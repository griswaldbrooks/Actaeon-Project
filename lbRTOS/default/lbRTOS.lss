
lbRTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000c6  00800200  00005cf2  00005d86  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00005cf2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000011fa  008002c6  008002c6  00005e4c  2**0
                  ALLOC
  3 .debug_aranges 000001a0  00000000  00000000  00005e4c  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000018a1  00000000  00000000  00005fec  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00005aa1  00000000  00000000  0000788d  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001764  00000000  00000000  0000d32e  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00004937  00000000  00000000  0000ea92  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000011f0  00000000  00000000  000133cc  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000024ad  00000000  00000000  000145bc  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00002a2f  00000000  00000000  00016a69  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000030  00000000  00000000  00019498  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 e6 00 	jmp	0x1cc	; 0x1cc <__ctors_end>
       4:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
       8:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
       c:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      10:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      14:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      18:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      1c:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      20:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      24:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      28:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      2c:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      30:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      34:	0c 94 7a 1d 	jmp	0x3af4	; 0x3af4 <__vector_13>
      38:	0c 94 a7 1d 	jmp	0x3b4e	; 0x3b4e <__vector_14>
      3c:	0c 94 99 1b 	jmp	0x3732	; 0x3732 <__vector_15>
      40:	0c 94 f3 1c 	jmp	0x39e6	; 0x39e6 <__vector_16>
      44:	0c 94 c7 16 	jmp	0x2d8e	; 0x2d8e <__vector_17>
      48:	0c 94 20 1d 	jmp	0x3a40	; 0x3a40 <__vector_18>
      4c:	0c 94 4d 1d 	jmp	0x3a9a	; 0x3a9a <__vector_19>
      50:	0c 94 59 1b 	jmp	0x36b2	; 0x36b2 <__vector_20>
      54:	0c 94 99 1c 	jmp	0x3932	; 0x3932 <__vector_21>
      58:	0c 94 c6 1c 	jmp	0x398c	; 0x398c <__vector_22>
      5c:	0c 94 06 1b 	jmp	0x360c	; 0x360c <__vector_23>
      60:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      64:	0c 94 70 21 	jmp	0x42e0	; 0x42e0 <__vector_25>
      68:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      6c:	0c 94 cd 22 	jmp	0x459a	; 0x459a <__vector_27>
      70:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      74:	0c 94 87 25 	jmp	0x4b0e	; 0x4b0e <__vector_29>
      78:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      7c:	0c 94 d4 1d 	jmp	0x3ba8	; 0x3ba8 <__vector_31>
      80:	0c 94 01 1e 	jmp	0x3c02	; 0x3c02 <__vector_32>
      84:	0c 94 2e 1e 	jmp	0x3c5c	; 0x3c5c <__vector_33>
      88:	0c 94 5b 1e 	jmp	0x3cb6	; 0x3cb6 <__vector_34>
      8c:	0c 94 d9 1b 	jmp	0x37b2	; 0x37b2 <__vector_35>
      90:	0c 94 4b 21 	jmp	0x4296	; 0x4296 <__vector_36>
      94:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      98:	0c 94 a8 22 	jmp	0x4550	; 0x4550 <__vector_38>
      9c:	0c 94 a5 29 	jmp	0x534a	; 0x534a <__vector_39>
      a0:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      a4:	0c 94 88 1e 	jmp	0x3d10	; 0x3d10 <__vector_41>
      a8:	0c 94 b5 1e 	jmp	0x3d6a	; 0x3d6a <__vector_42>
      ac:	0c 94 e2 1e 	jmp	0x3dc4	; 0x3dc4 <__vector_43>
      b0:	0c 94 0f 1f 	jmp	0x3e1e	; 0x3e1e <__vector_44>
      b4:	0c 94 19 1c 	jmp	0x3832	; 0x3832 <__vector_45>
      b8:	0c 94 3c 1f 	jmp	0x3e78	; 0x3e78 <__vector_46>
      bc:	0c 94 69 1f 	jmp	0x3ed2	; 0x3ed2 <__vector_47>
      c0:	0c 94 96 1f 	jmp	0x3f2c	; 0x3f2c <__vector_48>
      c4:	0c 94 c3 1f 	jmp	0x3f86	; 0x3f86 <__vector_49>
      c8:	0c 94 59 1c 	jmp	0x38b2	; 0x38b2 <__vector_50>
      cc:	0c 94 26 21 	jmp	0x424c	; 0x424c <__vector_51>
      d0:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      d4:	0c 94 83 22 	jmp	0x4506	; 0x4506 <__vector_53>
      d8:	0c 94 01 21 	jmp	0x4202	; 0x4202 <__vector_54>
      dc:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      e0:	0c 94 5e 22 	jmp	0x44bc	; 0x44bc <__vector_56>
      e4:	08 4a       	sbci	r16, 0xA8	; 168
      e6:	d7 3b       	cpi	r29, 0xB7	; 183
      e8:	3b ce       	rjmp	.-906    	; 0xfffffd60 <__eeprom_end+0xff7efd60>
      ea:	01 6e       	ori	r16, 0xE1	; 225
      ec:	84 bc       	out	0x24, r8	; 36
      ee:	bf fd       	.word	0xfdbf	; ????
      f0:	c1 2f       	mov	r28, r17
      f2:	3d 6c       	ori	r19, 0xCD	; 205
      f4:	74 31       	cpi	r23, 0x14	; 20
      f6:	9a bd       	out	0x2a, r25	; 42
      f8:	56 83       	std	Z+6, r21	; 0x06
      fa:	3d da       	rcall	.-2950   	; 0xfffff576 <__eeprom_end+0xff7ef576>
      fc:	3d 00       	.word	0x003d	; ????
      fe:	c7 7f       	andi	r28, 0xF7	; 247
     100:	11 be       	out	0x31, r1	; 49
     102:	d9 e4       	ldi	r29, 0x49	; 73
     104:	bb 4c       	sbci	r27, 0xCB	; 203
     106:	3e 91       	ld	r19, -X
     108:	6b aa       	std	Y+51, r6	; 0x33
     10a:	aa be       	out	0x3a, r10	; 58
     10c:	00 00       	nop
     10e:	00 80       	ld	r0, Z
     110:	3f 44       	sbci	r19, 0x4F	; 79

00000111 <__c.3354>:
     111:	44 45 41 54 48 0a 00                                DEATH..

00000118 <__c.3318>:
     118:	20 4f 6d 65 67 61 3a 20 00                           Omega: .

00000121 <__c.3316>:
     121:	52 65 63 65 69 76 65 64 20 56 65 6c 6f 63 69 74     Received Velocit
     131:	79 3a 20 00                                         y: .

00000135 <__c.3304>:
     135:	63 6d 64 5f 61 6e 67 6c 65 3a 20 00                 cmd_angle: .

00000141 <__c.3302>:
     141:	63 6d 64 5f 61 6e 67 6c 65 3a 20 00                 cmd_angle: .

0000014d <__c.3196>:
     14d:	0a 00                                               ..

0000014f <__c.3194>:
     14f:	25 64 00                                            %d.

00000152 <__c.3182>:
     152:	25 64 0a 00                                         %d..

00000156 <__c.3097>:
     156:	49 6e 69 74 69 61 6c 69 7a 61 74 69 6f 6e 20 43     Initialization C
     166:	6f 6d 70 6c 65 74 65 20 0d 0a 00                    omplete ...

00000171 <__c.3092>:
     171:	2e 00                                               ..

00000173 <__c.3090>:
     173:	0d 0a 53 79 73 74 65 6d 20 57 61 72 6d 65 64 20     ..System Warmed 
     183:	55 70 00                                            Up.

00000186 <__c.3045>:
     186:	57 52 0a 00                                         WR..

0000018a <__c.3014>:
     18a:	57 52 0a 00                                         WR..

0000018e <TimerPrescaleFactor>:
     18e:	00 00 01 00 08 00 40 00 00 01 00 04                 ......@.....

0000019a <Timer2PrescaleFactor>:
     19a:	00 00 01 00 08 00 20 00 40 00 80 00 00 01 00 04     ...... .@.......

000001aa <__c.1991>:
     1aa:	42 41 44 5f 76 65 63 74 20 63 61 6c 6c 65 64 21     BAD_vect called!
	...

000001bb <HexChars>:
     1bb:	30 31 32 33 34 35 36 37 38 39 41 42 43 44 45 46     0123456789ABCDEF
	...

000001cc <__ctors_end>:
     1cc:	11 24       	eor	r1, r1
     1ce:	1f be       	out	0x3f, r1	; 63
     1d0:	cf ef       	ldi	r28, 0xFF	; 255
     1d2:	d1 e2       	ldi	r29, 0x21	; 33
     1d4:	de bf       	out	0x3e, r29	; 62
     1d6:	cd bf       	out	0x3d, r28	; 61

000001d8 <__do_copy_data>:
     1d8:	12 e0       	ldi	r17, 0x02	; 2
     1da:	a0 e0       	ldi	r26, 0x00	; 0
     1dc:	b2 e0       	ldi	r27, 0x02	; 2
     1de:	e2 ef       	ldi	r30, 0xF2	; 242
     1e0:	fc e5       	ldi	r31, 0x5C	; 92
     1e2:	02 c0       	rjmp	.+4      	; 0x1e8 <.do_copy_data_start>

000001e4 <.do_copy_data_loop>:
     1e4:	05 90       	lpm	r0, Z+
     1e6:	0d 92       	st	X+, r0

000001e8 <.do_copy_data_start>:
     1e8:	a6 3c       	cpi	r26, 0xC6	; 198
     1ea:	b1 07       	cpc	r27, r17
     1ec:	d9 f7       	brne	.-10     	; 0x1e4 <.do_copy_data_loop>

000001ee <__do_clear_bss>:
     1ee:	14 e1       	ldi	r17, 0x14	; 20
     1f0:	a6 ec       	ldi	r26, 0xC6	; 198
     1f2:	b2 e0       	ldi	r27, 0x02	; 2
     1f4:	01 c0       	rjmp	.+2      	; 0x1f8 <.do_clear_bss_start>

000001f6 <.do_clear_bss_loop>:
     1f6:	1d 92       	st	X+, r1

000001f8 <.do_clear_bss_start>:
     1f8:	a0 3c       	cpi	r26, 0xC0	; 192
     1fa:	b1 07       	cpc	r27, r17
     1fc:	e1 f7       	brne	.-8      	; 0x1f6 <.do_clear_bss_loop>
     1fe:	0e 94 a7 0c 	call	0x194e	; 0x194e <main>
     202:	0c 94 d1 2a 	jmp	0x55a2	; 0x55a2 <exit>

00000206 <__bad_interrupt>:
     206:	0c 94 f0 1f 	jmp	0x3fe0	; 0x3fe0 <__vector_default>

0000020a <PWM_Init_timer1_LED>:

//OC1B  pin B6 (attached to green LED)
void PWM_Init_timer1_LED(u08 bitRes)
{
	// enable timer2 as 8,9,10bit PWM
	if(bitRes == 9)
     20a:	89 30       	cpi	r24, 0x09	; 9
     20c:	49 f4       	brne	.+18     	; 0x220 <PWM_Init_timer1_LED+0x16>
	{	// 9bit mode
		sbi(TCCR1A,PWM11);
     20e:	80 91 80 00 	lds	r24, 0x0080
     212:	82 60       	ori	r24, 0x02	; 2
     214:	80 93 80 00 	sts	0x0080, r24
		cbi(TCCR1A,PWM10);
     218:	80 91 80 00 	lds	r24, 0x0080
     21c:	8e 7f       	andi	r24, 0xFE	; 254
     21e:	0e c0       	rjmp	.+28     	; 0x23c <PWM_Init_timer1_LED+0x32>
	}
	else if( bitRes == 10 )
     220:	8a 30       	cpi	r24, 0x0A	; 10
     222:	21 f4       	brne	.+8      	; 0x22c <PWM_Init_timer1_LED+0x22>
	{	// 10bit mode
		sbi(TCCR1A,PWM11);
     224:	80 91 80 00 	lds	r24, 0x0080
     228:	82 60       	ori	r24, 0x02	; 2
     22a:	03 c0       	rjmp	.+6      	; 0x232 <PWM_Init_timer1_LED+0x28>
		sbi(TCCR1A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR1A,PWM11);
     22c:	80 91 80 00 	lds	r24, 0x0080
     230:	8d 7f       	andi	r24, 0xFD	; 253
     232:	80 93 80 00 	sts	0x0080, r24
		sbi(TCCR1A,PWM10);
     236:	80 91 80 00 	lds	r24, 0x0080
     23a:	81 60       	ori	r24, 0x01	; 1
     23c:	80 93 80 00 	sts	0x0080, r24
	}
	// clear output compare values
	OCR1B = 0;
     240:	10 92 8b 00 	sts	0x008B, r1
     244:	10 92 8a 00 	sts	0x008A, r1
}
     248:	08 95       	ret

0000024a <PWM_Init_timer2_H6>:
//pin H6, timer2
void PWM_Init_timer2_H6(u08 bitRes)
{
	// enable timer2 as 8,9,10bit PWM
	if(bitRes == 9)
     24a:	89 30       	cpi	r24, 0x09	; 9
     24c:	49 f4       	brne	.+18     	; 0x260 <PWM_Init_timer2_H6+0x16>
	{	// 9bit mode
		sbi(TCCR2A,PWM11);
     24e:	80 91 b0 00 	lds	r24, 0x00B0
     252:	82 60       	ori	r24, 0x02	; 2
     254:	80 93 b0 00 	sts	0x00B0, r24
		cbi(TCCR2A,PWM10);
     258:	80 91 b0 00 	lds	r24, 0x00B0
     25c:	8e 7f       	andi	r24, 0xFE	; 254
     25e:	0e c0       	rjmp	.+28     	; 0x27c <PWM_Init_timer2_H6+0x32>
	}
	else if( bitRes == 10 )
     260:	8a 30       	cpi	r24, 0x0A	; 10
     262:	21 f4       	brne	.+8      	; 0x26c <PWM_Init_timer2_H6+0x22>
	{	// 10bit mode
		sbi(TCCR2A,PWM11);
     264:	80 91 b0 00 	lds	r24, 0x00B0
     268:	82 60       	ori	r24, 0x02	; 2
     26a:	03 c0       	rjmp	.+6      	; 0x272 <PWM_Init_timer2_H6+0x28>
		sbi(TCCR2A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR2A,PWM11);
     26c:	80 91 b0 00 	lds	r24, 0x00B0
     270:	8d 7f       	andi	r24, 0xFD	; 253
     272:	80 93 b0 00 	sts	0x00B0, r24
		sbi(TCCR2A,PWM10);
     276:	80 91 b0 00 	lds	r24, 0x00B0
     27a:	81 60       	ori	r24, 0x01	; 1
     27c:	80 93 b0 00 	sts	0x00B0, r24
	}
	// clear output compare values
	OCR2B = 0;
     280:	10 92 b4 00 	sts	0x00B4, r1
}
     284:	08 95       	ret

00000286 <PWM_Init_timer3_E3>:
//pin E3
void PWM_Init_timer3_E3(u08 bitRes)
{
	// enable timer3 as 8,9,10bit PWM
	if(bitRes == 9)
     286:	89 30       	cpi	r24, 0x09	; 9
     288:	49 f4       	brne	.+18     	; 0x29c <PWM_Init_timer3_E3+0x16>
	{	// 9bit mode
		sbi(TCCR3A,PWM11);
     28a:	80 91 90 00 	lds	r24, 0x0090
     28e:	82 60       	ori	r24, 0x02	; 2
     290:	80 93 90 00 	sts	0x0090, r24
		cbi(TCCR3A,PWM10);
     294:	80 91 90 00 	lds	r24, 0x0090
     298:	8e 7f       	andi	r24, 0xFE	; 254
     29a:	0e c0       	rjmp	.+28     	; 0x2b8 <PWM_Init_timer3_E3+0x32>
	}
	else if( bitRes == 10 )
     29c:	8a 30       	cpi	r24, 0x0A	; 10
     29e:	21 f4       	brne	.+8      	; 0x2a8 <PWM_Init_timer3_E3+0x22>
	{	// 10bit mode
		sbi(TCCR3A,PWM11);
     2a0:	80 91 90 00 	lds	r24, 0x0090
     2a4:	82 60       	ori	r24, 0x02	; 2
     2a6:	03 c0       	rjmp	.+6      	; 0x2ae <PWM_Init_timer3_E3+0x28>
		sbi(TCCR3A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR3A,PWM11);
     2a8:	80 91 90 00 	lds	r24, 0x0090
     2ac:	8d 7f       	andi	r24, 0xFD	; 253
     2ae:	80 93 90 00 	sts	0x0090, r24
		sbi(TCCR3A,PWM10);
     2b2:	80 91 90 00 	lds	r24, 0x0090
     2b6:	81 60       	ori	r24, 0x01	; 1
     2b8:	80 93 90 00 	sts	0x0090, r24
	}
	// clear output compare values
	OCR3A = 0;
     2bc:	10 92 99 00 	sts	0x0099, r1
     2c0:	10 92 98 00 	sts	0x0098, r1
	//timer3PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     2c4:	08 95       	ret

000002c6 <PWM_Init_timer3_E4>:
//pin E4
void PWM_Init_timer3_E4(u08 bitRes)
{
	// enable timer3 as 8,9,10bit PWM
	if(bitRes == 9)
     2c6:	89 30       	cpi	r24, 0x09	; 9
     2c8:	49 f4       	brne	.+18     	; 0x2dc <PWM_Init_timer3_E4+0x16>
	{	// 9bit mode
		sbi(TCCR3B,PWM11);
     2ca:	80 91 91 00 	lds	r24, 0x0091
     2ce:	82 60       	ori	r24, 0x02	; 2
     2d0:	80 93 91 00 	sts	0x0091, r24
		cbi(TCCR3B,PWM10);
     2d4:	80 91 91 00 	lds	r24, 0x0091
     2d8:	8e 7f       	andi	r24, 0xFE	; 254
     2da:	0e c0       	rjmp	.+28     	; 0x2f8 <PWM_Init_timer3_E4+0x32>
	}
	else if( bitRes == 10 )
     2dc:	8a 30       	cpi	r24, 0x0A	; 10
     2de:	21 f4       	brne	.+8      	; 0x2e8 <PWM_Init_timer3_E4+0x22>
	{	// 10bit mode
		sbi(TCCR3B,PWM11);
     2e0:	80 91 91 00 	lds	r24, 0x0091
     2e4:	82 60       	ori	r24, 0x02	; 2
     2e6:	03 c0       	rjmp	.+6      	; 0x2ee <PWM_Init_timer3_E4+0x28>
		sbi(TCCR3B,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR3B,PWM11);
     2e8:	80 91 91 00 	lds	r24, 0x0091
     2ec:	8d 7f       	andi	r24, 0xFD	; 253
     2ee:	80 93 91 00 	sts	0x0091, r24
		sbi(TCCR3B,PWM10);
     2f2:	80 91 91 00 	lds	r24, 0x0091
     2f6:	81 60       	ori	r24, 0x01	; 1
     2f8:	80 93 91 00 	sts	0x0091, r24
	}
	// clear output compare values
	OCR3B = 0;
     2fc:	10 92 9b 00 	sts	0x009B, r1
     300:	10 92 9a 00 	sts	0x009A, r1
	//timer3PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     304:	08 95       	ret

00000306 <PWM_Init_timer3_E5>:
//pin E5
void PWM_Init_timer3_E5(u08 bitRes)
{
	// enable timer3 as 8,9,10bit PWM
	if(bitRes == 9)
     306:	89 30       	cpi	r24, 0x09	; 9
     308:	49 f4       	brne	.+18     	; 0x31c <PWM_Init_timer3_E5+0x16>
	{	// 9bit mode
		sbi(TCCR3C,PWM11);
     30a:	80 91 92 00 	lds	r24, 0x0092
     30e:	82 60       	ori	r24, 0x02	; 2
     310:	80 93 92 00 	sts	0x0092, r24
		cbi(TCCR3C,PWM10);
     314:	80 91 92 00 	lds	r24, 0x0092
     318:	8e 7f       	andi	r24, 0xFE	; 254
     31a:	0e c0       	rjmp	.+28     	; 0x338 <PWM_Init_timer3_E5+0x32>
	}
	else if( bitRes == 10 )
     31c:	8a 30       	cpi	r24, 0x0A	; 10
     31e:	21 f4       	brne	.+8      	; 0x328 <PWM_Init_timer3_E5+0x22>
	{	// 10bit mode
		sbi(TCCR3C,PWM11);
     320:	80 91 92 00 	lds	r24, 0x0092
     324:	82 60       	ori	r24, 0x02	; 2
     326:	03 c0       	rjmp	.+6      	; 0x32e <PWM_Init_timer3_E5+0x28>
		sbi(TCCR3C,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR3C,PWM11);
     328:	80 91 92 00 	lds	r24, 0x0092
     32c:	8d 7f       	andi	r24, 0xFD	; 253
     32e:	80 93 92 00 	sts	0x0092, r24
		sbi(TCCR3C,PWM10);
     332:	80 91 92 00 	lds	r24, 0x0092
     336:	81 60       	ori	r24, 0x01	; 1
     338:	80 93 92 00 	sts	0x0092, r24
	}
	// clear output compare values
	OCR3C = 0;
     33c:	10 92 9d 00 	sts	0x009D, r1
     340:	10 92 9c 00 	sts	0x009C, r1
	//timer3PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     344:	08 95       	ret

00000346 <PWM_Init_timer4_H3>:
//pin H3, timer4
void PWM_Init_timer4_H3(u08 bitRes)
{
	// enable timer4 as 8,9,10bit PWM
	if(bitRes == 9)
     346:	89 30       	cpi	r24, 0x09	; 9
     348:	49 f4       	brne	.+18     	; 0x35c <PWM_Init_timer4_H3+0x16>
	{	// 9bit mode
		sbi(TCCR4A,PWM11);
     34a:	80 91 a0 00 	lds	r24, 0x00A0
     34e:	82 60       	ori	r24, 0x02	; 2
     350:	80 93 a0 00 	sts	0x00A0, r24
		cbi(TCCR4A,PWM10);
     354:	80 91 a0 00 	lds	r24, 0x00A0
     358:	8e 7f       	andi	r24, 0xFE	; 254
     35a:	0e c0       	rjmp	.+28     	; 0x378 <PWM_Init_timer4_H3+0x32>
	}
	else if( bitRes == 10 )
     35c:	8a 30       	cpi	r24, 0x0A	; 10
     35e:	21 f4       	brne	.+8      	; 0x368 <PWM_Init_timer4_H3+0x22>
	{	// 10bit mode
		sbi(TCCR4A,PWM11);
     360:	80 91 a0 00 	lds	r24, 0x00A0
     364:	82 60       	ori	r24, 0x02	; 2
     366:	03 c0       	rjmp	.+6      	; 0x36e <PWM_Init_timer4_H3+0x28>
		sbi(TCCR4A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR4A,PWM11);
     368:	80 91 a0 00 	lds	r24, 0x00A0
     36c:	8d 7f       	andi	r24, 0xFD	; 253
     36e:	80 93 a0 00 	sts	0x00A0, r24
		sbi(TCCR4A,PWM10);
     372:	80 91 a0 00 	lds	r24, 0x00A0
     376:	81 60       	ori	r24, 0x01	; 1
     378:	80 93 a0 00 	sts	0x00A0, r24
	}
	// clear output compare values
	OCR4A = 0;
     37c:	10 92 a9 00 	sts	0x00A9, r1
     380:	10 92 a8 00 	sts	0x00A8, r1
	//timer4PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     384:	08 95       	ret

00000386 <PWM_Init_timer4_H4>:
//pin H4, timer4
void PWM_Init_timer4_H4(u08 bitRes)
{
	// enable timer4 as 8,9,10bit PWM
	if(bitRes == 9)
     386:	89 30       	cpi	r24, 0x09	; 9
     388:	49 f4       	brne	.+18     	; 0x39c <PWM_Init_timer4_H4+0x16>
	{	// 9bit mode
		sbi(TCCR4B,PWM11);
     38a:	80 91 a1 00 	lds	r24, 0x00A1
     38e:	82 60       	ori	r24, 0x02	; 2
     390:	80 93 a1 00 	sts	0x00A1, r24
		cbi(TCCR4B,PWM10);
     394:	80 91 a1 00 	lds	r24, 0x00A1
     398:	8e 7f       	andi	r24, 0xFE	; 254
     39a:	0e c0       	rjmp	.+28     	; 0x3b8 <PWM_Init_timer4_H4+0x32>
	}
	else if( bitRes == 10 )
     39c:	8a 30       	cpi	r24, 0x0A	; 10
     39e:	21 f4       	brne	.+8      	; 0x3a8 <PWM_Init_timer4_H4+0x22>
	{	// 10bit mode
		sbi(TCCR4B,PWM11);
     3a0:	80 91 a1 00 	lds	r24, 0x00A1
     3a4:	82 60       	ori	r24, 0x02	; 2
     3a6:	03 c0       	rjmp	.+6      	; 0x3ae <PWM_Init_timer4_H4+0x28>
		sbi(TCCR4B,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR4B,PWM11);
     3a8:	80 91 a1 00 	lds	r24, 0x00A1
     3ac:	8d 7f       	andi	r24, 0xFD	; 253
     3ae:	80 93 a1 00 	sts	0x00A1, r24
		sbi(TCCR4B,PWM10);
     3b2:	80 91 a1 00 	lds	r24, 0x00A1
     3b6:	81 60       	ori	r24, 0x01	; 1
     3b8:	80 93 a1 00 	sts	0x00A1, r24
	}
	// clear output compare values
	OCR4B = 0;
     3bc:	10 92 ab 00 	sts	0x00AB, r1
     3c0:	10 92 aa 00 	sts	0x00AA, r1
	//timer4PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     3c4:	08 95       	ret

000003c6 <PWM_Init_timer4_H5>:
//pin H5, timer4
void PWM_Init_timer4_H5(u08 bitRes)
{
	// enable timer4 as 8,9,10bit PWM
	if(bitRes == 9)
     3c6:	89 30       	cpi	r24, 0x09	; 9
     3c8:	49 f4       	brne	.+18     	; 0x3dc <PWM_Init_timer4_H5+0x16>
	{	// 9bit mode
		sbi(TCCR4A,PWM11);
     3ca:	80 91 a0 00 	lds	r24, 0x00A0
     3ce:	82 60       	ori	r24, 0x02	; 2
     3d0:	80 93 a0 00 	sts	0x00A0, r24
		cbi(TCCR4A,PWM10);
     3d4:	80 91 a0 00 	lds	r24, 0x00A0
     3d8:	8e 7f       	andi	r24, 0xFE	; 254
     3da:	0e c0       	rjmp	.+28     	; 0x3f8 <PWM_Init_timer4_H5+0x32>
	}
	else if( bitRes == 10 )
     3dc:	8a 30       	cpi	r24, 0x0A	; 10
     3de:	21 f4       	brne	.+8      	; 0x3e8 <PWM_Init_timer4_H5+0x22>
	{	// 10bit mode
		sbi(TCCR4A,PWM11);
     3e0:	80 91 a0 00 	lds	r24, 0x00A0
     3e4:	82 60       	ori	r24, 0x02	; 2
     3e6:	03 c0       	rjmp	.+6      	; 0x3ee <PWM_Init_timer4_H5+0x28>
		sbi(TCCR4A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR4A,PWM11);
     3e8:	80 91 a0 00 	lds	r24, 0x00A0
     3ec:	8d 7f       	andi	r24, 0xFD	; 253
     3ee:	80 93 a0 00 	sts	0x00A0, r24
		sbi(TCCR4A,PWM10);
     3f2:	80 91 a0 00 	lds	r24, 0x00A0
     3f6:	81 60       	ori	r24, 0x01	; 1
     3f8:	80 93 a0 00 	sts	0x00A0, r24
	}
	// clear output compare values
	OCR4C = 0;
     3fc:	10 92 ad 00 	sts	0x00AD, r1
     400:	10 92 ac 00 	sts	0x00AC, r1
	//timer4PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     404:	08 95       	ret

00000406 <timer1PWMInitICR>:
// include support for arbitrary top-count PWM
// on new AVR processors that support it
void timer1PWMInitICR(u16 topcount)
{
	// set PWM mode with ICR top-count
	cbi(TCCR1A,WGM10);
     406:	e0 e8       	ldi	r30, 0x80	; 128
     408:	f0 e0       	ldi	r31, 0x00	; 0
     40a:	20 81       	ld	r18, Z
     40c:	2e 7f       	andi	r18, 0xFE	; 254
     40e:	20 83       	st	Z, r18
	sbi(TCCR1A,WGM11);
     410:	20 81       	ld	r18, Z
     412:	22 60       	ori	r18, 0x02	; 2
     414:	20 83       	st	Z, r18
	sbi(TCCR1B,WGM12);
     416:	e1 e8       	ldi	r30, 0x81	; 129
     418:	f0 e0       	ldi	r31, 0x00	; 0
     41a:	20 81       	ld	r18, Z
     41c:	28 60       	ori	r18, 0x08	; 8
     41e:	20 83       	st	Z, r18
	sbi(TCCR1B,WGM13);
     420:	20 81       	ld	r18, Z
     422:	20 61       	ori	r18, 0x10	; 16
     424:	20 83       	st	Z, r18
	
	// set top count value
	ICR1 = topcount;
     426:	90 93 87 00 	sts	0x0087, r25
     42a:	80 93 86 00 	sts	0x0086, r24
	
	// clear output compare values
	OCR1A = 0;
     42e:	10 92 89 00 	sts	0x0089, r1
     432:	10 92 88 00 	sts	0x0088, r1
	OCR1B = 0;
     436:	10 92 8b 00 	sts	0x008B, r1
     43a:	10 92 8a 00 	sts	0x008A, r1
	OCR1C = 0;
     43e:	10 92 8d 00 	sts	0x008D, r1
     442:	10 92 8c 00 	sts	0x008C, r1
}
     446:	08 95       	ret

00000448 <timer3PWMInitICR>:
void timer3PWMInitICR(u16 topcount)
{
	// set PWM mode with ICR top-count
	cbi(TCCR3A,WGM10);
     448:	e0 e9       	ldi	r30, 0x90	; 144
     44a:	f0 e0       	ldi	r31, 0x00	; 0
     44c:	20 81       	ld	r18, Z
     44e:	2e 7f       	andi	r18, 0xFE	; 254
     450:	20 83       	st	Z, r18
	sbi(TCCR3A,WGM11);
     452:	20 81       	ld	r18, Z
     454:	22 60       	ori	r18, 0x02	; 2
     456:	20 83       	st	Z, r18
	sbi(TCCR3B,WGM12);
     458:	e1 e9       	ldi	r30, 0x91	; 145
     45a:	f0 e0       	ldi	r31, 0x00	; 0
     45c:	20 81       	ld	r18, Z
     45e:	28 60       	ori	r18, 0x08	; 8
     460:	20 83       	st	Z, r18
	sbi(TCCR3B,WGM13);
     462:	20 81       	ld	r18, Z
     464:	20 61       	ori	r18, 0x10	; 16
     466:	20 83       	st	Z, r18
	
	// set top count value
	ICR3 = topcount;
     468:	90 93 97 00 	sts	0x0097, r25
     46c:	80 93 96 00 	sts	0x0096, r24
	
	// clear output compare values
	OCR3A = 0;
     470:	10 92 99 00 	sts	0x0099, r1
     474:	10 92 98 00 	sts	0x0098, r1
	OCR3B = 0;
     478:	10 92 9b 00 	sts	0x009B, r1
     47c:	10 92 9a 00 	sts	0x009A, r1
	OCR3C = 0;
     480:	10 92 9d 00 	sts	0x009D, r1
     484:	10 92 9c 00 	sts	0x009C, r1
}
     488:	08 95       	ret

0000048a <timer4PWMInitICR>:
void timer4PWMInitICR(u16 topcount)
{
	// set PWM mode with ICR top-count
	cbi(TCCR4A,WGM10);
     48a:	e0 ea       	ldi	r30, 0xA0	; 160
     48c:	f0 e0       	ldi	r31, 0x00	; 0
     48e:	20 81       	ld	r18, Z
     490:	2e 7f       	andi	r18, 0xFE	; 254
     492:	20 83       	st	Z, r18
	sbi(TCCR4A,WGM11);
     494:	20 81       	ld	r18, Z
     496:	22 60       	ori	r18, 0x02	; 2
     498:	20 83       	st	Z, r18
	sbi(TCCR4B,WGM12);
     49a:	e1 ea       	ldi	r30, 0xA1	; 161
     49c:	f0 e0       	ldi	r31, 0x00	; 0
     49e:	20 81       	ld	r18, Z
     4a0:	28 60       	ori	r18, 0x08	; 8
     4a2:	20 83       	st	Z, r18
	sbi(TCCR4B,WGM13);
     4a4:	20 81       	ld	r18, Z
     4a6:	20 61       	ori	r18, 0x10	; 16
     4a8:	20 83       	st	Z, r18
	
	// set top count value
	ICR4 = topcount;
     4aa:	90 93 a7 00 	sts	0x00A7, r25
     4ae:	80 93 a6 00 	sts	0x00A6, r24
	
	// clear output compare values
	OCR4A = 0;
     4b2:	10 92 a9 00 	sts	0x00A9, r1
     4b6:	10 92 a8 00 	sts	0x00A8, r1
	OCR4B = 0;
     4ba:	10 92 ab 00 	sts	0x00AB, r1
     4be:	10 92 aa 00 	sts	0x00AA, r1
	OCR4C = 0;
     4c2:	10 92 ad 00 	sts	0x00AD, r1
     4c6:	10 92 ac 00 	sts	0x00AC, r1
}
     4ca:	08 95       	ret

000004cc <PWM_timer1_On_LED>:
#endif

//on commands
void PWM_timer1_On_LED(void)
{
	sbi(TCCR1A,COM1B1);
     4cc:	e0 e8       	ldi	r30, 0x80	; 128
     4ce:	f0 e0       	ldi	r31, 0x00	; 0
     4d0:	80 81       	ld	r24, Z
     4d2:	80 62       	ori	r24, 0x20	; 32
     4d4:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B0);
     4d6:	80 81       	ld	r24, Z
     4d8:	8f 7e       	andi	r24, 0xEF	; 239
     4da:	80 83       	st	Z, r24
}
     4dc:	08 95       	ret

000004de <PWM_timer2_On_H6>:
void PWM_timer2_On_H6(void)
{
	sbi(TCCR2A,COM2B1);
     4de:	e0 eb       	ldi	r30, 0xB0	; 176
     4e0:	f0 e0       	ldi	r31, 0x00	; 0
     4e2:	80 81       	ld	r24, Z
     4e4:	80 62       	ori	r24, 0x20	; 32
     4e6:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B0);
     4e8:	80 81       	ld	r24, Z
     4ea:	8f 7e       	andi	r24, 0xEF	; 239
     4ec:	80 83       	st	Z, r24
}
     4ee:	08 95       	ret

000004f0 <PWM_timer3_On_E3>:
void PWM_timer3_On_E3(void)
{
	sbi(TCCR3A,COM3A1);
     4f0:	e0 e9       	ldi	r30, 0x90	; 144
     4f2:	f0 e0       	ldi	r31, 0x00	; 0
     4f4:	80 81       	ld	r24, Z
     4f6:	80 68       	ori	r24, 0x80	; 128
     4f8:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3A0);
     4fa:	80 81       	ld	r24, Z
     4fc:	8f 7b       	andi	r24, 0xBF	; 191
     4fe:	80 83       	st	Z, r24
}
     500:	08 95       	ret

00000502 <PWM_timer3_On_E4>:
void PWM_timer3_On_E4(void)
{
	sbi(TCCR3A,COM3B1);
     502:	e0 e9       	ldi	r30, 0x90	; 144
     504:	f0 e0       	ldi	r31, 0x00	; 0
     506:	80 81       	ld	r24, Z
     508:	80 62       	ori	r24, 0x20	; 32
     50a:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3B0);
     50c:	80 81       	ld	r24, Z
     50e:	8f 7e       	andi	r24, 0xEF	; 239
     510:	80 83       	st	Z, r24
}
     512:	08 95       	ret

00000514 <PWM_timer3_On_E5>:
void PWM_timer3_On_E5(void)
{
	sbi(TCCR3A,COM3C1);
     514:	e0 e9       	ldi	r30, 0x90	; 144
     516:	f0 e0       	ldi	r31, 0x00	; 0
     518:	80 81       	ld	r24, Z
     51a:	88 60       	ori	r24, 0x08	; 8
     51c:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C0);
     51e:	80 81       	ld	r24, Z
     520:	8b 7f       	andi	r24, 0xFB	; 251
     522:	80 83       	st	Z, r24
}
     524:	08 95       	ret

00000526 <PWM_timer4_On_H3>:
void PWM_timer4_On_H3(void)
{
	sbi(TCCR4A,COM4A1);
     526:	e0 ea       	ldi	r30, 0xA0	; 160
     528:	f0 e0       	ldi	r31, 0x00	; 0
     52a:	80 81       	ld	r24, Z
     52c:	80 68       	ori	r24, 0x80	; 128
     52e:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4A0);
     530:	80 81       	ld	r24, Z
     532:	8f 7b       	andi	r24, 0xBF	; 191
     534:	80 83       	st	Z, r24
}
     536:	08 95       	ret

00000538 <PWM_timer4_On_H4>:
void PWM_timer4_On_H4(void)
{
	sbi(TCCR4A,COM4B1);
     538:	e0 ea       	ldi	r30, 0xA0	; 160
     53a:	f0 e0       	ldi	r31, 0x00	; 0
     53c:	80 81       	ld	r24, Z
     53e:	80 62       	ori	r24, 0x20	; 32
     540:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4B0);
     542:	80 81       	ld	r24, Z
     544:	8f 7e       	andi	r24, 0xEF	; 239
     546:	80 83       	st	Z, r24
}
     548:	08 95       	ret

0000054a <PWM_timer4_On_H5>:
void PWM_timer4_On_H5(void)
{
	sbi(TCCR4A,COM4C1);
     54a:	e0 ea       	ldi	r30, 0xA0	; 160
     54c:	f0 e0       	ldi	r31, 0x00	; 0
     54e:	80 81       	ld	r24, Z
     550:	88 60       	ori	r24, 0x08	; 8
     552:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4C0);
     554:	80 81       	ld	r24, Z
     556:	8b 7f       	andi	r24, 0xFB	; 251
     558:	80 83       	st	Z, r24
}
     55a:	08 95       	ret

0000055c <PWM_timer1_Off_LED>:

//off commands
void PWM_timer1_Off_LED(void)
{
	cbi(TCCR1A,COM1B1);
     55c:	e0 e8       	ldi	r30, 0x80	; 128
     55e:	f0 e0       	ldi	r31, 0x00	; 0
     560:	80 81       	ld	r24, Z
     562:	8f 7d       	andi	r24, 0xDF	; 223
     564:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B0);
     566:	80 81       	ld	r24, Z
     568:	8f 7e       	andi	r24, 0xEF	; 239
     56a:	80 83       	st	Z, r24
}
     56c:	08 95       	ret

0000056e <PWM_timer2_Off_H6>:
void PWM_timer2_Off_H6(void)
{
	cbi(TCCR2A,COM2B1);
     56e:	e0 eb       	ldi	r30, 0xB0	; 176
     570:	f0 e0       	ldi	r31, 0x00	; 0
     572:	80 81       	ld	r24, Z
     574:	8f 7d       	andi	r24, 0xDF	; 223
     576:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B0);
     578:	80 81       	ld	r24, Z
     57a:	8f 7e       	andi	r24, 0xEF	; 239
     57c:	80 83       	st	Z, r24
}
     57e:	08 95       	ret

00000580 <PWM_timer3_Off_E3>:
void PWM_timer3_Off_E3(void)
{
	cbi(TCCR3A,COM3A1);
     580:	e0 e9       	ldi	r30, 0x90	; 144
     582:	f0 e0       	ldi	r31, 0x00	; 0
     584:	80 81       	ld	r24, Z
     586:	8f 77       	andi	r24, 0x7F	; 127
     588:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3A0);
     58a:	80 81       	ld	r24, Z
     58c:	8f 7b       	andi	r24, 0xBF	; 191
     58e:	80 83       	st	Z, r24
}
     590:	08 95       	ret

00000592 <PWM_timer3_Off_E4>:
void PWM_timer3_Off_E4(void)
{
	cbi(TCCR3A,COM3B1);
     592:	e0 e9       	ldi	r30, 0x90	; 144
     594:	f0 e0       	ldi	r31, 0x00	; 0
     596:	80 81       	ld	r24, Z
     598:	8f 7d       	andi	r24, 0xDF	; 223
     59a:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3B0);
     59c:	80 81       	ld	r24, Z
     59e:	8f 7e       	andi	r24, 0xEF	; 239
     5a0:	80 83       	st	Z, r24
}
     5a2:	08 95       	ret

000005a4 <PWM_timer3_Off_E5>:
void PWM_timer3_Off_E5(void)
{
	cbi(TCCR3A,COM3C1);
     5a4:	e0 e9       	ldi	r30, 0x90	; 144
     5a6:	f0 e0       	ldi	r31, 0x00	; 0
     5a8:	80 81       	ld	r24, Z
     5aa:	87 7f       	andi	r24, 0xF7	; 247
     5ac:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C0);
     5ae:	80 81       	ld	r24, Z
     5b0:	8b 7f       	andi	r24, 0xFB	; 251
     5b2:	80 83       	st	Z, r24
}
     5b4:	08 95       	ret

000005b6 <PWM_timer4_Off_H3>:
void PWM_timer4_Off_H3(void)
{
	cbi(TCCR4A,COM4A1);
     5b6:	e0 ea       	ldi	r30, 0xA0	; 160
     5b8:	f0 e0       	ldi	r31, 0x00	; 0
     5ba:	80 81       	ld	r24, Z
     5bc:	8f 77       	andi	r24, 0x7F	; 127
     5be:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4A0);
     5c0:	80 81       	ld	r24, Z
     5c2:	8f 7b       	andi	r24, 0xBF	; 191
     5c4:	80 83       	st	Z, r24
}
     5c6:	08 95       	ret

000005c8 <PWM_timer4_Off_H4>:
void PWM_timer4_Off_H4(void)
{
	cbi(TCCR4A,COM4B1);
     5c8:	e0 ea       	ldi	r30, 0xA0	; 160
     5ca:	f0 e0       	ldi	r31, 0x00	; 0
     5cc:	80 81       	ld	r24, Z
     5ce:	8f 7d       	andi	r24, 0xDF	; 223
     5d0:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4B0);
     5d2:	80 81       	ld	r24, Z
     5d4:	8f 7e       	andi	r24, 0xEF	; 239
     5d6:	80 83       	st	Z, r24
}
     5d8:	08 95       	ret

000005da <PWM_timer4_Off_H5>:
void PWM_timer4_Off_H5(void)
{
	cbi(TCCR4A,COM4C1);
     5da:	e0 ea       	ldi	r30, 0xA0	; 160
     5dc:	f0 e0       	ldi	r31, 0x00	; 0
     5de:	80 81       	ld	r24, Z
     5e0:	87 7f       	andi	r24, 0xF7	; 247
     5e2:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4C0);
     5e4:	80 81       	ld	r24, Z
     5e6:	8b 7f       	andi	r24, 0xFB	; 251
     5e8:	80 83       	st	Z, r24
}
     5ea:	08 95       	ret

000005ec <PWM_timer1_Off_All>:


void PWM_timer1_Off_All(void)
{
	cbi(TCCR1A,PWM11);
     5ec:	e0 e8       	ldi	r30, 0x80	; 128
     5ee:	f0 e0       	ldi	r31, 0x00	; 0
     5f0:	80 81       	ld	r24, Z
     5f2:	8d 7f       	andi	r24, 0xFD	; 253
     5f4:	80 83       	st	Z, r24
	cbi(TCCR1A,PWM10);
     5f6:	80 81       	ld	r24, Z
     5f8:	8e 7f       	andi	r24, 0xFE	; 254
     5fa:	80 83       	st	Z, r24
}

//off commands
void PWM_timer1_Off_LED(void)
{
	cbi(TCCR1A,COM1B1);
     5fc:	80 81       	ld	r24, Z
     5fe:	8f 7d       	andi	r24, 0xDF	; 223
     600:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B0);
     602:	80 81       	ld	r24, Z
     604:	8f 7e       	andi	r24, 0xEF	; 239
     606:	80 83       	st	Z, r24
	cbi(TCCR1A,PWM11);
	cbi(TCCR1A,PWM10);
	//timer2PWMAOff();
	PWM_timer1_Off_LED();
	//timer2PWMCOff();
}
     608:	08 95       	ret

0000060a <PWM_timer2_Off_All>:
void PWM_timer2_Off_All(void)
{
	cbi(TCCR2A,PWM11);
     60a:	e0 eb       	ldi	r30, 0xB0	; 176
     60c:	f0 e0       	ldi	r31, 0x00	; 0
     60e:	80 81       	ld	r24, Z
     610:	8d 7f       	andi	r24, 0xFD	; 253
     612:	80 83       	st	Z, r24
	cbi(TCCR2A,PWM10);
     614:	80 81       	ld	r24, Z
     616:	8e 7f       	andi	r24, 0xFE	; 254
     618:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B1);
	cbi(TCCR1A,COM1B0);
}
void PWM_timer2_Off_H6(void)
{
	cbi(TCCR2A,COM2B1);
     61a:	80 81       	ld	r24, Z
     61c:	8f 7d       	andi	r24, 0xDF	; 223
     61e:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B0);
     620:	80 81       	ld	r24, Z
     622:	8f 7e       	andi	r24, 0xEF	; 239
     624:	80 83       	st	Z, r24
	cbi(TCCR2A,PWM11);
	cbi(TCCR2A,PWM10);
	//timer2PWMAOff();
	PWM_timer2_Off_H6();
	//timer2PWMCOff();
}
     626:	08 95       	ret

00000628 <PWM_timer3_Off_All>:
void PWM_timer3_Off_All(void)
{
	cbi(TCCR3A,PWM11);
     628:	e0 e9       	ldi	r30, 0x90	; 144
     62a:	f0 e0       	ldi	r31, 0x00	; 0
     62c:	80 81       	ld	r24, Z
     62e:	8d 7f       	andi	r24, 0xFD	; 253
     630:	80 83       	st	Z, r24
	cbi(TCCR3A,PWM10);
     632:	80 81       	ld	r24, Z
     634:	8e 7f       	andi	r24, 0xFE	; 254
     636:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B1);
	cbi(TCCR2A,COM2B0);
}
void PWM_timer3_Off_E3(void)
{
	cbi(TCCR3A,COM3A1);
     638:	80 81       	ld	r24, Z
     63a:	8f 77       	andi	r24, 0x7F	; 127
     63c:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3A0);
     63e:	80 81       	ld	r24, Z
     640:	8f 7b       	andi	r24, 0xBF	; 191
     642:	80 83       	st	Z, r24
}
void PWM_timer3_Off_E4(void)
{
	cbi(TCCR3A,COM3B1);
     644:	80 81       	ld	r24, Z
     646:	8f 7d       	andi	r24, 0xDF	; 223
     648:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3B0);
     64a:	80 81       	ld	r24, Z
     64c:	8f 7e       	andi	r24, 0xEF	; 239
     64e:	80 83       	st	Z, r24
}
void PWM_timer3_Off_E5(void)
{
	cbi(TCCR3A,COM3C1);
     650:	80 81       	ld	r24, Z
     652:	87 7f       	andi	r24, 0xF7	; 247
     654:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C0);
     656:	80 81       	ld	r24, Z
     658:	8b 7f       	andi	r24, 0xFB	; 251
     65a:	80 83       	st	Z, r24
	//timer2PWMAOff();
	PWM_timer3_Off_E3();
	PWM_timer3_Off_E4();
	PWM_timer3_Off_E5();
	//timer2PWMCOff();
}
     65c:	08 95       	ret

0000065e <PWM_timer4_Off_All>:
void PWM_timer4_Off_All(void)
{
	cbi(TCCR4A,PWM11);
     65e:	e0 ea       	ldi	r30, 0xA0	; 160
     660:	f0 e0       	ldi	r31, 0x00	; 0
     662:	80 81       	ld	r24, Z
     664:	8d 7f       	andi	r24, 0xFD	; 253
     666:	80 83       	st	Z, r24
	cbi(TCCR4A,PWM10);
     668:	80 81       	ld	r24, Z
     66a:	8e 7f       	andi	r24, 0xFE	; 254
     66c:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C1);
	cbi(TCCR3A,COM3C0);
}
void PWM_timer4_Off_H3(void)
{
	cbi(TCCR4A,COM4A1);
     66e:	80 81       	ld	r24, Z
     670:	8f 77       	andi	r24, 0x7F	; 127
     672:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4A0);
     674:	80 81       	ld	r24, Z
     676:	8f 7b       	andi	r24, 0xBF	; 191
     678:	80 83       	st	Z, r24
}
void PWM_timer4_Off_H4(void)
{
	cbi(TCCR4A,COM4B1);
     67a:	80 81       	ld	r24, Z
     67c:	8f 7d       	andi	r24, 0xDF	; 223
     67e:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4B0);
     680:	80 81       	ld	r24, Z
     682:	8f 7e       	andi	r24, 0xEF	; 239
     684:	80 83       	st	Z, r24
}
void PWM_timer4_Off_H5(void)
{
	cbi(TCCR4A,COM4C1);
     686:	80 81       	ld	r24, Z
     688:	87 7f       	andi	r24, 0xF7	; 247
     68a:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4C0);
     68c:	80 81       	ld	r24, Z
     68e:	8b 7f       	andi	r24, 0xFB	; 251
     690:	80 83       	st	Z, r24
	//timer2PWMAOff();
	PWM_timer4_Off_H3();
	PWM_timer4_Off_H4();
	PWM_timer4_Off_H5();
	//timer2PWMCOff();
}
     692:	08 95       	ret

00000694 <PWM_timer1_Set_LED>:
// this PWM output is generated on OC2B pin
// NOTE:	pwmDuty should be in the range 0-255 for 8bit PWM
//			pwmDuty should be in the range 0-511 for 9bit PWM
//			pwmDuty should be in the range 0-1023 for 10bit PWM
void PWM_timer1_Set_LED(u16 pwmDuty)
	{OCR1B = pwmDuty;}
     694:	90 93 8b 00 	sts	0x008B, r25
     698:	80 93 8a 00 	sts	0x008A, r24
     69c:	08 95       	ret

0000069e <PWM_timer2_Set_H6>:
void PWM_timer2_Set_H6(u16 pwmDuty)
	{OCR2B = pwmDuty;}
     69e:	80 93 b4 00 	sts	0x00B4, r24
     6a2:	08 95       	ret

000006a4 <PWM_timer3_Set_E3>:
void PWM_timer3_Set_E3(u16 pwmDuty)
	{OCR3A = pwmDuty;}
     6a4:	90 93 99 00 	sts	0x0099, r25
     6a8:	80 93 98 00 	sts	0x0098, r24
     6ac:	08 95       	ret

000006ae <PWM_timer3_Set_E4>:
void PWM_timer3_Set_E4(u16 pwmDuty)
	{OCR3B = pwmDuty;}
     6ae:	90 93 9b 00 	sts	0x009B, r25
     6b2:	80 93 9a 00 	sts	0x009A, r24
     6b6:	08 95       	ret

000006b8 <PWM_timer3_Set_E5>:
void PWM_timer3_Set_E5(u16 pwmDuty)
	{OCR3C = pwmDuty;}
     6b8:	90 93 9d 00 	sts	0x009D, r25
     6bc:	80 93 9c 00 	sts	0x009C, r24
     6c0:	08 95       	ret

000006c2 <PWM_timer4_Set_H3>:
void PWM_timer4_Set_H3(u16 pwmDuty)
	{OCR4A = pwmDuty;}
     6c2:	90 93 a9 00 	sts	0x00A9, r25
     6c6:	80 93 a8 00 	sts	0x00A8, r24
     6ca:	08 95       	ret

000006cc <PWM_timer4_Set_H4>:
void PWM_timer4_Set_H4(u16 pwmDuty)
	{OCR4B = pwmDuty;}
     6cc:	90 93 ab 00 	sts	0x00AB, r25
     6d0:	80 93 aa 00 	sts	0x00AA, r24
     6d4:	08 95       	ret

000006d6 <PWM_timer4_Set_H5>:
void PWM_timer4_Set_H5(u16 pwmDuty)
	{OCR4C = pwmDuty;}
     6d6:	90 93 ad 00 	sts	0x00AD, r25
     6da:	80 93 ac 00 	sts	0x00AC, r24
     6de:	08 95       	ret

000006e0 <configure_ports>:
	//cbi(DDRG, PG5);  //set G5 as input pin

	//ANALOG PORTS
	//useful for sensors, SharpIR, photoresistors, etc.
	//analog ports can be configured as digital ports if desired
	DDRF = 0b00000000;  //configure all F ports for input				0x00
     6e0:	10 ba       	out	0x10, r1	; 16
	PORTF = 0b00000000; //make sure pull-up resistors are turned off	0x00
     6e2:	11 ba       	out	0x11, r1	; 17
	DDRK = 0b00000000;  //configure all K ports for input				0x00
     6e4:	10 92 07 01 	sts	0x0107, r1
	PORTK = 0b00000000; //make sure pull-up resistors are turned off	0x00
     6e8:	10 92 08 01 	sts	0x0108, r1

	//DIGITAL PORTS
	//useful for servos, PWM, LED's, UART, interrupts, timers
	DDRA = 0b11111111;  //configure ports for output
     6ec:	9f ef       	ldi	r25, 0xFF	; 255
     6ee:	91 b9       	out	0x01, r25	; 1
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	//PORTB reserved for programmer (use programmer pins if you know what you are doing)
	DDRB = _BV (PB6);	//PB6 is LED, hold low to turn it on
     6f0:	80 e4       	ldi	r24, 0x40	; 64
     6f2:	84 b9       	out	0x04, r24	; 4
	DDRC = 0b11111111;  //configure ports for output
     6f4:	97 b9       	out	0x07, r25	; 7
	//       ||||\______3: 
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 	
	sbi(PORTD, PD0); // SCL pull-up
     6f6:	58 9a       	sbi	0x0b, 0	; 11
	sbi(PORTD, PD1); // SDA pull-up
     6f8:	59 9a       	sbi	0x0b, 1	; 11
	DDRD = 0b11110011;  //configure ports for output
     6fa:	83 ef       	ldi	r24, 0xF3	; 243
     6fc:	8a b9       	out	0x0a, r24	; 10
	//       ||||\______3: serial TXD1, output -> 1
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: timer0
	DDRE = 0b11111110;  //configure ports for output
     6fe:	8e ef       	ldi	r24, 0xFE	; 254
     700:	8d b9       	out	0x0d, r24	; 13
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	//cbi(PORTG, PG5);  // disable pull-up resistor for Axon v1e and earlier
	sbi(PORTG, PG5);  // enable pull-up resistor for v1f and later
     702:	a5 9a       	sbi	0x14, 5	; 20
	cbi(DDRG, PG5);	//PG5 is for the button, make a digital input
     704:	9d 98       	cbi	0x13, 5	; 19
	//note that button actions are inverted between both versions!!!
	DDRH = 0b11111110;  //configure ports for output
     706:	80 93 01 01 	sts	0x0101, r24
	//       ||||\______3: 
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	DDRJ = 0b11111110;  //configure ports for output
     70a:	80 93 04 01 	sts	0x0104, r24
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	//PORTL has no headers
	};
     70e:	08 95       	ret

00000710 <delay_cycles>:
void delay_cycles(unsigned long int cycles)
	{
	cycles=cycles;//doubled frequency but too lazy to change times
	while(cycles > 0)
		cycles--;
	}
     710:	08 95       	ret

00000712 <LED_off>:


//***************STATUS LED**************
//tank test
void LED_off(void)
	{PORT_ON(PORTB,6);}
     712:	2e 9a       	sbi	0x05, 6	; 5
     714:	08 95       	ret

00000716 <LED_on>:
void LED_on(void)
	{PORT_OFF(PORTB,6);}
     716:	2e 98       	cbi	0x05, 6	; 5
     718:	08 95       	ret

0000071a <button_pressed>:


//*****************BUTTON****************
int button_pressed(void)
	{
	return (bit_is_clear(PING, 5));
     71a:	22 b3       	in	r18, 0x12	; 18
     71c:	30 e0       	ldi	r19, 0x00	; 0
     71e:	85 e0       	ldi	r24, 0x05	; 5
     720:	36 95       	lsr	r19
     722:	27 95       	ror	r18
     724:	8a 95       	dec	r24
     726:	e1 f7       	brne	.-8      	; 0x720 <button_pressed+0x6>
     728:	20 95       	com	r18
     72a:	30 95       	com	r19
     72c:	21 70       	andi	r18, 0x01	; 1
     72e:	30 70       	andi	r19, 0x00	; 0
	//return ((PING) & (1<<PG5));//old version, went high when button pushed
	}
     730:	c9 01       	movw	r24, r18
     732:	08 95       	ret

00000734 <cos_SoR>:
signed int angtable[73]={100,100,98,97,94,91,87,82,77,71,64,57,50,42,34,26,17,9,0,-9,-17,-26,-34,-42,-50,-57,-64,-71,-77,-82,-87,-91,-94,-97,-98,-100,
						 -100,-100,-98,-97,-94,-91,-87,-82,-77,-71,-64,-57,-50,-42,-34,-26,-17,-9,0,9,17,26,34,42,50,57,64,71,77,82,87,91,94,97,98,100,100};

signed int cos_SoR(long signed int degrees)//returns cos*100
	{
	if (degrees >= 0)//positive angles
     734:	97 fd       	sbrc	r25, 7
     736:	10 c0       	rjmp	.+32     	; 0x758 <cos_SoR+0x24>
		return angtable[degrees/5];
     738:	25 e0       	ldi	r18, 0x05	; 5
     73a:	30 e0       	ldi	r19, 0x00	; 0
     73c:	40 e0       	ldi	r20, 0x00	; 0
     73e:	50 e0       	ldi	r21, 0x00	; 0
     740:	0e 94 5c 2e 	call	0x5cb8	; 0x5cb8 <__divmodsi4>
     744:	da 01       	movw	r26, r20
     746:	c9 01       	movw	r24, r18
     748:	88 0f       	add	r24, r24
     74a:	99 1f       	adc	r25, r25
     74c:	84 5d       	subi	r24, 0xD4	; 212
     74e:	9d 4f       	sbci	r25, 0xFD	; 253
     750:	fc 01       	movw	r30, r24
     752:	20 81       	ld	r18, Z
     754:	31 81       	ldd	r19, Z+1	; 0x01
     756:	17 c0       	rjmp	.+46     	; 0x786 <cos_SoR+0x52>
	else
		return -angtable[72-(-degrees)/5];
     758:	25 e0       	ldi	r18, 0x05	; 5
     75a:	30 e0       	ldi	r19, 0x00	; 0
     75c:	40 e0       	ldi	r20, 0x00	; 0
     75e:	50 e0       	ldi	r21, 0x00	; 0
     760:	0e 94 5c 2e 	call	0x5cb8	; 0x5cb8 <__divmodsi4>
     764:	da 01       	movw	r26, r20
     766:	c9 01       	movw	r24, r18
     768:	88 5b       	subi	r24, 0xB8	; 184
     76a:	9f 4f       	sbci	r25, 0xFF	; 255
     76c:	af 4f       	sbci	r26, 0xFF	; 255
     76e:	bf 4f       	sbci	r27, 0xFF	; 255
     770:	88 0f       	add	r24, r24
     772:	99 1f       	adc	r25, r25
     774:	84 5d       	subi	r24, 0xD4	; 212
     776:	9d 4f       	sbci	r25, 0xFD	; 253
     778:	fc 01       	movw	r30, r24
     77a:	80 81       	ld	r24, Z
     77c:	91 81       	ldd	r25, Z+1	; 0x01
     77e:	22 27       	eor	r18, r18
     780:	33 27       	eor	r19, r19
     782:	28 1b       	sub	r18, r24
     784:	39 0b       	sbc	r19, r25
	}
     786:	c9 01       	movw	r24, r18
     788:	08 95       	ret

0000078a <sin_SoR>:

signed int sin_SoR(long signed int degrees)//returns sin*100
	{
	degrees=degrees - 90;//phase shift 90 degrees
     78a:	6a 55       	subi	r22, 0x5A	; 90
     78c:	70 40       	sbci	r23, 0x00	; 0
     78e:	80 40       	sbci	r24, 0x00	; 0
     790:	90 40       	sbci	r25, 0x00	; 0

	if (degrees >= 0)//positive angles
     792:	97 fd       	sbrc	r25, 7
     794:	10 c0       	rjmp	.+32     	; 0x7b6 <sin_SoR+0x2c>
		return angtable[degrees/5];
     796:	25 e0       	ldi	r18, 0x05	; 5
     798:	30 e0       	ldi	r19, 0x00	; 0
     79a:	40 e0       	ldi	r20, 0x00	; 0
     79c:	50 e0       	ldi	r21, 0x00	; 0
     79e:	0e 94 5c 2e 	call	0x5cb8	; 0x5cb8 <__divmodsi4>
     7a2:	da 01       	movw	r26, r20
     7a4:	c9 01       	movw	r24, r18
     7a6:	88 0f       	add	r24, r24
     7a8:	99 1f       	adc	r25, r25
     7aa:	84 5d       	subi	r24, 0xD4	; 212
     7ac:	9d 4f       	sbci	r25, 0xFD	; 253
     7ae:	fc 01       	movw	r30, r24
     7b0:	20 81       	ld	r18, Z
     7b2:	31 81       	ldd	r19, Z+1	; 0x01
     7b4:	17 c0       	rjmp	.+46     	; 0x7e4 <sin_SoR+0x5a>
	else
		return -angtable[72-(-degrees)/5];
     7b6:	25 e0       	ldi	r18, 0x05	; 5
     7b8:	30 e0       	ldi	r19, 0x00	; 0
     7ba:	40 e0       	ldi	r20, 0x00	; 0
     7bc:	50 e0       	ldi	r21, 0x00	; 0
     7be:	0e 94 5c 2e 	call	0x5cb8	; 0x5cb8 <__divmodsi4>
     7c2:	da 01       	movw	r26, r20
     7c4:	c9 01       	movw	r24, r18
     7c6:	88 5b       	subi	r24, 0xB8	; 184
     7c8:	9f 4f       	sbci	r25, 0xFF	; 255
     7ca:	af 4f       	sbci	r26, 0xFF	; 255
     7cc:	bf 4f       	sbci	r27, 0xFF	; 255
     7ce:	88 0f       	add	r24, r24
     7d0:	99 1f       	adc	r25, r25
     7d2:	84 5d       	subi	r24, 0xD4	; 212
     7d4:	9d 4f       	sbci	r25, 0xFD	; 253
     7d6:	fc 01       	movw	r30, r24
     7d8:	80 81       	ld	r24, Z
     7da:	91 81       	ldd	r25, Z+1	; 0x01
     7dc:	22 27       	eor	r18, r18
     7de:	33 27       	eor	r19, r19
     7e0:	28 1b       	sub	r18, r24
     7e2:	39 0b       	sbc	r19, r25
	}
     7e4:	c9 01       	movw	r24, r18
     7e6:	08 95       	ret

000007e8 <tan_SoR>:

signed int tan_SoR(long signed int degrees)//returns tan * 10
	{
     7e8:	cf 92       	push	r12
     7ea:	df 92       	push	r13
     7ec:	ef 92       	push	r14
     7ee:	ff 92       	push	r15
     7f0:	0f 93       	push	r16
     7f2:	1f 93       	push	r17
     7f4:	6b 01       	movw	r12, r22
     7f6:	7c 01       	movw	r14, r24
	//tan(x) = sin(x)/cos(x)
	if (degrees == 90 || degrees == -90 || degrees == 270 || degrees == -270)//blows up
     7f8:	8a e5       	ldi	r24, 0x5A	; 90
     7fa:	c8 16       	cp	r12, r24
     7fc:	d1 04       	cpc	r13, r1
     7fe:	e1 04       	cpc	r14, r1
     800:	f1 04       	cpc	r15, r1
     802:	a1 f1       	breq	.+104    	; 0x86c <tan_SoR+0x84>
     804:	86 ea       	ldi	r24, 0xA6	; 166
     806:	c8 16       	cp	r12, r24
     808:	8f ef       	ldi	r24, 0xFF	; 255
     80a:	d8 06       	cpc	r13, r24
     80c:	8f ef       	ldi	r24, 0xFF	; 255
     80e:	e8 06       	cpc	r14, r24
     810:	8f ef       	ldi	r24, 0xFF	; 255
     812:	f8 06       	cpc	r15, r24
     814:	59 f1       	breq	.+86     	; 0x86c <tan_SoR+0x84>
     816:	8e e0       	ldi	r24, 0x0E	; 14
     818:	c8 16       	cp	r12, r24
     81a:	81 e0       	ldi	r24, 0x01	; 1
     81c:	d8 06       	cpc	r13, r24
     81e:	80 e0       	ldi	r24, 0x00	; 0
     820:	e8 06       	cpc	r14, r24
     822:	80 e0       	ldi	r24, 0x00	; 0
     824:	f8 06       	cpc	r15, r24
     826:	11 f1       	breq	.+68     	; 0x86c <tan_SoR+0x84>
     828:	82 ef       	ldi	r24, 0xF2	; 242
     82a:	c8 16       	cp	r12, r24
     82c:	8e ef       	ldi	r24, 0xFE	; 254
     82e:	d8 06       	cpc	r13, r24
     830:	8f ef       	ldi	r24, 0xFF	; 255
     832:	e8 06       	cpc	r14, r24
     834:	8f ef       	ldi	r24, 0xFF	; 255
     836:	f8 06       	cpc	r15, r24
     838:	c9 f0       	breq	.+50     	; 0x86c <tan_SoR+0x84>
		return 0;//what else should I return?!?!?
	return sin_SoR(degrees)/cos_SoR(degrees)*10;
     83a:	c7 01       	movw	r24, r14
     83c:	b6 01       	movw	r22, r12
     83e:	0e 94 c5 03 	call	0x78a	; 0x78a <sin_SoR>
     842:	8c 01       	movw	r16, r24
     844:	c7 01       	movw	r24, r14
     846:	b6 01       	movw	r22, r12
     848:	0e 94 9a 03 	call	0x734	; 0x734 <cos_SoR>
     84c:	bc 01       	movw	r22, r24
     84e:	c8 01       	movw	r24, r16
     850:	0e 94 27 2e 	call	0x5c4e	; 0x5c4e <__divmodhi4>
     854:	cb 01       	movw	r24, r22
     856:	9b 01       	movw	r18, r22
     858:	73 e0       	ldi	r23, 0x03	; 3
     85a:	22 0f       	add	r18, r18
     85c:	33 1f       	adc	r19, r19
     85e:	7a 95       	dec	r23
     860:	e1 f7       	brne	.-8      	; 0x85a <tan_SoR+0x72>
     862:	88 0f       	add	r24, r24
     864:	99 1f       	adc	r25, r25
     866:	28 0f       	add	r18, r24
     868:	39 1f       	adc	r19, r25
     86a:	02 c0       	rjmp	.+4      	; 0x870 <tan_SoR+0x88>
     86c:	20 e0       	ldi	r18, 0x00	; 0
     86e:	30 e0       	ldi	r19, 0x00	; 0
	}
     870:	c9 01       	movw	r24, r18
     872:	1f 91       	pop	r17
     874:	0f 91       	pop	r16
     876:	ff 90       	pop	r15
     878:	ef 90       	pop	r14
     87a:	df 90       	pop	r13
     87c:	cf 90       	pop	r12
     87e:	08 95       	ret

00000880 <prvPWMSetup>:
//-----------------------------**&&**


void prvPWMSetup(){

	PWM_Init_timer3_E4(10); // Left wheel
     880:	8a e0       	ldi	r24, 0x0A	; 10
     882:	0e 94 63 01 	call	0x2c6	; 0x2c6 <PWM_Init_timer3_E4>
	PWM_Init_timer3_E3(10); // Right wheel
     886:	8a e0       	ldi	r24, 0x0A	; 10
     888:	0e 94 43 01 	call	0x286	; 0x286 <PWM_Init_timer3_E3>
	PWM_Init_timer4_H3(10);	// Left sprayer
     88c:	8a e0       	ldi	r24, 0x0A	; 10
     88e:	0e 94 a3 01 	call	0x346	; 0x346 <PWM_Init_timer4_H3>
	PWM_Init_timer4_H4(10);	// Right sprayer
     892:	8a e0       	ldi	r24, 0x0A	; 10
     894:	0e 94 c3 01 	call	0x386	; 0x386 <PWM_Init_timer4_H4>

}
     898:	08 95       	ret

0000089a <char2hex>:

char char2hex(char c){
     89a:	98 2f       	mov	r25, r24
	
	if((c > 47) && (c <58)){
     89c:	80 53       	subi	r24, 0x30	; 48
     89e:	8a 30       	cpi	r24, 0x0A	; 10
     8a0:	38 f0       	brcs	.+14     	; 0x8b0 <char2hex+0x16>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     8a2:	81 51       	subi	r24, 0x11	; 17
     8a4:	86 30       	cpi	r24, 0x06	; 6
     8a6:	10 f0       	brcs	.+4      	; 0x8ac <char2hex+0x12>
     8a8:	89 2f       	mov	r24, r25
     8aa:	08 95       	ret
		c -= 55;
     8ac:	89 2f       	mov	r24, r25
     8ae:	87 53       	subi	r24, 0x37	; 55
	}
	return c;
}
     8b0:	08 95       	ret

000008b2 <retConv_s16>:

s16 retConv_s16(char* ch_head){
     8b2:	fc 01       	movw	r30, r24

	s16 int_val = 0x0000;
	char iv1 = *(ch_head);
     8b4:	90 81       	ld	r25, Z
	char iv2 = *(ch_head + 1);
     8b6:	21 81       	ldd	r18, Z+1	; 0x01
	char iv3 = *(ch_head + 2);
     8b8:	42 81       	ldd	r20, Z+2	; 0x02
	char iv4 = *(ch_head + 3);
     8ba:	53 81       	ldd	r21, Z+3	; 0x03

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     8bc:	89 2f       	mov	r24, r25
     8be:	80 53       	subi	r24, 0x30	; 48
     8c0:	8a 30       	cpi	r24, 0x0A	; 10
     8c2:	10 f4       	brcc	.+4      	; 0x8c8 <retConv_s16+0x16>
     8c4:	98 2f       	mov	r25, r24
     8c6:	05 c0       	rjmp	.+10     	; 0x8d2 <retConv_s16+0x20>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     8c8:	89 2f       	mov	r24, r25
     8ca:	81 54       	subi	r24, 0x41	; 65
     8cc:	86 30       	cpi	r24, 0x06	; 6
     8ce:	08 f4       	brcc	.+2      	; 0x8d2 <retConv_s16+0x20>
		c -= 55;
     8d0:	97 53       	subi	r25, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     8d2:	82 2f       	mov	r24, r18
     8d4:	80 53       	subi	r24, 0x30	; 48
     8d6:	8a 30       	cpi	r24, 0x0A	; 10
     8d8:	10 f4       	brcc	.+4      	; 0x8de <retConv_s16+0x2c>
     8da:	28 2f       	mov	r18, r24
     8dc:	05 c0       	rjmp	.+10     	; 0x8e8 <retConv_s16+0x36>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     8de:	82 2f       	mov	r24, r18
     8e0:	81 54       	subi	r24, 0x41	; 65
     8e2:	86 30       	cpi	r24, 0x06	; 6
     8e4:	08 f4       	brcc	.+2      	; 0x8e8 <retConv_s16+0x36>
		c -= 55;
     8e6:	27 53       	subi	r18, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     8e8:	84 2f       	mov	r24, r20
     8ea:	80 53       	subi	r24, 0x30	; 48
     8ec:	8a 30       	cpi	r24, 0x0A	; 10
     8ee:	10 f4       	brcc	.+4      	; 0x8f4 <retConv_s16+0x42>
     8f0:	48 2f       	mov	r20, r24
     8f2:	05 c0       	rjmp	.+10     	; 0x8fe <retConv_s16+0x4c>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     8f4:	84 2f       	mov	r24, r20
     8f6:	81 54       	subi	r24, 0x41	; 65
     8f8:	86 30       	cpi	r24, 0x06	; 6
     8fa:	08 f4       	brcc	.+2      	; 0x8fe <retConv_s16+0x4c>
		c -= 55;
     8fc:	47 53       	subi	r20, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     8fe:	85 2f       	mov	r24, r21
     900:	80 53       	subi	r24, 0x30	; 48
     902:	8a 30       	cpi	r24, 0x0A	; 10
     904:	10 f4       	brcc	.+4      	; 0x90a <retConv_s16+0x58>
     906:	58 2f       	mov	r21, r24
     908:	05 c0       	rjmp	.+10     	; 0x914 <retConv_s16+0x62>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     90a:	85 2f       	mov	r24, r21
     90c:	81 54       	subi	r24, 0x41	; 65
     90e:	86 30       	cpi	r24, 0x06	; 6
     910:	08 f4       	brcc	.+2      	; 0x914 <retConv_s16+0x62>
		c -= 55;
     912:	57 53       	subi	r21, 0x37	; 55
	iv2 = char2hex(iv2);
	iv3 = char2hex(iv3);
	iv4 = char2hex(iv4);

	int_val = (int_val | iv1);
	int_val = ((int_val<<4) | iv2);
     914:	30 e0       	ldi	r19, 0x00	; 0
     916:	89 2f       	mov	r24, r25
     918:	90 e0       	ldi	r25, 0x00	; 0
     91a:	a4 e0       	ldi	r26, 0x04	; 4
     91c:	88 0f       	add	r24, r24
     91e:	99 1f       	adc	r25, r25
     920:	aa 95       	dec	r26
     922:	e1 f7       	brne	.-8      	; 0x91c <retConv_s16+0x6a>
     924:	28 2b       	or	r18, r24
     926:	39 2b       	or	r19, r25
	int_val = ((int_val<<4) | iv3);
     928:	f4 e0       	ldi	r31, 0x04	; 4
     92a:	22 0f       	add	r18, r18
     92c:	33 1f       	adc	r19, r19
     92e:	fa 95       	dec	r31
     930:	e1 f7       	brne	.-8      	; 0x92a <retConv_s16+0x78>
     932:	84 2f       	mov	r24, r20
     934:	90 e0       	ldi	r25, 0x00	; 0
     936:	82 2b       	or	r24, r18
     938:	93 2b       	or	r25, r19
	int_val = ((int_val<<4) | iv4);
     93a:	e4 e0       	ldi	r30, 0x04	; 4
     93c:	88 0f       	add	r24, r24
     93e:	99 1f       	adc	r25, r25
     940:	ea 95       	dec	r30
     942:	e1 f7       	brne	.-8      	; 0x93c <retConv_s16+0x8a>
     944:	25 2f       	mov	r18, r21
     946:	30 e0       	ldi	r19, 0x00	; 0
     948:	28 2b       	or	r18, r24
     94a:	39 2b       	or	r19, r25
	return int_val;
}
     94c:	c9 01       	movw	r24, r18
     94e:	08 95       	ret

00000950 <retConv_s32>:

s32 retConv_s32(char* ch_head){
     950:	ff 92       	push	r15
     952:	0f 93       	push	r16
     954:	1f 93       	push	r17
     956:	fc 01       	movw	r30, r24

	s32 int_val = 0x00000000;
	char iv1 = *(ch_head);
     958:	90 81       	ld	r25, Z
	char iv2 = *(ch_head + 1);
     95a:	21 81       	ldd	r18, Z+1	; 0x01
	char iv3 = *(ch_head + 2);
     95c:	62 81       	ldd	r22, Z+2	; 0x02
	char iv4 = *(ch_head + 3);
     95e:	73 81       	ldd	r23, Z+3	; 0x03
	char iv5 = *(ch_head + 4);
     960:	14 81       	ldd	r17, Z+4	; 0x04
	char iv6 = *(ch_head + 5);
     962:	05 81       	ldd	r16, Z+5	; 0x05
	char iv7 = *(ch_head + 6);
     964:	f6 80       	ldd	r15, Z+6	; 0x06
	char iv8 = *(ch_head + 7);
     966:	e7 81       	ldd	r30, Z+7	; 0x07

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     968:	89 2f       	mov	r24, r25
     96a:	80 53       	subi	r24, 0x30	; 48
     96c:	8a 30       	cpi	r24, 0x0A	; 10
     96e:	10 f4       	brcc	.+4      	; 0x974 <retConv_s32+0x24>
     970:	98 2f       	mov	r25, r24
     972:	05 c0       	rjmp	.+10     	; 0x97e <retConv_s32+0x2e>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     974:	89 2f       	mov	r24, r25
     976:	81 54       	subi	r24, 0x41	; 65
     978:	86 30       	cpi	r24, 0x06	; 6
     97a:	08 f4       	brcc	.+2      	; 0x97e <retConv_s32+0x2e>
		c -= 55;
     97c:	97 53       	subi	r25, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     97e:	82 2f       	mov	r24, r18
     980:	80 53       	subi	r24, 0x30	; 48
     982:	8a 30       	cpi	r24, 0x0A	; 10
     984:	10 f4       	brcc	.+4      	; 0x98a <retConv_s32+0x3a>
     986:	28 2f       	mov	r18, r24
     988:	05 c0       	rjmp	.+10     	; 0x994 <retConv_s32+0x44>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     98a:	82 2f       	mov	r24, r18
     98c:	81 54       	subi	r24, 0x41	; 65
     98e:	86 30       	cpi	r24, 0x06	; 6
     990:	08 f4       	brcc	.+2      	; 0x994 <retConv_s32+0x44>
		c -= 55;
     992:	27 53       	subi	r18, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     994:	86 2f       	mov	r24, r22
     996:	80 53       	subi	r24, 0x30	; 48
     998:	8a 30       	cpi	r24, 0x0A	; 10
     99a:	10 f4       	brcc	.+4      	; 0x9a0 <retConv_s32+0x50>
     99c:	68 2f       	mov	r22, r24
     99e:	05 c0       	rjmp	.+10     	; 0x9aa <retConv_s32+0x5a>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     9a0:	86 2f       	mov	r24, r22
     9a2:	81 54       	subi	r24, 0x41	; 65
     9a4:	86 30       	cpi	r24, 0x06	; 6
     9a6:	08 f4       	brcc	.+2      	; 0x9aa <retConv_s32+0x5a>
		c -= 55;
     9a8:	67 53       	subi	r22, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     9aa:	87 2f       	mov	r24, r23
     9ac:	80 53       	subi	r24, 0x30	; 48
     9ae:	8a 30       	cpi	r24, 0x0A	; 10
     9b0:	10 f4       	brcc	.+4      	; 0x9b6 <retConv_s32+0x66>
     9b2:	78 2f       	mov	r23, r24
     9b4:	05 c0       	rjmp	.+10     	; 0x9c0 <retConv_s32+0x70>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     9b6:	87 2f       	mov	r24, r23
     9b8:	81 54       	subi	r24, 0x41	; 65
     9ba:	86 30       	cpi	r24, 0x06	; 6
     9bc:	08 f4       	brcc	.+2      	; 0x9c0 <retConv_s32+0x70>
		c -= 55;
     9be:	77 53       	subi	r23, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     9c0:	81 2f       	mov	r24, r17
     9c2:	80 53       	subi	r24, 0x30	; 48
     9c4:	8a 30       	cpi	r24, 0x0A	; 10
     9c6:	10 f4       	brcc	.+4      	; 0x9cc <retConv_s32+0x7c>
     9c8:	18 2f       	mov	r17, r24
     9ca:	05 c0       	rjmp	.+10     	; 0x9d6 <retConv_s32+0x86>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     9cc:	81 2f       	mov	r24, r17
     9ce:	81 54       	subi	r24, 0x41	; 65
     9d0:	86 30       	cpi	r24, 0x06	; 6
     9d2:	08 f4       	brcc	.+2      	; 0x9d6 <retConv_s32+0x86>
		c -= 55;
     9d4:	17 53       	subi	r17, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     9d6:	80 2f       	mov	r24, r16
     9d8:	80 53       	subi	r24, 0x30	; 48
     9da:	8a 30       	cpi	r24, 0x0A	; 10
     9dc:	10 f4       	brcc	.+4      	; 0x9e2 <retConv_s32+0x92>
     9de:	08 2f       	mov	r16, r24
     9e0:	05 c0       	rjmp	.+10     	; 0x9ec <retConv_s32+0x9c>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     9e2:	80 2f       	mov	r24, r16
     9e4:	81 54       	subi	r24, 0x41	; 65
     9e6:	86 30       	cpi	r24, 0x06	; 6
     9e8:	08 f4       	brcc	.+2      	; 0x9ec <retConv_s32+0x9c>
		c -= 55;
     9ea:	07 53       	subi	r16, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     9ec:	8f 2d       	mov	r24, r15
     9ee:	80 53       	subi	r24, 0x30	; 48
     9f0:	8a 30       	cpi	r24, 0x0A	; 10
     9f2:	10 f4       	brcc	.+4      	; 0x9f8 <retConv_s32+0xa8>
     9f4:	f8 2e       	mov	r15, r24
     9f6:	06 c0       	rjmp	.+12     	; 0xa04 <retConv_s32+0xb4>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     9f8:	8f 2d       	mov	r24, r15
     9fa:	81 54       	subi	r24, 0x41	; 65
     9fc:	86 30       	cpi	r24, 0x06	; 6
     9fe:	10 f4       	brcc	.+4      	; 0xa04 <retConv_s32+0xb4>
		c -= 55;
     a00:	89 ec       	ldi	r24, 0xC9	; 201
     a02:	f8 0e       	add	r15, r24

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     a04:	8e 2f       	mov	r24, r30
     a06:	80 53       	subi	r24, 0x30	; 48
     a08:	8a 30       	cpi	r24, 0x0A	; 10
     a0a:	10 f4       	brcc	.+4      	; 0xa10 <retConv_s32+0xc0>
     a0c:	e8 2f       	mov	r30, r24
     a0e:	05 c0       	rjmp	.+10     	; 0xa1a <retConv_s32+0xca>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     a10:	8e 2f       	mov	r24, r30
     a12:	81 54       	subi	r24, 0x41	; 65
     a14:	86 30       	cpi	r24, 0x06	; 6
     a16:	08 f4       	brcc	.+2      	; 0xa1a <retConv_s32+0xca>
		c -= 55;
     a18:	e7 53       	subi	r30, 0x37	; 55
	iv6 = char2hex(iv6);
	iv7 = char2hex(iv7);
	iv8 = char2hex(iv8);

	int_val = (int_val | iv1);
	int_val = ((int_val<<4) | iv2);
     a1a:	30 e0       	ldi	r19, 0x00	; 0
     a1c:	40 e0       	ldi	r20, 0x00	; 0
     a1e:	50 e0       	ldi	r21, 0x00	; 0
     a20:	89 2f       	mov	r24, r25
     a22:	90 e0       	ldi	r25, 0x00	; 0
     a24:	a0 e0       	ldi	r26, 0x00	; 0
     a26:	b0 e0       	ldi	r27, 0x00	; 0
     a28:	f4 e0       	ldi	r31, 0x04	; 4
     a2a:	88 0f       	add	r24, r24
     a2c:	99 1f       	adc	r25, r25
     a2e:	aa 1f       	adc	r26, r26
     a30:	bb 1f       	adc	r27, r27
     a32:	fa 95       	dec	r31
     a34:	d1 f7       	brne	.-12     	; 0xa2a <retConv_s32+0xda>
     a36:	28 2b       	or	r18, r24
     a38:	39 2b       	or	r19, r25
     a3a:	4a 2b       	or	r20, r26
     a3c:	5b 2b       	or	r21, r27
	int_val = ((int_val<<4) | iv3);
     a3e:	a4 e0       	ldi	r26, 0x04	; 4
     a40:	22 0f       	add	r18, r18
     a42:	33 1f       	adc	r19, r19
     a44:	44 1f       	adc	r20, r20
     a46:	55 1f       	adc	r21, r21
     a48:	aa 95       	dec	r26
     a4a:	d1 f7       	brne	.-12     	; 0xa40 <retConv_s32+0xf0>
     a4c:	86 2f       	mov	r24, r22
     a4e:	90 e0       	ldi	r25, 0x00	; 0
     a50:	a0 e0       	ldi	r26, 0x00	; 0
     a52:	b0 e0       	ldi	r27, 0x00	; 0
     a54:	82 2b       	or	r24, r18
     a56:	93 2b       	or	r25, r19
     a58:	a4 2b       	or	r26, r20
     a5a:	b5 2b       	or	r27, r21
	int_val = ((int_val<<4) | iv4);
     a5c:	f4 e0       	ldi	r31, 0x04	; 4
     a5e:	88 0f       	add	r24, r24
     a60:	99 1f       	adc	r25, r25
     a62:	aa 1f       	adc	r26, r26
     a64:	bb 1f       	adc	r27, r27
     a66:	fa 95       	dec	r31
     a68:	d1 f7       	brne	.-12     	; 0xa5e <retConv_s32+0x10e>
     a6a:	27 2f       	mov	r18, r23
     a6c:	30 e0       	ldi	r19, 0x00	; 0
     a6e:	40 e0       	ldi	r20, 0x00	; 0
     a70:	50 e0       	ldi	r21, 0x00	; 0
     a72:	28 2b       	or	r18, r24
     a74:	39 2b       	or	r19, r25
     a76:	4a 2b       	or	r20, r26
     a78:	5b 2b       	or	r21, r27
	int_val = ((int_val<<4) | iv5);
     a7a:	64 e0       	ldi	r22, 0x04	; 4
     a7c:	22 0f       	add	r18, r18
     a7e:	33 1f       	adc	r19, r19
     a80:	44 1f       	adc	r20, r20
     a82:	55 1f       	adc	r21, r21
     a84:	6a 95       	dec	r22
     a86:	d1 f7       	brne	.-12     	; 0xa7c <retConv_s32+0x12c>
     a88:	81 2f       	mov	r24, r17
     a8a:	90 e0       	ldi	r25, 0x00	; 0
     a8c:	a0 e0       	ldi	r26, 0x00	; 0
     a8e:	b0 e0       	ldi	r27, 0x00	; 0
     a90:	82 2b       	or	r24, r18
     a92:	93 2b       	or	r25, r19
     a94:	a4 2b       	or	r26, r20
     a96:	b5 2b       	or	r27, r21
	int_val = ((int_val<<4) | iv6);
     a98:	24 e0       	ldi	r18, 0x04	; 4
     a9a:	88 0f       	add	r24, r24
     a9c:	99 1f       	adc	r25, r25
     a9e:	aa 1f       	adc	r26, r26
     aa0:	bb 1f       	adc	r27, r27
     aa2:	2a 95       	dec	r18
     aa4:	d1 f7       	brne	.-12     	; 0xa9a <retConv_s32+0x14a>
     aa6:	20 2f       	mov	r18, r16
     aa8:	30 e0       	ldi	r19, 0x00	; 0
     aaa:	40 e0       	ldi	r20, 0x00	; 0
     aac:	50 e0       	ldi	r21, 0x00	; 0
     aae:	28 2b       	or	r18, r24
     ab0:	39 2b       	or	r19, r25
     ab2:	4a 2b       	or	r20, r26
     ab4:	5b 2b       	or	r21, r27
	int_val = ((int_val<<4) | iv7);
     ab6:	04 e0       	ldi	r16, 0x04	; 4
     ab8:	22 0f       	add	r18, r18
     aba:	33 1f       	adc	r19, r19
     abc:	44 1f       	adc	r20, r20
     abe:	55 1f       	adc	r21, r21
     ac0:	0a 95       	dec	r16
     ac2:	d1 f7       	brne	.-12     	; 0xab8 <retConv_s32+0x168>
     ac4:	8f 2d       	mov	r24, r15
     ac6:	90 e0       	ldi	r25, 0x00	; 0
     ac8:	a0 e0       	ldi	r26, 0x00	; 0
     aca:	b0 e0       	ldi	r27, 0x00	; 0
     acc:	82 2b       	or	r24, r18
     ace:	93 2b       	or	r25, r19
     ad0:	a4 2b       	or	r26, r20
     ad2:	b5 2b       	or	r27, r21
	int_val = ((int_val<<4) | iv8);
     ad4:	14 e0       	ldi	r17, 0x04	; 4
     ad6:	88 0f       	add	r24, r24
     ad8:	99 1f       	adc	r25, r25
     ada:	aa 1f       	adc	r26, r26
     adc:	bb 1f       	adc	r27, r27
     ade:	1a 95       	dec	r17
     ae0:	d1 f7       	brne	.-12     	; 0xad6 <retConv_s32+0x186>
     ae2:	2e 2f       	mov	r18, r30
     ae4:	30 e0       	ldi	r19, 0x00	; 0
     ae6:	40 e0       	ldi	r20, 0x00	; 0
     ae8:	50 e0       	ldi	r21, 0x00	; 0
     aea:	28 2b       	or	r18, r24
     aec:	39 2b       	or	r19, r25
     aee:	4a 2b       	or	r20, r26
     af0:	5b 2b       	or	r21, r27
	return int_val;
}
     af2:	b9 01       	movw	r22, r18
     af4:	ca 01       	movw	r24, r20
     af6:	1f 91       	pop	r17
     af8:	0f 91       	pop	r16
     afa:	ff 90       	pop	r15
     afc:	08 95       	ret

00000afe <ubRcv>:
			//taskYIELD();
	//	}
}

void ubRcv(unsigned char c){
	if(c != 0xff){
     afe:	8f 3f       	cpi	r24, 0xFF	; 255
     b00:	b9 f0       	breq	.+46     	; 0xb30 <ubRcv+0x32>
		*ub_buffer_write_ndx = c;
     b02:	e0 91 f8 02 	lds	r30, 0x02F8
     b06:	f0 91 f9 02 	lds	r31, 0x02F9
     b0a:	80 83       	st	Z, r24
		ub_buffer_write_ndx++;		
     b0c:	80 91 f8 02 	lds	r24, 0x02F8
     b10:	90 91 f9 02 	lds	r25, 0x02F9
     b14:	01 96       	adiw	r24, 0x01	; 1
     b16:	90 93 f9 02 	sts	0x02F9, r25
     b1a:	80 93 f8 02 	sts	0x02F8, r24
		if(ub_buffer_write_ndx >= (ub_buffer + UB_BUFFER_SIZE)){ 
     b1e:	80 54       	subi	r24, 0x40	; 64
     b20:	94 41       	sbci	r25, 0x14	; 20
     b22:	30 f0       	brcs	.+12     	; 0xb30 <ubRcv+0x32>
			ub_buffer_write_ndx = ub_buffer;
     b24:	80 e4       	ldi	r24, 0x40	; 64
     b26:	92 e1       	ldi	r25, 0x12	; 18
     b28:	90 93 f9 02 	sts	0x02F9, r25
     b2c:	80 93 f8 02 	sts	0x02F8, r24
     b30:	08 95       	ret

00000b32 <init_ub_buffer>:
	}
	return data;
}

void init_ub_buffer(){
	ub_buffer_write_ndx = ub_buffer_read_ndx = ub_buffer;
     b32:	80 e4       	ldi	r24, 0x40	; 64
     b34:	92 e1       	ldi	r25, 0x12	; 18
     b36:	90 93 fb 02 	sts	0x02FB, r25
     b3a:	80 93 fa 02 	sts	0x02FA, r24
     b3e:	90 93 f9 02 	sts	0x02F9, r25
     b42:	80 93 f8 02 	sts	0x02F8, r24
}
     b46:	08 95       	ret

00000b48 <wheel_L>:
}

/*************************************************/


void wheel_L(float cmd_vel){
     b48:	ef 92       	push	r14
     b4a:	ff 92       	push	r15
     b4c:	0f 93       	push	r16
     b4e:	1f 93       	push	r17
     b50:	7b 01       	movw	r14, r22
     b52:	8c 01       	movw	r16, r24
		if(cmd_vel > 36){cmd_vel = 36;}
     b54:	20 e0       	ldi	r18, 0x00	; 0
     b56:	30 e0       	ldi	r19, 0x00	; 0
     b58:	40 e1       	ldi	r20, 0x10	; 16
     b5a:	52 e4       	ldi	r21, 0x42	; 66
     b5c:	0e 94 83 2d 	call	0x5b06	; 0x5b06 <__gesf2>
     b60:	18 16       	cp	r1, r24
     b62:	5c f4       	brge	.+22     	; 0xb7a <wheel_L+0x32>
     b64:	0f 2e       	mov	r0, r31
     b66:	f0 e0       	ldi	r31, 0x00	; 0
     b68:	ef 2e       	mov	r14, r31
     b6a:	f0 e0       	ldi	r31, 0x00	; 0
     b6c:	ff 2e       	mov	r15, r31
     b6e:	f0 e1       	ldi	r31, 0x10	; 16
     b70:	0f 2f       	mov	r16, r31
     b72:	f2 e4       	ldi	r31, 0x42	; 66
     b74:	1f 2f       	mov	r17, r31
     b76:	f0 2d       	mov	r31, r0
     b78:	14 c0       	rjmp	.+40     	; 0xba2 <wheel_L+0x5a>
		if(cmd_vel < -36){cmd_vel = -36;}
     b7a:	c8 01       	movw	r24, r16
     b7c:	b7 01       	movw	r22, r14
     b7e:	20 e0       	ldi	r18, 0x00	; 0
     b80:	30 e0       	ldi	r19, 0x00	; 0
     b82:	40 e1       	ldi	r20, 0x10	; 16
     b84:	52 ec       	ldi	r21, 0xC2	; 194
     b86:	0e 94 ba 2b 	call	0x5774	; 0x5774 <__cmpsf2>
     b8a:	88 23       	and	r24, r24
     b8c:	54 f4       	brge	.+20     	; 0xba2 <wheel_L+0x5a>
     b8e:	0f 2e       	mov	r0, r31
     b90:	f0 e0       	ldi	r31, 0x00	; 0
     b92:	ef 2e       	mov	r14, r31
     b94:	f0 e0       	ldi	r31, 0x00	; 0
     b96:	ff 2e       	mov	r15, r31
     b98:	f0 e1       	ldi	r31, 0x10	; 16
     b9a:	0f 2f       	mov	r16, r31
     b9c:	f2 ec       	ldi	r31, 0xC2	; 194
     b9e:	1f 2f       	mov	r17, r31
     ba0:	f0 2d       	mov	r31, r0
		
		float s_out = -0.4928 * (cmd_vel) + 185.27;
		
		taskENTER_CRITICAL();
     ba2:	0f b6       	in	r0, 0x3f	; 63
     ba4:	f8 94       	cli
     ba6:	0f 92       	push	r0
		PWM_timer3_Set_E4((int)s_out);
     ba8:	c8 01       	movw	r24, r16
     baa:	b7 01       	movw	r22, r14
     bac:	28 e4       	ldi	r18, 0x48	; 72
     bae:	30 e5       	ldi	r19, 0x50	; 80
     bb0:	4c ef       	ldi	r20, 0xFC	; 252
     bb2:	5e eb       	ldi	r21, 0xBE	; 190
     bb4:	0e 94 8e 2d 	call	0x5b1c	; 0x5b1c <__mulsf3>
     bb8:	2f e1       	ldi	r18, 0x1F	; 31
     bba:	35 e4       	ldi	r19, 0x45	; 69
     bbc:	49 e3       	ldi	r20, 0x39	; 57
     bbe:	53 e4       	ldi	r21, 0x43	; 67
     bc0:	0e 94 f4 2a 	call	0x55e8	; 0x55e8 <__addsf3>
     bc4:	0e 94 26 2c 	call	0x584c	; 0x584c <__fixsfsi>
void PWM_timer2_Set_H6(u16 pwmDuty)
	{OCR2B = pwmDuty;}
void PWM_timer3_Set_E3(u16 pwmDuty)
	{OCR3A = pwmDuty;}
void PWM_timer3_Set_E4(u16 pwmDuty)
	{OCR3B = pwmDuty;}
     bc8:	70 93 9b 00 	sts	0x009B, r23
     bcc:	60 93 9a 00 	sts	0x009A, r22
		taskEXIT_CRITICAL();
     bd0:	0f 90       	pop	r0
     bd2:	0f be       	out	0x3f, r0	; 63


}
     bd4:	1f 91       	pop	r17
     bd6:	0f 91       	pop	r16
     bd8:	ff 90       	pop	r15
     bda:	ef 90       	pop	r14
     bdc:	08 95       	ret

00000bde <wheel_R>:

void wheel_R(float cmd_vel){
     bde:	ef 92       	push	r14
     be0:	ff 92       	push	r15
     be2:	0f 93       	push	r16
     be4:	1f 93       	push	r17
     be6:	7b 01       	movw	r14, r22
     be8:	8c 01       	movw	r16, r24
		if(cmd_vel > 36){cmd_vel = 36;}
     bea:	20 e0       	ldi	r18, 0x00	; 0
     bec:	30 e0       	ldi	r19, 0x00	; 0
     bee:	40 e1       	ldi	r20, 0x10	; 16
     bf0:	52 e4       	ldi	r21, 0x42	; 66
     bf2:	0e 94 83 2d 	call	0x5b06	; 0x5b06 <__gesf2>
     bf6:	18 16       	cp	r1, r24
     bf8:	5c f4       	brge	.+22     	; 0xc10 <wheel_R+0x32>
     bfa:	0f 2e       	mov	r0, r31
     bfc:	f0 e0       	ldi	r31, 0x00	; 0
     bfe:	ef 2e       	mov	r14, r31
     c00:	f0 e0       	ldi	r31, 0x00	; 0
     c02:	ff 2e       	mov	r15, r31
     c04:	f0 e1       	ldi	r31, 0x10	; 16
     c06:	0f 2f       	mov	r16, r31
     c08:	f2 e4       	ldi	r31, 0x42	; 66
     c0a:	1f 2f       	mov	r17, r31
     c0c:	f0 2d       	mov	r31, r0
     c0e:	14 c0       	rjmp	.+40     	; 0xc38 <wheel_R+0x5a>
		if(cmd_vel < -36){cmd_vel = -36;}
     c10:	c8 01       	movw	r24, r16
     c12:	b7 01       	movw	r22, r14
     c14:	20 e0       	ldi	r18, 0x00	; 0
     c16:	30 e0       	ldi	r19, 0x00	; 0
     c18:	40 e1       	ldi	r20, 0x10	; 16
     c1a:	52 ec       	ldi	r21, 0xC2	; 194
     c1c:	0e 94 ba 2b 	call	0x5774	; 0x5774 <__cmpsf2>
     c20:	88 23       	and	r24, r24
     c22:	54 f4       	brge	.+20     	; 0xc38 <wheel_R+0x5a>
     c24:	0f 2e       	mov	r0, r31
     c26:	f0 e0       	ldi	r31, 0x00	; 0
     c28:	ef 2e       	mov	r14, r31
     c2a:	f0 e0       	ldi	r31, 0x00	; 0
     c2c:	ff 2e       	mov	r15, r31
     c2e:	f0 e1       	ldi	r31, 0x10	; 16
     c30:	0f 2f       	mov	r16, r31
     c32:	f2 ec       	ldi	r31, 0xC2	; 194
     c34:	1f 2f       	mov	r17, r31
     c36:	f0 2d       	mov	r31, r0
				
		float s_out = -0.5421 * (cmd_vel) + 188.41;

		taskENTER_CRITICAL();
     c38:	0f b6       	in	r0, 0x3f	; 63
     c3a:	f8 94       	cli
     c3c:	0f 92       	push	r0
		PWM_timer3_Set_E3((int)s_out);
     c3e:	c8 01       	movw	r24, r16
     c40:	b7 01       	movw	r22, r14
     c42:	21 e1       	ldi	r18, 0x11	; 17
     c44:	37 ec       	ldi	r19, 0xC7	; 199
     c46:	4a e0       	ldi	r20, 0x0A	; 10
     c48:	5f eb       	ldi	r21, 0xBF	; 191
     c4a:	0e 94 8e 2d 	call	0x5b1c	; 0x5b1c <__mulsf3>
     c4e:	26 ef       	ldi	r18, 0xF6	; 246
     c50:	38 e6       	ldi	r19, 0x68	; 104
     c52:	4c e3       	ldi	r20, 0x3C	; 60
     c54:	53 e4       	ldi	r21, 0x43	; 67
     c56:	0e 94 f4 2a 	call	0x55e8	; 0x55e8 <__addsf3>
     c5a:	0e 94 26 2c 	call	0x584c	; 0x584c <__fixsfsi>
void PWM_timer1_Set_LED(u16 pwmDuty)
	{OCR1B = pwmDuty;}
void PWM_timer2_Set_H6(u16 pwmDuty)
	{OCR2B = pwmDuty;}
void PWM_timer3_Set_E3(u16 pwmDuty)
	{OCR3A = pwmDuty;}
     c5e:	70 93 99 00 	sts	0x0099, r23
     c62:	60 93 98 00 	sts	0x0098, r22
		taskEXIT_CRITICAL();
     c66:	0f 90       	pop	r0
     c68:	0f be       	out	0x3f, r0	; 63


}
     c6a:	1f 91       	pop	r17
     c6c:	0f 91       	pop	r16
     c6e:	ff 90       	pop	r15
     c70:	ef 90       	pop	r14
     c72:	08 95       	ret

00000c74 <num2char>:
	}
}



char num2char(char c){
     c74:	98 2f       	mov	r25, r24
	
	if(c <10){
     c76:	8a 30       	cpi	r24, 0x0A	; 10
     c78:	10 f4       	brcc	.+4      	; 0xc7e <num2char+0xa>
		c += 48;
     c7a:	90 5d       	subi	r25, 0xD0	; 208
     c7c:	04 c0       	rjmp	.+8      	; 0xc86 <num2char+0x12>
	}
	else if((c >= 10) && (c <= 16)){
     c7e:	8a 50       	subi	r24, 0x0A	; 10
     c80:	87 30       	cpi	r24, 0x07	; 7
     c82:	08 f4       	brcc	.+2      	; 0xc86 <num2char+0x12>
		c += 55;
     c84:	99 5c       	subi	r25, 0xC9	; 201
	}
	return c;
}
     c86:	89 2f       	mov	r24, r25
     c88:	08 95       	ret

00000c8a <vUpdatePose>:
		
	vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
	}
}

void vUpdatePose(){
     c8a:	af 92       	push	r10
     c8c:	bf 92       	push	r11
     c8e:	cf 92       	push	r12
     c90:	df 92       	push	r13
     c92:	ef 92       	push	r14
     c94:	ff 92       	push	r15
     c96:	0f 93       	push	r16
     c98:	1f 93       	push	r17
	float CMD_K = 0.5;
	float COR_K = 1;
	uint8_t lds_char;

	for(;;){
		robot.heading = (180 * enc_heading) / M_PI; 
     c9a:	60 91 e0 02 	lds	r22, 0x02E0
     c9e:	70 91 e1 02 	lds	r23, 0x02E1
     ca2:	80 91 e2 02 	lds	r24, 0x02E2
     ca6:	90 91 e3 02 	lds	r25, 0x02E3
     caa:	20 e0       	ldi	r18, 0x00	; 0
     cac:	30 e0       	ldi	r19, 0x00	; 0
     cae:	44 e3       	ldi	r20, 0x34	; 52
     cb0:	53 e4       	ldi	r21, 0x43	; 67
     cb2:	0e 94 8e 2d 	call	0x5b1c	; 0x5b1c <__mulsf3>
     cb6:	2b ed       	ldi	r18, 0xDB	; 219
     cb8:	3f e0       	ldi	r19, 0x0F	; 15
     cba:	49 e4       	ldi	r20, 0x49	; 73
     cbc:	50 e4       	ldi	r21, 0x40	; 64
     cbe:	0e 94 be 2b 	call	0x577c	; 0x577c <__divsf3>
     cc2:	5b 01       	movw	r10, r22
     cc4:	6c 01       	movw	r12, r24
		robot.vel = (LEFTVel_current + (-RIGHTVel_current)) / 2;
     cc6:	80 91 c6 02 	lds	r24, 0x02C6
     cca:	90 91 c7 02 	lds	r25, 0x02C7
     cce:	20 91 d3 02 	lds	r18, 0x02D3
     cd2:	30 91 d4 02 	lds	r19, 0x02D4
     cd6:	82 1b       	sub	r24, r18
     cd8:	93 0b       	sbc	r25, r19
     cda:	62 e0       	ldi	r22, 0x02	; 2
     cdc:	70 e0       	ldi	r23, 0x00	; 0
     cde:	0e 94 27 2e 	call	0x5c4e	; 0x5c4e <__divmodhi4>
     ce2:	88 27       	eor	r24, r24
     ce4:	77 fd       	sbrc	r23, 7
     ce6:	80 95       	com	r24
     ce8:	98 2f       	mov	r25, r24
     cea:	0e 94 59 2c 	call	0x58b2	; 0x58b2 <__floatsisf>
     cee:	7b 01       	movw	r14, r22
     cf0:	8c 01       	movw	r16, r24
	float CMD_K = 0.5;
	float COR_K = 1;
	uint8_t lds_char;

	for(;;){
		robot.heading = (180 * enc_heading) / M_PI; 
     cf2:	c5 01       	movw	r24, r10
     cf4:	d6 01       	movw	r26, r12
     cf6:	80 93 40 14 	sts	0x1440, r24
     cfa:	90 93 41 14 	sts	0x1441, r25
     cfe:	a0 93 42 14 	sts	0x1442, r26
     d02:	b0 93 43 14 	sts	0x1443, r27
		robot.vel = (LEFTVel_current + (-RIGHTVel_current)) / 2;
     d06:	e0 92 44 14 	sts	0x1444, r14
     d0a:	f0 92 45 14 	sts	0x1445, r15
     d0e:	00 93 46 14 	sts	0x1446, r16
     d12:	10 93 47 14 	sts	0x1447, r17
     d16:	ed cf       	rjmp	.-38     	; 0xcf2 <vUpdatePose+0x68>

00000d18 <fwdSer_L>:
		
			//taskYIELD();
	//	}
		
}
void fwdSer_L(unsigned char c){
     d18:	98 2f       	mov	r25, r24
	static char d_flag;
	static char vel_rough[4];  //store ascii chars
	static char dis_rough[8];  //store ascii chars

		//rprintf("%c",c);
		if(c != 0xff){
     d1a:	8f 3f       	cpi	r24, 0xFF	; 255
     d1c:	09 f4       	brne	.+2      	; 0xd20 <fwdSer_L+0x8>
     d1e:	7c c0       	rjmp	.+248    	; 0xe18 <fwdSer_L+0x100>
		//if the data isn't whitespace (0xff), post it
		//	rprintf("%c",c);

			if(c == 0x0A){lf_flag = SET;} //line feed detected, the character will be a 'D' or a 'V'
     d20:	8a 30       	cpi	r24, 0x0A	; 10
     d22:	21 f4       	brne	.+8      	; 0xd2c <fwdSer_L+0x14>
     d24:	81 e0       	ldi	r24, 0x01	; 1
     d26:	80 93 14 03 	sts	0x0314, r24
     d2a:	33 c0       	rjmp	.+102    	; 0xd92 <fwdSer_L+0x7a>
	
			else if((lf_flag) && (c == 'V')){ //set velocity flag
     d2c:	80 91 14 03 	lds	r24, 0x0314
     d30:	88 23       	and	r24, r24
     d32:	91 f0       	breq	.+36     	; 0xd58 <fwdSer_L+0x40>
     d34:	96 35       	cpi	r25, 0x56	; 86
     d36:	31 f4       	brne	.+12     	; 0xd44 <fwdSer_L+0x2c>
				v_flag = SET;
     d38:	81 e0       	ldi	r24, 0x01	; 1
     d3a:	80 93 11 03 	sts	0x0311, r24
				v_iter = 0;
     d3e:	10 92 13 03 	sts	0x0313, r1
     d42:	07 c0       	rjmp	.+14     	; 0xd52 <fwdSer_L+0x3a>
				lf_flag = UNSET;
				return;
			} 
			else if((lf_flag) && (c == 'D')){ //set distance flag
     d44:	94 34       	cpi	r25, 0x44	; 68
     d46:	41 f4       	brne	.+16     	; 0xd58 <fwdSer_L+0x40>
				d_flag = SET;
     d48:	81 e0       	ldi	r24, 0x01	; 1
     d4a:	80 93 10 03 	sts	0x0310, r24
				d_iter = 0;
     d4e:	10 92 12 03 	sts	0x0312, r1
				lf_flag = UNSET;
     d52:	10 92 14 03 	sts	0x0314, r1
     d56:	08 95       	ret
			//	rprintf("%c",c);
				return;
			}
			else if(v_flag){
     d58:	80 91 11 03 	lds	r24, 0x0311
     d5c:	88 23       	and	r24, r24
     d5e:	59 f0       	breq	.+22     	; 0xd76 <fwdSer_L+0x5e>
				vel_rough[v_iter++] = c;	//store then increment	
     d60:	80 91 13 03 	lds	r24, 0x0313
     d64:	e8 2f       	mov	r30, r24
     d66:	f0 e0       	ldi	r31, 0x00	; 0
     d68:	e4 5f       	subi	r30, 0xF4	; 244
     d6a:	fc 4f       	sbci	r31, 0xFC	; 252
     d6c:	90 83       	st	Z, r25
     d6e:	8f 5f       	subi	r24, 0xFF	; 255
     d70:	80 93 13 03 	sts	0x0313, r24
     d74:	0e c0       	rjmp	.+28     	; 0xd92 <fwdSer_L+0x7a>
				//rprintf("%c",c);
			}	
			else if(d_flag){
     d76:	80 91 10 03 	lds	r24, 0x0310
     d7a:	88 23       	and	r24, r24
     d7c:	51 f0       	breq	.+20     	; 0xd92 <fwdSer_L+0x7a>
				dis_rough[d_iter++] = c;	//store then increment	
     d7e:	80 91 12 03 	lds	r24, 0x0312
     d82:	e8 2f       	mov	r30, r24
     d84:	f0 e0       	ldi	r31, 0x00	; 0
     d86:	ec 5f       	subi	r30, 0xFC	; 252
     d88:	fc 4f       	sbci	r31, 0xFC	; 252
     d8a:	90 83       	st	Z, r25
     d8c:	8f 5f       	subi	r24, 0xFF	; 255
     d8e:	80 93 12 03 	sts	0x0312, r24
			//	rprintf("%c",c);
			}

			if(v_iter == 4){
     d92:	80 91 13 03 	lds	r24, 0x0313
     d96:	84 30       	cpi	r24, 0x04	; 4
     d98:	01 f5       	brne	.+64     	; 0xdda <fwdSer_L+0xc2>
				LEFTVel_current = CM_TICK * retConv_s16(&vel_rough);
     d9a:	8c e0       	ldi	r24, 0x0C	; 12
     d9c:	93 e0       	ldi	r25, 0x03	; 3
     d9e:	0e 94 59 04 	call	0x8b2	; 0x8b2 <retConv_s16>
     da2:	aa 27       	eor	r26, r26
     da4:	97 fd       	sbrc	r25, 7
     da6:	a0 95       	com	r26
     da8:	ba 2f       	mov	r27, r26
     daa:	bc 01       	movw	r22, r24
     dac:	cd 01       	movw	r24, r26
     dae:	0e 94 59 2c 	call	0x58b2	; 0x58b2 <__floatsisf>
     db2:	20 e0       	ldi	r18, 0x00	; 0
     db4:	30 e0       	ldi	r19, 0x00	; 0
     db6:	40 e8       	ldi	r20, 0x80	; 128
     db8:	5e e3       	ldi	r21, 0x3E	; 62
     dba:	0e 94 8e 2d 	call	0x5b1c	; 0x5b1c <__mulsf3>
     dbe:	0e 94 26 2c 	call	0x584c	; 0x584c <__fixsfsi>
     dc2:	70 93 c7 02 	sts	0x02C7, r23
     dc6:	60 93 c6 02 	sts	0x02C6, r22
				v_flag = UNSET;
     dca:	10 92 11 03 	sts	0x0311, r1
				v_iter = 0;
     dce:	10 92 13 03 	sts	0x0313, r1
				LEFTVel_ready = SET;
     dd2:	81 e0       	ldi	r24, 0x01	; 1
     dd4:	80 93 c8 02 	sts	0x02C8, r24
     dd8:	08 95       	ret
			//	rprintf("LEFTVel_ready: %d\n", LEFTVel_ready);
			//	rprintf("LLL VVV: ");
			//	rprintfu16(RIGHTVel_current);
			//	rprintf("\n");
			}
			else if(d_iter == 8){
     dda:	80 91 12 03 	lds	r24, 0x0312
     dde:	88 30       	cpi	r24, 0x08	; 8
     de0:	51 f5       	brne	.+84     	; 0xe36 <fwdSer_L+0x11e>
				LEFTDis_current = CM_TICK * retConv_s32(&dis_rough);
     de2:	84 e0       	ldi	r24, 0x04	; 4
     de4:	93 e0       	ldi	r25, 0x03	; 3
     de6:	0e 94 a8 04 	call	0x950	; 0x950 <retConv_s32>
     dea:	0e 94 59 2c 	call	0x58b2	; 0x58b2 <__floatsisf>
     dee:	20 e0       	ldi	r18, 0x00	; 0
     df0:	30 e0       	ldi	r19, 0x00	; 0
     df2:	40 e8       	ldi	r20, 0x80	; 128
     df4:	5e e3       	ldi	r21, 0x3E	; 62
     df6:	0e 94 8e 2d 	call	0x5b1c	; 0x5b1c <__mulsf3>
     dfa:	0e 94 26 2c 	call	0x584c	; 0x584c <__fixsfsi>
     dfe:	60 93 c9 02 	sts	0x02C9, r22
     e02:	70 93 ca 02 	sts	0x02CA, r23
     e06:	80 93 cb 02 	sts	0x02CB, r24
     e0a:	90 93 cc 02 	sts	0x02CC, r25
			//	rprintf("dL: %d\n",dLEFTDis);
				d_flag = UNSET;
     e0e:	10 92 10 03 	sts	0x0310, r1
				d_iter = 0;
     e12:	10 92 12 03 	sts	0x0312, r1
     e16:	08 95       	ret
			//	rprintf("\n");
			}
		
		}

		else{rprintf("WR\n");}
     e18:	00 d0       	rcall	.+0      	; 0xe1a <fwdSer_L+0x102>
     e1a:	0f 92       	push	r0
     e1c:	81 e0       	ldi	r24, 0x01	; 1
     e1e:	ed b7       	in	r30, 0x3d	; 61
     e20:	fe b7       	in	r31, 0x3e	; 62
     e22:	81 83       	std	Z+1, r24	; 0x01
     e24:	86 e8       	ldi	r24, 0x86	; 134
     e26:	91 e0       	ldi	r25, 0x01	; 1
     e28:	93 83       	std	Z+3, r25	; 0x03
     e2a:	82 83       	std	Z+2, r24	; 0x02
     e2c:	0e 94 ba 27 	call	0x4f74	; 0x4f74 <rprintf1RamRom>
     e30:	0f 90       	pop	r0
     e32:	0f 90       	pop	r0
     e34:	0f 90       	pop	r0
     e36:	08 95       	ret

00000e38 <fwdSer_R>:
	int_val = ((int_val<<4) | iv8);
	return int_val;
}


void fwdSer_R(unsigned char c){
     e38:	98 2f       	mov	r25, r24
	static char d_flag;
	static char vel_rough[4];  //store ascii chars
	static char dis_rough[8];  //store ascii chars

		//rprintf("%c",c);
		if(c != 0xff){
     e3a:	8f 3f       	cpi	r24, 0xFF	; 255
     e3c:	09 f4       	brne	.+2      	; 0xe40 <fwdSer_R+0x8>
     e3e:	7c c0       	rjmp	.+248    	; 0xf38 <fwdSer_R+0x100>
		//if the data isn't whitespace (0xff), post it
		//	rprintf("%c",c);

			if(c == 0x0A){lf_flag = SET;} //line feed detected, the character will be a 'D' or a 'V'
     e40:	8a 30       	cpi	r24, 0x0A	; 10
     e42:	21 f4       	brne	.+8      	; 0xe4c <fwdSer_R+0x14>
     e44:	81 e0       	ldi	r24, 0x01	; 1
     e46:	80 93 25 03 	sts	0x0325, r24
     e4a:	33 c0       	rjmp	.+102    	; 0xeb2 <fwdSer_R+0x7a>
	
			else if((lf_flag) && (c == 'V')){ //set velocity flag
     e4c:	80 91 25 03 	lds	r24, 0x0325
     e50:	88 23       	and	r24, r24
     e52:	91 f0       	breq	.+36     	; 0xe78 <fwdSer_R+0x40>
     e54:	96 35       	cpi	r25, 0x56	; 86
     e56:	31 f4       	brne	.+12     	; 0xe64 <fwdSer_R+0x2c>
				v_flag = SET;
     e58:	81 e0       	ldi	r24, 0x01	; 1
     e5a:	80 93 22 03 	sts	0x0322, r24
				v_iter = 0;
     e5e:	10 92 24 03 	sts	0x0324, r1
     e62:	07 c0       	rjmp	.+14     	; 0xe72 <fwdSer_R+0x3a>
				lf_flag = UNSET;
				return;
			} 
			else if((lf_flag) && (c == 'D')){ //set distance flag
     e64:	94 34       	cpi	r25, 0x44	; 68
     e66:	41 f4       	brne	.+16     	; 0xe78 <fwdSer_R+0x40>
				d_flag = SET;
     e68:	81 e0       	ldi	r24, 0x01	; 1
     e6a:	80 93 21 03 	sts	0x0321, r24
				d_iter = 0;
     e6e:	10 92 23 03 	sts	0x0323, r1
				lf_flag = UNSET;
     e72:	10 92 25 03 	sts	0x0325, r1
     e76:	08 95       	ret
			//	rprintf("%c",c);
				return;
			}
			else if(v_flag){
     e78:	80 91 22 03 	lds	r24, 0x0322
     e7c:	88 23       	and	r24, r24
     e7e:	59 f0       	breq	.+22     	; 0xe96 <fwdSer_R+0x5e>
				vel_rough[v_iter++] = c;	//store then increment	
     e80:	80 91 24 03 	lds	r24, 0x0324
     e84:	e8 2f       	mov	r30, r24
     e86:	f0 e0       	ldi	r31, 0x00	; 0
     e88:	e3 5e       	subi	r30, 0xE3	; 227
     e8a:	fc 4f       	sbci	r31, 0xFC	; 252
     e8c:	90 83       	st	Z, r25
     e8e:	8f 5f       	subi	r24, 0xFF	; 255
     e90:	80 93 24 03 	sts	0x0324, r24
     e94:	0e c0       	rjmp	.+28     	; 0xeb2 <fwdSer_R+0x7a>
				//rprintf("%c",c);
			}	
			else if(d_flag){
     e96:	80 91 21 03 	lds	r24, 0x0321
     e9a:	88 23       	and	r24, r24
     e9c:	51 f0       	breq	.+20     	; 0xeb2 <fwdSer_R+0x7a>
				dis_rough[d_iter++] = c;	//store then increment	
     e9e:	80 91 23 03 	lds	r24, 0x0323
     ea2:	e8 2f       	mov	r30, r24
     ea4:	f0 e0       	ldi	r31, 0x00	; 0
     ea6:	eb 5e       	subi	r30, 0xEB	; 235
     ea8:	fc 4f       	sbci	r31, 0xFC	; 252
     eaa:	90 83       	st	Z, r25
     eac:	8f 5f       	subi	r24, 0xFF	; 255
     eae:	80 93 23 03 	sts	0x0323, r24
			//	rprintf("%c",c);
			}

			if(v_iter == 4){
     eb2:	80 91 24 03 	lds	r24, 0x0324
     eb6:	84 30       	cpi	r24, 0x04	; 4
     eb8:	01 f5       	brne	.+64     	; 0xefa <fwdSer_R+0xc2>
				RIGHTVel_current = CM_TICK * retConv_s16(&vel_rough);
     eba:	8d e1       	ldi	r24, 0x1D	; 29
     ebc:	93 e0       	ldi	r25, 0x03	; 3
     ebe:	0e 94 59 04 	call	0x8b2	; 0x8b2 <retConv_s16>
     ec2:	aa 27       	eor	r26, r26
     ec4:	97 fd       	sbrc	r25, 7
     ec6:	a0 95       	com	r26
     ec8:	ba 2f       	mov	r27, r26
     eca:	bc 01       	movw	r22, r24
     ecc:	cd 01       	movw	r24, r26
     ece:	0e 94 59 2c 	call	0x58b2	; 0x58b2 <__floatsisf>
     ed2:	20 e0       	ldi	r18, 0x00	; 0
     ed4:	30 e0       	ldi	r19, 0x00	; 0
     ed6:	40 e8       	ldi	r20, 0x80	; 128
     ed8:	5e e3       	ldi	r21, 0x3E	; 62
     eda:	0e 94 8e 2d 	call	0x5b1c	; 0x5b1c <__mulsf3>
     ede:	0e 94 26 2c 	call	0x584c	; 0x584c <__fixsfsi>
     ee2:	70 93 d4 02 	sts	0x02D4, r23
     ee6:	60 93 d3 02 	sts	0x02D3, r22
				v_flag = UNSET;
     eea:	10 92 22 03 	sts	0x0322, r1
				v_iter = 0;
     eee:	10 92 24 03 	sts	0x0324, r1
				RIGHTVel_ready = SET;
     ef2:	81 e0       	ldi	r24, 0x01	; 1
     ef4:	80 93 d5 02 	sts	0x02D5, r24
     ef8:	08 95       	ret

			//	rprintf("RRR VVV: ");
			//	rprintfu16(RIGHTVel_current);
			//	rprintf("\n");
			}
			else if(d_iter == 8){
     efa:	80 91 23 03 	lds	r24, 0x0323
     efe:	88 30       	cpi	r24, 0x08	; 8
     f00:	51 f5       	brne	.+84     	; 0xf56 <fwdSer_R+0x11e>
				RIGHTDis_current = CM_TICK * retConv_s32(&dis_rough);
     f02:	85 e1       	ldi	r24, 0x15	; 21
     f04:	93 e0       	ldi	r25, 0x03	; 3
     f06:	0e 94 a8 04 	call	0x950	; 0x950 <retConv_s32>
     f0a:	0e 94 59 2c 	call	0x58b2	; 0x58b2 <__floatsisf>
     f0e:	20 e0       	ldi	r18, 0x00	; 0
     f10:	30 e0       	ldi	r19, 0x00	; 0
     f12:	40 e8       	ldi	r20, 0x80	; 128
     f14:	5e e3       	ldi	r21, 0x3E	; 62
     f16:	0e 94 8e 2d 	call	0x5b1c	; 0x5b1c <__mulsf3>
     f1a:	0e 94 26 2c 	call	0x584c	; 0x584c <__fixsfsi>
     f1e:	60 93 d6 02 	sts	0x02D6, r22
     f22:	70 93 d7 02 	sts	0x02D7, r23
     f26:	80 93 d8 02 	sts	0x02D8, r24
     f2a:	90 93 d9 02 	sts	0x02D9, r25
				//rprintf("dR: %d\n",dRIGHTDis);
				d_flag = UNSET;
     f2e:	10 92 21 03 	sts	0x0321, r1
				d_iter = 0;
     f32:	10 92 23 03 	sts	0x0323, r1
     f36:	08 95       	ret
				//rprintf("\n");
			}
		
		}

		else{rprintf("WR\n");}
     f38:	00 d0       	rcall	.+0      	; 0xf3a <fwdSer_R+0x102>
     f3a:	0f 92       	push	r0
     f3c:	81 e0       	ldi	r24, 0x01	; 1
     f3e:	ed b7       	in	r30, 0x3d	; 61
     f40:	fe b7       	in	r31, 0x3e	; 62
     f42:	81 83       	std	Z+1, r24	; 0x01
     f44:	8a e8       	ldi	r24, 0x8A	; 138
     f46:	91 e0       	ldi	r25, 0x01	; 1
     f48:	93 83       	std	Z+3, r25	; 0x03
     f4a:	82 83       	std	Z+2, r24	; 0x02
     f4c:	0e 94 ba 27 	call	0x4f74	; 0x4f74 <rprintf1RamRom>
     f50:	0f 90       	pop	r0
     f52:	0f 90       	pop	r0
     f54:	0f 90       	pop	r0
     f56:	08 95       	ret

00000f58 <vScript>:
		
	}

}

void vScript(){
     f58:	3f 92       	push	r3
     f5a:	4f 92       	push	r4
     f5c:	5f 92       	push	r5
     f5e:	6f 92       	push	r6
     f60:	7f 92       	push	r7
     f62:	8f 92       	push	r8
     f64:	9f 92       	push	r9
     f66:	af 92       	push	r10
     f68:	bf 92       	push	r11
     f6a:	cf 92       	push	r12
     f6c:	df 92       	push	r13
     f6e:	ef 92       	push	r14
     f70:	ff 92       	push	r15
     f72:	0f 93       	push	r16
     f74:	1f 93       	push	r17
     f76:	df 93       	push	r29
     f78:	cf 93       	push	r28
     f7a:	00 d0       	rcall	.+0      	; 0xf7c <vScript+0x24>
     f7c:	cd b7       	in	r28, 0x3d	; 61
     f7e:	de b7       	in	r29, 0x3e	; 62
	const portTickType xTicksToWait = 10000 / portTICK_RATE_MS;
	portTickType xLastWakeTime;

	for(;;){
		cmd_angle = 0;
     f80:	0f 2e       	mov	r0, r31
     f82:	f0 e0       	ldi	r31, 0x00	; 0
     f84:	af 2e       	mov	r10, r31
     f86:	f0 e0       	ldi	r31, 0x00	; 0
     f88:	bf 2e       	mov	r11, r31
     f8a:	f0 e0       	ldi	r31, 0x00	; 0
     f8c:	cf 2e       	mov	r12, r31
     f8e:	f0 e0       	ldi	r31, 0x00	; 0
     f90:	df 2e       	mov	r13, r31
     f92:	f0 2d       	mov	r31, r0
		rprintf("cmd_angle: ");
     f94:	33 24       	eor	r3, r3
     f96:	33 94       	inc	r3
     f98:	b1 e4       	ldi	r27, 0x41	; 65
     f9a:	4b 2e       	mov	r4, r27
     f9c:	b1 e0       	ldi	r27, 0x01	; 1
     f9e:	5b 2e       	mov	r5, r27
		rprintfFloat(5, cmd_angle);
		rprintfCRLF();
		vTaskDelayUntil(&xLastWakeTime, xTicksToWait);
     fa0:	4e 01       	movw	r8, r28
     fa2:	08 94       	sec
     fa4:	81 1c       	adc	r8, r1
     fa6:	91 1c       	adc	r9, r1
		cmd_angle = 90*(M_PI/180);
     fa8:	0f 2e       	mov	r0, r31
     faa:	fb ed       	ldi	r31, 0xDB	; 219
     fac:	ef 2e       	mov	r14, r31
     fae:	ff e0       	ldi	r31, 0x0F	; 15
     fb0:	ff 2e       	mov	r15, r31
     fb2:	f9 ec       	ldi	r31, 0xC9	; 201
     fb4:	0f 2f       	mov	r16, r31
     fb6:	ff e3       	ldi	r31, 0x3F	; 63
     fb8:	1f 2f       	mov	r17, r31
     fba:	f0 2d       	mov	r31, r0
		rprintf("cmd_angle: ");
     fbc:	a5 e3       	ldi	r26, 0x35	; 53
     fbe:	6a 2e       	mov	r6, r26
     fc0:	a1 e0       	ldi	r26, 0x01	; 1
     fc2:	7a 2e       	mov	r7, r26
void vScript(){
	const portTickType xTicksToWait = 10000 / portTICK_RATE_MS;
	portTickType xLastWakeTime;

	for(;;){
		cmd_angle = 0;
     fc4:	a0 92 ec 02 	sts	0x02EC, r10
     fc8:	b0 92 ed 02 	sts	0x02ED, r11
     fcc:	c0 92 ee 02 	sts	0x02EE, r12
     fd0:	d0 92 ef 02 	sts	0x02EF, r13
		rprintf("cmd_angle: ");
     fd4:	00 d0       	rcall	.+0      	; 0xfd6 <vScript+0x7e>
     fd6:	0f 92       	push	r0
     fd8:	ed b7       	in	r30, 0x3d	; 61
     fda:	fe b7       	in	r31, 0x3e	; 62
     fdc:	31 82       	std	Z+1, r3	; 0x01
     fde:	53 82       	std	Z+3, r5	; 0x03
     fe0:	42 82       	std	Z+2, r4	; 0x02
     fe2:	0e 94 ba 27 	call	0x4f74	; 0x4f74 <rprintf1RamRom>
		rprintfFloat(5, cmd_angle);
     fe6:	0f 90       	pop	r0
     fe8:	0f 90       	pop	r0
     fea:	0f 90       	pop	r0
     fec:	40 91 ec 02 	lds	r20, 0x02EC
     ff0:	50 91 ed 02 	lds	r21, 0x02ED
     ff4:	60 91 ee 02 	lds	r22, 0x02EE
     ff8:	70 91 ef 02 	lds	r23, 0x02EF
     ffc:	85 e0       	ldi	r24, 0x05	; 5
     ffe:	0e 94 f1 26 	call	0x4de2	; 0x4de2 <rprintfFloat>
		rprintfCRLF();
    1002:	0e 94 fa 25 	call	0x4bf4	; 0x4bf4 <rprintfCRLF>
		vTaskDelayUntil(&xLastWakeTime, xTicksToWait);
    1006:	c4 01       	movw	r24, r8
    1008:	60 e1       	ldi	r22, 0x10	; 16
    100a:	77 e2       	ldi	r23, 0x27	; 39
    100c:	0e 94 b0 13 	call	0x2760	; 0x2760 <vTaskDelayUntil>
		cmd_angle = 90*(M_PI/180);
    1010:	e0 92 ec 02 	sts	0x02EC, r14
    1014:	f0 92 ed 02 	sts	0x02ED, r15
    1018:	00 93 ee 02 	sts	0x02EE, r16
    101c:	10 93 ef 02 	sts	0x02EF, r17
		rprintf("cmd_angle: ");
    1020:	00 d0       	rcall	.+0      	; 0x1022 <vScript+0xca>
    1022:	0f 92       	push	r0
    1024:	ed b7       	in	r30, 0x3d	; 61
    1026:	fe b7       	in	r31, 0x3e	; 62
    1028:	31 82       	std	Z+1, r3	; 0x01
    102a:	73 82       	std	Z+3, r7	; 0x03
    102c:	62 82       	std	Z+2, r6	; 0x02
    102e:	0e 94 ba 27 	call	0x4f74	; 0x4f74 <rprintf1RamRom>
		rprintfFloat(5, cmd_angle);
    1032:	0f 90       	pop	r0
    1034:	0f 90       	pop	r0
    1036:	0f 90       	pop	r0
    1038:	40 91 ec 02 	lds	r20, 0x02EC
    103c:	50 91 ed 02 	lds	r21, 0x02ED
    1040:	60 91 ee 02 	lds	r22, 0x02EE
    1044:	70 91 ef 02 	lds	r23, 0x02EF
    1048:	85 e0       	ldi	r24, 0x05	; 5
    104a:	0e 94 f1 26 	call	0x4de2	; 0x4de2 <rprintfFloat>
		rprintfCRLF();
    104e:	0e 94 fa 25 	call	0x4bf4	; 0x4bf4 <rprintfCRLF>
		vTaskDelayUntil(&xLastWakeTime, xTicksToWait);
    1052:	c4 01       	movw	r24, r8
    1054:	60 e1       	ldi	r22, 0x10	; 16
    1056:	77 e2       	ldi	r23, 0x27	; 39
    1058:	0e 94 b0 13 	call	0x2760	; 0x2760 <vTaskDelayUntil>
    105c:	b3 cf       	rjmp	.-154    	; 0xfc4 <vScript+0x6c>

0000105e <vLight1On>:
		PORT_OFF(PORTA, 0);
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
		
	}
}
void vLight1On(void *pvParameters){
    105e:	0f 93       	push	r16
    1060:	1f 93       	push	r17
    1062:	df 93       	push	r29
    1064:	cf 93       	push	r28
    1066:	00 d0       	rcall	.+0      	; 0x1068 <vLight1On+0xa>
    1068:	cd b7       	in	r28, 0x3d	; 61
    106a:	de b7       	in	r29, 0x3e	; 62
	portTickType xLastWakeTime;
	for(;;){
		LED_on();
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
    106c:	8e 01       	movw	r16, r28
    106e:	0f 5f       	subi	r16, 0xFF	; 255
    1070:	1f 4f       	sbci	r17, 0xFF	; 255
//***************STATUS LED**************
//tank test
void LED_off(void)
	{PORT_ON(PORTB,6);}
void LED_on(void)
	{PORT_OFF(PORTB,6);}
    1072:	2e 98       	cbi	0x05, 6	; 5
    1074:	c8 01       	movw	r24, r16
    1076:	62 e3       	ldi	r22, 0x32	; 50
    1078:	70 e0       	ldi	r23, 0x00	; 0
    107a:	0e 94 b0 13 	call	0x2760	; 0x2760 <vTaskDelayUntil>


//***************STATUS LED**************
//tank test
void LED_off(void)
	{PORT_ON(PORTB,6);}
    107e:	2e 9a       	sbi	0x05, 6	; 5
		LED_off();
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));	}
    1080:	c8 01       	movw	r24, r16
    1082:	62 e3       	ldi	r22, 0x32	; 50
    1084:	70 e0       	ldi	r23, 0x00	; 0
    1086:	0e 94 b0 13 	call	0x2760	; 0x2760 <vTaskDelayUntil>
    108a:	f3 cf       	rjmp	.-26     	; 0x1072 <vLight1On+0x14>

0000108c <vLight0On>:
		vTaskDelayUntil(&xLastWakeTime, (1 / portTICK_RATE_MS));
	}

}

void vLight0On(void *pvParameters){
    108c:	0f 93       	push	r16
    108e:	1f 93       	push	r17
    1090:	df 93       	push	r29
    1092:	cf 93       	push	r28
    1094:	00 d0       	rcall	.+0      	; 0x1096 <vLight0On+0xa>
    1096:	cd b7       	in	r28, 0x3d	; 61
    1098:	de b7       	in	r29, 0x3e	; 62
	portTickType xLastWakeTime;
	for(;;){
		PORT_ON(PORTA, 0);
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
    109a:	8e 01       	movw	r16, r28
    109c:	0f 5f       	subi	r16, 0xFF	; 255
    109e:	1f 4f       	sbci	r17, 0xFF	; 255
}

void vLight0On(void *pvParameters){
	portTickType xLastWakeTime;
	for(;;){
		PORT_ON(PORTA, 0);
    10a0:	10 9a       	sbi	0x02, 0	; 2
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
    10a2:	c8 01       	movw	r24, r16
    10a4:	62 e3       	ldi	r22, 0x32	; 50
    10a6:	70 e0       	ldi	r23, 0x00	; 0
    10a8:	0e 94 b0 13 	call	0x2760	; 0x2760 <vTaskDelayUntil>
		//taskYIELD();	
		PORT_OFF(PORTA, 0);
    10ac:	10 98       	cbi	0x02, 0	; 2
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
    10ae:	c8 01       	movw	r24, r16
    10b0:	62 e3       	ldi	r22, 0x32	; 50
    10b2:	70 e0       	ldi	r23, 0x00	; 0
    10b4:	0e 94 b0 13 	call	0x2760	; 0x2760 <vTaskDelayUntil>
    10b8:	f3 cf       	rjmp	.-26     	; 0x10a0 <vLight0On+0x14>

000010ba <vEnc_UpdatePose>:
	uart3SendByte('\n'); //line feed
}



void vEnc_UpdatePose(){
    10ba:	af 92       	push	r10
    10bc:	bf 92       	push	r11
    10be:	df 92       	push	r13
    10c0:	ef 92       	push	r14
    10c2:	ff 92       	push	r15
    10c4:	0f 93       	push	r16
    10c6:	1f 93       	push	r17
    10c8:	df 93       	push	r29
    10ca:	cf 93       	push	r28
    10cc:	00 d0       	rcall	.+0      	; 0x10ce <vEnc_UpdatePose+0x14>
    10ce:	cd b7       	in	r28, 0x3d	; 61
    10d0:	de b7       	in	r29, 0x3e	; 62
	portTickType xLastWakeTime;
	float elapsed_time;
	reset_timer0();
    10d2:	0e 94 ee 19 	call	0x33dc	; 0x33dc <reset_timer0>
		taskEXIT_CRITICAL();
		*/

		}
		
	vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
    10d6:	5e 01       	movw	r10, r28
    10d8:	08 94       	sec
    10da:	a1 1c       	adc	r10, r1
    10dc:	b1 1c       	adc	r11, r1
	portTickType xLastWakeTime;
	float elapsed_time;
	reset_timer0();

	for(;;){
		if(LEFTVel_ready || RIGHTVel_ready){
    10de:	80 91 c8 02 	lds	r24, 0x02C8
    10e2:	88 23       	and	r24, r24
    10e4:	29 f4       	brne	.+10     	; 0x10f0 <vEnc_UpdatePose+0x36>
    10e6:	80 91 d5 02 	lds	r24, 0x02D5
    10ea:	88 23       	and	r24, r24
    10ec:	09 f4       	brne	.+2      	; 0x10f0 <vEnc_UpdatePose+0x36>
    10ee:	a4 c0       	rjmp	.+328    	; 0x1238 <vEnc_UpdatePose+0x17e>
		//The below formula yields the encoder calculated angular velocity of the robot
		//as it rotates about some ICC(Instantaneous Center of Curvature)
		
		enc_ang_vel = ((-RIGHTVel_current) - LEFTVel_current) / ROBOT_DIAMETER;
    10f0:	60 91 d3 02 	lds	r22, 0x02D3
    10f4:	70 91 d4 02 	lds	r23, 0x02D4
    10f8:	70 95       	com	r23
    10fa:	61 95       	neg	r22
    10fc:	7f 4f       	sbci	r23, 0xFF	; 255
    10fe:	20 91 c6 02 	lds	r18, 0x02C6
    1102:	30 91 c7 02 	lds	r19, 0x02C7
    1106:	62 1b       	sub	r22, r18
    1108:	73 0b       	sbc	r23, r19
    110a:	88 27       	eor	r24, r24
    110c:	77 fd       	sbrc	r23, 7
    110e:	80 95       	com	r24
    1110:	98 2f       	mov	r25, r24
    1112:	0e 94 59 2c 	call	0x58b2	; 0x58b2 <__floatsisf>
    1116:	26 e6       	ldi	r18, 0x66	; 102
    1118:	36 e6       	ldi	r19, 0x66	; 102
    111a:	46 e8       	ldi	r20, 0x86	; 134
    111c:	51 e4       	ldi	r21, 0x41	; 65
    111e:	0e 94 be 2b 	call	0x577c	; 0x577c <__divsf3>
    1122:	60 93 e4 02 	sts	0x02E4, r22
    1126:	70 93 e5 02 	sts	0x02E5, r23
    112a:	80 93 e6 02 	sts	0x02E6, r24
    112e:	90 93 e7 02 	sts	0x02E7, r25
		
		//elapsed_time = ((get_timer0_overflow()*255 + TCNT0) * 0.256) / 1000;
		elapsed_time = ((get_timer0_overflow()*255 + TCNT0) * 0.0633) / 1000;
    1132:	0e 94 8f 19 	call	0x331e	; 0x331e <get_timer0_overflow>
    1136:	7b 01       	movw	r14, r22
    1138:	8c 01       	movw	r16, r24
    113a:	d6 b4       	in	r13, 0x26	; 38
		reset_timer0();
    113c:	0e 94 ee 19 	call	0x33dc	; 0x33dc <reset_timer0>
		//dRL = dRIGHTDis - dLEFTDis;
		//dis_enc_heading += sin((dRL)/ ROBOT_DIAMETER);
		//dRIGHTDis = dLEFTDis = 0;
		enc_heading += enc_ang_vel * elapsed_time;
    1140:	c8 01       	movw	r24, r16
    1142:	b7 01       	movw	r22, r14
    1144:	2f ef       	ldi	r18, 0xFF	; 255
    1146:	30 e0       	ldi	r19, 0x00	; 0
    1148:	40 e0       	ldi	r20, 0x00	; 0
    114a:	50 e0       	ldi	r21, 0x00	; 0
    114c:	0e 94 f4 2d 	call	0x5be8	; 0x5be8 <__mulsi3>
    1150:	6d 0d       	add	r22, r13
    1152:	71 1d       	adc	r23, r1
    1154:	81 1d       	adc	r24, r1
    1156:	91 1d       	adc	r25, r1
    1158:	0e 94 57 2c 	call	0x58ae	; 0x58ae <__floatunsisf>
    115c:	2e e6       	ldi	r18, 0x6E	; 110
    115e:	33 ea       	ldi	r19, 0xA3	; 163
    1160:	41 e8       	ldi	r20, 0x81	; 129
    1162:	5d e3       	ldi	r21, 0x3D	; 61
    1164:	0e 94 8e 2d 	call	0x5b1c	; 0x5b1c <__mulsf3>
    1168:	20 e0       	ldi	r18, 0x00	; 0
    116a:	30 e0       	ldi	r19, 0x00	; 0
    116c:	4a e7       	ldi	r20, 0x7A	; 122
    116e:	54 e4       	ldi	r21, 0x44	; 68
    1170:	0e 94 be 2b 	call	0x577c	; 0x577c <__divsf3>
    1174:	20 91 e4 02 	lds	r18, 0x02E4
    1178:	30 91 e5 02 	lds	r19, 0x02E5
    117c:	40 91 e6 02 	lds	r20, 0x02E6
    1180:	50 91 e7 02 	lds	r21, 0x02E7
    1184:	0e 94 8e 2d 	call	0x5b1c	; 0x5b1c <__mulsf3>
    1188:	20 91 e0 02 	lds	r18, 0x02E0
    118c:	30 91 e1 02 	lds	r19, 0x02E1
    1190:	40 91 e2 02 	lds	r20, 0x02E2
    1194:	50 91 e3 02 	lds	r21, 0x02E3
    1198:	0e 94 f4 2a 	call	0x55e8	; 0x55e8 <__addsf3>
    119c:	7b 01       	movw	r14, r22
    119e:	8c 01       	movw	r16, r24
		// Limit the heading to 2pi
		enc_heading -= 2*M_PI*(1 + floor((enc_heading-M_PI)/(2*M_PI)));
    11a0:	2b ed       	ldi	r18, 0xDB	; 219
    11a2:	3f e0       	ldi	r19, 0x0F	; 15
    11a4:	49 e4       	ldi	r20, 0x49	; 73
    11a6:	50 e4       	ldi	r21, 0x40	; 64
    11a8:	0e 94 f3 2a 	call	0x55e6	; 0x55e6 <__subsf3>
    11ac:	2b ed       	ldi	r18, 0xDB	; 219
    11ae:	3f e0       	ldi	r19, 0x0F	; 15
    11b0:	49 ec       	ldi	r20, 0xC9	; 201
    11b2:	50 e4       	ldi	r21, 0x40	; 64
    11b4:	0e 94 be 2b 	call	0x577c	; 0x577c <__divsf3>
    11b8:	0e 94 94 2c 	call	0x5928	; 0x5928 <floor>
    11bc:	20 e0       	ldi	r18, 0x00	; 0
    11be:	30 e0       	ldi	r19, 0x00	; 0
    11c0:	40 e8       	ldi	r20, 0x80	; 128
    11c2:	5f e3       	ldi	r21, 0x3F	; 63
    11c4:	0e 94 f4 2a 	call	0x55e8	; 0x55e8 <__addsf3>
    11c8:	2b ed       	ldi	r18, 0xDB	; 219
    11ca:	3f e0       	ldi	r19, 0x0F	; 15
    11cc:	49 ec       	ldi	r20, 0xC9	; 201
    11ce:	50 ec       	ldi	r21, 0xC0	; 192
    11d0:	0e 94 8e 2d 	call	0x5b1c	; 0x5b1c <__mulsf3>
    11d4:	9b 01       	movw	r18, r22
    11d6:	ac 01       	movw	r20, r24
    11d8:	c8 01       	movw	r24, r16
    11da:	b7 01       	movw	r22, r14
    11dc:	0e 94 f4 2a 	call	0x55e8	; 0x55e8 <__addsf3>
    11e0:	60 93 e0 02 	sts	0x02E0, r22
    11e4:	70 93 e1 02 	sts	0x02E1, r23
    11e8:	80 93 e2 02 	sts	0x02E2, r24
    11ec:	90 93 e3 02 	sts	0x02E3, r25
		//cmd_ang_vel = 3*pow(cmd_angle - enc_heading,2)/(pow(cmd_angle - enc_heading,2) + pow(3,2));
		cmd_ang_vel = -0.5*atan2(1*(enc_heading - cmd_angle) +0,1);
    11f0:	20 91 ec 02 	lds	r18, 0x02EC
    11f4:	30 91 ed 02 	lds	r19, 0x02ED
    11f8:	40 91 ee 02 	lds	r20, 0x02EE
    11fc:	50 91 ef 02 	lds	r21, 0x02EF
    1200:	0e 94 f3 2a 	call	0x55e6	; 0x55e6 <__subsf3>
    1204:	20 e0       	ldi	r18, 0x00	; 0
    1206:	30 e0       	ldi	r19, 0x00	; 0
    1208:	40 e0       	ldi	r20, 0x00	; 0
    120a:	50 e0       	ldi	r21, 0x00	; 0
    120c:	0e 94 f4 2a 	call	0x55e8	; 0x55e8 <__addsf3>
    1210:	20 e0       	ldi	r18, 0x00	; 0
    1212:	30 e0       	ldi	r19, 0x00	; 0
    1214:	40 e8       	ldi	r20, 0x80	; 128
    1216:	5f e3       	ldi	r21, 0x3F	; 63
    1218:	0e 94 67 2b 	call	0x56ce	; 0x56ce <atan2>
    121c:	20 e0       	ldi	r18, 0x00	; 0
    121e:	30 e0       	ldi	r19, 0x00	; 0
    1220:	40 e0       	ldi	r20, 0x00	; 0
    1222:	5f eb       	ldi	r21, 0xBF	; 191
    1224:	0e 94 8e 2d 	call	0x5b1c	; 0x5b1c <__mulsf3>
    1228:	60 93 f0 02 	sts	0x02F0, r22
    122c:	70 93 f1 02 	sts	0x02F1, r23
    1230:	80 93 f2 02 	sts	0x02F2, r24
    1234:	90 93 f3 02 	sts	0x02F3, r25
		taskEXIT_CRITICAL();
		*/

		}
		
	vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
    1238:	c5 01       	movw	r24, r10
    123a:	62 e3       	ldi	r22, 0x32	; 50
    123c:	70 e0       	ldi	r23, 0x00	; 0
    123e:	0e 94 b0 13 	call	0x2760	; 0x2760 <vTaskDelayUntil>
    1242:	4d cf       	rjmp	.-358    	; 0x10de <vEnc_UpdatePose+0x24>

00001244 <send_frame>:
	}
	return c;
}


void send_frame(char flag, int16_t data){
    1244:	ff 92       	push	r15
    1246:	0f 93       	push	r16
    1248:	1f 93       	push	r17
    124a:	cf 93       	push	r28
    124c:	df 93       	push	r29
    124e:	eb 01       	movw	r28, r22
	uint8_t r1 = 0;
	uint8_t r2 = 0;
	uint8_t r3 = 0;
	uint8_t r4 = 0;

	uart3SendByte(flag);
    1250:	0e 94 af 20 	call	0x415e	; 0x415e <uart3SendByte>

	r1 = num2char(0x0F & (uint8_t)data);
    1254:	3f e0       	ldi	r19, 0x0F	; 15
    1256:	f3 2e       	mov	r15, r19
    1258:	fc 22       	and	r15, r28



char num2char(char c){
	
	if(c <10){
    125a:	89 e0       	ldi	r24, 0x09	; 9
    125c:	8f 15       	cp	r24, r15
    125e:	18 f0       	brcs	.+6      	; 0x1266 <send_frame+0x22>
		c += 48;
    1260:	90 e3       	ldi	r25, 0x30	; 48
    1262:	f9 0e       	add	r15, r25
    1264:	06 c0       	rjmp	.+12     	; 0x1272 <send_frame+0x2e>
	}
	else if((c >= 10) && (c <= 16)){
    1266:	8f 2d       	mov	r24, r15
    1268:	8a 50       	subi	r24, 0x0A	; 10
    126a:	87 30       	cpi	r24, 0x07	; 7
    126c:	10 f4       	brcc	.+4      	; 0x1272 <send_frame+0x2e>
		c += 55;
    126e:	87 e3       	ldi	r24, 0x37	; 55
    1270:	f8 0e       	add	r15, r24
	uint8_t r4 = 0;

	uart3SendByte(flag);

	r1 = num2char(0x0F & (uint8_t)data);
	r2 = num2char(0x0F & ((uint8_t)(data >> 4)) );
    1272:	ce 01       	movw	r24, r28
    1274:	24 e0       	ldi	r18, 0x04	; 4
    1276:	95 95       	asr	r25
    1278:	87 95       	ror	r24
    127a:	2a 95       	dec	r18
    127c:	e1 f7       	brne	.-8      	; 0x1276 <send_frame+0x32>
    127e:	08 2f       	mov	r16, r24
    1280:	0f 70       	andi	r16, 0x0F	; 15



char num2char(char c){
	
	if(c <10){
    1282:	0a 30       	cpi	r16, 0x0A	; 10
    1284:	10 f4       	brcc	.+4      	; 0x128a <send_frame+0x46>
		c += 48;
    1286:	00 5d       	subi	r16, 0xD0	; 208
    1288:	05 c0       	rjmp	.+10     	; 0x1294 <send_frame+0x50>
	}
	else if((c >= 10) && (c <= 16)){
    128a:	80 2f       	mov	r24, r16
    128c:	8a 50       	subi	r24, 0x0A	; 10
    128e:	87 30       	cpi	r24, 0x07	; 7
    1290:	08 f4       	brcc	.+2      	; 0x1294 <send_frame+0x50>
		c += 55;
    1292:	09 5c       	subi	r16, 0xC9	; 201

	uart3SendByte(flag);

	r1 = num2char(0x0F & (uint8_t)data);
	r2 = num2char(0x0F & ((uint8_t)(data >> 4)) );
	r3 = num2char(0x0F & ((uint8_t)(data >> 8)) );
    1294:	8d 2f       	mov	r24, r29
    1296:	99 27       	eor	r25, r25
    1298:	87 fd       	sbrc	r24, 7
    129a:	9a 95       	dec	r25
    129c:	18 2f       	mov	r17, r24
    129e:	1f 70       	andi	r17, 0x0F	; 15



char num2char(char c){
	
	if(c <10){
    12a0:	1a 30       	cpi	r17, 0x0A	; 10
    12a2:	10 f4       	brcc	.+4      	; 0x12a8 <send_frame+0x64>
		c += 48;
    12a4:	10 5d       	subi	r17, 0xD0	; 208
    12a6:	05 c0       	rjmp	.+10     	; 0x12b2 <send_frame+0x6e>
	}
	else if((c >= 10) && (c <= 16)){
    12a8:	81 2f       	mov	r24, r17
    12aa:	8a 50       	subi	r24, 0x0A	; 10
    12ac:	87 30       	cpi	r24, 0x07	; 7
    12ae:	08 f4       	brcc	.+2      	; 0x12b2 <send_frame+0x6e>
		c += 55;
    12b0:	19 5c       	subi	r17, 0xC9	; 201
	uart3SendByte(flag);

	r1 = num2char(0x0F & (uint8_t)data);
	r2 = num2char(0x0F & ((uint8_t)(data >> 4)) );
	r3 = num2char(0x0F & ((uint8_t)(data >> 8)) );
	r4 = num2char(0x0F & ((uint8_t)(data >> 12)) );
    12b2:	c0 e1       	ldi	r28, 0x10	; 16
    12b4:	dc 02       	muls	r29, r28
    12b6:	c1 2d       	mov	r28, r1
    12b8:	dd 0b       	sbc	r29, r29
    12ba:	11 24       	eor	r1, r1
    12bc:	ce 01       	movw	r24, r28
    12be:	8f 70       	andi	r24, 0x0F	; 15
    12c0:	68 2f       	mov	r22, r24



char num2char(char c){
	
	if(c <10){
    12c2:	8a 30       	cpi	r24, 0x0A	; 10
    12c4:	10 f4       	brcc	.+4      	; 0x12ca <send_frame+0x86>
		c += 48;
    12c6:	60 5d       	subi	r22, 0xD0	; 208
    12c8:	04 c0       	rjmp	.+8      	; 0x12d2 <send_frame+0x8e>
	}
	else if((c >= 10) && (c <= 16)){
    12ca:	8a 50       	subi	r24, 0x0A	; 10
    12cc:	87 30       	cpi	r24, 0x07	; 7
    12ce:	08 f4       	brcc	.+2      	; 0x12d2 <send_frame+0x8e>
		c += 55;
    12d0:	69 5c       	subi	r22, 0xC9	; 201
	r1 = num2char(0x0F & (uint8_t)data);
	r2 = num2char(0x0F & ((uint8_t)(data >> 4)) );
	r3 = num2char(0x0F & ((uint8_t)(data >> 8)) );
	r4 = num2char(0x0F & ((uint8_t)(data >> 12)) );

	uart3SendByte(r4);
    12d2:	86 2f       	mov	r24, r22
    12d4:	0e 94 af 20 	call	0x415e	; 0x415e <uart3SendByte>
	uart3SendByte(r3);
    12d8:	81 2f       	mov	r24, r17
    12da:	0e 94 af 20 	call	0x415e	; 0x415e <uart3SendByte>
	uart3SendByte(r2);
    12de:	80 2f       	mov	r24, r16
    12e0:	0e 94 af 20 	call	0x415e	; 0x415e <uart3SendByte>
	uart3SendByte(r1);
    12e4:	8f 2d       	mov	r24, r15
    12e6:	0e 94 af 20 	call	0x415e	; 0x415e <uart3SendByte>
	uart3SendByte('\n'); //line feed
    12ea:	8a e0       	ldi	r24, 0x0A	; 10
    12ec:	0e 94 af 20 	call	0x415e	; 0x415e <uart3SendByte>
}
    12f0:	df 91       	pop	r29
    12f2:	cf 91       	pop	r28
    12f4:	1f 91       	pop	r17
    12f6:	0f 91       	pop	r16
    12f8:	ff 90       	pop	r15
    12fa:	08 95       	ret

000012fc <vServoOsc>:
	}

}


void vServoOsc(){
    12fc:	7f 92       	push	r7
    12fe:	8f 92       	push	r8
    1300:	9f 92       	push	r9
    1302:	af 92       	push	r10
    1304:	bf 92       	push	r11
    1306:	cf 92       	push	r12
    1308:	df 92       	push	r13
    130a:	ef 92       	push	r14
    130c:	ff 92       	push	r15
    130e:	0f 93       	push	r16
    1310:	1f 93       	push	r17
    1312:	df 93       	push	r29
    1314:	cf 93       	push	r28
    1316:	00 d0       	rcall	.+0      	; 0x1318 <vServoOsc+0x1c>
    1318:	cd b7       	in	r28, 0x3d	; 61
    131a:	de b7       	in	r29, 0x3e	; 62
	sbi(TCCR4A,COM4A1);
	cbi(TCCR4A,COM4A0);
}
void PWM_timer4_On_H4(void)
{
	sbi(TCCR4A,COM4B1);
    131c:	80 91 a0 00 	lds	r24, 0x00A0
    1320:	80 62       	ori	r24, 0x20	; 32
    1322:	80 93 a0 00 	sts	0x00A0, r24
	cbi(TCCR4A,COM4B0);
    1326:	80 91 a0 00 	lds	r24, 0x00A0
    132a:	8f 7e       	andi	r24, 0xEF	; 239
    132c:	80 93 a0 00 	sts	0x00A0, r24
	sbi(TCCR3A,COM3C1);
	cbi(TCCR3A,COM3C0);
}
void PWM_timer4_On_H3(void)
{
	sbi(TCCR4A,COM4A1);
    1330:	80 91 a0 00 	lds	r24, 0x00A0
    1334:	80 68       	ori	r24, 0x80	; 128
    1336:	80 93 a0 00 	sts	0x00A0, r24
	cbi(TCCR4A,COM4A0);
    133a:	80 91 a0 00 	lds	r24, 0x00A0
    133e:	8f 7b       	andi	r24, 0xBF	; 191
    1340:	80 93 a0 00 	sts	0x00A0, r24
    1344:	0a e7       	ldi	r16, 0x7A	; 122
    1346:	10 e0       	ldi	r17, 0x00	; 0
void PWM_timer3_Set_E5(u16 pwmDuty)
	{OCR3C = pwmDuty;}
void PWM_timer4_Set_H3(u16 pwmDuty)
	{OCR4A = pwmDuty;}
void PWM_timer4_Set_H4(u16 pwmDuty)
	{OCR4B = pwmDuty;}
    1348:	6c ec       	ldi	r22, 0xCC	; 204
    134a:	86 2e       	mov	r8, r22
    134c:	91 2c       	mov	r9, r1
		taskENTER_CRITICAL();
	//	PWM_timer3_Set_E3(i);	//right
		PWM_timer4_Set_H3(h3duty);	//left sprayer //originally 204
		PWM_timer4_Set_H4(204);	//right sprayer
		taskEXIT_CRITICAL();
		vTaskDelayUntil(&xLastWakeTime, (spray_time / portTICK_RATE_MS));
    134e:	5e 01       	movw	r10, r28
    1350:	08 94       	sec
    1352:	a1 1c       	adc	r10, r1
    1354:	b1 1c       	adc	r11, r1
		PWM_timer4_Set_H4(135);	
		taskEXIT_CRITICAL();
		vTaskDelayUntil(&xLastWakeTime, (spray_time / portTICK_RATE_MS));
		*/

		rprintf("%d", h3duty);
    1356:	77 24       	eor	r7, r7
    1358:	73 94       	inc	r7
    135a:	5f e4       	ldi	r21, 0x4F	; 79
    135c:	c5 2e       	mov	r12, r21
    135e:	51 e0       	ldi	r21, 0x01	; 1
    1360:	d5 2e       	mov	r13, r21
		//rprintf(",");
		//rprintfNum(10, 5, 1, ' ', LEFTVel_current);
		rprintf("\n");
    1362:	4d e4       	ldi	r20, 0x4D	; 77
    1364:	e4 2e       	mov	r14, r20
    1366:	41 e0       	ldi	r20, 0x01	; 1
    1368:	f4 2e       	mov	r15, r20
	spray_R_on();
	spray_L_on();
	uint16_t h3duty = 122;

	for(;;){
		if(h3duty > 1023){ h3duty = 0;}
    136a:	84 e0       	ldi	r24, 0x04	; 4
    136c:	00 30       	cpi	r16, 0x00	; 0
    136e:	18 07       	cpc	r17, r24
    1370:	10 f0       	brcs	.+4      	; 0x1376 <vServoOsc+0x7a>
    1372:	00 e0       	ldi	r16, 0x00	; 0
    1374:	10 e0       	ldi	r17, 0x00	; 0
		taskENTER_CRITICAL();
    1376:	0f b6       	in	r0, 0x3f	; 63
    1378:	f8 94       	cli
    137a:	0f 92       	push	r0
void PWM_timer3_Set_E4(u16 pwmDuty)
	{OCR3B = pwmDuty;}
void PWM_timer3_Set_E5(u16 pwmDuty)
	{OCR3C = pwmDuty;}
void PWM_timer4_Set_H3(u16 pwmDuty)
	{OCR4A = pwmDuty;}
    137c:	10 93 a9 00 	sts	0x00A9, r17
    1380:	00 93 a8 00 	sts	0x00A8, r16
void PWM_timer4_Set_H4(u16 pwmDuty)
	{OCR4B = pwmDuty;}
    1384:	90 92 ab 00 	sts	0x00AB, r9
    1388:	80 92 aa 00 	sts	0x00AA, r8
	//	PWM_timer3_Set_E3(i);	//right
		PWM_timer4_Set_H3(h3duty);	//left sprayer //originally 204
		PWM_timer4_Set_H4(204);	//right sprayer
		taskEXIT_CRITICAL();
    138c:	0f 90       	pop	r0
    138e:	0f be       	out	0x3f, r0	; 63
		vTaskDelayUntil(&xLastWakeTime, (spray_time / portTICK_RATE_MS));
    1390:	60 91 be 02 	lds	r22, 0x02BE
    1394:	70 91 bf 02 	lds	r23, 0x02BF
    1398:	c5 01       	movw	r24, r10
    139a:	0e 94 b0 13 	call	0x2760	; 0x2760 <vTaskDelayUntil>
		adj = uart1GetByte();
    139e:	0e 94 67 23 	call	0x46ce	; 0x46ce <uart1GetByte>
		if(adj == 'p'){ h3duty++;;}
    13a2:	80 37       	cpi	r24, 0x70	; 112
    13a4:	19 f4       	brne	.+6      	; 0x13ac <vServoOsc+0xb0>
    13a6:	0f 5f       	subi	r16, 0xFF	; 255
    13a8:	1f 4f       	sbci	r17, 0xFF	; 255
    13aa:	04 c0       	rjmp	.+8      	; 0x13b4 <vServoOsc+0xb8>
		else if(adj == 'l'){ h3duty--;}
    13ac:	8c 36       	cpi	r24, 0x6C	; 108
    13ae:	11 f4       	brne	.+4      	; 0x13b4 <vServoOsc+0xb8>
    13b0:	01 50       	subi	r16, 0x01	; 1
    13b2:	10 40       	sbci	r17, 0x00	; 0
		PWM_timer4_Set_H4(135);	
		taskEXIT_CRITICAL();
		vTaskDelayUntil(&xLastWakeTime, (spray_time / portTICK_RATE_MS));
		*/

		rprintf("%d", h3duty);
    13b4:	00 d0       	rcall	.+0      	; 0x13b6 <vServoOsc+0xba>
    13b6:	00 d0       	rcall	.+0      	; 0x13b8 <vServoOsc+0xbc>
    13b8:	0f 92       	push	r0
    13ba:	ed b7       	in	r30, 0x3d	; 61
    13bc:	fe b7       	in	r31, 0x3e	; 62
    13be:	31 96       	adiw	r30, 0x01	; 1
    13c0:	ad b7       	in	r26, 0x3d	; 61
    13c2:	be b7       	in	r27, 0x3e	; 62
    13c4:	11 96       	adiw	r26, 0x01	; 1
    13c6:	7c 92       	st	X, r7
    13c8:	d2 82       	std	Z+2, r13	; 0x02
    13ca:	c1 82       	std	Z+1, r12	; 0x01
    13cc:	14 83       	std	Z+4, r17	; 0x04
    13ce:	03 83       	std	Z+3, r16	; 0x03
    13d0:	0e 94 ba 27 	call	0x4f74	; 0x4f74 <rprintf1RamRom>
		//rprintf(",");
		//rprintfNum(10, 5, 1, ' ', LEFTVel_current);
		rprintf("\n");
    13d4:	0f 90       	pop	r0
    13d6:	0f 90       	pop	r0
    13d8:	ed b7       	in	r30, 0x3d	; 61
    13da:	fe b7       	in	r31, 0x3e	; 62
    13dc:	71 82       	std	Z+1, r7	; 0x01
    13de:	f3 82       	std	Z+3, r15	; 0x03
    13e0:	e2 82       	std	Z+2, r14	; 0x02
    13e2:	0e 94 ba 27 	call	0x4f74	; 0x4f74 <rprintf1RamRom>
	
		h3duty++;
    13e6:	0f 5f       	subi	r16, 0xFF	; 255
    13e8:	1f 4f       	sbci	r17, 0xFF	; 255
    13ea:	0f 90       	pop	r0
    13ec:	0f 90       	pop	r0
    13ee:	0f 90       	pop	r0
    13f0:	bc cf       	rjmp	.-136    	; 0x136a <vServoOsc+0x6e>

000013f2 <vServoTm>:
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
		LED_off();
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));	}
}

void vServoTm(){
    13f2:	1f 93       	push	r17
    13f4:	cf 93       	push	r28
    13f6:	df 93       	push	r29
	char adj;
	for(;;){
		adj = uart1GetByte();
		if(adj == 'p'){ spray_time++;}
		else if(adj == 'l'){ spray_time--;}
		rprintf("%d\n", spray_time);
    13f8:	11 e0       	ldi	r17, 0x01	; 1
    13fa:	c2 e5       	ldi	r28, 0x52	; 82
    13fc:	d1 e0       	ldi	r29, 0x01	; 1
}

void vServoTm(){
	char adj;
	for(;;){
		adj = uart1GetByte();
    13fe:	0e 94 67 23 	call	0x46ce	; 0x46ce <uart1GetByte>
		if(adj == 'p'){ spray_time++;}
    1402:	80 37       	cpi	r24, 0x70	; 112
    1404:	31 f4       	brne	.+12     	; 0x1412 <vServoTm+0x20>
    1406:	80 91 be 02 	lds	r24, 0x02BE
    140a:	90 91 bf 02 	lds	r25, 0x02BF
    140e:	01 96       	adiw	r24, 0x01	; 1
    1410:	07 c0       	rjmp	.+14     	; 0x1420 <vServoTm+0x2e>
		else if(adj == 'l'){ spray_time--;}
    1412:	8c 36       	cpi	r24, 0x6C	; 108
    1414:	49 f4       	brne	.+18     	; 0x1428 <vServoTm+0x36>
    1416:	80 91 be 02 	lds	r24, 0x02BE
    141a:	90 91 bf 02 	lds	r25, 0x02BF
    141e:	01 97       	sbiw	r24, 0x01	; 1
    1420:	90 93 bf 02 	sts	0x02BF, r25
    1424:	80 93 be 02 	sts	0x02BE, r24
		rprintf("%d\n", spray_time);
    1428:	00 d0       	rcall	.+0      	; 0x142a <vServoTm+0x38>
    142a:	00 d0       	rcall	.+0      	; 0x142c <vServoTm+0x3a>
    142c:	0f 92       	push	r0
    142e:	ed b7       	in	r30, 0x3d	; 61
    1430:	fe b7       	in	r31, 0x3e	; 62
    1432:	31 96       	adiw	r30, 0x01	; 1
    1434:	ad b7       	in	r26, 0x3d	; 61
    1436:	be b7       	in	r27, 0x3e	; 62
    1438:	11 96       	adiw	r26, 0x01	; 1
    143a:	1c 93       	st	X, r17
    143c:	d2 83       	std	Z+2, r29	; 0x02
    143e:	c1 83       	std	Z+1, r28	; 0x01
    1440:	80 91 be 02 	lds	r24, 0x02BE
    1444:	90 91 bf 02 	lds	r25, 0x02BF
    1448:	94 83       	std	Z+4, r25	; 0x04
    144a:	83 83       	std	Z+3, r24	; 0x03
    144c:	0e 94 ba 27 	call	0x4f74	; 0x4f74 <rprintf1RamRom>
    1450:	0f 90       	pop	r0
    1452:	0f 90       	pop	r0
    1454:	0f 90       	pop	r0
    1456:	0f 90       	pop	r0
    1458:	0f 90       	pop	r0
    145a:	d1 cf       	rjmp	.-94     	; 0x13fe <vServoTm+0xc>

0000145c <vPID>:


}


void vPID(void* pvParameters){
    145c:	2f 92       	push	r2
    145e:	3f 92       	push	r3
    1460:	4f 92       	push	r4
    1462:	5f 92       	push	r5
    1464:	6f 92       	push	r6
    1466:	7f 92       	push	r7
    1468:	8f 92       	push	r8
    146a:	9f 92       	push	r9
    146c:	af 92       	push	r10
    146e:	bf 92       	push	r11
    1470:	cf 92       	push	r12
    1472:	df 92       	push	r13
    1474:	ef 92       	push	r14
    1476:	ff 92       	push	r15
    1478:	0f 93       	push	r16
    147a:	1f 93       	push	r17
    147c:	df 93       	push	r29
    147e:	cf 93       	push	r28
    1480:	cd b7       	in	r28, 0x3d	; 61
    1482:	de b7       	in	r29, 0x3e	; 62
    1484:	62 97       	sbiw	r28, 0x12	; 18
    1486:	0f b6       	in	r0, 0x3f	; 63
    1488:	f8 94       	cli
    148a:	de bf       	out	0x3e, r29	; 62
    148c:	0f be       	out	0x3f, r0	; 63
    148e:	cd bf       	out	0x3d, r28	; 61
	sbi(TCCR3A,COM3A1);
	cbi(TCCR3A,COM3A0);
}
void PWM_timer3_On_E4(void)
{
	sbi(TCCR3A,COM3B1);
    1490:	80 91 90 00 	lds	r24, 0x0090
    1494:	80 62       	ori	r24, 0x20	; 32
    1496:	80 93 90 00 	sts	0x0090, r24
	cbi(TCCR3A,COM3B0);
    149a:	80 91 90 00 	lds	r24, 0x0090
    149e:	8f 7e       	andi	r24, 0xEF	; 239
    14a0:	80 93 90 00 	sts	0x0090, r24
	sbi(TCCR2A,COM2B1);
	cbi(TCCR2A,COM2B0);
}
void PWM_timer3_On_E3(void)
{
	sbi(TCCR3A,COM3A1);
    14a4:	80 91 90 00 	lds	r24, 0x0090
    14a8:	80 68       	ori	r24, 0x80	; 128
    14aa:	80 93 90 00 	sts	0x0090, r24
	cbi(TCCR3A,COM3A0);
    14ae:	80 91 90 00 	lds	r24, 0x0090
    14b2:	8f 7b       	andi	r24, 0xBF	; 191
    14b4:	80 93 90 00 	sts	0x0090, r24
	float dt = 0;
	
	wheel_L_on();
	wheel_R_on();

	reset_timer2();
    14b8:	0e 94 05 1a 	call	0x340a	; 0x340a <reset_timer2>
    14bc:	80 e0       	ldi	r24, 0x00	; 0
    14be:	90 e0       	ldi	r25, 0x00	; 0
    14c0:	a0 e0       	ldi	r26, 0x00	; 0
    14c2:	b0 e0       	ldi	r27, 0x00	; 0
    14c4:	8f 87       	std	Y+15, r24	; 0x0f
    14c6:	98 8b       	std	Y+16, r25	; 0x10
    14c8:	a9 8b       	std	Y+17, r26	; 0x11
    14ca:	ba 8b       	std	Y+18, r27	; 0x12
    14cc:	8f 83       	std	Y+7, r24	; 0x07
    14ce:	98 87       	std	Y+8, r25	; 0x08
    14d0:	a9 87       	std	Y+9, r26	; 0x09
    14d2:	ba 87       	std	Y+10, r27	; 0x0a
			v_left = (signed int)(v_command - cmd_ang_vel*ROBOT_RADIUS);
			v_right = (signed int)(v_command + cmd_ang_vel*ROBOT_RADIUS);
		}
	*/
	
		v_left = (v_command - cmd_ang_vel*ROBOT_RADIUS);
    14d4:	a0 90 e8 02 	lds	r10, 0x02E8
    14d8:	b0 90 e9 02 	lds	r11, 0x02E9
    14dc:	c0 90 ea 02 	lds	r12, 0x02EA
    14e0:	d0 90 eb 02 	lds	r13, 0x02EB
    14e4:	e0 90 f0 02 	lds	r14, 0x02F0
    14e8:	f0 90 f1 02 	lds	r15, 0x02F1
    14ec:	00 91 f2 02 	lds	r16, 0x02F2
    14f0:	10 91 f3 02 	lds	r17, 0x02F3
    14f4:	c8 01       	movw	r24, r16
    14f6:	b7 01       	movw	r22, r14
    14f8:	23 e3       	ldi	r18, 0x33	; 51
    14fa:	33 e3       	ldi	r19, 0x33	; 51
    14fc:	43 e0       	ldi	r20, 0x03	; 3
    14fe:	51 ec       	ldi	r21, 0xC1	; 193
    1500:	0e 94 8e 2d 	call	0x5b1c	; 0x5b1c <__mulsf3>
    1504:	9b 01       	movw	r18, r22
    1506:	ac 01       	movw	r20, r24
    1508:	c6 01       	movw	r24, r12
    150a:	b5 01       	movw	r22, r10
    150c:	0e 94 f4 2a 	call	0x55e8	; 0x55e8 <__addsf3>
    1510:	1b 01       	movw	r2, r22
    1512:	2c 01       	movw	r4, r24
		v_right = (v_command + cmd_ang_vel*ROBOT_RADIUS);
    1514:	c8 01       	movw	r24, r16
    1516:	b7 01       	movw	r22, r14
    1518:	23 e3       	ldi	r18, 0x33	; 51
    151a:	33 e3       	ldi	r19, 0x33	; 51
    151c:	43 e0       	ldi	r20, 0x03	; 3
    151e:	51 e4       	ldi	r21, 0x41	; 65
    1520:	0e 94 8e 2d 	call	0x5b1c	; 0x5b1c <__mulsf3>
    1524:	9b 01       	movw	r18, r22
    1526:	ac 01       	movw	r20, r24
    1528:	c6 01       	movw	r24, r12
    152a:	b5 01       	movw	r22, r10
    152c:	0e 94 f4 2a 	call	0x55e8	; 0x55e8 <__addsf3>
    1530:	6b 83       	std	Y+3, r22	; 0x03
    1532:	7c 83       	std	Y+4, r23	; 0x04
    1534:	8d 83       	std	Y+5, r24	; 0x05
    1536:	9e 83       	std	Y+6, r25	; 0x06

		dt = ((get_timer2_overflow()*255 + TCNT2) * 0.0633) / 1000;
    1538:	0e 94 a5 19 	call	0x334a	; 0x334a <get_timer2_overflow>
    153c:	10 91 b2 00 	lds	r17, 0x00B2
    1540:	2f ef       	ldi	r18, 0xFF	; 255
    1542:	30 e0       	ldi	r19, 0x00	; 0
    1544:	40 e0       	ldi	r20, 0x00	; 0
    1546:	50 e0       	ldi	r21, 0x00	; 0
    1548:	0e 94 f4 2d 	call	0x5be8	; 0x5be8 <__mulsi3>
    154c:	61 0f       	add	r22, r17
    154e:	71 1d       	adc	r23, r1
    1550:	81 1d       	adc	r24, r1
    1552:	91 1d       	adc	r25, r1
    1554:	0e 94 57 2c 	call	0x58ae	; 0x58ae <__floatunsisf>
    1558:	2e e6       	ldi	r18, 0x6E	; 110
    155a:	33 ea       	ldi	r19, 0xA3	; 163
    155c:	41 e8       	ldi	r20, 0x81	; 129
    155e:	5d e3       	ldi	r21, 0x3D	; 61
    1560:	0e 94 8e 2d 	call	0x5b1c	; 0x5b1c <__mulsf3>
    1564:	20 e0       	ldi	r18, 0x00	; 0
    1566:	30 e0       	ldi	r19, 0x00	; 0
    1568:	4a e7       	ldi	r20, 0x7A	; 122
    156a:	54 e4       	ldi	r21, 0x44	; 68
    156c:	0e 94 be 2b 	call	0x577c	; 0x577c <__divsf3>
    1570:	3b 01       	movw	r6, r22
    1572:	4c 01       	movw	r8, r24
		reset_timer2();
    1574:	0e 94 05 1a 	call	0x340a	; 0x340a <reset_timer2>
	
	// PID

		LEFTVel_ready = RIGHTVel_ready = UNSET;
    1578:	10 92 d5 02 	sts	0x02D5, r1
    157c:	10 92 c8 02 	sts	0x02C8, r1

		error_L = v_left - LEFTVel_current;
    1580:	60 91 c6 02 	lds	r22, 0x02C6
    1584:	70 91 c7 02 	lds	r23, 0x02C7
    1588:	88 27       	eor	r24, r24
    158a:	77 fd       	sbrc	r23, 7
    158c:	80 95       	com	r24
    158e:	98 2f       	mov	r25, r24
    1590:	0e 94 59 2c 	call	0x58b2	; 0x58b2 <__floatsisf>
    1594:	9b 01       	movw	r18, r22
    1596:	ac 01       	movw	r20, r24
    1598:	c2 01       	movw	r24, r4
    159a:	b1 01       	movw	r22, r2
    159c:	0e 94 f3 2a 	call	0x55e6	; 0x55e6 <__subsf3>
    15a0:	5b 01       	movw	r10, r22
    15a2:	6c 01       	movw	r12, r24
		error_R = v_right - (-RIGHTVel_current);
    15a4:	60 91 d3 02 	lds	r22, 0x02D3
    15a8:	70 91 d4 02 	lds	r23, 0x02D4
    15ac:	70 95       	com	r23
    15ae:	61 95       	neg	r22
    15b0:	7f 4f       	sbci	r23, 0xFF	; 255
    15b2:	88 27       	eor	r24, r24
    15b4:	77 fd       	sbrc	r23, 7
    15b6:	80 95       	com	r24
    15b8:	98 2f       	mov	r25, r24
    15ba:	0e 94 59 2c 	call	0x58b2	; 0x58b2 <__floatsisf>
    15be:	9b 01       	movw	r18, r22
    15c0:	ac 01       	movw	r20, r24
    15c2:	6b 81       	ldd	r22, Y+3	; 0x03
    15c4:	7c 81       	ldd	r23, Y+4	; 0x04
    15c6:	8d 81       	ldd	r24, Y+5	; 0x05
    15c8:	9e 81       	ldd	r25, Y+6	; 0x06
    15ca:	0e 94 f3 2a 	call	0x55e6	; 0x55e6 <__subsf3>
    15ce:	6b 87       	std	Y+11, r22	; 0x0b
    15d0:	7c 87       	std	Y+12, r23	; 0x0c
    15d2:	8d 87       	std	Y+13, r24	; 0x0d
    15d4:	9e 87       	std	Y+14, r25	; 0x0e
			
		v_out_L = KP_L*error_L + KI_L*acc_error_L + (2/25)*v_left;
    15d6:	c6 01       	movw	r24, r12
    15d8:	b5 01       	movw	r22, r10
    15da:	22 ef       	ldi	r18, 0xF2	; 242
    15dc:	3c e5       	ldi	r19, 0x5C	; 92
    15de:	46 e6       	ldi	r20, 0x66	; 102
    15e0:	5d e3       	ldi	r21, 0x3D	; 61
    15e2:	0e 94 8e 2d 	call	0x5b1c	; 0x5b1c <__mulsf3>
    15e6:	7b 01       	movw	r14, r22
    15e8:	8c 01       	movw	r16, r24
    15ea:	6f 85       	ldd	r22, Y+15	; 0x0f
    15ec:	78 89       	ldd	r23, Y+16	; 0x10
    15ee:	89 89       	ldd	r24, Y+17	; 0x11
    15f0:	9a 89       	ldd	r25, Y+18	; 0x12
    15f2:	28 eb       	ldi	r18, 0xB8	; 184
    15f4:	32 e4       	ldi	r19, 0x42	; 66
    15f6:	4f e0       	ldi	r20, 0x0F	; 15
    15f8:	5e e3       	ldi	r21, 0x3E	; 62
    15fa:	0e 94 8e 2d 	call	0x5b1c	; 0x5b1c <__mulsf3>
    15fe:	9b 01       	movw	r18, r22
    1600:	ac 01       	movw	r20, r24
    1602:	c8 01       	movw	r24, r16
    1604:	b7 01       	movw	r22, r14
    1606:	0e 94 f4 2a 	call	0x55e8	; 0x55e8 <__addsf3>
    160a:	7b 01       	movw	r14, r22
    160c:	8c 01       	movw	r16, r24
    160e:	c2 01       	movw	r24, r4
    1610:	b1 01       	movw	r22, r2
    1612:	20 e0       	ldi	r18, 0x00	; 0
    1614:	30 e0       	ldi	r19, 0x00	; 0
    1616:	40 e0       	ldi	r20, 0x00	; 0
    1618:	50 e0       	ldi	r21, 0x00	; 0
    161a:	0e 94 8e 2d 	call	0x5b1c	; 0x5b1c <__mulsf3>
    161e:	9b 01       	movw	r18, r22
    1620:	ac 01       	movw	r20, r24
    1622:	c8 01       	movw	r24, r16
    1624:	b7 01       	movw	r22, r14
    1626:	0e 94 f4 2a 	call	0x55e8	; 0x55e8 <__addsf3>
    162a:	7b 01       	movw	r14, r22
    162c:	8c 01       	movw	r16, r24
		v_out_R = KP_R*error_R + KI_R*acc_error_R + (2/25)*v_right;
		
		acc_error_L += error_L*dt;
    162e:	c6 01       	movw	r24, r12
    1630:	b5 01       	movw	r22, r10
    1632:	a4 01       	movw	r20, r8
    1634:	93 01       	movw	r18, r6
    1636:	0e 94 8e 2d 	call	0x5b1c	; 0x5b1c <__mulsf3>
    163a:	9b 01       	movw	r18, r22
    163c:	ac 01       	movw	r20, r24
    163e:	6f 85       	ldd	r22, Y+15	; 0x0f
    1640:	78 89       	ldd	r23, Y+16	; 0x10
    1642:	89 89       	ldd	r24, Y+17	; 0x11
    1644:	9a 89       	ldd	r25, Y+18	; 0x12
    1646:	0e 94 f4 2a 	call	0x55e8	; 0x55e8 <__addsf3>
    164a:	6f 87       	std	Y+15, r22	; 0x0f
    164c:	78 8b       	std	Y+16, r23	; 0x10
    164e:	89 8b       	std	Y+17, r24	; 0x11
    1650:	9a 8b       	std	Y+18, r25	; 0x12
		acc_error_R += error_R*dt;
    1652:	6b 85       	ldd	r22, Y+11	; 0x0b
    1654:	7c 85       	ldd	r23, Y+12	; 0x0c
    1656:	8d 85       	ldd	r24, Y+13	; 0x0d
    1658:	9e 85       	ldd	r25, Y+14	; 0x0e
    165a:	a4 01       	movw	r20, r8
    165c:	93 01       	movw	r18, r6
    165e:	0e 94 8e 2d 	call	0x5b1c	; 0x5b1c <__mulsf3>
    1662:	9b 01       	movw	r18, r22
    1664:	ac 01       	movw	r20, r24
    1666:	6f 81       	ldd	r22, Y+7	; 0x07
    1668:	78 85       	ldd	r23, Y+8	; 0x08
    166a:	89 85       	ldd	r24, Y+9	; 0x09
    166c:	9a 85       	ldd	r25, Y+10	; 0x0a
    166e:	0e 94 f4 2a 	call	0x55e8	; 0x55e8 <__addsf3>
    1672:	a6 2e       	mov	r10, r22
    1674:	67 2e       	mov	r6, r23
    1676:	28 2e       	mov	r2, r24
    1678:	d9 2e       	mov	r13, r25
			rprintfFloat(8,dt);
			rprintfCRLF();
			taskEXIT_CRITICAL();
*/
			
		taskENTER_CRITICAL();
    167a:	0f b6       	in	r0, 0x3f	; 63
    167c:	f8 94       	cli
    167e:	0f 92       	push	r0

/*************************************************/


void wheel_L(float cmd_vel){
		if(cmd_vel > 36){cmd_vel = 36;}
    1680:	c8 01       	movw	r24, r16
    1682:	b7 01       	movw	r22, r14
    1684:	20 e0       	ldi	r18, 0x00	; 0
    1686:	30 e0       	ldi	r19, 0x00	; 0
    1688:	40 e1       	ldi	r20, 0x10	; 16
    168a:	52 e4       	ldi	r21, 0x42	; 66
    168c:	0e 94 83 2d 	call	0x5b06	; 0x5b06 <__gesf2>
    1690:	18 16       	cp	r1, r24
    1692:	5c f4       	brge	.+22     	; 0x16aa <vPID+0x24e>
    1694:	0f 2e       	mov	r0, r31
    1696:	f0 e0       	ldi	r31, 0x00	; 0
    1698:	ef 2e       	mov	r14, r31
    169a:	f0 e0       	ldi	r31, 0x00	; 0
    169c:	ff 2e       	mov	r15, r31
    169e:	f0 e1       	ldi	r31, 0x10	; 16
    16a0:	0f 2f       	mov	r16, r31
    16a2:	f2 e4       	ldi	r31, 0x42	; 66
    16a4:	1f 2f       	mov	r17, r31
    16a6:	f0 2d       	mov	r31, r0
    16a8:	14 c0       	rjmp	.+40     	; 0x16d2 <vPID+0x276>
		if(cmd_vel < -36){cmd_vel = -36;}
    16aa:	c8 01       	movw	r24, r16
    16ac:	b7 01       	movw	r22, r14
    16ae:	20 e0       	ldi	r18, 0x00	; 0
    16b0:	30 e0       	ldi	r19, 0x00	; 0
    16b2:	40 e1       	ldi	r20, 0x10	; 16
    16b4:	52 ec       	ldi	r21, 0xC2	; 194
    16b6:	0e 94 ba 2b 	call	0x5774	; 0x5774 <__cmpsf2>
    16ba:	88 23       	and	r24, r24
    16bc:	54 f4       	brge	.+20     	; 0x16d2 <vPID+0x276>
    16be:	0f 2e       	mov	r0, r31
    16c0:	f0 e0       	ldi	r31, 0x00	; 0
    16c2:	ef 2e       	mov	r14, r31
    16c4:	f0 e0       	ldi	r31, 0x00	; 0
    16c6:	ff 2e       	mov	r15, r31
    16c8:	f0 e1       	ldi	r31, 0x10	; 16
    16ca:	0f 2f       	mov	r16, r31
    16cc:	f2 ec       	ldi	r31, 0xC2	; 194
    16ce:	1f 2f       	mov	r17, r31
    16d0:	f0 2d       	mov	r31, r0
		
		float s_out = -0.4928 * (cmd_vel) + 185.27;
		
		taskENTER_CRITICAL();
    16d2:	0f b6       	in	r0, 0x3f	; 63
    16d4:	f8 94       	cli
    16d6:	0f 92       	push	r0
		PWM_timer3_Set_E4((int)s_out);
    16d8:	c8 01       	movw	r24, r16
    16da:	b7 01       	movw	r22, r14
    16dc:	28 e4       	ldi	r18, 0x48	; 72
    16de:	30 e5       	ldi	r19, 0x50	; 80
    16e0:	4c ef       	ldi	r20, 0xFC	; 252
    16e2:	5e eb       	ldi	r21, 0xBE	; 190
    16e4:	0e 94 8e 2d 	call	0x5b1c	; 0x5b1c <__mulsf3>
    16e8:	2f e1       	ldi	r18, 0x1F	; 31
    16ea:	35 e4       	ldi	r19, 0x45	; 69
    16ec:	49 e3       	ldi	r20, 0x39	; 57
    16ee:	53 e4       	ldi	r21, 0x43	; 67
    16f0:	0e 94 f4 2a 	call	0x55e8	; 0x55e8 <__addsf3>
    16f4:	0e 94 26 2c 	call	0x584c	; 0x584c <__fixsfsi>
void PWM_timer2_Set_H6(u16 pwmDuty)
	{OCR2B = pwmDuty;}
void PWM_timer3_Set_E3(u16 pwmDuty)
	{OCR3A = pwmDuty;}
void PWM_timer3_Set_E4(u16 pwmDuty)
	{OCR3B = pwmDuty;}
    16f8:	70 93 9b 00 	sts	0x009B, r23
    16fc:	60 93 9a 00 	sts	0x009A, r22
		taskEXIT_CRITICAL();
    1700:	0f 90       	pop	r0
    1702:	0f be       	out	0x3f, r0	; 63
			taskEXIT_CRITICAL();
*/
			
		taskENTER_CRITICAL();
		wheel_L(v_out_L);
		wheel_R(-v_out_R);
    1704:	6b 85       	ldd	r22, Y+11	; 0x0b
    1706:	7c 85       	ldd	r23, Y+12	; 0x0c
    1708:	8d 85       	ldd	r24, Y+13	; 0x0d
    170a:	9e 85       	ldd	r25, Y+14	; 0x0e
    170c:	20 eb       	ldi	r18, 0xB0	; 176
    170e:	34 eb       	ldi	r19, 0xB4	; 180
    1710:	4a e2       	ldi	r20, 0x2A	; 42
    1712:	5d e3       	ldi	r21, 0x3D	; 61
    1714:	0e 94 8e 2d 	call	0x5b1c	; 0x5b1c <__mulsf3>
    1718:	7b 01       	movw	r14, r22
    171a:	8c 01       	movw	r16, r24
    171c:	6f 81       	ldd	r22, Y+7	; 0x07
    171e:	78 85       	ldd	r23, Y+8	; 0x08
    1720:	89 85       	ldd	r24, Y+9	; 0x09
    1722:	9a 85       	ldd	r25, Y+10	; 0x0a
    1724:	2c e5       	ldi	r18, 0x5C	; 92
    1726:	36 e5       	ldi	r19, 0x56	; 86
    1728:	40 ea       	ldi	r20, 0xA0	; 160
    172a:	5d e3       	ldi	r21, 0x3D	; 61
    172c:	0e 94 8e 2d 	call	0x5b1c	; 0x5b1c <__mulsf3>
    1730:	9b 01       	movw	r18, r22
    1732:	ac 01       	movw	r20, r24
    1734:	c8 01       	movw	r24, r16
    1736:	b7 01       	movw	r22, r14
    1738:	0e 94 f4 2a 	call	0x55e8	; 0x55e8 <__addsf3>
    173c:	7b 01       	movw	r14, r22
    173e:	8c 01       	movw	r16, r24
    1740:	6b 81       	ldd	r22, Y+3	; 0x03
    1742:	7c 81       	ldd	r23, Y+4	; 0x04
    1744:	8d 81       	ldd	r24, Y+5	; 0x05
    1746:	9e 81       	ldd	r25, Y+6	; 0x06
    1748:	20 e0       	ldi	r18, 0x00	; 0
    174a:	30 e0       	ldi	r19, 0x00	; 0
    174c:	40 e0       	ldi	r20, 0x00	; 0
    174e:	50 e0       	ldi	r21, 0x00	; 0
    1750:	0e 94 8e 2d 	call	0x5b1c	; 0x5b1c <__mulsf3>
    1754:	9b 01       	movw	r18, r22
    1756:	ac 01       	movw	r20, r24
    1758:	c8 01       	movw	r24, r16
    175a:	b7 01       	movw	r22, r14
    175c:	0e 94 f4 2a 	call	0x55e8	; 0x55e8 <__addsf3>
    1760:	7b 01       	movw	r14, r22
    1762:	8c 01       	movw	r16, r24
    1764:	17 fb       	bst	r17, 7
    1766:	10 95       	com	r17
    1768:	17 f9       	bld	r17, 7
    176a:	10 95       	com	r17


}

void wheel_R(float cmd_vel){
		if(cmd_vel > 36){cmd_vel = 36;}
    176c:	c8 01       	movw	r24, r16
    176e:	b7 01       	movw	r22, r14
    1770:	20 e0       	ldi	r18, 0x00	; 0
    1772:	30 e0       	ldi	r19, 0x00	; 0
    1774:	40 e1       	ldi	r20, 0x10	; 16
    1776:	52 e4       	ldi	r21, 0x42	; 66
    1778:	0e 94 83 2d 	call	0x5b06	; 0x5b06 <__gesf2>
    177c:	18 16       	cp	r1, r24
    177e:	5c f4       	brge	.+22     	; 0x1796 <vPID+0x33a>
    1780:	0f 2e       	mov	r0, r31
    1782:	f0 e0       	ldi	r31, 0x00	; 0
    1784:	ef 2e       	mov	r14, r31
    1786:	f0 e0       	ldi	r31, 0x00	; 0
    1788:	ff 2e       	mov	r15, r31
    178a:	f0 e1       	ldi	r31, 0x10	; 16
    178c:	0f 2f       	mov	r16, r31
    178e:	f2 e4       	ldi	r31, 0x42	; 66
    1790:	1f 2f       	mov	r17, r31
    1792:	f0 2d       	mov	r31, r0
    1794:	14 c0       	rjmp	.+40     	; 0x17be <vPID+0x362>
		if(cmd_vel < -36){cmd_vel = -36;}
    1796:	c8 01       	movw	r24, r16
    1798:	b7 01       	movw	r22, r14
    179a:	20 e0       	ldi	r18, 0x00	; 0
    179c:	30 e0       	ldi	r19, 0x00	; 0
    179e:	40 e1       	ldi	r20, 0x10	; 16
    17a0:	52 ec       	ldi	r21, 0xC2	; 194
    17a2:	0e 94 ba 2b 	call	0x5774	; 0x5774 <__cmpsf2>
    17a6:	88 23       	and	r24, r24
    17a8:	54 f4       	brge	.+20     	; 0x17be <vPID+0x362>
    17aa:	0f 2e       	mov	r0, r31
    17ac:	f0 e0       	ldi	r31, 0x00	; 0
    17ae:	ef 2e       	mov	r14, r31
    17b0:	f0 e0       	ldi	r31, 0x00	; 0
    17b2:	ff 2e       	mov	r15, r31
    17b4:	f0 e1       	ldi	r31, 0x10	; 16
    17b6:	0f 2f       	mov	r16, r31
    17b8:	f2 ec       	ldi	r31, 0xC2	; 194
    17ba:	1f 2f       	mov	r17, r31
    17bc:	f0 2d       	mov	r31, r0
				
		float s_out = -0.5421 * (cmd_vel) + 188.41;

		taskENTER_CRITICAL();
    17be:	0f b6       	in	r0, 0x3f	; 63
    17c0:	f8 94       	cli
    17c2:	0f 92       	push	r0
		PWM_timer3_Set_E3((int)s_out);
    17c4:	c8 01       	movw	r24, r16
    17c6:	b7 01       	movw	r22, r14
    17c8:	21 e1       	ldi	r18, 0x11	; 17
    17ca:	37 ec       	ldi	r19, 0xC7	; 199
    17cc:	4a e0       	ldi	r20, 0x0A	; 10
    17ce:	5f eb       	ldi	r21, 0xBF	; 191
    17d0:	0e 94 8e 2d 	call	0x5b1c	; 0x5b1c <__mulsf3>
    17d4:	26 ef       	ldi	r18, 0xF6	; 246
    17d6:	38 e6       	ldi	r19, 0x68	; 104
    17d8:	4c e3       	ldi	r20, 0x3C	; 60
    17da:	53 e4       	ldi	r21, 0x43	; 67
    17dc:	0e 94 f4 2a 	call	0x55e8	; 0x55e8 <__addsf3>
    17e0:	0e 94 26 2c 	call	0x584c	; 0x584c <__fixsfsi>
void PWM_timer1_Set_LED(u16 pwmDuty)
	{OCR1B = pwmDuty;}
void PWM_timer2_Set_H6(u16 pwmDuty)
	{OCR2B = pwmDuty;}
void PWM_timer3_Set_E3(u16 pwmDuty)
	{OCR3A = pwmDuty;}
    17e4:	70 93 99 00 	sts	0x0099, r23
    17e8:	60 93 98 00 	sts	0x0098, r22
		taskEXIT_CRITICAL();
    17ec:	0f 90       	pop	r0
    17ee:	0f be       	out	0x3f, r0	; 63
*/
			
		taskENTER_CRITICAL();
		wheel_L(v_out_L);
		wheel_R(-v_out_R);
		taskEXIT_CRITICAL();
    17f0:	0f 90       	pop	r0
    17f2:	0f be       	out	0x3f, r0	; 63

		vTaskDelayUntil(&xLastWakeTime, (1 / portTICK_RATE_MS));
    17f4:	ce 01       	movw	r24, r28
    17f6:	01 96       	adiw	r24, 0x01	; 1
    17f8:	61 e0       	ldi	r22, 0x01	; 1
    17fa:	70 e0       	ldi	r23, 0x00	; 0
    17fc:	0e 94 b0 13 	call	0x2760	; 0x2760 <vTaskDelayUntil>
    1800:	2a 2d       	mov	r18, r10
    1802:	36 2d       	mov	r19, r6
    1804:	42 2d       	mov	r20, r2
    1806:	5d 2d       	mov	r21, r13
    1808:	c9 01       	movw	r24, r18
    180a:	da 01       	movw	r26, r20
    180c:	5f ce       	rjmp	.-834    	; 0x14cc <vPID+0x70>

0000180e <prvSetupHardware>:

void init_ub_buffer(){
	ub_buffer_write_ndx = ub_buffer_read_ndx = ub_buffer;
}

void prvSetupHardware(){
    180e:	0f 93       	push	r16
    1810:	1f 93       	push	r17
    1812:	cf 93       	push	r28
    1814:	df 93       	push	r29
	delay_cycles(65535);
	delay_cycles(65535);
	
	

	uartInit();  // initialize the UART (serial port)
    1816:	0e 94 52 24 	call	0x48a4	; 0x48a4 <uartInit>
    uartSetBaudRate(0, 38400); // set UARTE speed, for Bluetooth
    181a:	80 e0       	ldi	r24, 0x00	; 0
    181c:	40 e0       	ldi	r20, 0x00	; 0
    181e:	56 e9       	ldi	r21, 0x96	; 150
    1820:	60 e0       	ldi	r22, 0x00	; 0
    1822:	70 e0       	ldi	r23, 0x00	; 0
    1824:	0e 94 2c 20 	call	0x4058	; 0x4058 <uartSetBaudRate>
    uartSetBaudRate(1, 115200); // set UARTD speed, for USB connection, up to 500k, try 115200 if it doesn't work
    1828:	81 e0       	ldi	r24, 0x01	; 1
    182a:	40 e0       	ldi	r20, 0x00	; 0
    182c:	52 ec       	ldi	r21, 0xC2	; 194
    182e:	61 e0       	ldi	r22, 0x01	; 1
    1830:	70 e0       	ldi	r23, 0x00	; 0
    1832:	0e 94 2c 20 	call	0x4058	; 0x4058 <uartSetBaudRate>
    uartSetBaudRate(2, 38400); // set UARTH speed
    1836:	82 e0       	ldi	r24, 0x02	; 2
    1838:	40 e0       	ldi	r20, 0x00	; 0
    183a:	56 e9       	ldi	r21, 0x96	; 150
    183c:	60 e0       	ldi	r22, 0x00	; 0
    183e:	70 e0       	ldi	r23, 0x00	; 0
    1840:	0e 94 2c 20 	call	0x4058	; 0x4058 <uartSetBaudRate>
    uartSetBaudRate(3, 115200); // set UARTJ speed, for Blackfin
    1844:	83 e0       	ldi	r24, 0x03	; 3
    1846:	40 e0       	ldi	r20, 0x00	; 0
    1848:	52 ec       	ldi	r21, 0xC2	; 194
    184a:	61 e0       	ldi	r22, 0x01	; 1
    184c:	70 e0       	ldi	r23, 0x00	; 0
    184e:	0e 94 2c 20 	call	0x4058	; 0x4058 <uartSetBaudRate>
	//G=Ground, T=Tx (connect to external Rx), R=Rx (connect to external Tx)

	rprintfInit(uart1SendByte);// initialize rprintf system and configure uart1 (USB) for rprintf
    1852:	85 ea       	ldi	r24, 0xA5	; 165
    1854:	90 e2       	ldi	r25, 0x20	; 32
    1856:	0e 94 96 25 	call	0x4b2c	; 0x4b2c <rprintfInit>

	configure_ports(); // configure which ports are analog, digital, etc.
    185a:	0e 94 70 03 	call	0x6e0	; 0x6e0 <configure_ports>
	}
	return data;
}

void init_ub_buffer(){
	ub_buffer_write_ndx = ub_buffer_read_ndx = ub_buffer;
    185e:	80 e4       	ldi	r24, 0x40	; 64
    1860:	92 e1       	ldi	r25, 0x12	; 18
    1862:	90 93 fb 02 	sts	0x02FB, r25
    1866:	80 93 fa 02 	sts	0x02FA, r24
    186a:	90 93 f9 02 	sts	0x02F9, r25
    186e:	80 93 f8 02 	sts	0x02F8, r24
	
	//UART ISR *** UART ISR ***

	init_ub_buffer();
	
	uartSetRxHandler(2, &fwdSer_L);
    1872:	82 e0       	ldi	r24, 0x02	; 2
    1874:	6c e8       	ldi	r22, 0x8C	; 140
    1876:	76 e0       	ldi	r23, 0x06	; 6
    1878:	0e 94 21 20 	call	0x4042	; 0x4042 <uartSetRxHandler>
	uartSetRxHandler(0, &fwdSer_R);
    187c:	80 e0       	ldi	r24, 0x00	; 0
    187e:	6c e1       	ldi	r22, 0x1C	; 28
    1880:	77 e0       	ldi	r23, 0x07	; 7
    1882:	0e 94 21 20 	call	0x4042	; 0x4042 <uartSetRxHandler>
	uartSetRxHandler(3, &ubRcv);
    1886:	83 e0       	ldi	r24, 0x03	; 3
    1888:	6f e7       	ldi	r22, 0x7F	; 127
    188a:	75 e0       	ldi	r23, 0x05	; 5
    188c:	0e 94 21 20 	call	0x4042	; 0x4042 <uartSetRxHandler>
void LED_on(void)
	{PORT_OFF(PORTB,6);}
    1890:	2e 98       	cbi	0x05, 6	; 5

	//UART ISR *** UART ISR ***

	LED_on();

	rprintf("\r\nSystem Warmed Up");
    1892:	00 d0       	rcall	.+0      	; 0x1894 <prvSetupHardware+0x86>
    1894:	0f 92       	push	r0
    1896:	81 e0       	ldi	r24, 0x01	; 1
    1898:	ed b7       	in	r30, 0x3d	; 61
    189a:	fe b7       	in	r31, 0x3e	; 62
    189c:	81 83       	std	Z+1, r24	; 0x01
    189e:	83 e7       	ldi	r24, 0x73	; 115
    18a0:	91 e0       	ldi	r25, 0x01	; 1
    18a2:	93 83       	std	Z+3, r25	; 0x03
    18a4:	82 83       	std	Z+2, r24	; 0x02
    18a6:	0e 94 ba 27 	call	0x4f74	; 0x4f74 <rprintf1RamRom>

	// initialize the timer system
 	init_timer0(TIMER_CLK_1024);
    18aa:	0f 90       	pop	r0
    18ac:	0f 90       	pop	r0
    18ae:	0f 90       	pop	r0
    18b0:	85 e0       	ldi	r24, 0x05	; 5
    18b2:	0e 94 38 1a 	call	0x3470	; 0x3470 <init_timer0>
// 	init_timer1(TIMER_CLK_64); // Timer 1 is initialized by FreeRTOS
 	//init_timer2(TIMER2_CLK_64);
	init_timer2(TIMER2_CLK_1024);
    18b6:	87 e0       	ldi	r24, 0x07	; 7
    18b8:	0e 94 58 1a 	call	0x34b0	; 0x34b0 <init_timer2>
 	init_timer3(TIMER_CLK_64);
    18bc:	83 e0       	ldi	r24, 0x03	; 3
    18be:	0e 94 68 1a 	call	0x34d0	; 0x34d0 <init_timer3>
 	init_timer4(TIMER_CLK_64);
    18c2:	83 e0       	ldi	r24, 0x03	; 3
    18c4:	0e 94 7a 1a 	call	0x34f4	; 0x34f4 <init_timer4>
 	init_timer5(TIMER_CLK_64);
    18c8:	83 e0       	ldi	r24, 0x03	; 3
    18ca:	0e 94 8c 1a 	call	0x3518	; 0x3518 <init_timer5>

	a2dInit(); // initialize analog to digital converter (ADC)
    18ce:	0e 94 0b 25 	call	0x4a16	; 0x4a16 <a2dInit>
	a2dSetPrescaler(ADC_PRESCALE_DIV32); // configure ADC scaling
    18d2:	85 e0       	ldi	r24, 0x05	; 5
    18d4:	0e 94 30 25 	call	0x4a60	; 0x4a60 <a2dSetPrescaler>
	a2dSetReference(ADC_REFERENCE_AVCC); // configure ADC reference voltage
    18d8:	81 e0       	ldi	r24, 0x01	; 1
    18da:	0e 94 37 25 	call	0x4a6e	; 0x4a6e <a2dSetReference>
    18de:	10 e0       	ldi	r17, 0x00	; 0
	//let system stabelize for X time
	for(i=0;i<16;i++)
		{
		j=a2dConvert8bit(i);//read each ADC once to get it working accurately
		delay_cycles(5000); //keep LED on long enough to see Axon reseting
		rprintf(".");
    18e0:	01 e0       	ldi	r16, 0x01	; 1
    18e2:	c1 e7       	ldi	r28, 0x71	; 113
    18e4:	d1 e0       	ldi	r29, 0x01	; 1
	a2dSetReference(ADC_REFERENCE_AVCC); // configure ADC reference voltage

	//let system stabelize for X time
	for(i=0;i<16;i++)
		{
		j=a2dConvert8bit(i);//read each ADC once to get it working accurately
    18e6:	81 2f       	mov	r24, r17
    18e8:	0e 94 80 25 	call	0x4b00	; 0x4b00 <a2dConvert8bit>
		delay_cycles(5000); //keep LED on long enough to see Axon reseting
		rprintf(".");
    18ec:	00 d0       	rcall	.+0      	; 0x18ee <prvSetupHardware+0xe0>
    18ee:	0f 92       	push	r0
    18f0:	ed b7       	in	r30, 0x3d	; 61
    18f2:	fe b7       	in	r31, 0x3e	; 62
    18f4:	01 83       	std	Z+1, r16	; 0x01
    18f6:	d3 83       	std	Z+3, r29	; 0x03
    18f8:	c2 83       	std	Z+2, r28	; 0x02
    18fa:	0e 94 ba 27 	call	0x4f74	; 0x4f74 <rprintf1RamRom>
    18fe:	1f 5f       	subi	r17, 0xFF	; 255
	a2dInit(); // initialize analog to digital converter (ADC)
	a2dSetPrescaler(ADC_PRESCALE_DIV32); // configure ADC scaling
	a2dSetReference(ADC_REFERENCE_AVCC); // configure ADC reference voltage

	//let system stabelize for X time
	for(i=0;i<16;i++)
    1900:	0f 90       	pop	r0
    1902:	0f 90       	pop	r0
    1904:	0f 90       	pop	r0
    1906:	10 31       	cpi	r17, 0x10	; 16
    1908:	71 f7       	brne	.-36     	; 0x18e6 <prvSetupHardware+0xd8>


//***************STATUS LED**************
//tank test
void LED_off(void)
	{PORT_ON(PORTB,6);}
    190a:	2e 9a       	sbi	0x05, 6	; 5
		rprintf(".");
		}

	LED_off();

	rprintf("Initialization Complete \r\n");
    190c:	00 d0       	rcall	.+0      	; 0x190e <prvSetupHardware+0x100>
    190e:	0f 92       	push	r0
    1910:	ed b7       	in	r30, 0x3d	; 61
    1912:	fe b7       	in	r31, 0x3e	; 62
    1914:	01 83       	std	Z+1, r16	; 0x01
    1916:	86 e5       	ldi	r24, 0x56	; 86
    1918:	91 e0       	ldi	r25, 0x01	; 1
    191a:	93 83       	std	Z+3, r25	; 0x03
    191c:	82 83       	std	Z+2, r24	; 0x02
    191e:	0e 94 ba 27 	call	0x4f74	; 0x4f74 <rprintf1RamRom>

	//reset all timers to zero
	reset_timer0();
    1922:	0f 90       	pop	r0
    1924:	0f 90       	pop	r0
    1926:	0f 90       	pop	r0
    1928:	0e 94 ee 19 	call	0x33dc	; 0x33dc <reset_timer0>
	reset_timer1();
    192c:	0e 94 f8 19 	call	0x33f0	; 0x33f0 <reset_timer1>
	reset_timer2();
    1930:	0e 94 05 1a 	call	0x340a	; 0x340a <reset_timer2>
	reset_timer3();
    1934:	0e 94 10 1a 	call	0x3420	; 0x3420 <reset_timer3>
	reset_timer4();
    1938:	0e 94 1d 1a 	call	0x343a	; 0x343a <reset_timer4>
	reset_timer5();
    193c:	0e 94 2a 1a 	call	0x3454	; 0x3454 <reset_timer5>



	/********PWM Setup***********/
	prvPWMSetup();
    1940:	0e 94 40 04 	call	0x880	; 0x880 <prvPWMSetup>

}
    1944:	df 91       	pop	r29
    1946:	cf 91       	pop	r28
    1948:	1f 91       	pop	r17
    194a:	0f 91       	pop	r16
    194c:	08 95       	ret

0000194e <main>:
float elapsed_time;
float current_time = 0;
float previous_time = 0;

int main(void)
{
    194e:	af 92       	push	r10
    1950:	bf 92       	push	r11
    1952:	cf 92       	push	r12
    1954:	df 92       	push	r13
    1956:	ef 92       	push	r14
    1958:	ff 92       	push	r15
    195a:	0f 93       	push	r16
    195c:	cf 93       	push	r28
    195e:	df 93       	push	r29
	prvSetupHardware();
    1960:	0e 94 07 0c 	call	0x180e	; 0x180e <prvSetupHardware>
	
	//delay_ms(500);


	v_command = 25;
	v_command = 0;
    1964:	80 e0       	ldi	r24, 0x00	; 0
    1966:	90 e0       	ldi	r25, 0x00	; 0
    1968:	a0 e0       	ldi	r26, 0x00	; 0
    196a:	b0 e0       	ldi	r27, 0x00	; 0
    196c:	80 93 e8 02 	sts	0x02E8, r24
    1970:	90 93 e9 02 	sts	0x02E9, r25
    1974:	a0 93 ea 02 	sts	0x02EA, r26
    1978:	b0 93 eb 02 	sts	0x02EB, r27
	cmd_ang_vel = 0;
    197c:	80 93 f0 02 	sts	0x02F0, r24
    1980:	90 93 f1 02 	sts	0x02F1, r25
    1984:	a0 93 f2 02 	sts	0x02F2, r26
    1988:	b0 93 f3 02 	sts	0x02F3, r27


	xTaskCreate(vLight0On, "Light0", 100, NULL, 1, NULL);
    198c:	86 e4       	ldi	r24, 0x46	; 70
    198e:	98 e0       	ldi	r25, 0x08	; 8
    1990:	60 e0       	ldi	r22, 0x00	; 0
    1992:	72 e0       	ldi	r23, 0x02	; 2
    1994:	44 e6       	ldi	r20, 0x64	; 100
    1996:	50 e0       	ldi	r21, 0x00	; 0
    1998:	20 e0       	ldi	r18, 0x00	; 0
    199a:	30 e0       	ldi	r19, 0x00	; 0
    199c:	01 e0       	ldi	r16, 0x01	; 1
    199e:	ee 24       	eor	r14, r14
    19a0:	ff 24       	eor	r15, r15
    19a2:	cc 24       	eor	r12, r12
    19a4:	dd 24       	eor	r13, r13
    19a6:	aa 24       	eor	r10, r10
    19a8:	bb 24       	eor	r11, r11
    19aa:	0e 94 9a 14 	call	0x2934	; 0x2934 <xTaskGenericCreate>
	xTaskCreate(vLight1On, "Light1", 100, NULL, 1, NULL);
    19ae:	8f e2       	ldi	r24, 0x2F	; 47
    19b0:	98 e0       	ldi	r25, 0x08	; 8
    19b2:	67 e0       	ldi	r22, 0x07	; 7
    19b4:	72 e0       	ldi	r23, 0x02	; 2
    19b6:	44 e6       	ldi	r20, 0x64	; 100
    19b8:	50 e0       	ldi	r21, 0x00	; 0
    19ba:	20 e0       	ldi	r18, 0x00	; 0
    19bc:	30 e0       	ldi	r19, 0x00	; 0
    19be:	0e 94 9a 14 	call	0x2934	; 0x2934 <xTaskGenericCreate>
	xTaskCreate(vUpdatePose, "UpdatePs", 500, NULL, 1, NULL);
    19c2:	85 e4       	ldi	r24, 0x45	; 69
    19c4:	96 e0       	ldi	r25, 0x06	; 6
    19c6:	6e e0       	ldi	r22, 0x0E	; 14
    19c8:	72 e0       	ldi	r23, 0x02	; 2
    19ca:	44 ef       	ldi	r20, 0xF4	; 244
    19cc:	51 e0       	ldi	r21, 0x01	; 1
    19ce:	20 e0       	ldi	r18, 0x00	; 0
    19d0:	30 e0       	ldi	r19, 0x00	; 0
    19d2:	0e 94 9a 14 	call	0x2934	; 0x2934 <xTaskGenericCreate>
	xTaskCreate(vEnc_UpdatePose, "enUpdtPs", 500, NULL, 1, NULL);
    19d6:	8d e5       	ldi	r24, 0x5D	; 93
    19d8:	98 e0       	ldi	r25, 0x08	; 8
    19da:	67 e1       	ldi	r22, 0x17	; 23
    19dc:	72 e0       	ldi	r23, 0x02	; 2
    19de:	44 ef       	ldi	r20, 0xF4	; 244
    19e0:	51 e0       	ldi	r21, 0x01	; 1
    19e2:	20 e0       	ldi	r18, 0x00	; 0
    19e4:	30 e0       	ldi	r19, 0x00	; 0
    19e6:	0e 94 9a 14 	call	0x2934	; 0x2934 <xTaskGenericCreate>
//	xTaskCreate(vServoOsc, "ServoGo", 200, NULL, 1, NULL);
//	xTaskCreate(vServoTm, "ServoTm", 200, NULL, 1, NULL);
	xTaskCreate(vUbRcv, "vUbRcv", 500, NULL, 1, NULL);
    19ea:	8a e3       	ldi	r24, 0x3A	; 58
    19ec:	9d e0       	ldi	r25, 0x0D	; 13
    19ee:	60 e2       	ldi	r22, 0x20	; 32
    19f0:	72 e0       	ldi	r23, 0x02	; 2
    19f2:	44 ef       	ldi	r20, 0xF4	; 244
    19f4:	51 e0       	ldi	r21, 0x01	; 1
    19f6:	20 e0       	ldi	r18, 0x00	; 0
    19f8:	30 e0       	ldi	r19, 0x00	; 0
    19fa:	0e 94 9a 14 	call	0x2934	; 0x2934 <xTaskGenericCreate>
	xTaskCreate(vPID, "vPID", 500, NULL, 1, NULL);
    19fe:	8e e2       	ldi	r24, 0x2E	; 46
    1a00:	9a e0       	ldi	r25, 0x0A	; 10
    1a02:	67 e2       	ldi	r22, 0x27	; 39
    1a04:	72 e0       	ldi	r23, 0x02	; 2
    1a06:	44 ef       	ldi	r20, 0xF4	; 244
    1a08:	51 e0       	ldi	r21, 0x01	; 1
    1a0a:	20 e0       	ldi	r18, 0x00	; 0
    1a0c:	30 e0       	ldi	r19, 0x00	; 0
    1a0e:	0e 94 9a 14 	call	0x2934	; 0x2934 <xTaskGenericCreate>
//	xTaskCreate(vScript, "vScript", 100, NULL, 2, NULL);


	vTaskStartScheduler();
    1a12:	0e 94 be 15 	call	0x2b7c	; 0x2b7c <vTaskStartScheduler>
	for(;;){rprintf("DEATH\n");}
    1a16:	c1 e1       	ldi	r28, 0x11	; 17
    1a18:	d1 e0       	ldi	r29, 0x01	; 1
    1a1a:	00 d0       	rcall	.+0      	; 0x1a1c <main+0xce>
    1a1c:	0f 92       	push	r0
    1a1e:	ed b7       	in	r30, 0x3d	; 61
    1a20:	fe b7       	in	r31, 0x3e	; 62
    1a22:	01 83       	std	Z+1, r16	; 0x01
    1a24:	d3 83       	std	Z+3, r29	; 0x03
    1a26:	c2 83       	std	Z+2, r28	; 0x02
    1a28:	0e 94 ba 27 	call	0x4f74	; 0x4f74 <rprintf1RamRom>
    1a2c:	0f 90       	pop	r0
    1a2e:	0f 90       	pop	r0
    1a30:	0f 90       	pop	r0
    1a32:	f3 cf       	rjmp	.-26     	; 0x1a1a <main+0xcc>

00001a34 <read_ub>:
			ub_buffer_write_ndx = ub_buffer;
		}
	}	
}

uint8_t read_ub(){
    1a34:	04 c0       	rjmp	.+8      	; 0x1a3e <read_ub+0xa>
	while(ub_buffer_read_ndx == ub_buffer_write_ndx){ delay_us(10); };
    1a36:	8a e0       	ldi	r24, 0x0A	; 10
    1a38:	90 e0       	ldi	r25, 0x00	; 0
    1a3a:	0e 94 37 1a 	call	0x346e	; 0x346e <delay_us>
    1a3e:	e0 91 fa 02 	lds	r30, 0x02FA
    1a42:	f0 91 fb 02 	lds	r31, 0x02FB
    1a46:	80 91 f8 02 	lds	r24, 0x02F8
    1a4a:	90 91 f9 02 	lds	r25, 0x02F9
    1a4e:	e8 17       	cp	r30, r24
    1a50:	f9 07       	cpc	r31, r25
    1a52:	89 f3       	breq	.-30     	; 0x1a36 <read_ub+0x2>
	uint8_t data = *ub_buffer_read_ndx;
    1a54:	21 91       	ld	r18, Z+
	ub_buffer_read_ndx++;
    1a56:	f0 93 fb 02 	sts	0x02FB, r31
    1a5a:	e0 93 fa 02 	sts	0x02FA, r30
	if(ub_buffer_read_ndx >= (ub_buffer + UB_BUFFER_SIZE)){ 
    1a5e:	e0 54       	subi	r30, 0x40	; 64
    1a60:	f4 41       	sbci	r31, 0x14	; 20
    1a62:	30 f0       	brcs	.+12     	; 0x1a70 <read_ub+0x3c>
		ub_buffer_read_ndx = ub_buffer;
    1a64:	80 e4       	ldi	r24, 0x40	; 64
    1a66:	92 e1       	ldi	r25, 0x12	; 18
    1a68:	90 93 fb 02 	sts	0x02FB, r25
    1a6c:	80 93 fa 02 	sts	0x02FA, r24
	}
	return data;
}
    1a70:	82 2f       	mov	r24, r18
    1a72:	08 95       	ret

00001a74 <vUbRcv>:
		
	
	}
}

void vUbRcv(){
    1a74:	2f 92       	push	r2
    1a76:	3f 92       	push	r3
    1a78:	4f 92       	push	r4
    1a7a:	5f 92       	push	r5
    1a7c:	6f 92       	push	r6
    1a7e:	7f 92       	push	r7
    1a80:	8f 92       	push	r8
    1a82:	9f 92       	push	r9
    1a84:	af 92       	push	r10
    1a86:	bf 92       	push	r11
    1a88:	cf 92       	push	r12
    1a8a:	df 92       	push	r13
    1a8c:	ef 92       	push	r14
    1a8e:	ff 92       	push	r15
    1a90:	0f 93       	push	r16
    1a92:	1f 93       	push	r17
    1a94:	df 93       	push	r29
    1a96:	cf 93       	push	r28
    1a98:	00 d0       	rcall	.+0      	; 0x1a9a <vUbRcv+0x26>
    1a9a:	cd b7       	in	r28, 0x3d	; 61
    1a9c:	de b7       	in	r29, 0x3e	; 62
				
				
				rprintfCRLF();
				rprintf("Received Velocity: ");
				rprintfFloat(5,fltuint8_velocity.f_vel);
				rprintf(" Omega: ");
    1a9e:	78 e1       	ldi	r23, 0x18	; 24
    1aa0:	27 2e       	mov	r2, r23
    1aa2:	71 e0       	ldi	r23, 0x01	; 1
    1aa4:	37 2e       	mov	r3, r23
				rprintfFloat(5,fltuint8_omega.f_ome);
				rprintfCRLF();
			
			
		}
		vTaskDelayUntil(&xLastWakeTime, (1 / portTICK_RATE_MS));
    1aa6:	2e 01       	movw	r4, r28
    1aa8:	08 94       	sec
    1aaa:	41 1c       	adc	r4, r1
    1aac:	51 1c       	adc	r5, r1
	union u_ome fltuint8_omega;
	uint8_t rcv_byte;
	uint8_t rcv_chk;
	uint8_t calc_chk;
	for(;;){
		rcv_byte = read_ub();
    1aae:	0e 94 1a 0d 	call	0x1a34	; 0x1a34 <read_ub>
		//rprintfu08(rcv_byte);
		if(rcv_byte == 0xFA){
    1ab2:	8a 3f       	cpi	r24, 0xFA	; 250
    1ab4:	09 f0       	breq	.+2      	; 0x1ab8 <vUbRcv+0x44>
    1ab6:	7c c0       	rjmp	.+248    	; 0x1bb0 <vUbRcv+0x13c>
		
			fltuint8_velocity.arr_vel[0] = read_ub();
    1ab8:	0e 94 1a 0d 	call	0x1a34	; 0x1a34 <read_ub>
    1abc:	e8 2e       	mov	r14, r24
			fltuint8_velocity.arr_vel[1] = read_ub();
    1abe:	0e 94 1a 0d 	call	0x1a34	; 0x1a34 <read_ub>
    1ac2:	f8 2e       	mov	r15, r24
			fltuint8_velocity.arr_vel[2] = read_ub();
    1ac4:	0e 94 1a 0d 	call	0x1a34	; 0x1a34 <read_ub>
    1ac8:	08 2f       	mov	r16, r24
			fltuint8_velocity.arr_vel[3] = read_ub();
    1aca:	0e 94 1a 0d 	call	0x1a34	; 0x1a34 <read_ub>
    1ace:	18 2f       	mov	r17, r24
			

			fltuint8_omega.arr_ome[0] = read_ub();
    1ad0:	0e 94 1a 0d 	call	0x1a34	; 0x1a34 <read_ub>
    1ad4:	68 2e       	mov	r6, r24
			fltuint8_omega.arr_ome[1] = read_ub();
    1ad6:	0e 94 1a 0d 	call	0x1a34	; 0x1a34 <read_ub>
    1ada:	78 2e       	mov	r7, r24
			fltuint8_omega.arr_ome[2] = read_ub();
    1adc:	0e 94 1a 0d 	call	0x1a34	; 0x1a34 <read_ub>
    1ae0:	88 2e       	mov	r8, r24
			fltuint8_omega.arr_ome[3] = read_ub();
    1ae2:	0e 94 1a 0d 	call	0x1a34	; 0x1a34 <read_ub>
    1ae6:	98 2e       	mov	r9, r24
		

			rcv_chk = read_ub();
    1ae8:	0e 94 1a 0d 	call	0x1a34	; 0x1a34 <read_ub>

			calc_chk = fltuint8_velocity.arr_vel[0] + fltuint8_velocity.arr_vel[1] + fltuint8_velocity.arr_vel[2]
			+ fltuint8_velocity.arr_vel[3] + fltuint8_omega.arr_ome[0] + fltuint8_omega.arr_ome[1] 
			+ fltuint8_omega.arr_ome[2] + fltuint8_omega.arr_ome[3];
/**/
			rprintfu08(fltuint8_velocity.arr_vel[0]);
    1aec:	8e 2d       	mov	r24, r14
    1aee:	0e 94 09 26 	call	0x4c12	; 0x4c12 <rprintfu08>
			rprintfu08(fltuint8_velocity.arr_vel[1]);
    1af2:	8f 2d       	mov	r24, r15
    1af4:	0e 94 09 26 	call	0x4c12	; 0x4c12 <rprintfu08>
			rprintfu08(fltuint8_velocity.arr_vel[2]);
    1af8:	80 2f       	mov	r24, r16
    1afa:	0e 94 09 26 	call	0x4c12	; 0x4c12 <rprintfu08>
			rprintfu08(fltuint8_velocity.arr_vel[3]);
    1afe:	81 2f       	mov	r24, r17
    1b00:	0e 94 09 26 	call	0x4c12	; 0x4c12 <rprintfu08>

			rprintfu08(fltuint8_omega.arr_ome[0]);
    1b04:	86 2d       	mov	r24, r6
    1b06:	0e 94 09 26 	call	0x4c12	; 0x4c12 <rprintfu08>
			rprintfu08(fltuint8_omega.arr_ome[1]);
    1b0a:	87 2d       	mov	r24, r7
    1b0c:	0e 94 09 26 	call	0x4c12	; 0x4c12 <rprintfu08>
			rprintfu08(fltuint8_omega.arr_ome[2]);
    1b10:	88 2d       	mov	r24, r8
    1b12:	0e 94 09 26 	call	0x4c12	; 0x4c12 <rprintfu08>
			rprintfu08(fltuint8_omega.arr_ome[3]);
    1b16:	89 2d       	mov	r24, r9
    1b18:	0e 94 09 26 	call	0x4c12	; 0x4c12 <rprintfu08>

			if(calc_chk == rcv_chk){
			}
				v_command = fltuint8_velocity.f_vel;
    1b1c:	de 2c       	mov	r13, r14
    1b1e:	cf 2c       	mov	r12, r15
    1b20:	b0 2e       	mov	r11, r16
    1b22:	a1 2e       	mov	r10, r17
    1b24:	8e 2d       	mov	r24, r14
    1b26:	9f 2d       	mov	r25, r15
    1b28:	a0 2f       	mov	r26, r16
    1b2a:	b1 2f       	mov	r27, r17
    1b2c:	80 93 e8 02 	sts	0x02E8, r24
    1b30:	90 93 e9 02 	sts	0x02E9, r25
    1b34:	a0 93 ea 02 	sts	0x02EA, r26
    1b38:	b0 93 eb 02 	sts	0x02EB, r27
				cmd_ang_vel = fltuint8_omega.f_ome;
    1b3c:	86 2d       	mov	r24, r6
    1b3e:	97 2d       	mov	r25, r7
    1b40:	a8 2d       	mov	r26, r8
    1b42:	b9 2d       	mov	r27, r9
    1b44:	80 93 f0 02 	sts	0x02F0, r24
    1b48:	90 93 f1 02 	sts	0x02F1, r25
    1b4c:	a0 93 f2 02 	sts	0x02F2, r26
    1b50:	b0 93 f3 02 	sts	0x02F3, r27
				
				
				rprintfCRLF();
    1b54:	0e 94 fa 25 	call	0x4bf4	; 0x4bf4 <rprintfCRLF>
				rprintf("Received Velocity: ");
    1b58:	00 d0       	rcall	.+0      	; 0x1b5a <vUbRcv+0xe6>
    1b5a:	0f 92       	push	r0
    1b5c:	81 e0       	ldi	r24, 0x01	; 1
    1b5e:	ed b7       	in	r30, 0x3d	; 61
    1b60:	fe b7       	in	r31, 0x3e	; 62
    1b62:	81 83       	std	Z+1, r24	; 0x01
    1b64:	81 e2       	ldi	r24, 0x21	; 33
    1b66:	91 e0       	ldi	r25, 0x01	; 1
    1b68:	93 83       	std	Z+3, r25	; 0x03
    1b6a:	82 83       	std	Z+2, r24	; 0x02
    1b6c:	0e 94 ba 27 	call	0x4f74	; 0x4f74 <rprintf1RamRom>
				rprintfFloat(5,fltuint8_velocity.f_vel);
    1b70:	0f 90       	pop	r0
    1b72:	0f 90       	pop	r0
    1b74:	0f 90       	pop	r0
    1b76:	85 e0       	ldi	r24, 0x05	; 5
    1b78:	4d 2d       	mov	r20, r13
    1b7a:	5c 2d       	mov	r21, r12
    1b7c:	6b 2d       	mov	r22, r11
    1b7e:	7a 2d       	mov	r23, r10
    1b80:	0e 94 f1 26 	call	0x4de2	; 0x4de2 <rprintfFloat>
				rprintf(" Omega: ");
    1b84:	00 d0       	rcall	.+0      	; 0x1b86 <vUbRcv+0x112>
    1b86:	0f 92       	push	r0
    1b88:	81 e0       	ldi	r24, 0x01	; 1
    1b8a:	ed b7       	in	r30, 0x3d	; 61
    1b8c:	fe b7       	in	r31, 0x3e	; 62
    1b8e:	81 83       	std	Z+1, r24	; 0x01
    1b90:	33 82       	std	Z+3, r3	; 0x03
    1b92:	22 82       	std	Z+2, r2	; 0x02
    1b94:	0e 94 ba 27 	call	0x4f74	; 0x4f74 <rprintf1RamRom>
				rprintfFloat(5,fltuint8_omega.f_ome);
    1b98:	0f 90       	pop	r0
    1b9a:	0f 90       	pop	r0
    1b9c:	0f 90       	pop	r0
    1b9e:	85 e0       	ldi	r24, 0x05	; 5
    1ba0:	46 2d       	mov	r20, r6
    1ba2:	57 2d       	mov	r21, r7
    1ba4:	68 2d       	mov	r22, r8
    1ba6:	79 2d       	mov	r23, r9
    1ba8:	0e 94 f1 26 	call	0x4de2	; 0x4de2 <rprintfFloat>
				rprintfCRLF();
    1bac:	0e 94 fa 25 	call	0x4bf4	; 0x4bf4 <rprintfCRLF>
			
			
		}
		vTaskDelayUntil(&xLastWakeTime, (1 / portTICK_RATE_MS));
    1bb0:	c2 01       	movw	r24, r4
    1bb2:	61 e0       	ldi	r22, 0x01	; 1
    1bb4:	70 e0       	ldi	r23, 0x00	; 0
    1bb6:	0e 94 b0 13 	call	0x2760	; 0x2760 <vTaskDelayUntil>
    1bba:	79 cf       	rjmp	.-270    	; 0x1aae <vUbRcv+0x3a>

00001bbc <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1bbc:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    1bbe:	9c 01       	movw	r18, r24
    1bc0:	2d 5f       	subi	r18, 0xFD	; 253
    1bc2:	3f 4f       	sbci	r19, 0xFF	; 255
    1bc4:	32 83       	std	Z+2, r19	; 0x02
    1bc6:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1bc8:	8f ef       	ldi	r24, 0xFF	; 255
    1bca:	9f ef       	ldi	r25, 0xFF	; 255
    1bcc:	94 83       	std	Z+4, r25	; 0x04
    1bce:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1bd0:	36 83       	std	Z+6, r19	; 0x06
    1bd2:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1bd4:	30 87       	std	Z+8, r19	; 0x08
    1bd6:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = 0;
    1bd8:	10 82       	st	Z, r1
}
    1bda:	08 95       	ret

00001bdc <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1bdc:	fc 01       	movw	r30, r24
    1bde:	11 86       	std	Z+9, r1	; 0x09
    1be0:	10 86       	std	Z+8, r1	; 0x08
}
    1be2:	08 95       	ret

00001be4 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1be4:	cf 93       	push	r28
    1be6:	df 93       	push	r29
    1be8:	ac 01       	movw	r20, r24
    1bea:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1bec:	ec 01       	movw	r28, r24
    1bee:	29 81       	ldd	r18, Y+1	; 0x01
    1bf0:	3a 81       	ldd	r19, Y+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    1bf2:	f9 01       	movw	r30, r18
    1bf4:	82 81       	ldd	r24, Z+2	; 0x02
    1bf6:	93 81       	ldd	r25, Z+3	; 0x03
    1bf8:	13 96       	adiw	r26, 0x03	; 3
    1bfa:	9c 93       	st	X, r25
    1bfc:	8e 93       	st	-X, r24
    1bfe:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1c00:	89 81       	ldd	r24, Y+1	; 0x01
    1c02:	9a 81       	ldd	r25, Y+2	; 0x02
    1c04:	15 96       	adiw	r26, 0x05	; 5
    1c06:	9c 93       	st	X, r25
    1c08:	8e 93       	st	-X, r24
    1c0a:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1c0c:	02 80       	ldd	r0, Z+2	; 0x02
    1c0e:	f3 81       	ldd	r31, Z+3	; 0x03
    1c10:	e0 2d       	mov	r30, r0
    1c12:	75 83       	std	Z+5, r23	; 0x05
    1c14:	64 83       	std	Z+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1c16:	e9 01       	movw	r28, r18
    1c18:	7b 83       	std	Y+3, r23	; 0x03
    1c1a:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    1c1c:	fa 01       	movw	r30, r20
    1c1e:	72 83       	std	Z+2, r23	; 0x02
    1c20:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1c22:	19 96       	adiw	r26, 0x09	; 9
    1c24:	5c 93       	st	X, r21
    1c26:	4e 93       	st	-X, r20
    1c28:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
    1c2a:	80 81       	ld	r24, Z
    1c2c:	8f 5f       	subi	r24, 0xFF	; 255
    1c2e:	80 83       	st	Z, r24
}
    1c30:	df 91       	pop	r29
    1c32:	cf 91       	pop	r28
    1c34:	08 95       	ret

00001c36 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    1c36:	cf 93       	push	r28
    1c38:	df 93       	push	r29
    1c3a:	9c 01       	movw	r18, r24
    1c3c:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    1c3e:	48 81       	ld	r20, Y
    1c40:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as 
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the 
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1c42:	8f ef       	ldi	r24, 0xFF	; 255
    1c44:	4f 3f       	cpi	r20, 0xFF	; 255
    1c46:	58 07       	cpc	r21, r24
    1c48:	21 f4       	brne	.+8      	; 0x1c52 <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1c4a:	f9 01       	movw	r30, r18
    1c4c:	a7 81       	ldd	r26, Z+7	; 0x07
    1c4e:	b0 85       	ldd	r27, Z+8	; 0x08
    1c50:	10 c0       	rjmp	.+32     	; 0x1c72 <vListInsert+0x3c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips. 
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    1c52:	d9 01       	movw	r26, r18
    1c54:	13 96       	adiw	r26, 0x03	; 3
    1c56:	04 c0       	rjmp	.+8      	; 0x1c60 <vListInsert+0x2a>
    1c58:	12 96       	adiw	r26, 0x02	; 2
    1c5a:	0d 90       	ld	r0, X+
    1c5c:	bc 91       	ld	r27, X
    1c5e:	a0 2d       	mov	r26, r0
    1c60:	12 96       	adiw	r26, 0x02	; 2
    1c62:	ed 91       	ld	r30, X+
    1c64:	fc 91       	ld	r31, X
    1c66:	13 97       	sbiw	r26, 0x03	; 3
    1c68:	80 81       	ld	r24, Z
    1c6a:	91 81       	ldd	r25, Z+1	; 0x01
    1c6c:	48 17       	cp	r20, r24
    1c6e:	59 07       	cpc	r21, r25
    1c70:	98 f7       	brcc	.-26     	; 0x1c58 <vListInsert+0x22>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1c72:	12 96       	adiw	r26, 0x02	; 2
    1c74:	ed 91       	ld	r30, X+
    1c76:	fc 91       	ld	r31, X
    1c78:	13 97       	sbiw	r26, 0x03	; 3
    1c7a:	fb 83       	std	Y+3, r31	; 0x03
    1c7c:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1c7e:	d5 83       	std	Z+5, r29	; 0x05
    1c80:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1c82:	bd 83       	std	Y+5, r27	; 0x05
    1c84:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1c86:	13 96       	adiw	r26, 0x03	; 3
    1c88:	dc 93       	st	X, r29
    1c8a:	ce 93       	st	-X, r28
    1c8c:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1c8e:	39 87       	std	Y+9, r19	; 0x09
    1c90:	28 87       	std	Y+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    1c92:	f9 01       	movw	r30, r18
    1c94:	80 81       	ld	r24, Z
    1c96:	8f 5f       	subi	r24, 0xFF	; 255
    1c98:	80 83       	st	Z, r24
}
    1c9a:	df 91       	pop	r29
    1c9c:	cf 91       	pop	r28
    1c9e:	08 95       	ret

00001ca0 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    1ca0:	cf 93       	push	r28
    1ca2:	df 93       	push	r29
    1ca4:	dc 01       	movw	r26, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1ca6:	12 96       	adiw	r26, 0x02	; 2
    1ca8:	ed 91       	ld	r30, X+
    1caa:	fc 91       	ld	r31, X
    1cac:	13 97       	sbiw	r26, 0x03	; 3
    1cae:	14 96       	adiw	r26, 0x04	; 4
    1cb0:	8d 91       	ld	r24, X+
    1cb2:	9c 91       	ld	r25, X
    1cb4:	15 97       	sbiw	r26, 0x05	; 5
    1cb6:	95 83       	std	Z+5, r25	; 0x05
    1cb8:	84 83       	std	Z+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1cba:	14 96       	adiw	r26, 0x04	; 4
    1cbc:	cd 91       	ld	r28, X+
    1cbe:	dc 91       	ld	r29, X
    1cc0:	15 97       	sbiw	r26, 0x05	; 5
    1cc2:	fb 83       	std	Y+3, r31	; 0x03
    1cc4:	ea 83       	std	Y+2, r30	; 0x02
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1cc6:	18 96       	adiw	r26, 0x08	; 8
    1cc8:	ed 91       	ld	r30, X+
    1cca:	fc 91       	ld	r31, X
    1ccc:	19 97       	sbiw	r26, 0x09	; 9

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1cce:	81 81       	ldd	r24, Z+1	; 0x01
    1cd0:	92 81       	ldd	r25, Z+2	; 0x02
    1cd2:	8a 17       	cp	r24, r26
    1cd4:	9b 07       	cpc	r25, r27
    1cd6:	11 f4       	brne	.+4      	; 0x1cdc <vListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1cd8:	d2 83       	std	Z+2, r29	; 0x02
    1cda:	c1 83       	std	Z+1, r28	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    1cdc:	19 96       	adiw	r26, 0x09	; 9
    1cde:	1c 92       	st	X, r1
    1ce0:	1e 92       	st	-X, r1
    1ce2:	18 97       	sbiw	r26, 0x08	; 8
	( pxList->uxNumberOfItems )--;
    1ce4:	80 81       	ld	r24, Z
    1ce6:	81 50       	subi	r24, 0x01	; 1
    1ce8:	80 83       	st	Z, r24
}
    1cea:	df 91       	pop	r29
    1cec:	cf 91       	pop	r28
    1cee:	08 95       	ret

00001cf0 <uxQueueMessagesWaiting>:
	return xReturn;
}
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    1cf0:	fc 01       	movw	r30, r24
unsigned portBASE_TYPE uxReturn;

	taskENTER_CRITICAL();
    1cf2:	0f b6       	in	r0, 0x3f	; 63
    1cf4:	f8 94       	cli
    1cf6:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1cf8:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    1cfa:	0f 90       	pop	r0
    1cfc:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    1cfe:	08 95       	ret

00001d00 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    1d00:	fc 01       	movw	r30, r24
unsigned portBASE_TYPE uxReturn;

	uxReturn = pxQueue->uxMessagesWaiting;
    1d02:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
    1d04:	08 95       	ret

00001d06 <xQueueIsQueueEmptyFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    1d06:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1d08:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d0a:	90 e0       	ldi	r25, 0x00	; 0
    1d0c:	88 23       	and	r24, r24
    1d0e:	09 f4       	brne	.+2      	; 0x1d12 <xQueueIsQueueEmptyFromISR+0xc>
    1d10:	91 e0       	ldi	r25, 0x01	; 1

	return xReturn;
}
    1d12:	89 2f       	mov	r24, r25
    1d14:	08 95       	ret

00001d16 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    1d16:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    1d18:	92 8d       	ldd	r25, Z+26	; 0x1a
    1d1a:	20 e0       	ldi	r18, 0x00	; 0
    1d1c:	83 8d       	ldd	r24, Z+27	; 0x1b
    1d1e:	98 17       	cp	r25, r24
    1d20:	09 f4       	brne	.+2      	; 0x1d24 <xQueueIsQueueFullFromISR+0xe>
    1d22:	21 e0       	ldi	r18, 0x01	; 1

	return xReturn;
}
    1d24:	82 2f       	mov	r24, r18
    1d26:	08 95       	ret

00001d28 <vQueueDelete>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    1d28:	0f 93       	push	r16
    1d2a:	1f 93       	push	r17
    1d2c:	8c 01       	movw	r16, r24
	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    1d2e:	fc 01       	movw	r30, r24
    1d30:	80 81       	ld	r24, Z
    1d32:	91 81       	ldd	r25, Z+1	; 0x01
    1d34:	0e 94 ed 18 	call	0x31da	; 0x31da <vPortFree>
	vPortFree( pxQueue );
    1d38:	c8 01       	movw	r24, r16
    1d3a:	0e 94 ed 18 	call	0x31da	; 0x31da <vPortFree>
}
    1d3e:	1f 91       	pop	r17
    1d40:	0f 91       	pop	r16
    1d42:	08 95       	ret

00001d44 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    1d44:	0f 93       	push	r16
    1d46:	1f 93       	push	r17
    1d48:	cf 93       	push	r28
    1d4a:	df 93       	push	r29
    1d4c:	ec 01       	movw	r28, r24
    1d4e:	fb 01       	movw	r30, r22
    1d50:	8a 01       	movw	r16, r20
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1d52:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1d54:	88 23       	and	r24, r24
    1d56:	81 f1       	breq	.+96     	; 0x1db8 <xQueueReceiveFromISR+0x74>
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    1d58:	48 81       	ld	r20, Y
    1d5a:	59 81       	ldd	r21, Y+1	; 0x01
    1d5c:	41 15       	cp	r20, r1
    1d5e:	51 05       	cpc	r21, r1
    1d60:	a9 f0       	breq	.+42     	; 0x1d8c <xQueueReceiveFromISR+0x48>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    1d62:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1d64:	2e 81       	ldd	r18, Y+6	; 0x06
    1d66:	3f 81       	ldd	r19, Y+7	; 0x07
    1d68:	28 0f       	add	r18, r24
    1d6a:	31 1d       	adc	r19, r1
    1d6c:	3f 83       	std	Y+7, r19	; 0x07
    1d6e:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    1d70:	8a 81       	ldd	r24, Y+2	; 0x02
    1d72:	9b 81       	ldd	r25, Y+3	; 0x03
    1d74:	28 17       	cp	r18, r24
    1d76:	39 07       	cpc	r19, r25
    1d78:	10 f0       	brcs	.+4      	; 0x1d7e <xQueueReceiveFromISR+0x3a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    1d7a:	5f 83       	std	Y+7, r21	; 0x07
    1d7c:	4e 83       	std	Y+6, r20	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1d7e:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1d80:	6e 81       	ldd	r22, Y+6	; 0x06
    1d82:	7f 81       	ldd	r23, Y+7	; 0x07
    1d84:	cf 01       	movw	r24, r30
    1d86:	50 e0       	ldi	r21, 0x00	; 0
    1d88:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <memcpy>
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
			--( pxQueue->uxMessagesWaiting );
    1d8c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1d8e:	81 50       	subi	r24, 0x01	; 1
    1d90:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1d92:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1d94:	8f 3f       	cpi	r24, 0xFF	; 255
    1d96:	69 f4       	brne	.+26     	; 0x1db2 <xQueueReceiveFromISR+0x6e>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
    1d98:	88 85       	ldd	r24, Y+8	; 0x08
    1d9a:	88 23       	and	r24, r24
    1d9c:	61 f0       	breq	.+24     	; 0x1db6 <xQueueReceiveFromISR+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1d9e:	ce 01       	movw	r24, r28
    1da0:	08 96       	adiw	r24, 0x08	; 8
    1da2:	0e 94 02 12 	call	0x2404	; 0x2404 <xTaskRemoveFromEventList>
    1da6:	88 23       	and	r24, r24
    1da8:	31 f0       	breq	.+12     	; 0x1db6 <xQueueReceiveFromISR+0x72>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    1daa:	81 e0       	ldi	r24, 0x01	; 1
    1dac:	f8 01       	movw	r30, r16
    1dae:	80 83       	st	Z, r24
    1db0:	03 c0       	rjmp	.+6      	; 0x1db8 <xQueueReceiveFromISR+0x74>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1db2:	8f 5f       	subi	r24, 0xFF	; 255
    1db4:	8d 8f       	std	Y+29, r24	; 0x1d
    1db6:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1db8:	df 91       	pop	r29
    1dba:	cf 91       	pop	r28
    1dbc:	1f 91       	pop	r17
    1dbe:	0f 91       	pop	r16
    1dc0:	08 95       	ret

00001dc2 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    1dc2:	cf 93       	push	r28
    1dc4:	df 93       	push	r29
    1dc6:	ec 01       	movw	r28, r24
    1dc8:	84 2f       	mov	r24, r20
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    1dca:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1dcc:	44 23       	and	r20, r20
    1dce:	a1 f1       	breq	.+104    	; 0x1e38 <prvCopyDataToQueue+0x76>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    1dd0:	88 23       	and	r24, r24
    1dd2:	b1 f4       	brne	.+44     	; 0x1e00 <prvCopyDataToQueue+0x3e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1dd4:	8c 81       	ldd	r24, Y+4	; 0x04
    1dd6:	9d 81       	ldd	r25, Y+5	; 0x05
    1dd8:	50 e0       	ldi	r21, 0x00	; 0
    1dda:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    1dde:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1de0:	2c 81       	ldd	r18, Y+4	; 0x04
    1de2:	3d 81       	ldd	r19, Y+5	; 0x05
    1de4:	28 0f       	add	r18, r24
    1de6:	31 1d       	adc	r19, r1
    1de8:	3d 83       	std	Y+5, r19	; 0x05
    1dea:	2c 83       	std	Y+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    1dec:	8a 81       	ldd	r24, Y+2	; 0x02
    1dee:	9b 81       	ldd	r25, Y+3	; 0x03
    1df0:	28 17       	cp	r18, r24
    1df2:	39 07       	cpc	r19, r25
    1df4:	08 f1       	brcs	.+66     	; 0x1e38 <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1df6:	88 81       	ld	r24, Y
    1df8:	99 81       	ldd	r25, Y+1	; 0x01
    1dfa:	9d 83       	std	Y+5, r25	; 0x05
    1dfc:	8c 83       	std	Y+4, r24	; 0x04
    1dfe:	1c c0       	rjmp	.+56     	; 0x1e38 <prvCopyDataToQueue+0x76>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1e00:	8e 81       	ldd	r24, Y+6	; 0x06
    1e02:	9f 81       	ldd	r25, Y+7	; 0x07
    1e04:	50 e0       	ldi	r21, 0x00	; 0
    1e06:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    1e0a:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1e0c:	90 e0       	ldi	r25, 0x00	; 0
    1e0e:	44 27       	eor	r20, r20
    1e10:	55 27       	eor	r21, r21
    1e12:	48 1b       	sub	r20, r24
    1e14:	59 0b       	sbc	r21, r25
    1e16:	8e 81       	ldd	r24, Y+6	; 0x06
    1e18:	9f 81       	ldd	r25, Y+7	; 0x07
    1e1a:	84 0f       	add	r24, r20
    1e1c:	95 1f       	adc	r25, r21
    1e1e:	9f 83       	std	Y+7, r25	; 0x07
    1e20:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    1e22:	28 81       	ld	r18, Y
    1e24:	39 81       	ldd	r19, Y+1	; 0x01
    1e26:	82 17       	cp	r24, r18
    1e28:	93 07       	cpc	r25, r19
    1e2a:	30 f4       	brcc	.+12     	; 0x1e38 <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    1e2c:	8a 81       	ldd	r24, Y+2	; 0x02
    1e2e:	9b 81       	ldd	r25, Y+3	; 0x03
    1e30:	84 0f       	add	r24, r20
    1e32:	95 1f       	adc	r25, r21
    1e34:	9f 83       	std	Y+7, r25	; 0x07
    1e36:	8e 83       	std	Y+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    1e38:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1e3a:	8f 5f       	subi	r24, 0xFF	; 255
    1e3c:	8a 8f       	std	Y+26, r24	; 0x1a
}
    1e3e:	df 91       	pop	r29
    1e40:	cf 91       	pop	r28
    1e42:	08 95       	ret

00001e44 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    1e44:	0f 93       	push	r16
    1e46:	1f 93       	push	r17
    1e48:	cf 93       	push	r28
    1e4a:	df 93       	push	r29
    1e4c:	ec 01       	movw	r28, r24
    1e4e:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1e50:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1e52:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1e54:	98 17       	cp	r25, r24
    1e56:	10 f0       	brcs	.+4      	; 0x1e5c <xQueueGenericSendFromISR+0x18>
    1e58:	80 e0       	ldi	r24, 0x00	; 0
    1e5a:	17 c0       	rjmp	.+46     	; 0x1e8a <xQueueGenericSendFromISR+0x46>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1e5c:	ce 01       	movw	r24, r28
    1e5e:	42 2f       	mov	r20, r18
    1e60:	0e 94 e1 0e 	call	0x1dc2	; 0x1dc2 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1e64:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1e66:	8f 3f       	cpi	r24, 0xFF	; 255
    1e68:	69 f4       	brne	.+26     	; 0x1e84 <xQueueGenericSendFromISR+0x40>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    1e6a:	89 89       	ldd	r24, Y+17	; 0x11
    1e6c:	88 23       	and	r24, r24
    1e6e:	61 f0       	breq	.+24     	; 0x1e88 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1e70:	ce 01       	movw	r24, r28
    1e72:	41 96       	adiw	r24, 0x11	; 17
    1e74:	0e 94 02 12 	call	0x2404	; 0x2404 <xTaskRemoveFromEventList>
    1e78:	88 23       	and	r24, r24
    1e7a:	31 f0       	breq	.+12     	; 0x1e88 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    1e7c:	81 e0       	ldi	r24, 0x01	; 1
    1e7e:	f8 01       	movw	r30, r16
    1e80:	80 83       	st	Z, r24
    1e82:	03 c0       	rjmp	.+6      	; 0x1e8a <xQueueGenericSendFromISR+0x46>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1e84:	8f 5f       	subi	r24, 0xFF	; 255
    1e86:	8e 8f       	std	Y+30, r24	; 0x1e
    1e88:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1e8a:	df 91       	pop	r29
    1e8c:	cf 91       	pop	r28
    1e8e:	1f 91       	pop	r17
    1e90:	0f 91       	pop	r16
    1e92:	08 95       	ret

00001e94 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    1e94:	0f 93       	push	r16
    1e96:	1f 93       	push	r17
    1e98:	cf 93       	push	r28
    1e9a:	df 93       	push	r29
    1e9c:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1e9e:	0f b6       	in	r0, 0x3f	; 63
    1ea0:	f8 94       	cli
    1ea2:	0f 92       	push	r0
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1ea4:	8c 01       	movw	r16, r24
    1ea6:	0f 5e       	subi	r16, 0xEF	; 239
    1ea8:	1f 4f       	sbci	r17, 0xFF	; 255
    1eaa:	0d c0       	rjmp	.+26     	; 0x1ec6 <prvUnlockQueue+0x32>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    1eac:	89 89       	ldd	r24, Y+17	; 0x11
    1eae:	88 23       	and	r24, r24
    1eb0:	69 f0       	breq	.+26     	; 0x1ecc <prvUnlockQueue+0x38>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1eb2:	c8 01       	movw	r24, r16
    1eb4:	0e 94 02 12 	call	0x2404	; 0x2404 <xTaskRemoveFromEventList>
    1eb8:	88 23       	and	r24, r24
    1eba:	11 f0       	breq	.+4      	; 0x1ec0 <prvUnlockQueue+0x2c>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    1ebc:	0e 94 fe 11 	call	0x23fc	; 0x23fc <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    1ec0:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1ec2:	81 50       	subi	r24, 0x01	; 1
    1ec4:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1ec6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1ec8:	18 16       	cp	r1, r24
    1eca:	84 f3       	brlt	.-32     	; 0x1eac <prvUnlockQueue+0x18>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    1ecc:	8f ef       	ldi	r24, 0xFF	; 255
    1ece:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1ed0:	0f 90       	pop	r0
    1ed2:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1ed4:	0f b6       	in	r0, 0x3f	; 63
    1ed6:	f8 94       	cli
    1ed8:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1eda:	8e 01       	movw	r16, r28
    1edc:	08 5f       	subi	r16, 0xF8	; 248
    1ede:	1f 4f       	sbci	r17, 0xFF	; 255
    1ee0:	0d c0       	rjmp	.+26     	; 0x1efc <prvUnlockQueue+0x68>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
    1ee2:	88 85       	ldd	r24, Y+8	; 0x08
    1ee4:	88 23       	and	r24, r24
    1ee6:	69 f0       	breq	.+26     	; 0x1f02 <prvUnlockQueue+0x6e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1ee8:	c8 01       	movw	r24, r16
    1eea:	0e 94 02 12 	call	0x2404	; 0x2404 <xTaskRemoveFromEventList>
    1eee:	88 23       	and	r24, r24
    1ef0:	11 f0       	breq	.+4      	; 0x1ef6 <prvUnlockQueue+0x62>
				{
					vTaskMissedYield();
    1ef2:	0e 94 fe 11 	call	0x23fc	; 0x23fc <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    1ef6:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1ef8:	81 50       	subi	r24, 0x01	; 1
    1efa:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1efc:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1efe:	18 16       	cp	r1, r24
    1f00:	84 f3       	brlt	.-32     	; 0x1ee2 <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    1f02:	8f ef       	ldi	r24, 0xFF	; 255
    1f04:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1f06:	0f 90       	pop	r0
    1f08:	0f be       	out	0x3f, r0	; 63
}
    1f0a:	df 91       	pop	r29
    1f0c:	cf 91       	pop	r28
    1f0e:	1f 91       	pop	r17
    1f10:	0f 91       	pop	r16
    1f12:	08 95       	ret

00001f14 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    1f14:	7f 92       	push	r7
    1f16:	8f 92       	push	r8
    1f18:	9f 92       	push	r9
    1f1a:	af 92       	push	r10
    1f1c:	bf 92       	push	r11
    1f1e:	cf 92       	push	r12
    1f20:	df 92       	push	r13
    1f22:	ef 92       	push	r14
    1f24:	ff 92       	push	r15
    1f26:	0f 93       	push	r16
    1f28:	1f 93       	push	r17
    1f2a:	df 93       	push	r29
    1f2c:	cf 93       	push	r28
    1f2e:	00 d0       	rcall	.+0      	; 0x1f30 <xQueueGenericReceive+0x1c>
    1f30:	00 d0       	rcall	.+0      	; 0x1f32 <xQueueGenericReceive+0x1e>
    1f32:	0f 92       	push	r0
    1f34:	cd b7       	in	r28, 0x3d	; 61
    1f36:	de b7       	in	r29, 0x3e	; 62
    1f38:	8c 01       	movw	r16, r24
    1f3a:	96 2e       	mov	r9, r22
    1f3c:	87 2e       	mov	r8, r23
    1f3e:	5d 83       	std	Y+5, r21	; 0x05
    1f40:	4c 83       	std	Y+4, r20	; 0x04
    1f42:	72 2e       	mov	r7, r18
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1f44:	91 e1       	ldi	r25, 0x11	; 17
    1f46:	c9 2e       	mov	r12, r25
    1f48:	d1 2c       	mov	r13, r1
    1f4a:	c0 0e       	add	r12, r16
    1f4c:	d1 1e       	adc	r13, r17
    1f4e:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1f50:	7e 01       	movw	r14, r28
    1f52:	08 94       	sec
    1f54:	e1 1c       	adc	r14, r1
    1f56:	f1 1c       	adc	r15, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1f58:	84 e0       	ldi	r24, 0x04	; 4
    1f5a:	a8 2e       	mov	r10, r24
    1f5c:	b1 2c       	mov	r11, r1
    1f5e:	ac 0e       	add	r10, r28
    1f60:	bd 1e       	adc	r11, r29
    1f62:	01 c0       	rjmp	.+2      	; 0x1f66 <xQueueGenericReceive+0x52>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1f64:	21 e0       	ldi	r18, 0x01	; 1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1f66:	0f b6       	in	r0, 0x3f	; 63
    1f68:	f8 94       	cli
    1f6a:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1f6c:	f8 01       	movw	r30, r16
    1f6e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f70:	88 23       	and	r24, r24
    1f72:	09 f4       	brne	.+2      	; 0x1f76 <xQueueGenericReceive+0x62>
    1f74:	3e c0       	rjmp	.+124    	; 0x1ff2 <xQueueGenericReceive+0xde>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1f76:	e6 80       	ldd	r14, Z+6	; 0x06
    1f78:	f7 80       	ldd	r15, Z+7	; 0x07
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    1f7a:	40 81       	ld	r20, Z
    1f7c:	51 81       	ldd	r21, Z+1	; 0x01
    1f7e:	41 15       	cp	r20, r1
    1f80:	51 05       	cpc	r21, r1
    1f82:	b1 f0       	breq	.+44     	; 0x1fb0 <xQueueGenericReceive+0x9c>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    1f84:	84 8d       	ldd	r24, Z+28	; 0x1c
    1f86:	97 01       	movw	r18, r14
    1f88:	28 0f       	add	r18, r24
    1f8a:	31 1d       	adc	r19, r1
    1f8c:	37 83       	std	Z+7, r19	; 0x07
    1f8e:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    1f90:	82 81       	ldd	r24, Z+2	; 0x02
    1f92:	93 81       	ldd	r25, Z+3	; 0x03
    1f94:	28 17       	cp	r18, r24
    1f96:	39 07       	cpc	r19, r25
    1f98:	10 f0       	brcs	.+4      	; 0x1f9e <xQueueGenericReceive+0x8a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    1f9a:	57 83       	std	Z+7, r21	; 0x07
    1f9c:	46 83       	std	Z+6, r20	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1f9e:	f8 01       	movw	r30, r16
    1fa0:	44 8d       	ldd	r20, Z+28	; 0x1c
    1fa2:	66 81       	ldd	r22, Z+6	; 0x06
    1fa4:	77 81       	ldd	r23, Z+7	; 0x07
    1fa6:	89 2d       	mov	r24, r9
    1fa8:	98 2d       	mov	r25, r8
    1faa:	50 e0       	ldi	r21, 0x00	; 0
    1fac:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <memcpy>
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
    1fb0:	77 20       	and	r7, r7
    1fb2:	71 f4       	brne	.+28     	; 0x1fd0 <xQueueGenericReceive+0xbc>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1fb4:	f8 01       	movw	r30, r16
    1fb6:	82 8d       	ldd	r24, Z+26	; 0x1a
    1fb8:	81 50       	subi	r24, 0x01	; 1
    1fba:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1fbc:	80 85       	ldd	r24, Z+8	; 0x08
    1fbe:	88 23       	and	r24, r24
    1fc0:	a1 f0       	breq	.+40     	; 0x1fea <xQueueGenericReceive+0xd6>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1fc2:	c8 01       	movw	r24, r16
    1fc4:	08 96       	adiw	r24, 0x08	; 8
    1fc6:	0e 94 02 12 	call	0x2404	; 0x2404 <xTaskRemoveFromEventList>
    1fca:	81 30       	cpi	r24, 0x01	; 1
    1fcc:	71 f4       	brne	.+28     	; 0x1fea <xQueueGenericReceive+0xd6>
    1fce:	0b c0       	rjmp	.+22     	; 0x1fe6 <xQueueGenericReceive+0xd2>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    1fd0:	f8 01       	movw	r30, r16
    1fd2:	f7 82       	std	Z+7, r15	; 0x07
    1fd4:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    1fd6:	81 89       	ldd	r24, Z+17	; 0x11
    1fd8:	88 23       	and	r24, r24
    1fda:	39 f0       	breq	.+14     	; 0x1fea <xQueueGenericReceive+0xd6>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1fdc:	c6 01       	movw	r24, r12
    1fde:	0e 94 02 12 	call	0x2404	; 0x2404 <xTaskRemoveFromEventList>
    1fe2:	88 23       	and	r24, r24
    1fe4:	11 f0       	breq	.+4      	; 0x1fea <xQueueGenericReceive+0xd6>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    1fe6:	0e 94 ca 16 	call	0x2d94	; 0x2d94 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    1fea:	0f 90       	pop	r0
    1fec:	0f be       	out	0x3f, r0	; 63
    1fee:	81 e0       	ldi	r24, 0x01	; 1
    1ff0:	4a c0       	rjmp	.+148    	; 0x2086 <xQueueGenericReceive+0x172>
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1ff2:	8c 81       	ldd	r24, Y+4	; 0x04
    1ff4:	9d 81       	ldd	r25, Y+5	; 0x05
    1ff6:	89 2b       	or	r24, r25
    1ff8:	19 f4       	brne	.+6      	; 0x2000 <xQueueGenericReceive+0xec>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1ffa:	0f 90       	pop	r0
    1ffc:	0f be       	out	0x3f, r0	; 63
    1ffe:	42 c0       	rjmp	.+132    	; 0x2084 <xQueueGenericReceive+0x170>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    2000:	22 23       	and	r18, r18
    2002:	19 f4       	brne	.+6      	; 0x200a <xQueueGenericReceive+0xf6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2004:	c7 01       	movw	r24, r14
    2006:	0e 94 b9 11 	call	0x2372	; 0x2372 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    200a:	0f 90       	pop	r0
    200c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    200e:	0e 94 5d 11 	call	0x22ba	; 0x22ba <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2012:	0f b6       	in	r0, 0x3f	; 63
    2014:	f8 94       	cli
    2016:	0f 92       	push	r0
    2018:	f8 01       	movw	r30, r16
    201a:	85 8d       	ldd	r24, Z+29	; 0x1d
    201c:	8f 3f       	cpi	r24, 0xFF	; 255
    201e:	09 f4       	brne	.+2      	; 0x2022 <xQueueGenericReceive+0x10e>
    2020:	15 8e       	std	Z+29, r1	; 0x1d
    2022:	f8 01       	movw	r30, r16
    2024:	86 8d       	ldd	r24, Z+30	; 0x1e
    2026:	8f 3f       	cpi	r24, 0xFF	; 255
    2028:	09 f4       	brne	.+2      	; 0x202c <xQueueGenericReceive+0x118>
    202a:	16 8e       	std	Z+30, r1	; 0x1e
    202c:	0f 90       	pop	r0
    202e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2030:	c7 01       	movw	r24, r14
    2032:	b5 01       	movw	r22, r10
    2034:	0e 94 c4 11 	call	0x2388	; 0x2388 <xTaskCheckForTimeOut>
    2038:	88 23       	and	r24, r24
    203a:	f9 f4       	brne	.+62     	; 0x207a <xQueueGenericReceive+0x166>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    203c:	0f b6       	in	r0, 0x3f	; 63
    203e:	f8 94       	cli
    2040:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    2042:	f8 01       	movw	r30, r16
    2044:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    2046:	0f 90       	pop	r0
    2048:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
    204a:	88 23       	and	r24, r24
    204c:	81 f4       	brne	.+32     	; 0x206e <xQueueGenericReceive+0x15a>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    204e:	6c 81       	ldd	r22, Y+4	; 0x04
    2050:	7d 81       	ldd	r23, Y+5	; 0x05
    2052:	c6 01       	movw	r24, r12
    2054:	0e 94 bb 12 	call	0x2576	; 0x2576 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2058:	c8 01       	movw	r24, r16
    205a:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <prvUnlockQueue>
				if( !xTaskResumeAll() )
    205e:	0e 94 f4 12 	call	0x25e8	; 0x25e8 <xTaskResumeAll>
    2062:	88 23       	and	r24, r24
    2064:	09 f0       	breq	.+2      	; 0x2068 <xQueueGenericReceive+0x154>
    2066:	7e cf       	rjmp	.-260    	; 0x1f64 <xQueueGenericReceive+0x50>
				{
					portYIELD_WITHIN_API();
    2068:	0e 94 ca 16 	call	0x2d94	; 0x2d94 <vPortYield>
    206c:	7b cf       	rjmp	.-266    	; 0x1f64 <xQueueGenericReceive+0x50>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    206e:	c8 01       	movw	r24, r16
    2070:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2074:	0e 94 f4 12 	call	0x25e8	; 0x25e8 <xTaskResumeAll>
    2078:	75 cf       	rjmp	.-278    	; 0x1f64 <xQueueGenericReceive+0x50>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    207a:	c8 01       	movw	r24, r16
    207c:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2080:	0e 94 f4 12 	call	0x25e8	; 0x25e8 <xTaskResumeAll>
    2084:	80 e0       	ldi	r24, 0x00	; 0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
    2086:	0f 90       	pop	r0
    2088:	0f 90       	pop	r0
    208a:	0f 90       	pop	r0
    208c:	0f 90       	pop	r0
    208e:	0f 90       	pop	r0
    2090:	cf 91       	pop	r28
    2092:	df 91       	pop	r29
    2094:	1f 91       	pop	r17
    2096:	0f 91       	pop	r16
    2098:	ff 90       	pop	r15
    209a:	ef 90       	pop	r14
    209c:	df 90       	pop	r13
    209e:	cf 90       	pop	r12
    20a0:	bf 90       	pop	r11
    20a2:	af 90       	pop	r10
    20a4:	9f 90       	pop	r9
    20a6:	8f 90       	pop	r8
    20a8:	7f 90       	pop	r7
    20aa:	08 95       	ret

000020ac <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    20ac:	7f 92       	push	r7
    20ae:	8f 92       	push	r8
    20b0:	9f 92       	push	r9
    20b2:	af 92       	push	r10
    20b4:	bf 92       	push	r11
    20b6:	cf 92       	push	r12
    20b8:	df 92       	push	r13
    20ba:	ef 92       	push	r14
    20bc:	ff 92       	push	r15
    20be:	0f 93       	push	r16
    20c0:	1f 93       	push	r17
    20c2:	df 93       	push	r29
    20c4:	cf 93       	push	r28
    20c6:	00 d0       	rcall	.+0      	; 0x20c8 <xQueueGenericSend+0x1c>
    20c8:	00 d0       	rcall	.+0      	; 0x20ca <xQueueGenericSend+0x1e>
    20ca:	0f 92       	push	r0
    20cc:	cd b7       	in	r28, 0x3d	; 61
    20ce:	de b7       	in	r29, 0x3e	; 62
    20d0:	8c 01       	movw	r16, r24
    20d2:	6b 01       	movw	r12, r22
    20d4:	5d 83       	std	Y+5, r21	; 0x05
    20d6:	4c 83       	std	Y+4, r20	; 0x04
    20d8:	72 2e       	mov	r7, r18
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    20da:	48 e0       	ldi	r20, 0x08	; 8
    20dc:	e4 2e       	mov	r14, r20
    20de:	f1 2c       	mov	r15, r1
    20e0:	e8 0e       	add	r14, r24
    20e2:	f9 1e       	adc	r15, r25
    20e4:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    20e6:	5e 01       	movw	r10, r28
    20e8:	08 94       	sec
    20ea:	a1 1c       	adc	r10, r1
    20ec:	b1 1c       	adc	r11, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    20ee:	34 e0       	ldi	r19, 0x04	; 4
    20f0:	83 2e       	mov	r8, r19
    20f2:	91 2c       	mov	r9, r1
    20f4:	8c 0e       	add	r8, r28
    20f6:	9d 1e       	adc	r9, r29
    20f8:	01 c0       	rjmp	.+2      	; 0x20fc <xQueueGenericSend+0x50>
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    20fa:	21 e0       	ldi	r18, 0x01	; 1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    20fc:	0f b6       	in	r0, 0x3f	; 63
    20fe:	f8 94       	cli
    2100:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    2102:	f8 01       	movw	r30, r16
    2104:	92 8d       	ldd	r25, Z+26	; 0x1a
    2106:	83 8d       	ldd	r24, Z+27	; 0x1b
    2108:	98 17       	cp	r25, r24
    210a:	a8 f4       	brcc	.+42     	; 0x2136 <xQueueGenericSend+0x8a>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    210c:	c8 01       	movw	r24, r16
    210e:	b6 01       	movw	r22, r12
    2110:	47 2d       	mov	r20, r7
    2112:	0e 94 e1 0e 	call	0x1dc2	; 0x1dc2 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2116:	f8 01       	movw	r30, r16
    2118:	81 89       	ldd	r24, Z+17	; 0x11
    211a:	88 23       	and	r24, r24
    211c:	41 f0       	breq	.+16     	; 0x212e <xQueueGenericSend+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    211e:	c8 01       	movw	r24, r16
    2120:	41 96       	adiw	r24, 0x11	; 17
    2122:	0e 94 02 12 	call	0x2404	; 0x2404 <xTaskRemoveFromEventList>
    2126:	81 30       	cpi	r24, 0x01	; 1
    2128:	11 f4       	brne	.+4      	; 0x212e <xQueueGenericSend+0x82>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    212a:	0e 94 ca 16 	call	0x2d94	; 0x2d94 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    212e:	0f 90       	pop	r0
    2130:	0f be       	out	0x3f, r0	; 63
    2132:	81 e0       	ldi	r24, 0x01	; 1
    2134:	4c c0       	rjmp	.+152    	; 0x21ce <xQueueGenericSend+0x122>
				function. */
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    2136:	8c 81       	ldd	r24, Y+4	; 0x04
    2138:	9d 81       	ldd	r25, Y+5	; 0x05
    213a:	89 2b       	or	r24, r25
    213c:	19 f4       	brne	.+6      	; 0x2144 <xQueueGenericSend+0x98>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    213e:	0f 90       	pop	r0
    2140:	0f be       	out	0x3f, r0	; 63
    2142:	44 c0       	rjmp	.+136    	; 0x21cc <xQueueGenericSend+0x120>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    2144:	22 23       	and	r18, r18
    2146:	19 f4       	brne	.+6      	; 0x214e <xQueueGenericSend+0xa2>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2148:	c5 01       	movw	r24, r10
    214a:	0e 94 b9 11 	call	0x2372	; 0x2372 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    214e:	0f 90       	pop	r0
    2150:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2152:	0e 94 5d 11 	call	0x22ba	; 0x22ba <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2156:	0f b6       	in	r0, 0x3f	; 63
    2158:	f8 94       	cli
    215a:	0f 92       	push	r0
    215c:	f8 01       	movw	r30, r16
    215e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2160:	8f 3f       	cpi	r24, 0xFF	; 255
    2162:	09 f4       	brne	.+2      	; 0x2166 <xQueueGenericSend+0xba>
    2164:	15 8e       	std	Z+29, r1	; 0x1d
    2166:	f8 01       	movw	r30, r16
    2168:	86 8d       	ldd	r24, Z+30	; 0x1e
    216a:	8f 3f       	cpi	r24, 0xFF	; 255
    216c:	09 f4       	brne	.+2      	; 0x2170 <xQueueGenericSend+0xc4>
    216e:	16 8e       	std	Z+30, r1	; 0x1e
    2170:	0f 90       	pop	r0
    2172:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2174:	c5 01       	movw	r24, r10
    2176:	b4 01       	movw	r22, r8
    2178:	0e 94 c4 11 	call	0x2388	; 0x2388 <xTaskCheckForTimeOut>
    217c:	88 23       	and	r24, r24
    217e:	09 f5       	brne	.+66     	; 0x21c2 <xQueueGenericSend+0x116>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    2180:	0f b6       	in	r0, 0x3f	; 63
    2182:	f8 94       	cli
    2184:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    2186:	f8 01       	movw	r30, r16
    2188:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    218a:	0f 90       	pop	r0
    218c:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
    218e:	f8 01       	movw	r30, r16
    2190:	83 8d       	ldd	r24, Z+27	; 0x1b
    2192:	98 17       	cp	r25, r24
    2194:	81 f4       	brne	.+32     	; 0x21b6 <xQueueGenericSend+0x10a>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2196:	6c 81       	ldd	r22, Y+4	; 0x04
    2198:	7d 81       	ldd	r23, Y+5	; 0x05
    219a:	c7 01       	movw	r24, r14
    219c:	0e 94 bb 12 	call	0x2576	; 0x2576 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    21a0:	c8 01       	movw	r24, r16
    21a2:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
    21a6:	0e 94 f4 12 	call	0x25e8	; 0x25e8 <xTaskResumeAll>
    21aa:	88 23       	and	r24, r24
    21ac:	09 f0       	breq	.+2      	; 0x21b0 <xQueueGenericSend+0x104>
    21ae:	a5 cf       	rjmp	.-182    	; 0x20fa <xQueueGenericSend+0x4e>
				{
					portYIELD_WITHIN_API();
    21b0:	0e 94 ca 16 	call	0x2d94	; 0x2d94 <vPortYield>
    21b4:	a2 cf       	rjmp	.-188    	; 0x20fa <xQueueGenericSend+0x4e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    21b6:	c8 01       	movw	r24, r16
    21b8:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    21bc:	0e 94 f4 12 	call	0x25e8	; 0x25e8 <xTaskResumeAll>
    21c0:	9c cf       	rjmp	.-200    	; 0x20fa <xQueueGenericSend+0x4e>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    21c2:	c8 01       	movw	r24, r16
    21c4:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    21c8:	0e 94 f4 12 	call	0x25e8	; 0x25e8 <xTaskResumeAll>
    21cc:	80 e0       	ldi	r24, 0x00	; 0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
    21ce:	0f 90       	pop	r0
    21d0:	0f 90       	pop	r0
    21d2:	0f 90       	pop	r0
    21d4:	0f 90       	pop	r0
    21d6:	0f 90       	pop	r0
    21d8:	cf 91       	pop	r28
    21da:	df 91       	pop	r29
    21dc:	1f 91       	pop	r17
    21de:	0f 91       	pop	r16
    21e0:	ff 90       	pop	r15
    21e2:	ef 90       	pop	r14
    21e4:	df 90       	pop	r13
    21e6:	cf 90       	pop	r12
    21e8:	bf 90       	pop	r11
    21ea:	af 90       	pop	r10
    21ec:	9f 90       	pop	r9
    21ee:	8f 90       	pop	r8
    21f0:	7f 90       	pop	r7
    21f2:	08 95       	ret

000021f4 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    21f4:	8f 92       	push	r8
    21f6:	9f 92       	push	r9
    21f8:	af 92       	push	r10
    21fa:	bf 92       	push	r11
    21fc:	cf 92       	push	r12
    21fe:	df 92       	push	r13
    2200:	ef 92       	push	r14
    2202:	ff 92       	push	r15
    2204:	0f 93       	push	r16
    2206:	1f 93       	push	r17
    2208:	cf 93       	push	r28
    220a:	df 93       	push	r29
    220c:	98 2e       	mov	r9, r24
    220e:	86 2e       	mov	r8, r22
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    2210:	88 23       	and	r24, r24
    2212:	09 f4       	brne	.+2      	; 0x2216 <__stack+0x17>
    2214:	42 c0       	rjmp	.+132    	; 0x229a <__stack+0x9b>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    2216:	8f e1       	ldi	r24, 0x1F	; 31
    2218:	90 e0       	ldi	r25, 0x00	; 0
    221a:	0e 94 fd 18 	call	0x31fa	; 0x31fa <pvPortMalloc>
    221e:	8c 01       	movw	r16, r24
    2220:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    2222:	00 97       	sbiw	r24, 0x00	; 0
    2224:	e1 f1       	breq	.+120    	; 0x229e <__stack+0x9f>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    2226:	c9 2c       	mov	r12, r9
    2228:	dd 24       	eor	r13, r13
    222a:	a8 2c       	mov	r10, r8
    222c:	bb 24       	eor	r11, r11
    222e:	ac 9c       	mul	r10, r12
    2230:	70 01       	movw	r14, r0
    2232:	ad 9c       	mul	r10, r13
    2234:	f0 0c       	add	r15, r0
    2236:	bc 9c       	mul	r11, r12
    2238:	f0 0c       	add	r15, r0
    223a:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    223c:	c7 01       	movw	r24, r14
    223e:	01 96       	adiw	r24, 0x01	; 1
    2240:	0e 94 fd 18 	call	0x31fa	; 0x31fa <pvPortMalloc>
    2244:	9c 01       	movw	r18, r24
    2246:	99 83       	std	Y+1, r25	; 0x01
    2248:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    224a:	00 97       	sbiw	r24, 0x00	; 0
    224c:	19 f1       	breq	.+70     	; 0x2294 <__stack+0x95>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    224e:	e8 0e       	add	r14, r24
    2250:	f9 1e       	adc	r15, r25
    2252:	fb 82       	std	Y+3, r15	; 0x03
    2254:	ea 82       	std	Y+2, r14	; 0x02
				pxNewQueue->uxMessagesWaiting = 0;
    2256:	1a 8e       	std	Y+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    2258:	9d 83       	std	Y+5, r25	; 0x05
    225a:	8c 83       	std	Y+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
    225c:	08 94       	sec
    225e:	c1 08       	sbc	r12, r1
    2260:	d1 08       	sbc	r13, r1
    2262:	ca 9c       	mul	r12, r10
    2264:	c0 01       	movw	r24, r0
    2266:	cb 9c       	mul	r12, r11
    2268:	90 0d       	add	r25, r0
    226a:	da 9c       	mul	r13, r10
    226c:	90 0d       	add	r25, r0
    226e:	11 24       	eor	r1, r1
    2270:	28 0f       	add	r18, r24
    2272:	39 1f       	adc	r19, r25
    2274:	3f 83       	std	Y+7, r19	; 0x07
    2276:	2e 83       	std	Y+6, r18	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    2278:	9b 8e       	std	Y+27, r9	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    227a:	8c 8e       	std	Y+28, r8	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    227c:	8f ef       	ldi	r24, 0xFF	; 255
    227e:	8d 8f       	std	Y+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    2280:	8e 8f       	std	Y+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    2282:	c8 01       	movw	r24, r16
    2284:	08 96       	adiw	r24, 0x08	; 8
    2286:	0e 94 de 0d 	call	0x1bbc	; 0x1bbc <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    228a:	c8 01       	movw	r24, r16
    228c:	41 96       	adiw	r24, 0x11	; 17
    228e:	0e 94 de 0d 	call	0x1bbc	; 0x1bbc <vListInitialise>
    2292:	05 c0       	rjmp	.+10     	; 0x229e <__stack+0x9f>
				return  pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    2294:	c8 01       	movw	r24, r16
    2296:	0e 94 ed 18 	call	0x31da	; 0x31da <vPortFree>
    229a:	c0 e0       	ldi	r28, 0x00	; 0
    229c:	d0 e0       	ldi	r29, 0x00	; 0
	}

	/* Will only reach here if we could not allocate enough memory or no memory
	was required. */
	return NULL;
}
    229e:	ce 01       	movw	r24, r28
    22a0:	df 91       	pop	r29
    22a2:	cf 91       	pop	r28
    22a4:	1f 91       	pop	r17
    22a6:	0f 91       	pop	r16
    22a8:	ff 90       	pop	r15
    22aa:	ef 90       	pop	r14
    22ac:	df 90       	pop	r13
    22ae:	cf 90       	pop	r12
    22b0:	bf 90       	pop	r11
    22b2:	af 90       	pop	r10
    22b4:	9f 90       	pop	r9
    22b6:	8f 90       	pop	r8
    22b8:	08 95       	ret

000022ba <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    22ba:	80 91 2c 03 	lds	r24, 0x032C
    22be:	8f 5f       	subi	r24, 0xFF	; 255
    22c0:	80 93 2c 03 	sts	0x032C, r24
}
    22c4:	08 95       	ret

000022c6 <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portENTER_CRITICAL();
    22c6:	0f b6       	in	r0, 0x3f	; 63
    22c8:	f8 94       	cli
    22ca:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    22cc:	20 91 2a 03 	lds	r18, 0x032A
    22d0:	30 91 2b 03 	lds	r19, 0x032B
	}
	portEXIT_CRITICAL();
    22d4:	0f 90       	pop	r0
    22d6:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    22d8:	c9 01       	movw	r24, r18
    22da:	08 95       	ret

000022dc <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
	return xTickCount;
    22dc:	20 91 2a 03 	lds	r18, 0x032A
    22e0:	30 91 2b 03 	lds	r19, 0x032B
}
    22e4:	c9 01       	movw	r24, r18
    22e6:	08 95       	ret

000022e8 <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    22e8:	80 91 2f 03 	lds	r24, 0x032F
}
    22ec:	08 95       	ret

000022ee <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    22ee:	80 91 2c 03 	lds	r24, 0x032C
    22f2:	88 23       	and	r24, r24
    22f4:	51 f0       	breq	.+20     	; 0x230a <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    22f6:	81 e0       	ldi	r24, 0x01	; 1
    22f8:	80 93 28 03 	sts	0x0328, r24
    22fc:	08 95       	ret
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
	{
		--uxTopReadyPriority;
    22fe:	80 91 2d 03 	lds	r24, 0x032D
    2302:	81 50       	subi	r24, 0x01	; 1
    2304:	80 93 2d 03 	sts	0x032D, r24
    2308:	01 c0       	rjmp	.+2      	; 0x230c <vTaskSwitchContext+0x1e>

	taskFIRST_CHECK_FOR_STACK_OVERFLOW();
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    230a:	99 e0       	ldi	r25, 0x09	; 9
    230c:	e0 91 2d 03 	lds	r30, 0x032D
    2310:	e9 9f       	mul	r30, r25
    2312:	f0 01       	movw	r30, r0
    2314:	11 24       	eor	r1, r1
    2316:	ec 5c       	subi	r30, 0xCC	; 204
    2318:	fc 4f       	sbci	r31, 0xFC	; 252
    231a:	80 81       	ld	r24, Z
    231c:	88 23       	and	r24, r24
    231e:	79 f3       	breq	.-34     	; 0x22fe <vTaskSwitchContext+0x10>
		--uxTopReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2320:	90 91 2d 03 	lds	r25, 0x032D
    2324:	89 e0       	ldi	r24, 0x09	; 9
    2326:	98 9f       	mul	r25, r24
    2328:	d0 01       	movw	r26, r0
    232a:	11 24       	eor	r1, r1
    232c:	ac 5c       	subi	r26, 0xCC	; 204
    232e:	bc 4f       	sbci	r27, 0xFC	; 252
    2330:	11 96       	adiw	r26, 0x01	; 1
    2332:	ed 91       	ld	r30, X+
    2334:	fc 91       	ld	r31, X
    2336:	12 97       	sbiw	r26, 0x02	; 2
    2338:	02 80       	ldd	r0, Z+2	; 0x02
    233a:	f3 81       	ldd	r31, Z+3	; 0x03
    233c:	e0 2d       	mov	r30, r0
    233e:	12 96       	adiw	r26, 0x02	; 2
    2340:	fc 93       	st	X, r31
    2342:	ee 93       	st	-X, r30
    2344:	11 97       	sbiw	r26, 0x01	; 1
    2346:	cd 01       	movw	r24, r26
    2348:	03 96       	adiw	r24, 0x03	; 3
    234a:	e8 17       	cp	r30, r24
    234c:	f9 07       	cpc	r31, r25
    234e:	31 f4       	brne	.+12     	; 0x235c <vTaskSwitchContext+0x6e>
    2350:	82 81       	ldd	r24, Z+2	; 0x02
    2352:	93 81       	ldd	r25, Z+3	; 0x03
    2354:	12 96       	adiw	r26, 0x02	; 2
    2356:	9c 93       	st	X, r25
    2358:	8e 93       	st	-X, r24
    235a:	11 97       	sbiw	r26, 0x01	; 1
    235c:	11 96       	adiw	r26, 0x01	; 1
    235e:	ed 91       	ld	r30, X+
    2360:	fc 91       	ld	r31, X
    2362:	12 97       	sbiw	r26, 0x02	; 2
    2364:	86 81       	ldd	r24, Z+6	; 0x06
    2366:	97 81       	ldd	r25, Z+7	; 0x07
    2368:	90 93 27 03 	sts	0x0327, r25
    236c:	80 93 26 03 	sts	0x0326, r24
    2370:	08 95       	ret

00002372 <vTaskSetTimeOutState>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    2372:	fc 01       	movw	r30, r24
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2374:	80 91 29 03 	lds	r24, 0x0329
    2378:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    237a:	80 91 2a 03 	lds	r24, 0x032A
    237e:	90 91 2b 03 	lds	r25, 0x032B
    2382:	92 83       	std	Z+2, r25	; 0x02
    2384:	81 83       	std	Z+1, r24	; 0x01
}
    2386:	08 95       	ret

00002388 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    2388:	fc 01       	movw	r30, r24
    238a:	db 01       	movw	r26, r22
portBASE_TYPE xReturn;

	portENTER_CRITICAL();
    238c:	0f b6       	in	r0, 0x3f	; 63
    238e:	f8 94       	cli
    2390:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    2392:	90 91 29 03 	lds	r25, 0x0329
    2396:	80 81       	ld	r24, Z
    2398:	98 17       	cp	r25, r24
    239a:	49 f0       	breq	.+18     	; 0x23ae <xTaskCheckForTimeOut+0x26>
    239c:	20 91 2a 03 	lds	r18, 0x032A
    23a0:	30 91 2b 03 	lds	r19, 0x032B
    23a4:	81 81       	ldd	r24, Z+1	; 0x01
    23a6:	92 81       	ldd	r25, Z+2	; 0x02
    23a8:	28 17       	cp	r18, r24
    23aa:	39 07       	cpc	r19, r25
    23ac:	18 f5       	brcc	.+70     	; 0x23f4 <xTaskCheckForTimeOut+0x6c>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    23ae:	80 91 2a 03 	lds	r24, 0x032A
    23b2:	90 91 2b 03 	lds	r25, 0x032B
    23b6:	21 81       	ldd	r18, Z+1	; 0x01
    23b8:	32 81       	ldd	r19, Z+2	; 0x02
    23ba:	4d 91       	ld	r20, X+
    23bc:	5c 91       	ld	r21, X
    23be:	11 97       	sbiw	r26, 0x01	; 1
    23c0:	82 1b       	sub	r24, r18
    23c2:	93 0b       	sbc	r25, r19
    23c4:	84 17       	cp	r24, r20
    23c6:	95 07       	cpc	r25, r21
    23c8:	a8 f4       	brcc	.+42     	; 0x23f4 <xTaskCheckForTimeOut+0x6c>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    23ca:	80 91 2a 03 	lds	r24, 0x032A
    23ce:	90 91 2b 03 	lds	r25, 0x032B
    23d2:	28 1b       	sub	r18, r24
    23d4:	39 0b       	sbc	r19, r25
    23d6:	24 0f       	add	r18, r20
    23d8:	35 1f       	adc	r19, r21
    23da:	2d 93       	st	X+, r18
    23dc:	3c 93       	st	X, r19
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    23de:	80 91 29 03 	lds	r24, 0x0329
    23e2:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    23e4:	80 91 2a 03 	lds	r24, 0x032A
    23e8:	90 91 2b 03 	lds	r25, 0x032B
    23ec:	92 83       	std	Z+2, r25	; 0x02
    23ee:	81 83       	std	Z+1, r24	; 0x01
    23f0:	80 e0       	ldi	r24, 0x00	; 0
    23f2:	01 c0       	rjmp	.+2      	; 0x23f6 <xTaskCheckForTimeOut+0x6e>
    23f4:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			xReturn = pdTRUE;
		}
	}
	portEXIT_CRITICAL();
    23f6:	0f 90       	pop	r0
    23f8:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    23fa:	08 95       	ret

000023fc <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    23fc:	81 e0       	ldi	r24, 0x01	; 1
    23fe:	80 93 28 03 	sts	0x0328, r24
}
    2402:	08 95       	ret

00002404 <xTaskRemoveFromEventList>:
	#endif
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2404:	0f 93       	push	r16
    2406:	1f 93       	push	r17
    2408:	cf 93       	push	r28
    240a:	df 93       	push	r29
    240c:	fc 01       	movw	r30, r24
	it to the ready list.

	If an event is for a queue that is locked then this function will never
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    240e:	80 81       	ld	r24, Z
    2410:	88 23       	and	r24, r24
    2412:	19 f4       	brne	.+6      	; 0x241a <xTaskRemoveFromEventList+0x16>
    2414:	c0 e0       	ldi	r28, 0x00	; 0
    2416:	d0 e0       	ldi	r29, 0x00	; 0
    2418:	05 c0       	rjmp	.+10     	; 0x2424 <xTaskRemoveFromEventList+0x20>
    241a:	05 80       	ldd	r0, Z+5	; 0x05
    241c:	f6 81       	ldd	r31, Z+6	; 0x06
    241e:	e0 2d       	mov	r30, r0
    2420:	c6 81       	ldd	r28, Z+6	; 0x06
    2422:	d7 81       	ldd	r29, Z+7	; 0x07
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2424:	8e 01       	movw	r16, r28
    2426:	04 5f       	subi	r16, 0xF4	; 244
    2428:	1f 4f       	sbci	r17, 0xFF	; 255
    242a:	c8 01       	movw	r24, r16
    242c:	0e 94 50 0e 	call	0x1ca0	; 0x1ca0 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2430:	80 91 2c 03 	lds	r24, 0x032C
    2434:	88 23       	and	r24, r24
    2436:	a1 f4       	brne	.+40     	; 0x2460 <xTaskRemoveFromEventList+0x5c>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2438:	8e 01       	movw	r16, r28
    243a:	0e 5f       	subi	r16, 0xFE	; 254
    243c:	1f 4f       	sbci	r17, 0xFF	; 255
    243e:	c8 01       	movw	r24, r16
    2440:	0e 94 50 0e 	call	0x1ca0	; 0x1ca0 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2444:	9e 89       	ldd	r25, Y+22	; 0x16
    2446:	80 91 2d 03 	lds	r24, 0x032D
    244a:	89 17       	cp	r24, r25
    244c:	10 f4       	brcc	.+4      	; 0x2452 <xTaskRemoveFromEventList+0x4e>
    244e:	90 93 2d 03 	sts	0x032D, r25
    2452:	89 e0       	ldi	r24, 0x09	; 9
    2454:	98 9f       	mul	r25, r24
    2456:	c0 01       	movw	r24, r0
    2458:	11 24       	eor	r1, r1
    245a:	8c 5c       	subi	r24, 0xCC	; 204
    245c:	9c 4f       	sbci	r25, 0xFC	; 252
    245e:	02 c0       	rjmp	.+4      	; 0x2464 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2460:	8e e6       	ldi	r24, 0x6E	; 110
    2462:	93 e0       	ldi	r25, 0x03	; 3
    2464:	b8 01       	movw	r22, r16
    2466:	0e 94 f2 0d 	call	0x1be4	; 0x1be4 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    246a:	e0 91 26 03 	lds	r30, 0x0326
    246e:	f0 91 27 03 	lds	r31, 0x0327
    2472:	20 e0       	ldi	r18, 0x00	; 0
    2474:	9e 89       	ldd	r25, Y+22	; 0x16
    2476:	86 89       	ldd	r24, Z+22	; 0x16
    2478:	98 17       	cp	r25, r24
    247a:	08 f0       	brcs	.+2      	; 0x247e <xTaskRemoveFromEventList+0x7a>
    247c:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    247e:	82 2f       	mov	r24, r18
    2480:	df 91       	pop	r29
    2482:	cf 91       	pop	r28
    2484:	1f 91       	pop	r17
    2486:	0f 91       	pop	r16
    2488:	08 95       	ret

0000248a <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
    248a:	ff 92       	push	r15
    248c:	0f 93       	push	r16
    248e:	1f 93       	push	r17
    2490:	cf 93       	push	r28
    2492:	df 93       	push	r29
	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2494:	80 91 2c 03 	lds	r24, 0x032C
    2498:	88 23       	and	r24, r24
    249a:	09 f0       	breq	.+2      	; 0x249e <vTaskIncrementTick+0x14>
    249c:	61 c0       	rjmp	.+194    	; 0x2560 <vTaskIncrementTick+0xd6>
	{
		++xTickCount;
    249e:	80 91 2a 03 	lds	r24, 0x032A
    24a2:	90 91 2b 03 	lds	r25, 0x032B
    24a6:	01 96       	adiw	r24, 0x01	; 1
    24a8:	90 93 2b 03 	sts	0x032B, r25
    24ac:	80 93 2a 03 	sts	0x032A, r24
		if( xTickCount == ( portTickType ) 0 )
    24b0:	80 91 2a 03 	lds	r24, 0x032A
    24b4:	90 91 2b 03 	lds	r25, 0x032B
    24b8:	89 2b       	or	r24, r25
    24ba:	e9 f5       	brne	.+122    	; 0x2536 <vTaskIncrementTick+0xac>
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			pxTemp = pxDelayedTaskList;
    24bc:	80 91 6a 03 	lds	r24, 0x036A
    24c0:	90 91 6b 03 	lds	r25, 0x036B
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    24c4:	20 91 6c 03 	lds	r18, 0x036C
    24c8:	30 91 6d 03 	lds	r19, 0x036D
    24cc:	30 93 6b 03 	sts	0x036B, r19
    24d0:	20 93 6a 03 	sts	0x036A, r18
			pxOverflowDelayedTaskList = pxTemp;
    24d4:	90 93 6d 03 	sts	0x036D, r25
    24d8:	80 93 6c 03 	sts	0x036C, r24
			xNumOfOverflows++;
    24dc:	80 91 29 03 	lds	r24, 0x0329
    24e0:	8f 5f       	subi	r24, 0xFF	; 255
    24e2:	80 93 29 03 	sts	0x0329, r24
    24e6:	27 c0       	rjmp	.+78     	; 0x2536 <vTaskIncrementTick+0xac>
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    24e8:	20 91 2a 03 	lds	r18, 0x032A
    24ec:	30 91 2b 03 	lds	r19, 0x032B
    24f0:	8a 81       	ldd	r24, Y+2	; 0x02
    24f2:	9b 81       	ldd	r25, Y+3	; 0x03
    24f4:	28 17       	cp	r18, r24
    24f6:	39 07       	cpc	r19, r25
    24f8:	c0 f1       	brcs	.+112    	; 0x256a <vTaskIncrementTick+0xe0>
    24fa:	8e 01       	movw	r16, r28
    24fc:	0e 5f       	subi	r16, 0xFE	; 254
    24fe:	1f 4f       	sbci	r17, 0xFF	; 255
    2500:	c8 01       	movw	r24, r16
    2502:	0e 94 50 0e 	call	0x1ca0	; 0x1ca0 <vListRemove>
    2506:	8c 89       	ldd	r24, Y+20	; 0x14
    2508:	9d 89       	ldd	r25, Y+21	; 0x15
    250a:	89 2b       	or	r24, r25
    250c:	21 f0       	breq	.+8      	; 0x2516 <vTaskIncrementTick+0x8c>
    250e:	ce 01       	movw	r24, r28
    2510:	0c 96       	adiw	r24, 0x0c	; 12
    2512:	0e 94 50 0e 	call	0x1ca0	; 0x1ca0 <vListRemove>
    2516:	9e 89       	ldd	r25, Y+22	; 0x16
    2518:	80 91 2d 03 	lds	r24, 0x032D
    251c:	89 17       	cp	r24, r25
    251e:	10 f4       	brcc	.+4      	; 0x2524 <vTaskIncrementTick+0x9a>
    2520:	90 93 2d 03 	sts	0x032D, r25
    2524:	9f 9d       	mul	r25, r15
    2526:	c0 01       	movw	r24, r0
    2528:	11 24       	eor	r1, r1
    252a:	8c 5c       	subi	r24, 0xCC	; 204
    252c:	9c 4f       	sbci	r25, 0xFC	; 252
    252e:	b8 01       	movw	r22, r16
    2530:	0e 94 f2 0d 	call	0x1be4	; 0x1be4 <vListInsertEnd>
    2534:	02 c0       	rjmp	.+4      	; 0x253a <vTaskIncrementTick+0xb0>
    2536:	89 e0       	ldi	r24, 0x09	; 9
    2538:	f8 2e       	mov	r15, r24
    253a:	e0 91 6a 03 	lds	r30, 0x036A
    253e:	f0 91 6b 03 	lds	r31, 0x036B
    2542:	80 81       	ld	r24, Z
    2544:	88 23       	and	r24, r24
    2546:	89 f0       	breq	.+34     	; 0x256a <vTaskIncrementTick+0xe0>
    2548:	e0 91 6a 03 	lds	r30, 0x036A
    254c:	f0 91 6b 03 	lds	r31, 0x036B
    2550:	05 80       	ldd	r0, Z+5	; 0x05
    2552:	f6 81       	ldd	r31, Z+6	; 0x06
    2554:	e0 2d       	mov	r30, r0
    2556:	c6 81       	ldd	r28, Z+6	; 0x06
    2558:	d7 81       	ldd	r29, Z+7	; 0x07
    255a:	20 97       	sbiw	r28, 0x00	; 0
    255c:	29 f6       	brne	.-118    	; 0x24e8 <vTaskIncrementTick+0x5e>
    255e:	05 c0       	rjmp	.+10     	; 0x256a <vTaskIncrementTick+0xe0>
	}
	else
	{
		++uxMissedTicks;
    2560:	80 91 2e 03 	lds	r24, 0x032E
    2564:	8f 5f       	subi	r24, 0xFF	; 255
    2566:	80 93 2e 03 	sts	0x032E, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    256a:	df 91       	pop	r29
    256c:	cf 91       	pop	r28
    256e:	1f 91       	pop	r17
    2570:	0f 91       	pop	r16
    2572:	ff 90       	pop	r15
    2574:	08 95       	ret

00002576 <vTaskPlaceOnEventList>:
	vWriteTraceToBuffer();
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2576:	0f 93       	push	r16
    2578:	1f 93       	push	r17
    257a:	8b 01       	movw	r16, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    257c:	60 91 26 03 	lds	r22, 0x0326
    2580:	70 91 27 03 	lds	r23, 0x0327
    2584:	64 5f       	subi	r22, 0xF4	; 244
    2586:	7f 4f       	sbci	r23, 0xFF	; 255
    2588:	0e 94 1b 0e 	call	0x1c36	; 0x1c36 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    258c:	80 91 26 03 	lds	r24, 0x0326
    2590:	90 91 27 03 	lds	r25, 0x0327
    2594:	02 96       	adiw	r24, 0x02	; 2
    2596:	0e 94 50 0e 	call	0x1ca0	; 0x1ca0 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    259a:	80 91 2a 03 	lds	r24, 0x032A
    259e:	90 91 2b 03 	lds	r25, 0x032B
    25a2:	80 0f       	add	r24, r16
    25a4:	91 1f       	adc	r25, r17

			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    25a6:	e0 91 26 03 	lds	r30, 0x0326
    25aa:	f0 91 27 03 	lds	r31, 0x0327
    25ae:	93 83       	std	Z+3, r25	; 0x03
    25b0:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xTickCount )
    25b2:	20 91 2a 03 	lds	r18, 0x032A
    25b6:	30 91 2b 03 	lds	r19, 0x032B
    25ba:	82 17       	cp	r24, r18
    25bc:	93 07       	cpc	r25, r19
    25be:	28 f4       	brcc	.+10     	; 0x25ca <vTaskPlaceOnEventList+0x54>
			{
				/* Wake time has overflowed.  Place this item in the overflow list. */
				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    25c0:	80 91 6c 03 	lds	r24, 0x036C
    25c4:	90 91 6d 03 	lds	r25, 0x036D
    25c8:	04 c0       	rjmp	.+8      	; 0x25d2 <vTaskPlaceOnEventList+0x5c>
			}
			else
			{
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    25ca:	80 91 6a 03 	lds	r24, 0x036A
    25ce:	90 91 6b 03 	lds	r25, 0x036B
    25d2:	60 91 26 03 	lds	r22, 0x0326
    25d6:	70 91 27 03 	lds	r23, 0x0327
    25da:	6e 5f       	subi	r22, 0xFE	; 254
    25dc:	7f 4f       	sbci	r23, 0xFF	; 255
    25de:	0e 94 1b 0e 	call	0x1c36	; 0x1c36 <vListInsert>
			}
	}
	#endif
}
    25e2:	1f 91       	pop	r17
    25e4:	0f 91       	pop	r16
    25e6:	08 95       	ret

000025e8 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    25e8:	cf 92       	push	r12
    25ea:	df 92       	push	r13
    25ec:	ff 92       	push	r15
    25ee:	0f 93       	push	r16
    25f0:	1f 93       	push	r17
    25f2:	df 93       	push	r29
    25f4:	cf 93       	push	r28
    25f6:	0f 92       	push	r0
    25f8:	cd b7       	in	r28, 0x3d	; 61
    25fa:	de b7       	in	r29, 0x3e	; 62
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	portENTER_CRITICAL();
    25fc:	0f b6       	in	r0, 0x3f	; 63
    25fe:	f8 94       	cli
    2600:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2602:	80 91 2c 03 	lds	r24, 0x032C
    2606:	81 50       	subi	r24, 0x01	; 1
    2608:	80 93 2c 03 	sts	0x032C, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    260c:	80 91 2c 03 	lds	r24, 0x032C
    2610:	88 23       	and	r24, r24
    2612:	09 f0       	breq	.+2      	; 0x2616 <xTaskResumeAll+0x2e>
    2614:	5b c0       	rjmp	.+182    	; 0x26cc <xTaskResumeAll+0xe4>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
    2616:	80 91 2f 03 	lds	r24, 0x032F
    261a:	88 23       	and	r24, r24
    261c:	09 f4       	brne	.+2      	; 0x2620 <xTaskResumeAll+0x38>
    261e:	56 c0       	rjmp	.+172    	; 0x26cc <xTaskResumeAll+0xe4>
    2620:	19 82       	std	Y+1, r1	; 0x01
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    2622:	99 e0       	ldi	r25, 0x09	; 9
    2624:	f9 2e       	mov	r15, r25
    2626:	27 c0       	rjmp	.+78     	; 0x2676 <xTaskResumeAll+0x8e>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
    2628:	c6 01       	movw	r24, r12
    262a:	0c 96       	adiw	r24, 0x0c	; 12
    262c:	0e 94 50 0e 	call	0x1ca0	; 0x1ca0 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    2630:	86 01       	movw	r16, r12
    2632:	0e 5f       	subi	r16, 0xFE	; 254
    2634:	1f 4f       	sbci	r17, 0xFF	; 255
    2636:	c8 01       	movw	r24, r16
    2638:	0e 94 50 0e 	call	0x1ca0	; 0x1ca0 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    263c:	d6 01       	movw	r26, r12
    263e:	56 96       	adiw	r26, 0x16	; 22
    2640:	9c 91       	ld	r25, X
    2642:	80 91 2d 03 	lds	r24, 0x032D
    2646:	89 17       	cp	r24, r25
    2648:	10 f4       	brcc	.+4      	; 0x264e <xTaskResumeAll+0x66>
    264a:	90 93 2d 03 	sts	0x032D, r25
    264e:	9f 9d       	mul	r25, r15
    2650:	c0 01       	movw	r24, r0
    2652:	11 24       	eor	r1, r1
    2654:	8c 5c       	subi	r24, 0xCC	; 204
    2656:	9c 4f       	sbci	r25, 0xFC	; 252
    2658:	b8 01       	movw	r22, r16
    265a:	0e 94 f2 0d 	call	0x1be4	; 0x1be4 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    265e:	e0 91 26 03 	lds	r30, 0x0326
    2662:	f0 91 27 03 	lds	r31, 0x0327
    2666:	d6 01       	movw	r26, r12
    2668:	56 96       	adiw	r26, 0x16	; 22
    266a:	9c 91       	ld	r25, X
    266c:	86 89       	ldd	r24, Z+22	; 0x16
    266e:	98 17       	cp	r25, r24
    2670:	10 f0       	brcs	.+4      	; 0x2676 <xTaskResumeAll+0x8e>
    2672:	b1 e0       	ldi	r27, 0x01	; 1
    2674:	b9 83       	std	Y+1, r27	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
    2676:	80 91 6e 03 	lds	r24, 0x036E
    267a:	88 23       	and	r24, r24
    267c:	49 f0       	breq	.+18     	; 0x2690 <xTaskResumeAll+0xa8>
    267e:	e0 91 73 03 	lds	r30, 0x0373
    2682:	f0 91 74 03 	lds	r31, 0x0374
    2686:	c6 80       	ldd	r12, Z+6	; 0x06
    2688:	d7 80       	ldd	r13, Z+7	; 0x07
    268a:	c1 14       	cp	r12, r1
    268c:	d1 04       	cpc	r13, r1
    268e:	61 f6       	brne	.-104    	; 0x2628 <xTaskResumeAll+0x40>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    2690:	80 91 2e 03 	lds	r24, 0x032E
    2694:	88 23       	and	r24, r24
    2696:	41 f4       	brne	.+16     	; 0x26a8 <xTaskResumeAll+0xc0>
    2698:	0c c0       	rjmp	.+24     	; 0x26b2 <xTaskResumeAll+0xca>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
    269a:	0e 94 45 12 	call	0x248a	; 0x248a <vTaskIncrementTick>
						--uxMissedTicks;
    269e:	80 91 2e 03 	lds	r24, 0x032E
    26a2:	81 50       	subi	r24, 0x01	; 1
    26a4:	80 93 2e 03 	sts	0x032E, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    26a8:	80 91 2e 03 	lds	r24, 0x032E
    26ac:	88 23       	and	r24, r24
    26ae:	a9 f7       	brne	.-22     	; 0x269a <xTaskResumeAll+0xb2>
    26b0:	07 c0       	rjmp	.+14     	; 0x26c0 <xTaskResumeAll+0xd8>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    26b2:	e9 81       	ldd	r30, Y+1	; 0x01
    26b4:	e1 30       	cpi	r30, 0x01	; 1
    26b6:	21 f0       	breq	.+8      	; 0x26c0 <xTaskResumeAll+0xd8>
    26b8:	80 91 28 03 	lds	r24, 0x0328
    26bc:	81 30       	cpi	r24, 0x01	; 1
    26be:	31 f4       	brne	.+12     	; 0x26cc <xTaskResumeAll+0xe4>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    26c0:	10 92 28 03 	sts	0x0328, r1
					portYIELD_WITHIN_API();
    26c4:	0e 94 ca 16 	call	0x2d94	; 0x2d94 <vPortYield>
    26c8:	81 e0       	ldi	r24, 0x01	; 1
    26ca:	01 c0       	rjmp	.+2      	; 0x26ce <xTaskResumeAll+0xe6>
    26cc:	80 e0       	ldi	r24, 0x00	; 0
				}
			}
		}
	}
	portEXIT_CRITICAL();
    26ce:	0f 90       	pop	r0
    26d0:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    26d2:	0f 90       	pop	r0
    26d4:	cf 91       	pop	r28
    26d6:	df 91       	pop	r29
    26d8:	1f 91       	pop	r17
    26da:	0f 91       	pop	r16
    26dc:	ff 90       	pop	r15
    26de:	df 90       	pop	r13
    26e0:	cf 90       	pop	r12
    26e2:	08 95       	ret

000026e4 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    26e4:	0f 93       	push	r16
    26e6:	1f 93       	push	r17
    26e8:	9c 01       	movw	r18, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
    26ea:	00 97       	sbiw	r24, 0x00	; 0
    26ec:	a1 f1       	breq	.+104    	; 0x2756 <vTaskDelay+0x72>

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    26ee:	80 91 2c 03 	lds	r24, 0x032C
    26f2:	8f 5f       	subi	r24, 0xFF	; 255
    26f4:	80 93 2c 03 	sts	0x032C, r24
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    26f8:	00 91 2a 03 	lds	r16, 0x032A
    26fc:	10 91 2b 03 	lds	r17, 0x032B
    2700:	02 0f       	add	r16, r18
    2702:	13 1f       	adc	r17, r19

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2704:	80 91 26 03 	lds	r24, 0x0326
    2708:	90 91 27 03 	lds	r25, 0x0327
    270c:	02 96       	adiw	r24, 0x02	; 2
    270e:	0e 94 50 0e 	call	0x1ca0	; 0x1ca0 <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    2712:	e0 91 26 03 	lds	r30, 0x0326
    2716:	f0 91 27 03 	lds	r31, 0x0327
    271a:	13 83       	std	Z+3, r17	; 0x03
    271c:	02 83       	std	Z+2, r16	; 0x02

				if( xTimeToWake < xTickCount )
    271e:	80 91 2a 03 	lds	r24, 0x032A
    2722:	90 91 2b 03 	lds	r25, 0x032B
    2726:	08 17       	cp	r16, r24
    2728:	19 07       	cpc	r17, r25
    272a:	28 f4       	brcc	.+10     	; 0x2736 <vTaskDelay+0x52>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    272c:	80 91 6c 03 	lds	r24, 0x036C
    2730:	90 91 6d 03 	lds	r25, 0x036D
    2734:	04 c0       	rjmp	.+8      	; 0x273e <vTaskDelay+0x5a>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2736:	80 91 6a 03 	lds	r24, 0x036A
    273a:	90 91 6b 03 	lds	r25, 0x036B
    273e:	60 91 26 03 	lds	r22, 0x0326
    2742:	70 91 27 03 	lds	r23, 0x0327
    2746:	6e 5f       	subi	r22, 0xFE	; 254
    2748:	7f 4f       	sbci	r23, 0xFF	; 255
    274a:	0e 94 1b 0e 	call	0x1c36	; 0x1c36 <vListInsert>
				}
			}
			xAlreadyYielded = xTaskResumeAll();
    274e:	0e 94 f4 12 	call	0x25e8	; 0x25e8 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
    2752:	88 23       	and	r24, r24
    2754:	11 f4       	brne	.+4      	; 0x275a <vTaskDelay+0x76>
		{
			portYIELD_WITHIN_API();
    2756:	0e 94 ca 16 	call	0x2d94	; 0x2d94 <vPortYield>
		}
	}
    275a:	1f 91       	pop	r17
    275c:	0f 91       	pop	r16
    275e:	08 95       	ret

00002760 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    2760:	cf 93       	push	r28
    2762:	df 93       	push	r29
    2764:	fc 01       	movw	r30, r24
    2766:	eb 01       	movw	r28, r22

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    2768:	80 91 2c 03 	lds	r24, 0x032C
    276c:	8f 5f       	subi	r24, 0xFF	; 255
    276e:	80 93 2c 03 	sts	0x032C, r24
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		vTaskSuspendAll();
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2772:	20 81       	ld	r18, Z
    2774:	31 81       	ldd	r19, Z+1	; 0x01
    2776:	c2 0f       	add	r28, r18
    2778:	d3 1f       	adc	r29, r19

			if( xTickCount < *pxPreviousWakeTime )
    277a:	80 91 2a 03 	lds	r24, 0x032A
    277e:	90 91 2b 03 	lds	r25, 0x032B
    2782:	82 17       	cp	r24, r18
    2784:	93 07       	cpc	r25, r19
    2786:	28 f4       	brcc	.+10     	; 0x2792 <vTaskDelayUntil+0x32>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    2788:	c2 17       	cp	r28, r18
    278a:	d3 07       	cpc	r29, r19
    278c:	28 f0       	brcs	.+10     	; 0x2798 <vTaskDelayUntil+0x38>
    278e:	20 e0       	ldi	r18, 0x00	; 0
    2790:	0c c0       	rjmp	.+24     	; 0x27aa <vTaskDelayUntil+0x4a>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    2792:	c2 17       	cp	r28, r18
    2794:	d3 07       	cpc	r29, r19
    2796:	40 f0       	brcs	.+16     	; 0x27a8 <vTaskDelayUntil+0x48>
    2798:	80 91 2a 03 	lds	r24, 0x032A
    279c:	90 91 2b 03 	lds	r25, 0x032B
    27a0:	20 e0       	ldi	r18, 0x00	; 0
    27a2:	8c 17       	cp	r24, r28
    27a4:	9d 07       	cpc	r25, r29
    27a6:	08 f4       	brcc	.+2      	; 0x27aa <vTaskDelayUntil+0x4a>
    27a8:	21 e0       	ldi	r18, 0x01	; 1
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    27aa:	d1 83       	std	Z+1, r29	; 0x01
    27ac:	c0 83       	st	Z, r28

			if( xShouldDelay )
    27ae:	22 23       	and	r18, r18
    27b0:	29 f1       	breq	.+74     	; 0x27fc <vTaskDelayUntil+0x9c>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    27b2:	80 91 26 03 	lds	r24, 0x0326
    27b6:	90 91 27 03 	lds	r25, 0x0327
    27ba:	02 96       	adiw	r24, 0x02	; 2
    27bc:	0e 94 50 0e 	call	0x1ca0	; 0x1ca0 <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    27c0:	e0 91 26 03 	lds	r30, 0x0326
    27c4:	f0 91 27 03 	lds	r31, 0x0327
    27c8:	d3 83       	std	Z+3, r29	; 0x03
    27ca:	c2 83       	std	Z+2, r28	; 0x02

				if( xTimeToWake < xTickCount )
    27cc:	80 91 2a 03 	lds	r24, 0x032A
    27d0:	90 91 2b 03 	lds	r25, 0x032B
    27d4:	c8 17       	cp	r28, r24
    27d6:	d9 07       	cpc	r29, r25
    27d8:	28 f4       	brcc	.+10     	; 0x27e4 <vTaskDelayUntil+0x84>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    27da:	80 91 6c 03 	lds	r24, 0x036C
    27de:	90 91 6d 03 	lds	r25, 0x036D
    27e2:	04 c0       	rjmp	.+8      	; 0x27ec <vTaskDelayUntil+0x8c>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    27e4:	80 91 6a 03 	lds	r24, 0x036A
    27e8:	90 91 6b 03 	lds	r25, 0x036B
    27ec:	60 91 26 03 	lds	r22, 0x0326
    27f0:	70 91 27 03 	lds	r23, 0x0327
    27f4:	6e 5f       	subi	r22, 0xFE	; 254
    27f6:	7f 4f       	sbci	r23, 0xFF	; 255
    27f8:	0e 94 1b 0e 	call	0x1c36	; 0x1c36 <vListInsert>
				}
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    27fc:	0e 94 f4 12 	call	0x25e8	; 0x25e8 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
    2800:	88 23       	and	r24, r24
    2802:	11 f4       	brne	.+4      	; 0x2808 <vTaskDelayUntil+0xa8>
		{
			portYIELD_WITHIN_API();
    2804:	0e 94 ca 16 	call	0x2d94	; 0x2d94 <vPortYield>
		}
	}
    2808:	df 91       	pop	r29
    280a:	cf 91       	pop	r28
    280c:	08 95       	ret

0000280e <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    280e:	ef 92       	push	r14
    2810:	ff 92       	push	r15
    2812:	0f 93       	push	r16
    2814:	1f 93       	push	r17
    2816:	cf 93       	push	r28
    2818:	df 93       	push	r29
    281a:	8c 01       	movw	r16, r24
	tskTCB *pxTCB;

		portENTER_CRITICAL();
    281c:	0f b6       	in	r0, 0x3f	; 63
    281e:	f8 94       	cli
    2820:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    2822:	80 91 26 03 	lds	r24, 0x0326
    2826:	90 91 27 03 	lds	r25, 0x0327
    282a:	08 17       	cp	r16, r24
    282c:	19 07       	cpc	r17, r25
    282e:	19 f4       	brne	.+6      	; 0x2836 <vTaskDelete+0x28>
    2830:	00 e0       	ldi	r16, 0x00	; 0
    2832:	10 e0       	ldi	r17, 0x00	; 0
    2834:	03 c0       	rjmp	.+6      	; 0x283c <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    2836:	01 15       	cp	r16, r1
    2838:	11 05       	cpc	r17, r1
    283a:	29 f4       	brne	.+10     	; 0x2846 <vTaskDelete+0x38>
    283c:	c0 91 26 03 	lds	r28, 0x0326
    2840:	d0 91 27 03 	lds	r29, 0x0327
    2844:	01 c0       	rjmp	.+2      	; 0x2848 <vTaskDelete+0x3a>
    2846:	e8 01       	movw	r28, r16

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    2848:	22 e0       	ldi	r18, 0x02	; 2
    284a:	e2 2e       	mov	r14, r18
    284c:	f1 2c       	mov	r15, r1
    284e:	ec 0e       	add	r14, r28
    2850:	fd 1e       	adc	r15, r29
    2852:	c7 01       	movw	r24, r14
    2854:	0e 94 50 0e 	call	0x1ca0	; 0x1ca0 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer )
    2858:	8c 89       	ldd	r24, Y+20	; 0x14
    285a:	9d 89       	ldd	r25, Y+21	; 0x15
    285c:	89 2b       	or	r24, r25
    285e:	21 f0       	breq	.+8      	; 0x2868 <vTaskDelete+0x5a>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    2860:	ce 01       	movw	r24, r28
    2862:	0c 96       	adiw	r24, 0x0c	; 12
    2864:	0e 94 50 0e 	call	0x1ca0	; 0x1ca0 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    2868:	87 e7       	ldi	r24, 0x77	; 119
    286a:	93 e0       	ldi	r25, 0x03	; 3
    286c:	b7 01       	movw	r22, r14
    286e:	0e 94 f2 0d 	call	0x1be4	; 0x1be4 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    2872:	80 91 31 03 	lds	r24, 0x0331
    2876:	8f 5f       	subi	r24, 0xFF	; 255
    2878:	80 93 31 03 	sts	0x0331, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    287c:	80 91 32 03 	lds	r24, 0x0332
    2880:	8f 5f       	subi	r24, 0xFF	; 255
    2882:	80 93 32 03 	sts	0x0332, r24

			traceTASK_DELETE( pxTCB );
		}
		portEXIT_CRITICAL();
    2886:	0f 90       	pop	r0
    2888:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    288a:	80 91 30 03 	lds	r24, 0x0330
    288e:	88 23       	and	r24, r24
    2890:	21 f0       	breq	.+8      	; 0x289a <vTaskDelete+0x8c>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    2892:	01 2b       	or	r16, r17
    2894:	11 f4       	brne	.+4      	; 0x289a <vTaskDelete+0x8c>
			{
				portYIELD_WITHIN_API();
    2896:	0e 94 ca 16 	call	0x2d94	; 0x2d94 <vPortYield>
			}
		}
	}
    289a:	df 91       	pop	r29
    289c:	cf 91       	pop	r28
    289e:	1f 91       	pop	r17
    28a0:	0f 91       	pop	r16
    28a2:	ff 90       	pop	r15
    28a4:	ef 90       	pop	r14
    28a6:	08 95       	ret

000028a8 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    28a8:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    28aa:	10 92 30 03 	sts	0x0330, r1
	vPortEndScheduler();
    28ae:	0e 94 6b 16 	call	0x2cd6	; 0x2cd6 <vPortEndScheduler>
}
    28b2:	08 95       	ret

000028b4 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    28b4:	1f 93       	push	r17
    28b6:	cf 93       	push	r28
    28b8:	df 93       	push	r29
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
    28ba:	80 91 31 03 	lds	r24, 0x0331
    28be:	88 23       	and	r24, r24
    28c0:	91 f1       	breq	.+100    	; 0x2926 <prvIdleTask+0x72>

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    28c2:	80 91 2c 03 	lds	r24, 0x032C
    28c6:	8f 5f       	subi	r24, 0xFF	; 255
    28c8:	80 93 2c 03 	sts	0x032C, r24
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    28cc:	10 91 77 03 	lds	r17, 0x0377
			xTaskResumeAll();
    28d0:	0e 94 f4 12 	call	0x25e8	; 0x25e8 <xTaskResumeAll>

			if( !xListIsEmpty )
    28d4:	11 23       	and	r17, r17
    28d6:	39 f1       	breq	.+78     	; 0x2926 <prvIdleTask+0x72>
			{
				tskTCB *pxTCB;

				portENTER_CRITICAL();
    28d8:	0f b6       	in	r0, 0x3f	; 63
    28da:	f8 94       	cli
    28dc:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    28de:	80 91 77 03 	lds	r24, 0x0377
    28e2:	88 23       	and	r24, r24
    28e4:	19 f4       	brne	.+6      	; 0x28ec <prvIdleTask+0x38>
    28e6:	c0 e0       	ldi	r28, 0x00	; 0
    28e8:	d0 e0       	ldi	r29, 0x00	; 0
    28ea:	06 c0       	rjmp	.+12     	; 0x28f8 <prvIdleTask+0x44>
    28ec:	e0 91 7c 03 	lds	r30, 0x037C
    28f0:	f0 91 7d 03 	lds	r31, 0x037D
    28f4:	c6 81       	ldd	r28, Z+6	; 0x06
    28f6:	d7 81       	ldd	r29, Z+7	; 0x07
					vListRemove( &( pxTCB->xGenericListItem ) );
    28f8:	ce 01       	movw	r24, r28
    28fa:	02 96       	adiw	r24, 0x02	; 2
    28fc:	0e 94 50 0e 	call	0x1ca0	; 0x1ca0 <vListRemove>
					--uxCurrentNumberOfTasks;
    2900:	80 91 2f 03 	lds	r24, 0x032F
    2904:	81 50       	subi	r24, 0x01	; 1
    2906:	80 93 2f 03 	sts	0x032F, r24
					--uxTasksDeleted;
    290a:	80 91 31 03 	lds	r24, 0x0331
    290e:	81 50       	subi	r24, 0x01	; 1
    2910:	80 93 31 03 	sts	0x0331, r24
				}
				portEXIT_CRITICAL();
    2914:	0f 90       	pop	r0
    2916:	0f be       	out	0x3f, r0	; 63

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    2918:	8f 89       	ldd	r24, Y+23	; 0x17
    291a:	98 8d       	ldd	r25, Y+24	; 0x18
    291c:	0e 94 ed 18 	call	0x31da	; 0x31da <vPortFree>
		vPortFree( pxTCB );
    2920:	ce 01       	movw	r24, r28
    2922:	0e 94 ed 18 	call	0x31da	; 0x31da <vPortFree>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    2926:	80 91 34 03 	lds	r24, 0x0334
    292a:	82 30       	cpi	r24, 0x02	; 2
    292c:	30 f2       	brcs	.-116    	; 0x28ba <prvIdleTask+0x6>
			{
				taskYIELD();
    292e:	0e 94 ca 16 	call	0x2d94	; 0x2d94 <vPortYield>
    2932:	c3 cf       	rjmp	.-122    	; 0x28ba <prvIdleTask+0x6>

00002934 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    2934:	2f 92       	push	r2
    2936:	3f 92       	push	r3
    2938:	5f 92       	push	r5
    293a:	6f 92       	push	r6
    293c:	7f 92       	push	r7
    293e:	8f 92       	push	r8
    2940:	9f 92       	push	r9
    2942:	af 92       	push	r10
    2944:	bf 92       	push	r11
    2946:	cf 92       	push	r12
    2948:	df 92       	push	r13
    294a:	ef 92       	push	r14
    294c:	ff 92       	push	r15
    294e:	0f 93       	push	r16
    2950:	1f 93       	push	r17
    2952:	df 93       	push	r29
    2954:	cf 93       	push	r28
    2956:	00 d0       	rcall	.+0      	; 0x2958 <xTaskGenericCreate+0x24>
    2958:	00 d0       	rcall	.+0      	; 0x295a <xTaskGenericCreate+0x26>
    295a:	cd b7       	in	r28, 0x3d	; 61
    295c:	de b7       	in	r29, 0x3e	; 62
    295e:	9a 83       	std	Y+2, r25	; 0x02
    2960:	89 83       	std	Y+1, r24	; 0x01
    2962:	4b 01       	movw	r8, r22
    2964:	5a 01       	movw	r10, r20
    2966:	19 01       	movw	r2, r18
    2968:	50 2e       	mov	r5, r16
    296a:	37 01       	movw	r6, r14
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    296c:	81 e2       	ldi	r24, 0x21	; 33
    296e:	90 e0       	ldi	r25, 0x00	; 0
    2970:	0e 94 fd 18 	call	0x31fa	; 0x31fa <pvPortMalloc>
    2974:	8b 83       	std	Y+3, r24	; 0x03
    2976:	9c 83       	std	Y+4, r25	; 0x04

	if( pxNewTCB != NULL )
    2978:	8b 81       	ldd	r24, Y+3	; 0x03
    297a:	9c 81       	ldd	r25, Y+4	; 0x04
    297c:	89 2b       	or	r24, r25
    297e:	89 f0       	breq	.+34     	; 0x29a2 <xTaskGenericCreate+0x6e>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    2980:	c1 14       	cp	r12, r1
    2982:	d1 04       	cpc	r13, r1
    2984:	21 f4       	brne	.+8      	; 0x298e <xTaskGenericCreate+0x5a>
    2986:	c5 01       	movw	r24, r10
    2988:	0e 94 fd 18 	call	0x31fa	; 0x31fa <pvPortMalloc>
    298c:	6c 01       	movw	r12, r24
    298e:	eb 81       	ldd	r30, Y+3	; 0x03
    2990:	fc 81       	ldd	r31, Y+4	; 0x04
    2992:	d0 8e       	std	Z+24, r13	; 0x18
    2994:	c7 8a       	std	Z+23, r12	; 0x17

		if( pxNewTCB->pxStack == NULL )
    2996:	c1 14       	cp	r12, r1
    2998:	d1 04       	cpc	r13, r1
    299a:	29 f4       	brne	.+10     	; 0x29a6 <xTaskGenericCreate+0x72>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    299c:	cf 01       	movw	r24, r30
    299e:	0e 94 ed 18 	call	0x31da	; 0x31da <vPortFree>
    29a2:	8f ef       	ldi	r24, 0xFF	; 255
    29a4:	d5 c0       	rjmp	.+426    	; 0x2b50 <xTaskGenericCreate+0x21c>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
    29a6:	c6 01       	movw	r24, r12
    29a8:	65 ea       	ldi	r22, 0xA5	; 165
    29aa:	70 e0       	ldi	r23, 0x00	; 0
    29ac:	a5 01       	movw	r20, r10
    29ae:	0e 94 dd 2a 	call	0x55ba	; 0x55ba <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
    29b2:	08 94       	sec
    29b4:	a1 08       	sbc	r10, r1
    29b6:	b1 08       	sbc	r11, r1
    29b8:	eb 81       	ldd	r30, Y+3	; 0x03
    29ba:	fc 81       	ldd	r31, Y+4	; 0x04
    29bc:	e7 88       	ldd	r14, Z+23	; 0x17
    29be:	f0 8c       	ldd	r15, Z+24	; 0x18
    29c0:	ea 0c       	add	r14, r10
    29c2:	fb 1c       	adc	r15, r11
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    29c4:	cf 01       	movw	r24, r30
    29c6:	49 96       	adiw	r24, 0x19	; 25
    29c8:	b4 01       	movw	r22, r8
    29ca:	48 e0       	ldi	r20, 0x08	; 8
    29cc:	50 e0       	ldi	r21, 0x00	; 0
    29ce:	0e 94 e4 2a 	call	0x55c8	; 0x55c8 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
    29d2:	eb 81       	ldd	r30, Y+3	; 0x03
    29d4:	fc 81       	ldd	r31, Y+4	; 0x04
    29d6:	10 a2       	std	Z+32, r1	; 0x20
    29d8:	05 2d       	mov	r16, r5
    29da:	f3 e0       	ldi	r31, 0x03	; 3
    29dc:	f5 15       	cp	r31, r5
    29de:	08 f4       	brcc	.+2      	; 0x29e2 <xTaskGenericCreate+0xae>
    29e0:	03 e0       	ldi	r16, 0x03	; 3
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - 1;
	}

	pxTCB->uxPriority = uxPriority;
    29e2:	eb 81       	ldd	r30, Y+3	; 0x03
    29e4:	fc 81       	ldd	r31, Y+4	; 0x04
    29e6:	06 8b       	std	Z+22, r16	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    29e8:	42 e0       	ldi	r20, 0x02	; 2
    29ea:	c4 2e       	mov	r12, r20
    29ec:	d1 2c       	mov	r13, r1
    29ee:	ce 0e       	add	r12, r30
    29f0:	df 1e       	adc	r13, r31
    29f2:	c6 01       	movw	r24, r12
    29f4:	0e 94 ee 0d 	call	0x1bdc	; 0x1bdc <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    29f8:	8b 81       	ldd	r24, Y+3	; 0x03
    29fa:	9c 81       	ldd	r25, Y+4	; 0x04
    29fc:	0c 96       	adiw	r24, 0x0c	; 12
    29fe:	0e 94 ee 0d 	call	0x1bdc	; 0x1bdc <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    2a02:	8b 81       	ldd	r24, Y+3	; 0x03
    2a04:	9c 81       	ldd	r25, Y+4	; 0x04
    2a06:	fc 01       	movw	r30, r24
    2a08:	91 87       	std	Z+9, r25	; 0x09
    2a0a:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    2a0c:	84 e0       	ldi	r24, 0x04	; 4
    2a0e:	90 e0       	ldi	r25, 0x00	; 0
    2a10:	80 1b       	sub	r24, r16
    2a12:	91 09       	sbc	r25, r1
    2a14:	95 87       	std	Z+13, r25	; 0x0d
    2a16:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    2a18:	f3 8b       	std	Z+19, r31	; 0x13
    2a1a:	e2 8b       	std	Z+18, r30	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    2a1c:	c7 01       	movw	r24, r14
    2a1e:	69 81       	ldd	r22, Y+1	; 0x01
    2a20:	7a 81       	ldd	r23, Y+2	; 0x02
    2a22:	a1 01       	movw	r20, r2
    2a24:	0e 94 e9 15 	call	0x2bd2	; 0x2bd2 <pxPortInitialiseStack>
    2a28:	eb 81       	ldd	r30, Y+3	; 0x03
    2a2a:	fc 81       	ldd	r31, Y+4	; 0x04
    2a2c:	91 83       	std	Z+1, r25	; 0x01
    2a2e:	80 83       	st	Z, r24
		}
		#endif

		if( ( void * ) pxCreatedTask != NULL )
    2a30:	61 14       	cp	r6, r1
    2a32:	71 04       	cpc	r7, r1
    2a34:	21 f0       	breq	.+8      	; 0x2a3e <xTaskGenericCreate+0x10a>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    2a36:	cf 01       	movw	r24, r30
    2a38:	f3 01       	movw	r30, r6
    2a3a:	91 83       	std	Z+1, r25	; 0x01
    2a3c:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		portENTER_CRITICAL();
    2a3e:	0f b6       	in	r0, 0x3f	; 63
    2a40:	f8 94       	cli
    2a42:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    2a44:	80 91 2f 03 	lds	r24, 0x032F
    2a48:	8f 5f       	subi	r24, 0xFF	; 255
    2a4a:	80 93 2f 03 	sts	0x032F, r24
			if( pxCurrentTCB == NULL )
    2a4e:	80 91 26 03 	lds	r24, 0x0326
    2a52:	90 91 27 03 	lds	r25, 0x0327
    2a56:	89 2b       	or	r24, r25
    2a58:	b9 f5       	brne	.+110    	; 0x2ac8 <xTaskGenericCreate+0x194>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    2a5a:	eb 81       	ldd	r30, Y+3	; 0x03
    2a5c:	fc 81       	ldd	r31, Y+4	; 0x04
    2a5e:	f0 93 27 03 	sts	0x0327, r31
    2a62:	e0 93 26 03 	sts	0x0326, r30

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    2a66:	80 91 2f 03 	lds	r24, 0x032F
    2a6a:	81 30       	cpi	r24, 0x01	; 1
    2a6c:	f1 f5       	brne	.+124    	; 0x2aea <xTaskGenericCreate+0x1b6>
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    2a6e:	84 e3       	ldi	r24, 0x34	; 52
    2a70:	93 e0       	ldi	r25, 0x03	; 3
    2a72:	0e 94 de 0d 	call	0x1bbc	; 0x1bbc <vListInitialise>
    2a76:	8d e3       	ldi	r24, 0x3D	; 61
    2a78:	93 e0       	ldi	r25, 0x03	; 3
    2a7a:	0e 94 de 0d 	call	0x1bbc	; 0x1bbc <vListInitialise>
    2a7e:	86 e4       	ldi	r24, 0x46	; 70
    2a80:	93 e0       	ldi	r25, 0x03	; 3
    2a82:	0e 94 de 0d 	call	0x1bbc	; 0x1bbc <vListInitialise>
    2a86:	8f e4       	ldi	r24, 0x4F	; 79
    2a88:	93 e0       	ldi	r25, 0x03	; 3
    2a8a:	0e 94 de 0d 	call	0x1bbc	; 0x1bbc <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    2a8e:	38 e5       	ldi	r19, 0x58	; 88
    2a90:	e3 2e       	mov	r14, r19
    2a92:	33 e0       	ldi	r19, 0x03	; 3
    2a94:	f3 2e       	mov	r15, r19
    2a96:	c7 01       	movw	r24, r14
    2a98:	0e 94 de 0d 	call	0x1bbc	; 0x1bbc <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    2a9c:	01 e6       	ldi	r16, 0x61	; 97
    2a9e:	13 e0       	ldi	r17, 0x03	; 3
    2aa0:	c8 01       	movw	r24, r16
    2aa2:	0e 94 de 0d 	call	0x1bbc	; 0x1bbc <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    2aa6:	8e e6       	ldi	r24, 0x6E	; 110
    2aa8:	93 e0       	ldi	r25, 0x03	; 3
    2aaa:	0e 94 de 0d 	call	0x1bbc	; 0x1bbc <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    2aae:	87 e7       	ldi	r24, 0x77	; 119
    2ab0:	93 e0       	ldi	r25, 0x03	; 3
    2ab2:	0e 94 de 0d 	call	0x1bbc	; 0x1bbc <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    2ab6:	f0 92 6b 03 	sts	0x036B, r15
    2aba:	e0 92 6a 03 	sts	0x036A, r14
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    2abe:	10 93 6d 03 	sts	0x036D, r17
    2ac2:	00 93 6c 03 	sts	0x036C, r16
    2ac6:	11 c0       	rjmp	.+34     	; 0x2aea <xTaskGenericCreate+0x1b6>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    2ac8:	80 91 30 03 	lds	r24, 0x0330
    2acc:	88 23       	and	r24, r24
    2ace:	69 f4       	brne	.+26     	; 0x2aea <xTaskGenericCreate+0x1b6>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    2ad0:	e0 91 26 03 	lds	r30, 0x0326
    2ad4:	f0 91 27 03 	lds	r31, 0x0327
    2ad8:	86 89       	ldd	r24, Z+22	; 0x16
    2ada:	58 16       	cp	r5, r24
    2adc:	30 f0       	brcs	.+12     	; 0x2aea <xTaskGenericCreate+0x1b6>
					{
						pxCurrentTCB = pxNewTCB;
    2ade:	8b 81       	ldd	r24, Y+3	; 0x03
    2ae0:	9c 81       	ldd	r25, Y+4	; 0x04
    2ae2:	90 93 27 03 	sts	0x0327, r25
    2ae6:	80 93 26 03 	sts	0x0326, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    2aea:	eb 81       	ldd	r30, Y+3	; 0x03
    2aec:	fc 81       	ldd	r31, Y+4	; 0x04
    2aee:	96 89       	ldd	r25, Z+22	; 0x16
    2af0:	80 91 33 03 	lds	r24, 0x0333
    2af4:	89 17       	cp	r24, r25
    2af6:	10 f4       	brcc	.+4      	; 0x2afc <xTaskGenericCreate+0x1c8>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    2af8:	90 93 33 03 	sts	0x0333, r25
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    2afc:	80 91 32 03 	lds	r24, 0x0332
    2b00:	8f 5f       	subi	r24, 0xFF	; 255
    2b02:	80 93 32 03 	sts	0x0332, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    2b06:	eb 81       	ldd	r30, Y+3	; 0x03
    2b08:	fc 81       	ldd	r31, Y+4	; 0x04
    2b0a:	96 89       	ldd	r25, Z+22	; 0x16
    2b0c:	80 91 2d 03 	lds	r24, 0x032D
    2b10:	89 17       	cp	r24, r25
    2b12:	10 f4       	brcc	.+4      	; 0x2b18 <xTaskGenericCreate+0x1e4>
    2b14:	90 93 2d 03 	sts	0x032D, r25
    2b18:	eb 81       	ldd	r30, Y+3	; 0x03
    2b1a:	fc 81       	ldd	r31, Y+4	; 0x04
    2b1c:	86 89       	ldd	r24, Z+22	; 0x16
    2b1e:	29 e0       	ldi	r18, 0x09	; 9
    2b20:	82 9f       	mul	r24, r18
    2b22:	c0 01       	movw	r24, r0
    2b24:	11 24       	eor	r1, r1
    2b26:	8c 5c       	subi	r24, 0xCC	; 204
    2b28:	9c 4f       	sbci	r25, 0xFC	; 252
    2b2a:	b6 01       	movw	r22, r12
    2b2c:	0e 94 f2 0d 	call	0x1be4	; 0x1be4 <vListInsertEnd>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		portEXIT_CRITICAL();
    2b30:	0f 90       	pop	r0
    2b32:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED( pxNewTCB );
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    2b34:	80 91 30 03 	lds	r24, 0x0330
    2b38:	88 23       	and	r24, r24
    2b3a:	49 f0       	breq	.+18     	; 0x2b4e <xTaskGenericCreate+0x21a>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    2b3c:	e0 91 26 03 	lds	r30, 0x0326
    2b40:	f0 91 27 03 	lds	r31, 0x0327
    2b44:	86 89       	ldd	r24, Z+22	; 0x16
    2b46:	85 15       	cp	r24, r5
    2b48:	10 f4       	brcc	.+4      	; 0x2b4e <xTaskGenericCreate+0x21a>
			{
				portYIELD_WITHIN_API();
    2b4a:	0e 94 ca 16 	call	0x2d94	; 0x2d94 <vPortYield>
    2b4e:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    2b50:	0f 90       	pop	r0
    2b52:	0f 90       	pop	r0
    2b54:	0f 90       	pop	r0
    2b56:	0f 90       	pop	r0
    2b58:	cf 91       	pop	r28
    2b5a:	df 91       	pop	r29
    2b5c:	1f 91       	pop	r17
    2b5e:	0f 91       	pop	r16
    2b60:	ff 90       	pop	r15
    2b62:	ef 90       	pop	r14
    2b64:	df 90       	pop	r13
    2b66:	cf 90       	pop	r12
    2b68:	bf 90       	pop	r11
    2b6a:	af 90       	pop	r10
    2b6c:	9f 90       	pop	r9
    2b6e:	8f 90       	pop	r8
    2b70:	7f 90       	pop	r7
    2b72:	6f 90       	pop	r6
    2b74:	5f 90       	pop	r5
    2b76:	3f 90       	pop	r3
    2b78:	2f 90       	pop	r2
    2b7a:	08 95       	ret

00002b7c <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    2b7c:	af 92       	push	r10
    2b7e:	bf 92       	push	r11
    2b80:	cf 92       	push	r12
    2b82:	df 92       	push	r13
    2b84:	ef 92       	push	r14
    2b86:	ff 92       	push	r15
    2b88:	0f 93       	push	r16
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
    2b8a:	8a e5       	ldi	r24, 0x5A	; 90
    2b8c:	94 e1       	ldi	r25, 0x14	; 20
    2b8e:	60 ec       	ldi	r22, 0xC0	; 192
    2b90:	72 e0       	ldi	r23, 0x02	; 2
    2b92:	45 e5       	ldi	r20, 0x55	; 85
    2b94:	50 e0       	ldi	r21, 0x00	; 0
    2b96:	20 e0       	ldi	r18, 0x00	; 0
    2b98:	30 e0       	ldi	r19, 0x00	; 0
    2b9a:	00 e0       	ldi	r16, 0x00	; 0
    2b9c:	ee 24       	eor	r14, r14
    2b9e:	ff 24       	eor	r15, r15
    2ba0:	cc 24       	eor	r12, r12
    2ba2:	dd 24       	eor	r13, r13
    2ba4:	aa 24       	eor	r10, r10
    2ba6:	bb 24       	eor	r11, r11
    2ba8:	0e 94 9a 14 	call	0x2934	; 0x2934 <xTaskGenericCreate>

	if( xReturn == pdPASS )
    2bac:	81 30       	cpi	r24, 0x01	; 1
    2bae:	49 f4       	brne	.+18     	; 0x2bc2 <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    2bb0:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    2bb2:	80 93 30 03 	sts	0x0330, r24
		xTickCount = ( portTickType ) 0;
    2bb6:	10 92 2b 03 	sts	0x032B, r1
    2bba:	10 92 2a 03 	sts	0x032A, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
    2bbe:	0e 94 31 16 	call	0x2c62	; 0x2c62 <xPortStartScheduler>
		else
		{
			/* Should only reach here if a task calls xTaskEndScheduler(). */
		}
	}
}
    2bc2:	0f 91       	pop	r16
    2bc4:	ff 90       	pop	r15
    2bc6:	ef 90       	pop	r14
    2bc8:	df 90       	pop	r13
    2bca:	cf 90       	pop	r12
    2bcc:	bf 90       	pop	r11
    2bce:	af 90       	pop	r10
    2bd0:	08 95       	ret

00002bd2 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    2bd2:	fc 01       	movw	r30, r24
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    2bd4:	91 e1       	ldi	r25, 0x11	; 17
    2bd6:	90 83       	st	Z, r25
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    2bd8:	22 e2       	ldi	r18, 0x22	; 34
    2bda:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    2bdc:	83 e3       	ldi	r24, 0x33	; 51
    2bde:	82 93       	st	-Z, r24
	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	

	usAddress = ( unsigned short ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2be0:	62 93       	st	-Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2be2:	72 93       	st	-Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    2be4:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    2be6:	80 e8       	ldi	r24, 0x80	; 128
    2be8:	82 93       	st	-Z, r24
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    2bea:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    2bec:	82 e0       	ldi	r24, 0x02	; 2
    2bee:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    2bf0:	83 e0       	ldi	r24, 0x03	; 3
    2bf2:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    2bf4:	84 e0       	ldi	r24, 0x04	; 4
    2bf6:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    2bf8:	85 e0       	ldi	r24, 0x05	; 5
    2bfa:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    2bfc:	86 e0       	ldi	r24, 0x06	; 6
    2bfe:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    2c00:	87 e0       	ldi	r24, 0x07	; 7
    2c02:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    2c04:	88 e0       	ldi	r24, 0x08	; 8
    2c06:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    2c08:	89 e0       	ldi	r24, 0x09	; 9
    2c0a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    2c0c:	80 e1       	ldi	r24, 0x10	; 16
    2c0e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    2c10:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    2c12:	82 e1       	ldi	r24, 0x12	; 18
    2c14:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    2c16:	83 e1       	ldi	r24, 0x13	; 19
    2c18:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    2c1a:	84 e1       	ldi	r24, 0x14	; 20
    2c1c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    2c1e:	85 e1       	ldi	r24, 0x15	; 21
    2c20:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    2c22:	86 e1       	ldi	r24, 0x16	; 22
    2c24:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    2c26:	87 e1       	ldi	r24, 0x17	; 23
    2c28:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    2c2a:	88 e1       	ldi	r24, 0x18	; 24
    2c2c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    2c2e:	89 e1       	ldi	r24, 0x19	; 25
    2c30:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    2c32:	80 e2       	ldi	r24, 0x20	; 32
    2c34:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    2c36:	81 e2       	ldi	r24, 0x21	; 33
    2c38:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    2c3a:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    2c3c:	83 e2       	ldi	r24, 0x23	; 35
    2c3e:	82 93       	st	-Z, r24
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */

	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2c40:	42 93       	st	-Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2c42:	52 93       	st	-Z, r21
	pxTopOfStack--;


	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    2c44:	86 e2       	ldi	r24, 0x26	; 38
    2c46:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    2c48:	87 e2       	ldi	r24, 0x27	; 39
    2c4a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    2c4c:	88 e2       	ldi	r24, 0x28	; 40
    2c4e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    2c50:	89 e2       	ldi	r24, 0x29	; 41
    2c52:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    2c54:	80 e3       	ldi	r24, 0x30	; 48
    2c56:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    2c58:	81 e3       	ldi	r24, 0x31	; 49
    2c5a:	82 93       	st	-Z, r24
    2c5c:	31 97       	sbiw	r30, 0x01	; 1
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    2c5e:	cf 01       	movw	r24, r30
    2c60:	08 95       	ret

00002c62 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	OCR1AH = ucHighByte;
    2c62:	10 92 89 00 	sts	0x0089, r1
	OCR1AL = ucLowByte;
    2c66:	89 ef       	ldi	r24, 0xF9	; 249
    2c68:	80 93 88 00 	sts	0x0088, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    2c6c:	8b e0       	ldi	r24, 0x0B	; 11
    2c6e:	80 93 81 00 	sts	0x0081, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
    2c72:	ef e6       	ldi	r30, 0x6F	; 111
    2c74:	f0 e0       	ldi	r31, 0x00	; 0
    2c76:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    2c78:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
    2c7a:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    2c7c:	a0 91 26 03 	lds	r26, 0x0326
    2c80:	b0 91 27 03 	lds	r27, 0x0327
    2c84:	cd 91       	ld	r28, X+
    2c86:	cd bf       	out	0x3d, r28	; 61
    2c88:	dd 91       	ld	r29, X+
    2c8a:	de bf       	out	0x3e, r29	; 62
    2c8c:	ff 91       	pop	r31
    2c8e:	ef 91       	pop	r30
    2c90:	df 91       	pop	r29
    2c92:	cf 91       	pop	r28
    2c94:	bf 91       	pop	r27
    2c96:	af 91       	pop	r26
    2c98:	9f 91       	pop	r25
    2c9a:	8f 91       	pop	r24
    2c9c:	7f 91       	pop	r23
    2c9e:	6f 91       	pop	r22
    2ca0:	5f 91       	pop	r21
    2ca2:	4f 91       	pop	r20
    2ca4:	3f 91       	pop	r19
    2ca6:	2f 91       	pop	r18
    2ca8:	1f 91       	pop	r17
    2caa:	0f 91       	pop	r16
    2cac:	ff 90       	pop	r15
    2cae:	ef 90       	pop	r14
    2cb0:	df 90       	pop	r13
    2cb2:	cf 90       	pop	r12
    2cb4:	bf 90       	pop	r11
    2cb6:	af 90       	pop	r10
    2cb8:	9f 90       	pop	r9
    2cba:	8f 90       	pop	r8
    2cbc:	7f 90       	pop	r7
    2cbe:	6f 90       	pop	r6
    2cc0:	5f 90       	pop	r5
    2cc2:	4f 90       	pop	r4
    2cc4:	3f 90       	pop	r3
    2cc6:	2f 90       	pop	r2
    2cc8:	1f 90       	pop	r1
    2cca:	0f 90       	pop	r0
    2ccc:	0f be       	out	0x3f, r0	; 63
    2cce:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    2cd0:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    2cd2:	81 e0       	ldi	r24, 0x01	; 1
    2cd4:	08 95       	ret

00002cd6 <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    2cd6:	08 95       	ret

00002cd8 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2cd8:	0f 92       	push	r0
    2cda:	0f b6       	in	r0, 0x3f	; 63
    2cdc:	f8 94       	cli
    2cde:	0f 92       	push	r0
    2ce0:	1f 92       	push	r1
    2ce2:	11 24       	eor	r1, r1
    2ce4:	2f 92       	push	r2
    2ce6:	3f 92       	push	r3
    2ce8:	4f 92       	push	r4
    2cea:	5f 92       	push	r5
    2cec:	6f 92       	push	r6
    2cee:	7f 92       	push	r7
    2cf0:	8f 92       	push	r8
    2cf2:	9f 92       	push	r9
    2cf4:	af 92       	push	r10
    2cf6:	bf 92       	push	r11
    2cf8:	cf 92       	push	r12
    2cfa:	df 92       	push	r13
    2cfc:	ef 92       	push	r14
    2cfe:	ff 92       	push	r15
    2d00:	0f 93       	push	r16
    2d02:	1f 93       	push	r17
    2d04:	2f 93       	push	r18
    2d06:	3f 93       	push	r19
    2d08:	4f 93       	push	r20
    2d0a:	5f 93       	push	r21
    2d0c:	6f 93       	push	r22
    2d0e:	7f 93       	push	r23
    2d10:	8f 93       	push	r24
    2d12:	9f 93       	push	r25
    2d14:	af 93       	push	r26
    2d16:	bf 93       	push	r27
    2d18:	cf 93       	push	r28
    2d1a:	df 93       	push	r29
    2d1c:	ef 93       	push	r30
    2d1e:	ff 93       	push	r31
    2d20:	a0 91 26 03 	lds	r26, 0x0326
    2d24:	b0 91 27 03 	lds	r27, 0x0327
    2d28:	0d b6       	in	r0, 0x3d	; 61
    2d2a:	0d 92       	st	X+, r0
    2d2c:	0e b6       	in	r0, 0x3e	; 62
    2d2e:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    2d30:	0e 94 45 12 	call	0x248a	; 0x248a <vTaskIncrementTick>
	vTaskSwitchContext();
    2d34:	0e 94 77 11 	call	0x22ee	; 0x22ee <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2d38:	a0 91 26 03 	lds	r26, 0x0326
    2d3c:	b0 91 27 03 	lds	r27, 0x0327
    2d40:	cd 91       	ld	r28, X+
    2d42:	cd bf       	out	0x3d, r28	; 61
    2d44:	dd 91       	ld	r29, X+
    2d46:	de bf       	out	0x3e, r29	; 62
    2d48:	ff 91       	pop	r31
    2d4a:	ef 91       	pop	r30
    2d4c:	df 91       	pop	r29
    2d4e:	cf 91       	pop	r28
    2d50:	bf 91       	pop	r27
    2d52:	af 91       	pop	r26
    2d54:	9f 91       	pop	r25
    2d56:	8f 91       	pop	r24
    2d58:	7f 91       	pop	r23
    2d5a:	6f 91       	pop	r22
    2d5c:	5f 91       	pop	r21
    2d5e:	4f 91       	pop	r20
    2d60:	3f 91       	pop	r19
    2d62:	2f 91       	pop	r18
    2d64:	1f 91       	pop	r17
    2d66:	0f 91       	pop	r16
    2d68:	ff 90       	pop	r15
    2d6a:	ef 90       	pop	r14
    2d6c:	df 90       	pop	r13
    2d6e:	cf 90       	pop	r12
    2d70:	bf 90       	pop	r11
    2d72:	af 90       	pop	r10
    2d74:	9f 90       	pop	r9
    2d76:	8f 90       	pop	r8
    2d78:	7f 90       	pop	r7
    2d7a:	6f 90       	pop	r6
    2d7c:	5f 90       	pop	r5
    2d7e:	4f 90       	pop	r4
    2d80:	3f 90       	pop	r3
    2d82:	2f 90       	pop	r2
    2d84:	1f 90       	pop	r1
    2d86:	0f 90       	pop	r0
    2d88:	0f be       	out	0x3f, r0	; 63
    2d8a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2d8c:	08 95       	ret

00002d8e <__vector_17>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    2d8e:	0e 94 6c 16 	call	0x2cd8	; 0x2cd8 <vPortYieldFromTick>
		asm volatile ( "reti" );
    2d92:	18 95       	reti

00002d94 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2d94:	0f 92       	push	r0
    2d96:	0f b6       	in	r0, 0x3f	; 63
    2d98:	f8 94       	cli
    2d9a:	0f 92       	push	r0
    2d9c:	1f 92       	push	r1
    2d9e:	11 24       	eor	r1, r1
    2da0:	2f 92       	push	r2
    2da2:	3f 92       	push	r3
    2da4:	4f 92       	push	r4
    2da6:	5f 92       	push	r5
    2da8:	6f 92       	push	r6
    2daa:	7f 92       	push	r7
    2dac:	8f 92       	push	r8
    2dae:	9f 92       	push	r9
    2db0:	af 92       	push	r10
    2db2:	bf 92       	push	r11
    2db4:	cf 92       	push	r12
    2db6:	df 92       	push	r13
    2db8:	ef 92       	push	r14
    2dba:	ff 92       	push	r15
    2dbc:	0f 93       	push	r16
    2dbe:	1f 93       	push	r17
    2dc0:	2f 93       	push	r18
    2dc2:	3f 93       	push	r19
    2dc4:	4f 93       	push	r20
    2dc6:	5f 93       	push	r21
    2dc8:	6f 93       	push	r22
    2dca:	7f 93       	push	r23
    2dcc:	8f 93       	push	r24
    2dce:	9f 93       	push	r25
    2dd0:	af 93       	push	r26
    2dd2:	bf 93       	push	r27
    2dd4:	cf 93       	push	r28
    2dd6:	df 93       	push	r29
    2dd8:	ef 93       	push	r30
    2dda:	ff 93       	push	r31
    2ddc:	a0 91 26 03 	lds	r26, 0x0326
    2de0:	b0 91 27 03 	lds	r27, 0x0327
    2de4:	0d b6       	in	r0, 0x3d	; 61
    2de6:	0d 92       	st	X+, r0
    2de8:	0e b6       	in	r0, 0x3e	; 62
    2dea:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2dec:	0e 94 77 11 	call	0x22ee	; 0x22ee <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2df0:	a0 91 26 03 	lds	r26, 0x0326
    2df4:	b0 91 27 03 	lds	r27, 0x0327
    2df8:	cd 91       	ld	r28, X+
    2dfa:	cd bf       	out	0x3d, r28	; 61
    2dfc:	dd 91       	ld	r29, X+
    2dfe:	de bf       	out	0x3e, r29	; 62
    2e00:	ff 91       	pop	r31
    2e02:	ef 91       	pop	r30
    2e04:	df 91       	pop	r29
    2e06:	cf 91       	pop	r28
    2e08:	bf 91       	pop	r27
    2e0a:	af 91       	pop	r26
    2e0c:	9f 91       	pop	r25
    2e0e:	8f 91       	pop	r24
    2e10:	7f 91       	pop	r23
    2e12:	6f 91       	pop	r22
    2e14:	5f 91       	pop	r21
    2e16:	4f 91       	pop	r20
    2e18:	3f 91       	pop	r19
    2e1a:	2f 91       	pop	r18
    2e1c:	1f 91       	pop	r17
    2e1e:	0f 91       	pop	r16
    2e20:	ff 90       	pop	r15
    2e22:	ef 90       	pop	r14
    2e24:	df 90       	pop	r13
    2e26:	cf 90       	pop	r12
    2e28:	bf 90       	pop	r11
    2e2a:	af 90       	pop	r10
    2e2c:	9f 90       	pop	r9
    2e2e:	8f 90       	pop	r8
    2e30:	7f 90       	pop	r7
    2e32:	6f 90       	pop	r6
    2e34:	5f 90       	pop	r5
    2e36:	4f 90       	pop	r4
    2e38:	3f 90       	pop	r3
    2e3a:	2f 90       	pop	r2
    2e3c:	1f 90       	pop	r1
    2e3e:	0f 90       	pop	r0
    2e40:	0f be       	out	0x3f, r0	; 63
    2e42:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2e44:	08 95       	ret

00002e46 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    2e46:	0f 93       	push	r16
    2e48:	1f 93       	push	r17
    2e4a:	cf 93       	push	r28
    2e4c:	df 93       	push	r29
    2e4e:	fc 01       	movw	r30, r24
corCRCB *pxUnblockedCRCB;
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2e50:	80 81       	ld	r24, Z
    2e52:	88 23       	and	r24, r24
    2e54:	19 f4       	brne	.+6      	; 0x2e5c <xCoRoutineRemoveFromEventList+0x16>
    2e56:	c0 e0       	ldi	r28, 0x00	; 0
    2e58:	d0 e0       	ldi	r29, 0x00	; 0
    2e5a:	05 c0       	rjmp	.+10     	; 0x2e66 <xCoRoutineRemoveFromEventList+0x20>
    2e5c:	05 80       	ldd	r0, Z+5	; 0x05
    2e5e:	f6 81       	ldd	r31, Z+6	; 0x06
    2e60:	e0 2d       	mov	r30, r0
    2e62:	c6 81       	ldd	r28, Z+6	; 0x06
    2e64:	d7 81       	ldd	r29, Z+7	; 0x07
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2e66:	8e 01       	movw	r16, r28
    2e68:	04 5f       	subi	r16, 0xF4	; 244
    2e6a:	1f 4f       	sbci	r17, 0xFF	; 255
    2e6c:	c8 01       	movw	r24, r16
    2e6e:	0e 94 50 0e 	call	0x1ca0	; 0x1ca0 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    2e72:	81 eb       	ldi	r24, 0xB1	; 177
    2e74:	93 e0       	ldi	r25, 0x03	; 3
    2e76:	b8 01       	movw	r22, r16
    2e78:	0e 94 f2 0d 	call	0x1be4	; 0x1be4 <vListInsertEnd>
    2e7c:	20 e0       	ldi	r18, 0x00	; 0
    2e7e:	e0 91 80 03 	lds	r30, 0x0380
    2e82:	f0 91 81 03 	lds	r31, 0x0381
    2e86:	9e 89       	ldd	r25, Y+22	; 0x16
    2e88:	86 89       	ldd	r24, Z+22	; 0x16
    2e8a:	98 17       	cp	r25, r24
    2e8c:	08 f0       	brcs	.+2      	; 0x2e90 <xCoRoutineRemoveFromEventList+0x4a>
    2e8e:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    2e90:	82 2f       	mov	r24, r18
    2e92:	df 91       	pop	r29
    2e94:	cf 91       	pop	r28
    2e96:	1f 91       	pop	r17
    2e98:	0f 91       	pop	r16
    2e9a:	08 95       	ret

00002e9c <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    2e9c:	ff 92       	push	r15
    2e9e:	0f 93       	push	r16
    2ea0:	1f 93       	push	r17
    2ea2:	cf 93       	push	r28
    2ea4:	df 93       	push	r29
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    2ea6:	99 e0       	ldi	r25, 0x09	; 9
    2ea8:	f9 2e       	mov	r15, r25
    2eaa:	28 c0       	rjmp	.+80     	; 0x2efc <vCoRoutineSchedule+0x60>
	while( !listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    2eac:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    2eae:	80 91 b1 03 	lds	r24, 0x03B1
    2eb2:	88 23       	and	r24, r24
    2eb4:	19 f4       	brne	.+6      	; 0x2ebc <vCoRoutineSchedule+0x20>
    2eb6:	c0 e0       	ldi	r28, 0x00	; 0
    2eb8:	d0 e0       	ldi	r29, 0x00	; 0
    2eba:	06 c0       	rjmp	.+12     	; 0x2ec8 <vCoRoutineSchedule+0x2c>
    2ebc:	e0 91 b6 03 	lds	r30, 0x03B6
    2ec0:	f0 91 b7 03 	lds	r31, 0x03B7
    2ec4:	c6 81       	ldd	r28, Z+6	; 0x06
    2ec6:	d7 81       	ldd	r29, Z+7	; 0x07
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2ec8:	ce 01       	movw	r24, r28
    2eca:	0c 96       	adiw	r24, 0x0c	; 12
    2ecc:	0e 94 50 0e 	call	0x1ca0	; 0x1ca0 <vListRemove>
		}
		portENABLE_INTERRUPTS();
    2ed0:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    2ed2:	8e 01       	movw	r16, r28
    2ed4:	0e 5f       	subi	r16, 0xFE	; 254
    2ed6:	1f 4f       	sbci	r17, 0xFF	; 255
    2ed8:	c8 01       	movw	r24, r16
    2eda:	0e 94 50 0e 	call	0x1ca0	; 0x1ca0 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    2ede:	9e 89       	ldd	r25, Y+22	; 0x16
    2ee0:	80 91 82 03 	lds	r24, 0x0382
    2ee4:	89 17       	cp	r24, r25
    2ee6:	10 f4       	brcc	.+4      	; 0x2eec <vCoRoutineSchedule+0x50>
    2ee8:	90 93 82 03 	sts	0x0382, r25
    2eec:	9f 9d       	mul	r25, r15
    2eee:	c0 01       	movw	r24, r0
    2ef0:	11 24       	eor	r1, r1
    2ef2:	87 57       	subi	r24, 0x77	; 119
    2ef4:	9c 4f       	sbci	r25, 0xFC	; 252
    2ef6:	b8 01       	movw	r22, r16
    2ef8:	0e 94 f2 0d 	call	0x1be4	; 0x1be4 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( !listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) )
    2efc:	80 91 b1 03 	lds	r24, 0x03B1
    2f00:	88 23       	and	r24, r24
    2f02:	a1 f6       	brne	.-88     	; 0x2eac <vCoRoutineSchedule+0x10>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    2f04:	0e 94 63 11 	call	0x22c6	; 0x22c6 <xTaskGetTickCount>
    2f08:	20 91 83 03 	lds	r18, 0x0383
    2f0c:	30 91 84 03 	lds	r19, 0x0384
    2f10:	82 1b       	sub	r24, r18
    2f12:	93 0b       	sbc	r25, r19
    2f14:	90 93 86 03 	sts	0x0386, r25
    2f18:	80 93 85 03 	sts	0x0385, r24
					vListRemove( &( pxCRCB->xEventListItem ) );											
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    2f1c:	89 e0       	ldi	r24, 0x09	; 9
    2f1e:	f8 2e       	mov	r15, r24
    2f20:	54 c0       	rjmp	.+168    	; 0x2fca <vCoRoutineSchedule+0x12e>
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    2f22:	01 96       	adiw	r24, 0x01	; 1
    2f24:	90 93 88 03 	sts	0x0388, r25
    2f28:	80 93 87 03 	sts	0x0387, r24
		xPassedTicks--;
    2f2c:	21 50       	subi	r18, 0x01	; 1
    2f2e:	30 40       	sbci	r19, 0x00	; 0
    2f30:	30 93 86 03 	sts	0x0386, r19
    2f34:	20 93 85 03 	sts	0x0385, r18

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    2f38:	89 2b       	or	r24, r25
    2f3a:	c9 f5       	brne	.+114    	; 0x2fae <vCoRoutineSchedule+0x112>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    2f3c:	20 91 ad 03 	lds	r18, 0x03AD
    2f40:	30 91 ae 03 	lds	r19, 0x03AE
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    2f44:	80 91 af 03 	lds	r24, 0x03AF
    2f48:	90 91 b0 03 	lds	r25, 0x03B0
    2f4c:	90 93 ae 03 	sts	0x03AE, r25
    2f50:	80 93 ad 03 	sts	0x03AD, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    2f54:	30 93 b0 03 	sts	0x03B0, r19
    2f58:	20 93 af 03 	sts	0x03AF, r18
    2f5c:	28 c0       	rjmp	.+80     	; 0x2fae <vCoRoutineSchedule+0x112>
		}

		/* See if this tick has made a timeout expire. */
		while( ( pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList ) ) != NULL )
		{	
			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    2f5e:	20 91 87 03 	lds	r18, 0x0387
    2f62:	30 91 88 03 	lds	r19, 0x0388
    2f66:	8a 81       	ldd	r24, Y+2	; 0x02
    2f68:	9b 81       	ldd	r25, Y+3	; 0x03
    2f6a:	28 17       	cp	r18, r24
    2f6c:	39 07       	cpc	r19, r25
    2f6e:	68 f1       	brcs	.+90     	; 0x2fca <vCoRoutineSchedule+0x12e>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    2f70:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    2f72:	8e 01       	movw	r16, r28
    2f74:	0e 5f       	subi	r16, 0xFE	; 254
    2f76:	1f 4f       	sbci	r17, 0xFF	; 255
    2f78:	c8 01       	movw	r24, r16
    2f7a:	0e 94 50 0e 	call	0x1ca0	; 0x1ca0 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    2f7e:	8c 89       	ldd	r24, Y+20	; 0x14
    2f80:	9d 89       	ldd	r25, Y+21	; 0x15
    2f82:	89 2b       	or	r24, r25
    2f84:	21 f0       	breq	.+8      	; 0x2f8e <vCoRoutineSchedule+0xf2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    2f86:	ce 01       	movw	r24, r28
    2f88:	0c 96       	adiw	r24, 0x0c	; 12
    2f8a:	0e 94 50 0e 	call	0x1ca0	; 0x1ca0 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    2f8e:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    2f90:	9e 89       	ldd	r25, Y+22	; 0x16
    2f92:	80 91 82 03 	lds	r24, 0x0382
    2f96:	89 17       	cp	r24, r25
    2f98:	10 f4       	brcc	.+4      	; 0x2f9e <vCoRoutineSchedule+0x102>
    2f9a:	90 93 82 03 	sts	0x0382, r25
    2f9e:	9f 9d       	mul	r25, r15
    2fa0:	c0 01       	movw	r24, r0
    2fa2:	11 24       	eor	r1, r1
    2fa4:	87 57       	subi	r24, 0x77	; 119
    2fa6:	9c 4f       	sbci	r25, 0xFC	; 252
    2fa8:	b8 01       	movw	r22, r16
    2faa:	0e 94 f2 0d 	call	0x1be4	; 0x1be4 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( ( pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList ) ) != NULL )
    2fae:	e0 91 ad 03 	lds	r30, 0x03AD
    2fb2:	f0 91 ae 03 	lds	r31, 0x03AE
    2fb6:	80 81       	ld	r24, Z
    2fb8:	88 23       	and	r24, r24
    2fba:	39 f0       	breq	.+14     	; 0x2fca <vCoRoutineSchedule+0x12e>
    2fbc:	05 80       	ldd	r0, Z+5	; 0x05
    2fbe:	f6 81       	ldd	r31, Z+6	; 0x06
    2fc0:	e0 2d       	mov	r30, r0
    2fc2:	c6 81       	ldd	r28, Z+6	; 0x06
    2fc4:	d7 81       	ldd	r29, Z+7	; 0x07
    2fc6:	20 97       	sbiw	r28, 0x00	; 0
    2fc8:	51 f6       	brne	.-108    	; 0x2f5e <vCoRoutineSchedule+0xc2>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    2fca:	20 91 85 03 	lds	r18, 0x0385
    2fce:	30 91 86 03 	lds	r19, 0x0386
    2fd2:	80 91 87 03 	lds	r24, 0x0387
    2fd6:	90 91 88 03 	lds	r25, 0x0388
    2fda:	21 15       	cp	r18, r1
    2fdc:	31 05       	cpc	r19, r1
    2fde:	09 f0       	breq	.+2      	; 0x2fe2 <vCoRoutineSchedule+0x146>
    2fe0:	a0 cf       	rjmp	.-192    	; 0x2f22 <vCoRoutineSchedule+0x86>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    2fe2:	90 93 84 03 	sts	0x0384, r25
    2fe6:	80 93 83 03 	sts	0x0383, r24
    2fea:	90 91 82 03 	lds	r25, 0x0382

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    2fee:	29 e0       	ldi	r18, 0x09	; 9
    2ff0:	06 c0       	rjmp	.+12     	; 0x2ffe <vCoRoutineSchedule+0x162>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    2ff2:	99 23       	and	r25, r25
    2ff4:	19 f4       	brne	.+6      	; 0x2ffc <vCoRoutineSchedule+0x160>
    2ff6:	10 92 82 03 	sts	0x0382, r1
    2ffa:	32 c0       	rjmp	.+100    	; 0x3060 <vCoRoutineSchedule+0x1c4>
    2ffc:	91 50       	subi	r25, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    2ffe:	92 9f       	mul	r25, r18
    3000:	d0 01       	movw	r26, r0
    3002:	11 24       	eor	r1, r1
    3004:	a7 57       	subi	r26, 0x77	; 119
    3006:	bc 4f       	sbci	r27, 0xFC	; 252
    3008:	8c 91       	ld	r24, X
    300a:	88 23       	and	r24, r24
    300c:	91 f3       	breq	.-28     	; 0x2ff2 <vCoRoutineSchedule+0x156>
    300e:	90 93 82 03 	sts	0x0382, r25
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    3012:	11 96       	adiw	r26, 0x01	; 1
    3014:	ed 91       	ld	r30, X+
    3016:	fc 91       	ld	r31, X
    3018:	12 97       	sbiw	r26, 0x02	; 2
    301a:	02 80       	ldd	r0, Z+2	; 0x02
    301c:	f3 81       	ldd	r31, Z+3	; 0x03
    301e:	e0 2d       	mov	r30, r0
    3020:	12 96       	adiw	r26, 0x02	; 2
    3022:	fc 93       	st	X, r31
    3024:	ee 93       	st	-X, r30
    3026:	11 97       	sbiw	r26, 0x01	; 1
    3028:	cd 01       	movw	r24, r26
    302a:	03 96       	adiw	r24, 0x03	; 3
    302c:	e8 17       	cp	r30, r24
    302e:	f9 07       	cpc	r31, r25
    3030:	31 f4       	brne	.+12     	; 0x303e <vCoRoutineSchedule+0x1a2>
    3032:	82 81       	ldd	r24, Z+2	; 0x02
    3034:	93 81       	ldd	r25, Z+3	; 0x03
    3036:	12 96       	adiw	r26, 0x02	; 2
    3038:	9c 93       	st	X, r25
    303a:	8e 93       	st	-X, r24
    303c:	11 97       	sbiw	r26, 0x01	; 1
    303e:	11 96       	adiw	r26, 0x01	; 1
    3040:	ed 91       	ld	r30, X+
    3042:	fc 91       	ld	r31, X
    3044:	12 97       	sbiw	r26, 0x02	; 2
    3046:	06 80       	ldd	r0, Z+6	; 0x06
    3048:	f7 81       	ldd	r31, Z+7	; 0x07
    304a:	e0 2d       	mov	r30, r0
    304c:	f0 93 81 03 	sts	0x0381, r31
    3050:	e0 93 80 03 	sts	0x0380, r30

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    3054:	20 81       	ld	r18, Z
    3056:	31 81       	ldd	r19, Z+1	; 0x01
    3058:	cf 01       	movw	r24, r30
    305a:	67 89       	ldd	r22, Z+23	; 0x17
    305c:	f9 01       	movw	r30, r18
    305e:	09 95       	icall

	return;
}
    3060:	df 91       	pop	r29
    3062:	cf 91       	pop	r28
    3064:	1f 91       	pop	r17
    3066:	0f 91       	pop	r16
    3068:	ff 90       	pop	r15
    306a:	08 95       	ret

0000306c <vCoRoutineAddToDelayedList>:
	return xReturn;	
}
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    306c:	0f 93       	push	r16
    306e:	1f 93       	push	r17
    3070:	cf 93       	push	r28
    3072:	df 93       	push	r29
    3074:	eb 01       	movw	r28, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    3076:	00 91 87 03 	lds	r16, 0x0387
    307a:	10 91 88 03 	lds	r17, 0x0388
    307e:	08 0f       	add	r16, r24
    3080:	19 1f       	adc	r17, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    3082:	80 91 80 03 	lds	r24, 0x0380
    3086:	90 91 81 03 	lds	r25, 0x0381
    308a:	02 96       	adiw	r24, 0x02	; 2
    308c:	0e 94 50 0e 	call	0x1ca0	; 0x1ca0 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    3090:	e0 91 80 03 	lds	r30, 0x0380
    3094:	f0 91 81 03 	lds	r31, 0x0381
    3098:	13 83       	std	Z+3, r17	; 0x03
    309a:	02 83       	std	Z+2, r16	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    309c:	80 91 87 03 	lds	r24, 0x0387
    30a0:	90 91 88 03 	lds	r25, 0x0388
    30a4:	bf 01       	movw	r22, r30
    30a6:	6e 5f       	subi	r22, 0xFE	; 254
    30a8:	7f 4f       	sbci	r23, 0xFF	; 255
    30aa:	08 17       	cp	r16, r24
    30ac:	19 07       	cpc	r17, r25
    30ae:	28 f4       	brcc	.+10     	; 0x30ba <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    30b0:	80 91 af 03 	lds	r24, 0x03AF
    30b4:	90 91 b0 03 	lds	r25, 0x03B0
    30b8:	04 c0       	rjmp	.+8      	; 0x30c2 <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    30ba:	80 91 ad 03 	lds	r24, 0x03AD
    30be:	90 91 ae 03 	lds	r25, 0x03AE
    30c2:	0e 94 1b 0e 	call	0x1c36	; 0x1c36 <vListInsert>
	}

	if( pxEventList )
    30c6:	20 97       	sbiw	r28, 0x00	; 0
    30c8:	49 f0       	breq	.+18     	; 0x30dc <vCoRoutineAddToDelayedList+0x70>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    30ca:	60 91 80 03 	lds	r22, 0x0380
    30ce:	70 91 81 03 	lds	r23, 0x0381
    30d2:	64 5f       	subi	r22, 0xF4	; 244
    30d4:	7f 4f       	sbci	r23, 0xFF	; 255
    30d6:	ce 01       	movw	r24, r28
    30d8:	0e 94 1b 0e 	call	0x1c36	; 0x1c36 <vListInsert>
	}
}
    30dc:	df 91       	pop	r29
    30de:	cf 91       	pop	r28
    30e0:	1f 91       	pop	r17
    30e2:	0f 91       	pop	r16
    30e4:	08 95       	ret

000030e6 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    30e6:	af 92       	push	r10
    30e8:	bf 92       	push	r11
    30ea:	cf 92       	push	r12
    30ec:	df 92       	push	r13
    30ee:	ef 92       	push	r14
    30f0:	ff 92       	push	r15
    30f2:	0f 93       	push	r16
    30f4:	1f 93       	push	r17
    30f6:	cf 93       	push	r28
    30f8:	df 93       	push	r29
    30fa:	6c 01       	movw	r12, r24
    30fc:	b6 2e       	mov	r11, r22
    30fe:	a4 2e       	mov	r10, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    3100:	8a e1       	ldi	r24, 0x1A	; 26
    3102:	90 e0       	ldi	r25, 0x00	; 0
    3104:	0e 94 fd 18 	call	0x31fa	; 0x31fa <pvPortMalloc>
    3108:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
    310a:	00 97       	sbiw	r24, 0x00	; 0
    310c:	11 f4       	brne	.+4      	; 0x3112 <xCoRoutineCreate+0x2c>
    310e:	8f ef       	ldi	r24, 0xFF	; 255
    3110:	59 c0       	rjmp	.+178    	; 0x31c4 <xCoRoutineCreate+0xde>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    3112:	80 91 80 03 	lds	r24, 0x0380
    3116:	90 91 81 03 	lds	r25, 0x0381
    311a:	89 2b       	or	r24, r25
    311c:	21 f5       	brne	.+72     	; 0x3166 <xCoRoutineCreate+0x80>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    311e:	d0 93 81 03 	sts	0x0381, r29
    3122:	c0 93 80 03 	sts	0x0380, r28
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    3126:	89 e8       	ldi	r24, 0x89	; 137
    3128:	93 e0       	ldi	r25, 0x03	; 3
    312a:	0e 94 de 0d 	call	0x1bbc	; 0x1bbc <vListInitialise>
    312e:	82 e9       	ldi	r24, 0x92	; 146
    3130:	93 e0       	ldi	r25, 0x03	; 3
    3132:	0e 94 de 0d 	call	0x1bbc	; 0x1bbc <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    3136:	2b e9       	ldi	r18, 0x9B	; 155
    3138:	e2 2e       	mov	r14, r18
    313a:	23 e0       	ldi	r18, 0x03	; 3
    313c:	f2 2e       	mov	r15, r18
    313e:	c7 01       	movw	r24, r14
    3140:	0e 94 de 0d 	call	0x1bbc	; 0x1bbc <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    3144:	04 ea       	ldi	r16, 0xA4	; 164
    3146:	13 e0       	ldi	r17, 0x03	; 3
    3148:	c8 01       	movw	r24, r16
    314a:	0e 94 de 0d 	call	0x1bbc	; 0x1bbc <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    314e:	81 eb       	ldi	r24, 0xB1	; 177
    3150:	93 e0       	ldi	r25, 0x03	; 3
    3152:	0e 94 de 0d 	call	0x1bbc	; 0x1bbc <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    3156:	f0 92 ae 03 	sts	0x03AE, r15
    315a:	e0 92 ad 03 	sts	0x03AD, r14
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    315e:	10 93 b0 03 	sts	0x03B0, r17
    3162:	00 93 af 03 	sts	0x03AF, r16
    3166:	eb 2c       	mov	r14, r11
    3168:	bb 20       	and	r11, r11
    316a:	11 f0       	breq	.+4      	; 0x3170 <xCoRoutineCreate+0x8a>
    316c:	ee 24       	eor	r14, r14
    316e:	e3 94       	inc	r14
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    3170:	19 8e       	std	Y+25, r1	; 0x19
    3172:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    3174:	ee 8a       	std	Y+22, r14	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    3176:	af 8a       	std	Y+23, r10	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    3178:	fe 01       	movw	r30, r28
    317a:	c1 92       	st	Z+, r12
    317c:	d1 92       	st	Z+, r13
    317e:	8f 01       	movw	r16, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    3180:	cf 01       	movw	r24, r30
    3182:	0e 94 ee 0d 	call	0x1bdc	; 0x1bdc <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    3186:	ce 01       	movw	r24, r28
    3188:	0c 96       	adiw	r24, 0x0c	; 12
    318a:	0e 94 ee 0d 	call	0x1bdc	; 0x1bdc <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    318e:	d9 87       	std	Y+9, r29	; 0x09
    3190:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    3192:	db 8b       	std	Y+19, r29	; 0x13
    3194:	ca 8b       	std	Y+18, r28	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    3196:	84 e0       	ldi	r24, 0x04	; 4
    3198:	90 e0       	ldi	r25, 0x00	; 0
    319a:	8e 19       	sub	r24, r14
    319c:	91 09       	sbc	r25, r1
    319e:	9d 87       	std	Y+13, r25	; 0x0d
    31a0:	8c 87       	std	Y+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    31a2:	9e 89       	ldd	r25, Y+22	; 0x16
    31a4:	80 91 82 03 	lds	r24, 0x0382
    31a8:	89 17       	cp	r24, r25
    31aa:	10 f4       	brcc	.+4      	; 0x31b0 <xCoRoutineCreate+0xca>
    31ac:	90 93 82 03 	sts	0x0382, r25
    31b0:	89 e0       	ldi	r24, 0x09	; 9
    31b2:	98 9f       	mul	r25, r24
    31b4:	c0 01       	movw	r24, r0
    31b6:	11 24       	eor	r1, r1
    31b8:	87 57       	subi	r24, 0x77	; 119
    31ba:	9c 4f       	sbci	r25, 0xFC	; 252
    31bc:	b8 01       	movw	r22, r16
    31be:	0e 94 f2 0d 	call	0x1be4	; 0x1be4 <vListInsertEnd>
    31c2:	81 e0       	ldi	r24, 0x01	; 1
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
	}
	
	return xReturn;	
}
    31c4:	df 91       	pop	r29
    31c6:	cf 91       	pop	r28
    31c8:	1f 91       	pop	r17
    31ca:	0f 91       	pop	r16
    31cc:	ff 90       	pop	r15
    31ce:	ef 90       	pop	r14
    31d0:	df 90       	pop	r13
    31d2:	cf 90       	pop	r12
    31d4:	bf 90       	pop	r11
    31d6:	af 90       	pop	r10
    31d8:	08 95       	ret

000031da <vPortFree>:
{
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    31da:	08 95       	ret

000031dc <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    31dc:	10 92 bb 03 	sts	0x03BB, r1
    31e0:	10 92 ba 03 	sts	0x03BA, r1
}
    31e4:	08 95       	ret

000031e6 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    31e6:	28 eb       	ldi	r18, 0xB8	; 184
    31e8:	3b e0       	ldi	r19, 0x0B	; 11
    31ea:	80 91 ba 03 	lds	r24, 0x03BA
    31ee:	90 91 bb 03 	lds	r25, 0x03BB
    31f2:	28 1b       	sub	r18, r24
    31f4:	39 0b       	sbc	r19, r25
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
}
    31f6:	c9 01       	movw	r24, r18
    31f8:	08 95       	ret

000031fa <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    31fa:	0f 93       	push	r16
    31fc:	1f 93       	push	r17
    31fe:	cf 93       	push	r28
    3200:	df 93       	push	r29
    3202:	8c 01       	movw	r16, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    3204:	0e 94 5d 11 	call	0x22ba	; 0x22ba <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    3208:	80 91 ba 03 	lds	r24, 0x03BA
    320c:	90 91 bb 03 	lds	r25, 0x03BB
    3210:	98 01       	movw	r18, r16
    3212:	28 0f       	add	r18, r24
    3214:	39 1f       	adc	r19, r25
    3216:	4b e0       	ldi	r20, 0x0B	; 11
    3218:	28 3b       	cpi	r18, 0xB8	; 184
    321a:	34 07       	cpc	r19, r20
    321c:	58 f4       	brcc	.+22     	; 0x3234 <pvPortMalloc+0x3a>
    321e:	82 17       	cp	r24, r18
    3220:	93 07       	cpc	r25, r19
    3222:	40 f4       	brcc	.+16     	; 0x3234 <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    3224:	ec 01       	movw	r28, r24
    3226:	c4 54       	subi	r28, 0x44	; 68
    3228:	dc 4f       	sbci	r29, 0xFC	; 252
			xNextFreeByte += xWantedSize;			
    322a:	30 93 bb 03 	sts	0x03BB, r19
    322e:	20 93 ba 03 	sts	0x03BA, r18
    3232:	02 c0       	rjmp	.+4      	; 0x3238 <pvPortMalloc+0x3e>
    3234:	c0 e0       	ldi	r28, 0x00	; 0
    3236:	d0 e0       	ldi	r29, 0x00	; 0
		}	
	}
	xTaskResumeAll();
    3238:	0e 94 f4 12 	call	0x25e8	; 0x25e8 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
    323c:	ce 01       	movw	r24, r28
    323e:	df 91       	pop	r29
    3240:	cf 91       	pop	r28
    3242:	1f 91       	pop	r17
    3244:	0f 91       	pop	r16
    3246:	08 95       	ret

00003248 <prescaler_hex_to_value>:
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    3248:	e8 2f       	mov	r30, r24
    324a:	f0 e0       	ldi	r31, 0x00	; 0
    324c:	e7 70       	andi	r30, 0x07	; 7
    324e:	f0 70       	andi	r31, 0x00	; 0
    3250:	ee 0f       	add	r30, r30
    3252:	ff 1f       	adc	r31, r31
    3254:	e2 57       	subi	r30, 0x72	; 114
    3256:	fe 4f       	sbci	r31, 0xFE	; 254
    3258:	25 91       	lpm	r18, Z+
    325a:	34 91       	lpm	r19, Z+
}
    325c:	c9 01       	movw	r24, r18
    325e:	08 95       	ret

00003260 <prescaler_hex_to_value_for_timer2>:
uint16_t prescaler_hex_to_value_for_timer2(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to Timer2PrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(Timer2PrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    3260:	e8 2f       	mov	r30, r24
    3262:	f0 e0       	ldi	r31, 0x00	; 0
    3264:	e7 70       	andi	r30, 0x07	; 7
    3266:	f0 70       	andi	r31, 0x00	; 0
    3268:	ee 0f       	add	r30, r30
    326a:	ff 1f       	adc	r31, r31
    326c:	e6 56       	subi	r30, 0x66	; 102
    326e:	fe 4f       	sbci	r31, 0xFE	; 254
    3270:	25 91       	lpm	r18, Z+
    3272:	34 91       	lpm	r19, Z+
}
    3274:	c9 01       	movw	r24, r18
    3276:	08 95       	ret

00003278 <get_timer0_prescaler>:

uint16_t get_timer0_prescaler(void)
{
  return prescaler_hex_to_value(TCCR0B);
    3278:	85 b5       	in	r24, 0x25	; 37
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    327a:	e8 2f       	mov	r30, r24
    327c:	f0 e0       	ldi	r31, 0x00	; 0
    327e:	e7 70       	andi	r30, 0x07	; 7
    3280:	f0 70       	andi	r31, 0x00	; 0
    3282:	ee 0f       	add	r30, r30
    3284:	ff 1f       	adc	r31, r31
    3286:	e2 57       	subi	r30, 0x72	; 114
    3288:	fe 4f       	sbci	r31, 0xFE	; 254
    328a:	25 91       	lpm	r18, Z+
    328c:	34 91       	lpm	r19, Z+
}

uint16_t get_timer0_prescaler(void)
{
  return prescaler_hex_to_value(TCCR0B);
}
    328e:	c9 01       	movw	r24, r18
    3290:	08 95       	ret

00003292 <get_timer1_prescaler>:
uint16_t get_timer1_prescaler(void)
{
  return prescaler_hex_to_value(TCCR1B);
    3292:	80 91 81 00 	lds	r24, 0x0081
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    3296:	e8 2f       	mov	r30, r24
    3298:	f0 e0       	ldi	r31, 0x00	; 0
    329a:	e7 70       	andi	r30, 0x07	; 7
    329c:	f0 70       	andi	r31, 0x00	; 0
    329e:	ee 0f       	add	r30, r30
    32a0:	ff 1f       	adc	r31, r31
    32a2:	e2 57       	subi	r30, 0x72	; 114
    32a4:	fe 4f       	sbci	r31, 0xFE	; 254
    32a6:	25 91       	lpm	r18, Z+
    32a8:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR0B);
}
uint16_t get_timer1_prescaler(void)
{
  return prescaler_hex_to_value(TCCR1B);
}
    32aa:	c9 01       	movw	r24, r18
    32ac:	08 95       	ret

000032ae <get_timer2_prescaler>:
uint16_t get_timer2_prescaler(void)
{
  return prescaler_hex_to_value_for_timer2(TCCR2B);
    32ae:	80 91 b1 00 	lds	r24, 0x00B1
uint16_t prescaler_hex_to_value_for_timer2(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to Timer2PrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(Timer2PrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    32b2:	e8 2f       	mov	r30, r24
    32b4:	f0 e0       	ldi	r31, 0x00	; 0
    32b6:	e7 70       	andi	r30, 0x07	; 7
    32b8:	f0 70       	andi	r31, 0x00	; 0
    32ba:	ee 0f       	add	r30, r30
    32bc:	ff 1f       	adc	r31, r31
    32be:	e6 56       	subi	r30, 0x66	; 102
    32c0:	fe 4f       	sbci	r31, 0xFE	; 254
    32c2:	25 91       	lpm	r18, Z+
    32c4:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR1B);
}
uint16_t get_timer2_prescaler(void)
{
  return prescaler_hex_to_value_for_timer2(TCCR2B);
}
    32c6:	c9 01       	movw	r24, r18
    32c8:	08 95       	ret

000032ca <get_timer3_prescaler>:
uint16_t get_timer3_prescaler(void)
{
  return prescaler_hex_to_value(TCCR3B);
    32ca:	80 91 91 00 	lds	r24, 0x0091
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    32ce:	e8 2f       	mov	r30, r24
    32d0:	f0 e0       	ldi	r31, 0x00	; 0
    32d2:	e7 70       	andi	r30, 0x07	; 7
    32d4:	f0 70       	andi	r31, 0x00	; 0
    32d6:	ee 0f       	add	r30, r30
    32d8:	ff 1f       	adc	r31, r31
    32da:	e2 57       	subi	r30, 0x72	; 114
    32dc:	fe 4f       	sbci	r31, 0xFE	; 254
    32de:	25 91       	lpm	r18, Z+
    32e0:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value_for_timer2(TCCR2B);
}
uint16_t get_timer3_prescaler(void)
{
  return prescaler_hex_to_value(TCCR3B);
}
    32e2:	c9 01       	movw	r24, r18
    32e4:	08 95       	ret

000032e6 <get_timer4_prescaler>:
uint16_t get_timer4_prescaler(void)
{
  return prescaler_hex_to_value(TCCR4B);
    32e6:	80 91 a1 00 	lds	r24, 0x00A1
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    32ea:	e8 2f       	mov	r30, r24
    32ec:	f0 e0       	ldi	r31, 0x00	; 0
    32ee:	e7 70       	andi	r30, 0x07	; 7
    32f0:	f0 70       	andi	r31, 0x00	; 0
    32f2:	ee 0f       	add	r30, r30
    32f4:	ff 1f       	adc	r31, r31
    32f6:	e2 57       	subi	r30, 0x72	; 114
    32f8:	fe 4f       	sbci	r31, 0xFE	; 254
    32fa:	25 91       	lpm	r18, Z+
    32fc:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR3B);
}
uint16_t get_timer4_prescaler(void)
{
  return prescaler_hex_to_value(TCCR4B);
}
    32fe:	c9 01       	movw	r24, r18
    3300:	08 95       	ret

00003302 <get_timer5_prescaler>:
uint16_t get_timer5_prescaler(void)
{
  return prescaler_hex_to_value(TCCR5B);
    3302:	80 91 21 01 	lds	r24, 0x0121
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    3306:	e8 2f       	mov	r30, r24
    3308:	f0 e0       	ldi	r31, 0x00	; 0
    330a:	e7 70       	andi	r30, 0x07	; 7
    330c:	f0 70       	andi	r31, 0x00	; 0
    330e:	ee 0f       	add	r30, r30
    3310:	ff 1f       	adc	r31, r31
    3312:	e2 57       	subi	r30, 0x72	; 114
    3314:	fe 4f       	sbci	r31, 0xFE	; 254
    3316:	25 91       	lpm	r18, Z+
    3318:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR4B);
}
uint16_t get_timer5_prescaler(void)
{
  return prescaler_hex_to_value(TCCR5B);
}
    331a:	c9 01       	movw	r24, r18
    331c:	08 95       	ret

0000331e <get_timer0_overflow>:

const uint32_t get_timer0_overflow(void)
{
    return timer0_ovrflow_cnt;
    331e:	20 91 5b 14 	lds	r18, 0x145B
    3322:	30 91 5c 14 	lds	r19, 0x145C
    3326:	40 91 5d 14 	lds	r20, 0x145D
    332a:	50 91 5e 14 	lds	r21, 0x145E
}
    332e:	b9 01       	movw	r22, r18
    3330:	ca 01       	movw	r24, r20
    3332:	08 95       	ret

00003334 <get_timer1_overflow>:
const uint32_t get_timer1_overflow(void)
{
    return timer1_ovrflow_cnt;
    3334:	20 91 57 14 	lds	r18, 0x1457
    3338:	30 91 58 14 	lds	r19, 0x1458
    333c:	40 91 59 14 	lds	r20, 0x1459
    3340:	50 91 5a 14 	lds	r21, 0x145A
}
    3344:	b9 01       	movw	r22, r18
    3346:	ca 01       	movw	r24, r20
    3348:	08 95       	ret

0000334a <get_timer2_overflow>:
const uint32_t get_timer2_overflow(void)
{
    return timer2_ovrflow_cnt;
    334a:	20 91 5f 14 	lds	r18, 0x145F
    334e:	30 91 60 14 	lds	r19, 0x1460
    3352:	40 91 61 14 	lds	r20, 0x1461
    3356:	50 91 62 14 	lds	r21, 0x1462
}
    335a:	b9 01       	movw	r22, r18
    335c:	ca 01       	movw	r24, r20
    335e:	08 95       	ret

00003360 <get_timer3_overflow>:
const uint32_t get_timer3_overflow(void)
{
    return timer3_ovrflow_cnt;
    3360:	20 91 67 14 	lds	r18, 0x1467
    3364:	30 91 68 14 	lds	r19, 0x1468
    3368:	40 91 69 14 	lds	r20, 0x1469
    336c:	50 91 6a 14 	lds	r21, 0x146A
}
    3370:	b9 01       	movw	r22, r18
    3372:	ca 01       	movw	r24, r20
    3374:	08 95       	ret

00003376 <get_timer4_overflow>:
const uint32_t get_timer4_overflow(void)
{
    return timer4_ovrflow_cnt;
    3376:	20 91 53 14 	lds	r18, 0x1453
    337a:	30 91 54 14 	lds	r19, 0x1454
    337e:	40 91 55 14 	lds	r20, 0x1455
    3382:	50 91 56 14 	lds	r21, 0x1456
}
    3386:	b9 01       	movw	r22, r18
    3388:	ca 01       	movw	r24, r20
    338a:	08 95       	ret

0000338c <get_timer5_overflow>:
const uint32_t get_timer5_overflow(void)
{
    return timer5_ovrflow_cnt;
    338c:	20 91 6b 14 	lds	r18, 0x146B
    3390:	30 91 6c 14 	lds	r19, 0x146C
    3394:	40 91 6d 14 	lds	r20, 0x146D
    3398:	50 91 6e 14 	lds	r21, 0x146E
}
    339c:	b9 01       	movw	r22, r18
    339e:	ca 01       	movw	r24, r20
    33a0:	08 95       	ret

000033a2 <get_timer0_counter>:

const uint8_t get_timer0_counter(void)
{
    return TCNT0;
    33a2:	86 b5       	in	r24, 0x26	; 38
}
    33a4:	08 95       	ret

000033a6 <get_timer1_counter>:
const uint16_t get_timer1_counter(void)
{
    return TCNT1;
    33a6:	20 91 84 00 	lds	r18, 0x0084
    33aa:	30 91 85 00 	lds	r19, 0x0085
}
    33ae:	c9 01       	movw	r24, r18
    33b0:	08 95       	ret

000033b2 <get_timer2_counter>:
const uint8_t get_timer2_counter(void)
{
    return TCNT2;
    33b2:	80 91 b2 00 	lds	r24, 0x00B2
}
    33b6:	08 95       	ret

000033b8 <get_timer3_counter>:
const uint16_t get_timer3_counter(void)
{
    return TCNT3;
    33b8:	20 91 94 00 	lds	r18, 0x0094
    33bc:	30 91 95 00 	lds	r19, 0x0095
}
    33c0:	c9 01       	movw	r24, r18
    33c2:	08 95       	ret

000033c4 <get_timer4_counter>:
const uint16_t get_timer4_counter(void)
{
    return TCNT4;
    33c4:	20 91 a4 00 	lds	r18, 0x00A4
    33c8:	30 91 a5 00 	lds	r19, 0x00A5
}
    33cc:	c9 01       	movw	r24, r18
    33ce:	08 95       	ret

000033d0 <get_timer5_counter>:
const uint16_t get_timer5_counter(void)
{
    return TCNT5;
    33d0:	20 91 24 01 	lds	r18, 0x0124
    33d4:	30 91 25 01 	lds	r19, 0x0125
}
    33d8:	c9 01       	movw	r24, r18
    33da:	08 95       	ret

000033dc <reset_timer0>:

void reset_timer0(void)
{
    TCNT0 = timer0_ovrflow_cnt = 0;
    33dc:	10 92 5b 14 	sts	0x145B, r1
    33e0:	10 92 5c 14 	sts	0x145C, r1
    33e4:	10 92 5d 14 	sts	0x145D, r1
    33e8:	10 92 5e 14 	sts	0x145E, r1
    33ec:	16 bc       	out	0x26, r1	; 38
}
    33ee:	08 95       	ret

000033f0 <reset_timer1>:
void reset_timer1(void)
{
    TCNT1 = timer1_ovrflow_cnt = 0;
    33f0:	10 92 57 14 	sts	0x1457, r1
    33f4:	10 92 58 14 	sts	0x1458, r1
    33f8:	10 92 59 14 	sts	0x1459, r1
    33fc:	10 92 5a 14 	sts	0x145A, r1
    3400:	10 92 85 00 	sts	0x0085, r1
    3404:	10 92 84 00 	sts	0x0084, r1
}
    3408:	08 95       	ret

0000340a <reset_timer2>:
void reset_timer2(void)
{
    TCNT2 = timer2_ovrflow_cnt = 0;
    340a:	10 92 5f 14 	sts	0x145F, r1
    340e:	10 92 60 14 	sts	0x1460, r1
    3412:	10 92 61 14 	sts	0x1461, r1
    3416:	10 92 62 14 	sts	0x1462, r1
    341a:	10 92 b2 00 	sts	0x00B2, r1
}
    341e:	08 95       	ret

00003420 <reset_timer3>:
void reset_timer3(void)
{
    TCNT3 = timer3_ovrflow_cnt = 0;
    3420:	10 92 67 14 	sts	0x1467, r1
    3424:	10 92 68 14 	sts	0x1468, r1
    3428:	10 92 69 14 	sts	0x1469, r1
    342c:	10 92 6a 14 	sts	0x146A, r1
    3430:	10 92 95 00 	sts	0x0095, r1
    3434:	10 92 94 00 	sts	0x0094, r1
}
    3438:	08 95       	ret

0000343a <reset_timer4>:
void reset_timer4(void)
{
    TCNT4 = timer4_ovrflow_cnt = 0;
    343a:	10 92 53 14 	sts	0x1453, r1
    343e:	10 92 54 14 	sts	0x1454, r1
    3442:	10 92 55 14 	sts	0x1455, r1
    3446:	10 92 56 14 	sts	0x1456, r1
    344a:	10 92 a5 00 	sts	0x00A5, r1
    344e:	10 92 a4 00 	sts	0x00A4, r1
}
    3452:	08 95       	ret

00003454 <reset_timer5>:
void reset_timer5(void)
{
    TCNT5 = timer5_ovrflow_cnt = 0;
    3454:	10 92 6b 14 	sts	0x146B, r1
    3458:	10 92 6c 14 	sts	0x146C, r1
    345c:	10 92 6d 14 	sts	0x146D, r1
    3460:	10 92 6e 14 	sts	0x146E, r1
    3464:	10 92 25 01 	sts	0x0125, r1
    3468:	10 92 24 01 	sts	0x0124, r1
}
    346c:	08 95       	ret

0000346e <delay_us>:

	delay_loops = ((time_us * CYCLES_PER_US)+3) / 5; // +3 for rounding up (dirty) 

	// one loop takes 5 cpu cycles 
	for (i=0; i < delay_loops; i++) {};
}
    346e:	08 95       	ret

00003470 <init_timer0>:

void init_timer0(const uint8_t prescaler)
{
  TCCR0B = prescaler;
    3470:	85 bd       	out	0x25, r24	; 37
  TIMSK0 = _BV(TOIE0); // enable interrupts
    3472:	81 e0       	ldi	r24, 0x01	; 1
    3474:	80 93 6e 00 	sts	0x006E, r24
    return TCNT5;
}

void reset_timer0(void)
{
    TCNT0 = timer0_ovrflow_cnt = 0;
    3478:	10 92 5b 14 	sts	0x145B, r1
    347c:	10 92 5c 14 	sts	0x145C, r1
    3480:	10 92 5d 14 	sts	0x145D, r1
    3484:	10 92 5e 14 	sts	0x145E, r1
    3488:	16 bc       	out	0x26, r1	; 38
void init_timer0(const uint8_t prescaler)
{
  TCCR0B = prescaler;
  TIMSK0 = _BV(TOIE0); // enable interrupts
  reset_timer0(); // reset counter
}
    348a:	08 95       	ret

0000348c <init_timer1>:
void init_timer1(const uint8_t prescaler)
{
  TCCR1B = prescaler;
    348c:	80 93 81 00 	sts	0x0081, r24
  TIMSK1 = _BV(TOIE1); // enable interrupts
    3490:	81 e0       	ldi	r24, 0x01	; 1
    3492:	80 93 6f 00 	sts	0x006F, r24
{
    TCNT0 = timer0_ovrflow_cnt = 0;
}
void reset_timer1(void)
{
    TCNT1 = timer1_ovrflow_cnt = 0;
    3496:	10 92 57 14 	sts	0x1457, r1
    349a:	10 92 58 14 	sts	0x1458, r1
    349e:	10 92 59 14 	sts	0x1459, r1
    34a2:	10 92 5a 14 	sts	0x145A, r1
    34a6:	10 92 85 00 	sts	0x0085, r1
    34aa:	10 92 84 00 	sts	0x0084, r1
void init_timer1(const uint8_t prescaler)
{
  TCCR1B = prescaler;
  TIMSK1 = _BV(TOIE1); // enable interrupts
  reset_timer1(); // reset counter
}
    34ae:	08 95       	ret

000034b0 <init_timer2>:
void init_timer2(const uint8_t prescaler)
{
  TCCR2B = prescaler;
    34b0:	80 93 b1 00 	sts	0x00B1, r24
  TIMSK2 = _BV(TOIE2); // enable interrupts
    34b4:	81 e0       	ldi	r24, 0x01	; 1
    34b6:	80 93 70 00 	sts	0x0070, r24
{
    TCNT1 = timer1_ovrflow_cnt = 0;
}
void reset_timer2(void)
{
    TCNT2 = timer2_ovrflow_cnt = 0;
    34ba:	10 92 5f 14 	sts	0x145F, r1
    34be:	10 92 60 14 	sts	0x1460, r1
    34c2:	10 92 61 14 	sts	0x1461, r1
    34c6:	10 92 62 14 	sts	0x1462, r1
    34ca:	10 92 b2 00 	sts	0x00B2, r1
void init_timer2(const uint8_t prescaler)
{
  TCCR2B = prescaler;
  TIMSK2 = _BV(TOIE2); // enable interrupts
  reset_timer2(); // reset counter
}
    34ce:	08 95       	ret

000034d0 <init_timer3>:
void init_timer3(const uint8_t prescaler)
{
  TCCR3B = prescaler;
    34d0:	80 93 91 00 	sts	0x0091, r24
  TIMSK3 = _BV(TOIE3); // enable interrupts
    34d4:	81 e0       	ldi	r24, 0x01	; 1
    34d6:	80 93 71 00 	sts	0x0071, r24
{
    TCNT2 = timer2_ovrflow_cnt = 0;
}
void reset_timer3(void)
{
    TCNT3 = timer3_ovrflow_cnt = 0;
    34da:	10 92 67 14 	sts	0x1467, r1
    34de:	10 92 68 14 	sts	0x1468, r1
    34e2:	10 92 69 14 	sts	0x1469, r1
    34e6:	10 92 6a 14 	sts	0x146A, r1
    34ea:	10 92 95 00 	sts	0x0095, r1
    34ee:	10 92 94 00 	sts	0x0094, r1
void init_timer3(const uint8_t prescaler)
{
  TCCR3B = prescaler;
  TIMSK3 = _BV(TOIE3); // enable interrupts
  reset_timer3(); // reset counter
}
    34f2:	08 95       	ret

000034f4 <init_timer4>:
void init_timer4(const uint8_t prescaler)
{
  TCCR4B = prescaler;
    34f4:	80 93 a1 00 	sts	0x00A1, r24
  TIMSK4 = _BV(TOIE4); // enable interrupts
    34f8:	81 e0       	ldi	r24, 0x01	; 1
    34fa:	80 93 72 00 	sts	0x0072, r24
{
    TCNT3 = timer3_ovrflow_cnt = 0;
}
void reset_timer4(void)
{
    TCNT4 = timer4_ovrflow_cnt = 0;
    34fe:	10 92 53 14 	sts	0x1453, r1
    3502:	10 92 54 14 	sts	0x1454, r1
    3506:	10 92 55 14 	sts	0x1455, r1
    350a:	10 92 56 14 	sts	0x1456, r1
    350e:	10 92 a5 00 	sts	0x00A5, r1
    3512:	10 92 a4 00 	sts	0x00A4, r1
void init_timer4(const uint8_t prescaler)
{
  TCCR4B = prescaler;
  TIMSK4 = _BV(TOIE4); // enable interrupts
  reset_timer4(); // reset counter
}
    3516:	08 95       	ret

00003518 <init_timer5>:
void init_timer5(const uint8_t prescaler)
{
  TCCR5B = prescaler;
    3518:	80 93 21 01 	sts	0x0121, r24
  TIMSK5 = _BV(TOIE5); // enable interrupts
    351c:	81 e0       	ldi	r24, 0x01	; 1
    351e:	80 93 73 00 	sts	0x0073, r24
{
    TCNT4 = timer4_ovrflow_cnt = 0;
}
void reset_timer5(void)
{
    TCNT5 = timer5_ovrflow_cnt = 0;
    3522:	10 92 6b 14 	sts	0x146B, r1
    3526:	10 92 6c 14 	sts	0x146C, r1
    352a:	10 92 6d 14 	sts	0x146D, r1
    352e:	10 92 6e 14 	sts	0x146E, r1
    3532:	10 92 25 01 	sts	0x0125, r1
    3536:	10 92 24 01 	sts	0x0124, r1
void init_timer5(const uint8_t prescaler)
{
  TCCR5B = prescaler;
  TIMSK5 = _BV(TOIE5); // enable interrupts
  reset_timer5(); // reset counter
}
    353a:	08 95       	ret

0000353c <timer_attach>:

void timer_attach(TimerInterrupt_t interrupt, void (*user_func)(void) )
{
  // set the interrupt function to run
  // the supplied user's function
  TimerIntFunc[interrupt] = user_func;
    353c:	e8 2f       	mov	r30, r24
    353e:	f0 e0       	ldi	r31, 0x00	; 0
    3540:	ee 0f       	add	r30, r30
    3542:	ff 1f       	adc	r31, r31
    3544:	ec 58       	subi	r30, 0x8C	; 140
    3546:	f0 4f       	sbci	r31, 0xF0	; 240
    3548:	71 83       	std	Z+1, r23	; 0x01
    354a:	60 83       	st	Z, r22
}
    354c:	08 95       	ret

0000354e <timer_detach>:

void timer_detach(TimerInterrupt_t interrupt)
{
  // clear the user defined interrupt function
  TimerIntFunc[interrupt] = NULL;
    354e:	e8 2f       	mov	r30, r24
    3550:	f0 e0       	ldi	r31, 0x00	; 0
    3552:	ee 0f       	add	r30, r30
    3554:	ff 1f       	adc	r31, r31
    3556:	ec 58       	subi	r30, 0x8C	; 140
    3558:	f0 4f       	sbci	r31, 0xF0	; 240
    355a:	11 82       	std	Z+1, r1	; 0x01
    355c:	10 82       	st	Z, r1
}
    355e:	08 95       	ret

00003560 <_delay_loop_2>:

void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3560:	01 97       	sbiw	r24, 0x01	; 1
    3562:	f1 f7       	brne	.-4      	; 0x3560 <_delay_loop_2>
		"1: sbiw %0,1" "\n\t"
		"brne 1b"
		: "=w" (__count)
		: "0" (__count)
	);
}
    3564:	08 95       	ret

00003566 <sleep>:

void sleep(uint16_t time_ms)
{
    3566:	af 92       	push	r10
    3568:	bf 92       	push	r11
    356a:	cf 92       	push	r12
    356c:	df 92       	push	r13
    356e:	ef 92       	push	r14
    3570:	ff 92       	push	r15
    3572:	0f 93       	push	r16
    3574:	1f 93       	push	r17
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * time_ms;
    3576:	a0 e0       	ldi	r26, 0x00	; 0
    3578:	b0 e0       	ldi	r27, 0x00	; 0
    357a:	bc 01       	movw	r22, r24
    357c:	cd 01       	movw	r24, r26
    357e:	0e 94 57 2c 	call	0x58ae	; 0x58ae <__floatunsisf>
    3582:	5b 01       	movw	r10, r22
    3584:	6c 01       	movw	r12, r24
    3586:	20 e0       	ldi	r18, 0x00	; 0
    3588:	30 e0       	ldi	r19, 0x00	; 0
    358a:	4a e7       	ldi	r20, 0x7A	; 122
    358c:	55 e4       	ldi	r21, 0x45	; 69
    358e:	0e 94 8e 2d 	call	0x5b1c	; 0x5b1c <__mulsf3>
    3592:	7b 01       	movw	r14, r22
    3594:	8c 01       	movw	r16, r24
	if (__tmp < 1.0)
    3596:	20 e0       	ldi	r18, 0x00	; 0
    3598:	30 e0       	ldi	r19, 0x00	; 0
    359a:	40 e8       	ldi	r20, 0x80	; 128
    359c:	5f e3       	ldi	r21, 0x3F	; 63
    359e:	0e 94 ba 2b 	call	0x5774	; 0x5774 <__cmpsf2>
    35a2:	88 23       	and	r24, r24
    35a4:	1c f4       	brge	.+6      	; 0x35ac <sleep+0x46>
    35a6:	61 e0       	ldi	r22, 0x01	; 1
    35a8:	70 e0       	ldi	r23, 0x00	; 0
    35aa:	24 c0       	rjmp	.+72     	; 0x35f4 <sleep+0x8e>
		__ticks = 1;
	else if (__tmp > 65535)
    35ac:	c8 01       	movw	r24, r16
    35ae:	b7 01       	movw	r22, r14
    35b0:	20 e0       	ldi	r18, 0x00	; 0
    35b2:	3f ef       	ldi	r19, 0xFF	; 255
    35b4:	4f e7       	ldi	r20, 0x7F	; 127
    35b6:	57 e4       	ldi	r21, 0x47	; 71
    35b8:	0e 94 83 2d 	call	0x5b06	; 0x5b06 <__gesf2>
    35bc:	18 16       	cp	r1, r24
    35be:	b4 f4       	brge	.+44     	; 0x35ec <sleep+0x86>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (time_ms * 10.0);
    35c0:	c6 01       	movw	r24, r12
    35c2:	b5 01       	movw	r22, r10
    35c4:	20 e0       	ldi	r18, 0x00	; 0
    35c6:	30 e0       	ldi	r19, 0x00	; 0
    35c8:	40 e2       	ldi	r20, 0x20	; 32
    35ca:	51 e4       	ldi	r21, 0x41	; 65
    35cc:	0e 94 8e 2d 	call	0x5b1c	; 0x5b1c <__mulsf3>
    35d0:	0e 94 2b 2c 	call	0x5856	; 0x5856 <__fixunssfsi>
}

void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    35d4:	80 e9       	ldi	r24, 0x90	; 144
    35d6:	91 e0       	ldi	r25, 0x01	; 1
    35d8:	05 c0       	rjmp	.+10     	; 0x35e4 <sleep+0x7e>
    35da:	fc 01       	movw	r30, r24
    35dc:	31 97       	sbiw	r30, 0x01	; 1
    35de:	f1 f7       	brne	.-4      	; 0x35dc <sleep+0x76>
		__ticks = (uint16_t) (time_ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    35e0:	61 50       	subi	r22, 0x01	; 1
    35e2:	70 40       	sbci	r23, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (time_ms * 10.0);
		while(__ticks)
    35e4:	61 15       	cp	r22, r1
    35e6:	71 05       	cpc	r23, r1
    35e8:	c1 f7       	brne	.-16     	; 0x35da <sleep+0x74>
    35ea:	07 c0       	rjmp	.+14     	; 0x35fa <sleep+0x94>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    35ec:	c8 01       	movw	r24, r16
    35ee:	b7 01       	movw	r22, r14
    35f0:	0e 94 2b 2c 	call	0x5856	; 0x5856 <__fixunssfsi>
}

void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    35f4:	cb 01       	movw	r24, r22
    35f6:	01 97       	sbiw	r24, 0x01	; 1
    35f8:	f1 f7       	brne	.-4      	; 0x35f6 <sleep+0x90>
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
	_delay_loop_2(__ticks);
}
    35fa:	1f 91       	pop	r17
    35fc:	0f 91       	pop	r16
    35fe:	ff 90       	pop	r15
    3600:	ef 90       	pop	r14
    3602:	df 90       	pop	r13
    3604:	cf 90       	pop	r12
    3606:	bf 90       	pop	r11
    3608:	af 90       	pop	r10
    360a:	08 95       	ret

0000360c <__vector_23>:
    }
  }
}*/

ISR(TIMER0_OVF_vect) 
{
    360c:	1f 92       	push	r1
    360e:	0f 92       	push	r0
    3610:	0f b6       	in	r0, 0x3f	; 63
    3612:	0f 92       	push	r0
    3614:	11 24       	eor	r1, r1
    3616:	2f 93       	push	r18
    3618:	3f 93       	push	r19
    361a:	4f 93       	push	r20
    361c:	5f 93       	push	r21
    361e:	6f 93       	push	r22
    3620:	7f 93       	push	r23
    3622:	8f 93       	push	r24
    3624:	9f 93       	push	r25
    3626:	af 93       	push	r26
    3628:	bf 93       	push	r27
    362a:	ef 93       	push	r30
    362c:	ff 93       	push	r31
  timer0_ovrflow_cnt++;
    362e:	80 91 5b 14 	lds	r24, 0x145B
    3632:	90 91 5c 14 	lds	r25, 0x145C
    3636:	a0 91 5d 14 	lds	r26, 0x145D
    363a:	b0 91 5e 14 	lds	r27, 0x145E
    363e:	01 96       	adiw	r24, 0x01	; 1
    3640:	a1 1d       	adc	r26, r1
    3642:	b1 1d       	adc	r27, r1
    3644:	80 93 5b 14 	sts	0x145B, r24
    3648:	90 93 5c 14 	sts	0x145C, r25
    364c:	a0 93 5d 14 	sts	0x145D, r26
    3650:	b0 93 5e 14 	sts	0x145E, r27
  timer_sleep_cnt++;
    3654:	80 91 63 14 	lds	r24, 0x1463
    3658:	90 91 64 14 	lds	r25, 0x1464
    365c:	a0 91 65 14 	lds	r26, 0x1465
    3660:	b0 91 66 14 	lds	r27, 0x1466
    3664:	01 96       	adiw	r24, 0x01	; 1
    3666:	a1 1d       	adc	r26, r1
    3668:	b1 1d       	adc	r27, r1
    366a:	80 93 63 14 	sts	0x1463, r24
    366e:	90 93 64 14 	sts	0x1464, r25
    3672:	a0 93 65 14 	sts	0x1465, r26
    3676:	b0 93 66 14 	sts	0x1466, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER0_OVF_interrupt);
    367a:	80 91 78 0f 	lds	r24, 0x0F78
    367e:	90 91 79 0f 	lds	r25, 0x0F79
    3682:	89 2b       	or	r24, r25
    3684:	29 f0       	breq	.+10     	; 0x3690 <__vector_23+0x84>
    3686:	e0 91 78 0f 	lds	r30, 0x0F78
    368a:	f0 91 79 0f 	lds	r31, 0x0F79
    368e:	09 95       	icall
}
    3690:	ff 91       	pop	r31
    3692:	ef 91       	pop	r30
    3694:	bf 91       	pop	r27
    3696:	af 91       	pop	r26
    3698:	9f 91       	pop	r25
    369a:	8f 91       	pop	r24
    369c:	7f 91       	pop	r23
    369e:	6f 91       	pop	r22
    36a0:	5f 91       	pop	r21
    36a2:	4f 91       	pop	r20
    36a4:	3f 91       	pop	r19
    36a6:	2f 91       	pop	r18
    36a8:	0f 90       	pop	r0
    36aa:	0f be       	out	0x3f, r0	; 63
    36ac:	0f 90       	pop	r0
    36ae:	1f 90       	pop	r1
    36b0:	18 95       	reti

000036b2 <__vector_20>:
ISR(TIMER1_OVF_vect) 
{
    36b2:	1f 92       	push	r1
    36b4:	0f 92       	push	r0
    36b6:	0f b6       	in	r0, 0x3f	; 63
    36b8:	0f 92       	push	r0
    36ba:	11 24       	eor	r1, r1
    36bc:	2f 93       	push	r18
    36be:	3f 93       	push	r19
    36c0:	4f 93       	push	r20
    36c2:	5f 93       	push	r21
    36c4:	6f 93       	push	r22
    36c6:	7f 93       	push	r23
    36c8:	8f 93       	push	r24
    36ca:	9f 93       	push	r25
    36cc:	af 93       	push	r26
    36ce:	bf 93       	push	r27
    36d0:	ef 93       	push	r30
    36d2:	ff 93       	push	r31
  timer1_ovrflow_cnt++;
    36d4:	80 91 57 14 	lds	r24, 0x1457
    36d8:	90 91 58 14 	lds	r25, 0x1458
    36dc:	a0 91 59 14 	lds	r26, 0x1459
    36e0:	b0 91 5a 14 	lds	r27, 0x145A
    36e4:	01 96       	adiw	r24, 0x01	; 1
    36e6:	a1 1d       	adc	r26, r1
    36e8:	b1 1d       	adc	r27, r1
    36ea:	80 93 57 14 	sts	0x1457, r24
    36ee:	90 93 58 14 	sts	0x1458, r25
    36f2:	a0 93 59 14 	sts	0x1459, r26
    36f6:	b0 93 5a 14 	sts	0x145A, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER1_OVF_interrupt);
    36fa:	80 91 82 0f 	lds	r24, 0x0F82
    36fe:	90 91 83 0f 	lds	r25, 0x0F83
    3702:	89 2b       	or	r24, r25
    3704:	29 f0       	breq	.+10     	; 0x3710 <__vector_20+0x5e>
    3706:	e0 91 82 0f 	lds	r30, 0x0F82
    370a:	f0 91 83 0f 	lds	r31, 0x0F83
    370e:	09 95       	icall
}
    3710:	ff 91       	pop	r31
    3712:	ef 91       	pop	r30
    3714:	bf 91       	pop	r27
    3716:	af 91       	pop	r26
    3718:	9f 91       	pop	r25
    371a:	8f 91       	pop	r24
    371c:	7f 91       	pop	r23
    371e:	6f 91       	pop	r22
    3720:	5f 91       	pop	r21
    3722:	4f 91       	pop	r20
    3724:	3f 91       	pop	r19
    3726:	2f 91       	pop	r18
    3728:	0f 90       	pop	r0
    372a:	0f be       	out	0x3f, r0	; 63
    372c:	0f 90       	pop	r0
    372e:	1f 90       	pop	r1
    3730:	18 95       	reti

00003732 <__vector_15>:
ISR(TIMER2_OVF_vect) 
{
    3732:	1f 92       	push	r1
    3734:	0f 92       	push	r0
    3736:	0f b6       	in	r0, 0x3f	; 63
    3738:	0f 92       	push	r0
    373a:	11 24       	eor	r1, r1
    373c:	2f 93       	push	r18
    373e:	3f 93       	push	r19
    3740:	4f 93       	push	r20
    3742:	5f 93       	push	r21
    3744:	6f 93       	push	r22
    3746:	7f 93       	push	r23
    3748:	8f 93       	push	r24
    374a:	9f 93       	push	r25
    374c:	af 93       	push	r26
    374e:	bf 93       	push	r27
    3750:	ef 93       	push	r30
    3752:	ff 93       	push	r31
  timer2_ovrflow_cnt++;
    3754:	80 91 5f 14 	lds	r24, 0x145F
    3758:	90 91 60 14 	lds	r25, 0x1460
    375c:	a0 91 61 14 	lds	r26, 0x1461
    3760:	b0 91 62 14 	lds	r27, 0x1462
    3764:	01 96       	adiw	r24, 0x01	; 1
    3766:	a1 1d       	adc	r26, r1
    3768:	b1 1d       	adc	r27, r1
    376a:	80 93 5f 14 	sts	0x145F, r24
    376e:	90 93 60 14 	sts	0x1460, r25
    3772:	a0 93 61 14 	sts	0x1461, r26
    3776:	b0 93 62 14 	sts	0x1462, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER2_OVF_interrupt);
    377a:	80 91 88 0f 	lds	r24, 0x0F88
    377e:	90 91 89 0f 	lds	r25, 0x0F89
    3782:	89 2b       	or	r24, r25
    3784:	29 f0       	breq	.+10     	; 0x3790 <__vector_15+0x5e>
    3786:	e0 91 88 0f 	lds	r30, 0x0F88
    378a:	f0 91 89 0f 	lds	r31, 0x0F89
    378e:	09 95       	icall
}
    3790:	ff 91       	pop	r31
    3792:	ef 91       	pop	r30
    3794:	bf 91       	pop	r27
    3796:	af 91       	pop	r26
    3798:	9f 91       	pop	r25
    379a:	8f 91       	pop	r24
    379c:	7f 91       	pop	r23
    379e:	6f 91       	pop	r22
    37a0:	5f 91       	pop	r21
    37a2:	4f 91       	pop	r20
    37a4:	3f 91       	pop	r19
    37a6:	2f 91       	pop	r18
    37a8:	0f 90       	pop	r0
    37aa:	0f be       	out	0x3f, r0	; 63
    37ac:	0f 90       	pop	r0
    37ae:	1f 90       	pop	r1
    37b0:	18 95       	reti

000037b2 <__vector_35>:
ISR(TIMER3_OVF_vect) 
{
    37b2:	1f 92       	push	r1
    37b4:	0f 92       	push	r0
    37b6:	0f b6       	in	r0, 0x3f	; 63
    37b8:	0f 92       	push	r0
    37ba:	11 24       	eor	r1, r1
    37bc:	2f 93       	push	r18
    37be:	3f 93       	push	r19
    37c0:	4f 93       	push	r20
    37c2:	5f 93       	push	r21
    37c4:	6f 93       	push	r22
    37c6:	7f 93       	push	r23
    37c8:	8f 93       	push	r24
    37ca:	9f 93       	push	r25
    37cc:	af 93       	push	r26
    37ce:	bf 93       	push	r27
    37d0:	ef 93       	push	r30
    37d2:	ff 93       	push	r31
  timer3_ovrflow_cnt++;
    37d4:	80 91 67 14 	lds	r24, 0x1467
    37d8:	90 91 68 14 	lds	r25, 0x1468
    37dc:	a0 91 69 14 	lds	r26, 0x1469
    37e0:	b0 91 6a 14 	lds	r27, 0x146A
    37e4:	01 96       	adiw	r24, 0x01	; 1
    37e6:	a1 1d       	adc	r26, r1
    37e8:	b1 1d       	adc	r27, r1
    37ea:	80 93 67 14 	sts	0x1467, r24
    37ee:	90 93 68 14 	sts	0x1468, r25
    37f2:	a0 93 69 14 	sts	0x1469, r26
    37f6:	b0 93 6a 14 	sts	0x146A, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER3_OVF_interrupt);
    37fa:	80 91 92 0f 	lds	r24, 0x0F92
    37fe:	90 91 93 0f 	lds	r25, 0x0F93
    3802:	89 2b       	or	r24, r25
    3804:	29 f0       	breq	.+10     	; 0x3810 <__vector_35+0x5e>
    3806:	e0 91 92 0f 	lds	r30, 0x0F92
    380a:	f0 91 93 0f 	lds	r31, 0x0F93
    380e:	09 95       	icall
}
    3810:	ff 91       	pop	r31
    3812:	ef 91       	pop	r30
    3814:	bf 91       	pop	r27
    3816:	af 91       	pop	r26
    3818:	9f 91       	pop	r25
    381a:	8f 91       	pop	r24
    381c:	7f 91       	pop	r23
    381e:	6f 91       	pop	r22
    3820:	5f 91       	pop	r21
    3822:	4f 91       	pop	r20
    3824:	3f 91       	pop	r19
    3826:	2f 91       	pop	r18
    3828:	0f 90       	pop	r0
    382a:	0f be       	out	0x3f, r0	; 63
    382c:	0f 90       	pop	r0
    382e:	1f 90       	pop	r1
    3830:	18 95       	reti

00003832 <__vector_45>:
ISR(TIMER4_OVF_vect) 
{
    3832:	1f 92       	push	r1
    3834:	0f 92       	push	r0
    3836:	0f b6       	in	r0, 0x3f	; 63
    3838:	0f 92       	push	r0
    383a:	11 24       	eor	r1, r1
    383c:	2f 93       	push	r18
    383e:	3f 93       	push	r19
    3840:	4f 93       	push	r20
    3842:	5f 93       	push	r21
    3844:	6f 93       	push	r22
    3846:	7f 93       	push	r23
    3848:	8f 93       	push	r24
    384a:	9f 93       	push	r25
    384c:	af 93       	push	r26
    384e:	bf 93       	push	r27
    3850:	ef 93       	push	r30
    3852:	ff 93       	push	r31
  timer4_ovrflow_cnt++;
    3854:	80 91 53 14 	lds	r24, 0x1453
    3858:	90 91 54 14 	lds	r25, 0x1454
    385c:	a0 91 55 14 	lds	r26, 0x1455
    3860:	b0 91 56 14 	lds	r27, 0x1456
    3864:	01 96       	adiw	r24, 0x01	; 1
    3866:	a1 1d       	adc	r26, r1
    3868:	b1 1d       	adc	r27, r1
    386a:	80 93 53 14 	sts	0x1453, r24
    386e:	90 93 54 14 	sts	0x1454, r25
    3872:	a0 93 55 14 	sts	0x1455, r26
    3876:	b0 93 56 14 	sts	0x1456, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER4_OVF_interrupt);
    387a:	80 91 9c 0f 	lds	r24, 0x0F9C
    387e:	90 91 9d 0f 	lds	r25, 0x0F9D
    3882:	89 2b       	or	r24, r25
    3884:	29 f0       	breq	.+10     	; 0x3890 <__vector_45+0x5e>
    3886:	e0 91 9c 0f 	lds	r30, 0x0F9C
    388a:	f0 91 9d 0f 	lds	r31, 0x0F9D
    388e:	09 95       	icall
}
    3890:	ff 91       	pop	r31
    3892:	ef 91       	pop	r30
    3894:	bf 91       	pop	r27
    3896:	af 91       	pop	r26
    3898:	9f 91       	pop	r25
    389a:	8f 91       	pop	r24
    389c:	7f 91       	pop	r23
    389e:	6f 91       	pop	r22
    38a0:	5f 91       	pop	r21
    38a2:	4f 91       	pop	r20
    38a4:	3f 91       	pop	r19
    38a6:	2f 91       	pop	r18
    38a8:	0f 90       	pop	r0
    38aa:	0f be       	out	0x3f, r0	; 63
    38ac:	0f 90       	pop	r0
    38ae:	1f 90       	pop	r1
    38b0:	18 95       	reti

000038b2 <__vector_50>:
ISR(TIMER5_OVF_vect) 
{
    38b2:	1f 92       	push	r1
    38b4:	0f 92       	push	r0
    38b6:	0f b6       	in	r0, 0x3f	; 63
    38b8:	0f 92       	push	r0
    38ba:	11 24       	eor	r1, r1
    38bc:	2f 93       	push	r18
    38be:	3f 93       	push	r19
    38c0:	4f 93       	push	r20
    38c2:	5f 93       	push	r21
    38c4:	6f 93       	push	r22
    38c6:	7f 93       	push	r23
    38c8:	8f 93       	push	r24
    38ca:	9f 93       	push	r25
    38cc:	af 93       	push	r26
    38ce:	bf 93       	push	r27
    38d0:	ef 93       	push	r30
    38d2:	ff 93       	push	r31
  timer5_ovrflow_cnt++;
    38d4:	80 91 6b 14 	lds	r24, 0x146B
    38d8:	90 91 6c 14 	lds	r25, 0x146C
    38dc:	a0 91 6d 14 	lds	r26, 0x146D
    38e0:	b0 91 6e 14 	lds	r27, 0x146E
    38e4:	01 96       	adiw	r24, 0x01	; 1
    38e6:	a1 1d       	adc	r26, r1
    38e8:	b1 1d       	adc	r27, r1
    38ea:	80 93 6b 14 	sts	0x146B, r24
    38ee:	90 93 6c 14 	sts	0x146C, r25
    38f2:	a0 93 6d 14 	sts	0x146D, r26
    38f6:	b0 93 6e 14 	sts	0x146E, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER5_OVF_interrupt);
    38fa:	80 91 a6 0f 	lds	r24, 0x0FA6
    38fe:	90 91 a7 0f 	lds	r25, 0x0FA7
    3902:	89 2b       	or	r24, r25
    3904:	29 f0       	breq	.+10     	; 0x3910 <__vector_50+0x5e>
    3906:	e0 91 a6 0f 	lds	r30, 0x0FA6
    390a:	f0 91 a7 0f 	lds	r31, 0x0FA7
    390e:	09 95       	icall
}
    3910:	ff 91       	pop	r31
    3912:	ef 91       	pop	r30
    3914:	bf 91       	pop	r27
    3916:	af 91       	pop	r26
    3918:	9f 91       	pop	r25
    391a:	8f 91       	pop	r24
    391c:	7f 91       	pop	r23
    391e:	6f 91       	pop	r22
    3920:	5f 91       	pop	r21
    3922:	4f 91       	pop	r20
    3924:	3f 91       	pop	r19
    3926:	2f 91       	pop	r18
    3928:	0f 90       	pop	r0
    392a:	0f be       	out	0x3f, r0	; 63
    392c:	0f 90       	pop	r0
    392e:	1f 90       	pop	r1
    3930:	18 95       	reti

00003932 <__vector_21>:
ISR(TIMER0_COMPA_vect)
{
    3932:	1f 92       	push	r1
    3934:	0f 92       	push	r0
    3936:	0f b6       	in	r0, 0x3f	; 63
    3938:	0f 92       	push	r0
    393a:	11 24       	eor	r1, r1
    393c:	2f 93       	push	r18
    393e:	3f 93       	push	r19
    3940:	4f 93       	push	r20
    3942:	5f 93       	push	r21
    3944:	6f 93       	push	r22
    3946:	7f 93       	push	r23
    3948:	8f 93       	push	r24
    394a:	9f 93       	push	r25
    394c:	af 93       	push	r26
    394e:	bf 93       	push	r27
    3950:	ef 93       	push	r30
    3952:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER0_COMPA_interrupt);
    3954:	80 91 74 0f 	lds	r24, 0x0F74
    3958:	90 91 75 0f 	lds	r25, 0x0F75
    395c:	89 2b       	or	r24, r25
    395e:	29 f0       	breq	.+10     	; 0x396a <__vector_21+0x38>
    3960:	e0 91 74 0f 	lds	r30, 0x0F74
    3964:	f0 91 75 0f 	lds	r31, 0x0F75
    3968:	09 95       	icall
}
    396a:	ff 91       	pop	r31
    396c:	ef 91       	pop	r30
    396e:	bf 91       	pop	r27
    3970:	af 91       	pop	r26
    3972:	9f 91       	pop	r25
    3974:	8f 91       	pop	r24
    3976:	7f 91       	pop	r23
    3978:	6f 91       	pop	r22
    397a:	5f 91       	pop	r21
    397c:	4f 91       	pop	r20
    397e:	3f 91       	pop	r19
    3980:	2f 91       	pop	r18
    3982:	0f 90       	pop	r0
    3984:	0f be       	out	0x3f, r0	; 63
    3986:	0f 90       	pop	r0
    3988:	1f 90       	pop	r1
    398a:	18 95       	reti

0000398c <__vector_22>:
ISR(TIMER0_COMPB_vect)
{
    398c:	1f 92       	push	r1
    398e:	0f 92       	push	r0
    3990:	0f b6       	in	r0, 0x3f	; 63
    3992:	0f 92       	push	r0
    3994:	11 24       	eor	r1, r1
    3996:	2f 93       	push	r18
    3998:	3f 93       	push	r19
    399a:	4f 93       	push	r20
    399c:	5f 93       	push	r21
    399e:	6f 93       	push	r22
    39a0:	7f 93       	push	r23
    39a2:	8f 93       	push	r24
    39a4:	9f 93       	push	r25
    39a6:	af 93       	push	r26
    39a8:	bf 93       	push	r27
    39aa:	ef 93       	push	r30
    39ac:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER0_COMPB_interrupt);
    39ae:	80 91 76 0f 	lds	r24, 0x0F76
    39b2:	90 91 77 0f 	lds	r25, 0x0F77
    39b6:	89 2b       	or	r24, r25
    39b8:	29 f0       	breq	.+10     	; 0x39c4 <__vector_22+0x38>
    39ba:	e0 91 76 0f 	lds	r30, 0x0F76
    39be:	f0 91 77 0f 	lds	r31, 0x0F77
    39c2:	09 95       	icall
}
    39c4:	ff 91       	pop	r31
    39c6:	ef 91       	pop	r30
    39c8:	bf 91       	pop	r27
    39ca:	af 91       	pop	r26
    39cc:	9f 91       	pop	r25
    39ce:	8f 91       	pop	r24
    39d0:	7f 91       	pop	r23
    39d2:	6f 91       	pop	r22
    39d4:	5f 91       	pop	r21
    39d6:	4f 91       	pop	r20
    39d8:	3f 91       	pop	r19
    39da:	2f 91       	pop	r18
    39dc:	0f 90       	pop	r0
    39de:	0f be       	out	0x3f, r0	; 63
    39e0:	0f 90       	pop	r0
    39e2:	1f 90       	pop	r1
    39e4:	18 95       	reti

000039e6 <__vector_16>:
ISR(TIMER1_CAPT_vect)
{
    39e6:	1f 92       	push	r1
    39e8:	0f 92       	push	r0
    39ea:	0f b6       	in	r0, 0x3f	; 63
    39ec:	0f 92       	push	r0
    39ee:	11 24       	eor	r1, r1
    39f0:	2f 93       	push	r18
    39f2:	3f 93       	push	r19
    39f4:	4f 93       	push	r20
    39f6:	5f 93       	push	r21
    39f8:	6f 93       	push	r22
    39fa:	7f 93       	push	r23
    39fc:	8f 93       	push	r24
    39fe:	9f 93       	push	r25
    3a00:	af 93       	push	r26
    3a02:	bf 93       	push	r27
    3a04:	ef 93       	push	r30
    3a06:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER1_CAPT_interrupt);
    3a08:	80 91 7a 0f 	lds	r24, 0x0F7A
    3a0c:	90 91 7b 0f 	lds	r25, 0x0F7B
    3a10:	89 2b       	or	r24, r25
    3a12:	29 f0       	breq	.+10     	; 0x3a1e <__vector_16+0x38>
    3a14:	e0 91 7a 0f 	lds	r30, 0x0F7A
    3a18:	f0 91 7b 0f 	lds	r31, 0x0F7B
    3a1c:	09 95       	icall
}
    3a1e:	ff 91       	pop	r31
    3a20:	ef 91       	pop	r30
    3a22:	bf 91       	pop	r27
    3a24:	af 91       	pop	r26
    3a26:	9f 91       	pop	r25
    3a28:	8f 91       	pop	r24
    3a2a:	7f 91       	pop	r23
    3a2c:	6f 91       	pop	r22
    3a2e:	5f 91       	pop	r21
    3a30:	4f 91       	pop	r20
    3a32:	3f 91       	pop	r19
    3a34:	2f 91       	pop	r18
    3a36:	0f 90       	pop	r0
    3a38:	0f be       	out	0x3f, r0	; 63
    3a3a:	0f 90       	pop	r0
    3a3c:	1f 90       	pop	r1
    3a3e:	18 95       	reti

00003a40 <__vector_18>:
{
  RUN_USER_DEFINE_INTERRUPT(TIMER1_COMPA_interrupt);
}
*/
ISR(TIMER1_COMPB_vect)
{
    3a40:	1f 92       	push	r1
    3a42:	0f 92       	push	r0
    3a44:	0f b6       	in	r0, 0x3f	; 63
    3a46:	0f 92       	push	r0
    3a48:	11 24       	eor	r1, r1
    3a4a:	2f 93       	push	r18
    3a4c:	3f 93       	push	r19
    3a4e:	4f 93       	push	r20
    3a50:	5f 93       	push	r21
    3a52:	6f 93       	push	r22
    3a54:	7f 93       	push	r23
    3a56:	8f 93       	push	r24
    3a58:	9f 93       	push	r25
    3a5a:	af 93       	push	r26
    3a5c:	bf 93       	push	r27
    3a5e:	ef 93       	push	r30
    3a60:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER1_COMPB_interrupt);
    3a62:	80 91 7e 0f 	lds	r24, 0x0F7E
    3a66:	90 91 7f 0f 	lds	r25, 0x0F7F
    3a6a:	89 2b       	or	r24, r25
    3a6c:	29 f0       	breq	.+10     	; 0x3a78 <__vector_18+0x38>
    3a6e:	e0 91 7e 0f 	lds	r30, 0x0F7E
    3a72:	f0 91 7f 0f 	lds	r31, 0x0F7F
    3a76:	09 95       	icall
}
    3a78:	ff 91       	pop	r31
    3a7a:	ef 91       	pop	r30
    3a7c:	bf 91       	pop	r27
    3a7e:	af 91       	pop	r26
    3a80:	9f 91       	pop	r25
    3a82:	8f 91       	pop	r24
    3a84:	7f 91       	pop	r23
    3a86:	6f 91       	pop	r22
    3a88:	5f 91       	pop	r21
    3a8a:	4f 91       	pop	r20
    3a8c:	3f 91       	pop	r19
    3a8e:	2f 91       	pop	r18
    3a90:	0f 90       	pop	r0
    3a92:	0f be       	out	0x3f, r0	; 63
    3a94:	0f 90       	pop	r0
    3a96:	1f 90       	pop	r1
    3a98:	18 95       	reti

00003a9a <__vector_19>:
ISR(TIMER1_COMPC_vect)
{
    3a9a:	1f 92       	push	r1
    3a9c:	0f 92       	push	r0
    3a9e:	0f b6       	in	r0, 0x3f	; 63
    3aa0:	0f 92       	push	r0
    3aa2:	11 24       	eor	r1, r1
    3aa4:	2f 93       	push	r18
    3aa6:	3f 93       	push	r19
    3aa8:	4f 93       	push	r20
    3aaa:	5f 93       	push	r21
    3aac:	6f 93       	push	r22
    3aae:	7f 93       	push	r23
    3ab0:	8f 93       	push	r24
    3ab2:	9f 93       	push	r25
    3ab4:	af 93       	push	r26
    3ab6:	bf 93       	push	r27
    3ab8:	ef 93       	push	r30
    3aba:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER1_COMPC_interrupt);
    3abc:	80 91 80 0f 	lds	r24, 0x0F80
    3ac0:	90 91 81 0f 	lds	r25, 0x0F81
    3ac4:	89 2b       	or	r24, r25
    3ac6:	29 f0       	breq	.+10     	; 0x3ad2 <__vector_19+0x38>
    3ac8:	e0 91 80 0f 	lds	r30, 0x0F80
    3acc:	f0 91 81 0f 	lds	r31, 0x0F81
    3ad0:	09 95       	icall
}
    3ad2:	ff 91       	pop	r31
    3ad4:	ef 91       	pop	r30
    3ad6:	bf 91       	pop	r27
    3ad8:	af 91       	pop	r26
    3ada:	9f 91       	pop	r25
    3adc:	8f 91       	pop	r24
    3ade:	7f 91       	pop	r23
    3ae0:	6f 91       	pop	r22
    3ae2:	5f 91       	pop	r21
    3ae4:	4f 91       	pop	r20
    3ae6:	3f 91       	pop	r19
    3ae8:	2f 91       	pop	r18
    3aea:	0f 90       	pop	r0
    3aec:	0f be       	out	0x3f, r0	; 63
    3aee:	0f 90       	pop	r0
    3af0:	1f 90       	pop	r1
    3af2:	18 95       	reti

00003af4 <__vector_13>:
ISR(TIMER2_COMPA_vect)
{
    3af4:	1f 92       	push	r1
    3af6:	0f 92       	push	r0
    3af8:	0f b6       	in	r0, 0x3f	; 63
    3afa:	0f 92       	push	r0
    3afc:	11 24       	eor	r1, r1
    3afe:	2f 93       	push	r18
    3b00:	3f 93       	push	r19
    3b02:	4f 93       	push	r20
    3b04:	5f 93       	push	r21
    3b06:	6f 93       	push	r22
    3b08:	7f 93       	push	r23
    3b0a:	8f 93       	push	r24
    3b0c:	9f 93       	push	r25
    3b0e:	af 93       	push	r26
    3b10:	bf 93       	push	r27
    3b12:	ef 93       	push	r30
    3b14:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER2_COMPA_interrupt);
    3b16:	80 91 84 0f 	lds	r24, 0x0F84
    3b1a:	90 91 85 0f 	lds	r25, 0x0F85
    3b1e:	89 2b       	or	r24, r25
    3b20:	29 f0       	breq	.+10     	; 0x3b2c <__vector_13+0x38>
    3b22:	e0 91 84 0f 	lds	r30, 0x0F84
    3b26:	f0 91 85 0f 	lds	r31, 0x0F85
    3b2a:	09 95       	icall
}
    3b2c:	ff 91       	pop	r31
    3b2e:	ef 91       	pop	r30
    3b30:	bf 91       	pop	r27
    3b32:	af 91       	pop	r26
    3b34:	9f 91       	pop	r25
    3b36:	8f 91       	pop	r24
    3b38:	7f 91       	pop	r23
    3b3a:	6f 91       	pop	r22
    3b3c:	5f 91       	pop	r21
    3b3e:	4f 91       	pop	r20
    3b40:	3f 91       	pop	r19
    3b42:	2f 91       	pop	r18
    3b44:	0f 90       	pop	r0
    3b46:	0f be       	out	0x3f, r0	; 63
    3b48:	0f 90       	pop	r0
    3b4a:	1f 90       	pop	r1
    3b4c:	18 95       	reti

00003b4e <__vector_14>:
ISR(TIMER2_COMPB_vect)
{
    3b4e:	1f 92       	push	r1
    3b50:	0f 92       	push	r0
    3b52:	0f b6       	in	r0, 0x3f	; 63
    3b54:	0f 92       	push	r0
    3b56:	11 24       	eor	r1, r1
    3b58:	2f 93       	push	r18
    3b5a:	3f 93       	push	r19
    3b5c:	4f 93       	push	r20
    3b5e:	5f 93       	push	r21
    3b60:	6f 93       	push	r22
    3b62:	7f 93       	push	r23
    3b64:	8f 93       	push	r24
    3b66:	9f 93       	push	r25
    3b68:	af 93       	push	r26
    3b6a:	bf 93       	push	r27
    3b6c:	ef 93       	push	r30
    3b6e:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER2_COMPB_interrupt);
    3b70:	80 91 86 0f 	lds	r24, 0x0F86
    3b74:	90 91 87 0f 	lds	r25, 0x0F87
    3b78:	89 2b       	or	r24, r25
    3b7a:	29 f0       	breq	.+10     	; 0x3b86 <__vector_14+0x38>
    3b7c:	e0 91 86 0f 	lds	r30, 0x0F86
    3b80:	f0 91 87 0f 	lds	r31, 0x0F87
    3b84:	09 95       	icall
}
    3b86:	ff 91       	pop	r31
    3b88:	ef 91       	pop	r30
    3b8a:	bf 91       	pop	r27
    3b8c:	af 91       	pop	r26
    3b8e:	9f 91       	pop	r25
    3b90:	8f 91       	pop	r24
    3b92:	7f 91       	pop	r23
    3b94:	6f 91       	pop	r22
    3b96:	5f 91       	pop	r21
    3b98:	4f 91       	pop	r20
    3b9a:	3f 91       	pop	r19
    3b9c:	2f 91       	pop	r18
    3b9e:	0f 90       	pop	r0
    3ba0:	0f be       	out	0x3f, r0	; 63
    3ba2:	0f 90       	pop	r0
    3ba4:	1f 90       	pop	r1
    3ba6:	18 95       	reti

00003ba8 <__vector_31>:
ISR(TIMER3_CAPT_vect)
{
    3ba8:	1f 92       	push	r1
    3baa:	0f 92       	push	r0
    3bac:	0f b6       	in	r0, 0x3f	; 63
    3bae:	0f 92       	push	r0
    3bb0:	11 24       	eor	r1, r1
    3bb2:	2f 93       	push	r18
    3bb4:	3f 93       	push	r19
    3bb6:	4f 93       	push	r20
    3bb8:	5f 93       	push	r21
    3bba:	6f 93       	push	r22
    3bbc:	7f 93       	push	r23
    3bbe:	8f 93       	push	r24
    3bc0:	9f 93       	push	r25
    3bc2:	af 93       	push	r26
    3bc4:	bf 93       	push	r27
    3bc6:	ef 93       	push	r30
    3bc8:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_CAPT_interrupt);
    3bca:	80 91 8a 0f 	lds	r24, 0x0F8A
    3bce:	90 91 8b 0f 	lds	r25, 0x0F8B
    3bd2:	89 2b       	or	r24, r25
    3bd4:	29 f0       	breq	.+10     	; 0x3be0 <__vector_31+0x38>
    3bd6:	e0 91 8a 0f 	lds	r30, 0x0F8A
    3bda:	f0 91 8b 0f 	lds	r31, 0x0F8B
    3bde:	09 95       	icall
}
    3be0:	ff 91       	pop	r31
    3be2:	ef 91       	pop	r30
    3be4:	bf 91       	pop	r27
    3be6:	af 91       	pop	r26
    3be8:	9f 91       	pop	r25
    3bea:	8f 91       	pop	r24
    3bec:	7f 91       	pop	r23
    3bee:	6f 91       	pop	r22
    3bf0:	5f 91       	pop	r21
    3bf2:	4f 91       	pop	r20
    3bf4:	3f 91       	pop	r19
    3bf6:	2f 91       	pop	r18
    3bf8:	0f 90       	pop	r0
    3bfa:	0f be       	out	0x3f, r0	; 63
    3bfc:	0f 90       	pop	r0
    3bfe:	1f 90       	pop	r1
    3c00:	18 95       	reti

00003c02 <__vector_32>:
ISR(TIMER3_COMPA_vect)
{
    3c02:	1f 92       	push	r1
    3c04:	0f 92       	push	r0
    3c06:	0f b6       	in	r0, 0x3f	; 63
    3c08:	0f 92       	push	r0
    3c0a:	11 24       	eor	r1, r1
    3c0c:	2f 93       	push	r18
    3c0e:	3f 93       	push	r19
    3c10:	4f 93       	push	r20
    3c12:	5f 93       	push	r21
    3c14:	6f 93       	push	r22
    3c16:	7f 93       	push	r23
    3c18:	8f 93       	push	r24
    3c1a:	9f 93       	push	r25
    3c1c:	af 93       	push	r26
    3c1e:	bf 93       	push	r27
    3c20:	ef 93       	push	r30
    3c22:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_COMPA_interrupt);
    3c24:	80 91 8c 0f 	lds	r24, 0x0F8C
    3c28:	90 91 8d 0f 	lds	r25, 0x0F8D
    3c2c:	89 2b       	or	r24, r25
    3c2e:	29 f0       	breq	.+10     	; 0x3c3a <__vector_32+0x38>
    3c30:	e0 91 8c 0f 	lds	r30, 0x0F8C
    3c34:	f0 91 8d 0f 	lds	r31, 0x0F8D
    3c38:	09 95       	icall
}
    3c3a:	ff 91       	pop	r31
    3c3c:	ef 91       	pop	r30
    3c3e:	bf 91       	pop	r27
    3c40:	af 91       	pop	r26
    3c42:	9f 91       	pop	r25
    3c44:	8f 91       	pop	r24
    3c46:	7f 91       	pop	r23
    3c48:	6f 91       	pop	r22
    3c4a:	5f 91       	pop	r21
    3c4c:	4f 91       	pop	r20
    3c4e:	3f 91       	pop	r19
    3c50:	2f 91       	pop	r18
    3c52:	0f 90       	pop	r0
    3c54:	0f be       	out	0x3f, r0	; 63
    3c56:	0f 90       	pop	r0
    3c58:	1f 90       	pop	r1
    3c5a:	18 95       	reti

00003c5c <__vector_33>:
ISR(TIMER3_COMPB_vect)
{
    3c5c:	1f 92       	push	r1
    3c5e:	0f 92       	push	r0
    3c60:	0f b6       	in	r0, 0x3f	; 63
    3c62:	0f 92       	push	r0
    3c64:	11 24       	eor	r1, r1
    3c66:	2f 93       	push	r18
    3c68:	3f 93       	push	r19
    3c6a:	4f 93       	push	r20
    3c6c:	5f 93       	push	r21
    3c6e:	6f 93       	push	r22
    3c70:	7f 93       	push	r23
    3c72:	8f 93       	push	r24
    3c74:	9f 93       	push	r25
    3c76:	af 93       	push	r26
    3c78:	bf 93       	push	r27
    3c7a:	ef 93       	push	r30
    3c7c:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_COMPB_interrupt);
    3c7e:	80 91 8e 0f 	lds	r24, 0x0F8E
    3c82:	90 91 8f 0f 	lds	r25, 0x0F8F
    3c86:	89 2b       	or	r24, r25
    3c88:	29 f0       	breq	.+10     	; 0x3c94 <__vector_33+0x38>
    3c8a:	e0 91 8e 0f 	lds	r30, 0x0F8E
    3c8e:	f0 91 8f 0f 	lds	r31, 0x0F8F
    3c92:	09 95       	icall
}
    3c94:	ff 91       	pop	r31
    3c96:	ef 91       	pop	r30
    3c98:	bf 91       	pop	r27
    3c9a:	af 91       	pop	r26
    3c9c:	9f 91       	pop	r25
    3c9e:	8f 91       	pop	r24
    3ca0:	7f 91       	pop	r23
    3ca2:	6f 91       	pop	r22
    3ca4:	5f 91       	pop	r21
    3ca6:	4f 91       	pop	r20
    3ca8:	3f 91       	pop	r19
    3caa:	2f 91       	pop	r18
    3cac:	0f 90       	pop	r0
    3cae:	0f be       	out	0x3f, r0	; 63
    3cb0:	0f 90       	pop	r0
    3cb2:	1f 90       	pop	r1
    3cb4:	18 95       	reti

00003cb6 <__vector_34>:
ISR(TIMER3_COMPC_vect)
{
    3cb6:	1f 92       	push	r1
    3cb8:	0f 92       	push	r0
    3cba:	0f b6       	in	r0, 0x3f	; 63
    3cbc:	0f 92       	push	r0
    3cbe:	11 24       	eor	r1, r1
    3cc0:	2f 93       	push	r18
    3cc2:	3f 93       	push	r19
    3cc4:	4f 93       	push	r20
    3cc6:	5f 93       	push	r21
    3cc8:	6f 93       	push	r22
    3cca:	7f 93       	push	r23
    3ccc:	8f 93       	push	r24
    3cce:	9f 93       	push	r25
    3cd0:	af 93       	push	r26
    3cd2:	bf 93       	push	r27
    3cd4:	ef 93       	push	r30
    3cd6:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_COMPC_interrupt);
    3cd8:	80 91 90 0f 	lds	r24, 0x0F90
    3cdc:	90 91 91 0f 	lds	r25, 0x0F91
    3ce0:	89 2b       	or	r24, r25
    3ce2:	29 f0       	breq	.+10     	; 0x3cee <__vector_34+0x38>
    3ce4:	e0 91 90 0f 	lds	r30, 0x0F90
    3ce8:	f0 91 91 0f 	lds	r31, 0x0F91
    3cec:	09 95       	icall
}
    3cee:	ff 91       	pop	r31
    3cf0:	ef 91       	pop	r30
    3cf2:	bf 91       	pop	r27
    3cf4:	af 91       	pop	r26
    3cf6:	9f 91       	pop	r25
    3cf8:	8f 91       	pop	r24
    3cfa:	7f 91       	pop	r23
    3cfc:	6f 91       	pop	r22
    3cfe:	5f 91       	pop	r21
    3d00:	4f 91       	pop	r20
    3d02:	3f 91       	pop	r19
    3d04:	2f 91       	pop	r18
    3d06:	0f 90       	pop	r0
    3d08:	0f be       	out	0x3f, r0	; 63
    3d0a:	0f 90       	pop	r0
    3d0c:	1f 90       	pop	r1
    3d0e:	18 95       	reti

00003d10 <__vector_41>:
ISR(TIMER4_CAPT_vect)
{
    3d10:	1f 92       	push	r1
    3d12:	0f 92       	push	r0
    3d14:	0f b6       	in	r0, 0x3f	; 63
    3d16:	0f 92       	push	r0
    3d18:	11 24       	eor	r1, r1
    3d1a:	2f 93       	push	r18
    3d1c:	3f 93       	push	r19
    3d1e:	4f 93       	push	r20
    3d20:	5f 93       	push	r21
    3d22:	6f 93       	push	r22
    3d24:	7f 93       	push	r23
    3d26:	8f 93       	push	r24
    3d28:	9f 93       	push	r25
    3d2a:	af 93       	push	r26
    3d2c:	bf 93       	push	r27
    3d2e:	ef 93       	push	r30
    3d30:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_CAPT_interrupt);
    3d32:	80 91 94 0f 	lds	r24, 0x0F94
    3d36:	90 91 95 0f 	lds	r25, 0x0F95
    3d3a:	89 2b       	or	r24, r25
    3d3c:	29 f0       	breq	.+10     	; 0x3d48 <__vector_41+0x38>
    3d3e:	e0 91 94 0f 	lds	r30, 0x0F94
    3d42:	f0 91 95 0f 	lds	r31, 0x0F95
    3d46:	09 95       	icall
}
    3d48:	ff 91       	pop	r31
    3d4a:	ef 91       	pop	r30
    3d4c:	bf 91       	pop	r27
    3d4e:	af 91       	pop	r26
    3d50:	9f 91       	pop	r25
    3d52:	8f 91       	pop	r24
    3d54:	7f 91       	pop	r23
    3d56:	6f 91       	pop	r22
    3d58:	5f 91       	pop	r21
    3d5a:	4f 91       	pop	r20
    3d5c:	3f 91       	pop	r19
    3d5e:	2f 91       	pop	r18
    3d60:	0f 90       	pop	r0
    3d62:	0f be       	out	0x3f, r0	; 63
    3d64:	0f 90       	pop	r0
    3d66:	1f 90       	pop	r1
    3d68:	18 95       	reti

00003d6a <__vector_42>:
ISR(TIMER4_COMPA_vect)
{
    3d6a:	1f 92       	push	r1
    3d6c:	0f 92       	push	r0
    3d6e:	0f b6       	in	r0, 0x3f	; 63
    3d70:	0f 92       	push	r0
    3d72:	11 24       	eor	r1, r1
    3d74:	2f 93       	push	r18
    3d76:	3f 93       	push	r19
    3d78:	4f 93       	push	r20
    3d7a:	5f 93       	push	r21
    3d7c:	6f 93       	push	r22
    3d7e:	7f 93       	push	r23
    3d80:	8f 93       	push	r24
    3d82:	9f 93       	push	r25
    3d84:	af 93       	push	r26
    3d86:	bf 93       	push	r27
    3d88:	ef 93       	push	r30
    3d8a:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_COMPA_interrupt);
    3d8c:	80 91 96 0f 	lds	r24, 0x0F96
    3d90:	90 91 97 0f 	lds	r25, 0x0F97
    3d94:	89 2b       	or	r24, r25
    3d96:	29 f0       	breq	.+10     	; 0x3da2 <__vector_42+0x38>
    3d98:	e0 91 96 0f 	lds	r30, 0x0F96
    3d9c:	f0 91 97 0f 	lds	r31, 0x0F97
    3da0:	09 95       	icall
}
    3da2:	ff 91       	pop	r31
    3da4:	ef 91       	pop	r30
    3da6:	bf 91       	pop	r27
    3da8:	af 91       	pop	r26
    3daa:	9f 91       	pop	r25
    3dac:	8f 91       	pop	r24
    3dae:	7f 91       	pop	r23
    3db0:	6f 91       	pop	r22
    3db2:	5f 91       	pop	r21
    3db4:	4f 91       	pop	r20
    3db6:	3f 91       	pop	r19
    3db8:	2f 91       	pop	r18
    3dba:	0f 90       	pop	r0
    3dbc:	0f be       	out	0x3f, r0	; 63
    3dbe:	0f 90       	pop	r0
    3dc0:	1f 90       	pop	r1
    3dc2:	18 95       	reti

00003dc4 <__vector_43>:
ISR(TIMER4_COMPB_vect)
{
    3dc4:	1f 92       	push	r1
    3dc6:	0f 92       	push	r0
    3dc8:	0f b6       	in	r0, 0x3f	; 63
    3dca:	0f 92       	push	r0
    3dcc:	11 24       	eor	r1, r1
    3dce:	2f 93       	push	r18
    3dd0:	3f 93       	push	r19
    3dd2:	4f 93       	push	r20
    3dd4:	5f 93       	push	r21
    3dd6:	6f 93       	push	r22
    3dd8:	7f 93       	push	r23
    3dda:	8f 93       	push	r24
    3ddc:	9f 93       	push	r25
    3dde:	af 93       	push	r26
    3de0:	bf 93       	push	r27
    3de2:	ef 93       	push	r30
    3de4:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_COMPB_interrupt);
    3de6:	80 91 98 0f 	lds	r24, 0x0F98
    3dea:	90 91 99 0f 	lds	r25, 0x0F99
    3dee:	89 2b       	or	r24, r25
    3df0:	29 f0       	breq	.+10     	; 0x3dfc <__vector_43+0x38>
    3df2:	e0 91 98 0f 	lds	r30, 0x0F98
    3df6:	f0 91 99 0f 	lds	r31, 0x0F99
    3dfa:	09 95       	icall
}
    3dfc:	ff 91       	pop	r31
    3dfe:	ef 91       	pop	r30
    3e00:	bf 91       	pop	r27
    3e02:	af 91       	pop	r26
    3e04:	9f 91       	pop	r25
    3e06:	8f 91       	pop	r24
    3e08:	7f 91       	pop	r23
    3e0a:	6f 91       	pop	r22
    3e0c:	5f 91       	pop	r21
    3e0e:	4f 91       	pop	r20
    3e10:	3f 91       	pop	r19
    3e12:	2f 91       	pop	r18
    3e14:	0f 90       	pop	r0
    3e16:	0f be       	out	0x3f, r0	; 63
    3e18:	0f 90       	pop	r0
    3e1a:	1f 90       	pop	r1
    3e1c:	18 95       	reti

00003e1e <__vector_44>:
ISR(TIMER4_COMPC_vect)
{
    3e1e:	1f 92       	push	r1
    3e20:	0f 92       	push	r0
    3e22:	0f b6       	in	r0, 0x3f	; 63
    3e24:	0f 92       	push	r0
    3e26:	11 24       	eor	r1, r1
    3e28:	2f 93       	push	r18
    3e2a:	3f 93       	push	r19
    3e2c:	4f 93       	push	r20
    3e2e:	5f 93       	push	r21
    3e30:	6f 93       	push	r22
    3e32:	7f 93       	push	r23
    3e34:	8f 93       	push	r24
    3e36:	9f 93       	push	r25
    3e38:	af 93       	push	r26
    3e3a:	bf 93       	push	r27
    3e3c:	ef 93       	push	r30
    3e3e:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_COMPC_interrupt);
    3e40:	80 91 9a 0f 	lds	r24, 0x0F9A
    3e44:	90 91 9b 0f 	lds	r25, 0x0F9B
    3e48:	89 2b       	or	r24, r25
    3e4a:	29 f0       	breq	.+10     	; 0x3e56 <__vector_44+0x38>
    3e4c:	e0 91 9a 0f 	lds	r30, 0x0F9A
    3e50:	f0 91 9b 0f 	lds	r31, 0x0F9B
    3e54:	09 95       	icall
}
    3e56:	ff 91       	pop	r31
    3e58:	ef 91       	pop	r30
    3e5a:	bf 91       	pop	r27
    3e5c:	af 91       	pop	r26
    3e5e:	9f 91       	pop	r25
    3e60:	8f 91       	pop	r24
    3e62:	7f 91       	pop	r23
    3e64:	6f 91       	pop	r22
    3e66:	5f 91       	pop	r21
    3e68:	4f 91       	pop	r20
    3e6a:	3f 91       	pop	r19
    3e6c:	2f 91       	pop	r18
    3e6e:	0f 90       	pop	r0
    3e70:	0f be       	out	0x3f, r0	; 63
    3e72:	0f 90       	pop	r0
    3e74:	1f 90       	pop	r1
    3e76:	18 95       	reti

00003e78 <__vector_46>:
ISR(TIMER5_CAPT_vect)
{
    3e78:	1f 92       	push	r1
    3e7a:	0f 92       	push	r0
    3e7c:	0f b6       	in	r0, 0x3f	; 63
    3e7e:	0f 92       	push	r0
    3e80:	11 24       	eor	r1, r1
    3e82:	2f 93       	push	r18
    3e84:	3f 93       	push	r19
    3e86:	4f 93       	push	r20
    3e88:	5f 93       	push	r21
    3e8a:	6f 93       	push	r22
    3e8c:	7f 93       	push	r23
    3e8e:	8f 93       	push	r24
    3e90:	9f 93       	push	r25
    3e92:	af 93       	push	r26
    3e94:	bf 93       	push	r27
    3e96:	ef 93       	push	r30
    3e98:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_CAPT_interrupt);
    3e9a:	80 91 9e 0f 	lds	r24, 0x0F9E
    3e9e:	90 91 9f 0f 	lds	r25, 0x0F9F
    3ea2:	89 2b       	or	r24, r25
    3ea4:	29 f0       	breq	.+10     	; 0x3eb0 <__vector_46+0x38>
    3ea6:	e0 91 9e 0f 	lds	r30, 0x0F9E
    3eaa:	f0 91 9f 0f 	lds	r31, 0x0F9F
    3eae:	09 95       	icall
}
    3eb0:	ff 91       	pop	r31
    3eb2:	ef 91       	pop	r30
    3eb4:	bf 91       	pop	r27
    3eb6:	af 91       	pop	r26
    3eb8:	9f 91       	pop	r25
    3eba:	8f 91       	pop	r24
    3ebc:	7f 91       	pop	r23
    3ebe:	6f 91       	pop	r22
    3ec0:	5f 91       	pop	r21
    3ec2:	4f 91       	pop	r20
    3ec4:	3f 91       	pop	r19
    3ec6:	2f 91       	pop	r18
    3ec8:	0f 90       	pop	r0
    3eca:	0f be       	out	0x3f, r0	; 63
    3ecc:	0f 90       	pop	r0
    3ece:	1f 90       	pop	r1
    3ed0:	18 95       	reti

00003ed2 <__vector_47>:
ISR(TIMER5_COMPA_vect)
{
    3ed2:	1f 92       	push	r1
    3ed4:	0f 92       	push	r0
    3ed6:	0f b6       	in	r0, 0x3f	; 63
    3ed8:	0f 92       	push	r0
    3eda:	11 24       	eor	r1, r1
    3edc:	2f 93       	push	r18
    3ede:	3f 93       	push	r19
    3ee0:	4f 93       	push	r20
    3ee2:	5f 93       	push	r21
    3ee4:	6f 93       	push	r22
    3ee6:	7f 93       	push	r23
    3ee8:	8f 93       	push	r24
    3eea:	9f 93       	push	r25
    3eec:	af 93       	push	r26
    3eee:	bf 93       	push	r27
    3ef0:	ef 93       	push	r30
    3ef2:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_COMPA_interrupt);
    3ef4:	80 91 a0 0f 	lds	r24, 0x0FA0
    3ef8:	90 91 a1 0f 	lds	r25, 0x0FA1
    3efc:	89 2b       	or	r24, r25
    3efe:	29 f0       	breq	.+10     	; 0x3f0a <__vector_47+0x38>
    3f00:	e0 91 a0 0f 	lds	r30, 0x0FA0
    3f04:	f0 91 a1 0f 	lds	r31, 0x0FA1
    3f08:	09 95       	icall
}
    3f0a:	ff 91       	pop	r31
    3f0c:	ef 91       	pop	r30
    3f0e:	bf 91       	pop	r27
    3f10:	af 91       	pop	r26
    3f12:	9f 91       	pop	r25
    3f14:	8f 91       	pop	r24
    3f16:	7f 91       	pop	r23
    3f18:	6f 91       	pop	r22
    3f1a:	5f 91       	pop	r21
    3f1c:	4f 91       	pop	r20
    3f1e:	3f 91       	pop	r19
    3f20:	2f 91       	pop	r18
    3f22:	0f 90       	pop	r0
    3f24:	0f be       	out	0x3f, r0	; 63
    3f26:	0f 90       	pop	r0
    3f28:	1f 90       	pop	r1
    3f2a:	18 95       	reti

00003f2c <__vector_48>:
ISR(TIMER5_COMPB_vect)
{
    3f2c:	1f 92       	push	r1
    3f2e:	0f 92       	push	r0
    3f30:	0f b6       	in	r0, 0x3f	; 63
    3f32:	0f 92       	push	r0
    3f34:	11 24       	eor	r1, r1
    3f36:	2f 93       	push	r18
    3f38:	3f 93       	push	r19
    3f3a:	4f 93       	push	r20
    3f3c:	5f 93       	push	r21
    3f3e:	6f 93       	push	r22
    3f40:	7f 93       	push	r23
    3f42:	8f 93       	push	r24
    3f44:	9f 93       	push	r25
    3f46:	af 93       	push	r26
    3f48:	bf 93       	push	r27
    3f4a:	ef 93       	push	r30
    3f4c:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_COMPB_interrupt);
    3f4e:	80 91 a2 0f 	lds	r24, 0x0FA2
    3f52:	90 91 a3 0f 	lds	r25, 0x0FA3
    3f56:	89 2b       	or	r24, r25
    3f58:	29 f0       	breq	.+10     	; 0x3f64 <__vector_48+0x38>
    3f5a:	e0 91 a2 0f 	lds	r30, 0x0FA2
    3f5e:	f0 91 a3 0f 	lds	r31, 0x0FA3
    3f62:	09 95       	icall
}
    3f64:	ff 91       	pop	r31
    3f66:	ef 91       	pop	r30
    3f68:	bf 91       	pop	r27
    3f6a:	af 91       	pop	r26
    3f6c:	9f 91       	pop	r25
    3f6e:	8f 91       	pop	r24
    3f70:	7f 91       	pop	r23
    3f72:	6f 91       	pop	r22
    3f74:	5f 91       	pop	r21
    3f76:	4f 91       	pop	r20
    3f78:	3f 91       	pop	r19
    3f7a:	2f 91       	pop	r18
    3f7c:	0f 90       	pop	r0
    3f7e:	0f be       	out	0x3f, r0	; 63
    3f80:	0f 90       	pop	r0
    3f82:	1f 90       	pop	r1
    3f84:	18 95       	reti

00003f86 <__vector_49>:
ISR(TIMER5_COMPC_vect)
{
    3f86:	1f 92       	push	r1
    3f88:	0f 92       	push	r0
    3f8a:	0f b6       	in	r0, 0x3f	; 63
    3f8c:	0f 92       	push	r0
    3f8e:	11 24       	eor	r1, r1
    3f90:	2f 93       	push	r18
    3f92:	3f 93       	push	r19
    3f94:	4f 93       	push	r20
    3f96:	5f 93       	push	r21
    3f98:	6f 93       	push	r22
    3f9a:	7f 93       	push	r23
    3f9c:	8f 93       	push	r24
    3f9e:	9f 93       	push	r25
    3fa0:	af 93       	push	r26
    3fa2:	bf 93       	push	r27
    3fa4:	ef 93       	push	r30
    3fa6:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_COMPC_interrupt);
    3fa8:	80 91 a4 0f 	lds	r24, 0x0FA4
    3fac:	90 91 a5 0f 	lds	r25, 0x0FA5
    3fb0:	89 2b       	or	r24, r25
    3fb2:	29 f0       	breq	.+10     	; 0x3fbe <__vector_49+0x38>
    3fb4:	e0 91 a4 0f 	lds	r30, 0x0FA4
    3fb8:	f0 91 a5 0f 	lds	r31, 0x0FA5
    3fbc:	09 95       	icall
}
    3fbe:	ff 91       	pop	r31
    3fc0:	ef 91       	pop	r30
    3fc2:	bf 91       	pop	r27
    3fc4:	af 91       	pop	r26
    3fc6:	9f 91       	pop	r25
    3fc8:	8f 91       	pop	r24
    3fca:	7f 91       	pop	r23
    3fcc:	6f 91       	pop	r22
    3fce:	5f 91       	pop	r21
    3fd0:	4f 91       	pop	r20
    3fd2:	3f 91       	pop	r19
    3fd4:	2f 91       	pop	r18
    3fd6:	0f 90       	pop	r0
    3fd8:	0f be       	out	0x3f, r0	; 63
    3fda:	0f 90       	pop	r0
    3fdc:	1f 90       	pop	r1
    3fde:	18 95       	reti

00003fe0 <__vector_default>:

ISR(BADISR_vect)
{
    3fe0:	1f 92       	push	r1
    3fe2:	0f 92       	push	r0
    3fe4:	0f b6       	in	r0, 0x3f	; 63
    3fe6:	0f 92       	push	r0
    3fe8:	11 24       	eor	r1, r1
    3fea:	2f 93       	push	r18
    3fec:	3f 93       	push	r19
    3fee:	4f 93       	push	r20
    3ff0:	5f 93       	push	r21
    3ff2:	6f 93       	push	r22
    3ff4:	7f 93       	push	r23
    3ff6:	8f 93       	push	r24
    3ff8:	9f 93       	push	r25
    3ffa:	af 93       	push	r26
    3ffc:	bf 93       	push	r27
    3ffe:	ef 93       	push	r30
    4000:	ff 93       	push	r31
  rprintf("BAD_vect called!");
    4002:	00 d0       	rcall	.+0      	; 0x4004 <__vector_default+0x24>
    4004:	0f 92       	push	r0
    4006:	81 e0       	ldi	r24, 0x01	; 1
    4008:	ed b7       	in	r30, 0x3d	; 61
    400a:	fe b7       	in	r31, 0x3e	; 62
    400c:	81 83       	std	Z+1, r24	; 0x01
    400e:	8a ea       	ldi	r24, 0xAA	; 170
    4010:	91 e0       	ldi	r25, 0x01	; 1
    4012:	93 83       	std	Z+3, r25	; 0x03
    4014:	82 83       	std	Z+2, r24	; 0x02
    4016:	0e 94 ba 27 	call	0x4f74	; 0x4f74 <rprintf1RamRom>
    401a:	0f 90       	pop	r0
    401c:	0f 90       	pop	r0
    401e:	0f 90       	pop	r0
}
    4020:	ff 91       	pop	r31
    4022:	ef 91       	pop	r30
    4024:	bf 91       	pop	r27
    4026:	af 91       	pop	r26
    4028:	9f 91       	pop	r25
    402a:	8f 91       	pop	r24
    402c:	7f 91       	pop	r23
    402e:	6f 91       	pop	r22
    4030:	5f 91       	pop	r21
    4032:	4f 91       	pop	r20
    4034:	3f 91       	pop	r19
    4036:	2f 91       	pop	r18
    4038:	0f 90       	pop	r0
    403a:	0f be       	out	0x3f, r0	; 63
    403c:	0f 90       	pop	r0
    403e:	1f 90       	pop	r1
    4040:	18 95       	reti

00004042 <uartSetRxHandler>:
}

void uartSetRxHandler(u08 nUart, void (*rx_func)(unsigned char c))
{
	// make sure the uart number is within bounds
	if(nUart < 4)
    4042:	84 30       	cpi	r24, 0x04	; 4
    4044:	40 f4       	brcc	.+16     	; 0x4056 <uartSetRxHandler+0x14>
	{
		// set the receive interrupt to run the supplied user function
		UartRxFunc[nUart] = rx_func;
    4046:	e8 2f       	mov	r30, r24
    4048:	f0 e0       	ldi	r31, 0x00	; 0
    404a:	ee 0f       	add	r30, r30
    404c:	ff 1f       	adc	r31, r31
    404e:	e8 51       	subi	r30, 0x18	; 24
    4050:	fe 4e       	sbci	r31, 0xEE	; 238
    4052:	71 83       	std	Z+1, r23	; 0x01
    4054:	60 83       	st	Z, r22
    4056:	08 95       	ret

00004058 <uartSetBaudRate>:
	}
}

void uartSetBaudRate(u08 nUart, u32 baudrate)
{
    4058:	1f 93       	push	r17
    405a:	18 2f       	mov	r17, r24
    405c:	9a 01       	movw	r18, r20
    405e:	ab 01       	movw	r20, r22
	// calculate division factor for requested baud rate, and set it
	u16 bauddiv = ((F_CPU+(baudrate*8L))/(baudrate*16L)-1);
    4060:	ca 01       	movw	r24, r20
    4062:	b9 01       	movw	r22, r18
    4064:	60 58       	subi	r22, 0x80	; 128
    4066:	7b 47       	sbci	r23, 0x7B	; 123
    4068:	81 4e       	sbci	r24, 0xE1	; 225
    406a:	9f 4f       	sbci	r25, 0xFF	; 255
    406c:	f3 e0       	ldi	r31, 0x03	; 3
    406e:	66 0f       	add	r22, r22
    4070:	77 1f       	adc	r23, r23
    4072:	88 1f       	adc	r24, r24
    4074:	99 1f       	adc	r25, r25
    4076:	fa 95       	dec	r31
    4078:	d1 f7       	brne	.-12     	; 0x406e <uartSetBaudRate+0x16>
    407a:	e4 e0       	ldi	r30, 0x04	; 4
    407c:	22 0f       	add	r18, r18
    407e:	33 1f       	adc	r19, r19
    4080:	44 1f       	adc	r20, r20
    4082:	55 1f       	adc	r21, r21
    4084:	ea 95       	dec	r30
    4086:	d1 f7       	brne	.-12     	; 0x407c <uartSetBaudRate+0x24>
    4088:	0e 94 3a 2e 	call	0x5c74	; 0x5c74 <__udivmodsi4>
    408c:	21 50       	subi	r18, 0x01	; 1
    408e:	30 40       	sbci	r19, 0x00	; 0
	if(nUart==3)
    4090:	13 30       	cpi	r17, 0x03	; 3
    4092:	29 f4       	brne	.+10     	; 0x409e <uartSetBaudRate+0x46>
	{
		outb(UBRR3L, bauddiv);
    4094:	20 93 34 01 	sts	0x0134, r18
		#ifdef UBRR3H
		outb(UBRR3H, bauddiv>>8);
    4098:	30 93 35 01 	sts	0x0135, r19
    409c:	12 c0       	rjmp	.+36     	; 0x40c2 <uartSetBaudRate+0x6a>
		#endif
	}
	else if(nUart==2)
    409e:	12 30       	cpi	r17, 0x02	; 2
    40a0:	29 f4       	brne	.+10     	; 0x40ac <uartSetBaudRate+0x54>
	{
		outb(UBRR2L, bauddiv);
    40a2:	20 93 d4 00 	sts	0x00D4, r18
		#ifdef UBRR2H
		outb(UBRR2H, bauddiv>>8);
    40a6:	30 93 d5 00 	sts	0x00D5, r19
    40aa:	0b c0       	rjmp	.+22     	; 0x40c2 <uartSetBaudRate+0x6a>
		#endif
	}
	else if(nUart==1)
    40ac:	11 30       	cpi	r17, 0x01	; 1
    40ae:	29 f4       	brne	.+10     	; 0x40ba <uartSetBaudRate+0x62>
	{
		outb(UBRR1L, bauddiv);
    40b0:	20 93 cc 00 	sts	0x00CC, r18
		#ifdef UBRR1H
		outb(UBRR1H, bauddiv>>8);
    40b4:	30 93 cd 00 	sts	0x00CD, r19
    40b8:	04 c0       	rjmp	.+8      	; 0x40c2 <uartSetBaudRate+0x6a>
		#endif
	}
	else
	{
		outb(UBRR0L, bauddiv);
    40ba:	20 93 c4 00 	sts	0x00C4, r18
		#ifdef UBRR0H
		outb(UBRR0H, bauddiv>>8);
    40be:	30 93 c5 00 	sts	0x00C5, r19
		#endif
	}
}
    40c2:	1f 91       	pop	r17
    40c4:	08 95       	ret

000040c6 <uartGetRxBuffer>:

cBuffer* uartGetRxBuffer(u08 nUart)
{
    40c6:	28 2f       	mov	r18, r24
    40c8:	30 e0       	ldi	r19, 0x00	; 0
    40ca:	a3 e0       	ldi	r26, 0x03	; 3
    40cc:	22 0f       	add	r18, r18
    40ce:	33 1f       	adc	r19, r19
    40d0:	aa 95       	dec	r26
    40d2:	e1 f7       	brne	.-8      	; 0x40cc <uartGetRxBuffer+0x6>
    40d4:	2d 58       	subi	r18, 0x8D	; 141
    40d6:	3b 4e       	sbci	r19, 0xEB	; 235
	// return rx buffer pointer
	return &uartRxBuffer[nUart];
}
    40d8:	c9 01       	movw	r24, r18
    40da:	08 95       	ret

000040dc <uartGetTxBuffer>:

cBuffer* uartGetTxBuffer(u08 nUart)
{
    40dc:	28 2f       	mov	r18, r24
    40de:	30 e0       	ldi	r19, 0x00	; 0
    40e0:	b3 e0       	ldi	r27, 0x03	; 3
    40e2:	22 0f       	add	r18, r18
    40e4:	33 1f       	adc	r19, r19
    40e6:	ba 95       	dec	r27
    40e8:	e1 f7       	brne	.-8      	; 0x40e2 <uartGetTxBuffer+0x6>
    40ea:	29 56       	subi	r18, 0x69	; 105
    40ec:	3b 4e       	sbci	r19, 0xEB	; 235
	// return tx buffer pointer
	return &uartTxBuffer[nUart];
}
    40ee:	c9 01       	movw	r24, r18
    40f0:	08 95       	ret

000040f2 <uartSendByte>:

void uartSendByte(u08 nUart, u08 txData)
{
    40f2:	e8 2f       	mov	r30, r24
	// wait for the transmitter to be ready
//	while(!uartReadyTx[nUart]);
	// send byte
	if(nUart==3)
    40f4:	83 30       	cpi	r24, 0x03	; 3
    40f6:	39 f4       	brne	.+14     	; 0x4106 <uartSendByte+0x14>
	{
		while(!(UCSR3A & (1<<UDRE3)));
    40f8:	80 91 30 01 	lds	r24, 0x0130
    40fc:	85 ff       	sbrs	r24, 5
    40fe:	fc cf       	rjmp	.-8      	; 0x40f8 <uartSendByte+0x6>
		outb(UDR3, txData);
    4100:	60 93 36 01 	sts	0x0136, r22
    4104:	18 c0       	rjmp	.+48     	; 0x4136 <uartSendByte+0x44>
	}
	else if(nUart==2)
    4106:	82 30       	cpi	r24, 0x02	; 2
    4108:	39 f4       	brne	.+14     	; 0x4118 <uartSendByte+0x26>
	{
		while(!(UCSR2A & (1<<UDRE2)));
    410a:	80 91 d0 00 	lds	r24, 0x00D0
    410e:	85 ff       	sbrs	r24, 5
    4110:	fc cf       	rjmp	.-8      	; 0x410a <uartSendByte+0x18>
		outb(UDR2, txData);
    4112:	60 93 d6 00 	sts	0x00D6, r22
    4116:	0f c0       	rjmp	.+30     	; 0x4136 <uartSendByte+0x44>
	}
	else if(nUart==1)
    4118:	81 30       	cpi	r24, 0x01	; 1
    411a:	39 f4       	brne	.+14     	; 0x412a <uartSendByte+0x38>
	{
		while(!(UCSR1A & (1<<UDRE1)));
    411c:	80 91 c8 00 	lds	r24, 0x00C8
    4120:	85 ff       	sbrs	r24, 5
    4122:	fc cf       	rjmp	.-8      	; 0x411c <uartSendByte+0x2a>
		outb(UDR1, txData);
    4124:	60 93 ce 00 	sts	0x00CE, r22
    4128:	06 c0       	rjmp	.+12     	; 0x4136 <uartSendByte+0x44>
	}
	else
	{
		while(!(UCSR0A & (1<<UDRE0)));
    412a:	80 91 c0 00 	lds	r24, 0x00C0
    412e:	85 ff       	sbrs	r24, 5
    4130:	fc cf       	rjmp	.-8      	; 0x412a <uartSendByte+0x38>
		outb(UDR0, txData);
    4132:	60 93 c6 00 	sts	0x00C6, r22
	}
	// set ready state to FALSE
	uartReadyTx[nUart] = FALSE;
    4136:	f0 e0       	ldi	r31, 0x00	; 0
    4138:	e1 59       	subi	r30, 0x91	; 145
    413a:	fb 4e       	sbci	r31, 0xEB	; 235
    413c:	10 82       	st	Z, r1
}
    413e:	08 95       	ret

00004140 <uart0SendByte>:

void uart0SendByte(u08 data)
{
    4140:	68 2f       	mov	r22, r24
	// send byte on UART0
	uartSendByte(0, data);
    4142:	80 e0       	ldi	r24, 0x00	; 0
    4144:	0e 94 79 20 	call	0x40f2	; 0x40f2 <uartSendByte>
}
    4148:	08 95       	ret

0000414a <uart1SendByte>:

void uart1SendByte(u08 data)
{
    414a:	68 2f       	mov	r22, r24
	// send byte on UART1
	uartSendByte(1, data);
    414c:	81 e0       	ldi	r24, 0x01	; 1
    414e:	0e 94 79 20 	call	0x40f2	; 0x40f2 <uartSendByte>
}
    4152:	08 95       	ret

00004154 <uart2SendByte>:

void uart2SendByte(u08 data)
{
    4154:	68 2f       	mov	r22, r24
	// send byte on UART2
	uartSendByte(2, data);
    4156:	82 e0       	ldi	r24, 0x02	; 2
    4158:	0e 94 79 20 	call	0x40f2	; 0x40f2 <uartSendByte>
}
    415c:	08 95       	ret

0000415e <uart3SendByte>:

void uart3SendByte(u08 data)
{
    415e:	68 2f       	mov	r22, r24
	// send byte on UART3
	uartSendByte(3, data);
    4160:	83 e0       	ldi	r24, 0x03	; 3
    4162:	0e 94 79 20 	call	0x40f2	; 0x40f2 <uartSendByte>
}
    4166:	08 95       	ret

00004168 <uartReceiveBufferIsEmpty>:
	// flush all data from receive buffer
	bufferFlush(&uartRxBuffer[nUart]);
}

u08 uartReceiveBufferIsEmpty(u08 nUart)
{
    4168:	20 e0       	ldi	r18, 0x00	; 0
    416a:	e8 2f       	mov	r30, r24
    416c:	f0 e0       	ldi	r31, 0x00	; 0
    416e:	83 e0       	ldi	r24, 0x03	; 3
    4170:	ee 0f       	add	r30, r30
    4172:	ff 1f       	adc	r31, r31
    4174:	8a 95       	dec	r24
    4176:	e1 f7       	brne	.-8      	; 0x4170 <uartReceiveBufferIsEmpty+0x8>
    4178:	e9 58       	subi	r30, 0x89	; 137
    417a:	fb 4e       	sbci	r31, 0xEB	; 235
    417c:	80 81       	ld	r24, Z
    417e:	91 81       	ldd	r25, Z+1	; 0x01
    4180:	89 2b       	or	r24, r25
    4182:	09 f4       	brne	.+2      	; 0x4186 <uartReceiveBufferIsEmpty+0x1e>
    4184:	21 e0       	ldi	r18, 0x01	; 1
	return (uartRxBuffer[nUart].datalength == 0);
}
    4186:	82 2f       	mov	r24, r18
    4188:	08 95       	ret

0000418a <uartReceiveService>:
	}
}

// UART Receive Complete Interrupt Function
void uartReceiveService(u08 nUart)
{
    418a:	cf 93       	push	r28
    418c:	df 93       	push	r29
	u08 c;
	// get received char
	if(nUart==3)
    418e:	83 30       	cpi	r24, 0x03	; 3
    4190:	19 f4       	brne	.+6      	; 0x4198 <uartReceiveService+0xe>
		c = inb(UDR3);
    4192:	60 91 36 01 	lds	r22, 0x0136
    4196:	0c c0       	rjmp	.+24     	; 0x41b0 <uartReceiveService+0x26>
	else if(nUart==2)
    4198:	82 30       	cpi	r24, 0x02	; 2
    419a:	19 f4       	brne	.+6      	; 0x41a2 <uartReceiveService+0x18>
		c = inb(UDR2);
    419c:	60 91 d6 00 	lds	r22, 0x00D6
    41a0:	07 c0       	rjmp	.+14     	; 0x41b0 <uartReceiveService+0x26>
	else if(nUart==1)
    41a2:	81 30       	cpi	r24, 0x01	; 1
    41a4:	19 f4       	brne	.+6      	; 0x41ac <uartReceiveService+0x22>
		c = inb(UDR1);
    41a6:	60 91 ce 00 	lds	r22, 0x00CE
    41aa:	02 c0       	rjmp	.+4      	; 0x41b0 <uartReceiveService+0x26>
	else
		c = inb(UDR0);
    41ac:	60 91 c6 00 	lds	r22, 0x00C6

	// if there's a user function to handle this receive event
	if(UartRxFunc[nUart])
    41b0:	28 2f       	mov	r18, r24
    41b2:	30 e0       	ldi	r19, 0x00	; 0
    41b4:	e9 01       	movw	r28, r18
    41b6:	cc 0f       	add	r28, r28
    41b8:	dd 1f       	adc	r29, r29
    41ba:	fe 01       	movw	r30, r28
    41bc:	e8 51       	subi	r30, 0x18	; 24
    41be:	fe 4e       	sbci	r31, 0xEE	; 238
    41c0:	80 81       	ld	r24, Z
    41c2:	91 81       	ldd	r25, Z+1	; 0x01
    41c4:	89 2b       	or	r24, r25
    41c6:	31 f0       	breq	.+12     	; 0x41d4 <uartReceiveService+0x4a>
	{
		// call it and pass the received data
		UartRxFunc[nUart](c);
    41c8:	01 90       	ld	r0, Z+
    41ca:	f0 81       	ld	r31, Z
    41cc:	e0 2d       	mov	r30, r0
    41ce:	86 2f       	mov	r24, r22
    41d0:	09 95       	icall
    41d2:	14 c0       	rjmp	.+40     	; 0x41fc <uartReceiveService+0x72>
	else
	{
		// otherwise do default processing
		// put received char in buffer
		// check if there's space
		if( !bufferAddToEnd(&uartRxBuffer[nUart], c) )
    41d4:	93 e0       	ldi	r25, 0x03	; 3
    41d6:	22 0f       	add	r18, r18
    41d8:	33 1f       	adc	r19, r19
    41da:	9a 95       	dec	r25
    41dc:	e1 f7       	brne	.-8      	; 0x41d6 <uartReceiveService+0x4c>
    41de:	c9 01       	movw	r24, r18
    41e0:	8d 58       	subi	r24, 0x8D	; 141
    41e2:	9b 4e       	sbci	r25, 0xEB	; 235
    41e4:	0e 94 d1 24 	call	0x49a2	; 0x49a2 <bufferAddToEnd>
    41e8:	88 23       	and	r24, r24
    41ea:	41 f4       	brne	.+16     	; 0x41fc <uartReceiveService+0x72>
		{
			// no space in buffer
			// count overflow
			uartRxOverflow[nUart]++;
    41ec:	fe 01       	movw	r30, r28
    41ee:	e9 54       	subi	r30, 0x49	; 73
    41f0:	fb 4e       	sbci	r31, 0xEB	; 235
    41f2:	80 81       	ld	r24, Z
    41f4:	91 81       	ldd	r25, Z+1	; 0x01
    41f6:	01 96       	adiw	r24, 0x01	; 1
    41f8:	91 83       	std	Z+1, r25	; 0x01
    41fa:	80 83       	st	Z, r24
		}
	}
}
    41fc:	df 91       	pop	r29
    41fe:	cf 91       	pop	r28
    4200:	08 95       	ret

00004202 <__vector_54>:
{
	uartReceiveService(2);
}

UART_INTERRUPT_HANDLER(SIG_USART3_RECV)      
{
    4202:	1f 92       	push	r1
    4204:	0f 92       	push	r0
    4206:	0f b6       	in	r0, 0x3f	; 63
    4208:	0f 92       	push	r0
    420a:	11 24       	eor	r1, r1
    420c:	2f 93       	push	r18
    420e:	3f 93       	push	r19
    4210:	4f 93       	push	r20
    4212:	5f 93       	push	r21
    4214:	6f 93       	push	r22
    4216:	7f 93       	push	r23
    4218:	8f 93       	push	r24
    421a:	9f 93       	push	r25
    421c:	af 93       	push	r26
    421e:	bf 93       	push	r27
    4220:	ef 93       	push	r30
    4222:	ff 93       	push	r31
	uartReceiveService(3);
    4224:	83 e0       	ldi	r24, 0x03	; 3
    4226:	0e 94 c5 20 	call	0x418a	; 0x418a <uartReceiveService>
}
    422a:	ff 91       	pop	r31
    422c:	ef 91       	pop	r30
    422e:	bf 91       	pop	r27
    4230:	af 91       	pop	r26
    4232:	9f 91       	pop	r25
    4234:	8f 91       	pop	r24
    4236:	7f 91       	pop	r23
    4238:	6f 91       	pop	r22
    423a:	5f 91       	pop	r21
    423c:	4f 91       	pop	r20
    423e:	3f 91       	pop	r19
    4240:	2f 91       	pop	r18
    4242:	0f 90       	pop	r0
    4244:	0f be       	out	0x3f, r0	; 63
    4246:	0f 90       	pop	r0
    4248:	1f 90       	pop	r1
    424a:	18 95       	reti

0000424c <__vector_51>:
{
	uartReceiveService(1);
}

UART_INTERRUPT_HANDLER(SIG_USART2_RECV)      
{
    424c:	1f 92       	push	r1
    424e:	0f 92       	push	r0
    4250:	0f b6       	in	r0, 0x3f	; 63
    4252:	0f 92       	push	r0
    4254:	11 24       	eor	r1, r1
    4256:	2f 93       	push	r18
    4258:	3f 93       	push	r19
    425a:	4f 93       	push	r20
    425c:	5f 93       	push	r21
    425e:	6f 93       	push	r22
    4260:	7f 93       	push	r23
    4262:	8f 93       	push	r24
    4264:	9f 93       	push	r25
    4266:	af 93       	push	r26
    4268:	bf 93       	push	r27
    426a:	ef 93       	push	r30
    426c:	ff 93       	push	r31
	uartReceiveService(2);
    426e:	82 e0       	ldi	r24, 0x02	; 2
    4270:	0e 94 c5 20 	call	0x418a	; 0x418a <uartReceiveService>
}
    4274:	ff 91       	pop	r31
    4276:	ef 91       	pop	r30
    4278:	bf 91       	pop	r27
    427a:	af 91       	pop	r26
    427c:	9f 91       	pop	r25
    427e:	8f 91       	pop	r24
    4280:	7f 91       	pop	r23
    4282:	6f 91       	pop	r22
    4284:	5f 91       	pop	r21
    4286:	4f 91       	pop	r20
    4288:	3f 91       	pop	r19
    428a:	2f 91       	pop	r18
    428c:	0f 90       	pop	r0
    428e:	0f be       	out	0x3f, r0	; 63
    4290:	0f 90       	pop	r0
    4292:	1f 90       	pop	r1
    4294:	18 95       	reti

00004296 <__vector_36>:
{
	uartReceiveService(0);
}

UART_INTERRUPT_HANDLER(SIG_USART1_RECV)      
{
    4296:	1f 92       	push	r1
    4298:	0f 92       	push	r0
    429a:	0f b6       	in	r0, 0x3f	; 63
    429c:	0f 92       	push	r0
    429e:	11 24       	eor	r1, r1
    42a0:	2f 93       	push	r18
    42a2:	3f 93       	push	r19
    42a4:	4f 93       	push	r20
    42a6:	5f 93       	push	r21
    42a8:	6f 93       	push	r22
    42aa:	7f 93       	push	r23
    42ac:	8f 93       	push	r24
    42ae:	9f 93       	push	r25
    42b0:	af 93       	push	r26
    42b2:	bf 93       	push	r27
    42b4:	ef 93       	push	r30
    42b6:	ff 93       	push	r31
	uartReceiveService(1);
    42b8:	81 e0       	ldi	r24, 0x01	; 1
    42ba:	0e 94 c5 20 	call	0x418a	; 0x418a <uartReceiveService>
}
    42be:	ff 91       	pop	r31
    42c0:	ef 91       	pop	r30
    42c2:	bf 91       	pop	r27
    42c4:	af 91       	pop	r26
    42c6:	9f 91       	pop	r25
    42c8:	8f 91       	pop	r24
    42ca:	7f 91       	pop	r23
    42cc:	6f 91       	pop	r22
    42ce:	5f 91       	pop	r21
    42d0:	4f 91       	pop	r20
    42d2:	3f 91       	pop	r19
    42d4:	2f 91       	pop	r18
    42d6:	0f 90       	pop	r0
    42d8:	0f be       	out	0x3f, r0	; 63
    42da:	0f 90       	pop	r0
    42dc:	1f 90       	pop	r1
    42de:	18 95       	reti

000042e0 <__vector_25>:
	uartTransmitService(3);
}

	// service UART receive interrupt
UART_INTERRUPT_HANDLER(SIG_USART0_RECV)      
{
    42e0:	1f 92       	push	r1
    42e2:	0f 92       	push	r0
    42e4:	0f b6       	in	r0, 0x3f	; 63
    42e6:	0f 92       	push	r0
    42e8:	11 24       	eor	r1, r1
    42ea:	2f 93       	push	r18
    42ec:	3f 93       	push	r19
    42ee:	4f 93       	push	r20
    42f0:	5f 93       	push	r21
    42f2:	6f 93       	push	r22
    42f4:	7f 93       	push	r23
    42f6:	8f 93       	push	r24
    42f8:	9f 93       	push	r25
    42fa:	af 93       	push	r26
    42fc:	bf 93       	push	r27
    42fe:	ef 93       	push	r30
    4300:	ff 93       	push	r31
	uartReceiveService(0);
    4302:	80 e0       	ldi	r24, 0x00	; 0
    4304:	0e 94 c5 20 	call	0x418a	; 0x418a <uartReceiveService>
}
    4308:	ff 91       	pop	r31
    430a:	ef 91       	pop	r30
    430c:	bf 91       	pop	r27
    430e:	af 91       	pop	r26
    4310:	9f 91       	pop	r25
    4312:	8f 91       	pop	r24
    4314:	7f 91       	pop	r23
    4316:	6f 91       	pop	r22
    4318:	5f 91       	pop	r21
    431a:	4f 91       	pop	r20
    431c:	3f 91       	pop	r19
    431e:	2f 91       	pop	r18
    4320:	0f 90       	pop	r0
    4322:	0f be       	out	0x3f, r0	; 63
    4324:	0f 90       	pop	r0
    4326:	1f 90       	pop	r1
    4328:	18 95       	reti

0000432a <uartSendBuffer>:
	// send the first byte to get things going by interrupts
	uartSendByte(nUart, bufferGetFromFront(&uartTxBuffer[nUart]));
}

u08 uartSendBuffer(u08 nUart, char *buffer, u16 nBytes)
{
    432a:	8f 92       	push	r8
    432c:	9f 92       	push	r9
    432e:	af 92       	push	r10
    4330:	bf 92       	push	r11
    4332:	cf 92       	push	r12
    4334:	df 92       	push	r13
    4336:	ef 92       	push	r14
    4338:	ff 92       	push	r15
    433a:	0f 93       	push	r16
    433c:	1f 93       	push	r17
    433e:	cf 93       	push	r28
    4340:	df 93       	push	r29
    4342:	88 2e       	mov	r8, r24
    4344:	db 01       	movw	r26, r22
	register u08 first;
	register u16 i;

	// check if there's space (and that we have any bytes to send at all)
	if((uartTxBuffer[nUart].datalength + nBytes < uartTxBuffer[nUart].size) && nBytes)
    4346:	c8 2e       	mov	r12, r24
    4348:	dd 24       	eor	r13, r13
    434a:	f6 01       	movw	r30, r12
    434c:	13 e0       	ldi	r17, 0x03	; 3
    434e:	ee 0f       	add	r30, r30
    4350:	ff 1f       	adc	r31, r31
    4352:	1a 95       	dec	r17
    4354:	e1 f7       	brne	.-8      	; 0x434e <uartSendBuffer+0x24>
    4356:	e5 56       	subi	r30, 0x65	; 101
    4358:	fb 4e       	sbci	r31, 0xEB	; 235
    435a:	20 81       	ld	r18, Z
    435c:	31 81       	ldd	r19, Z+1	; 0x01
    435e:	24 0f       	add	r18, r20
    4360:	35 1f       	adc	r19, r21
    4362:	f6 01       	movw	r30, r12
    4364:	73 e0       	ldi	r23, 0x03	; 3
    4366:	ee 0f       	add	r30, r30
    4368:	ff 1f       	adc	r31, r31
    436a:	7a 95       	dec	r23
    436c:	e1 f7       	brne	.-8      	; 0x4366 <uartSendBuffer+0x3c>
    436e:	e7 56       	subi	r30, 0x67	; 103
    4370:	fb 4e       	sbci	r31, 0xEB	; 235
    4372:	80 81       	ld	r24, Z
    4374:	91 81       	ldd	r25, Z+1	; 0x01
    4376:	28 17       	cp	r18, r24
    4378:	39 07       	cpc	r19, r25
    437a:	70 f5       	brcc	.+92     	; 0x43d8 <uartSendBuffer+0xae>
    437c:	41 15       	cp	r20, r1
    437e:	51 05       	cpc	r21, r1
    4380:	59 f1       	breq	.+86     	; 0x43d8 <uartSendBuffer+0xae>
	{
		// grab first character
		first = *buffer++;
    4382:	9c 90       	ld	r9, X
		// copy user buffer to uart transmit buffer
		for(i = 0; i < nBytes-1; i++)
		{
			// put data bytes at end of buffer
			bufferAddToEnd(&uartTxBuffer[nUart], *buffer++);
    4384:	76 01       	movw	r14, r12
    4386:	63 e0       	ldi	r22, 0x03	; 3
    4388:	ee 0c       	add	r14, r14
    438a:	ff 1c       	adc	r15, r15
    438c:	6a 95       	dec	r22
    438e:	e1 f7       	brne	.-8      	; 0x4388 <uartSendBuffer+0x5e>
    4390:	87 e9       	ldi	r24, 0x97	; 151
    4392:	94 e1       	ldi	r25, 0x14	; 20
    4394:	e8 0e       	add	r14, r24
    4396:	f9 1e       	adc	r15, r25
    4398:	8d 01       	movw	r16, r26
    439a:	c0 e0       	ldi	r28, 0x00	; 0
    439c:	d0 e0       	ldi	r29, 0x00	; 0
	if((uartTxBuffer[nUart].datalength + nBytes < uartTxBuffer[nUart].size) && nBytes)
	{
		// grab first character
		first = *buffer++;
		// copy user buffer to uart transmit buffer
		for(i = 0; i < nBytes-1; i++)
    439e:	5a 01       	movw	r10, r20
    43a0:	08 94       	sec
    43a2:	a1 08       	sbc	r10, r1
    43a4:	b1 08       	sbc	r11, r1
    43a6:	06 c0       	rjmp	.+12     	; 0x43b4 <uartSendBuffer+0x8a>
    43a8:	c7 01       	movw	r24, r14
    43aa:	f8 01       	movw	r30, r16
    43ac:	60 81       	ld	r22, Z
    43ae:	0e 94 d1 24 	call	0x49a2	; 0x49a2 <bufferAddToEnd>
    43b2:	21 96       	adiw	r28, 0x01	; 1
    43b4:	0f 5f       	subi	r16, 0xFF	; 255
    43b6:	1f 4f       	sbci	r17, 0xFF	; 255
    43b8:	ca 15       	cp	r28, r10
    43ba:	db 05       	cpc	r29, r11
    43bc:	a8 f3       	brcs	.-22     	; 0x43a8 <uartSendBuffer+0x7e>
			// put data bytes at end of buffer
			bufferAddToEnd(&uartTxBuffer[nUart], *buffer++);
		}

		// send the first byte to get things going by interrupts
		uartBufferedTx[nUart] = TRUE;
    43be:	83 e9       	ldi	r24, 0x93	; 147
    43c0:	94 e1       	ldi	r25, 0x14	; 20
    43c2:	c8 0e       	add	r12, r24
    43c4:	d9 1e       	adc	r13, r25
    43c6:	8f ef       	ldi	r24, 0xFF	; 255
    43c8:	f6 01       	movw	r30, r12
    43ca:	80 83       	st	Z, r24
		uartSendByte(nUart, first);
    43cc:	88 2d       	mov	r24, r8
    43ce:	69 2d       	mov	r22, r9
    43d0:	0e 94 79 20 	call	0x40f2	; 0x40f2 <uartSendByte>
    43d4:	8f ef       	ldi	r24, 0xFF	; 255
    43d6:	01 c0       	rjmp	.+2      	; 0x43da <uartSendBuffer+0xb0>
		// return success
		return TRUE;
    43d8:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		// return failure
		return FALSE;
	}
}
    43da:	df 91       	pop	r29
    43dc:	cf 91       	pop	r28
    43de:	1f 91       	pop	r17
    43e0:	0f 91       	pop	r16
    43e2:	ff 90       	pop	r15
    43e4:	ef 90       	pop	r14
    43e6:	df 90       	pop	r13
    43e8:	cf 90       	pop	r12
    43ea:	bf 90       	pop	r11
    43ec:	af 90       	pop	r10
    43ee:	9f 90       	pop	r9
    43f0:	8f 90       	pop	r8
    43f2:	08 95       	ret

000043f4 <uartAddToTxBuffer>:
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    43f4:	90 e0       	ldi	r25, 0x00	; 0
    43f6:	23 e0       	ldi	r18, 0x03	; 3
    43f8:	88 0f       	add	r24, r24
    43fa:	99 1f       	adc	r25, r25
    43fc:	2a 95       	dec	r18
    43fe:	e1 f7       	brne	.-8      	; 0x43f8 <uartAddToTxBuffer+0x4>
    4400:	89 56       	subi	r24, 0x69	; 105
    4402:	9b 4e       	sbci	r25, 0xEB	; 235
    4404:	0e 94 d1 24 	call	0x49a2	; 0x49a2 <bufferAddToEnd>
}
    4408:	08 95       	ret

0000440a <uart3AddToTxBuffer>:
{
	uartAddToTxBuffer(2,data);
}

void uart3AddToTxBuffer(u08 data)
{
    440a:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    440c:	8f ea       	ldi	r24, 0xAF	; 175
    440e:	94 e1       	ldi	r25, 0x14	; 20
    4410:	0e 94 d1 24 	call	0x49a2	; 0x49a2 <bufferAddToEnd>
}

void uart3AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(3,data);
}
    4414:	08 95       	ret

00004416 <uart2AddToTxBuffer>:
{
	uartAddToTxBuffer(1,data);
}

void uart2AddToTxBuffer(u08 data)
{
    4416:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    4418:	87 ea       	ldi	r24, 0xA7	; 167
    441a:	94 e1       	ldi	r25, 0x14	; 20
    441c:	0e 94 d1 24 	call	0x49a2	; 0x49a2 <bufferAddToEnd>
}

void uart2AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(2,data);
}
    4420:	08 95       	ret

00004422 <uart1AddToTxBuffer>:
{
	uartAddToTxBuffer(0,data);
}

void uart1AddToTxBuffer(u08 data)
{
    4422:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    4424:	8f e9       	ldi	r24, 0x9F	; 159
    4426:	94 e1       	ldi	r25, 0x14	; 20
    4428:	0e 94 d1 24 	call	0x49a2	; 0x49a2 <bufferAddToEnd>
}

void uart1AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(1,data);
}
    442c:	08 95       	ret

0000442e <uart0AddToTxBuffer>:
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
}

void uart0AddToTxBuffer(u08 data)
{
    442e:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    4430:	87 e9       	ldi	r24, 0x97	; 151
    4432:	94 e1       	ldi	r25, 0x14	; 20
    4434:	0e 94 d1 24 	call	0x49a2	; 0x49a2 <bufferAddToEnd>
}

void uart0AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(0,data);
}
    4438:	08 95       	ret

0000443a <uartTransmitService>:
	}
}

// UART Transmit Complete Interrupt Function
void uartTransmitService(u08 nUart)
{
    443a:	cf 93       	push	r28
    443c:	df 93       	push	r29
    443e:	28 2f       	mov	r18, r24
	// check if buffered tx is enabled
	if(uartBufferedTx[nUart])
    4440:	a8 2f       	mov	r26, r24
    4442:	b0 e0       	ldi	r27, 0x00	; 0
    4444:	ed 01       	movw	r28, r26
    4446:	cd 56       	subi	r28, 0x6D	; 109
    4448:	db 4e       	sbci	r29, 0xEB	; 235
    444a:	88 81       	ld	r24, Y
    444c:	88 23       	and	r24, r24
    444e:	79 f1       	breq	.+94     	; 0x44ae <uartTransmitService+0x74>
	{
		// check if there's data left in the buffer
		if(uartTxBuffer[nUart].datalength)
    4450:	fd 01       	movw	r30, r26
    4452:	33 e0       	ldi	r19, 0x03	; 3
    4454:	ee 0f       	add	r30, r30
    4456:	ff 1f       	adc	r31, r31
    4458:	3a 95       	dec	r19
    445a:	e1 f7       	brne	.-8      	; 0x4454 <uartTransmitService+0x1a>
    445c:	e5 56       	subi	r30, 0x65	; 101
    445e:	fb 4e       	sbci	r31, 0xEB	; 235
    4460:	80 81       	ld	r24, Z
    4462:	91 81       	ldd	r25, Z+1	; 0x01
    4464:	89 2b       	or	r24, r25
    4466:	11 f1       	breq	.+68     	; 0x44ac <uartTransmitService+0x72>
		{
			// send byte from top of buffer
			if(nUart==3)
    4468:	23 30       	cpi	r18, 0x03	; 3
    446a:	39 f4       	brne	.+14     	; 0x447a <uartTransmitService+0x40>
				outb(UDR3,  bufferGetFromFront(&uartTxBuffer[3]) );
    446c:	8f ea       	ldi	r24, 0xAF	; 175
    446e:	94 e1       	ldi	r25, 0x14	; 20
    4470:	0e 94 68 24 	call	0x48d0	; 0x48d0 <bufferGetFromFront>
    4474:	80 93 36 01 	sts	0x0136, r24
    4478:	1e c0       	rjmp	.+60     	; 0x44b6 <uartTransmitService+0x7c>
			else if(nUart==2)
    447a:	22 30       	cpi	r18, 0x02	; 2
    447c:	39 f4       	brne	.+14     	; 0x448c <uartTransmitService+0x52>
				outb(UDR2,  bufferGetFromFront(&uartTxBuffer[2]) );
    447e:	87 ea       	ldi	r24, 0xA7	; 167
    4480:	94 e1       	ldi	r25, 0x14	; 20
    4482:	0e 94 68 24 	call	0x48d0	; 0x48d0 <bufferGetFromFront>
    4486:	80 93 d6 00 	sts	0x00D6, r24
    448a:	15 c0       	rjmp	.+42     	; 0x44b6 <uartTransmitService+0x7c>
			else if(nUart==1)
    448c:	21 30       	cpi	r18, 0x01	; 1
    448e:	39 f4       	brne	.+14     	; 0x449e <uartTransmitService+0x64>
				outb(UDR1,  bufferGetFromFront(&uartTxBuffer[1]) );
    4490:	8f e9       	ldi	r24, 0x9F	; 159
    4492:	94 e1       	ldi	r25, 0x14	; 20
    4494:	0e 94 68 24 	call	0x48d0	; 0x48d0 <bufferGetFromFront>
    4498:	80 93 ce 00 	sts	0x00CE, r24
    449c:	0c c0       	rjmp	.+24     	; 0x44b6 <uartTransmitService+0x7c>
			else
				outb(UDR0,  bufferGetFromFront(&uartTxBuffer[0]) );
    449e:	87 e9       	ldi	r24, 0x97	; 151
    44a0:	94 e1       	ldi	r25, 0x14	; 20
    44a2:	0e 94 68 24 	call	0x48d0	; 0x48d0 <bufferGetFromFront>
    44a6:	80 93 c6 00 	sts	0x00C6, r24
    44aa:	05 c0       	rjmp	.+10     	; 0x44b6 <uartTransmitService+0x7c>
		}
		else
		{
			// no data left
			uartBufferedTx[nUart] = FALSE;
    44ac:	18 82       	st	Y, r1
	}
	else
	{
		// we're using single-byte tx mode
		// indicate transmit complete, back to ready
		uartReadyTx[nUart] = TRUE;
    44ae:	a1 59       	subi	r26, 0x91	; 145
    44b0:	bb 4e       	sbci	r27, 0xEB	; 235
    44b2:	8f ef       	ldi	r24, 0xFF	; 255
    44b4:	8c 93       	st	X, r24
	}
}
    44b6:	df 91       	pop	r29
    44b8:	cf 91       	pop	r28
    44ba:	08 95       	ret

000044bc <__vector_56>:
{
	uartTransmitService(2);
}

UART_INTERRUPT_HANDLER(SIG_USART3_TRANS)      
{
    44bc:	1f 92       	push	r1
    44be:	0f 92       	push	r0
    44c0:	0f b6       	in	r0, 0x3f	; 63
    44c2:	0f 92       	push	r0
    44c4:	11 24       	eor	r1, r1
    44c6:	2f 93       	push	r18
    44c8:	3f 93       	push	r19
    44ca:	4f 93       	push	r20
    44cc:	5f 93       	push	r21
    44ce:	6f 93       	push	r22
    44d0:	7f 93       	push	r23
    44d2:	8f 93       	push	r24
    44d4:	9f 93       	push	r25
    44d6:	af 93       	push	r26
    44d8:	bf 93       	push	r27
    44da:	ef 93       	push	r30
    44dc:	ff 93       	push	r31
	uartTransmitService(3);
    44de:	83 e0       	ldi	r24, 0x03	; 3
    44e0:	0e 94 1d 22 	call	0x443a	; 0x443a <uartTransmitService>
}
    44e4:	ff 91       	pop	r31
    44e6:	ef 91       	pop	r30
    44e8:	bf 91       	pop	r27
    44ea:	af 91       	pop	r26
    44ec:	9f 91       	pop	r25
    44ee:	8f 91       	pop	r24
    44f0:	7f 91       	pop	r23
    44f2:	6f 91       	pop	r22
    44f4:	5f 91       	pop	r21
    44f6:	4f 91       	pop	r20
    44f8:	3f 91       	pop	r19
    44fa:	2f 91       	pop	r18
    44fc:	0f 90       	pop	r0
    44fe:	0f be       	out	0x3f, r0	; 63
    4500:	0f 90       	pop	r0
    4502:	1f 90       	pop	r1
    4504:	18 95       	reti

00004506 <__vector_53>:
{
	uartTransmitService(1);
}

UART_INTERRUPT_HANDLER(SIG_USART2_TRANS)      
{
    4506:	1f 92       	push	r1
    4508:	0f 92       	push	r0
    450a:	0f b6       	in	r0, 0x3f	; 63
    450c:	0f 92       	push	r0
    450e:	11 24       	eor	r1, r1
    4510:	2f 93       	push	r18
    4512:	3f 93       	push	r19
    4514:	4f 93       	push	r20
    4516:	5f 93       	push	r21
    4518:	6f 93       	push	r22
    451a:	7f 93       	push	r23
    451c:	8f 93       	push	r24
    451e:	9f 93       	push	r25
    4520:	af 93       	push	r26
    4522:	bf 93       	push	r27
    4524:	ef 93       	push	r30
    4526:	ff 93       	push	r31
	uartTransmitService(2);
    4528:	82 e0       	ldi	r24, 0x02	; 2
    452a:	0e 94 1d 22 	call	0x443a	; 0x443a <uartTransmitService>
}
    452e:	ff 91       	pop	r31
    4530:	ef 91       	pop	r30
    4532:	bf 91       	pop	r27
    4534:	af 91       	pop	r26
    4536:	9f 91       	pop	r25
    4538:	8f 91       	pop	r24
    453a:	7f 91       	pop	r23
    453c:	6f 91       	pop	r22
    453e:	5f 91       	pop	r21
    4540:	4f 91       	pop	r20
    4542:	3f 91       	pop	r19
    4544:	2f 91       	pop	r18
    4546:	0f 90       	pop	r0
    4548:	0f be       	out	0x3f, r0	; 63
    454a:	0f 90       	pop	r0
    454c:	1f 90       	pop	r1
    454e:	18 95       	reti

00004550 <__vector_38>:
{
	uartTransmitService(0);
}

UART_INTERRUPT_HANDLER(SIG_USART1_TRANS)      
{
    4550:	1f 92       	push	r1
    4552:	0f 92       	push	r0
    4554:	0f b6       	in	r0, 0x3f	; 63
    4556:	0f 92       	push	r0
    4558:	11 24       	eor	r1, r1
    455a:	2f 93       	push	r18
    455c:	3f 93       	push	r19
    455e:	4f 93       	push	r20
    4560:	5f 93       	push	r21
    4562:	6f 93       	push	r22
    4564:	7f 93       	push	r23
    4566:	8f 93       	push	r24
    4568:	9f 93       	push	r25
    456a:	af 93       	push	r26
    456c:	bf 93       	push	r27
    456e:	ef 93       	push	r30
    4570:	ff 93       	push	r31
	uartTransmitService(1);
    4572:	81 e0       	ldi	r24, 0x01	; 1
    4574:	0e 94 1d 22 	call	0x443a	; 0x443a <uartTransmitService>
}
    4578:	ff 91       	pop	r31
    457a:	ef 91       	pop	r30
    457c:	bf 91       	pop	r27
    457e:	af 91       	pop	r26
    4580:	9f 91       	pop	r25
    4582:	8f 91       	pop	r24
    4584:	7f 91       	pop	r23
    4586:	6f 91       	pop	r22
    4588:	5f 91       	pop	r21
    458a:	4f 91       	pop	r20
    458c:	3f 91       	pop	r19
    458e:	2f 91       	pop	r18
    4590:	0f 90       	pop	r0
    4592:	0f be       	out	0x3f, r0	; 63
    4594:	0f 90       	pop	r0
    4596:	1f 90       	pop	r1
    4598:	18 95       	reti

0000459a <__vector_27>:
	}
}

	// service UART transmit interrupt
UART_INTERRUPT_HANDLER(SIG_USART0_TRANS)      
{
    459a:	1f 92       	push	r1
    459c:	0f 92       	push	r0
    459e:	0f b6       	in	r0, 0x3f	; 63
    45a0:	0f 92       	push	r0
    45a2:	11 24       	eor	r1, r1
    45a4:	2f 93       	push	r18
    45a6:	3f 93       	push	r19
    45a8:	4f 93       	push	r20
    45aa:	5f 93       	push	r21
    45ac:	6f 93       	push	r22
    45ae:	7f 93       	push	r23
    45b0:	8f 93       	push	r24
    45b2:	9f 93       	push	r25
    45b4:	af 93       	push	r26
    45b6:	bf 93       	push	r27
    45b8:	ef 93       	push	r30
    45ba:	ff 93       	push	r31
	uartTransmitService(0);
    45bc:	80 e0       	ldi	r24, 0x00	; 0
    45be:	0e 94 1d 22 	call	0x443a	; 0x443a <uartTransmitService>
}
    45c2:	ff 91       	pop	r31
    45c4:	ef 91       	pop	r30
    45c6:	bf 91       	pop	r27
    45c8:	af 91       	pop	r26
    45ca:	9f 91       	pop	r25
    45cc:	8f 91       	pop	r24
    45ce:	7f 91       	pop	r23
    45d0:	6f 91       	pop	r22
    45d2:	5f 91       	pop	r21
    45d4:	4f 91       	pop	r20
    45d6:	3f 91       	pop	r19
    45d8:	2f 91       	pop	r18
    45da:	0f 90       	pop	r0
    45dc:	0f be       	out	0x3f, r0	; 63
    45de:	0f 90       	pop	r0
    45e0:	1f 90       	pop	r1
    45e2:	18 95       	reti

000045e4 <uartSendTxBuffer>:
{
	uartAddToTxBuffer(3,data);
}

void uartSendTxBuffer(u08 nUart)
{
    45e4:	1f 93       	push	r17
    45e6:	18 2f       	mov	r17, r24
	// turn on buffered transmit
	uartBufferedTx[nUart] = TRUE;
    45e8:	90 e0       	ldi	r25, 0x00	; 0
    45ea:	fc 01       	movw	r30, r24
    45ec:	ed 56       	subi	r30, 0x6D	; 109
    45ee:	fb 4e       	sbci	r31, 0xEB	; 235
    45f0:	2f ef       	ldi	r18, 0xFF	; 255
    45f2:	20 83       	st	Z, r18
	// send the first byte to get things going by interrupts
	uartSendByte(nUart, bufferGetFromFront(&uartTxBuffer[nUart]));
    45f4:	43 e0       	ldi	r20, 0x03	; 3
    45f6:	88 0f       	add	r24, r24
    45f8:	99 1f       	adc	r25, r25
    45fa:	4a 95       	dec	r20
    45fc:	e1 f7       	brne	.-8      	; 0x45f6 <uartSendTxBuffer+0x12>
    45fe:	89 56       	subi	r24, 0x69	; 105
    4600:	9b 4e       	sbci	r25, 0xEB	; 235
    4602:	0e 94 68 24 	call	0x48d0	; 0x48d0 <bufferGetFromFront>
    4606:	68 2f       	mov	r22, r24
    4608:	81 2f       	mov	r24, r17
    460a:	0e 94 79 20 	call	0x40f2	; 0x40f2 <uartSendByte>
}
    460e:	1f 91       	pop	r17
    4610:	08 95       	ret

00004612 <uartReceiveByte>:
		return -1;
}


u08 uartReceiveByte(u08 nUart, u08* rxData)
{
    4612:	cf 93       	push	r28
    4614:	df 93       	push	r29
    4616:	eb 01       	movw	r28, r22
	// make sure we have a receive buffer
	if(uartRxBuffer[nUart].size)
    4618:	28 2f       	mov	r18, r24
    461a:	30 e0       	ldi	r19, 0x00	; 0
    461c:	f9 01       	movw	r30, r18
    461e:	73 e0       	ldi	r23, 0x03	; 3
    4620:	ee 0f       	add	r30, r30
    4622:	ff 1f       	adc	r31, r31
    4624:	7a 95       	dec	r23
    4626:	e1 f7       	brne	.-8      	; 0x4620 <uartReceiveByte+0xe>
    4628:	eb 58       	subi	r30, 0x8B	; 139
    462a:	fb 4e       	sbci	r31, 0xEB	; 235
    462c:	80 81       	ld	r24, Z
    462e:	91 81       	ldd	r25, Z+1	; 0x01
    4630:	89 2b       	or	r24, r25
    4632:	c9 f0       	breq	.+50     	; 0x4666 <uartReceiveByte+0x54>
	{
		// make sure we have data
		if(uartRxBuffer[nUart].datalength)
    4634:	f9 01       	movw	r30, r18
    4636:	63 e0       	ldi	r22, 0x03	; 3
    4638:	ee 0f       	add	r30, r30
    463a:	ff 1f       	adc	r31, r31
    463c:	6a 95       	dec	r22
    463e:	e1 f7       	brne	.-8      	; 0x4638 <uartReceiveByte+0x26>
    4640:	e9 58       	subi	r30, 0x89	; 137
    4642:	fb 4e       	sbci	r31, 0xEB	; 235
    4644:	80 81       	ld	r24, Z
    4646:	91 81       	ldd	r25, Z+1	; 0x01
    4648:	89 2b       	or	r24, r25
    464a:	69 f0       	breq	.+26     	; 0x4666 <uartReceiveByte+0x54>
		{
			// get byte from beginning of buffer
			*rxData = bufferGetFromFront(&uartRxBuffer[nUart]);
    464c:	53 e0       	ldi	r21, 0x03	; 3
    464e:	22 0f       	add	r18, r18
    4650:	33 1f       	adc	r19, r19
    4652:	5a 95       	dec	r21
    4654:	e1 f7       	brne	.-8      	; 0x464e <uartReceiveByte+0x3c>
    4656:	c9 01       	movw	r24, r18
    4658:	8d 58       	subi	r24, 0x8D	; 141
    465a:	9b 4e       	sbci	r25, 0xEB	; 235
    465c:	0e 94 68 24 	call	0x48d0	; 0x48d0 <bufferGetFromFront>
    4660:	88 83       	st	Y, r24
    4662:	8f ef       	ldi	r24, 0xFF	; 255
    4664:	01 c0       	rjmp	.+2      	; 0x4668 <uartReceiveByte+0x56>
			return TRUE;
    4666:	80 e0       	ldi	r24, 0x00	; 0
		else
			return FALSE;			// no data
	}
	else
		return FALSE;				// no buffer
}
    4668:	df 91       	pop	r29
    466a:	cf 91       	pop	r28
    466c:	08 95       	ret

0000466e <uart3GetByte>:
	else
		return -1;
}

int uart3GetByte(void)
{
    466e:	df 93       	push	r29
    4670:	cf 93       	push	r28
    4672:	0f 92       	push	r0
    4674:	cd b7       	in	r28, 0x3d	; 61
    4676:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(3,&c))
    4678:	83 e0       	ldi	r24, 0x03	; 3
    467a:	be 01       	movw	r22, r28
    467c:	6f 5f       	subi	r22, 0xFF	; 255
    467e:	7f 4f       	sbci	r23, 0xFF	; 255
    4680:	0e 94 09 23 	call	0x4612	; 0x4612 <uartReceiveByte>
    4684:	88 23       	and	r24, r24
    4686:	19 f4       	brne	.+6      	; 0x468e <uart3GetByte+0x20>
    4688:	2f ef       	ldi	r18, 0xFF	; 255
    468a:	3f ef       	ldi	r19, 0xFF	; 255
    468c:	03 c0       	rjmp	.+6      	; 0x4694 <uart3GetByte+0x26>
		return c;
    468e:	89 81       	ldd	r24, Y+1	; 0x01
    4690:	28 2f       	mov	r18, r24
    4692:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    4694:	c9 01       	movw	r24, r18
    4696:	0f 90       	pop	r0
    4698:	cf 91       	pop	r28
    469a:	df 91       	pop	r29
    469c:	08 95       	ret

0000469e <uart2GetByte>:
	else
		return -1;
}

int uart2GetByte(void)
{
    469e:	df 93       	push	r29
    46a0:	cf 93       	push	r28
    46a2:	0f 92       	push	r0
    46a4:	cd b7       	in	r28, 0x3d	; 61
    46a6:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(2,&c))
    46a8:	82 e0       	ldi	r24, 0x02	; 2
    46aa:	be 01       	movw	r22, r28
    46ac:	6f 5f       	subi	r22, 0xFF	; 255
    46ae:	7f 4f       	sbci	r23, 0xFF	; 255
    46b0:	0e 94 09 23 	call	0x4612	; 0x4612 <uartReceiveByte>
    46b4:	88 23       	and	r24, r24
    46b6:	19 f4       	brne	.+6      	; 0x46be <uart2GetByte+0x20>
    46b8:	2f ef       	ldi	r18, 0xFF	; 255
    46ba:	3f ef       	ldi	r19, 0xFF	; 255
    46bc:	03 c0       	rjmp	.+6      	; 0x46c4 <uart2GetByte+0x26>
		return c;
    46be:	89 81       	ldd	r24, Y+1	; 0x01
    46c0:	28 2f       	mov	r18, r24
    46c2:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    46c4:	c9 01       	movw	r24, r18
    46c6:	0f 90       	pop	r0
    46c8:	cf 91       	pop	r28
    46ca:	df 91       	pop	r29
    46cc:	08 95       	ret

000046ce <uart1GetByte>:
	else
		return -1;
}

int uart1GetByte(void)
{
    46ce:	df 93       	push	r29
    46d0:	cf 93       	push	r28
    46d2:	0f 92       	push	r0
    46d4:	cd b7       	in	r28, 0x3d	; 61
    46d6:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(1,&c))
    46d8:	81 e0       	ldi	r24, 0x01	; 1
    46da:	be 01       	movw	r22, r28
    46dc:	6f 5f       	subi	r22, 0xFF	; 255
    46de:	7f 4f       	sbci	r23, 0xFF	; 255
    46e0:	0e 94 09 23 	call	0x4612	; 0x4612 <uartReceiveByte>
    46e4:	88 23       	and	r24, r24
    46e6:	19 f4       	brne	.+6      	; 0x46ee <uart1GetByte+0x20>
    46e8:	2f ef       	ldi	r18, 0xFF	; 255
    46ea:	3f ef       	ldi	r19, 0xFF	; 255
    46ec:	03 c0       	rjmp	.+6      	; 0x46f4 <uart1GetByte+0x26>
		return c;
    46ee:	89 81       	ldd	r24, Y+1	; 0x01
    46f0:	28 2f       	mov	r18, r24
    46f2:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    46f4:	c9 01       	movw	r24, r18
    46f6:	0f 90       	pop	r0
    46f8:	cf 91       	pop	r28
    46fa:	df 91       	pop	r29
    46fc:	08 95       	ret

000046fe <uart0GetByte>:
	// send byte on UART3
	uartSendByte(3, data);
}

int uart0GetByte(void)
{
    46fe:	df 93       	push	r29
    4700:	cf 93       	push	r28
    4702:	0f 92       	push	r0
    4704:	cd b7       	in	r28, 0x3d	; 61
    4706:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(0,&c))
    4708:	80 e0       	ldi	r24, 0x00	; 0
    470a:	be 01       	movw	r22, r28
    470c:	6f 5f       	subi	r22, 0xFF	; 255
    470e:	7f 4f       	sbci	r23, 0xFF	; 255
    4710:	0e 94 09 23 	call	0x4612	; 0x4612 <uartReceiveByte>
    4714:	88 23       	and	r24, r24
    4716:	19 f4       	brne	.+6      	; 0x471e <uart0GetByte+0x20>
    4718:	2f ef       	ldi	r18, 0xFF	; 255
    471a:	3f ef       	ldi	r19, 0xFF	; 255
    471c:	03 c0       	rjmp	.+6      	; 0x4724 <uart0GetByte+0x26>
		return c;
    471e:	89 81       	ldd	r24, Y+1	; 0x01
    4720:	28 2f       	mov	r18, r24
    4722:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    4724:	c9 01       	movw	r24, r18
    4726:	0f 90       	pop	r0
    4728:	cf 91       	pop	r28
    472a:	df 91       	pop	r29
    472c:	08 95       	ret

0000472e <uartFlushReceiveBuffer>:
}

void uartFlushReceiveBuffer(u08 nUart)
{
	// flush all data from receive buffer
	bufferFlush(&uartRxBuffer[nUart]);
    472e:	90 e0       	ldi	r25, 0x00	; 0
    4730:	e3 e0       	ldi	r30, 0x03	; 3
    4732:	88 0f       	add	r24, r24
    4734:	99 1f       	adc	r25, r25
    4736:	ea 95       	dec	r30
    4738:	e1 f7       	brne	.-8      	; 0x4732 <uartFlushReceiveBuffer+0x4>
    473a:	8d 58       	subi	r24, 0x8D	; 141
    473c:	9b 4e       	sbci	r25, 0xEB	; 235
    473e:	0e 94 04 25 	call	0x4a08	; 0x4a08 <bufferFlush>
}
    4742:	08 95       	ret

00004744 <uart3InitBuffers>:

void uart3InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART3 buffers
		bufferInit(&uartRxBuffer[3], (u08*) uart3RxData, UART3_RX_BUFFER_SIZE);
    4744:	8b e8       	ldi	r24, 0x8B	; 139
    4746:	94 e1       	ldi	r25, 0x14	; 20
    4748:	68 e5       	ldi	r22, 0x58	; 88
    474a:	71 e1       	ldi	r23, 0x11	; 17
    474c:	40 e8       	ldi	r20, 0x80	; 128
    474e:	50 e0       	ldi	r21, 0x00	; 0
    4750:	0e 94 5b 24 	call	0x48b6	; 0x48b6 <bufferInit>
		bufferInit(&uartTxBuffer[3], (u08*) uart3TxData, UART3_TX_BUFFER_SIZE);
    4754:	8f ea       	ldi	r24, 0xAF	; 175
    4756:	94 e1       	ldi	r25, 0x14	; 20
    4758:	68 ed       	ldi	r22, 0xD8	; 216
    475a:	71 e1       	ldi	r23, 0x11	; 17
    475c:	40 e1       	ldi	r20, 0x10	; 16
    475e:	50 e0       	ldi	r21, 0x00	; 0
    4760:	0e 94 5b 24 	call	0x48b6	; 0x48b6 <bufferInit>
	#else
		// initialize the UART3 buffers
		bufferInit(&uartRxBuffer[3], (u08*) UART3_RX_BUFFER_ADDR, UART3_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[3], (u08*) UART3_TX_BUFFER_ADDR, UART3_TX_BUFFER_SIZE);
	#endif
}
    4764:	08 95       	ret

00004766 <uart3Init>:
}

void uart3Init(void)
{
	// initialize the buffers
	uart3InitBuffers();
    4766:	0e 94 a2 23 	call	0x4744	; 0x4744 <uart3InitBuffers>
	// initialize user receive handlers
	UartRxFunc[3] = 0;
    476a:	10 92 ef 11 	sts	0x11EF, r1
    476e:	10 92 ee 11 	sts	0x11EE, r1
	// enable RxD/TxD and interrupts
	outb(UCSR3B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    4772:	88 ed       	ldi	r24, 0xD8	; 216
    4774:	80 93 31 01 	sts	0x0131, r24
	// set default baud rate
	uartSetBaudRate(3, UART3_DEFAULT_BAUD_RATE);
    4778:	83 e0       	ldi	r24, 0x03	; 3
    477a:	40 e8       	ldi	r20, 0x80	; 128
    477c:	55 e2       	ldi	r21, 0x25	; 37
    477e:	60 e0       	ldi	r22, 0x00	; 0
    4780:	70 e0       	ldi	r23, 0x00	; 0
    4782:	0e 94 2c 20 	call	0x4058	; 0x4058 <uartSetBaudRate>
	// initialize states
	uartReadyTx[3] = TRUE;
    4786:	8f ef       	ldi	r24, 0xFF	; 255
    4788:	80 93 72 14 	sts	0x1472, r24
	uartBufferedTx[3] = FALSE;
    478c:	10 92 96 14 	sts	0x1496, r1
	// clear overflow count
	uartRxOverflow[3] = 0;
    4790:	10 92 be 14 	sts	0x14BE, r1
    4794:	10 92 bd 14 	sts	0x14BD, r1
	// enable interrupts
	sei();
    4798:	78 94       	sei
}
    479a:	08 95       	ret

0000479c <uart2InitBuffers>:

void uart2InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART2 buffers
		bufferInit(&uartRxBuffer[2], (u08*) uart2RxData, UART2_RX_BUFFER_SIZE);
    479c:	83 e8       	ldi	r24, 0x83	; 131
    479e:	94 e1       	ldi	r25, 0x14	; 20
    47a0:	68 ec       	ldi	r22, 0xC8	; 200
    47a2:	70 e1       	ldi	r23, 0x10	; 16
    47a4:	40 e8       	ldi	r20, 0x80	; 128
    47a6:	50 e0       	ldi	r21, 0x00	; 0
    47a8:	0e 94 5b 24 	call	0x48b6	; 0x48b6 <bufferInit>
		bufferInit(&uartTxBuffer[2], (u08*) uart2TxData, UART2_TX_BUFFER_SIZE);
    47ac:	87 ea       	ldi	r24, 0xA7	; 167
    47ae:	94 e1       	ldi	r25, 0x14	; 20
    47b0:	68 e4       	ldi	r22, 0x48	; 72
    47b2:	71 e1       	ldi	r23, 0x11	; 17
    47b4:	40 e1       	ldi	r20, 0x10	; 16
    47b6:	50 e0       	ldi	r21, 0x00	; 0
    47b8:	0e 94 5b 24 	call	0x48b6	; 0x48b6 <bufferInit>
	#else
		// initialize the UART2 buffers
		bufferInit(&uartRxBuffer[2], (u08*) UART2_RX_BUFFER_ADDR, UART2_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[2], (u08*) UART2_TX_BUFFER_ADDR, UART2_TX_BUFFER_SIZE);
	#endif
}
    47bc:	08 95       	ret

000047be <uart2Init>:
}

void uart2Init(void)
{
	// initialize the buffers
	uart2InitBuffers();
    47be:	0e 94 ce 23 	call	0x479c	; 0x479c <uart2InitBuffers>
	// initialize user receive handlers
	UartRxFunc[2] = 0;
    47c2:	10 92 ed 11 	sts	0x11ED, r1
    47c6:	10 92 ec 11 	sts	0x11EC, r1
	// enable RxD/TxD and interrupts
	outb(UCSR2B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    47ca:	88 ed       	ldi	r24, 0xD8	; 216
    47cc:	80 93 d1 00 	sts	0x00D1, r24
	// set default baud rate
	uartSetBaudRate(2, UART2_DEFAULT_BAUD_RATE);
    47d0:	82 e0       	ldi	r24, 0x02	; 2
    47d2:	40 e8       	ldi	r20, 0x80	; 128
    47d4:	55 e2       	ldi	r21, 0x25	; 37
    47d6:	60 e0       	ldi	r22, 0x00	; 0
    47d8:	70 e0       	ldi	r23, 0x00	; 0
    47da:	0e 94 2c 20 	call	0x4058	; 0x4058 <uartSetBaudRate>
	// initialize states
	uartReadyTx[2] = TRUE;
    47de:	8f ef       	ldi	r24, 0xFF	; 255
    47e0:	80 93 71 14 	sts	0x1471, r24
	uartBufferedTx[2] = FALSE;
    47e4:	10 92 95 14 	sts	0x1495, r1
	// clear overflow count
	uartRxOverflow[2] = 0;
    47e8:	10 92 bc 14 	sts	0x14BC, r1
    47ec:	10 92 bb 14 	sts	0x14BB, r1
	// enable interrupts
	sei();
    47f0:	78 94       	sei
}
    47f2:	08 95       	ret

000047f4 <uart1InitBuffers>:

void uart1InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART1 buffers
		bufferInit(&uartRxBuffer[1], (u08*) uart1RxData, UART1_RX_BUFFER_SIZE);
    47f4:	8b e7       	ldi	r24, 0x7B	; 123
    47f6:	94 e1       	ldi	r25, 0x14	; 20
    47f8:	68 e3       	ldi	r22, 0x38	; 56
    47fa:	70 e1       	ldi	r23, 0x10	; 16
    47fc:	40 e8       	ldi	r20, 0x80	; 128
    47fe:	50 e0       	ldi	r21, 0x00	; 0
    4800:	0e 94 5b 24 	call	0x48b6	; 0x48b6 <bufferInit>
		bufferInit(&uartTxBuffer[1], (u08*) uart1TxData, UART1_TX_BUFFER_SIZE);
    4804:	8f e9       	ldi	r24, 0x9F	; 159
    4806:	94 e1       	ldi	r25, 0x14	; 20
    4808:	68 eb       	ldi	r22, 0xB8	; 184
    480a:	70 e1       	ldi	r23, 0x10	; 16
    480c:	40 e1       	ldi	r20, 0x10	; 16
    480e:	50 e0       	ldi	r21, 0x00	; 0
    4810:	0e 94 5b 24 	call	0x48b6	; 0x48b6 <bufferInit>
	#else
		// initialize the UART1 buffers
		bufferInit(&uartRxBuffer[1], (u08*) UART1_RX_BUFFER_ADDR, UART1_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[1], (u08*) UART1_TX_BUFFER_ADDR, UART1_TX_BUFFER_SIZE);
	#endif
}
    4814:	08 95       	ret

00004816 <uart1Init>:
}

void uart1Init(void)
{
	// initialize the buffers
	uart1InitBuffers();
    4816:	0e 94 fa 23 	call	0x47f4	; 0x47f4 <uart1InitBuffers>
	// initialize user receive handlers
	UartRxFunc[1] = 0;
    481a:	10 92 eb 11 	sts	0x11EB, r1
    481e:	10 92 ea 11 	sts	0x11EA, r1
	// enable RxD/TxD and interrupts
	outb(UCSR1B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    4822:	88 ed       	ldi	r24, 0xD8	; 216
    4824:	80 93 c9 00 	sts	0x00C9, r24
	// set default baud rate
	uartSetBaudRate(1, UART1_DEFAULT_BAUD_RATE);
    4828:	81 e0       	ldi	r24, 0x01	; 1
    482a:	40 e8       	ldi	r20, 0x80	; 128
    482c:	55 e2       	ldi	r21, 0x25	; 37
    482e:	60 e0       	ldi	r22, 0x00	; 0
    4830:	70 e0       	ldi	r23, 0x00	; 0
    4832:	0e 94 2c 20 	call	0x4058	; 0x4058 <uartSetBaudRate>
	// initialize states
	uartReadyTx[1] = TRUE;
    4836:	8f ef       	ldi	r24, 0xFF	; 255
    4838:	80 93 70 14 	sts	0x1470, r24
	uartBufferedTx[1] = FALSE;
    483c:	10 92 94 14 	sts	0x1494, r1
	// clear overflow count
	uartRxOverflow[1] = 0;
    4840:	10 92 ba 14 	sts	0x14BA, r1
    4844:	10 92 b9 14 	sts	0x14B9, r1
	// enable interrupts
	sei();
    4848:	78 94       	sei
}
    484a:	08 95       	ret

0000484c <uart0InitBuffers>:

void uart0InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART0 buffers
		bufferInit(&uartRxBuffer[0], (u08*) uart0RxData, UART0_RX_BUFFER_SIZE);
    484c:	83 e7       	ldi	r24, 0x73	; 115
    484e:	94 e1       	ldi	r25, 0x14	; 20
    4850:	68 ea       	ldi	r22, 0xA8	; 168
    4852:	7f e0       	ldi	r23, 0x0F	; 15
    4854:	40 e8       	ldi	r20, 0x80	; 128
    4856:	50 e0       	ldi	r21, 0x00	; 0
    4858:	0e 94 5b 24 	call	0x48b6	; 0x48b6 <bufferInit>
		bufferInit(&uartTxBuffer[0], (u08*) uart0TxData, UART0_TX_BUFFER_SIZE);
    485c:	87 e9       	ldi	r24, 0x97	; 151
    485e:	94 e1       	ldi	r25, 0x14	; 20
    4860:	68 e2       	ldi	r22, 0x28	; 40
    4862:	70 e1       	ldi	r23, 0x10	; 16
    4864:	40 e1       	ldi	r20, 0x10	; 16
    4866:	50 e0       	ldi	r21, 0x00	; 0
    4868:	0e 94 5b 24 	call	0x48b6	; 0x48b6 <bufferInit>
	#else
		// initialize the UART0 buffers
		bufferInit(&uartRxBuffer[0], (u08*) UART0_RX_BUFFER_ADDR, UART0_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[0], (u08*) UART0_TX_BUFFER_ADDR, UART0_TX_BUFFER_SIZE);
	#endif
}
    486c:	08 95       	ret

0000486e <uart0Init>:
}

void uart0Init(void)
{
	// initialize the buffers
	uart0InitBuffers();
    486e:	0e 94 26 24 	call	0x484c	; 0x484c <uart0InitBuffers>
	// initialize user receive handlers
	UartRxFunc[0] = 0;
    4872:	10 92 e9 11 	sts	0x11E9, r1
    4876:	10 92 e8 11 	sts	0x11E8, r1
	// enable RxD/TxD and interrupts
	outb(UCSR0B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    487a:	88 ed       	ldi	r24, 0xD8	; 216
    487c:	80 93 c1 00 	sts	0x00C1, r24
	// set default baud rate
	uartSetBaudRate(0, UART0_DEFAULT_BAUD_RATE); 
    4880:	80 e0       	ldi	r24, 0x00	; 0
    4882:	40 e8       	ldi	r20, 0x80	; 128
    4884:	55 e2       	ldi	r21, 0x25	; 37
    4886:	60 e0       	ldi	r22, 0x00	; 0
    4888:	70 e0       	ldi	r23, 0x00	; 0
    488a:	0e 94 2c 20 	call	0x4058	; 0x4058 <uartSetBaudRate>
	// initialize states
	uartReadyTx[0] = TRUE;
    488e:	8f ef       	ldi	r24, 0xFF	; 255
    4890:	80 93 6f 14 	sts	0x146F, r24
	uartBufferedTx[0] = FALSE;
    4894:	10 92 93 14 	sts	0x1493, r1
	// clear overflow count
	uartRxOverflow[0] = 0;
    4898:	10 92 b8 14 	sts	0x14B8, r1
    489c:	10 92 b7 14 	sts	0x14B7, r1
	// enable interrupts
	sei();
    48a0:	78 94       	sei
}
    48a2:	08 95       	ret

000048a4 <uartInit>:
volatile static voidFuncPtru08 UartRxFunc[4];

void uartInit(void)
{
	// initialize all uarts
	uart0Init();
    48a4:	0e 94 37 24 	call	0x486e	; 0x486e <uart0Init>
	uart1Init();
    48a8:	0e 94 0b 24 	call	0x4816	; 0x4816 <uart1Init>
	uart2Init();
    48ac:	0e 94 df 23 	call	0x47be	; 0x47be <uart2Init>
	uart3Init();
    48b0:	0e 94 b3 23 	call	0x4766	; 0x4766 <uart3Init>
}
    48b4:	08 95       	ret

000048b6 <bufferInit>:
// global variables

// initialization

void bufferInit(cBuffer* buffer, unsigned char *start, unsigned short size)
{
    48b6:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    48b8:	8f b7       	in	r24, 0x3f	; 63
    48ba:	f8 94       	cli
	// set start pointer of the buffer
	buffer->dataptr = start;
    48bc:	71 83       	std	Z+1, r23	; 0x01
    48be:	60 83       	st	Z, r22
	buffer->size = size;
    48c0:	53 83       	std	Z+3, r21	; 0x03
    48c2:	42 83       	std	Z+2, r20	; 0x02
	// initialize index and length
	buffer->dataindex = 0;
    48c4:	17 82       	std	Z+7, r1	; 0x07
    48c6:	16 82       	std	Z+6, r1	; 0x06
	buffer->datalength = 0;
    48c8:	15 82       	std	Z+5, r1	; 0x05
    48ca:	14 82       	std	Z+4, r1	; 0x04
	// end critical section
	CRITICAL_SECTION_END;
    48cc:	8f bf       	out	0x3f, r24	; 63
}
    48ce:	08 95       	ret

000048d0 <bufferGetFromFront>:

// access routines
unsigned char  bufferGetFromFront(cBuffer* buffer)
{
    48d0:	dc 01       	movw	r26, r24
	unsigned char data = 0;
	// begin critical section
	CRITICAL_SECTION_START;
    48d2:	4f b7       	in	r20, 0x3f	; 63
    48d4:	f8 94       	cli
	// check to see if there's data in the buffer
	if(buffer->datalength)
    48d6:	14 96       	adiw	r26, 0x04	; 4
    48d8:	8d 91       	ld	r24, X+
    48da:	9c 91       	ld	r25, X
    48dc:	15 97       	sbiw	r26, 0x05	; 5
    48de:	89 2b       	or	r24, r25
    48e0:	11 f4       	brne	.+4      	; 0x48e6 <bufferGetFromFront+0x16>
    48e2:	e0 e0       	ldi	r30, 0x00	; 0
    48e4:	25 c0       	rjmp	.+74     	; 0x4930 <bufferGetFromFront+0x60>
	{
		// get the first character from buffer
		data = buffer->dataptr[buffer->dataindex];
    48e6:	16 96       	adiw	r26, 0x06	; 6
    48e8:	8d 91       	ld	r24, X+
    48ea:	9c 91       	ld	r25, X
    48ec:	17 97       	sbiw	r26, 0x07	; 7
    48ee:	ed 91       	ld	r30, X+
    48f0:	fc 91       	ld	r31, X
    48f2:	11 97       	sbiw	r26, 0x01	; 1
    48f4:	e8 0f       	add	r30, r24
    48f6:	f9 1f       	adc	r31, r25
    48f8:	e0 81       	ld	r30, Z
		// move index down and decrement length
		buffer->dataindex++;
    48fa:	01 96       	adiw	r24, 0x01	; 1
    48fc:	17 96       	adiw	r26, 0x07	; 7
    48fe:	9c 93       	st	X, r25
    4900:	8e 93       	st	-X, r24
    4902:	16 97       	sbiw	r26, 0x06	; 6
		if(buffer->dataindex >= buffer->size)
    4904:	12 96       	adiw	r26, 0x02	; 2
    4906:	2d 91       	ld	r18, X+
    4908:	3c 91       	ld	r19, X
    490a:	13 97       	sbiw	r26, 0x03	; 3
    490c:	82 17       	cp	r24, r18
    490e:	93 07       	cpc	r25, r19
    4910:	30 f0       	brcs	.+12     	; 0x491e <bufferGetFromFront+0x4e>
		{
			buffer->dataindex -= buffer->size;
    4912:	82 1b       	sub	r24, r18
    4914:	93 0b       	sbc	r25, r19
    4916:	17 96       	adiw	r26, 0x07	; 7
    4918:	9c 93       	st	X, r25
    491a:	8e 93       	st	-X, r24
    491c:	16 97       	sbiw	r26, 0x06	; 6
		}
		buffer->datalength--;
    491e:	14 96       	adiw	r26, 0x04	; 4
    4920:	8d 91       	ld	r24, X+
    4922:	9c 91       	ld	r25, X
    4924:	15 97       	sbiw	r26, 0x05	; 5
    4926:	01 97       	sbiw	r24, 0x01	; 1
    4928:	15 96       	adiw	r26, 0x05	; 5
    492a:	9c 93       	st	X, r25
    492c:	8e 93       	st	-X, r24
    492e:	14 97       	sbiw	r26, 0x04	; 4
	}
	// end critical section
	CRITICAL_SECTION_END;
    4930:	4f bf       	out	0x3f, r20	; 63
	// return
	return data;
}
    4932:	8e 2f       	mov	r24, r30
    4934:	08 95       	ret

00004936 <bufferDumpFromFront>:

void bufferDumpFromFront(cBuffer* buffer, unsigned short numbytes)
{
    4936:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    4938:	4f b7       	in	r20, 0x3f	; 63
    493a:	f8 94       	cli
	// dump numbytes from the front of the buffer
	// are we dumping less than the entire buffer?
	if(numbytes < buffer->datalength)
    493c:	84 81       	ldd	r24, Z+4	; 0x04
    493e:	95 81       	ldd	r25, Z+5	; 0x05
    4940:	68 17       	cp	r22, r24
    4942:	79 07       	cpc	r23, r25
    4944:	b0 f4       	brcc	.+44     	; 0x4972 <bufferDumpFromFront+0x3c>
	{
		// move index down by numbytes and decrement length by numbytes
		buffer->dataindex += numbytes;
    4946:	86 81       	ldd	r24, Z+6	; 0x06
    4948:	97 81       	ldd	r25, Z+7	; 0x07
    494a:	86 0f       	add	r24, r22
    494c:	97 1f       	adc	r25, r23
    494e:	97 83       	std	Z+7, r25	; 0x07
    4950:	86 83       	std	Z+6, r24	; 0x06
		if(buffer->dataindex >= buffer->size)
    4952:	22 81       	ldd	r18, Z+2	; 0x02
    4954:	33 81       	ldd	r19, Z+3	; 0x03
    4956:	82 17       	cp	r24, r18
    4958:	93 07       	cpc	r25, r19
    495a:	20 f0       	brcs	.+8      	; 0x4964 <bufferDumpFromFront+0x2e>
		{
			buffer->dataindex -= buffer->size;
    495c:	82 1b       	sub	r24, r18
    495e:	93 0b       	sbc	r25, r19
    4960:	97 83       	std	Z+7, r25	; 0x07
    4962:	86 83       	std	Z+6, r24	; 0x06
		}
		buffer->datalength -= numbytes;
    4964:	84 81       	ldd	r24, Z+4	; 0x04
    4966:	95 81       	ldd	r25, Z+5	; 0x05
    4968:	86 1b       	sub	r24, r22
    496a:	97 0b       	sbc	r25, r23
    496c:	95 83       	std	Z+5, r25	; 0x05
    496e:	84 83       	std	Z+4, r24	; 0x04
    4970:	02 c0       	rjmp	.+4      	; 0x4976 <bufferDumpFromFront+0x40>
	}
	else
	{
		// flush the whole buffer
		buffer->datalength = 0;
    4972:	15 82       	std	Z+5, r1	; 0x05
    4974:	14 82       	std	Z+4, r1	; 0x04
	}
	// end critical section
	CRITICAL_SECTION_END;
    4976:	4f bf       	out	0x3f, r20	; 63
}
    4978:	08 95       	ret

0000497a <bufferGetAtIndex>:

unsigned char bufferGetAtIndex(cBuffer* buffer, unsigned short index)
{
    497a:	fc 01       	movw	r30, r24
    497c:	cb 01       	movw	r24, r22
	// begin critical section
	CRITICAL_SECTION_START;
    497e:	2f b7       	in	r18, 0x3f	; 63
    4980:	f8 94       	cli
	// return character at index in buffer
	unsigned char data = buffer->dataptr[(buffer->dataindex+index)%(buffer->size)];
	// end critical section
	CRITICAL_SECTION_END;
    4982:	2f bf       	out	0x3f, r18	; 63
    4984:	26 81       	ldd	r18, Z+6	; 0x06
    4986:	37 81       	ldd	r19, Z+7	; 0x07
    4988:	62 81       	ldd	r22, Z+2	; 0x02
    498a:	73 81       	ldd	r23, Z+3	; 0x03
    498c:	82 0f       	add	r24, r18
    498e:	93 1f       	adc	r25, r19
    4990:	0e 94 13 2e 	call	0x5c26	; 0x5c26 <__udivmodhi4>
    4994:	01 90       	ld	r0, Z+
    4996:	f0 81       	ld	r31, Z
    4998:	e0 2d       	mov	r30, r0
    499a:	e8 0f       	add	r30, r24
    499c:	f9 1f       	adc	r31, r25
	return data;
}
    499e:	80 81       	ld	r24, Z
    49a0:	08 95       	ret

000049a2 <bufferAddToEnd>:

unsigned char bufferAddToEnd(cBuffer* buffer, unsigned char data)
{
    49a2:	1f 93       	push	r17
    49a4:	cf 93       	push	r28
    49a6:	df 93       	push	r29
    49a8:	ec 01       	movw	r28, r24
    49aa:	16 2f       	mov	r17, r22
	// begin critical section
	CRITICAL_SECTION_START;
    49ac:	4f b7       	in	r20, 0x3f	; 63
    49ae:	f8 94       	cli
	// make sure the buffer has room
	if(buffer->datalength < buffer->size)
    49b0:	2c 81       	ldd	r18, Y+4	; 0x04
    49b2:	3d 81       	ldd	r19, Y+5	; 0x05
    49b4:	6a 81       	ldd	r22, Y+2	; 0x02
    49b6:	7b 81       	ldd	r23, Y+3	; 0x03
    49b8:	26 17       	cp	r18, r22
    49ba:	37 07       	cpc	r19, r23
    49bc:	98 f4       	brcc	.+38     	; 0x49e4 <bufferAddToEnd+0x42>
	{
		// save data byte at end of buffer
		buffer->dataptr[(buffer->dataindex + buffer->datalength) % buffer->size] = data;
    49be:	8e 81       	ldd	r24, Y+6	; 0x06
    49c0:	9f 81       	ldd	r25, Y+7	; 0x07
    49c2:	82 0f       	add	r24, r18
    49c4:	93 1f       	adc	r25, r19
    49c6:	0e 94 13 2e 	call	0x5c26	; 0x5c26 <__udivmodhi4>
    49ca:	e8 81       	ld	r30, Y
    49cc:	f9 81       	ldd	r31, Y+1	; 0x01
    49ce:	e8 0f       	add	r30, r24
    49d0:	f9 1f       	adc	r31, r25
    49d2:	10 83       	st	Z, r17
		// increment the length
		buffer->datalength++;
    49d4:	8c 81       	ldd	r24, Y+4	; 0x04
    49d6:	9d 81       	ldd	r25, Y+5	; 0x05
    49d8:	01 96       	adiw	r24, 0x01	; 1
    49da:	9d 83       	std	Y+5, r25	; 0x05
    49dc:	8c 83       	std	Y+4, r24	; 0x04
		// end critical section
		CRITICAL_SECTION_END;
    49de:	4f bf       	out	0x3f, r20	; 63
    49e0:	8f ef       	ldi	r24, 0xFF	; 255
    49e2:	02 c0       	rjmp	.+4      	; 0x49e8 <bufferAddToEnd+0x46>
		// return success
		return -1;
	}
	// end critical section
	CRITICAL_SECTION_END;
    49e4:	4f bf       	out	0x3f, r20	; 63
    49e6:	80 e0       	ldi	r24, 0x00	; 0
	// return failure
	return 0;
}
    49e8:	df 91       	pop	r29
    49ea:	cf 91       	pop	r28
    49ec:	1f 91       	pop	r17
    49ee:	08 95       	ret

000049f0 <bufferIsNotFull>:

unsigned short bufferIsNotFull(cBuffer* buffer)
{
    49f0:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    49f2:	8f b7       	in	r24, 0x3f	; 63
    49f4:	f8 94       	cli
	// check to see if the buffer has room
	// return true if there is room
	unsigned short bytesleft = (buffer->size - buffer->datalength);
	// end critical section
	CRITICAL_SECTION_END;
    49f6:	8f bf       	out	0x3f, r24	; 63
    49f8:	22 81       	ldd	r18, Z+2	; 0x02
    49fa:	33 81       	ldd	r19, Z+3	; 0x03
    49fc:	84 81       	ldd	r24, Z+4	; 0x04
    49fe:	95 81       	ldd	r25, Z+5	; 0x05
    4a00:	28 1b       	sub	r18, r24
    4a02:	39 0b       	sbc	r19, r25
	return bytesleft;
}
    4a04:	c9 01       	movw	r24, r18
    4a06:	08 95       	ret

00004a08 <bufferFlush>:

void bufferFlush(cBuffer* buffer)
{
    4a08:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    4a0a:	8f b7       	in	r24, 0x3f	; 63
    4a0c:	f8 94       	cli
	// flush contents of the buffer
	buffer->datalength = 0;
    4a0e:	15 82       	std	Z+5, r1	; 0x05
    4a10:	14 82       	std	Z+4, r1	; 0x04
	// end critical section
	CRITICAL_SECTION_END;
    4a12:	8f bf       	out	0x3f, r24	; 63
}
    4a14:	08 95       	ret

00004a16 <a2dInit>:
// functions

// initialize a2d converter
void a2dInit(void)
{
	sbi(ADCSR, ADEN);				// enable ADC (turn on ADC power)
    4a16:	aa e7       	ldi	r26, 0x7A	; 122
    4a18:	b0 e0       	ldi	r27, 0x00	; 0
    4a1a:	8c 91       	ld	r24, X
    4a1c:	80 68       	ori	r24, 0x80	; 128
    4a1e:	8c 93       	st	X, r24
	cbi(ADCSR, ADFR);				// default to single sample convert mode
    4a20:	8c 91       	ld	r24, X
    4a22:	8f 7d       	andi	r24, 0xDF	; 223
    4a24:	8c 93       	st	X, r24
}

// configure A2D converter clock division (prescaling)
void a2dSetPrescaler(unsigned char prescale)
{
	outb(ADCSR, ((inb(ADCSR) & ~ADC_PRESCALE_MASK) | prescale));
    4a26:	8c 91       	ld	r24, X
    4a28:	88 7f       	andi	r24, 0xF8	; 248
    4a2a:	86 60       	ori	r24, 0x06	; 6
    4a2c:	8c 93       	st	X, r24
}

// configure A2D converter voltage reference
void a2dSetReference(unsigned char ref)
{
	outb(ADMUX, ((inb(ADMUX) & ~ADC_REFERENCE_MASK) | (ref<<6)));
    4a2e:	ec e7       	ldi	r30, 0x7C	; 124
    4a30:	f0 e0       	ldi	r31, 0x00	; 0
    4a32:	80 81       	ld	r24, Z
    4a34:	8f 73       	andi	r24, 0x3F	; 63
    4a36:	80 64       	ori	r24, 0x40	; 64
    4a38:	80 83       	st	Z, r24
{
	sbi(ADCSR, ADEN);				// enable ADC (turn on ADC power)
	cbi(ADCSR, ADFR);				// default to single sample convert mode
	a2dSetPrescaler(ADC_PRESCALE);	// set default prescaler
	a2dSetReference(ADC_REFERENCE);	// set default reference
	cbi(ADMUX, ADLAR);				// set to right-adjusted result
    4a3a:	80 81       	ld	r24, Z
    4a3c:	8f 7d       	andi	r24, 0xDF	; 223
    4a3e:	80 83       	st	Z, r24

	sbi(ADCSR, ADIE);				// enable ADC interrupts
    4a40:	8c 91       	ld	r24, X
    4a42:	88 60       	ori	r24, 0x08	; 8
    4a44:	8c 93       	st	X, r24

	a2dCompleteFlag = FALSE;		// clear conversion complete flag
    4a46:	10 92 bf 14 	sts	0x14BF, r1
	sei();							// turn on interrupts (if not already on)
    4a4a:	78 94       	sei
}
    4a4c:	08 95       	ret

00004a4e <a2dOff>:

// turn off a2d converter
void a2dOff(void)
{
	cbi(ADCSR, ADIE);				// disable ADC interrupts
    4a4e:	ea e7       	ldi	r30, 0x7A	; 122
    4a50:	f0 e0       	ldi	r31, 0x00	; 0
    4a52:	80 81       	ld	r24, Z
    4a54:	87 7f       	andi	r24, 0xF7	; 247
    4a56:	80 83       	st	Z, r24
	cbi(ADCSR, ADEN);				// disable ADC (turn off ADC power)
    4a58:	80 81       	ld	r24, Z
    4a5a:	8f 77       	andi	r24, 0x7F	; 127
    4a5c:	80 83       	st	Z, r24
}
    4a5e:	08 95       	ret

00004a60 <a2dSetPrescaler>:

// configure A2D converter clock division (prescaling)
void a2dSetPrescaler(unsigned char prescale)
{
	outb(ADCSR, ((inb(ADCSR) & ~ADC_PRESCALE_MASK) | prescale));
    4a60:	ea e7       	ldi	r30, 0x7A	; 122
    4a62:	f0 e0       	ldi	r31, 0x00	; 0
    4a64:	90 81       	ld	r25, Z
    4a66:	98 7f       	andi	r25, 0xF8	; 248
    4a68:	98 2b       	or	r25, r24
    4a6a:	90 83       	st	Z, r25
}
    4a6c:	08 95       	ret

00004a6e <a2dSetReference>:

// configure A2D converter voltage reference
void a2dSetReference(unsigned char ref)
{
	outb(ADMUX, ((inb(ADMUX) & ~ADC_REFERENCE_MASK) | (ref<<6)));
    4a6e:	ec e7       	ldi	r30, 0x7C	; 124
    4a70:	f0 e0       	ldi	r31, 0x00	; 0
    4a72:	90 81       	ld	r25, Z
    4a74:	82 95       	swap	r24
    4a76:	88 0f       	add	r24, r24
    4a78:	88 0f       	add	r24, r24
    4a7a:	80 7c       	andi	r24, 0xC0	; 192
    4a7c:	9f 73       	andi	r25, 0x3F	; 63
    4a7e:	98 2b       	or	r25, r24
    4a80:	90 83       	st	Z, r25
}
    4a82:	08 95       	ret

00004a84 <a2dSetChannel>:

// sets the a2d input channel
void a2dSetChannel(unsigned char ch)
{
	outb(ADMUX, (inb(ADMUX) & ~ADC_MUX_MASK) | (ch & ADC_MUX_MASK));	// set channel
    4a84:	ec e7       	ldi	r30, 0x7C	; 124
    4a86:	f0 e0       	ldi	r31, 0x00	; 0
    4a88:	90 81       	ld	r25, Z
    4a8a:	8f 71       	andi	r24, 0x1F	; 31
    4a8c:	90 7e       	andi	r25, 0xE0	; 224
    4a8e:	89 2b       	or	r24, r25
    4a90:	80 83       	st	Z, r24
}
    4a92:	08 95       	ret

00004a94 <a2dStartConvert>:

// start a conversion on the current a2d input channel
void a2dStartConvert(void)
{
	sbi(ADCSR, ADIF);	// clear hardware "conversion complete" flag 
    4a94:	ea e7       	ldi	r30, 0x7A	; 122
    4a96:	f0 e0       	ldi	r31, 0x00	; 0
    4a98:	80 81       	ld	r24, Z
    4a9a:	80 61       	ori	r24, 0x10	; 16
    4a9c:	80 83       	st	Z, r24
	sbi(ADCSR, ADSC);	// start conversion
    4a9e:	80 81       	ld	r24, Z
    4aa0:	80 64       	ori	r24, 0x40	; 64
    4aa2:	80 83       	st	Z, r24
}
    4aa4:	08 95       	ret

00004aa6 <a2dIsComplete>:

// return TRUE if conversion is complete
u08 a2dIsComplete(void)
{
	return bit_is_set(ADCSR, ADSC);
    4aa6:	80 91 7a 00 	lds	r24, 0x007A
}
    4aaa:	80 74       	andi	r24, 0x40	; 64
    4aac:	08 95       	ret

00004aae <a2dConvert10bit>:

// Perform a 10-bit conversion
// starts conversion, waits until conversion is done, and returns result
unsigned short a2dConvert10bit(unsigned char ch)
{
    4aae:	98 2f       	mov	r25, r24
	a2dCompleteFlag = FALSE;				// clear conversion complete flag
    4ab0:	10 92 bf 14 	sts	0x14BF, r1

if (ch >= 8)
    4ab4:	88 30       	cpi	r24, 0x08	; 8
    4ab6:	20 f0       	brcs	.+8      	; 0x4ac0 <a2dConvert10bit+0x12>
    ADCSRB |= _BV(MUX5);
    4ab8:	80 91 7b 00 	lds	r24, 0x007B
    4abc:	88 60       	ori	r24, 0x08	; 8
    4abe:	03 c0       	rjmp	.+6      	; 0x4ac6 <a2dConvert10bit+0x18>
else
    ADCSRB &= ~_BV(MUX5);
    4ac0:	80 91 7b 00 	lds	r24, 0x007B
    4ac4:	87 7f       	andi	r24, 0xF7	; 247
    4ac6:	80 93 7b 00 	sts	0x007B, r24

   outb(ADMUX, (inb(ADMUX) & ~7) | (ch & 7));   // set channel
    4aca:	80 91 7c 00 	lds	r24, 0x007C
    4ace:	97 70       	andi	r25, 0x07	; 7
    4ad0:	88 7f       	andi	r24, 0xF8	; 248
    4ad2:	89 2b       	or	r24, r25
    4ad4:	80 93 7c 00 	sts	0x007C, r24

	//outb(ADMUX, (inb(ADMUX) & ~ADC_MUX_MASK) | (ch & ADC_MUX_MASK));	// set channel
	sbi(ADCSR, ADIF);						// clear hardware "conversion complete" flag 
    4ad8:	80 91 7a 00 	lds	r24, 0x007A
    4adc:	80 61       	ori	r24, 0x10	; 16
    4ade:	80 93 7a 00 	sts	0x007A, r24
	sbi(ADCSR, ADSC);						// start conversion
    4ae2:	80 91 7a 00 	lds	r24, 0x007A
    4ae6:	80 64       	ori	r24, 0x40	; 64
    4ae8:	80 93 7a 00 	sts	0x007A, r24
	//while(!a2dCompleteFlag);				// wait until conversion complete
	//while( bit_is_clear(ADCSR, ADIF) );		// wait until conversion complete
	while( bit_is_set(ADCSR, ADSC) );		// wait until conversion complete
    4aec:	80 91 7a 00 	lds	r24, 0x007A
    4af0:	86 fd       	sbrc	r24, 6
    4af2:	fc cf       	rjmp	.-8      	; 0x4aec <a2dConvert10bit+0x3e>

	// CAUTION: MUST READ ADCL BEFORE ADCH!!!
	//return (inb(ADCL) | (inb(ADCH)<<8));	// read ADC (full 10 bits) //old version
	return ADC;//new version code
    4af4:	20 91 78 00 	lds	r18, 0x0078
    4af8:	30 91 79 00 	lds	r19, 0x0079
}
    4afc:	c9 01       	movw	r24, r18
    4afe:	08 95       	ret

00004b00 <a2dConvert8bit>:
// Perform a 8-bit conversion.
// starts conversion, waits until conversion is done, and returns result
unsigned char a2dConvert8bit(unsigned char ch)
{
	// do 10-bit conversion and return highest 8 bits
	return a2dConvert10bit(ch)>>2;			// return ADC MSB byte
    4b00:	0e 94 57 25 	call	0x4aae	; 0x4aae <a2dConvert10bit>
    4b04:	96 95       	lsr	r25
    4b06:	87 95       	ror	r24
    4b08:	96 95       	lsr	r25
    4b0a:	87 95       	ror	r24
}
    4b0c:	08 95       	ret

00004b0e <__vector_29>:

//! Interrupt handler for ADC complete interrupt.
SIGNAL(SIG_ADC)
{
    4b0e:	1f 92       	push	r1
    4b10:	0f 92       	push	r0
    4b12:	0f b6       	in	r0, 0x3f	; 63
    4b14:	0f 92       	push	r0
    4b16:	11 24       	eor	r1, r1
    4b18:	8f 93       	push	r24
	// set the a2d conversion flag to indicate "complete"
	a2dCompleteFlag = TRUE;
    4b1a:	8f ef       	ldi	r24, 0xFF	; 255
    4b1c:	80 93 bf 14 	sts	0x14BF, r24
}
    4b20:	8f 91       	pop	r24
    4b22:	0f 90       	pop	r0
    4b24:	0f be       	out	0x3f, r0	; 63
    4b26:	0f 90       	pop	r0
    4b28:	1f 90       	pop	r1
    4b2a:	18 95       	reti

00004b2c <rprintfInit>:
// *** rprintf initialization ***
// you must call this function once and supply the character output
// routine before using other functions in this library
void rprintfInit(void (*putchar_func)(unsigned char c))
{
	rputchar = putchar_func;
    4b2c:	90 93 f1 11 	sts	0x11F1, r25
    4b30:	80 93 f0 11 	sts	0x11F0, r24
}
    4b34:	08 95       	ret

00004b36 <rprintfChar>:

// *** rprintfChar ***
// send a character/byte to the current output device
void rprintfChar(unsigned char c)
{
    4b36:	1f 93       	push	r17
    4b38:	18 2f       	mov	r17, r24
	// do LF -> CR/LF translation
	if(c == '\n')
    4b3a:	8a 30       	cpi	r24, 0x0A	; 10
    4b3c:	31 f4       	brne	.+12     	; 0x4b4a <rprintfChar+0x14>
		rputchar('\r');
    4b3e:	e0 91 f0 11 	lds	r30, 0x11F0
    4b42:	f0 91 f1 11 	lds	r31, 0x11F1
    4b46:	8d e0       	ldi	r24, 0x0D	; 13
    4b48:	09 95       	icall
	// send character
	rputchar(c);
    4b4a:	e0 91 f0 11 	lds	r30, 0x11F0
    4b4e:	f0 91 f1 11 	lds	r31, 0x11F1
    4b52:	81 2f       	mov	r24, r17
    4b54:	09 95       	icall
}
    4b56:	1f 91       	pop	r17
    4b58:	08 95       	ret

00004b5a <rprintfStr>:

// *** rprintfStr ***
// prints a null-terminated string stored in RAM
void rprintfStr(char str[])
{
    4b5a:	cf 93       	push	r28
    4b5c:	df 93       	push	r29
    4b5e:	ec 01       	movw	r28, r24
	// send a string stored in RAM
	// check to make sure we have a good pointer
	if (!str) return;
    4b60:	00 97       	sbiw	r24, 0x00	; 0
    4b62:	21 f4       	brne	.+8      	; 0x4b6c <rprintfStr+0x12>
    4b64:	06 c0       	rjmp	.+12     	; 0x4b72 <rprintfStr+0x18>

	// print the string until a null-terminator
	while (*str)
		rprintfChar(*str++);
    4b66:	21 96       	adiw	r28, 0x01	; 1
    4b68:	0e 94 9b 25 	call	0x4b36	; 0x4b36 <rprintfChar>
	// send a string stored in RAM
	// check to make sure we have a good pointer
	if (!str) return;

	// print the string until a null-terminator
	while (*str)
    4b6c:	88 81       	ld	r24, Y
    4b6e:	88 23       	and	r24, r24
    4b70:	d1 f7       	brne	.-12     	; 0x4b66 <rprintfStr+0xc>
		rprintfChar(*str++);
}
    4b72:	df 91       	pop	r29
    4b74:	cf 91       	pop	r28
    4b76:	08 95       	ret

00004b78 <rprintfStrLen>:
// *** rprintfStrLen ***
// prints a section of a string stored in RAM
// begins printing at position indicated by <start>
// prints number of characters indicated by <len>
void rprintfStrLen(char str[], unsigned int start, unsigned int len)
{
    4b78:	ef 92       	push	r14
    4b7a:	ff 92       	push	r15
    4b7c:	0f 93       	push	r16
    4b7e:	1f 93       	push	r17
    4b80:	cf 93       	push	r28
    4b82:	df 93       	push	r29
    4b84:	8c 01       	movw	r16, r24
    4b86:	7a 01       	movw	r14, r20
	register int i=0;

	// check to make sure we have a good pointer
	if (!str) return;
    4b88:	00 97       	sbiw	r24, 0x00	; 0
    4b8a:	e9 f0       	breq	.+58     	; 0x4bc6 <rprintfStrLen+0x4e>
    4b8c:	20 e0       	ldi	r18, 0x00	; 0
    4b8e:	30 e0       	ldi	r19, 0x00	; 0
	// spin through characters up to requested start
	// keep going as long as there's no null
	while((i++<start) && (*str++));
    4b90:	26 17       	cp	r18, r22
    4b92:	37 07       	cpc	r19, r23
    4b94:	38 f4       	brcc	.+14     	; 0x4ba4 <rprintfStrLen+0x2c>
    4b96:	f8 01       	movw	r30, r16
    4b98:	81 91       	ld	r24, Z+
    4b9a:	8f 01       	movw	r16, r30
    4b9c:	2f 5f       	subi	r18, 0xFF	; 255
    4b9e:	3f 4f       	sbci	r19, 0xFF	; 255
    4ba0:	88 23       	and	r24, r24
    4ba2:	b1 f7       	brne	.-20     	; 0x4b90 <rprintfStrLen+0x18>
    4ba4:	c0 e0       	ldi	r28, 0x00	; 0
    4ba6:	d0 e0       	ldi	r29, 0x00	; 0
    4ba8:	0b c0       	rjmp	.+22     	; 0x4bc0 <rprintfStrLen+0x48>
	// then print exactly len characters
	for(i=0; i<len; i++)
	{
		// print data out of the string as long as we haven't reached a null yet
		// at the null, start printing spaces
		if(*str)
    4baa:	f8 01       	movw	r30, r16
    4bac:	80 81       	ld	r24, Z
    4bae:	88 23       	and	r24, r24
    4bb0:	19 f0       	breq	.+6      	; 0x4bb8 <rprintfStrLen+0x40>
			rprintfChar(*str++);
    4bb2:	0f 5f       	subi	r16, 0xFF	; 255
    4bb4:	1f 4f       	sbci	r17, 0xFF	; 255
    4bb6:	01 c0       	rjmp	.+2      	; 0x4bba <rprintfStrLen+0x42>
		else
			rprintfChar(' ');
    4bb8:	80 e2       	ldi	r24, 0x20	; 32
    4bba:	0e 94 9b 25 	call	0x4b36	; 0x4b36 <rprintfChar>
//		// keep steping through string as long as there's no null
//		if(*str) str++;
//	}

	// then print exactly len characters
	for(i=0; i<len; i++)
    4bbe:	21 96       	adiw	r28, 0x01	; 1
    4bc0:	ce 15       	cp	r28, r14
    4bc2:	df 05       	cpc	r29, r15
    4bc4:	90 f3       	brcs	.-28     	; 0x4baa <rprintfStrLen+0x32>
			rprintfChar(*str++);
		else
			rprintfChar(' ');
	}

}
    4bc6:	df 91       	pop	r29
    4bc8:	cf 91       	pop	r28
    4bca:	1f 91       	pop	r17
    4bcc:	0f 91       	pop	r16
    4bce:	ff 90       	pop	r15
    4bd0:	ef 90       	pop	r14
    4bd2:	08 95       	ret

00004bd4 <rprintfProgStr>:

// *** rprintfProgStr ***
// prints a null-terminated string stored in program ROM
void rprintfProgStr(const prog_char str[])
{
    4bd4:	cf 93       	push	r28
    4bd6:	df 93       	push	r29
    4bd8:	ec 01       	movw	r28, r24
	// print a string stored in program memory
	register char c;

	// check to make sure we have a good pointer
	if (!str) return;
    4bda:	00 97       	sbiw	r24, 0x00	; 0
    4bdc:	19 f4       	brne	.+6      	; 0x4be4 <rprintfProgStr+0x10>
    4bde:	07 c0       	rjmp	.+14     	; 0x4bee <rprintfProgStr+0x1a>
	
	// print the string until the null-terminator
	while((c = pgm_read_byte(str++)))
		rprintfChar(c);
    4be0:	0e 94 9b 25 	call	0x4b36	; 0x4b36 <rprintfChar>
    4be4:	fe 01       	movw	r30, r28

	// check to make sure we have a good pointer
	if (!str) return;
	
	// print the string until the null-terminator
	while((c = pgm_read_byte(str++)))
    4be6:	21 96       	adiw	r28, 0x01	; 1
    4be8:	84 91       	lpm	r24, Z+
    4bea:	88 23       	and	r24, r24
    4bec:	c9 f7       	brne	.-14     	; 0x4be0 <rprintfProgStr+0xc>
		rprintfChar(c);
}
    4bee:	df 91       	pop	r29
    4bf0:	cf 91       	pop	r28
    4bf2:	08 95       	ret

00004bf4 <rprintfCRLF>:
void rprintfCRLF(void)
{
	// print CR/LF
	//rprintfChar('\r');
	// LF -> CR/LF translation built-in to rprintfChar()
	rprintfChar('\n');
    4bf4:	8a e0       	ldi	r24, 0x0A	; 10
    4bf6:	0e 94 9b 25 	call	0x4b36	; 0x4b36 <rprintfChar>
}
    4bfa:	08 95       	ret

00004bfc <rprintfu04>:
//	char Character = data&0x0f;
//	if (Character>9)
//		Character+='A'-10;
//	else
//		Character+='0';
	rprintfChar(hexchar(data));
    4bfc:	e8 2f       	mov	r30, r24
    4bfe:	f0 e0       	ldi	r31, 0x00	; 0
    4c00:	ef 70       	andi	r30, 0x0F	; 15
    4c02:	f0 70       	andi	r31, 0x00	; 0
    4c04:	e5 54       	subi	r30, 0x45	; 69
    4c06:	fe 4f       	sbci	r31, 0xFE	; 254
    4c08:	e4 91       	lpm	r30, Z+
    4c0a:	8e 2f       	mov	r24, r30
    4c0c:	0e 94 9b 25 	call	0x4b36	; 0x4b36 <rprintfChar>
}
    4c10:	08 95       	ret

00004c12 <rprintfu08>:

// *** rprintfu08 ***
// prints an unsigned 8-bit number in hex (2 digits)
void rprintfu08(unsigned char data)
{
    4c12:	1f 93       	push	r17
    4c14:	18 2f       	mov	r17, r24
	// print 8-bit hex value
	rprintfu04(data>>4);
    4c16:	82 95       	swap	r24
    4c18:	8f 70       	andi	r24, 0x0F	; 15
    4c1a:	0e 94 fe 25 	call	0x4bfc	; 0x4bfc <rprintfu04>
	rprintfu04(data);
    4c1e:	81 2f       	mov	r24, r17
    4c20:	0e 94 fe 25 	call	0x4bfc	; 0x4bfc <rprintfu04>
}
    4c24:	1f 91       	pop	r17
    4c26:	08 95       	ret

00004c28 <rprintfu16>:

// *** rprintfu16 ***
// prints an unsigned 16-bit number in hex (4 digits)
void rprintfu16(unsigned short data)
{
    4c28:	1f 93       	push	r17
    4c2a:	18 2f       	mov	r17, r24
	// print 16-bit hex value
	rprintfu08(data>>8);
    4c2c:	89 2f       	mov	r24, r25
    4c2e:	0e 94 09 26 	call	0x4c12	; 0x4c12 <rprintfu08>
	rprintfu08(data);
    4c32:	81 2f       	mov	r24, r17
    4c34:	0e 94 09 26 	call	0x4c12	; 0x4c12 <rprintfu08>
}
    4c38:	1f 91       	pop	r17
    4c3a:	08 95       	ret

00004c3c <rprintfu32>:

// *** rprintfu32 ***
// prints an unsigned 32-bit number in hex (8 digits)
void rprintfu32(unsigned long data)
{
    4c3c:	ef 92       	push	r14
    4c3e:	ff 92       	push	r15
    4c40:	0f 93       	push	r16
    4c42:	1f 93       	push	r17
    4c44:	7b 01       	movw	r14, r22
    4c46:	8c 01       	movw	r16, r24
	// print 32-bit hex value
	rprintfu16(data>>16);
    4c48:	c8 01       	movw	r24, r16
    4c4a:	aa 27       	eor	r26, r26
    4c4c:	bb 27       	eor	r27, r27
    4c4e:	0e 94 14 26 	call	0x4c28	; 0x4c28 <rprintfu16>
	rprintfu16(data);
    4c52:	c7 01       	movw	r24, r14
    4c54:	0e 94 14 26 	call	0x4c28	; 0x4c28 <rprintfu16>
}
    4c58:	1f 91       	pop	r17
    4c5a:	0f 91       	pop	r16
    4c5c:	ff 90       	pop	r15
    4c5e:	ef 90       	pop	r14
    4c60:	08 95       	ret

00004c62 <rprintfNum>:
//	Examples:
//	uartPrintfNum(10, 6,  TRUE, ' ',   1234);  -->  " +1234"
//	uartPrintfNum(10, 6, FALSE, '0',   1234);  -->  "001234"
//	uartPrintfNum(16, 6, FALSE, '.', 0x5AA5);  -->  "..5AA5"
void rprintfNum(char base, char numDigits, char isSigned, char padchar, long n)
{
    4c62:	2f 92       	push	r2
    4c64:	3f 92       	push	r3
    4c66:	4f 92       	push	r4
    4c68:	5f 92       	push	r5
    4c6a:	6f 92       	push	r6
    4c6c:	7f 92       	push	r7
    4c6e:	8f 92       	push	r8
    4c70:	9f 92       	push	r9
    4c72:	af 92       	push	r10
    4c74:	bf 92       	push	r11
    4c76:	cf 92       	push	r12
    4c78:	df 92       	push	r13
    4c7a:	ef 92       	push	r14
    4c7c:	ff 92       	push	r15
    4c7e:	0f 93       	push	r16
    4c80:	1f 93       	push	r17
    4c82:	df 93       	push	r29
    4c84:	cf 93       	push	r28
    4c86:	cd b7       	in	r28, 0x3d	; 61
    4c88:	de b7       	in	r29, 0x3e	; 62
    4c8a:	a3 97       	sbiw	r28, 0x23	; 35
    4c8c:	0f b6       	in	r0, 0x3f	; 63
    4c8e:	f8 94       	cli
    4c90:	de bf       	out	0x3e, r29	; 62
    4c92:	0f be       	out	0x3f, r0	; 63
    4c94:	cd bf       	out	0x3d, r28	; 61
    4c96:	6a a3       	std	Y+34, r22	; 0x22
    4c98:	24 2e       	mov	r2, r20
    4c9a:	2b a3       	std	Y+35, r18	; 0x23
    4c9c:	37 01       	movw	r6, r14
    4c9e:	48 01       	movw	r8, r16
	char *p, buf[32];
	unsigned long x;
	unsigned char count;

	// prepare negative number
	if( isSigned && (n < 0) )
    4ca0:	44 23       	and	r20, r20
    4ca2:	51 f0       	breq	.+20     	; 0x4cb8 <rprintfNum+0x56>
    4ca4:	17 ff       	sbrs	r17, 7
    4ca6:	08 c0       	rjmp	.+16     	; 0x4cb8 <rprintfNum+0x56>
	{
		x = -n;
    4ca8:	ee 24       	eor	r14, r14
    4caa:	ff 24       	eor	r15, r15
    4cac:	87 01       	movw	r16, r14
    4cae:	e6 18       	sub	r14, r6
    4cb0:	f7 08       	sbc	r15, r7
    4cb2:	08 09       	sbc	r16, r8
    4cb4:	19 09       	sbc	r17, r9
    4cb6:	02 c0       	rjmp	.+4      	; 0x4cbc <rprintfNum+0x5a>
	}
	else
	{
	 	x = n;
    4cb8:	84 01       	movw	r16, r8
    4cba:	73 01       	movw	r14, r6
	}

	// setup little string buffer
	count = (numDigits-1)-(isSigned?1:0);
    4cbc:	2a a1       	ldd	r18, Y+34	; 0x22
    4cbe:	21 50       	subi	r18, 0x01	; 1
    4cc0:	90 e0       	ldi	r25, 0x00	; 0
    4cc2:	21 10       	cpse	r2, r1
    4cc4:	91 e0       	ldi	r25, 0x01	; 1
    4cc6:	29 1b       	sub	r18, r25
    4cc8:	29 a3       	std	Y+33, r18	; 0x21
  	p = buf + sizeof (buf);
  	*--p = '\0';
    4cca:	18 a2       	std	Y+32, r1	; 0x20
	
	// force calculation of first digit
	// (to prevent zero from not printing at all!!!)
	*--p = hexchar(x%base); x /= base;
    4ccc:	a8 2e       	mov	r10, r24
    4cce:	bb 24       	eor	r11, r11
    4cd0:	cc 24       	eor	r12, r12
    4cd2:	dd 24       	eor	r13, r13
    4cd4:	c8 01       	movw	r24, r16
    4cd6:	b7 01       	movw	r22, r14
    4cd8:	a6 01       	movw	r20, r12
    4cda:	95 01       	movw	r18, r10
    4cdc:	0e 94 3a 2e 	call	0x5c74	; 0x5c74 <__udivmodsi4>
    4ce0:	fb 01       	movw	r30, r22
    4ce2:	ef 70       	andi	r30, 0x0F	; 15
    4ce4:	f0 70       	andi	r31, 0x00	; 0
    4ce6:	e5 54       	subi	r30, 0x45	; 69
    4ce8:	fe 4f       	sbci	r31, 0xFE	; 254
    4cea:	64 91       	lpm	r22, Z+
    4cec:	6f 8f       	std	Y+31, r22	; 0x1f
    4cee:	c8 01       	movw	r24, r16
    4cf0:	b7 01       	movw	r22, r14
    4cf2:	a6 01       	movw	r20, r12
    4cf4:	95 01       	movw	r18, r10
    4cf6:	0e 94 3a 2e 	call	0x5c74	; 0x5c74 <__udivmodsi4>
    4cfa:	c9 01       	movw	r24, r18
    4cfc:	da 01       	movw	r26, r20
    4cfe:	7c 01       	movw	r14, r24
    4d00:	8d 01       	movw	r16, r26
    4d02:	9e e1       	ldi	r25, 0x1E	; 30
    4d04:	49 2e       	mov	r4, r25
    4d06:	51 2c       	mov	r5, r1
    4d08:	4c 0e       	add	r4, r28
    4d0a:	5d 1e       	adc	r5, r29
    4d0c:	39 a0       	ldd	r3, Y+33	; 0x21
    4d0e:	25 c0       	rjmp	.+74     	; 0x4d5a <rprintfNum+0xf8>
	// calculate remaining digits
	while(count--)
	{
		if(x != 0)
    4d10:	e1 14       	cp	r14, r1
    4d12:	f1 04       	cpc	r15, r1
    4d14:	01 05       	cpc	r16, r1
    4d16:	11 05       	cpc	r17, r1
    4d18:	c9 f0       	breq	.+50     	; 0x4d4c <rprintfNum+0xea>
		{
			// calculate next digit
			*--p = hexchar(x%base); x /= base;
    4d1a:	c8 01       	movw	r24, r16
    4d1c:	b7 01       	movw	r22, r14
    4d1e:	a6 01       	movw	r20, r12
    4d20:	95 01       	movw	r18, r10
    4d22:	0e 94 3a 2e 	call	0x5c74	; 0x5c74 <__udivmodsi4>
    4d26:	fb 01       	movw	r30, r22
    4d28:	ef 70       	andi	r30, 0x0F	; 15
    4d2a:	f0 70       	andi	r31, 0x00	; 0
    4d2c:	e5 54       	subi	r30, 0x45	; 69
    4d2e:	fe 4f       	sbci	r31, 0xFE	; 254
    4d30:	64 91       	lpm	r22, Z+
    4d32:	f2 01       	movw	r30, r4
    4d34:	60 83       	st	Z, r22
    4d36:	c8 01       	movw	r24, r16
    4d38:	b7 01       	movw	r22, r14
    4d3a:	a6 01       	movw	r20, r12
    4d3c:	95 01       	movw	r18, r10
    4d3e:	0e 94 3a 2e 	call	0x5c74	; 0x5c74 <__udivmodsi4>
    4d42:	c9 01       	movw	r24, r18
    4d44:	da 01       	movw	r26, r20
    4d46:	7c 01       	movw	r14, r24
    4d48:	8d 01       	movw	r16, r26
    4d4a:	03 c0       	rjmp	.+6      	; 0x4d52 <rprintfNum+0xf0>
		}
		else
		{
			// no more digits left, pad out to desired length
			*--p = padchar;
    4d4c:	2b a1       	ldd	r18, Y+35	; 0x23
    4d4e:	f2 01       	movw	r30, r4
    4d50:	20 83       	st	Z, r18
    4d52:	3a 94       	dec	r3
    4d54:	08 94       	sec
    4d56:	41 08       	sbc	r4, r1
    4d58:	51 08       	sbc	r5, r1
	
	// force calculation of first digit
	// (to prevent zero from not printing at all!!!)
	*--p = hexchar(x%base); x /= base;
	// calculate remaining digits
	while(count--)
    4d5a:	33 20       	and	r3, r3
    4d5c:	c9 f6       	brne	.-78     	; 0x4d10 <rprintfNum+0xae>
    4d5e:	ce 01       	movw	r24, r28
    4d60:	4f 96       	adiw	r24, 0x1f	; 31
    4d62:	8c 01       	movw	r16, r24
    4d64:	e9 a1       	ldd	r30, Y+33	; 0x21
    4d66:	0e 1b       	sub	r16, r30
    4d68:	11 09       	sbc	r17, r1
			*--p = padchar;
		}
	}

	// apply signed notation if requested
	if( isSigned )
    4d6a:	22 20       	and	r2, r2
    4d6c:	f1 f0       	breq	.+60     	; 0x4daa <rprintfNum+0x148>
	{
		if(n < 0)
    4d6e:	97 fe       	sbrs	r9, 7
    4d70:	05 c0       	rjmp	.+10     	; 0x4d7c <rprintfNum+0x11a>
		{
   			*--p = '-';
    4d72:	8d e2       	ldi	r24, 0x2D	; 45
    4d74:	f8 01       	movw	r30, r16
    4d76:	82 93       	st	-Z, r24
    4d78:	8f 01       	movw	r16, r30
    4d7a:	17 c0       	rjmp	.+46     	; 0x4daa <rprintfNum+0x148>
    4d7c:	c8 01       	movw	r24, r16
    4d7e:	01 97       	sbiw	r24, 0x01	; 1
		}
		else if(n > 0)
    4d80:	61 14       	cp	r6, r1
    4d82:	71 04       	cpc	r7, r1
    4d84:	81 04       	cpc	r8, r1
    4d86:	91 04       	cpc	r9, r1
    4d88:	19 f0       	breq	.+6      	; 0x4d90 <rprintfNum+0x12e>
		{
	   		*--p = '+';
    4d8a:	8c 01       	movw	r16, r24
    4d8c:	8b e2       	ldi	r24, 0x2B	; 43
    4d8e:	02 c0       	rjmp	.+4      	; 0x4d94 <rprintfNum+0x132>
		}
		else
		{
	   		*--p = ' ';
    4d90:	8c 01       	movw	r16, r24
    4d92:	80 e2       	ldi	r24, 0x20	; 32
    4d94:	f8 01       	movw	r30, r16
    4d96:	80 83       	st	Z, r24
    4d98:	08 c0       	rjmp	.+16     	; 0x4daa <rprintfNum+0x148>

	// print the string right-justified
	count = numDigits;
	while(count--)
	{
		rprintfChar(*p++);
    4d9a:	f8 01       	movw	r30, r16
    4d9c:	81 91       	ld	r24, Z+
    4d9e:	8f 01       	movw	r16, r30
    4da0:	0e 94 9b 25 	call	0x4b36	; 0x4b36 <rprintfChar>
    4da4:	fa a1       	ldd	r31, Y+34	; 0x22
    4da6:	f1 50       	subi	r31, 0x01	; 1
    4da8:	fa a3       	std	Y+34, r31	; 0x22
		}
	}

	// print the string right-justified
	count = numDigits;
	while(count--)
    4daa:	2a a1       	ldd	r18, Y+34	; 0x22
    4dac:	22 23       	and	r18, r18
    4dae:	a9 f7       	brne	.-22     	; 0x4d9a <rprintfNum+0x138>
	{
		rprintfChar(*p++);
	}
}
    4db0:	a3 96       	adiw	r28, 0x23	; 35
    4db2:	0f b6       	in	r0, 0x3f	; 63
    4db4:	f8 94       	cli
    4db6:	de bf       	out	0x3e, r29	; 62
    4db8:	0f be       	out	0x3f, r0	; 63
    4dba:	cd bf       	out	0x3d, r28	; 61
    4dbc:	cf 91       	pop	r28
    4dbe:	df 91       	pop	r29
    4dc0:	1f 91       	pop	r17
    4dc2:	0f 91       	pop	r16
    4dc4:	ff 90       	pop	r15
    4dc6:	ef 90       	pop	r14
    4dc8:	df 90       	pop	r13
    4dca:	cf 90       	pop	r12
    4dcc:	bf 90       	pop	r11
    4dce:	af 90       	pop	r10
    4dd0:	9f 90       	pop	r9
    4dd2:	8f 90       	pop	r8
    4dd4:	7f 90       	pop	r7
    4dd6:	6f 90       	pop	r6
    4dd8:	5f 90       	pop	r5
    4dda:	4f 90       	pop	r4
    4ddc:	3f 90       	pop	r3
    4dde:	2f 90       	pop	r2
    4de0:	08 95       	ret

00004de2 <rprintfFloat>:

#ifdef RPRINTF_FLOAT
// *** rprintfFloat ***
// floating-point print
void rprintfFloat(char numDigits, double x)
{
    4de2:	4f 92       	push	r4
    4de4:	5f 92       	push	r5
    4de6:	6f 92       	push	r6
    4de8:	7f 92       	push	r7
    4dea:	8f 92       	push	r8
    4dec:	9f 92       	push	r9
    4dee:	af 92       	push	r10
    4df0:	bf 92       	push	r11
    4df2:	cf 92       	push	r12
    4df4:	df 92       	push	r13
    4df6:	ef 92       	push	r14
    4df8:	ff 92       	push	r15
    4dfa:	0f 93       	push	r16
    4dfc:	1f 93       	push	r17
    4dfe:	cf 93       	push	r28
    4e00:	df 93       	push	r29
    4e02:	48 2e       	mov	r4, r24
    4e04:	5a 01       	movw	r10, r20
    4e06:	6b 01       	movw	r12, r22
	double place = 1.0;
	
	// save sign
	negative = (x<0);
	// convert to absolute value
	x = (x>0)?(x):(-x);
    4e08:	cb 01       	movw	r24, r22
    4e0a:	ba 01       	movw	r22, r20
    4e0c:	20 e0       	ldi	r18, 0x00	; 0
    4e0e:	30 e0       	ldi	r19, 0x00	; 0
    4e10:	40 e0       	ldi	r20, 0x00	; 0
    4e12:	50 e0       	ldi	r21, 0x00	; 0
    4e14:	0e 94 83 2d 	call	0x5b06	; 0x5b06 <__gesf2>
    4e18:	18 16       	cp	r1, r24
    4e1a:	1c f4       	brge	.+6      	; 0x4e22 <rprintfFloat+0x40>
    4e1c:	35 01       	movw	r6, r10
    4e1e:	46 01       	movw	r8, r12
    4e20:	06 c0       	rjmp	.+12     	; 0x4e2e <rprintfFloat+0x4c>
    4e22:	35 01       	movw	r6, r10
    4e24:	46 01       	movw	r8, r12
    4e26:	97 fa       	bst	r9, 7
    4e28:	90 94       	com	r9
    4e2a:	97 f8       	bld	r9, 7
    4e2c:	90 94       	com	r9
    4e2e:	0f 2e       	mov	r0, r31
    4e30:	f0 e0       	ldi	r31, 0x00	; 0
    4e32:	ef 2e       	mov	r14, r31
    4e34:	f0 e0       	ldi	r31, 0x00	; 0
    4e36:	ff 2e       	mov	r15, r31
    4e38:	f0 e8       	ldi	r31, 0x80	; 128
    4e3a:	0f 2f       	mov	r16, r31
    4e3c:	ff e3       	ldi	r31, 0x3F	; 63
    4e3e:	1f 2f       	mov	r17, r31
    4e40:	f0 2d       	mov	r31, r0
    4e42:	55 24       	eor	r5, r5
	
	// find starting digit place
	for(i=0; i<15; i++)
	{
		if((x/place) < 10.0)
    4e44:	c4 01       	movw	r24, r8
    4e46:	b3 01       	movw	r22, r6
    4e48:	a8 01       	movw	r20, r16
    4e4a:	97 01       	movw	r18, r14
    4e4c:	0e 94 be 2b 	call	0x577c	; 0x577c <__divsf3>
    4e50:	20 e0       	ldi	r18, 0x00	; 0
    4e52:	30 e0       	ldi	r19, 0x00	; 0
    4e54:	40 e2       	ldi	r20, 0x20	; 32
    4e56:	51 e4       	ldi	r21, 0x41	; 65
    4e58:	0e 94 ba 2b 	call	0x5774	; 0x5774 <__cmpsf2>
    4e5c:	87 fd       	sbrc	r24, 7
    4e5e:	0e c0       	rjmp	.+28     	; 0x4e7c <rprintfFloat+0x9a>
			break;
		else
			place *= 10.0;
    4e60:	c8 01       	movw	r24, r16
    4e62:	b7 01       	movw	r22, r14
    4e64:	20 e0       	ldi	r18, 0x00	; 0
    4e66:	30 e0       	ldi	r19, 0x00	; 0
    4e68:	40 e2       	ldi	r20, 0x20	; 32
    4e6a:	51 e4       	ldi	r21, 0x41	; 65
    4e6c:	0e 94 8e 2d 	call	0x5b1c	; 0x5b1c <__mulsf3>
    4e70:	7b 01       	movw	r14, r22
    4e72:	8c 01       	movw	r16, r24
	negative = (x<0);
	// convert to absolute value
	x = (x>0)?(x):(-x);
	
	// find starting digit place
	for(i=0; i<15; i++)
    4e74:	53 94       	inc	r5
    4e76:	8f e0       	ldi	r24, 0x0F	; 15
    4e78:	58 16       	cp	r5, r24
    4e7a:	21 f7       	brne	.-56     	; 0x4e44 <rprintfFloat+0x62>
			break;
		else
			place *= 10.0;
	}
	// print polarity character
	if(negative)
    4e7c:	c6 01       	movw	r24, r12
    4e7e:	b5 01       	movw	r22, r10
    4e80:	20 e0       	ldi	r18, 0x00	; 0
    4e82:	30 e0       	ldi	r19, 0x00	; 0
    4e84:	40 e0       	ldi	r20, 0x00	; 0
    4e86:	50 e0       	ldi	r21, 0x00	; 0
    4e88:	0e 94 ba 2b 	call	0x5774	; 0x5774 <__cmpsf2>
    4e8c:	88 23       	and	r24, r24
    4e8e:	14 f4       	brge	.+4      	; 0x4e94 <rprintfFloat+0xb2>
		rprintfChar('-');
    4e90:	8d e2       	ldi	r24, 0x2D	; 45
    4e92:	01 c0       	rjmp	.+2      	; 0x4e96 <rprintfFloat+0xb4>
	else
		rprintfChar('+');
    4e94:	8b e2       	ldi	r24, 0x2B	; 43
    4e96:	0e 94 9b 25 	call	0x4b36	; 0x4b36 <rprintfChar>
    4e9a:	dd 24       	eor	r13, r13
    4e9c:	aa 24       	eor	r10, r10
    4e9e:	56 c0       	rjmp	.+172    	; 0x4f4c <rprintfFloat+0x16a>

	// print digits
	for(i=0; i<numDigits; i++)
	{
		digit = (x/place);
    4ea0:	c4 01       	movw	r24, r8
    4ea2:	b3 01       	movw	r22, r6
    4ea4:	a8 01       	movw	r20, r16
    4ea6:	97 01       	movw	r18, r14
    4ea8:	0e 94 be 2b 	call	0x577c	; 0x577c <__divsf3>
    4eac:	0e 94 2b 2c 	call	0x5856	; 0x5856 <__fixunssfsi>
    4eb0:	b6 2e       	mov	r11, r22

		if(digit | firstplace | (place == 1.0))
    4eb2:	d6 2a       	or	r13, r22
    4eb4:	cd 2d       	mov	r28, r13
    4eb6:	d0 e0       	ldi	r29, 0x00	; 0
    4eb8:	cc 24       	eor	r12, r12
    4eba:	dd 24       	eor	r13, r13
    4ebc:	c8 01       	movw	r24, r16
    4ebe:	b7 01       	movw	r22, r14
    4ec0:	20 e0       	ldi	r18, 0x00	; 0
    4ec2:	30 e0       	ldi	r19, 0x00	; 0
    4ec4:	40 e8       	ldi	r20, 0x80	; 128
    4ec6:	5f e3       	ldi	r21, 0x3F	; 63
    4ec8:	0e 94 ba 2b 	call	0x5774	; 0x5774 <__cmpsf2>
    4ecc:	88 23       	and	r24, r24
    4ece:	19 f4       	brne	.+6      	; 0x4ed6 <rprintfFloat+0xf4>
    4ed0:	21 e0       	ldi	r18, 0x01	; 1
    4ed2:	c2 2e       	mov	r12, r18
    4ed4:	d1 2c       	mov	r13, r1
    4ed6:	cc 29       	or	r28, r12
    4ed8:	dd 29       	or	r29, r13
    4eda:	cd 2b       	or	r28, r29
    4edc:	39 f0       	breq	.+14     	; 0x4eec <rprintfFloat+0x10a>
		{
			firstplace = TRUE;
			rprintfChar(digit+0x30);
    4ede:	8b 2d       	mov	r24, r11
    4ee0:	80 5d       	subi	r24, 0xD0	; 208
    4ee2:	0e 94 9b 25 	call	0x4b36	; 0x4b36 <rprintfChar>
    4ee6:	dd 24       	eor	r13, r13
    4ee8:	da 94       	dec	r13
    4eea:	04 c0       	rjmp	.+8      	; 0x4ef4 <rprintfFloat+0x112>
		}
		else
			rprintfChar(' ');
    4eec:	80 e2       	ldi	r24, 0x20	; 32
    4eee:	0e 94 9b 25 	call	0x4b36	; 0x4b36 <rprintfChar>
    4ef2:	dd 24       	eor	r13, r13
		
		if(place == 1.0)
    4ef4:	c8 01       	movw	r24, r16
    4ef6:	b7 01       	movw	r22, r14
    4ef8:	20 e0       	ldi	r18, 0x00	; 0
    4efa:	30 e0       	ldi	r19, 0x00	; 0
    4efc:	40 e8       	ldi	r20, 0x80	; 128
    4efe:	5f e3       	ldi	r21, 0x3F	; 63
    4f00:	0e 94 ba 2b 	call	0x5774	; 0x5774 <__cmpsf2>
    4f04:	88 23       	and	r24, r24
    4f06:	19 f4       	brne	.+6      	; 0x4f0e <rprintfFloat+0x12c>
		{
			rprintfChar('.');
    4f08:	8e e2       	ldi	r24, 0x2E	; 46
    4f0a:	0e 94 9b 25 	call	0x4b36	; 0x4b36 <rprintfChar>
		}
		
		x -= (digit*place);
    4f0e:	6b 2d       	mov	r22, r11
    4f10:	70 e0       	ldi	r23, 0x00	; 0
    4f12:	88 27       	eor	r24, r24
    4f14:	77 fd       	sbrc	r23, 7
    4f16:	80 95       	com	r24
    4f18:	98 2f       	mov	r25, r24
    4f1a:	0e 94 59 2c 	call	0x58b2	; 0x58b2 <__floatsisf>
    4f1e:	a8 01       	movw	r20, r16
    4f20:	97 01       	movw	r18, r14
    4f22:	0e 94 8e 2d 	call	0x5b1c	; 0x5b1c <__mulsf3>
    4f26:	9b 01       	movw	r18, r22
    4f28:	ac 01       	movw	r20, r24
    4f2a:	c4 01       	movw	r24, r8
    4f2c:	b3 01       	movw	r22, r6
    4f2e:	0e 94 f3 2a 	call	0x55e6	; 0x55e6 <__subsf3>
    4f32:	3b 01       	movw	r6, r22
    4f34:	4c 01       	movw	r8, r24
		place /= 10.0;
    4f36:	c8 01       	movw	r24, r16
    4f38:	b7 01       	movw	r22, r14
    4f3a:	20 e0       	ldi	r18, 0x00	; 0
    4f3c:	30 e0       	ldi	r19, 0x00	; 0
    4f3e:	40 e2       	ldi	r20, 0x20	; 32
    4f40:	51 e4       	ldi	r21, 0x41	; 65
    4f42:	0e 94 be 2b 	call	0x577c	; 0x577c <__divsf3>
    4f46:	7b 01       	movw	r14, r22
    4f48:	8c 01       	movw	r16, r24
		rprintfChar('-');
	else
		rprintfChar('+');

	// print digits
	for(i=0; i<numDigits; i++)
    4f4a:	a3 94       	inc	r10
    4f4c:	a4 14       	cp	r10, r4
    4f4e:	08 f4       	brcc	.+2      	; 0x4f52 <rprintfFloat+0x170>
    4f50:	a7 cf       	rjmp	.-178    	; 0x4ea0 <rprintfFloat+0xbe>
		}
		
		x -= (digit*place);
		place /= 10.0;
	}
}
    4f52:	df 91       	pop	r29
    4f54:	cf 91       	pop	r28
    4f56:	1f 91       	pop	r17
    4f58:	0f 91       	pop	r16
    4f5a:	ff 90       	pop	r15
    4f5c:	ef 90       	pop	r14
    4f5e:	df 90       	pop	r13
    4f60:	cf 90       	pop	r12
    4f62:	bf 90       	pop	r11
    4f64:	af 90       	pop	r10
    4f66:	9f 90       	pop	r9
    4f68:	8f 90       	pop	r8
    4f6a:	7f 90       	pop	r7
    4f6c:	6f 90       	pop	r6
    4f6e:	5f 90       	pop	r5
    4f70:	4f 90       	pop	r4
    4f72:	08 95       	ret

00004f74 <rprintf1RamRom>:
// Supports:
// %d - decimal
// %x - hex
// %c - character
int rprintf1RamRom(unsigned char stringInRom, const char *format, ...)
{
    4f74:	7f 92       	push	r7
    4f76:	8f 92       	push	r8
    4f78:	9f 92       	push	r9
    4f7a:	af 92       	push	r10
    4f7c:	bf 92       	push	r11
    4f7e:	cf 92       	push	r12
    4f80:	df 92       	push	r13
    4f82:	ef 92       	push	r14
    4f84:	ff 92       	push	r15
    4f86:	0f 93       	push	r16
    4f88:	1f 93       	push	r17
    4f8a:	df 93       	push	r29
    4f8c:	cf 93       	push	r28
    4f8e:	cd b7       	in	r28, 0x3d	; 61
    4f90:	de b7       	in	r29, 0x3e	; 62
    4f92:	78 88       	ldd	r7, Y+16	; 0x10
    4f94:	c9 88       	ldd	r12, Y+17	; 0x11
    4f96:	da 88       	ldd	r13, Y+18	; 0x12
    4f98:	63 e1       	ldi	r22, 0x13	; 19
    4f9a:	e6 2e       	mov	r14, r22
    4f9c:	f1 2c       	mov	r15, r1
    4f9e:	ec 0e       	add	r14, r28
    4fa0:	fd 1e       	adc	r15, r29
    4fa2:	14 c0       	rjmp	.+40     	; 0x4fcc <rprintf1RamRom+0x58>
	va_start(ap, format);
	for (;;)
	{
		while ((format_flag = READMEMBYTE(stringInRom,format++) ) != '%')
		{	// Until '%' or '\0'
			if (!format_flag)
    4fa4:	88 23       	and	r24, r24
    4fa6:	81 f4       	brne	.+32     	; 0x4fc8 <rprintf1RamRom+0x54>
				div_val /= base;
			} while (div_val);
		}
	}
	va_end(ap);
}
    4fa8:	80 e0       	ldi	r24, 0x00	; 0
    4faa:	90 e0       	ldi	r25, 0x00	; 0
    4fac:	cf 91       	pop	r28
    4fae:	df 91       	pop	r29
    4fb0:	1f 91       	pop	r17
    4fb2:	0f 91       	pop	r16
    4fb4:	ff 90       	pop	r15
    4fb6:	ef 90       	pop	r14
    4fb8:	df 90       	pop	r13
    4fba:	cf 90       	pop	r12
    4fbc:	bf 90       	pop	r11
    4fbe:	af 90       	pop	r10
    4fc0:	9f 90       	pop	r9
    4fc2:	8f 90       	pop	r8
    4fc4:	7f 90       	pop	r7
    4fc6:	08 95       	ret
			if (!format_flag)
			{
				va_end(ap);
				return(0);
			}
			rprintfChar(format_flag);
    4fc8:	0e 94 9b 25 	call	0x4b36	; 0x4b36 <rprintfChar>
    4fcc:	96 01       	movw	r18, r12
    4fce:	2f 5f       	subi	r18, 0xFF	; 255
    4fd0:	3f 4f       	sbci	r19, 0xFF	; 255
	va_list ap;

	va_start(ap, format);
	for (;;)
	{
		while ((format_flag = READMEMBYTE(stringInRom,format++) ) != '%')
    4fd2:	77 20       	and	r7, r7
    4fd4:	21 f0       	breq	.+8      	; 0x4fde <rprintf1RamRom+0x6a>
    4fd6:	f6 01       	movw	r30, r12
    4fd8:	69 01       	movw	r12, r18
    4fda:	84 91       	lpm	r24, Z+
    4fdc:	03 c0       	rjmp	.+6      	; 0x4fe4 <rprintf1RamRom+0x70>
    4fde:	f6 01       	movw	r30, r12
    4fe0:	80 81       	ld	r24, Z
    4fe2:	69 01       	movw	r12, r18
    4fe4:	85 32       	cpi	r24, 0x25	; 37
    4fe6:	f1 f6       	brne	.-68     	; 0x4fa4 <rprintf1RamRom+0x30>
    4fe8:	2f 5f       	subi	r18, 0xFF	; 255
    4fea:	3f 4f       	sbci	r19, 0xFF	; 255
				return(0);
			}
			rprintfChar(format_flag);
		}

		switch (format_flag = READMEMBYTE(stringInRom,format++) )
    4fec:	77 20       	and	r7, r7
    4fee:	21 f0       	breq	.+8      	; 0x4ff8 <rprintf1RamRom+0x84>
    4ff0:	f6 01       	movw	r30, r12
    4ff2:	69 01       	movw	r12, r18
    4ff4:	84 91       	lpm	r24, Z+
    4ff6:	03 c0       	rjmp	.+6      	; 0x4ffe <rprintf1RamRom+0x8a>
    4ff8:	f6 01       	movw	r30, r12
    4ffa:	80 81       	ld	r24, Z
    4ffc:	69 01       	movw	r12, r18
    4ffe:	84 36       	cpi	r24, 0x64	; 100
    5000:	29 f0       	breq	.+10     	; 0x500c <rprintf1RamRom+0x98>
    5002:	88 37       	cpi	r24, 0x78	; 120
    5004:	81 f0       	breq	.+32     	; 0x5026 <rprintf1RamRom+0xb2>
    5006:	83 36       	cpi	r24, 0x63	; 99
    5008:	f9 f6       	brne	.-66     	; 0x4fc8 <rprintf1RamRom+0x54>
    500a:	06 c0       	rjmp	.+12     	; 0x5018 <rprintf1RamRom+0xa4>
    500c:	00 e1       	ldi	r16, 0x10	; 16
    500e:	17 e2       	ldi	r17, 0x27	; 39
    5010:	5a e0       	ldi	r21, 0x0A	; 10
    5012:	a5 2e       	mov	r10, r21
    5014:	b1 2c       	mov	r11, r1
    5016:	0c c0       	rjmp	.+24     	; 0x5030 <rprintf1RamRom+0xbc>
		{
			case 'c': format_flag = va_arg(ap,int);
    5018:	f7 01       	movw	r30, r14
    501a:	80 81       	ld	r24, Z
    501c:	22 e0       	ldi	r18, 0x02	; 2
    501e:	30 e0       	ldi	r19, 0x00	; 0
    5020:	e2 0e       	add	r14, r18
    5022:	f3 1e       	adc	r15, r19
    5024:	d1 cf       	rjmp	.-94     	; 0x4fc8 <rprintf1RamRom+0x54>
			default:  rprintfChar(format_flag); continue;
    5026:	00 e0       	ldi	r16, 0x00	; 0
    5028:	10 e1       	ldi	r17, 0x10	; 16
    502a:	40 e1       	ldi	r20, 0x10	; 16
    502c:	a4 2e       	mov	r10, r20
    502e:	b1 2c       	mov	r11, r1
			case 'd': base = 10; div_val = 10000; goto CONVERSION_LOOP;
//			case 'x': base = 16; div_val = 0x10;
			case 'x': base = 16; div_val = 0x1000;

			CONVERSION_LOOP:
			u_val = va_arg(ap,int);
    5030:	32 e0       	ldi	r19, 0x02	; 2
    5032:	83 2e       	mov	r8, r19
    5034:	91 2c       	mov	r9, r1
    5036:	8e 0c       	add	r8, r14
    5038:	9f 1c       	adc	r9, r15
    503a:	f7 01       	movw	r30, r14
    503c:	e0 80       	ld	r14, Z
    503e:	f1 80       	ldd	r15, Z+1	; 0x01
			if (format_flag == 'd')
    5040:	84 36       	cpi	r24, 0x64	; 100
    5042:	b1 f4       	brne	.+44     	; 0x5070 <rprintf1RamRom+0xfc>
			{
				if (((int)u_val) < 0)
    5044:	f7 fe       	sbrs	r15, 7
    5046:	11 c0       	rjmp	.+34     	; 0x506a <rprintf1RamRom+0xf6>
				{
					u_val = - u_val;
    5048:	f0 94       	com	r15
    504a:	e1 94       	neg	r14
    504c:	f1 08       	sbc	r15, r1
    504e:	f3 94       	inc	r15
					rprintfChar('-');
    5050:	8d e2       	ldi	r24, 0x2D	; 45
    5052:	0e 94 9b 25 	call	0x4b36	; 0x4b36 <rprintfChar>
    5056:	09 c0       	rjmp	.+18     	; 0x506a <rprintf1RamRom+0xf6>
				}
				while (div_val > 1 && div_val > u_val) div_val /= 10;
    5058:	c8 01       	movw	r24, r16
    505a:	6a e0       	ldi	r22, 0x0A	; 10
    505c:	70 e0       	ldi	r23, 0x00	; 0
    505e:	0e 94 13 2e 	call	0x5c26	; 0x5c26 <__udivmodhi4>
    5062:	8b 01       	movw	r16, r22
    5064:	62 30       	cpi	r22, 0x02	; 2
    5066:	71 05       	cpc	r23, r1
    5068:	18 f0       	brcs	.+6      	; 0x5070 <rprintf1RamRom+0xfc>
    506a:	e0 16       	cp	r14, r16
    506c:	f1 06       	cpc	r15, r17
    506e:	a0 f3       	brcs	.-24     	; 0x5058 <rprintf1RamRom+0xe4>
			}
			do
			{
				//rprintfChar(pgm_read_byte(HexChars+(u_val/div_val)));
				rprintfu04(u_val/div_val);
    5070:	c7 01       	movw	r24, r14
    5072:	b8 01       	movw	r22, r16
    5074:	0e 94 13 2e 	call	0x5c26	; 0x5c26 <__udivmodhi4>
    5078:	86 2f       	mov	r24, r22
    507a:	0e 94 fe 25 	call	0x4bfc	; 0x4bfc <rprintfu04>
				u_val %= div_val;
    507e:	c7 01       	movw	r24, r14
    5080:	b8 01       	movw	r22, r16
    5082:	0e 94 13 2e 	call	0x5c26	; 0x5c26 <__udivmodhi4>
    5086:	7c 01       	movw	r14, r24
				div_val /= base;
    5088:	c8 01       	movw	r24, r16
    508a:	b5 01       	movw	r22, r10
    508c:	0e 94 13 2e 	call	0x5c26	; 0x5c26 <__udivmodhi4>
    5090:	8b 01       	movw	r16, r22
			} while (div_val);
    5092:	61 15       	cp	r22, r1
    5094:	71 05       	cpc	r23, r1
    5096:	61 f7       	brne	.-40     	; 0x5070 <rprintf1RamRom+0xfc>
    5098:	74 01       	movw	r14, r8
    509a:	98 cf       	rjmp	.-208    	; 0x4fcc <rprintf1RamRom+0x58>

0000509c <i2cSetBitrate>:
	// SCL freq = F_CPU/(16+2*TWBR))
	#ifdef TWPS0
		// for processors with additional bitrate division (mega128)
		// SCL freq = F_CPU/(16+2*TWBR*4^TWPS)
		// set TWPS to zero
		cbi(TWSR, TWPS0);
    509c:	20 91 b9 00 	lds	r18, 0x00B9
    50a0:	2e 7f       	andi	r18, 0xFE	; 254
    50a2:	20 93 b9 00 	sts	0x00B9, r18
		cbi(TWSR, TWPS1);
    50a6:	20 91 b9 00 	lds	r18, 0x00B9
    50aa:	2d 7f       	andi	r18, 0xFD	; 253
    50ac:	20 93 b9 00 	sts	0x00B9, r18
	#endif
	// calculate bitrate division	
	bitrate_div = ((F_CPU/1000l)/bitrateKHz);
    50b0:	9c 01       	movw	r18, r24
    50b2:	40 e0       	ldi	r20, 0x00	; 0
    50b4:	50 e0       	ldi	r21, 0x00	; 0
    50b6:	60 e8       	ldi	r22, 0x80	; 128
    50b8:	7e e3       	ldi	r23, 0x3E	; 62
    50ba:	80 e0       	ldi	r24, 0x00	; 0
    50bc:	90 e0       	ldi	r25, 0x00	; 0
    50be:	0e 94 5c 2e 	call	0x5cb8	; 0x5cb8 <__divmodsi4>
	if(bitrate_div >= 16)
    50c2:	20 31       	cpi	r18, 0x10	; 16
    50c4:	30 f0       	brcs	.+12     	; 0x50d2 <i2cSetBitrate+0x36>
		bitrate_div = (bitrate_div-16)/2;
    50c6:	82 2f       	mov	r24, r18
    50c8:	90 e0       	ldi	r25, 0x00	; 0
    50ca:	40 97       	sbiw	r24, 0x10	; 16
    50cc:	95 95       	asr	r25
    50ce:	87 95       	ror	r24
    50d0:	28 2f       	mov	r18, r24
	outb(TWBR, bitrate_div);
    50d2:	20 93 b8 00 	sts	0x00B8, r18
}
    50d6:	08 95       	ret

000050d8 <i2cInit>:

// functions
void i2cInit(void)
{
	// set pull-up resistors on I2C bus pins
	sbi(PORTD, 0);	// i2c SCL on 640
    50d8:	58 9a       	sbi	0x0b, 0	; 11
	sbi(PORTD, 1);	// i2c SDA on 640
    50da:	59 9a       	sbi	0x0b, 1	; 11

	// clear SlaveReceive and SlaveTransmit handler to null
	i2cSlaveReceive = 0;
    50dc:	10 92 39 12 	sts	0x1239, r1
    50e0:	10 92 38 12 	sts	0x1238, r1
	i2cSlaveTransmit = 0;
    50e4:	10 92 3b 12 	sts	0x123B, r1
    50e8:	10 92 3a 12 	sts	0x123A, r1
	// set i2c bit rate to 100KHz
	i2cSetBitrate(100);
    50ec:	84 e6       	ldi	r24, 0x64	; 100
    50ee:	90 e0       	ldi	r25, 0x00	; 0
    50f0:	0e 94 4e 28 	call	0x509c	; 0x509c <i2cSetBitrate>
	// enable TWI (two-wire interface)
	sbi(TWCR, TWEN);
    50f4:	ec eb       	ldi	r30, 0xBC	; 188
    50f6:	f0 e0       	ldi	r31, 0x00	; 0
    50f8:	80 81       	ld	r24, Z
    50fa:	84 60       	ori	r24, 0x04	; 4
    50fc:	80 83       	st	Z, r24
	// set state
	I2cState = I2C_IDLE;
    50fe:	10 92 f2 11 	sts	0x11F2, r1
	// enable TWI interrupt and slave address ACK
	sbi(TWCR, TWIE);
    5102:	80 81       	ld	r24, Z
    5104:	81 60       	ori	r24, 0x01	; 1
    5106:	80 83       	st	Z, r24
	sbi(TWCR, TWEA);
    5108:	80 81       	ld	r24, Z
    510a:	80 64       	ori	r24, 0x40	; 64
    510c:	80 83       	st	Z, r24
	//outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
	// enable interrupts
	sei();
    510e:	78 94       	sei
}
    5110:	08 95       	ret

00005112 <i2cSetLocalDeviceAddr>:
}

void i2cSetLocalDeviceAddr(u08 deviceAddr, u08 genCallEn)
{
	// set local device address (used in slave mode only)
	outb(TWAR, ((deviceAddr&0xFE) | (genCallEn?1:0)) );
    5112:	90 e0       	ldi	r25, 0x00	; 0
    5114:	61 11       	cpse	r22, r1
    5116:	91 e0       	ldi	r25, 0x01	; 1
    5118:	8e 7f       	andi	r24, 0xFE	; 254
    511a:	98 2b       	or	r25, r24
    511c:	90 93 ba 00 	sts	0x00BA, r25
}
    5120:	08 95       	ret

00005122 <i2cSetSlaveReceiveHandler>:

void i2cSetSlaveReceiveHandler(void (*i2cSlaveRx_func)(u08 receiveDataLength, u08* recieveData))
{
	i2cSlaveReceive = i2cSlaveRx_func;
    5122:	90 93 39 12 	sts	0x1239, r25
    5126:	80 93 38 12 	sts	0x1238, r24
}
    512a:	08 95       	ret

0000512c <i2cSetSlaveTransmitHandler>:

void i2cSetSlaveTransmitHandler(u08 (*i2cSlaveTx_func)(u08 transmitDataLengthMax, u08* transmitData))
{
	i2cSlaveTransmit = i2cSlaveTx_func;
    512c:	90 93 3b 12 	sts	0x123B, r25
    5130:	80 93 3a 12 	sts	0x123A, r24
}
    5134:	08 95       	ret

00005136 <i2cSendStart>:

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    5136:	ec eb       	ldi	r30, 0xBC	; 188
    5138:	f0 e0       	ldi	r31, 0x00	; 0
    513a:	80 81       	ld	r24, Z
    513c:	8f 70       	andi	r24, 0x0F	; 15
    513e:	80 6a       	ori	r24, 0xA0	; 160
    5140:	80 83       	st	Z, r24
}
    5142:	08 95       	ret

00005144 <i2cSendStop>:

inline void i2cSendStop(void)
{
	// transmit stop condition
	// leave with TWEA on for slave receiving
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA)|BV(TWSTO));
    5144:	ec eb       	ldi	r30, 0xBC	; 188
    5146:	f0 e0       	ldi	r31, 0x00	; 0
    5148:	80 81       	ld	r24, Z
    514a:	8f 70       	andi	r24, 0x0F	; 15
    514c:	80 6d       	ori	r24, 0xD0	; 208
    514e:	80 83       	st	Z, r24
}
    5150:	08 95       	ret

00005152 <i2cWaitForComplete>:

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    5152:	80 91 bc 00 	lds	r24, 0x00BC
    5156:	87 ff       	sbrs	r24, 7
    5158:	fc cf       	rjmp	.-8      	; 0x5152 <i2cWaitForComplete>
}
    515a:	08 95       	ret

0000515c <i2cSendByte>:

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    515c:	80 93 bb 00 	sts	0x00BB, r24
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    5160:	ec eb       	ldi	r30, 0xBC	; 188
    5162:	f0 e0       	ldi	r31, 0x00	; 0
    5164:	80 81       	ld	r24, Z
    5166:	8f 70       	andi	r24, 0x0F	; 15
    5168:	80 68       	ori	r24, 0x80	; 128
    516a:	80 83       	st	Z, r24
}
    516c:	08 95       	ret

0000516e <i2cReceiveByte>:

inline void i2cReceiveByte(u08 ackFlag)
{
	// begin receive over i2c
	if( ackFlag )
    516e:	88 23       	and	r24, r24
    5170:	29 f0       	breq	.+10     	; 0x517c <i2cReceiveByte+0xe>
	{
		// ackFlag = TRUE: ACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    5172:	80 91 bc 00 	lds	r24, 0x00BC
    5176:	8f 70       	andi	r24, 0x0F	; 15
    5178:	80 6c       	ori	r24, 0xC0	; 192
    517a:	04 c0       	rjmp	.+8      	; 0x5184 <i2cReceiveByte+0x16>
	}
	else
	{
		// ackFlag = FALSE: NACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    517c:	80 91 bc 00 	lds	r24, 0x00BC
    5180:	8f 70       	andi	r24, 0x0F	; 15
    5182:	80 68       	ori	r24, 0x80	; 128
    5184:	80 93 bc 00 	sts	0x00BC, r24
    5188:	08 95       	ret

0000518a <i2cGetReceivedByte>:
}

inline u08 i2cGetReceivedByte(void)
{
	// retieve received data byte from i2c TWDR
	return( inb(TWDR) );
    518a:	80 91 bb 00 	lds	r24, 0x00BB
}
    518e:	08 95       	ret

00005190 <i2cGetStatus>:

inline u08 i2cGetStatus(void)
{
	// retieve current i2c status from i2c TWSR
	return( inb(TWSR) );
    5190:	80 91 b9 00 	lds	r24, 0x00B9
}
    5194:	08 95       	ret

00005196 <i2cMasterSend>:

void i2cMasterSend(u08 deviceAddr, u08 length, u08* data)
{
    5196:	98 2f       	mov	r25, r24
	u08 i;
	// wait for interface to be ready
	while(I2cState);
    5198:	80 91 f2 11 	lds	r24, 0x11F2
    519c:	88 23       	and	r24, r24
    519e:	e1 f7       	brne	.-8      	; 0x5198 <i2cMasterSend+0x2>
	// set state
	I2cState = I2C_MASTER_TX;
    51a0:	82 e0       	ldi	r24, 0x02	; 2
    51a2:	80 93 f2 11 	sts	0x11F2, r24
	// save data
	I2cDeviceAddrRW = (deviceAddr & 0xFE);	// RW cleared: write operation
    51a6:	9e 7f       	andi	r25, 0xFE	; 254
    51a8:	90 93 f3 11 	sts	0x11F3, r25
    51ac:	a4 ef       	ldi	r26, 0xF4	; 244
    51ae:	b1 e1       	ldi	r27, 0x11	; 17
    51b0:	fa 01       	movw	r30, r20
    51b2:	02 c0       	rjmp	.+4      	; 0x51b8 <i2cMasterSend+0x22>
	for(i=0; i<length; i++)
		I2cSendData[i] = *data++;
    51b4:	81 91       	ld	r24, Z+
    51b6:	8d 93       	st	X+, r24
	while(I2cState);
	// set state
	I2cState = I2C_MASTER_TX;
	// save data
	I2cDeviceAddrRW = (deviceAddr & 0xFE);	// RW cleared: write operation
	for(i=0; i<length; i++)
    51b8:	8e 2f       	mov	r24, r30
    51ba:	84 1b       	sub	r24, r20
    51bc:	86 17       	cp	r24, r22
    51be:	d0 f3       	brcs	.-12     	; 0x51b4 <i2cMasterSend+0x1e>
		I2cSendData[i] = *data++;
	I2cSendDataIndex = 0;
    51c0:	10 92 14 12 	sts	0x1214, r1
	I2cSendDataLength = length;
    51c4:	60 93 15 12 	sts	0x1215, r22
}

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    51c8:	80 91 bc 00 	lds	r24, 0x00BC
    51cc:	8f 70       	andi	r24, 0x0F	; 15
    51ce:	80 6a       	ori	r24, 0xA0	; 160
    51d0:	80 93 bc 00 	sts	0x00BC, r24
		I2cSendData[i] = *data++;
	I2cSendDataIndex = 0;
	I2cSendDataLength = length;
	// send start condition
	i2cSendStart();
}
    51d4:	08 95       	ret

000051d6 <i2cMasterReceive>:

void i2cMasterReceive(u08 deviceAddr, u08 length, u08* data)
{
    51d6:	98 2f       	mov	r25, r24
	u08 i;
	// wait for interface to be ready
	while(I2cState);
    51d8:	80 91 f2 11 	lds	r24, 0x11F2
    51dc:	88 23       	and	r24, r24
    51de:	e1 f7       	brne	.-8      	; 0x51d8 <i2cMasterReceive+0x2>
	// set state
	I2cState = I2C_MASTER_RX;
    51e0:	83 e0       	ldi	r24, 0x03	; 3
    51e2:	80 93 f2 11 	sts	0x11F2, r24
	// save data
	I2cDeviceAddrRW = (deviceAddr|0x01);	// RW set: read operation
    51e6:	91 60       	ori	r25, 0x01	; 1
    51e8:	90 93 f3 11 	sts	0x11F3, r25
	I2cReceiveDataIndex = 0;
    51ec:	10 92 36 12 	sts	0x1236, r1
	I2cReceiveDataLength = length;
    51f0:	60 93 37 12 	sts	0x1237, r22
}

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    51f4:	80 91 bc 00 	lds	r24, 0x00BC
    51f8:	8f 70       	andi	r24, 0x0F	; 15
    51fa:	80 6a       	ori	r24, 0xA0	; 160
    51fc:	80 93 bc 00 	sts	0x00BC, r24
	I2cReceiveDataIndex = 0;
	I2cReceiveDataLength = length;
	// send start condition
	i2cSendStart();
	// wait for data
	while(I2cState);
    5200:	80 91 f2 11 	lds	r24, 0x11F2
    5204:	88 23       	and	r24, r24
    5206:	e1 f7       	brne	.-8      	; 0x5200 <i2cMasterReceive+0x2a>
    5208:	a6 e1       	ldi	r26, 0x16	; 22
    520a:	b2 e1       	ldi	r27, 0x12	; 18
    520c:	fa 01       	movw	r30, r20
    520e:	02 c0       	rjmp	.+4      	; 0x5214 <i2cMasterReceive+0x3e>
	// return data
	for(i=0; i<length; i++)
		*data++ = I2cReceiveData[i];
    5210:	8d 91       	ld	r24, X+
    5212:	81 93       	st	Z+, r24
	// send start condition
	i2cSendStart();
	// wait for data
	while(I2cState);
	// return data
	for(i=0; i<length; i++)
    5214:	8e 2f       	mov	r24, r30
    5216:	84 1b       	sub	r24, r20
    5218:	86 17       	cp	r24, r22
    521a:	d0 f3       	brcs	.-12     	; 0x5210 <i2cMasterReceive+0x3a>
		*data++ = I2cReceiveData[i];
}
    521c:	08 95       	ret

0000521e <i2cMasterSendNI>:

u08 i2cMasterSendNI(u08 deviceAddr, u08 length, u08* data)
{
    521e:	98 2f       	mov	r25, r24
    5220:	fa 01       	movw	r30, r20
	u08 retval = I2C_OK;

	// disable TWI interrupt
	cbi(TWCR, TWIE);
    5222:	80 91 bc 00 	lds	r24, 0x00BC
    5226:	8e 7f       	andi	r24, 0xFE	; 254
    5228:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    522c:	80 91 bc 00 	lds	r24, 0x00BC
    5230:	8f 70       	andi	r24, 0x0F	; 15
    5232:	80 6a       	ori	r24, 0xA0	; 160
    5234:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    5238:	80 91 bc 00 	lds	r24, 0x00BC
    523c:	87 ff       	sbrs	r24, 7
    523e:	fc cf       	rjmp	.-8      	; 0x5238 <i2cMasterSendNI+0x1a>
	// send start condition
	i2cSendStart();
	i2cWaitForComplete();

	// send device address with write
	i2cSendByte( deviceAddr & 0xFE );
    5240:	9e 7f       	andi	r25, 0xFE	; 254
}

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    5242:	90 93 bb 00 	sts	0x00BB, r25
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    5246:	80 91 bc 00 	lds	r24, 0x00BC
    524a:	8f 70       	andi	r24, 0x0F	; 15
    524c:	80 68       	ori	r24, 0x80	; 128
    524e:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    5252:	80 91 bc 00 	lds	r24, 0x00BC
    5256:	87 ff       	sbrs	r24, 7
    5258:	fc cf       	rjmp	.-8      	; 0x5252 <i2cMasterSendNI+0x34>
	// send device address with write
	i2cSendByte( deviceAddr & 0xFE );
	i2cWaitForComplete();

	// check if device is present and live
	if( inb(TWSR) == TW_MT_SLA_ACK)
    525a:	80 91 b9 00 	lds	r24, 0x00B9
    525e:	88 31       	cpi	r24, 0x18	; 24
    5260:	89 f0       	breq	.+34     	; 0x5284 <i2cMasterSendNI+0x66>
    5262:	91 e0       	ldi	r25, 0x01	; 1
    5264:	12 c0       	rjmp	.+36     	; 0x528a <i2cMasterSendNI+0x6c>
	{
		// send data
		while(length)
		{
			i2cSendByte( *data++ );
    5266:	80 81       	ld	r24, Z
}

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    5268:	80 93 bb 00 	sts	0x00BB, r24
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    526c:	80 91 bc 00 	lds	r24, 0x00BC
    5270:	8f 70       	andi	r24, 0x0F	; 15
    5272:	80 68       	ori	r24, 0x80	; 128
    5274:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    5278:	80 91 bc 00 	lds	r24, 0x00BC
    527c:	87 ff       	sbrs	r24, 7
    527e:	fc cf       	rjmp	.-8      	; 0x5278 <i2cMasterSendNI+0x5a>
	if( inb(TWSR) == TW_MT_SLA_ACK)
	{
		// send data
		while(length)
		{
			i2cSendByte( *data++ );
    5280:	31 96       	adiw	r30, 0x01	; 1
			i2cWaitForComplete();
			length--;
    5282:	61 50       	subi	r22, 0x01	; 1

	// check if device is present and live
	if( inb(TWSR) == TW_MT_SLA_ACK)
	{
		// send data
		while(length)
    5284:	66 23       	and	r22, r22
    5286:	79 f7       	brne	.-34     	; 0x5266 <i2cMasterSendNI+0x48>
    5288:	90 e0       	ldi	r25, 0x00	; 0

inline void i2cSendStop(void)
{
	// transmit stop condition
	// leave with TWEA on for slave receiving
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA)|BV(TWSTO));
    528a:	80 91 bc 00 	lds	r24, 0x00BC
    528e:	8f 70       	andi	r24, 0x0F	; 15
    5290:	80 6d       	ori	r24, 0xD0	; 208
    5292:	80 93 bc 00 	sts	0x00BC, r24
	}

	// transmit stop condition
	// leave with TWEA on for slave receiving
	i2cSendStop();
	while( !(inb(TWCR) & BV(TWSTO)) );
    5296:	80 91 bc 00 	lds	r24, 0x00BC
    529a:	84 ff       	sbrs	r24, 4
    529c:	fc cf       	rjmp	.-8      	; 0x5296 <i2cMasterSendNI+0x78>

	// enable TWI interrupt
	sbi(TWCR, TWIE);
    529e:	80 91 bc 00 	lds	r24, 0x00BC
    52a2:	81 60       	ori	r24, 0x01	; 1
    52a4:	80 93 bc 00 	sts	0x00BC, r24

	return retval;
}
    52a8:	89 2f       	mov	r24, r25
    52aa:	08 95       	ret

000052ac <i2cMasterReceiveNI>:

u08 i2cMasterReceiveNI(u08 deviceAddr, u08 length, u08 *data)
{
    52ac:	98 2f       	mov	r25, r24
    52ae:	fa 01       	movw	r30, r20
	u08 retval = I2C_OK;

	// disable TWI interrupt
	cbi(TWCR, TWIE);
    52b0:	80 91 bc 00 	lds	r24, 0x00BC
    52b4:	8e 7f       	andi	r24, 0xFE	; 254
    52b6:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    52ba:	80 91 bc 00 	lds	r24, 0x00BC
    52be:	8f 70       	andi	r24, 0x0F	; 15
    52c0:	80 6a       	ori	r24, 0xA0	; 160
    52c2:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    52c6:	80 91 bc 00 	lds	r24, 0x00BC
    52ca:	87 ff       	sbrs	r24, 7
    52cc:	fc cf       	rjmp	.-8      	; 0x52c6 <i2cMasterReceiveNI+0x1a>
	// send start condition
	i2cSendStart();
	i2cWaitForComplete();

	// send device address with read
	i2cSendByte( deviceAddr | 0x01 );
    52ce:	91 60       	ori	r25, 0x01	; 1
}

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    52d0:	90 93 bb 00 	sts	0x00BB, r25
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    52d4:	80 91 bc 00 	lds	r24, 0x00BC
    52d8:	8f 70       	andi	r24, 0x0F	; 15
    52da:	80 68       	ori	r24, 0x80	; 128
    52dc:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    52e0:	80 91 bc 00 	lds	r24, 0x00BC
    52e4:	87 ff       	sbrs	r24, 7
    52e6:	fc cf       	rjmp	.-8      	; 0x52e0 <i2cMasterReceiveNI+0x34>
	// send device address with read
	i2cSendByte( deviceAddr | 0x01 );
	i2cWaitForComplete();

	// check if device is present and live
	if( inb(TWSR) == TW_MR_SLA_ACK)
    52e8:	80 91 b9 00 	lds	r24, 0x00B9
    52ec:	80 34       	cpi	r24, 0x40	; 64
    52ee:	81 f0       	breq	.+32     	; 0x5310 <i2cMasterReceiveNI+0x64>
    52f0:	91 e0       	ldi	r25, 0x01	; 1
    52f2:	1e c0       	rjmp	.+60     	; 0x5330 <i2cMasterReceiveNI+0x84>
{
	// begin receive over i2c
	if( ackFlag )
	{
		// ackFlag = TRUE: ACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    52f4:	80 91 bc 00 	lds	r24, 0x00BC
    52f8:	8f 70       	andi	r24, 0x0F	; 15
    52fa:	80 6c       	ori	r24, 0xC0	; 192
    52fc:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    5300:	80 91 bc 00 	lds	r24, 0x00BC
    5304:	87 ff       	sbrs	r24, 7
    5306:	fc cf       	rjmp	.-8      	; 0x5300 <i2cMasterReceiveNI+0x54>
}

inline u08 i2cGetReceivedByte(void)
{
	// retieve received data byte from i2c TWDR
	return( inb(TWDR) );
    5308:	80 91 bb 00 	lds	r24, 0x00BB
		// accept receive data and ack it
		while(length > 1)
		{
			i2cReceiveByte(TRUE);
			i2cWaitForComplete();
			*data++ = i2cGetReceivedByte();
    530c:	81 93       	st	Z+, r24
			// decrement length
			length--;
    530e:	61 50       	subi	r22, 0x01	; 1

	// check if device is present and live
	if( inb(TWSR) == TW_MR_SLA_ACK)
	{
		// accept receive data and ack it
		while(length > 1)
    5310:	62 30       	cpi	r22, 0x02	; 2
    5312:	80 f7       	brcc	.-32     	; 0x52f4 <i2cMasterReceiveNI+0x48>
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
	}
	else
	{
		// ackFlag = FALSE: NACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    5314:	80 91 bc 00 	lds	r24, 0x00BC
    5318:	8f 70       	andi	r24, 0x0F	; 15
    531a:	80 68       	ori	r24, 0x80	; 128
    531c:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    5320:	80 91 bc 00 	lds	r24, 0x00BC
    5324:	87 ff       	sbrs	r24, 7
    5326:	fc cf       	rjmp	.-8      	; 0x5320 <i2cMasterReceiveNI+0x74>
}

inline u08 i2cGetReceivedByte(void)
{
	// retieve received data byte from i2c TWDR
	return( inb(TWDR) );
    5328:	80 91 bb 00 	lds	r24, 0x00BB
		}

		// accept receive data and nack it (last-byte signal)
		i2cReceiveByte(FALSE);
		i2cWaitForComplete();
		*data++ = i2cGetReceivedByte();
    532c:	80 83       	st	Z, r24
    532e:	90 e0       	ldi	r25, 0x00	; 0

inline void i2cSendStop(void)
{
	// transmit stop condition
	// leave with TWEA on for slave receiving
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA)|BV(TWSTO));
    5330:	80 91 bc 00 	lds	r24, 0x00BC
    5334:	8f 70       	andi	r24, 0x0F	; 15
    5336:	80 6d       	ori	r24, 0xD0	; 208
    5338:	80 93 bc 00 	sts	0x00BC, r24
	// transmit stop condition
	// leave with TWEA on for slave receiving
	i2cSendStop();

	// enable TWI interrupt
	sbi(TWCR, TWIE);
    533c:	80 91 bc 00 	lds	r24, 0x00BC
    5340:	81 60       	ori	r24, 0x01	; 1
    5342:	80 93 bc 00 	sts	0x00BC, r24

	return retval;
}
    5346:	89 2f       	mov	r24, r25
    5348:	08 95       	ret

0000534a <__vector_39>:
}
*/

//! I2C (TWI) interrupt service routine
SIGNAL(SIG_2WIRE_SERIAL)
{
    534a:	1f 92       	push	r1
    534c:	0f 92       	push	r0
    534e:	0f b6       	in	r0, 0x3f	; 63
    5350:	0f 92       	push	r0
    5352:	11 24       	eor	r1, r1
    5354:	2f 93       	push	r18
    5356:	3f 93       	push	r19
    5358:	4f 93       	push	r20
    535a:	5f 93       	push	r21
    535c:	6f 93       	push	r22
    535e:	7f 93       	push	r23
    5360:	8f 93       	push	r24
    5362:	9f 93       	push	r25
    5364:	af 93       	push	r26
    5366:	bf 93       	push	r27
    5368:	ef 93       	push	r30
    536a:	ff 93       	push	r31
	// read status bits
	u08 status = inb(TWSR) & TWSR_STATUS_MASK;
    536c:	80 91 b9 00 	lds	r24, 0x00B9

	switch(status)
    5370:	88 7f       	andi	r24, 0xF8	; 248
    5372:	80 36       	cpi	r24, 0x60	; 96
    5374:	09 f4       	brne	.+2      	; 0x5378 <__vector_39+0x2e>
    5376:	a0 c0       	rjmp	.+320    	; 0x54b8 <__vector_39+0x16e>
    5378:	81 36       	cpi	r24, 0x61	; 97
    537a:	70 f5       	brcc	.+92     	; 0x53d8 <__vector_39+0x8e>
    537c:	88 32       	cpi	r24, 0x28	; 40
    537e:	09 f4       	brne	.+2      	; 0x5382 <__vector_39+0x38>
    5380:	5f c0       	rjmp	.+190    	; 0x5440 <__vector_39+0xf6>
    5382:	89 32       	cpi	r24, 0x29	; 41
    5384:	98 f4       	brcc	.+38     	; 0x53ac <__vector_39+0x62>
    5386:	80 31       	cpi	r24, 0x10	; 16
    5388:	09 f4       	brne	.+2      	; 0x538c <__vector_39+0x42>
    538a:	57 c0       	rjmp	.+174    	; 0x543a <__vector_39+0xf0>
    538c:	81 31       	cpi	r24, 0x11	; 17
    538e:	38 f4       	brcc	.+14     	; 0x539e <__vector_39+0x54>
    5390:	88 23       	and	r24, r24
    5392:	09 f4       	brne	.+2      	; 0x5396 <__vector_39+0x4c>
    5394:	ea c0       	rjmp	.+468    	; 0x556a <__vector_39+0x220>
    5396:	88 30       	cpi	r24, 0x08	; 8
    5398:	09 f0       	breq	.+2      	; 0x539c <__vector_39+0x52>
    539a:	ef c0       	rjmp	.+478    	; 0x557a <__vector_39+0x230>
    539c:	4e c0       	rjmp	.+156    	; 0x543a <__vector_39+0xf0>
    539e:	88 31       	cpi	r24, 0x18	; 24
    53a0:	09 f4       	brne	.+2      	; 0x53a4 <__vector_39+0x5a>
    53a2:	4e c0       	rjmp	.+156    	; 0x5440 <__vector_39+0xf6>
    53a4:	80 32       	cpi	r24, 0x20	; 32
    53a6:	09 f0       	breq	.+2      	; 0x53aa <__vector_39+0x60>
    53a8:	e8 c0       	rjmp	.+464    	; 0x557a <__vector_39+0x230>
    53aa:	df c0       	rjmp	.+446    	; 0x556a <__vector_39+0x220>
    53ac:	80 34       	cpi	r24, 0x40	; 64
    53ae:	09 f4       	brne	.+2      	; 0x53b2 <__vector_39+0x68>
    53b0:	77 c0       	rjmp	.+238    	; 0x54a0 <__vector_39+0x156>
    53b2:	81 34       	cpi	r24, 0x41	; 65
    53b4:	38 f4       	brcc	.+14     	; 0x53c4 <__vector_39+0x7a>
    53b6:	80 33       	cpi	r24, 0x30	; 48
    53b8:	09 f4       	brne	.+2      	; 0x53bc <__vector_39+0x72>
    53ba:	d7 c0       	rjmp	.+430    	; 0x556a <__vector_39+0x220>
    53bc:	88 33       	cpi	r24, 0x38	; 56
    53be:	09 f0       	breq	.+2      	; 0x53c2 <__vector_39+0x78>
    53c0:	dc c0       	rjmp	.+440    	; 0x557a <__vector_39+0x230>
    53c2:	5d c0       	rjmp	.+186    	; 0x547e <__vector_39+0x134>
    53c4:	80 35       	cpi	r24, 0x50	; 80
    53c6:	09 f4       	brne	.+2      	; 0x53ca <__vector_39+0x80>
    53c8:	5f c0       	rjmp	.+190    	; 0x5488 <__vector_39+0x13e>
    53ca:	88 35       	cpi	r24, 0x58	; 88
    53cc:	09 f4       	brne	.+2      	; 0x53d0 <__vector_39+0x86>
    53ce:	4a c0       	rjmp	.+148    	; 0x5464 <__vector_39+0x11a>
    53d0:	88 34       	cpi	r24, 0x48	; 72
    53d2:	09 f0       	breq	.+2      	; 0x53d6 <__vector_39+0x8c>
    53d4:	d2 c0       	rjmp	.+420    	; 0x557a <__vector_39+0x230>
    53d6:	c9 c0       	rjmp	.+402    	; 0x556a <__vector_39+0x220>
    53d8:	88 39       	cpi	r24, 0x98	; 152
    53da:	09 f4       	brne	.+2      	; 0x53de <__vector_39+0x94>
    53dc:	ba c0       	rjmp	.+372    	; 0x5552 <__vector_39+0x208>
    53de:	89 39       	cpi	r24, 0x99	; 153
    53e0:	b0 f4       	brcc	.+44     	; 0x540e <__vector_39+0xc4>
    53e2:	88 37       	cpi	r24, 0x78	; 120
    53e4:	09 f4       	brne	.+2      	; 0x53e8 <__vector_39+0x9e>
    53e6:	68 c0       	rjmp	.+208    	; 0x54b8 <__vector_39+0x16e>
    53e8:	89 37       	cpi	r24, 0x79	; 121
    53ea:	38 f4       	brcc	.+14     	; 0x53fa <__vector_39+0xb0>
    53ec:	88 36       	cpi	r24, 0x68	; 104
    53ee:	09 f4       	brne	.+2      	; 0x53f2 <__vector_39+0xa8>
    53f0:	63 c0       	rjmp	.+198    	; 0x54b8 <__vector_39+0x16e>
    53f2:	80 37       	cpi	r24, 0x70	; 112
    53f4:	09 f0       	breq	.+2      	; 0x53f8 <__vector_39+0xae>
    53f6:	c1 c0       	rjmp	.+386    	; 0x557a <__vector_39+0x230>
    53f8:	5f c0       	rjmp	.+190    	; 0x54b8 <__vector_39+0x16e>
    53fa:	88 38       	cpi	r24, 0x88	; 136
    53fc:	09 f4       	brne	.+2      	; 0x5400 <__vector_39+0xb6>
    53fe:	a9 c0       	rjmp	.+338    	; 0x5552 <__vector_39+0x208>
    5400:	80 39       	cpi	r24, 0x90	; 144
    5402:	09 f4       	brne	.+2      	; 0x5406 <__vector_39+0xbc>
    5404:	5f c0       	rjmp	.+190    	; 0x54c4 <__vector_39+0x17a>
    5406:	80 38       	cpi	r24, 0x80	; 128
    5408:	09 f0       	breq	.+2      	; 0x540c <__vector_39+0xc2>
    540a:	b7 c0       	rjmp	.+366    	; 0x557a <__vector_39+0x230>
    540c:	5b c0       	rjmp	.+182    	; 0x54c4 <__vector_39+0x17a>
    540e:	80 3b       	cpi	r24, 0xB0	; 176
    5410:	09 f4       	brne	.+2      	; 0x5414 <__vector_39+0xca>
    5412:	79 c0       	rjmp	.+242    	; 0x5506 <__vector_39+0x1bc>
    5414:	81 3b       	cpi	r24, 0xB1	; 177
    5416:	38 f4       	brcc	.+14     	; 0x5426 <__vector_39+0xdc>
    5418:	80 3a       	cpi	r24, 0xA0	; 160
    541a:	09 f4       	brne	.+2      	; 0x541e <__vector_39+0xd4>
    541c:	62 c0       	rjmp	.+196    	; 0x54e2 <__vector_39+0x198>
    541e:	88 3a       	cpi	r24, 0xA8	; 168
    5420:	09 f0       	breq	.+2      	; 0x5424 <__vector_39+0xda>
    5422:	ab c0       	rjmp	.+342    	; 0x557a <__vector_39+0x230>
    5424:	70 c0       	rjmp	.+224    	; 0x5506 <__vector_39+0x1bc>
    5426:	80 3c       	cpi	r24, 0xC0	; 192
    5428:	09 f4       	brne	.+2      	; 0x542c <__vector_39+0xe2>
    542a:	9a c0       	rjmp	.+308    	; 0x5560 <__vector_39+0x216>
    542c:	88 3c       	cpi	r24, 0xC8	; 200
    542e:	09 f4       	brne	.+2      	; 0x5432 <__vector_39+0xe8>
    5430:	97 c0       	rjmp	.+302    	; 0x5560 <__vector_39+0x216>
    5432:	88 3b       	cpi	r24, 0xB8	; 184
    5434:	09 f0       	breq	.+2      	; 0x5438 <__vector_39+0xee>
    5436:	a1 c0       	rjmp	.+322    	; 0x557a <__vector_39+0x230>
    5438:	77 c0       	rjmp	.+238    	; 0x5528 <__vector_39+0x1de>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: M->START\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// send device address
		i2cSendByte(I2cDeviceAddrRW);
    543a:	80 91 f3 11 	lds	r24, 0x11F3
    543e:	0f c0       	rjmp	.+30     	; 0x545e <__vector_39+0x114>
		#ifdef I2C_DEBUG
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MT->SLA_ACK or DATA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		if(I2cSendDataIndex < I2cSendDataLength)
    5440:	90 91 14 12 	lds	r25, 0x1214
    5444:	80 91 15 12 	lds	r24, 0x1215
    5448:	98 17       	cp	r25, r24
    544a:	08 f0       	brcs	.+2      	; 0x544e <__vector_39+0x104>
    544c:	8e c0       	rjmp	.+284    	; 0x556a <__vector_39+0x220>
		{
			// send data
			i2cSendByte( I2cSendData[I2cSendDataIndex++] );
    544e:	e9 2f       	mov	r30, r25
    5450:	f0 e0       	ldi	r31, 0x00	; 0
    5452:	ec 50       	subi	r30, 0x0C	; 12
    5454:	fe 4e       	sbci	r31, 0xEE	; 238
    5456:	80 81       	ld	r24, Z
    5458:	9f 5f       	subi	r25, 0xFF	; 255
    545a:	90 93 14 12 	sts	0x1214, r25
}

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    545e:	80 93 bb 00 	sts	0x00BB, r24
    5462:	77 c0       	rjmp	.+238    	; 0x5552 <__vector_39+0x208>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MR->DATA_NACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// store final received data byte
		I2cReceiveData[I2cReceiveDataIndex++] = inb(TWDR);
    5464:	80 91 36 12 	lds	r24, 0x1236
    5468:	90 91 bb 00 	lds	r25, 0x00BB
    546c:	e8 2f       	mov	r30, r24
    546e:	f0 e0       	ldi	r31, 0x00	; 0
    5470:	ea 5e       	subi	r30, 0xEA	; 234
    5472:	fd 4e       	sbci	r31, 0xED	; 237
    5474:	90 83       	st	Z, r25
    5476:	8f 5f       	subi	r24, 0xFF	; 255
    5478:	80 93 36 12 	sts	0x1236, r24
    547c:	76 c0       	rjmp	.+236    	; 0x556a <__vector_39+0x220>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MT->ARB_LOST\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// release bus
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    547e:	80 91 bc 00 	lds	r24, 0x00BC
    5482:	8f 70       	andi	r24, 0x0F	; 15
    5484:	80 68       	ori	r24, 0x80	; 128
    5486:	75 c0       	rjmp	.+234    	; 0x5572 <__vector_39+0x228>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MR->DATA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// store received data byte
		I2cReceiveData[I2cReceiveDataIndex++] = inb(TWDR);
    5488:	80 91 36 12 	lds	r24, 0x1236
    548c:	90 91 bb 00 	lds	r25, 0x00BB
    5490:	e8 2f       	mov	r30, r24
    5492:	f0 e0       	ldi	r31, 0x00	; 0
    5494:	ea 5e       	subi	r30, 0xEA	; 234
    5496:	fd 4e       	sbci	r31, 0xED	; 237
    5498:	90 83       	st	Z, r25
    549a:	8f 5f       	subi	r24, 0xFF	; 255
    549c:	80 93 36 12 	sts	0x1236, r24
		#ifdef I2C_DEBUG
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MR->SLA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		if(I2cReceiveDataIndex < (I2cReceiveDataLength-1))
    54a0:	20 91 36 12 	lds	r18, 0x1236
    54a4:	30 e0       	ldi	r19, 0x00	; 0
    54a6:	80 91 37 12 	lds	r24, 0x1237
    54aa:	90 e0       	ldi	r25, 0x00	; 0
    54ac:	01 97       	sbiw	r24, 0x01	; 1
    54ae:	28 17       	cp	r18, r24
    54b0:	39 07       	cpc	r19, r25
    54b2:	0c f0       	brlt	.+2      	; 0x54b6 <__vector_39+0x16c>
    54b4:	4e c0       	rjmp	.+156    	; 0x5552 <__vector_39+0x208>
    54b6:	48 c0       	rjmp	.+144    	; 0x5548 <__vector_39+0x1fe>
		rprintf("I2C: SR->SLA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// we are being addressed as slave for writing (data will be received from master)
		// set state
		I2cState = I2C_SLAVE_RX;
    54b8:	85 e0       	ldi	r24, 0x05	; 5
    54ba:	80 93 f2 11 	sts	0x11F2, r24
		// prepare buffer
		I2cReceiveDataIndex = 0;
    54be:	10 92 36 12 	sts	0x1236, r1
    54c2:	42 c0       	rjmp	.+132    	; 0x5548 <__vector_39+0x1fe>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: SR->DATA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// get previously received data byte
		I2cReceiveData[I2cReceiveDataIndex++] = inb(TWDR);
    54c4:	80 91 36 12 	lds	r24, 0x1236
    54c8:	90 91 bb 00 	lds	r25, 0x00BB
    54cc:	e8 2f       	mov	r30, r24
    54ce:	f0 e0       	ldi	r31, 0x00	; 0
    54d0:	ea 5e       	subi	r30, 0xEA	; 234
    54d2:	fd 4e       	sbci	r31, 0xED	; 237
    54d4:	90 83       	st	Z, r25
    54d6:	8f 5f       	subi	r24, 0xFF	; 255
    54d8:	80 93 36 12 	sts	0x1236, r24
		// check receive buffer status
		if(I2cReceiveDataIndex < I2C_RECEIVE_DATA_BUFFER_SIZE)
    54dc:	80 32       	cpi	r24, 0x20	; 32
    54de:	c8 f5       	brcc	.+114    	; 0x5552 <__vector_39+0x208>
    54e0:	33 c0       	rjmp	.+102    	; 0x5548 <__vector_39+0x1fe>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: SR->SR_STOP\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// switch to SR mode with SLA ACK
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    54e2:	80 91 bc 00 	lds	r24, 0x00BC
    54e6:	8f 70       	andi	r24, 0x0F	; 15
    54e8:	80 6c       	ori	r24, 0xC0	; 192
    54ea:	80 93 bc 00 	sts	0x00BC, r24
		// i2c receive is complete, call i2cSlaveReceive
		if(i2cSlaveReceive) i2cSlaveReceive(I2cReceiveDataIndex, I2cReceiveData);
    54ee:	e0 91 38 12 	lds	r30, 0x1238
    54f2:	f0 91 39 12 	lds	r31, 0x1239
    54f6:	30 97       	sbiw	r30, 0x00	; 0
    54f8:	f1 f1       	breq	.+124    	; 0x5576 <__vector_39+0x22c>
    54fa:	80 91 36 12 	lds	r24, 0x1236
    54fe:	66 e1       	ldi	r22, 0x16	; 22
    5500:	72 e1       	ldi	r23, 0x12	; 18
    5502:	09 95       	icall
    5504:	38 c0       	rjmp	.+112    	; 0x5576 <__vector_39+0x22c>
		rprintf("I2C: ST->SLA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// we are being addressed as slave for reading (data must be transmitted back to master)
		// set state
		I2cState = I2C_SLAVE_TX;
    5506:	84 e0       	ldi	r24, 0x04	; 4
    5508:	80 93 f2 11 	sts	0x11F2, r24
		// request data from application
		if(i2cSlaveTransmit) I2cSendDataLength = i2cSlaveTransmit(I2C_SEND_DATA_BUFFER_SIZE, I2cSendData);
    550c:	e0 91 3a 12 	lds	r30, 0x123A
    5510:	f0 91 3b 12 	lds	r31, 0x123B
    5514:	30 97       	sbiw	r30, 0x00	; 0
    5516:	31 f0       	breq	.+12     	; 0x5524 <__vector_39+0x1da>
    5518:	80 e2       	ldi	r24, 0x20	; 32
    551a:	64 ef       	ldi	r22, 0xF4	; 244
    551c:	71 e1       	ldi	r23, 0x11	; 17
    551e:	09 95       	icall
    5520:	80 93 15 12 	sts	0x1215, r24
		// reset data index
		I2cSendDataIndex = 0;
    5524:	10 92 14 12 	sts	0x1214, r1
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: ST->DATA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// transmit data byte
		outb(TWDR, I2cSendData[I2cSendDataIndex++]);
    5528:	90 91 14 12 	lds	r25, 0x1214
    552c:	e9 2f       	mov	r30, r25
    552e:	f0 e0       	ldi	r31, 0x00	; 0
    5530:	ec 50       	subi	r30, 0x0C	; 12
    5532:	fe 4e       	sbci	r31, 0xEE	; 238
    5534:	80 81       	ld	r24, Z
    5536:	80 93 bb 00 	sts	0x00BB, r24
    553a:	9f 5f       	subi	r25, 0xFF	; 255
    553c:	90 93 14 12 	sts	0x1214, r25
		if(I2cSendDataIndex < I2cSendDataLength)
    5540:	80 91 15 12 	lds	r24, 0x1215
    5544:	98 17       	cp	r25, r24
    5546:	28 f4       	brcc	.+10     	; 0x5552 <__vector_39+0x208>
			// expect ACK to data byte
			outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    5548:	80 91 bc 00 	lds	r24, 0x00BC
    554c:	8f 70       	andi	r24, 0x0F	; 15
    554e:	80 6c       	ori	r24, 0xC0	; 192
    5550:	04 c0       	rjmp	.+8      	; 0x555a <__vector_39+0x210>
		else
			// expect NACK to data byte
			outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    5552:	80 91 bc 00 	lds	r24, 0x00BC
    5556:	8f 70       	andi	r24, 0x0F	; 15
    5558:	80 68       	ori	r24, 0x80	; 128
    555a:	80 93 bc 00 	sts	0x00BC, r24
    555e:	0d c0       	rjmp	.+26     	; 0x557a <__vector_39+0x230>
		rprintf("I2C: ST->DATA_NACK or LAST_DATA\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// all done
		// switch to open slave
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    5560:	80 91 bc 00 	lds	r24, 0x00BC
    5564:	8f 70       	andi	r24, 0x0F	; 15
    5566:	80 6c       	ori	r24, 0xC0	; 192
    5568:	04 c0       	rjmp	.+8      	; 0x5572 <__vector_39+0x228>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: BUS_ERROR\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// reset internal hardware and release bus
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTO)|BV(TWEA));
    556a:	80 91 bc 00 	lds	r24, 0x00BC
    556e:	8f 70       	andi	r24, 0x0F	; 15
    5570:	80 6d       	ori	r24, 0xD0	; 208
    5572:	80 93 bc 00 	sts	0x00BC, r24
		// set state
		I2cState = I2C_IDLE;
    5576:	10 92 f2 11 	sts	0x11F2, r1
		break;
	}
}
    557a:	ff 91       	pop	r31
    557c:	ef 91       	pop	r30
    557e:	bf 91       	pop	r27
    5580:	af 91       	pop	r26
    5582:	9f 91       	pop	r25
    5584:	8f 91       	pop	r24
    5586:	7f 91       	pop	r23
    5588:	6f 91       	pop	r22
    558a:	5f 91       	pop	r21
    558c:	4f 91       	pop	r20
    558e:	3f 91       	pop	r19
    5590:	2f 91       	pop	r18
    5592:	0f 90       	pop	r0
    5594:	0f be       	out	0x3f, r0	; 63
    5596:	0f 90       	pop	r0
    5598:	1f 90       	pop	r1
    559a:	18 95       	reti

0000559c <i2cGetState>:

eI2cStateType i2cGetState(void)
{
	return I2cState;
    559c:	80 91 f2 11 	lds	r24, 0x11F2
}
    55a0:	08 95       	ret

000055a2 <exit>:
    55a2:	f8 94       	cli
    55a4:	0c 94 77 2e 	jmp	0x5cee	; 0x5cee <_exit>

000055a8 <memcpy>:
    55a8:	fb 01       	movw	r30, r22
    55aa:	dc 01       	movw	r26, r24
    55ac:	02 c0       	rjmp	.+4      	; 0x55b2 <memcpy+0xa>
    55ae:	01 90       	ld	r0, Z+
    55b0:	0d 92       	st	X+, r0
    55b2:	41 50       	subi	r20, 0x01	; 1
    55b4:	50 40       	sbci	r21, 0x00	; 0
    55b6:	d8 f7       	brcc	.-10     	; 0x55ae <memcpy+0x6>
    55b8:	08 95       	ret

000055ba <memset>:
    55ba:	dc 01       	movw	r26, r24
    55bc:	01 c0       	rjmp	.+2      	; 0x55c0 <memset+0x6>
    55be:	6d 93       	st	X+, r22
    55c0:	41 50       	subi	r20, 0x01	; 1
    55c2:	50 40       	sbci	r21, 0x00	; 0
    55c4:	e0 f7       	brcc	.-8      	; 0x55be <memset+0x4>
    55c6:	08 95       	ret

000055c8 <strncpy>:
    55c8:	fb 01       	movw	r30, r22
    55ca:	dc 01       	movw	r26, r24
    55cc:	41 50       	subi	r20, 0x01	; 1
    55ce:	50 40       	sbci	r21, 0x00	; 0
    55d0:	48 f0       	brcs	.+18     	; 0x55e4 <strncpy+0x1c>
    55d2:	01 90       	ld	r0, Z+
    55d4:	0d 92       	st	X+, r0
    55d6:	00 20       	and	r0, r0
    55d8:	c9 f7       	brne	.-14     	; 0x55cc <strncpy+0x4>
    55da:	01 c0       	rjmp	.+2      	; 0x55de <strncpy+0x16>
    55dc:	1d 92       	st	X+, r1
    55de:	41 50       	subi	r20, 0x01	; 1
    55e0:	50 40       	sbci	r21, 0x00	; 0
    55e2:	e0 f7       	brcc	.-8      	; 0x55dc <strncpy+0x14>
    55e4:	08 95       	ret

000055e6 <__subsf3>:
    55e6:	50 58       	subi	r21, 0x80	; 128

000055e8 <__addsf3>:
    55e8:	bb 27       	eor	r27, r27
    55ea:	aa 27       	eor	r26, r26
    55ec:	0e d0       	rcall	.+28     	; 0x560a <__addsf3x>
    55ee:	3a c2       	rjmp	.+1140   	; 0x5a64 <__fp_round>
    55f0:	2b d2       	rcall	.+1110   	; 0x5a48 <__fp_pscA>
    55f2:	30 f0       	brcs	.+12     	; 0x5600 <__addsf3+0x18>
    55f4:	30 d2       	rcall	.+1120   	; 0x5a56 <__fp_pscB>
    55f6:	20 f0       	brcs	.+8      	; 0x5600 <__addsf3+0x18>
    55f8:	31 f4       	brne	.+12     	; 0x5606 <__addsf3+0x1e>
    55fa:	9f 3f       	cpi	r25, 0xFF	; 255
    55fc:	11 f4       	brne	.+4      	; 0x5602 <__addsf3+0x1a>
    55fe:	1e f4       	brtc	.+6      	; 0x5606 <__addsf3+0x1e>
    5600:	fb c1       	rjmp	.+1014   	; 0x59f8 <__fp_nan>
    5602:	0e f4       	brtc	.+2      	; 0x5606 <__addsf3+0x1e>
    5604:	e0 95       	com	r30
    5606:	e7 fb       	bst	r30, 7
    5608:	c6 c1       	rjmp	.+908    	; 0x5996 <__fp_inf>

0000560a <__addsf3x>:
    560a:	e9 2f       	mov	r30, r25
    560c:	3c d2       	rcall	.+1144   	; 0x5a86 <__fp_split3>
    560e:	80 f3       	brcs	.-32     	; 0x55f0 <__addsf3+0x8>
    5610:	ba 17       	cp	r27, r26
    5612:	62 07       	cpc	r22, r18
    5614:	73 07       	cpc	r23, r19
    5616:	84 07       	cpc	r24, r20
    5618:	95 07       	cpc	r25, r21
    561a:	18 f0       	brcs	.+6      	; 0x5622 <__addsf3x+0x18>
    561c:	71 f4       	brne	.+28     	; 0x563a <__addsf3x+0x30>
    561e:	9e f5       	brtc	.+102    	; 0x5686 <__addsf3x+0x7c>
    5620:	6b c2       	rjmp	.+1238   	; 0x5af8 <__fp_zero>
    5622:	0e f4       	brtc	.+2      	; 0x5626 <__addsf3x+0x1c>
    5624:	e0 95       	com	r30
    5626:	0b 2e       	mov	r0, r27
    5628:	ba 2f       	mov	r27, r26
    562a:	a0 2d       	mov	r26, r0
    562c:	0b 01       	movw	r0, r22
    562e:	b9 01       	movw	r22, r18
    5630:	90 01       	movw	r18, r0
    5632:	0c 01       	movw	r0, r24
    5634:	ca 01       	movw	r24, r20
    5636:	a0 01       	movw	r20, r0
    5638:	11 24       	eor	r1, r1
    563a:	ff 27       	eor	r31, r31
    563c:	59 1b       	sub	r21, r25
    563e:	99 f0       	breq	.+38     	; 0x5666 <__addsf3x+0x5c>
    5640:	59 3f       	cpi	r21, 0xF9	; 249
    5642:	50 f4       	brcc	.+20     	; 0x5658 <__addsf3x+0x4e>
    5644:	50 3e       	cpi	r21, 0xE0	; 224
    5646:	68 f1       	brcs	.+90     	; 0x56a2 <__addsf3x+0x98>
    5648:	1a 16       	cp	r1, r26
    564a:	f0 40       	sbci	r31, 0x00	; 0
    564c:	a2 2f       	mov	r26, r18
    564e:	23 2f       	mov	r18, r19
    5650:	34 2f       	mov	r19, r20
    5652:	44 27       	eor	r20, r20
    5654:	58 5f       	subi	r21, 0xF8	; 248
    5656:	f3 cf       	rjmp	.-26     	; 0x563e <__addsf3x+0x34>
    5658:	46 95       	lsr	r20
    565a:	37 95       	ror	r19
    565c:	27 95       	ror	r18
    565e:	a7 95       	ror	r26
    5660:	f0 40       	sbci	r31, 0x00	; 0
    5662:	53 95       	inc	r21
    5664:	c9 f7       	brne	.-14     	; 0x5658 <__addsf3x+0x4e>
    5666:	7e f4       	brtc	.+30     	; 0x5686 <__addsf3x+0x7c>
    5668:	1f 16       	cp	r1, r31
    566a:	ba 0b       	sbc	r27, r26
    566c:	62 0b       	sbc	r22, r18
    566e:	73 0b       	sbc	r23, r19
    5670:	84 0b       	sbc	r24, r20
    5672:	ba f0       	brmi	.+46     	; 0x56a2 <__addsf3x+0x98>
    5674:	91 50       	subi	r25, 0x01	; 1
    5676:	a1 f0       	breq	.+40     	; 0x56a0 <__addsf3x+0x96>
    5678:	ff 0f       	add	r31, r31
    567a:	bb 1f       	adc	r27, r27
    567c:	66 1f       	adc	r22, r22
    567e:	77 1f       	adc	r23, r23
    5680:	88 1f       	adc	r24, r24
    5682:	c2 f7       	brpl	.-16     	; 0x5674 <__addsf3x+0x6a>
    5684:	0e c0       	rjmp	.+28     	; 0x56a2 <__addsf3x+0x98>
    5686:	ba 0f       	add	r27, r26
    5688:	62 1f       	adc	r22, r18
    568a:	73 1f       	adc	r23, r19
    568c:	84 1f       	adc	r24, r20
    568e:	48 f4       	brcc	.+18     	; 0x56a2 <__addsf3x+0x98>
    5690:	87 95       	ror	r24
    5692:	77 95       	ror	r23
    5694:	67 95       	ror	r22
    5696:	b7 95       	ror	r27
    5698:	f7 95       	ror	r31
    569a:	9e 3f       	cpi	r25, 0xFE	; 254
    569c:	08 f0       	brcs	.+2      	; 0x56a0 <__addsf3x+0x96>
    569e:	b3 cf       	rjmp	.-154    	; 0x5606 <__addsf3+0x1e>
    56a0:	93 95       	inc	r25
    56a2:	88 0f       	add	r24, r24
    56a4:	08 f0       	brcs	.+2      	; 0x56a8 <__addsf3x+0x9e>
    56a6:	99 27       	eor	r25, r25
    56a8:	ee 0f       	add	r30, r30
    56aa:	97 95       	ror	r25
    56ac:	87 95       	ror	r24
    56ae:	08 95       	ret
    56b0:	cb d1       	rcall	.+918    	; 0x5a48 <__fp_pscA>
    56b2:	58 f0       	brcs	.+22     	; 0x56ca <__addsf3x+0xc0>
    56b4:	80 e8       	ldi	r24, 0x80	; 128
    56b6:	91 e0       	ldi	r25, 0x01	; 1
    56b8:	09 f4       	brne	.+2      	; 0x56bc <__addsf3x+0xb2>
    56ba:	9e ef       	ldi	r25, 0xFE	; 254
    56bc:	cc d1       	rcall	.+920    	; 0x5a56 <__fp_pscB>
    56be:	28 f0       	brcs	.+10     	; 0x56ca <__addsf3x+0xc0>
    56c0:	40 e8       	ldi	r20, 0x80	; 128
    56c2:	51 e0       	ldi	r21, 0x01	; 1
    56c4:	59 f4       	brne	.+22     	; 0x56dc <atan2+0xe>
    56c6:	5e ef       	ldi	r21, 0xFE	; 254
    56c8:	09 c0       	rjmp	.+18     	; 0x56dc <atan2+0xe>
    56ca:	96 c1       	rjmp	.+812    	; 0x59f8 <__fp_nan>
    56cc:	15 c2       	rjmp	.+1066   	; 0x5af8 <__fp_zero>

000056ce <atan2>:
    56ce:	e9 2f       	mov	r30, r25
    56d0:	e0 78       	andi	r30, 0x80	; 128
    56d2:	d9 d1       	rcall	.+946    	; 0x5a86 <__fp_split3>
    56d4:	68 f3       	brcs	.-38     	; 0x56b0 <__addsf3x+0xa6>
    56d6:	09 2e       	mov	r0, r25
    56d8:	05 2a       	or	r0, r21
    56da:	c1 f3       	breq	.-16     	; 0x56cc <__addsf3x+0xc2>
    56dc:	26 17       	cp	r18, r22
    56de:	37 07       	cpc	r19, r23
    56e0:	48 07       	cpc	r20, r24
    56e2:	59 07       	cpc	r21, r25
    56e4:	38 f0       	brcs	.+14     	; 0x56f4 <atan2+0x26>
    56e6:	0e 2e       	mov	r0, r30
    56e8:	07 f8       	bld	r0, 7
    56ea:	e0 25       	eor	r30, r0
    56ec:	69 f0       	breq	.+26     	; 0x5708 <atan2+0x3a>
    56ee:	e0 25       	eor	r30, r0
    56f0:	e0 64       	ori	r30, 0x40	; 64
    56f2:	0a c0       	rjmp	.+20     	; 0x5708 <atan2+0x3a>
    56f4:	ef 63       	ori	r30, 0x3F	; 63
    56f6:	07 f8       	bld	r0, 7
    56f8:	00 94       	com	r0
    56fa:	07 fa       	bst	r0, 7
    56fc:	db 01       	movw	r26, r22
    56fe:	b9 01       	movw	r22, r18
    5700:	9d 01       	movw	r18, r26
    5702:	dc 01       	movw	r26, r24
    5704:	ca 01       	movw	r24, r20
    5706:	ad 01       	movw	r20, r26
    5708:	ef 93       	push	r30
    570a:	47 d0       	rcall	.+142    	; 0x579a <__divsf3_pse>
    570c:	ab d1       	rcall	.+854    	; 0x5a64 <__fp_round>
    570e:	0a d0       	rcall	.+20     	; 0x5724 <atan>
    5710:	5f 91       	pop	r21
    5712:	55 23       	and	r21, r21
    5714:	31 f0       	breq	.+12     	; 0x5722 <atan2+0x54>
    5716:	2b ed       	ldi	r18, 0xDB	; 219
    5718:	3f e0       	ldi	r19, 0x0F	; 15
    571a:	49 e4       	ldi	r20, 0x49	; 73
    571c:	50 fd       	sbrc	r21, 0
    571e:	49 ec       	ldi	r20, 0xC9	; 201
    5720:	63 cf       	rjmp	.-314    	; 0x55e8 <__addsf3>
    5722:	08 95       	ret

00005724 <atan>:
    5724:	df 93       	push	r29
    5726:	dd 27       	eor	r29, r29
    5728:	b9 2f       	mov	r27, r25
    572a:	bf 77       	andi	r27, 0x7F	; 127
    572c:	40 e8       	ldi	r20, 0x80	; 128
    572e:	5f e3       	ldi	r21, 0x3F	; 63
    5730:	16 16       	cp	r1, r22
    5732:	17 06       	cpc	r1, r23
    5734:	48 07       	cpc	r20, r24
    5736:	5b 07       	cpc	r21, r27
    5738:	10 f4       	brcc	.+4      	; 0x573e <atan+0x1a>
    573a:	d9 2f       	mov	r29, r25
    573c:	e8 d1       	rcall	.+976    	; 0x5b0e <inverse>
    573e:	9f 93       	push	r25
    5740:	8f 93       	push	r24
    5742:	7f 93       	push	r23
    5744:	6f 93       	push	r22
    5746:	4d d2       	rcall	.+1178   	; 0x5be2 <square>
    5748:	e4 ee       	ldi	r30, 0xE4	; 228
    574a:	f0 e0       	ldi	r31, 0x00	; 0
    574c:	58 d1       	rcall	.+688    	; 0x59fe <__fp_powser>
    574e:	8a d1       	rcall	.+788    	; 0x5a64 <__fp_round>
    5750:	2f 91       	pop	r18
    5752:	3f 91       	pop	r19
    5754:	4f 91       	pop	r20
    5756:	5f 91       	pop	r21
    5758:	ed d1       	rcall	.+986    	; 0x5b34 <__mulsf3x>
    575a:	dd 23       	and	r29, r29
    575c:	49 f0       	breq	.+18     	; 0x5770 <atan+0x4c>
    575e:	90 58       	subi	r25, 0x80	; 128
    5760:	a2 ea       	ldi	r26, 0xA2	; 162
    5762:	2a ed       	ldi	r18, 0xDA	; 218
    5764:	3f e0       	ldi	r19, 0x0F	; 15
    5766:	49 ec       	ldi	r20, 0xC9	; 201
    5768:	5f e3       	ldi	r21, 0x3F	; 63
    576a:	d0 78       	andi	r29, 0x80	; 128
    576c:	5d 27       	eor	r21, r29
    576e:	4d df       	rcall	.-358    	; 0x560a <__addsf3x>
    5770:	df 91       	pop	r29
    5772:	78 c1       	rjmp	.+752    	; 0x5a64 <__fp_round>

00005774 <__cmpsf2>:
    5774:	ec d0       	rcall	.+472    	; 0x594e <__fp_cmp>
    5776:	08 f4       	brcc	.+2      	; 0x577a <__cmpsf2+0x6>
    5778:	81 e0       	ldi	r24, 0x01	; 1
    577a:	08 95       	ret

0000577c <__divsf3>:
    577c:	0c d0       	rcall	.+24     	; 0x5796 <__divsf3x>
    577e:	72 c1       	rjmp	.+740    	; 0x5a64 <__fp_round>
    5780:	6a d1       	rcall	.+724    	; 0x5a56 <__fp_pscB>
    5782:	40 f0       	brcs	.+16     	; 0x5794 <__divsf3+0x18>
    5784:	61 d1       	rcall	.+706    	; 0x5a48 <__fp_pscA>
    5786:	30 f0       	brcs	.+12     	; 0x5794 <__divsf3+0x18>
    5788:	21 f4       	brne	.+8      	; 0x5792 <__divsf3+0x16>
    578a:	5f 3f       	cpi	r21, 0xFF	; 255
    578c:	19 f0       	breq	.+6      	; 0x5794 <__divsf3+0x18>
    578e:	03 c1       	rjmp	.+518    	; 0x5996 <__fp_inf>
    5790:	51 11       	cpse	r21, r1
    5792:	b3 c1       	rjmp	.+870    	; 0x5afa <__fp_szero>
    5794:	31 c1       	rjmp	.+610    	; 0x59f8 <__fp_nan>

00005796 <__divsf3x>:
    5796:	77 d1       	rcall	.+750    	; 0x5a86 <__fp_split3>
    5798:	98 f3       	brcs	.-26     	; 0x5780 <__divsf3+0x4>

0000579a <__divsf3_pse>:
    579a:	99 23       	and	r25, r25
    579c:	c9 f3       	breq	.-14     	; 0x5790 <__divsf3+0x14>
    579e:	55 23       	and	r21, r21
    57a0:	b1 f3       	breq	.-20     	; 0x578e <__divsf3+0x12>
    57a2:	95 1b       	sub	r25, r21
    57a4:	55 0b       	sbc	r21, r21
    57a6:	bb 27       	eor	r27, r27
    57a8:	aa 27       	eor	r26, r26
    57aa:	62 17       	cp	r22, r18
    57ac:	73 07       	cpc	r23, r19
    57ae:	84 07       	cpc	r24, r20
    57b0:	38 f0       	brcs	.+14     	; 0x57c0 <__divsf3_pse+0x26>
    57b2:	9f 5f       	subi	r25, 0xFF	; 255
    57b4:	5f 4f       	sbci	r21, 0xFF	; 255
    57b6:	22 0f       	add	r18, r18
    57b8:	33 1f       	adc	r19, r19
    57ba:	44 1f       	adc	r20, r20
    57bc:	aa 1f       	adc	r26, r26
    57be:	a9 f3       	breq	.-22     	; 0x57aa <__divsf3_pse+0x10>
    57c0:	33 d0       	rcall	.+102    	; 0x5828 <__divsf3_pse+0x8e>
    57c2:	0e 2e       	mov	r0, r30
    57c4:	3a f0       	brmi	.+14     	; 0x57d4 <__divsf3_pse+0x3a>
    57c6:	e0 e8       	ldi	r30, 0x80	; 128
    57c8:	30 d0       	rcall	.+96     	; 0x582a <__divsf3_pse+0x90>
    57ca:	91 50       	subi	r25, 0x01	; 1
    57cc:	50 40       	sbci	r21, 0x00	; 0
    57ce:	e6 95       	lsr	r30
    57d0:	00 1c       	adc	r0, r0
    57d2:	ca f7       	brpl	.-14     	; 0x57c6 <__divsf3_pse+0x2c>
    57d4:	29 d0       	rcall	.+82     	; 0x5828 <__divsf3_pse+0x8e>
    57d6:	fe 2f       	mov	r31, r30
    57d8:	27 d0       	rcall	.+78     	; 0x5828 <__divsf3_pse+0x8e>
    57da:	66 0f       	add	r22, r22
    57dc:	77 1f       	adc	r23, r23
    57de:	88 1f       	adc	r24, r24
    57e0:	bb 1f       	adc	r27, r27
    57e2:	26 17       	cp	r18, r22
    57e4:	37 07       	cpc	r19, r23
    57e6:	48 07       	cpc	r20, r24
    57e8:	ab 07       	cpc	r26, r27
    57ea:	b0 e8       	ldi	r27, 0x80	; 128
    57ec:	09 f0       	breq	.+2      	; 0x57f0 <__divsf3_pse+0x56>
    57ee:	bb 0b       	sbc	r27, r27
    57f0:	80 2d       	mov	r24, r0
    57f2:	bf 01       	movw	r22, r30
    57f4:	ff 27       	eor	r31, r31
    57f6:	93 58       	subi	r25, 0x83	; 131
    57f8:	5f 4f       	sbci	r21, 0xFF	; 255
    57fa:	2a f0       	brmi	.+10     	; 0x5806 <__divsf3_pse+0x6c>
    57fc:	9e 3f       	cpi	r25, 0xFE	; 254
    57fe:	51 05       	cpc	r21, r1
    5800:	68 f0       	brcs	.+26     	; 0x581c <__divsf3_pse+0x82>
    5802:	c9 c0       	rjmp	.+402    	; 0x5996 <__fp_inf>
    5804:	7a c1       	rjmp	.+756    	; 0x5afa <__fp_szero>
    5806:	5f 3f       	cpi	r21, 0xFF	; 255
    5808:	ec f3       	brlt	.-6      	; 0x5804 <__divsf3_pse+0x6a>
    580a:	98 3e       	cpi	r25, 0xE8	; 232
    580c:	dc f3       	brlt	.-10     	; 0x5804 <__divsf3_pse+0x6a>
    580e:	86 95       	lsr	r24
    5810:	77 95       	ror	r23
    5812:	67 95       	ror	r22
    5814:	b7 95       	ror	r27
    5816:	f7 95       	ror	r31
    5818:	9f 5f       	subi	r25, 0xFF	; 255
    581a:	c9 f7       	brne	.-14     	; 0x580e <__divsf3_pse+0x74>
    581c:	88 0f       	add	r24, r24
    581e:	91 1d       	adc	r25, r1
    5820:	96 95       	lsr	r25
    5822:	87 95       	ror	r24
    5824:	97 f9       	bld	r25, 7
    5826:	08 95       	ret
    5828:	e1 e0       	ldi	r30, 0x01	; 1
    582a:	66 0f       	add	r22, r22
    582c:	77 1f       	adc	r23, r23
    582e:	88 1f       	adc	r24, r24
    5830:	bb 1f       	adc	r27, r27
    5832:	62 17       	cp	r22, r18
    5834:	73 07       	cpc	r23, r19
    5836:	84 07       	cpc	r24, r20
    5838:	ba 07       	cpc	r27, r26
    583a:	20 f0       	brcs	.+8      	; 0x5844 <__divsf3_pse+0xaa>
    583c:	62 1b       	sub	r22, r18
    583e:	73 0b       	sbc	r23, r19
    5840:	84 0b       	sbc	r24, r20
    5842:	ba 0b       	sbc	r27, r26
    5844:	ee 1f       	adc	r30, r30
    5846:	88 f7       	brcc	.-30     	; 0x582a <__divsf3_pse+0x90>
    5848:	e0 95       	com	r30
    584a:	08 95       	ret

0000584c <__fixsfsi>:
    584c:	04 d0       	rcall	.+8      	; 0x5856 <__fixunssfsi>
    584e:	68 94       	set
    5850:	b1 11       	cpse	r27, r1
    5852:	53 c1       	rjmp	.+678    	; 0x5afa <__fp_szero>
    5854:	08 95       	ret

00005856 <__fixunssfsi>:
    5856:	1f d1       	rcall	.+574    	; 0x5a96 <__fp_splitA>
    5858:	88 f0       	brcs	.+34     	; 0x587c <__fixunssfsi+0x26>
    585a:	9f 57       	subi	r25, 0x7F	; 127
    585c:	90 f0       	brcs	.+36     	; 0x5882 <__fixunssfsi+0x2c>
    585e:	b9 2f       	mov	r27, r25
    5860:	99 27       	eor	r25, r25
    5862:	b7 51       	subi	r27, 0x17	; 23
    5864:	a0 f0       	brcs	.+40     	; 0x588e <__fixunssfsi+0x38>
    5866:	d1 f0       	breq	.+52     	; 0x589c <__fixunssfsi+0x46>
    5868:	66 0f       	add	r22, r22
    586a:	77 1f       	adc	r23, r23
    586c:	88 1f       	adc	r24, r24
    586e:	99 1f       	adc	r25, r25
    5870:	1a f0       	brmi	.+6      	; 0x5878 <__fixunssfsi+0x22>
    5872:	ba 95       	dec	r27
    5874:	c9 f7       	brne	.-14     	; 0x5868 <__fixunssfsi+0x12>
    5876:	12 c0       	rjmp	.+36     	; 0x589c <__fixunssfsi+0x46>
    5878:	b1 30       	cpi	r27, 0x01	; 1
    587a:	81 f0       	breq	.+32     	; 0x589c <__fixunssfsi+0x46>
    587c:	3d d1       	rcall	.+634    	; 0x5af8 <__fp_zero>
    587e:	b1 e0       	ldi	r27, 0x01	; 1
    5880:	08 95       	ret
    5882:	3a c1       	rjmp	.+628    	; 0x5af8 <__fp_zero>
    5884:	67 2f       	mov	r22, r23
    5886:	78 2f       	mov	r23, r24
    5888:	88 27       	eor	r24, r24
    588a:	b8 5f       	subi	r27, 0xF8	; 248
    588c:	39 f0       	breq	.+14     	; 0x589c <__fixunssfsi+0x46>
    588e:	b9 3f       	cpi	r27, 0xF9	; 249
    5890:	cc f3       	brlt	.-14     	; 0x5884 <__fixunssfsi+0x2e>
    5892:	86 95       	lsr	r24
    5894:	77 95       	ror	r23
    5896:	67 95       	ror	r22
    5898:	b3 95       	inc	r27
    589a:	d9 f7       	brne	.-10     	; 0x5892 <__fixunssfsi+0x3c>
    589c:	3e f4       	brtc	.+14     	; 0x58ac <__fixunssfsi+0x56>
    589e:	90 95       	com	r25
    58a0:	80 95       	com	r24
    58a2:	70 95       	com	r23
    58a4:	61 95       	neg	r22
    58a6:	7f 4f       	sbci	r23, 0xFF	; 255
    58a8:	8f 4f       	sbci	r24, 0xFF	; 255
    58aa:	9f 4f       	sbci	r25, 0xFF	; 255
    58ac:	08 95       	ret

000058ae <__floatunsisf>:
    58ae:	e8 94       	clt
    58b0:	09 c0       	rjmp	.+18     	; 0x58c4 <__floatsisf+0x12>

000058b2 <__floatsisf>:
    58b2:	97 fb       	bst	r25, 7
    58b4:	3e f4       	brtc	.+14     	; 0x58c4 <__floatsisf+0x12>
    58b6:	90 95       	com	r25
    58b8:	80 95       	com	r24
    58ba:	70 95       	com	r23
    58bc:	61 95       	neg	r22
    58be:	7f 4f       	sbci	r23, 0xFF	; 255
    58c0:	8f 4f       	sbci	r24, 0xFF	; 255
    58c2:	9f 4f       	sbci	r25, 0xFF	; 255
    58c4:	99 23       	and	r25, r25
    58c6:	a9 f0       	breq	.+42     	; 0x58f2 <__floatsisf+0x40>
    58c8:	f9 2f       	mov	r31, r25
    58ca:	96 e9       	ldi	r25, 0x96	; 150
    58cc:	bb 27       	eor	r27, r27
    58ce:	93 95       	inc	r25
    58d0:	f6 95       	lsr	r31
    58d2:	87 95       	ror	r24
    58d4:	77 95       	ror	r23
    58d6:	67 95       	ror	r22
    58d8:	b7 95       	ror	r27
    58da:	f1 11       	cpse	r31, r1
    58dc:	f8 cf       	rjmp	.-16     	; 0x58ce <__floatsisf+0x1c>
    58de:	fa f4       	brpl	.+62     	; 0x591e <__floatsisf+0x6c>
    58e0:	bb 0f       	add	r27, r27
    58e2:	11 f4       	brne	.+4      	; 0x58e8 <__floatsisf+0x36>
    58e4:	60 ff       	sbrs	r22, 0
    58e6:	1b c0       	rjmp	.+54     	; 0x591e <__floatsisf+0x6c>
    58e8:	6f 5f       	subi	r22, 0xFF	; 255
    58ea:	7f 4f       	sbci	r23, 0xFF	; 255
    58ec:	8f 4f       	sbci	r24, 0xFF	; 255
    58ee:	9f 4f       	sbci	r25, 0xFF	; 255
    58f0:	16 c0       	rjmp	.+44     	; 0x591e <__floatsisf+0x6c>
    58f2:	88 23       	and	r24, r24
    58f4:	11 f0       	breq	.+4      	; 0x58fa <__floatsisf+0x48>
    58f6:	96 e9       	ldi	r25, 0x96	; 150
    58f8:	11 c0       	rjmp	.+34     	; 0x591c <__floatsisf+0x6a>
    58fa:	77 23       	and	r23, r23
    58fc:	21 f0       	breq	.+8      	; 0x5906 <__floatsisf+0x54>
    58fe:	9e e8       	ldi	r25, 0x8E	; 142
    5900:	87 2f       	mov	r24, r23
    5902:	76 2f       	mov	r23, r22
    5904:	05 c0       	rjmp	.+10     	; 0x5910 <__floatsisf+0x5e>
    5906:	66 23       	and	r22, r22
    5908:	71 f0       	breq	.+28     	; 0x5926 <__floatsisf+0x74>
    590a:	96 e8       	ldi	r25, 0x86	; 134
    590c:	86 2f       	mov	r24, r22
    590e:	70 e0       	ldi	r23, 0x00	; 0
    5910:	60 e0       	ldi	r22, 0x00	; 0
    5912:	2a f0       	brmi	.+10     	; 0x591e <__floatsisf+0x6c>
    5914:	9a 95       	dec	r25
    5916:	66 0f       	add	r22, r22
    5918:	77 1f       	adc	r23, r23
    591a:	88 1f       	adc	r24, r24
    591c:	da f7       	brpl	.-10     	; 0x5914 <__floatsisf+0x62>
    591e:	88 0f       	add	r24, r24
    5920:	96 95       	lsr	r25
    5922:	87 95       	ror	r24
    5924:	97 f9       	bld	r25, 7
    5926:	08 95       	ret

00005928 <floor>:
    5928:	d0 d0       	rcall	.+416    	; 0x5aca <__fp_trunc>
    592a:	80 f0       	brcs	.+32     	; 0x594c <floor+0x24>
    592c:	9f 37       	cpi	r25, 0x7F	; 127
    592e:	40 f4       	brcc	.+16     	; 0x5940 <floor+0x18>
    5930:	91 11       	cpse	r25, r1
    5932:	0e f0       	brts	.+2      	; 0x5936 <floor+0xe>
    5934:	e2 c0       	rjmp	.+452    	; 0x5afa <__fp_szero>
    5936:	60 e0       	ldi	r22, 0x00	; 0
    5938:	70 e0       	ldi	r23, 0x00	; 0
    593a:	80 e8       	ldi	r24, 0x80	; 128
    593c:	9f eb       	ldi	r25, 0xBF	; 191
    593e:	08 95       	ret
    5940:	26 f4       	brtc	.+8      	; 0x594a <floor+0x22>
    5942:	1b 16       	cp	r1, r27
    5944:	61 1d       	adc	r22, r1
    5946:	71 1d       	adc	r23, r1
    5948:	81 1d       	adc	r24, r1
    594a:	2b c0       	rjmp	.+86     	; 0x59a2 <__fp_mintl>
    594c:	45 c0       	rjmp	.+138    	; 0x59d8 <__fp_mpack>

0000594e <__fp_cmp>:
    594e:	99 0f       	add	r25, r25
    5950:	00 08       	sbc	r0, r0
    5952:	55 0f       	add	r21, r21
    5954:	aa 0b       	sbc	r26, r26
    5956:	e0 e8       	ldi	r30, 0x80	; 128
    5958:	fe ef       	ldi	r31, 0xFE	; 254
    595a:	16 16       	cp	r1, r22
    595c:	17 06       	cpc	r1, r23
    595e:	e8 07       	cpc	r30, r24
    5960:	f9 07       	cpc	r31, r25
    5962:	c0 f0       	brcs	.+48     	; 0x5994 <__fp_cmp+0x46>
    5964:	12 16       	cp	r1, r18
    5966:	13 06       	cpc	r1, r19
    5968:	e4 07       	cpc	r30, r20
    596a:	f5 07       	cpc	r31, r21
    596c:	98 f0       	brcs	.+38     	; 0x5994 <__fp_cmp+0x46>
    596e:	62 1b       	sub	r22, r18
    5970:	73 0b       	sbc	r23, r19
    5972:	84 0b       	sbc	r24, r20
    5974:	95 0b       	sbc	r25, r21
    5976:	39 f4       	brne	.+14     	; 0x5986 <__fp_cmp+0x38>
    5978:	0a 26       	eor	r0, r26
    597a:	61 f0       	breq	.+24     	; 0x5994 <__fp_cmp+0x46>
    597c:	23 2b       	or	r18, r19
    597e:	24 2b       	or	r18, r20
    5980:	25 2b       	or	r18, r21
    5982:	21 f4       	brne	.+8      	; 0x598c <__fp_cmp+0x3e>
    5984:	08 95       	ret
    5986:	0a 26       	eor	r0, r26
    5988:	09 f4       	brne	.+2      	; 0x598c <__fp_cmp+0x3e>
    598a:	a1 40       	sbci	r26, 0x01	; 1
    598c:	a6 95       	lsr	r26
    598e:	8f ef       	ldi	r24, 0xFF	; 255
    5990:	81 1d       	adc	r24, r1
    5992:	81 1d       	adc	r24, r1
    5994:	08 95       	ret

00005996 <__fp_inf>:
    5996:	97 f9       	bld	r25, 7
    5998:	9f 67       	ori	r25, 0x7F	; 127
    599a:	80 e8       	ldi	r24, 0x80	; 128
    599c:	70 e0       	ldi	r23, 0x00	; 0
    599e:	60 e0       	ldi	r22, 0x00	; 0
    59a0:	08 95       	ret

000059a2 <__fp_mintl>:
    59a2:	88 23       	and	r24, r24
    59a4:	71 f4       	brne	.+28     	; 0x59c2 <__fp_mintl+0x20>
    59a6:	77 23       	and	r23, r23
    59a8:	21 f0       	breq	.+8      	; 0x59b2 <__fp_mintl+0x10>
    59aa:	98 50       	subi	r25, 0x08	; 8
    59ac:	87 2b       	or	r24, r23
    59ae:	76 2f       	mov	r23, r22
    59b0:	07 c0       	rjmp	.+14     	; 0x59c0 <__fp_mintl+0x1e>
    59b2:	66 23       	and	r22, r22
    59b4:	11 f4       	brne	.+4      	; 0x59ba <__fp_mintl+0x18>
    59b6:	99 27       	eor	r25, r25
    59b8:	0d c0       	rjmp	.+26     	; 0x59d4 <__fp_mintl+0x32>
    59ba:	90 51       	subi	r25, 0x10	; 16
    59bc:	86 2b       	or	r24, r22
    59be:	70 e0       	ldi	r23, 0x00	; 0
    59c0:	60 e0       	ldi	r22, 0x00	; 0
    59c2:	2a f0       	brmi	.+10     	; 0x59ce <__fp_mintl+0x2c>
    59c4:	9a 95       	dec	r25
    59c6:	66 0f       	add	r22, r22
    59c8:	77 1f       	adc	r23, r23
    59ca:	88 1f       	adc	r24, r24
    59cc:	da f7       	brpl	.-10     	; 0x59c4 <__fp_mintl+0x22>
    59ce:	88 0f       	add	r24, r24
    59d0:	96 95       	lsr	r25
    59d2:	87 95       	ror	r24
    59d4:	97 f9       	bld	r25, 7
    59d6:	08 95       	ret

000059d8 <__fp_mpack>:
    59d8:	9f 3f       	cpi	r25, 0xFF	; 255
    59da:	49 f0       	breq	.+18     	; 0x59ee <__fp_mpack+0x16>
    59dc:	91 50       	subi	r25, 0x01	; 1
    59de:	28 f4       	brcc	.+10     	; 0x59ea <__fp_mpack+0x12>
    59e0:	86 95       	lsr	r24
    59e2:	77 95       	ror	r23
    59e4:	67 95       	ror	r22
    59e6:	b7 95       	ror	r27
    59e8:	9f 5f       	subi	r25, 0xFF	; 255
    59ea:	80 38       	cpi	r24, 0x80	; 128
    59ec:	9f 4f       	sbci	r25, 0xFF	; 255
    59ee:	88 0f       	add	r24, r24
    59f0:	96 95       	lsr	r25
    59f2:	87 95       	ror	r24
    59f4:	97 f9       	bld	r25, 7
    59f6:	08 95       	ret

000059f8 <__fp_nan>:
    59f8:	9f ef       	ldi	r25, 0xFF	; 255
    59fa:	80 ec       	ldi	r24, 0xC0	; 192
    59fc:	08 95       	ret

000059fe <__fp_powser>:
    59fe:	df 93       	push	r29
    5a00:	cf 93       	push	r28
    5a02:	1f 93       	push	r17
    5a04:	0f 93       	push	r16
    5a06:	ff 92       	push	r15
    5a08:	ef 92       	push	r14
    5a0a:	df 92       	push	r13
    5a0c:	7b 01       	movw	r14, r22
    5a0e:	8c 01       	movw	r16, r24
    5a10:	68 94       	set
    5a12:	05 c0       	rjmp	.+10     	; 0x5a1e <__fp_powser+0x20>
    5a14:	da 2e       	mov	r13, r26
    5a16:	ef 01       	movw	r28, r30
    5a18:	8d d0       	rcall	.+282    	; 0x5b34 <__mulsf3x>
    5a1a:	fe 01       	movw	r30, r28
    5a1c:	e8 94       	clt
    5a1e:	a5 91       	lpm	r26, Z+
    5a20:	25 91       	lpm	r18, Z+
    5a22:	35 91       	lpm	r19, Z+
    5a24:	45 91       	lpm	r20, Z+
    5a26:	55 91       	lpm	r21, Z+
    5a28:	ae f3       	brts	.-22     	; 0x5a14 <__fp_powser+0x16>
    5a2a:	ef 01       	movw	r28, r30
    5a2c:	ee dd       	rcall	.-1060   	; 0x560a <__addsf3x>
    5a2e:	fe 01       	movw	r30, r28
    5a30:	97 01       	movw	r18, r14
    5a32:	a8 01       	movw	r20, r16
    5a34:	da 94       	dec	r13
    5a36:	79 f7       	brne	.-34     	; 0x5a16 <__fp_powser+0x18>
    5a38:	df 90       	pop	r13
    5a3a:	ef 90       	pop	r14
    5a3c:	ff 90       	pop	r15
    5a3e:	0f 91       	pop	r16
    5a40:	1f 91       	pop	r17
    5a42:	cf 91       	pop	r28
    5a44:	df 91       	pop	r29
    5a46:	08 95       	ret

00005a48 <__fp_pscA>:
    5a48:	00 24       	eor	r0, r0
    5a4a:	0a 94       	dec	r0
    5a4c:	16 16       	cp	r1, r22
    5a4e:	17 06       	cpc	r1, r23
    5a50:	18 06       	cpc	r1, r24
    5a52:	09 06       	cpc	r0, r25
    5a54:	08 95       	ret

00005a56 <__fp_pscB>:
    5a56:	00 24       	eor	r0, r0
    5a58:	0a 94       	dec	r0
    5a5a:	12 16       	cp	r1, r18
    5a5c:	13 06       	cpc	r1, r19
    5a5e:	14 06       	cpc	r1, r20
    5a60:	05 06       	cpc	r0, r21
    5a62:	08 95       	ret

00005a64 <__fp_round>:
    5a64:	09 2e       	mov	r0, r25
    5a66:	03 94       	inc	r0
    5a68:	00 0c       	add	r0, r0
    5a6a:	11 f4       	brne	.+4      	; 0x5a70 <__fp_round+0xc>
    5a6c:	88 23       	and	r24, r24
    5a6e:	52 f0       	brmi	.+20     	; 0x5a84 <__fp_round+0x20>
    5a70:	bb 0f       	add	r27, r27
    5a72:	40 f4       	brcc	.+16     	; 0x5a84 <__fp_round+0x20>
    5a74:	bf 2b       	or	r27, r31
    5a76:	11 f4       	brne	.+4      	; 0x5a7c <__fp_round+0x18>
    5a78:	60 ff       	sbrs	r22, 0
    5a7a:	04 c0       	rjmp	.+8      	; 0x5a84 <__fp_round+0x20>
    5a7c:	6f 5f       	subi	r22, 0xFF	; 255
    5a7e:	7f 4f       	sbci	r23, 0xFF	; 255
    5a80:	8f 4f       	sbci	r24, 0xFF	; 255
    5a82:	9f 4f       	sbci	r25, 0xFF	; 255
    5a84:	08 95       	ret

00005a86 <__fp_split3>:
    5a86:	57 fd       	sbrc	r21, 7
    5a88:	90 58       	subi	r25, 0x80	; 128
    5a8a:	44 0f       	add	r20, r20
    5a8c:	55 1f       	adc	r21, r21
    5a8e:	59 f0       	breq	.+22     	; 0x5aa6 <__fp_splitA+0x10>
    5a90:	5f 3f       	cpi	r21, 0xFF	; 255
    5a92:	71 f0       	breq	.+28     	; 0x5ab0 <__fp_splitA+0x1a>
    5a94:	47 95       	ror	r20

00005a96 <__fp_splitA>:
    5a96:	88 0f       	add	r24, r24
    5a98:	97 fb       	bst	r25, 7
    5a9a:	99 1f       	adc	r25, r25
    5a9c:	61 f0       	breq	.+24     	; 0x5ab6 <__fp_splitA+0x20>
    5a9e:	9f 3f       	cpi	r25, 0xFF	; 255
    5aa0:	79 f0       	breq	.+30     	; 0x5ac0 <__fp_splitA+0x2a>
    5aa2:	87 95       	ror	r24
    5aa4:	08 95       	ret
    5aa6:	12 16       	cp	r1, r18
    5aa8:	13 06       	cpc	r1, r19
    5aaa:	14 06       	cpc	r1, r20
    5aac:	55 1f       	adc	r21, r21
    5aae:	f2 cf       	rjmp	.-28     	; 0x5a94 <__fp_split3+0xe>
    5ab0:	46 95       	lsr	r20
    5ab2:	f1 df       	rcall	.-30     	; 0x5a96 <__fp_splitA>
    5ab4:	08 c0       	rjmp	.+16     	; 0x5ac6 <__fp_splitA+0x30>
    5ab6:	16 16       	cp	r1, r22
    5ab8:	17 06       	cpc	r1, r23
    5aba:	18 06       	cpc	r1, r24
    5abc:	99 1f       	adc	r25, r25
    5abe:	f1 cf       	rjmp	.-30     	; 0x5aa2 <__fp_splitA+0xc>
    5ac0:	86 95       	lsr	r24
    5ac2:	71 05       	cpc	r23, r1
    5ac4:	61 05       	cpc	r22, r1
    5ac6:	08 94       	sec
    5ac8:	08 95       	ret

00005aca <__fp_trunc>:
    5aca:	e5 df       	rcall	.-54     	; 0x5a96 <__fp_splitA>
    5acc:	a0 f0       	brcs	.+40     	; 0x5af6 <__fp_trunc+0x2c>
    5ace:	be e7       	ldi	r27, 0x7E	; 126
    5ad0:	b9 17       	cp	r27, r25
    5ad2:	88 f4       	brcc	.+34     	; 0x5af6 <__fp_trunc+0x2c>
    5ad4:	bb 27       	eor	r27, r27
    5ad6:	9f 38       	cpi	r25, 0x8F	; 143
    5ad8:	60 f4       	brcc	.+24     	; 0x5af2 <__fp_trunc+0x28>
    5ada:	16 16       	cp	r1, r22
    5adc:	b1 1d       	adc	r27, r1
    5ade:	67 2f       	mov	r22, r23
    5ae0:	78 2f       	mov	r23, r24
    5ae2:	88 27       	eor	r24, r24
    5ae4:	98 5f       	subi	r25, 0xF8	; 248
    5ae6:	f7 cf       	rjmp	.-18     	; 0x5ad6 <__fp_trunc+0xc>
    5ae8:	86 95       	lsr	r24
    5aea:	77 95       	ror	r23
    5aec:	67 95       	ror	r22
    5aee:	b1 1d       	adc	r27, r1
    5af0:	93 95       	inc	r25
    5af2:	96 39       	cpi	r25, 0x96	; 150
    5af4:	c8 f3       	brcs	.-14     	; 0x5ae8 <__fp_trunc+0x1e>
    5af6:	08 95       	ret

00005af8 <__fp_zero>:
    5af8:	e8 94       	clt

00005afa <__fp_szero>:
    5afa:	bb 27       	eor	r27, r27
    5afc:	66 27       	eor	r22, r22
    5afe:	77 27       	eor	r23, r23
    5b00:	cb 01       	movw	r24, r22
    5b02:	97 f9       	bld	r25, 7
    5b04:	08 95       	ret

00005b06 <__gesf2>:
    5b06:	23 df       	rcall	.-442    	; 0x594e <__fp_cmp>
    5b08:	08 f4       	brcc	.+2      	; 0x5b0c <__gesf2+0x6>
    5b0a:	8f ef       	ldi	r24, 0xFF	; 255
    5b0c:	08 95       	ret

00005b0e <inverse>:
    5b0e:	9b 01       	movw	r18, r22
    5b10:	ac 01       	movw	r20, r24
    5b12:	60 e0       	ldi	r22, 0x00	; 0
    5b14:	70 e0       	ldi	r23, 0x00	; 0
    5b16:	80 e8       	ldi	r24, 0x80	; 128
    5b18:	9f e3       	ldi	r25, 0x3F	; 63
    5b1a:	30 ce       	rjmp	.-928    	; 0x577c <__divsf3>

00005b1c <__mulsf3>:
    5b1c:	0b d0       	rcall	.+22     	; 0x5b34 <__mulsf3x>
    5b1e:	a2 cf       	rjmp	.-188    	; 0x5a64 <__fp_round>
    5b20:	93 df       	rcall	.-218    	; 0x5a48 <__fp_pscA>
    5b22:	28 f0       	brcs	.+10     	; 0x5b2e <__mulsf3+0x12>
    5b24:	98 df       	rcall	.-208    	; 0x5a56 <__fp_pscB>
    5b26:	18 f0       	brcs	.+6      	; 0x5b2e <__mulsf3+0x12>
    5b28:	95 23       	and	r25, r21
    5b2a:	09 f0       	breq	.+2      	; 0x5b2e <__mulsf3+0x12>
    5b2c:	34 cf       	rjmp	.-408    	; 0x5996 <__fp_inf>
    5b2e:	64 cf       	rjmp	.-312    	; 0x59f8 <__fp_nan>
    5b30:	11 24       	eor	r1, r1
    5b32:	e3 cf       	rjmp	.-58     	; 0x5afa <__fp_szero>

00005b34 <__mulsf3x>:
    5b34:	a8 df       	rcall	.-176    	; 0x5a86 <__fp_split3>
    5b36:	a0 f3       	brcs	.-24     	; 0x5b20 <__mulsf3+0x4>

00005b38 <__mulsf3_pse>:
    5b38:	95 9f       	mul	r25, r21
    5b3a:	d1 f3       	breq	.-12     	; 0x5b30 <__mulsf3+0x14>
    5b3c:	95 0f       	add	r25, r21
    5b3e:	50 e0       	ldi	r21, 0x00	; 0
    5b40:	55 1f       	adc	r21, r21
    5b42:	62 9f       	mul	r22, r18
    5b44:	f0 01       	movw	r30, r0
    5b46:	72 9f       	mul	r23, r18
    5b48:	bb 27       	eor	r27, r27
    5b4a:	f0 0d       	add	r31, r0
    5b4c:	b1 1d       	adc	r27, r1
    5b4e:	63 9f       	mul	r22, r19
    5b50:	aa 27       	eor	r26, r26
    5b52:	f0 0d       	add	r31, r0
    5b54:	b1 1d       	adc	r27, r1
    5b56:	aa 1f       	adc	r26, r26
    5b58:	64 9f       	mul	r22, r20
    5b5a:	66 27       	eor	r22, r22
    5b5c:	b0 0d       	add	r27, r0
    5b5e:	a1 1d       	adc	r26, r1
    5b60:	66 1f       	adc	r22, r22
    5b62:	82 9f       	mul	r24, r18
    5b64:	22 27       	eor	r18, r18
    5b66:	b0 0d       	add	r27, r0
    5b68:	a1 1d       	adc	r26, r1
    5b6a:	62 1f       	adc	r22, r18
    5b6c:	73 9f       	mul	r23, r19
    5b6e:	b0 0d       	add	r27, r0
    5b70:	a1 1d       	adc	r26, r1
    5b72:	62 1f       	adc	r22, r18
    5b74:	83 9f       	mul	r24, r19
    5b76:	a0 0d       	add	r26, r0
    5b78:	61 1d       	adc	r22, r1
    5b7a:	22 1f       	adc	r18, r18
    5b7c:	74 9f       	mul	r23, r20
    5b7e:	33 27       	eor	r19, r19
    5b80:	a0 0d       	add	r26, r0
    5b82:	61 1d       	adc	r22, r1
    5b84:	23 1f       	adc	r18, r19
    5b86:	84 9f       	mul	r24, r20
    5b88:	60 0d       	add	r22, r0
    5b8a:	21 1d       	adc	r18, r1
    5b8c:	82 2f       	mov	r24, r18
    5b8e:	76 2f       	mov	r23, r22
    5b90:	6a 2f       	mov	r22, r26
    5b92:	11 24       	eor	r1, r1
    5b94:	9f 57       	subi	r25, 0x7F	; 127
    5b96:	50 40       	sbci	r21, 0x00	; 0
    5b98:	8a f0       	brmi	.+34     	; 0x5bbc <__mulsf3_pse+0x84>
    5b9a:	e1 f0       	breq	.+56     	; 0x5bd4 <__mulsf3_pse+0x9c>
    5b9c:	88 23       	and	r24, r24
    5b9e:	4a f0       	brmi	.+18     	; 0x5bb2 <__mulsf3_pse+0x7a>
    5ba0:	ee 0f       	add	r30, r30
    5ba2:	ff 1f       	adc	r31, r31
    5ba4:	bb 1f       	adc	r27, r27
    5ba6:	66 1f       	adc	r22, r22
    5ba8:	77 1f       	adc	r23, r23
    5baa:	88 1f       	adc	r24, r24
    5bac:	91 50       	subi	r25, 0x01	; 1
    5bae:	50 40       	sbci	r21, 0x00	; 0
    5bb0:	a9 f7       	brne	.-22     	; 0x5b9c <__mulsf3_pse+0x64>
    5bb2:	9e 3f       	cpi	r25, 0xFE	; 254
    5bb4:	51 05       	cpc	r21, r1
    5bb6:	70 f0       	brcs	.+28     	; 0x5bd4 <__mulsf3_pse+0x9c>
    5bb8:	ee ce       	rjmp	.-548    	; 0x5996 <__fp_inf>
    5bba:	9f cf       	rjmp	.-194    	; 0x5afa <__fp_szero>
    5bbc:	5f 3f       	cpi	r21, 0xFF	; 255
    5bbe:	ec f3       	brlt	.-6      	; 0x5bba <__mulsf3_pse+0x82>
    5bc0:	98 3e       	cpi	r25, 0xE8	; 232
    5bc2:	dc f3       	brlt	.-10     	; 0x5bba <__mulsf3_pse+0x82>
    5bc4:	86 95       	lsr	r24
    5bc6:	77 95       	ror	r23
    5bc8:	67 95       	ror	r22
    5bca:	b7 95       	ror	r27
    5bcc:	f7 95       	ror	r31
    5bce:	e7 95       	ror	r30
    5bd0:	9f 5f       	subi	r25, 0xFF	; 255
    5bd2:	c1 f7       	brne	.-16     	; 0x5bc4 <__mulsf3_pse+0x8c>
    5bd4:	fe 2b       	or	r31, r30
    5bd6:	88 0f       	add	r24, r24
    5bd8:	91 1d       	adc	r25, r1
    5bda:	96 95       	lsr	r25
    5bdc:	87 95       	ror	r24
    5bde:	97 f9       	bld	r25, 7
    5be0:	08 95       	ret

00005be2 <square>:
    5be2:	9b 01       	movw	r18, r22
    5be4:	ac 01       	movw	r20, r24
    5be6:	9a cf       	rjmp	.-204    	; 0x5b1c <__mulsf3>

00005be8 <__mulsi3>:
    5be8:	62 9f       	mul	r22, r18
    5bea:	d0 01       	movw	r26, r0
    5bec:	73 9f       	mul	r23, r19
    5bee:	f0 01       	movw	r30, r0
    5bf0:	82 9f       	mul	r24, r18
    5bf2:	e0 0d       	add	r30, r0
    5bf4:	f1 1d       	adc	r31, r1
    5bf6:	64 9f       	mul	r22, r20
    5bf8:	e0 0d       	add	r30, r0
    5bfa:	f1 1d       	adc	r31, r1
    5bfc:	92 9f       	mul	r25, r18
    5bfe:	f0 0d       	add	r31, r0
    5c00:	83 9f       	mul	r24, r19
    5c02:	f0 0d       	add	r31, r0
    5c04:	74 9f       	mul	r23, r20
    5c06:	f0 0d       	add	r31, r0
    5c08:	65 9f       	mul	r22, r21
    5c0a:	f0 0d       	add	r31, r0
    5c0c:	99 27       	eor	r25, r25
    5c0e:	72 9f       	mul	r23, r18
    5c10:	b0 0d       	add	r27, r0
    5c12:	e1 1d       	adc	r30, r1
    5c14:	f9 1f       	adc	r31, r25
    5c16:	63 9f       	mul	r22, r19
    5c18:	b0 0d       	add	r27, r0
    5c1a:	e1 1d       	adc	r30, r1
    5c1c:	f9 1f       	adc	r31, r25
    5c1e:	bd 01       	movw	r22, r26
    5c20:	cf 01       	movw	r24, r30
    5c22:	11 24       	eor	r1, r1
    5c24:	08 95       	ret

00005c26 <__udivmodhi4>:
    5c26:	aa 1b       	sub	r26, r26
    5c28:	bb 1b       	sub	r27, r27
    5c2a:	51 e1       	ldi	r21, 0x11	; 17
    5c2c:	07 c0       	rjmp	.+14     	; 0x5c3c <__udivmodhi4_ep>

00005c2e <__udivmodhi4_loop>:
    5c2e:	aa 1f       	adc	r26, r26
    5c30:	bb 1f       	adc	r27, r27
    5c32:	a6 17       	cp	r26, r22
    5c34:	b7 07       	cpc	r27, r23
    5c36:	10 f0       	brcs	.+4      	; 0x5c3c <__udivmodhi4_ep>
    5c38:	a6 1b       	sub	r26, r22
    5c3a:	b7 0b       	sbc	r27, r23

00005c3c <__udivmodhi4_ep>:
    5c3c:	88 1f       	adc	r24, r24
    5c3e:	99 1f       	adc	r25, r25
    5c40:	5a 95       	dec	r21
    5c42:	a9 f7       	brne	.-22     	; 0x5c2e <__udivmodhi4_loop>
    5c44:	80 95       	com	r24
    5c46:	90 95       	com	r25
    5c48:	bc 01       	movw	r22, r24
    5c4a:	cd 01       	movw	r24, r26
    5c4c:	08 95       	ret

00005c4e <__divmodhi4>:
    5c4e:	97 fb       	bst	r25, 7
    5c50:	09 2e       	mov	r0, r25
    5c52:	07 26       	eor	r0, r23
    5c54:	0a d0       	rcall	.+20     	; 0x5c6a <__divmodhi4_neg1>
    5c56:	77 fd       	sbrc	r23, 7
    5c58:	04 d0       	rcall	.+8      	; 0x5c62 <__divmodhi4_neg2>
    5c5a:	e5 df       	rcall	.-54     	; 0x5c26 <__udivmodhi4>
    5c5c:	06 d0       	rcall	.+12     	; 0x5c6a <__divmodhi4_neg1>
    5c5e:	00 20       	and	r0, r0
    5c60:	1a f4       	brpl	.+6      	; 0x5c68 <__divmodhi4_exit>

00005c62 <__divmodhi4_neg2>:
    5c62:	70 95       	com	r23
    5c64:	61 95       	neg	r22
    5c66:	7f 4f       	sbci	r23, 0xFF	; 255

00005c68 <__divmodhi4_exit>:
    5c68:	08 95       	ret

00005c6a <__divmodhi4_neg1>:
    5c6a:	f6 f7       	brtc	.-4      	; 0x5c68 <__divmodhi4_exit>
    5c6c:	90 95       	com	r25
    5c6e:	81 95       	neg	r24
    5c70:	9f 4f       	sbci	r25, 0xFF	; 255
    5c72:	08 95       	ret

00005c74 <__udivmodsi4>:
    5c74:	a1 e2       	ldi	r26, 0x21	; 33
    5c76:	1a 2e       	mov	r1, r26
    5c78:	aa 1b       	sub	r26, r26
    5c7a:	bb 1b       	sub	r27, r27
    5c7c:	fd 01       	movw	r30, r26
    5c7e:	0d c0       	rjmp	.+26     	; 0x5c9a <__udivmodsi4_ep>

00005c80 <__udivmodsi4_loop>:
    5c80:	aa 1f       	adc	r26, r26
    5c82:	bb 1f       	adc	r27, r27
    5c84:	ee 1f       	adc	r30, r30
    5c86:	ff 1f       	adc	r31, r31
    5c88:	a2 17       	cp	r26, r18
    5c8a:	b3 07       	cpc	r27, r19
    5c8c:	e4 07       	cpc	r30, r20
    5c8e:	f5 07       	cpc	r31, r21
    5c90:	20 f0       	brcs	.+8      	; 0x5c9a <__udivmodsi4_ep>
    5c92:	a2 1b       	sub	r26, r18
    5c94:	b3 0b       	sbc	r27, r19
    5c96:	e4 0b       	sbc	r30, r20
    5c98:	f5 0b       	sbc	r31, r21

00005c9a <__udivmodsi4_ep>:
    5c9a:	66 1f       	adc	r22, r22
    5c9c:	77 1f       	adc	r23, r23
    5c9e:	88 1f       	adc	r24, r24
    5ca0:	99 1f       	adc	r25, r25
    5ca2:	1a 94       	dec	r1
    5ca4:	69 f7       	brne	.-38     	; 0x5c80 <__udivmodsi4_loop>
    5ca6:	60 95       	com	r22
    5ca8:	70 95       	com	r23
    5caa:	80 95       	com	r24
    5cac:	90 95       	com	r25
    5cae:	9b 01       	movw	r18, r22
    5cb0:	ac 01       	movw	r20, r24
    5cb2:	bd 01       	movw	r22, r26
    5cb4:	cf 01       	movw	r24, r30
    5cb6:	08 95       	ret

00005cb8 <__divmodsi4>:
    5cb8:	97 fb       	bst	r25, 7
    5cba:	09 2e       	mov	r0, r25
    5cbc:	05 26       	eor	r0, r21
    5cbe:	0e d0       	rcall	.+28     	; 0x5cdc <__divmodsi4_neg1>
    5cc0:	57 fd       	sbrc	r21, 7
    5cc2:	04 d0       	rcall	.+8      	; 0x5ccc <__divmodsi4_neg2>
    5cc4:	d7 df       	rcall	.-82     	; 0x5c74 <__udivmodsi4>
    5cc6:	0a d0       	rcall	.+20     	; 0x5cdc <__divmodsi4_neg1>
    5cc8:	00 1c       	adc	r0, r0
    5cca:	38 f4       	brcc	.+14     	; 0x5cda <__divmodsi4_exit>

00005ccc <__divmodsi4_neg2>:
    5ccc:	50 95       	com	r21
    5cce:	40 95       	com	r20
    5cd0:	30 95       	com	r19
    5cd2:	21 95       	neg	r18
    5cd4:	3f 4f       	sbci	r19, 0xFF	; 255
    5cd6:	4f 4f       	sbci	r20, 0xFF	; 255
    5cd8:	5f 4f       	sbci	r21, 0xFF	; 255

00005cda <__divmodsi4_exit>:
    5cda:	08 95       	ret

00005cdc <__divmodsi4_neg1>:
    5cdc:	f6 f7       	brtc	.-4      	; 0x5cda <__divmodsi4_exit>
    5cde:	90 95       	com	r25
    5ce0:	80 95       	com	r24
    5ce2:	70 95       	com	r23
    5ce4:	61 95       	neg	r22
    5ce6:	7f 4f       	sbci	r23, 0xFF	; 255
    5ce8:	8f 4f       	sbci	r24, 0xFF	; 255
    5cea:	9f 4f       	sbci	r25, 0xFF	; 255
    5cec:	08 95       	ret

00005cee <_exit>:
    5cee:	f8 94       	cli

00005cf0 <__stop_program>:
    5cf0:	ff cf       	rjmp	.-2      	; 0x5cf0 <__stop_program>

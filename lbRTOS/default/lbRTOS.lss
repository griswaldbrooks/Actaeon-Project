
lbRTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000be  00800200  00005d02  00005d96  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00005d02  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000011fa  008002be  008002be  00005e54  2**0
                  ALLOC
  3 .debug_aranges 000001a0  00000000  00000000  00005e54  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000018a1  00000000  00000000  00005ff4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00005aa1  00000000  00000000  00007895  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001764  00000000  00000000  0000d336  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00004947  00000000  00000000  0000ea9a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000011f0  00000000  00000000  000133e4  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000024ad  00000000  00000000  000145d4  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00002a2f  00000000  00000000  00016a81  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000030  00000000  00000000  000194b0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 e6 00 	jmp	0x1cc	; 0x1cc <__ctors_end>
       4:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
       8:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
       c:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      10:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      14:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      18:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      1c:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      20:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      24:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      28:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      2c:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      30:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      34:	0c 94 82 1d 	jmp	0x3b04	; 0x3b04 <__vector_13>
      38:	0c 94 af 1d 	jmp	0x3b5e	; 0x3b5e <__vector_14>
      3c:	0c 94 a1 1b 	jmp	0x3742	; 0x3742 <__vector_15>
      40:	0c 94 fb 1c 	jmp	0x39f6	; 0x39f6 <__vector_16>
      44:	0c 94 cf 16 	jmp	0x2d9e	; 0x2d9e <__vector_17>
      48:	0c 94 28 1d 	jmp	0x3a50	; 0x3a50 <__vector_18>
      4c:	0c 94 55 1d 	jmp	0x3aaa	; 0x3aaa <__vector_19>
      50:	0c 94 61 1b 	jmp	0x36c2	; 0x36c2 <__vector_20>
      54:	0c 94 a1 1c 	jmp	0x3942	; 0x3942 <__vector_21>
      58:	0c 94 ce 1c 	jmp	0x399c	; 0x399c <__vector_22>
      5c:	0c 94 0e 1b 	jmp	0x361c	; 0x361c <__vector_23>
      60:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      64:	0c 94 78 21 	jmp	0x42f0	; 0x42f0 <__vector_25>
      68:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      6c:	0c 94 d5 22 	jmp	0x45aa	; 0x45aa <__vector_27>
      70:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      74:	0c 94 8f 25 	jmp	0x4b1e	; 0x4b1e <__vector_29>
      78:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      7c:	0c 94 dc 1d 	jmp	0x3bb8	; 0x3bb8 <__vector_31>
      80:	0c 94 09 1e 	jmp	0x3c12	; 0x3c12 <__vector_32>
      84:	0c 94 36 1e 	jmp	0x3c6c	; 0x3c6c <__vector_33>
      88:	0c 94 63 1e 	jmp	0x3cc6	; 0x3cc6 <__vector_34>
      8c:	0c 94 e1 1b 	jmp	0x37c2	; 0x37c2 <__vector_35>
      90:	0c 94 53 21 	jmp	0x42a6	; 0x42a6 <__vector_36>
      94:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      98:	0c 94 b0 22 	jmp	0x4560	; 0x4560 <__vector_38>
      9c:	0c 94 ad 29 	jmp	0x535a	; 0x535a <__vector_39>
      a0:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      a4:	0c 94 90 1e 	jmp	0x3d20	; 0x3d20 <__vector_41>
      a8:	0c 94 bd 1e 	jmp	0x3d7a	; 0x3d7a <__vector_42>
      ac:	0c 94 ea 1e 	jmp	0x3dd4	; 0x3dd4 <__vector_43>
      b0:	0c 94 17 1f 	jmp	0x3e2e	; 0x3e2e <__vector_44>
      b4:	0c 94 21 1c 	jmp	0x3842	; 0x3842 <__vector_45>
      b8:	0c 94 44 1f 	jmp	0x3e88	; 0x3e88 <__vector_46>
      bc:	0c 94 71 1f 	jmp	0x3ee2	; 0x3ee2 <__vector_47>
      c0:	0c 94 9e 1f 	jmp	0x3f3c	; 0x3f3c <__vector_48>
      c4:	0c 94 cb 1f 	jmp	0x3f96	; 0x3f96 <__vector_49>
      c8:	0c 94 61 1c 	jmp	0x38c2	; 0x38c2 <__vector_50>
      cc:	0c 94 2e 21 	jmp	0x425c	; 0x425c <__vector_51>
      d0:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      d4:	0c 94 8b 22 	jmp	0x4516	; 0x4516 <__vector_53>
      d8:	0c 94 09 21 	jmp	0x4212	; 0x4212 <__vector_54>
      dc:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      e0:	0c 94 66 22 	jmp	0x44cc	; 0x44cc <__vector_56>
      e4:	08 4a       	sbci	r16, 0xA8	; 168
      e6:	d7 3b       	cpi	r29, 0xB7	; 183
      e8:	3b ce       	rjmp	.-906    	; 0xfffffd60 <__eeprom_end+0xff7efd60>
      ea:	01 6e       	ori	r16, 0xE1	; 225
      ec:	84 bc       	out	0x24, r8	; 36
      ee:	bf fd       	.word	0xfdbf	; ????
      f0:	c1 2f       	mov	r28, r17
      f2:	3d 6c       	ori	r19, 0xCD	; 205
      f4:	74 31       	cpi	r23, 0x14	; 20
      f6:	9a bd       	out	0x2a, r25	; 42
      f8:	56 83       	std	Z+6, r21	; 0x06
      fa:	3d da       	rcall	.-2950   	; 0xfffff576 <__eeprom_end+0xff7ef576>
      fc:	3d 00       	.word	0x003d	; ????
      fe:	c7 7f       	andi	r28, 0xF7	; 247
     100:	11 be       	out	0x31, r1	; 49
     102:	d9 e4       	ldi	r29, 0x49	; 73
     104:	bb 4c       	sbci	r27, 0xCB	; 203
     106:	3e 91       	ld	r19, -X
     108:	6b aa       	std	Y+51, r6	; 0x33
     10a:	aa be       	out	0x3a, r10	; 58
     10c:	00 00       	nop
     10e:	00 80       	ld	r0, Z
     110:	3f 44       	sbci	r19, 0x4F	; 79

00000111 <__c.3359>:
     111:	44 45 41 54 48 0a 00                                DEATH..

00000118 <__c.3323>:
     118:	20 4f 6d 65 67 61 3a 20 00                           Omega: .

00000121 <__c.3321>:
     121:	52 65 63 65 69 76 65 64 20 56 65 6c 6f 63 69 74     Received Velocit
     131:	79 3a 20 00                                         y: .

00000135 <__c.3309>:
     135:	63 6d 64 5f 61 6e 67 6c 65 3a 20 00                 cmd_angle: .

00000141 <__c.3307>:
     141:	63 6d 64 5f 61 6e 67 6c 65 3a 20 00                 cmd_angle: .

0000014d <__c.3201>:
     14d:	0a 00                                               ..

0000014f <__c.3199>:
     14f:	25 64 00                                            %d.

00000152 <__c.3187>:
     152:	25 64 0a 00                                         %d..

00000156 <__c.3097>:
     156:	49 6e 69 74 69 61 6c 69 7a 61 74 69 6f 6e 20 43     Initialization C
     166:	6f 6d 70 6c 65 74 65 20 0d 0a 00                    omplete ...

00000171 <__c.3092>:
     171:	2e 00                                               ..

00000173 <__c.3090>:
     173:	0d 0a 53 79 73 74 65 6d 20 57 61 72 6d 65 64 20     ..System Warmed 
     183:	55 70 00                                            Up.

00000186 <__c.3045>:
     186:	57 52 0a 00                                         WR..

0000018a <__c.3014>:
     18a:	57 52 0a 00                                         WR..

0000018e <TimerPrescaleFactor>:
     18e:	00 00 01 00 08 00 40 00 00 01 00 04                 ......@.....

0000019a <Timer2PrescaleFactor>:
     19a:	00 00 01 00 08 00 20 00 40 00 80 00 00 01 00 04     ...... .@.......

000001aa <__c.1991>:
     1aa:	42 41 44 5f 76 65 63 74 20 63 61 6c 6c 65 64 21     BAD_vect called!
	...

000001bb <HexChars>:
     1bb:	30 31 32 33 34 35 36 37 38 39 41 42 43 44 45 46     0123456789ABCDEF
	...

000001cc <__ctors_end>:
     1cc:	11 24       	eor	r1, r1
     1ce:	1f be       	out	0x3f, r1	; 63
     1d0:	cf ef       	ldi	r28, 0xFF	; 255
     1d2:	d1 e2       	ldi	r29, 0x21	; 33
     1d4:	de bf       	out	0x3e, r29	; 62
     1d6:	cd bf       	out	0x3d, r28	; 61

000001d8 <__do_copy_data>:
     1d8:	12 e0       	ldi	r17, 0x02	; 2
     1da:	a0 e0       	ldi	r26, 0x00	; 0
     1dc:	b2 e0       	ldi	r27, 0x02	; 2
     1de:	e2 e0       	ldi	r30, 0x02	; 2
     1e0:	fd e5       	ldi	r31, 0x5D	; 93
     1e2:	02 c0       	rjmp	.+4      	; 0x1e8 <.do_copy_data_start>

000001e4 <.do_copy_data_loop>:
     1e4:	05 90       	lpm	r0, Z+
     1e6:	0d 92       	st	X+, r0

000001e8 <.do_copy_data_start>:
     1e8:	ae 3b       	cpi	r26, 0xBE	; 190
     1ea:	b1 07       	cpc	r27, r17
     1ec:	d9 f7       	brne	.-10     	; 0x1e4 <.do_copy_data_loop>

000001ee <__do_clear_bss>:
     1ee:	14 e1       	ldi	r17, 0x14	; 20
     1f0:	ae eb       	ldi	r26, 0xBE	; 190
     1f2:	b2 e0       	ldi	r27, 0x02	; 2
     1f4:	01 c0       	rjmp	.+2      	; 0x1f8 <.do_clear_bss_start>

000001f6 <.do_clear_bss_loop>:
     1f6:	1d 92       	st	X+, r1

000001f8 <.do_clear_bss_start>:
     1f8:	a8 3b       	cpi	r26, 0xB8	; 184
     1fa:	b1 07       	cpc	r27, r17
     1fc:	e1 f7       	brne	.-8      	; 0x1f6 <.do_clear_bss_loop>
     1fe:	0e 94 79 0d 	call	0x1af2	; 0x1af2 <main>
     202:	0c 94 d9 2a 	jmp	0x55b2	; 0x55b2 <exit>

00000206 <__bad_interrupt>:
     206:	0c 94 f8 1f 	jmp	0x3ff0	; 0x3ff0 <__vector_default>

0000020a <PWM_Init_timer1_LED>:

//OC1B  pin B6 (attached to green LED)
void PWM_Init_timer1_LED(u08 bitRes)
{
	// enable timer2 as 8,9,10bit PWM
	if(bitRes == 9)
     20a:	89 30       	cpi	r24, 0x09	; 9
     20c:	49 f4       	brne	.+18     	; 0x220 <PWM_Init_timer1_LED+0x16>
	{	// 9bit mode
		sbi(TCCR1A,PWM11);
     20e:	80 91 80 00 	lds	r24, 0x0080
     212:	82 60       	ori	r24, 0x02	; 2
     214:	80 93 80 00 	sts	0x0080, r24
		cbi(TCCR1A,PWM10);
     218:	80 91 80 00 	lds	r24, 0x0080
     21c:	8e 7f       	andi	r24, 0xFE	; 254
     21e:	0e c0       	rjmp	.+28     	; 0x23c <PWM_Init_timer1_LED+0x32>
	}
	else if( bitRes == 10 )
     220:	8a 30       	cpi	r24, 0x0A	; 10
     222:	21 f4       	brne	.+8      	; 0x22c <PWM_Init_timer1_LED+0x22>
	{	// 10bit mode
		sbi(TCCR1A,PWM11);
     224:	80 91 80 00 	lds	r24, 0x0080
     228:	82 60       	ori	r24, 0x02	; 2
     22a:	03 c0       	rjmp	.+6      	; 0x232 <PWM_Init_timer1_LED+0x28>
		sbi(TCCR1A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR1A,PWM11);
     22c:	80 91 80 00 	lds	r24, 0x0080
     230:	8d 7f       	andi	r24, 0xFD	; 253
     232:	80 93 80 00 	sts	0x0080, r24
		sbi(TCCR1A,PWM10);
     236:	80 91 80 00 	lds	r24, 0x0080
     23a:	81 60       	ori	r24, 0x01	; 1
     23c:	80 93 80 00 	sts	0x0080, r24
	}
	// clear output compare values
	OCR1B = 0;
     240:	10 92 8b 00 	sts	0x008B, r1
     244:	10 92 8a 00 	sts	0x008A, r1
}
     248:	08 95       	ret

0000024a <PWM_Init_timer2_H6>:
//pin H6, timer2
void PWM_Init_timer2_H6(u08 bitRes)
{
	// enable timer2 as 8,9,10bit PWM
	if(bitRes == 9)
     24a:	89 30       	cpi	r24, 0x09	; 9
     24c:	49 f4       	brne	.+18     	; 0x260 <PWM_Init_timer2_H6+0x16>
	{	// 9bit mode
		sbi(TCCR2A,PWM11);
     24e:	80 91 b0 00 	lds	r24, 0x00B0
     252:	82 60       	ori	r24, 0x02	; 2
     254:	80 93 b0 00 	sts	0x00B0, r24
		cbi(TCCR2A,PWM10);
     258:	80 91 b0 00 	lds	r24, 0x00B0
     25c:	8e 7f       	andi	r24, 0xFE	; 254
     25e:	0e c0       	rjmp	.+28     	; 0x27c <PWM_Init_timer2_H6+0x32>
	}
	else if( bitRes == 10 )
     260:	8a 30       	cpi	r24, 0x0A	; 10
     262:	21 f4       	brne	.+8      	; 0x26c <PWM_Init_timer2_H6+0x22>
	{	// 10bit mode
		sbi(TCCR2A,PWM11);
     264:	80 91 b0 00 	lds	r24, 0x00B0
     268:	82 60       	ori	r24, 0x02	; 2
     26a:	03 c0       	rjmp	.+6      	; 0x272 <PWM_Init_timer2_H6+0x28>
		sbi(TCCR2A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR2A,PWM11);
     26c:	80 91 b0 00 	lds	r24, 0x00B0
     270:	8d 7f       	andi	r24, 0xFD	; 253
     272:	80 93 b0 00 	sts	0x00B0, r24
		sbi(TCCR2A,PWM10);
     276:	80 91 b0 00 	lds	r24, 0x00B0
     27a:	81 60       	ori	r24, 0x01	; 1
     27c:	80 93 b0 00 	sts	0x00B0, r24
	}
	// clear output compare values
	OCR2B = 0;
     280:	10 92 b4 00 	sts	0x00B4, r1
}
     284:	08 95       	ret

00000286 <PWM_Init_timer3_E3>:
//pin E3
void PWM_Init_timer3_E3(u08 bitRes)
{
	// enable timer3 as 8,9,10bit PWM
	if(bitRes == 9)
     286:	89 30       	cpi	r24, 0x09	; 9
     288:	49 f4       	brne	.+18     	; 0x29c <PWM_Init_timer3_E3+0x16>
	{	// 9bit mode
		sbi(TCCR3A,PWM11);
     28a:	80 91 90 00 	lds	r24, 0x0090
     28e:	82 60       	ori	r24, 0x02	; 2
     290:	80 93 90 00 	sts	0x0090, r24
		cbi(TCCR3A,PWM10);
     294:	80 91 90 00 	lds	r24, 0x0090
     298:	8e 7f       	andi	r24, 0xFE	; 254
     29a:	0e c0       	rjmp	.+28     	; 0x2b8 <PWM_Init_timer3_E3+0x32>
	}
	else if( bitRes == 10 )
     29c:	8a 30       	cpi	r24, 0x0A	; 10
     29e:	21 f4       	brne	.+8      	; 0x2a8 <PWM_Init_timer3_E3+0x22>
	{	// 10bit mode
		sbi(TCCR3A,PWM11);
     2a0:	80 91 90 00 	lds	r24, 0x0090
     2a4:	82 60       	ori	r24, 0x02	; 2
     2a6:	03 c0       	rjmp	.+6      	; 0x2ae <PWM_Init_timer3_E3+0x28>
		sbi(TCCR3A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR3A,PWM11);
     2a8:	80 91 90 00 	lds	r24, 0x0090
     2ac:	8d 7f       	andi	r24, 0xFD	; 253
     2ae:	80 93 90 00 	sts	0x0090, r24
		sbi(TCCR3A,PWM10);
     2b2:	80 91 90 00 	lds	r24, 0x0090
     2b6:	81 60       	ori	r24, 0x01	; 1
     2b8:	80 93 90 00 	sts	0x0090, r24
	}
	// clear output compare values
	OCR3A = 0;
     2bc:	10 92 99 00 	sts	0x0099, r1
     2c0:	10 92 98 00 	sts	0x0098, r1
	//timer3PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     2c4:	08 95       	ret

000002c6 <PWM_Init_timer3_E4>:
//pin E4
void PWM_Init_timer3_E4(u08 bitRes)
{
	// enable timer3 as 8,9,10bit PWM
	if(bitRes == 9)
     2c6:	89 30       	cpi	r24, 0x09	; 9
     2c8:	49 f4       	brne	.+18     	; 0x2dc <PWM_Init_timer3_E4+0x16>
	{	// 9bit mode
		sbi(TCCR3B,PWM11);
     2ca:	80 91 91 00 	lds	r24, 0x0091
     2ce:	82 60       	ori	r24, 0x02	; 2
     2d0:	80 93 91 00 	sts	0x0091, r24
		cbi(TCCR3B,PWM10);
     2d4:	80 91 91 00 	lds	r24, 0x0091
     2d8:	8e 7f       	andi	r24, 0xFE	; 254
     2da:	0e c0       	rjmp	.+28     	; 0x2f8 <PWM_Init_timer3_E4+0x32>
	}
	else if( bitRes == 10 )
     2dc:	8a 30       	cpi	r24, 0x0A	; 10
     2de:	21 f4       	brne	.+8      	; 0x2e8 <PWM_Init_timer3_E4+0x22>
	{	// 10bit mode
		sbi(TCCR3B,PWM11);
     2e0:	80 91 91 00 	lds	r24, 0x0091
     2e4:	82 60       	ori	r24, 0x02	; 2
     2e6:	03 c0       	rjmp	.+6      	; 0x2ee <PWM_Init_timer3_E4+0x28>
		sbi(TCCR3B,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR3B,PWM11);
     2e8:	80 91 91 00 	lds	r24, 0x0091
     2ec:	8d 7f       	andi	r24, 0xFD	; 253
     2ee:	80 93 91 00 	sts	0x0091, r24
		sbi(TCCR3B,PWM10);
     2f2:	80 91 91 00 	lds	r24, 0x0091
     2f6:	81 60       	ori	r24, 0x01	; 1
     2f8:	80 93 91 00 	sts	0x0091, r24
	}
	// clear output compare values
	OCR3B = 0;
     2fc:	10 92 9b 00 	sts	0x009B, r1
     300:	10 92 9a 00 	sts	0x009A, r1
	//timer3PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     304:	08 95       	ret

00000306 <PWM_Init_timer3_E5>:
//pin E5
void PWM_Init_timer3_E5(u08 bitRes)
{
	// enable timer3 as 8,9,10bit PWM
	if(bitRes == 9)
     306:	89 30       	cpi	r24, 0x09	; 9
     308:	49 f4       	brne	.+18     	; 0x31c <PWM_Init_timer3_E5+0x16>
	{	// 9bit mode
		sbi(TCCR3C,PWM11);
     30a:	80 91 92 00 	lds	r24, 0x0092
     30e:	82 60       	ori	r24, 0x02	; 2
     310:	80 93 92 00 	sts	0x0092, r24
		cbi(TCCR3C,PWM10);
     314:	80 91 92 00 	lds	r24, 0x0092
     318:	8e 7f       	andi	r24, 0xFE	; 254
     31a:	0e c0       	rjmp	.+28     	; 0x338 <PWM_Init_timer3_E5+0x32>
	}
	else if( bitRes == 10 )
     31c:	8a 30       	cpi	r24, 0x0A	; 10
     31e:	21 f4       	brne	.+8      	; 0x328 <PWM_Init_timer3_E5+0x22>
	{	// 10bit mode
		sbi(TCCR3C,PWM11);
     320:	80 91 92 00 	lds	r24, 0x0092
     324:	82 60       	ori	r24, 0x02	; 2
     326:	03 c0       	rjmp	.+6      	; 0x32e <PWM_Init_timer3_E5+0x28>
		sbi(TCCR3C,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR3C,PWM11);
     328:	80 91 92 00 	lds	r24, 0x0092
     32c:	8d 7f       	andi	r24, 0xFD	; 253
     32e:	80 93 92 00 	sts	0x0092, r24
		sbi(TCCR3C,PWM10);
     332:	80 91 92 00 	lds	r24, 0x0092
     336:	81 60       	ori	r24, 0x01	; 1
     338:	80 93 92 00 	sts	0x0092, r24
	}
	// clear output compare values
	OCR3C = 0;
     33c:	10 92 9d 00 	sts	0x009D, r1
     340:	10 92 9c 00 	sts	0x009C, r1
	//timer3PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     344:	08 95       	ret

00000346 <PWM_Init_timer4_H3>:
//pin H3, timer4
void PWM_Init_timer4_H3(u08 bitRes)
{
	// enable timer4 as 8,9,10bit PWM
	if(bitRes == 9)
     346:	89 30       	cpi	r24, 0x09	; 9
     348:	49 f4       	brne	.+18     	; 0x35c <PWM_Init_timer4_H3+0x16>
	{	// 9bit mode
		sbi(TCCR4A,PWM11);
     34a:	80 91 a0 00 	lds	r24, 0x00A0
     34e:	82 60       	ori	r24, 0x02	; 2
     350:	80 93 a0 00 	sts	0x00A0, r24
		cbi(TCCR4A,PWM10);
     354:	80 91 a0 00 	lds	r24, 0x00A0
     358:	8e 7f       	andi	r24, 0xFE	; 254
     35a:	0e c0       	rjmp	.+28     	; 0x378 <PWM_Init_timer4_H3+0x32>
	}
	else if( bitRes == 10 )
     35c:	8a 30       	cpi	r24, 0x0A	; 10
     35e:	21 f4       	brne	.+8      	; 0x368 <PWM_Init_timer4_H3+0x22>
	{	// 10bit mode
		sbi(TCCR4A,PWM11);
     360:	80 91 a0 00 	lds	r24, 0x00A0
     364:	82 60       	ori	r24, 0x02	; 2
     366:	03 c0       	rjmp	.+6      	; 0x36e <PWM_Init_timer4_H3+0x28>
		sbi(TCCR4A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR4A,PWM11);
     368:	80 91 a0 00 	lds	r24, 0x00A0
     36c:	8d 7f       	andi	r24, 0xFD	; 253
     36e:	80 93 a0 00 	sts	0x00A0, r24
		sbi(TCCR4A,PWM10);
     372:	80 91 a0 00 	lds	r24, 0x00A0
     376:	81 60       	ori	r24, 0x01	; 1
     378:	80 93 a0 00 	sts	0x00A0, r24
	}
	// clear output compare values
	OCR4A = 0;
     37c:	10 92 a9 00 	sts	0x00A9, r1
     380:	10 92 a8 00 	sts	0x00A8, r1
	//timer4PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     384:	08 95       	ret

00000386 <PWM_Init_timer4_H4>:
//pin H4, timer4
void PWM_Init_timer4_H4(u08 bitRes)
{
	// enable timer4 as 8,9,10bit PWM
	if(bitRes == 9)
     386:	89 30       	cpi	r24, 0x09	; 9
     388:	49 f4       	brne	.+18     	; 0x39c <PWM_Init_timer4_H4+0x16>
	{	// 9bit mode
		sbi(TCCR4B,PWM11);
     38a:	80 91 a1 00 	lds	r24, 0x00A1
     38e:	82 60       	ori	r24, 0x02	; 2
     390:	80 93 a1 00 	sts	0x00A1, r24
		cbi(TCCR4B,PWM10);
     394:	80 91 a1 00 	lds	r24, 0x00A1
     398:	8e 7f       	andi	r24, 0xFE	; 254
     39a:	0e c0       	rjmp	.+28     	; 0x3b8 <PWM_Init_timer4_H4+0x32>
	}
	else if( bitRes == 10 )
     39c:	8a 30       	cpi	r24, 0x0A	; 10
     39e:	21 f4       	brne	.+8      	; 0x3a8 <PWM_Init_timer4_H4+0x22>
	{	// 10bit mode
		sbi(TCCR4B,PWM11);
     3a0:	80 91 a1 00 	lds	r24, 0x00A1
     3a4:	82 60       	ori	r24, 0x02	; 2
     3a6:	03 c0       	rjmp	.+6      	; 0x3ae <PWM_Init_timer4_H4+0x28>
		sbi(TCCR4B,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR4B,PWM11);
     3a8:	80 91 a1 00 	lds	r24, 0x00A1
     3ac:	8d 7f       	andi	r24, 0xFD	; 253
     3ae:	80 93 a1 00 	sts	0x00A1, r24
		sbi(TCCR4B,PWM10);
     3b2:	80 91 a1 00 	lds	r24, 0x00A1
     3b6:	81 60       	ori	r24, 0x01	; 1
     3b8:	80 93 a1 00 	sts	0x00A1, r24
	}
	// clear output compare values
	OCR4B = 0;
     3bc:	10 92 ab 00 	sts	0x00AB, r1
     3c0:	10 92 aa 00 	sts	0x00AA, r1
	//timer4PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     3c4:	08 95       	ret

000003c6 <PWM_Init_timer4_H5>:
//pin H5, timer4
void PWM_Init_timer4_H5(u08 bitRes)
{
	// enable timer4 as 8,9,10bit PWM
	if(bitRes == 9)
     3c6:	89 30       	cpi	r24, 0x09	; 9
     3c8:	49 f4       	brne	.+18     	; 0x3dc <PWM_Init_timer4_H5+0x16>
	{	// 9bit mode
		sbi(TCCR4A,PWM11);
     3ca:	80 91 a0 00 	lds	r24, 0x00A0
     3ce:	82 60       	ori	r24, 0x02	; 2
     3d0:	80 93 a0 00 	sts	0x00A0, r24
		cbi(TCCR4A,PWM10);
     3d4:	80 91 a0 00 	lds	r24, 0x00A0
     3d8:	8e 7f       	andi	r24, 0xFE	; 254
     3da:	0e c0       	rjmp	.+28     	; 0x3f8 <PWM_Init_timer4_H5+0x32>
	}
	else if( bitRes == 10 )
     3dc:	8a 30       	cpi	r24, 0x0A	; 10
     3de:	21 f4       	brne	.+8      	; 0x3e8 <PWM_Init_timer4_H5+0x22>
	{	// 10bit mode
		sbi(TCCR4A,PWM11);
     3e0:	80 91 a0 00 	lds	r24, 0x00A0
     3e4:	82 60       	ori	r24, 0x02	; 2
     3e6:	03 c0       	rjmp	.+6      	; 0x3ee <PWM_Init_timer4_H5+0x28>
		sbi(TCCR4A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR4A,PWM11);
     3e8:	80 91 a0 00 	lds	r24, 0x00A0
     3ec:	8d 7f       	andi	r24, 0xFD	; 253
     3ee:	80 93 a0 00 	sts	0x00A0, r24
		sbi(TCCR4A,PWM10);
     3f2:	80 91 a0 00 	lds	r24, 0x00A0
     3f6:	81 60       	ori	r24, 0x01	; 1
     3f8:	80 93 a0 00 	sts	0x00A0, r24
	}
	// clear output compare values
	OCR4C = 0;
     3fc:	10 92 ad 00 	sts	0x00AD, r1
     400:	10 92 ac 00 	sts	0x00AC, r1
	//timer4PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     404:	08 95       	ret

00000406 <timer1PWMInitICR>:
// include support for arbitrary top-count PWM
// on new AVR processors that support it
void timer1PWMInitICR(u16 topcount)
{
	// set PWM mode with ICR top-count
	cbi(TCCR1A,WGM10);
     406:	e0 e8       	ldi	r30, 0x80	; 128
     408:	f0 e0       	ldi	r31, 0x00	; 0
     40a:	20 81       	ld	r18, Z
     40c:	2e 7f       	andi	r18, 0xFE	; 254
     40e:	20 83       	st	Z, r18
	sbi(TCCR1A,WGM11);
     410:	20 81       	ld	r18, Z
     412:	22 60       	ori	r18, 0x02	; 2
     414:	20 83       	st	Z, r18
	sbi(TCCR1B,WGM12);
     416:	e1 e8       	ldi	r30, 0x81	; 129
     418:	f0 e0       	ldi	r31, 0x00	; 0
     41a:	20 81       	ld	r18, Z
     41c:	28 60       	ori	r18, 0x08	; 8
     41e:	20 83       	st	Z, r18
	sbi(TCCR1B,WGM13);
     420:	20 81       	ld	r18, Z
     422:	20 61       	ori	r18, 0x10	; 16
     424:	20 83       	st	Z, r18
	
	// set top count value
	ICR1 = topcount;
     426:	90 93 87 00 	sts	0x0087, r25
     42a:	80 93 86 00 	sts	0x0086, r24
	
	// clear output compare values
	OCR1A = 0;
     42e:	10 92 89 00 	sts	0x0089, r1
     432:	10 92 88 00 	sts	0x0088, r1
	OCR1B = 0;
     436:	10 92 8b 00 	sts	0x008B, r1
     43a:	10 92 8a 00 	sts	0x008A, r1
	OCR1C = 0;
     43e:	10 92 8d 00 	sts	0x008D, r1
     442:	10 92 8c 00 	sts	0x008C, r1
}
     446:	08 95       	ret

00000448 <timer3PWMInitICR>:
void timer3PWMInitICR(u16 topcount)
{
	// set PWM mode with ICR top-count
	cbi(TCCR3A,WGM10);
     448:	e0 e9       	ldi	r30, 0x90	; 144
     44a:	f0 e0       	ldi	r31, 0x00	; 0
     44c:	20 81       	ld	r18, Z
     44e:	2e 7f       	andi	r18, 0xFE	; 254
     450:	20 83       	st	Z, r18
	sbi(TCCR3A,WGM11);
     452:	20 81       	ld	r18, Z
     454:	22 60       	ori	r18, 0x02	; 2
     456:	20 83       	st	Z, r18
	sbi(TCCR3B,WGM12);
     458:	e1 e9       	ldi	r30, 0x91	; 145
     45a:	f0 e0       	ldi	r31, 0x00	; 0
     45c:	20 81       	ld	r18, Z
     45e:	28 60       	ori	r18, 0x08	; 8
     460:	20 83       	st	Z, r18
	sbi(TCCR3B,WGM13);
     462:	20 81       	ld	r18, Z
     464:	20 61       	ori	r18, 0x10	; 16
     466:	20 83       	st	Z, r18
	
	// set top count value
	ICR3 = topcount;
     468:	90 93 97 00 	sts	0x0097, r25
     46c:	80 93 96 00 	sts	0x0096, r24
	
	// clear output compare values
	OCR3A = 0;
     470:	10 92 99 00 	sts	0x0099, r1
     474:	10 92 98 00 	sts	0x0098, r1
	OCR3B = 0;
     478:	10 92 9b 00 	sts	0x009B, r1
     47c:	10 92 9a 00 	sts	0x009A, r1
	OCR3C = 0;
     480:	10 92 9d 00 	sts	0x009D, r1
     484:	10 92 9c 00 	sts	0x009C, r1
}
     488:	08 95       	ret

0000048a <timer4PWMInitICR>:
void timer4PWMInitICR(u16 topcount)
{
	// set PWM mode with ICR top-count
	cbi(TCCR4A,WGM10);
     48a:	e0 ea       	ldi	r30, 0xA0	; 160
     48c:	f0 e0       	ldi	r31, 0x00	; 0
     48e:	20 81       	ld	r18, Z
     490:	2e 7f       	andi	r18, 0xFE	; 254
     492:	20 83       	st	Z, r18
	sbi(TCCR4A,WGM11);
     494:	20 81       	ld	r18, Z
     496:	22 60       	ori	r18, 0x02	; 2
     498:	20 83       	st	Z, r18
	sbi(TCCR4B,WGM12);
     49a:	e1 ea       	ldi	r30, 0xA1	; 161
     49c:	f0 e0       	ldi	r31, 0x00	; 0
     49e:	20 81       	ld	r18, Z
     4a0:	28 60       	ori	r18, 0x08	; 8
     4a2:	20 83       	st	Z, r18
	sbi(TCCR4B,WGM13);
     4a4:	20 81       	ld	r18, Z
     4a6:	20 61       	ori	r18, 0x10	; 16
     4a8:	20 83       	st	Z, r18
	
	// set top count value
	ICR4 = topcount;
     4aa:	90 93 a7 00 	sts	0x00A7, r25
     4ae:	80 93 a6 00 	sts	0x00A6, r24
	
	// clear output compare values
	OCR4A = 0;
     4b2:	10 92 a9 00 	sts	0x00A9, r1
     4b6:	10 92 a8 00 	sts	0x00A8, r1
	OCR4B = 0;
     4ba:	10 92 ab 00 	sts	0x00AB, r1
     4be:	10 92 aa 00 	sts	0x00AA, r1
	OCR4C = 0;
     4c2:	10 92 ad 00 	sts	0x00AD, r1
     4c6:	10 92 ac 00 	sts	0x00AC, r1
}
     4ca:	08 95       	ret

000004cc <PWM_timer1_On_LED>:
#endif

//on commands
void PWM_timer1_On_LED(void)
{
	sbi(TCCR1A,COM1B1);
     4cc:	e0 e8       	ldi	r30, 0x80	; 128
     4ce:	f0 e0       	ldi	r31, 0x00	; 0
     4d0:	80 81       	ld	r24, Z
     4d2:	80 62       	ori	r24, 0x20	; 32
     4d4:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B0);
     4d6:	80 81       	ld	r24, Z
     4d8:	8f 7e       	andi	r24, 0xEF	; 239
     4da:	80 83       	st	Z, r24
}
     4dc:	08 95       	ret

000004de <PWM_timer2_On_H6>:
void PWM_timer2_On_H6(void)
{
	sbi(TCCR2A,COM2B1);
     4de:	e0 eb       	ldi	r30, 0xB0	; 176
     4e0:	f0 e0       	ldi	r31, 0x00	; 0
     4e2:	80 81       	ld	r24, Z
     4e4:	80 62       	ori	r24, 0x20	; 32
     4e6:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B0);
     4e8:	80 81       	ld	r24, Z
     4ea:	8f 7e       	andi	r24, 0xEF	; 239
     4ec:	80 83       	st	Z, r24
}
     4ee:	08 95       	ret

000004f0 <PWM_timer3_On_E3>:
void PWM_timer3_On_E3(void)
{
	sbi(TCCR3A,COM3A1);
     4f0:	e0 e9       	ldi	r30, 0x90	; 144
     4f2:	f0 e0       	ldi	r31, 0x00	; 0
     4f4:	80 81       	ld	r24, Z
     4f6:	80 68       	ori	r24, 0x80	; 128
     4f8:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3A0);
     4fa:	80 81       	ld	r24, Z
     4fc:	8f 7b       	andi	r24, 0xBF	; 191
     4fe:	80 83       	st	Z, r24
}
     500:	08 95       	ret

00000502 <PWM_timer3_On_E4>:
void PWM_timer3_On_E4(void)
{
	sbi(TCCR3A,COM3B1);
     502:	e0 e9       	ldi	r30, 0x90	; 144
     504:	f0 e0       	ldi	r31, 0x00	; 0
     506:	80 81       	ld	r24, Z
     508:	80 62       	ori	r24, 0x20	; 32
     50a:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3B0);
     50c:	80 81       	ld	r24, Z
     50e:	8f 7e       	andi	r24, 0xEF	; 239
     510:	80 83       	st	Z, r24
}
     512:	08 95       	ret

00000514 <PWM_timer3_On_E5>:
void PWM_timer3_On_E5(void)
{
	sbi(TCCR3A,COM3C1);
     514:	e0 e9       	ldi	r30, 0x90	; 144
     516:	f0 e0       	ldi	r31, 0x00	; 0
     518:	80 81       	ld	r24, Z
     51a:	88 60       	ori	r24, 0x08	; 8
     51c:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C0);
     51e:	80 81       	ld	r24, Z
     520:	8b 7f       	andi	r24, 0xFB	; 251
     522:	80 83       	st	Z, r24
}
     524:	08 95       	ret

00000526 <PWM_timer4_On_H3>:
void PWM_timer4_On_H3(void)
{
	sbi(TCCR4A,COM4A1);
     526:	e0 ea       	ldi	r30, 0xA0	; 160
     528:	f0 e0       	ldi	r31, 0x00	; 0
     52a:	80 81       	ld	r24, Z
     52c:	80 68       	ori	r24, 0x80	; 128
     52e:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4A0);
     530:	80 81       	ld	r24, Z
     532:	8f 7b       	andi	r24, 0xBF	; 191
     534:	80 83       	st	Z, r24
}
     536:	08 95       	ret

00000538 <PWM_timer4_On_H4>:
void PWM_timer4_On_H4(void)
{
	sbi(TCCR4A,COM4B1);
     538:	e0 ea       	ldi	r30, 0xA0	; 160
     53a:	f0 e0       	ldi	r31, 0x00	; 0
     53c:	80 81       	ld	r24, Z
     53e:	80 62       	ori	r24, 0x20	; 32
     540:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4B0);
     542:	80 81       	ld	r24, Z
     544:	8f 7e       	andi	r24, 0xEF	; 239
     546:	80 83       	st	Z, r24
}
     548:	08 95       	ret

0000054a <PWM_timer4_On_H5>:
void PWM_timer4_On_H5(void)
{
	sbi(TCCR4A,COM4C1);
     54a:	e0 ea       	ldi	r30, 0xA0	; 160
     54c:	f0 e0       	ldi	r31, 0x00	; 0
     54e:	80 81       	ld	r24, Z
     550:	88 60       	ori	r24, 0x08	; 8
     552:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4C0);
     554:	80 81       	ld	r24, Z
     556:	8b 7f       	andi	r24, 0xFB	; 251
     558:	80 83       	st	Z, r24
}
     55a:	08 95       	ret

0000055c <PWM_timer1_Off_LED>:

//off commands
void PWM_timer1_Off_LED(void)
{
	cbi(TCCR1A,COM1B1);
     55c:	e0 e8       	ldi	r30, 0x80	; 128
     55e:	f0 e0       	ldi	r31, 0x00	; 0
     560:	80 81       	ld	r24, Z
     562:	8f 7d       	andi	r24, 0xDF	; 223
     564:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B0);
     566:	80 81       	ld	r24, Z
     568:	8f 7e       	andi	r24, 0xEF	; 239
     56a:	80 83       	st	Z, r24
}
     56c:	08 95       	ret

0000056e <PWM_timer2_Off_H6>:
void PWM_timer2_Off_H6(void)
{
	cbi(TCCR2A,COM2B1);
     56e:	e0 eb       	ldi	r30, 0xB0	; 176
     570:	f0 e0       	ldi	r31, 0x00	; 0
     572:	80 81       	ld	r24, Z
     574:	8f 7d       	andi	r24, 0xDF	; 223
     576:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B0);
     578:	80 81       	ld	r24, Z
     57a:	8f 7e       	andi	r24, 0xEF	; 239
     57c:	80 83       	st	Z, r24
}
     57e:	08 95       	ret

00000580 <PWM_timer3_Off_E3>:
void PWM_timer3_Off_E3(void)
{
	cbi(TCCR3A,COM3A1);
     580:	e0 e9       	ldi	r30, 0x90	; 144
     582:	f0 e0       	ldi	r31, 0x00	; 0
     584:	80 81       	ld	r24, Z
     586:	8f 77       	andi	r24, 0x7F	; 127
     588:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3A0);
     58a:	80 81       	ld	r24, Z
     58c:	8f 7b       	andi	r24, 0xBF	; 191
     58e:	80 83       	st	Z, r24
}
     590:	08 95       	ret

00000592 <PWM_timer3_Off_E4>:
void PWM_timer3_Off_E4(void)
{
	cbi(TCCR3A,COM3B1);
     592:	e0 e9       	ldi	r30, 0x90	; 144
     594:	f0 e0       	ldi	r31, 0x00	; 0
     596:	80 81       	ld	r24, Z
     598:	8f 7d       	andi	r24, 0xDF	; 223
     59a:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3B0);
     59c:	80 81       	ld	r24, Z
     59e:	8f 7e       	andi	r24, 0xEF	; 239
     5a0:	80 83       	st	Z, r24
}
     5a2:	08 95       	ret

000005a4 <PWM_timer3_Off_E5>:
void PWM_timer3_Off_E5(void)
{
	cbi(TCCR3A,COM3C1);
     5a4:	e0 e9       	ldi	r30, 0x90	; 144
     5a6:	f0 e0       	ldi	r31, 0x00	; 0
     5a8:	80 81       	ld	r24, Z
     5aa:	87 7f       	andi	r24, 0xF7	; 247
     5ac:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C0);
     5ae:	80 81       	ld	r24, Z
     5b0:	8b 7f       	andi	r24, 0xFB	; 251
     5b2:	80 83       	st	Z, r24
}
     5b4:	08 95       	ret

000005b6 <PWM_timer4_Off_H3>:
void PWM_timer4_Off_H3(void)
{
	cbi(TCCR4A,COM4A1);
     5b6:	e0 ea       	ldi	r30, 0xA0	; 160
     5b8:	f0 e0       	ldi	r31, 0x00	; 0
     5ba:	80 81       	ld	r24, Z
     5bc:	8f 77       	andi	r24, 0x7F	; 127
     5be:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4A0);
     5c0:	80 81       	ld	r24, Z
     5c2:	8f 7b       	andi	r24, 0xBF	; 191
     5c4:	80 83       	st	Z, r24
}
     5c6:	08 95       	ret

000005c8 <PWM_timer4_Off_H4>:
void PWM_timer4_Off_H4(void)
{
	cbi(TCCR4A,COM4B1);
     5c8:	e0 ea       	ldi	r30, 0xA0	; 160
     5ca:	f0 e0       	ldi	r31, 0x00	; 0
     5cc:	80 81       	ld	r24, Z
     5ce:	8f 7d       	andi	r24, 0xDF	; 223
     5d0:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4B0);
     5d2:	80 81       	ld	r24, Z
     5d4:	8f 7e       	andi	r24, 0xEF	; 239
     5d6:	80 83       	st	Z, r24
}
     5d8:	08 95       	ret

000005da <PWM_timer4_Off_H5>:
void PWM_timer4_Off_H5(void)
{
	cbi(TCCR4A,COM4C1);
     5da:	e0 ea       	ldi	r30, 0xA0	; 160
     5dc:	f0 e0       	ldi	r31, 0x00	; 0
     5de:	80 81       	ld	r24, Z
     5e0:	87 7f       	andi	r24, 0xF7	; 247
     5e2:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4C0);
     5e4:	80 81       	ld	r24, Z
     5e6:	8b 7f       	andi	r24, 0xFB	; 251
     5e8:	80 83       	st	Z, r24
}
     5ea:	08 95       	ret

000005ec <PWM_timer1_Off_All>:


void PWM_timer1_Off_All(void)
{
	cbi(TCCR1A,PWM11);
     5ec:	e0 e8       	ldi	r30, 0x80	; 128
     5ee:	f0 e0       	ldi	r31, 0x00	; 0
     5f0:	80 81       	ld	r24, Z
     5f2:	8d 7f       	andi	r24, 0xFD	; 253
     5f4:	80 83       	st	Z, r24
	cbi(TCCR1A,PWM10);
     5f6:	80 81       	ld	r24, Z
     5f8:	8e 7f       	andi	r24, 0xFE	; 254
     5fa:	80 83       	st	Z, r24
}

//off commands
void PWM_timer1_Off_LED(void)
{
	cbi(TCCR1A,COM1B1);
     5fc:	80 81       	ld	r24, Z
     5fe:	8f 7d       	andi	r24, 0xDF	; 223
     600:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B0);
     602:	80 81       	ld	r24, Z
     604:	8f 7e       	andi	r24, 0xEF	; 239
     606:	80 83       	st	Z, r24
	cbi(TCCR1A,PWM11);
	cbi(TCCR1A,PWM10);
	//timer2PWMAOff();
	PWM_timer1_Off_LED();
	//timer2PWMCOff();
}
     608:	08 95       	ret

0000060a <PWM_timer2_Off_All>:
void PWM_timer2_Off_All(void)
{
	cbi(TCCR2A,PWM11);
     60a:	e0 eb       	ldi	r30, 0xB0	; 176
     60c:	f0 e0       	ldi	r31, 0x00	; 0
     60e:	80 81       	ld	r24, Z
     610:	8d 7f       	andi	r24, 0xFD	; 253
     612:	80 83       	st	Z, r24
	cbi(TCCR2A,PWM10);
     614:	80 81       	ld	r24, Z
     616:	8e 7f       	andi	r24, 0xFE	; 254
     618:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B1);
	cbi(TCCR1A,COM1B0);
}
void PWM_timer2_Off_H6(void)
{
	cbi(TCCR2A,COM2B1);
     61a:	80 81       	ld	r24, Z
     61c:	8f 7d       	andi	r24, 0xDF	; 223
     61e:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B0);
     620:	80 81       	ld	r24, Z
     622:	8f 7e       	andi	r24, 0xEF	; 239
     624:	80 83       	st	Z, r24
	cbi(TCCR2A,PWM11);
	cbi(TCCR2A,PWM10);
	//timer2PWMAOff();
	PWM_timer2_Off_H6();
	//timer2PWMCOff();
}
     626:	08 95       	ret

00000628 <PWM_timer3_Off_All>:
void PWM_timer3_Off_All(void)
{
	cbi(TCCR3A,PWM11);
     628:	e0 e9       	ldi	r30, 0x90	; 144
     62a:	f0 e0       	ldi	r31, 0x00	; 0
     62c:	80 81       	ld	r24, Z
     62e:	8d 7f       	andi	r24, 0xFD	; 253
     630:	80 83       	st	Z, r24
	cbi(TCCR3A,PWM10);
     632:	80 81       	ld	r24, Z
     634:	8e 7f       	andi	r24, 0xFE	; 254
     636:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B1);
	cbi(TCCR2A,COM2B0);
}
void PWM_timer3_Off_E3(void)
{
	cbi(TCCR3A,COM3A1);
     638:	80 81       	ld	r24, Z
     63a:	8f 77       	andi	r24, 0x7F	; 127
     63c:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3A0);
     63e:	80 81       	ld	r24, Z
     640:	8f 7b       	andi	r24, 0xBF	; 191
     642:	80 83       	st	Z, r24
}
void PWM_timer3_Off_E4(void)
{
	cbi(TCCR3A,COM3B1);
     644:	80 81       	ld	r24, Z
     646:	8f 7d       	andi	r24, 0xDF	; 223
     648:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3B0);
     64a:	80 81       	ld	r24, Z
     64c:	8f 7e       	andi	r24, 0xEF	; 239
     64e:	80 83       	st	Z, r24
}
void PWM_timer3_Off_E5(void)
{
	cbi(TCCR3A,COM3C1);
     650:	80 81       	ld	r24, Z
     652:	87 7f       	andi	r24, 0xF7	; 247
     654:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C0);
     656:	80 81       	ld	r24, Z
     658:	8b 7f       	andi	r24, 0xFB	; 251
     65a:	80 83       	st	Z, r24
	//timer2PWMAOff();
	PWM_timer3_Off_E3();
	PWM_timer3_Off_E4();
	PWM_timer3_Off_E5();
	//timer2PWMCOff();
}
     65c:	08 95       	ret

0000065e <PWM_timer4_Off_All>:
void PWM_timer4_Off_All(void)
{
	cbi(TCCR4A,PWM11);
     65e:	e0 ea       	ldi	r30, 0xA0	; 160
     660:	f0 e0       	ldi	r31, 0x00	; 0
     662:	80 81       	ld	r24, Z
     664:	8d 7f       	andi	r24, 0xFD	; 253
     666:	80 83       	st	Z, r24
	cbi(TCCR4A,PWM10);
     668:	80 81       	ld	r24, Z
     66a:	8e 7f       	andi	r24, 0xFE	; 254
     66c:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C1);
	cbi(TCCR3A,COM3C0);
}
void PWM_timer4_Off_H3(void)
{
	cbi(TCCR4A,COM4A1);
     66e:	80 81       	ld	r24, Z
     670:	8f 77       	andi	r24, 0x7F	; 127
     672:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4A0);
     674:	80 81       	ld	r24, Z
     676:	8f 7b       	andi	r24, 0xBF	; 191
     678:	80 83       	st	Z, r24
}
void PWM_timer4_Off_H4(void)
{
	cbi(TCCR4A,COM4B1);
     67a:	80 81       	ld	r24, Z
     67c:	8f 7d       	andi	r24, 0xDF	; 223
     67e:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4B0);
     680:	80 81       	ld	r24, Z
     682:	8f 7e       	andi	r24, 0xEF	; 239
     684:	80 83       	st	Z, r24
}
void PWM_timer4_Off_H5(void)
{
	cbi(TCCR4A,COM4C1);
     686:	80 81       	ld	r24, Z
     688:	87 7f       	andi	r24, 0xF7	; 247
     68a:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4C0);
     68c:	80 81       	ld	r24, Z
     68e:	8b 7f       	andi	r24, 0xFB	; 251
     690:	80 83       	st	Z, r24
	//timer2PWMAOff();
	PWM_timer4_Off_H3();
	PWM_timer4_Off_H4();
	PWM_timer4_Off_H5();
	//timer2PWMCOff();
}
     692:	08 95       	ret

00000694 <PWM_timer1_Set_LED>:
// this PWM output is generated on OC2B pin
// NOTE:	pwmDuty should be in the range 0-255 for 8bit PWM
//			pwmDuty should be in the range 0-511 for 9bit PWM
//			pwmDuty should be in the range 0-1023 for 10bit PWM
void PWM_timer1_Set_LED(u16 pwmDuty)
	{OCR1B = pwmDuty;}
     694:	90 93 8b 00 	sts	0x008B, r25
     698:	80 93 8a 00 	sts	0x008A, r24
     69c:	08 95       	ret

0000069e <PWM_timer2_Set_H6>:
void PWM_timer2_Set_H6(u16 pwmDuty)
	{OCR2B = pwmDuty;}
     69e:	80 93 b4 00 	sts	0x00B4, r24
     6a2:	08 95       	ret

000006a4 <PWM_timer3_Set_E3>:
void PWM_timer3_Set_E3(u16 pwmDuty)
	{OCR3A = pwmDuty;}
     6a4:	90 93 99 00 	sts	0x0099, r25
     6a8:	80 93 98 00 	sts	0x0098, r24
     6ac:	08 95       	ret

000006ae <PWM_timer3_Set_E4>:
void PWM_timer3_Set_E4(u16 pwmDuty)
	{OCR3B = pwmDuty;}
     6ae:	90 93 9b 00 	sts	0x009B, r25
     6b2:	80 93 9a 00 	sts	0x009A, r24
     6b6:	08 95       	ret

000006b8 <PWM_timer3_Set_E5>:
void PWM_timer3_Set_E5(u16 pwmDuty)
	{OCR3C = pwmDuty;}
     6b8:	90 93 9d 00 	sts	0x009D, r25
     6bc:	80 93 9c 00 	sts	0x009C, r24
     6c0:	08 95       	ret

000006c2 <PWM_timer4_Set_H3>:
void PWM_timer4_Set_H3(u16 pwmDuty)
	{OCR4A = pwmDuty;}
     6c2:	90 93 a9 00 	sts	0x00A9, r25
     6c6:	80 93 a8 00 	sts	0x00A8, r24
     6ca:	08 95       	ret

000006cc <PWM_timer4_Set_H4>:
void PWM_timer4_Set_H4(u16 pwmDuty)
	{OCR4B = pwmDuty;}
     6cc:	90 93 ab 00 	sts	0x00AB, r25
     6d0:	80 93 aa 00 	sts	0x00AA, r24
     6d4:	08 95       	ret

000006d6 <PWM_timer4_Set_H5>:
void PWM_timer4_Set_H5(u16 pwmDuty)
	{OCR4C = pwmDuty;}
     6d6:	90 93 ad 00 	sts	0x00AD, r25
     6da:	80 93 ac 00 	sts	0x00AC, r24
     6de:	08 95       	ret

000006e0 <configure_ports>:
	//cbi(DDRG, PG5);  //set G5 as input pin

	//ANALOG PORTS
	//useful for sensors, SharpIR, photoresistors, etc.
	//analog ports can be configured as digital ports if desired
	DDRF = 0b00000000;  //configure all F ports for input				0x00
     6e0:	10 ba       	out	0x10, r1	; 16
	PORTF = 0b00000000; //make sure pull-up resistors are turned off	0x00
     6e2:	11 ba       	out	0x11, r1	; 17
	DDRK = 0b00000000;  //configure all K ports for input				0x00
     6e4:	10 92 07 01 	sts	0x0107, r1
	PORTK = 0b00000000; //make sure pull-up resistors are turned off	0x00
     6e8:	10 92 08 01 	sts	0x0108, r1

	//DIGITAL PORTS
	//useful for servos, PWM, LED's, UART, interrupts, timers
	DDRA = 0b11111111;  //configure ports for output
     6ec:	9f ef       	ldi	r25, 0xFF	; 255
     6ee:	91 b9       	out	0x01, r25	; 1
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	//PORTB reserved for programmer (use programmer pins if you know what you are doing)
	DDRB = _BV (PB6);	//PB6 is LED, hold low to turn it on
     6f0:	80 e4       	ldi	r24, 0x40	; 64
     6f2:	84 b9       	out	0x04, r24	; 4
	DDRC = 0b11111111;  //configure ports for output
     6f4:	97 b9       	out	0x07, r25	; 7
	//       ||||\______3: 
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 	
	sbi(PORTD, PD0); // SCL pull-up
     6f6:	58 9a       	sbi	0x0b, 0	; 11
	sbi(PORTD, PD1); // SDA pull-up
     6f8:	59 9a       	sbi	0x0b, 1	; 11
	DDRD = 0b11110011;  //configure ports for output
     6fa:	83 ef       	ldi	r24, 0xF3	; 243
     6fc:	8a b9       	out	0x0a, r24	; 10
	//       ||||\______3: serial TXD1, output -> 1
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: timer0
	DDRE = 0b11111110;  //configure ports for output
     6fe:	8e ef       	ldi	r24, 0xFE	; 254
     700:	8d b9       	out	0x0d, r24	; 13
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	//cbi(PORTG, PG5);  // disable pull-up resistor for Axon v1e and earlier
	sbi(PORTG, PG5);  // enable pull-up resistor for v1f and later
     702:	a5 9a       	sbi	0x14, 5	; 20
	cbi(DDRG, PG5);	//PG5 is for the button, make a digital input
     704:	9d 98       	cbi	0x13, 5	; 19
	//note that button actions are inverted between both versions!!!
	DDRH = 0b11111110;  //configure ports for output
     706:	80 93 01 01 	sts	0x0101, r24
	//       ||||\______3: 
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	DDRJ = 0b11111110;  //configure ports for output
     70a:	80 93 04 01 	sts	0x0104, r24
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	//PORTL has no headers
	};
     70e:	08 95       	ret

00000710 <delay_cycles>:
void delay_cycles(unsigned long int cycles)
	{
	cycles=cycles;//doubled frequency but too lazy to change times
	while(cycles > 0)
		cycles--;
	}
     710:	08 95       	ret

00000712 <LED_off>:


//***************STATUS LED**************
//tank test
void LED_off(void)
	{PORT_ON(PORTB,6);}
     712:	2e 9a       	sbi	0x05, 6	; 5
     714:	08 95       	ret

00000716 <LED_on>:
void LED_on(void)
	{PORT_OFF(PORTB,6);}
     716:	2e 98       	cbi	0x05, 6	; 5
     718:	08 95       	ret

0000071a <button_pressed>:


//*****************BUTTON****************
int button_pressed(void)
	{
	return (bit_is_clear(PING, 5));
     71a:	22 b3       	in	r18, 0x12	; 18
     71c:	30 e0       	ldi	r19, 0x00	; 0
     71e:	85 e0       	ldi	r24, 0x05	; 5
     720:	36 95       	lsr	r19
     722:	27 95       	ror	r18
     724:	8a 95       	dec	r24
     726:	e1 f7       	brne	.-8      	; 0x720 <button_pressed+0x6>
     728:	20 95       	com	r18
     72a:	30 95       	com	r19
     72c:	21 70       	andi	r18, 0x01	; 1
     72e:	30 70       	andi	r19, 0x00	; 0
	//return ((PING) & (1<<PG5));//old version, went high when button pushed
	}
     730:	c9 01       	movw	r24, r18
     732:	08 95       	ret

00000734 <cos_SoR>:
signed int angtable[73]={100,100,98,97,94,91,87,82,77,71,64,57,50,42,34,26,17,9,0,-9,-17,-26,-34,-42,-50,-57,-64,-71,-77,-82,-87,-91,-94,-97,-98,-100,
						 -100,-100,-98,-97,-94,-91,-87,-82,-77,-71,-64,-57,-50,-42,-34,-26,-17,-9,0,9,17,26,34,42,50,57,64,71,77,82,87,91,94,97,98,100,100};

signed int cos_SoR(long signed int degrees)//returns cos*100
	{
	if (degrees >= 0)//positive angles
     734:	97 fd       	sbrc	r25, 7
     736:	10 c0       	rjmp	.+32     	; 0x758 <cos_SoR+0x24>
		return angtable[degrees/5];
     738:	25 e0       	ldi	r18, 0x05	; 5
     73a:	30 e0       	ldi	r19, 0x00	; 0
     73c:	40 e0       	ldi	r20, 0x00	; 0
     73e:	50 e0       	ldi	r21, 0x00	; 0
     740:	0e 94 64 2e 	call	0x5cc8	; 0x5cc8 <__divmodsi4>
     744:	da 01       	movw	r26, r20
     746:	c9 01       	movw	r24, r18
     748:	88 0f       	add	r24, r24
     74a:	99 1f       	adc	r25, r25
     74c:	8b 5d       	subi	r24, 0xDB	; 219
     74e:	9d 4f       	sbci	r25, 0xFD	; 253
     750:	fc 01       	movw	r30, r24
     752:	20 81       	ld	r18, Z
     754:	31 81       	ldd	r19, Z+1	; 0x01
     756:	17 c0       	rjmp	.+46     	; 0x786 <cos_SoR+0x52>
	else
		return -angtable[72-(-degrees)/5];
     758:	25 e0       	ldi	r18, 0x05	; 5
     75a:	30 e0       	ldi	r19, 0x00	; 0
     75c:	40 e0       	ldi	r20, 0x00	; 0
     75e:	50 e0       	ldi	r21, 0x00	; 0
     760:	0e 94 64 2e 	call	0x5cc8	; 0x5cc8 <__divmodsi4>
     764:	da 01       	movw	r26, r20
     766:	c9 01       	movw	r24, r18
     768:	88 5b       	subi	r24, 0xB8	; 184
     76a:	9f 4f       	sbci	r25, 0xFF	; 255
     76c:	af 4f       	sbci	r26, 0xFF	; 255
     76e:	bf 4f       	sbci	r27, 0xFF	; 255
     770:	88 0f       	add	r24, r24
     772:	99 1f       	adc	r25, r25
     774:	8b 5d       	subi	r24, 0xDB	; 219
     776:	9d 4f       	sbci	r25, 0xFD	; 253
     778:	fc 01       	movw	r30, r24
     77a:	80 81       	ld	r24, Z
     77c:	91 81       	ldd	r25, Z+1	; 0x01
     77e:	22 27       	eor	r18, r18
     780:	33 27       	eor	r19, r19
     782:	28 1b       	sub	r18, r24
     784:	39 0b       	sbc	r19, r25
	}
     786:	c9 01       	movw	r24, r18
     788:	08 95       	ret

0000078a <sin_SoR>:

signed int sin_SoR(long signed int degrees)//returns sin*100
	{
	degrees=degrees - 90;//phase shift 90 degrees
     78a:	6a 55       	subi	r22, 0x5A	; 90
     78c:	70 40       	sbci	r23, 0x00	; 0
     78e:	80 40       	sbci	r24, 0x00	; 0
     790:	90 40       	sbci	r25, 0x00	; 0

	if (degrees >= 0)//positive angles
     792:	97 fd       	sbrc	r25, 7
     794:	10 c0       	rjmp	.+32     	; 0x7b6 <sin_SoR+0x2c>
		return angtable[degrees/5];
     796:	25 e0       	ldi	r18, 0x05	; 5
     798:	30 e0       	ldi	r19, 0x00	; 0
     79a:	40 e0       	ldi	r20, 0x00	; 0
     79c:	50 e0       	ldi	r21, 0x00	; 0
     79e:	0e 94 64 2e 	call	0x5cc8	; 0x5cc8 <__divmodsi4>
     7a2:	da 01       	movw	r26, r20
     7a4:	c9 01       	movw	r24, r18
     7a6:	88 0f       	add	r24, r24
     7a8:	99 1f       	adc	r25, r25
     7aa:	8b 5d       	subi	r24, 0xDB	; 219
     7ac:	9d 4f       	sbci	r25, 0xFD	; 253
     7ae:	fc 01       	movw	r30, r24
     7b0:	20 81       	ld	r18, Z
     7b2:	31 81       	ldd	r19, Z+1	; 0x01
     7b4:	17 c0       	rjmp	.+46     	; 0x7e4 <sin_SoR+0x5a>
	else
		return -angtable[72-(-degrees)/5];
     7b6:	25 e0       	ldi	r18, 0x05	; 5
     7b8:	30 e0       	ldi	r19, 0x00	; 0
     7ba:	40 e0       	ldi	r20, 0x00	; 0
     7bc:	50 e0       	ldi	r21, 0x00	; 0
     7be:	0e 94 64 2e 	call	0x5cc8	; 0x5cc8 <__divmodsi4>
     7c2:	da 01       	movw	r26, r20
     7c4:	c9 01       	movw	r24, r18
     7c6:	88 5b       	subi	r24, 0xB8	; 184
     7c8:	9f 4f       	sbci	r25, 0xFF	; 255
     7ca:	af 4f       	sbci	r26, 0xFF	; 255
     7cc:	bf 4f       	sbci	r27, 0xFF	; 255
     7ce:	88 0f       	add	r24, r24
     7d0:	99 1f       	adc	r25, r25
     7d2:	8b 5d       	subi	r24, 0xDB	; 219
     7d4:	9d 4f       	sbci	r25, 0xFD	; 253
     7d6:	fc 01       	movw	r30, r24
     7d8:	80 81       	ld	r24, Z
     7da:	91 81       	ldd	r25, Z+1	; 0x01
     7dc:	22 27       	eor	r18, r18
     7de:	33 27       	eor	r19, r19
     7e0:	28 1b       	sub	r18, r24
     7e2:	39 0b       	sbc	r19, r25
	}
     7e4:	c9 01       	movw	r24, r18
     7e6:	08 95       	ret

000007e8 <tan_SoR>:

signed int tan_SoR(long signed int degrees)//returns tan * 10
	{
     7e8:	cf 92       	push	r12
     7ea:	df 92       	push	r13
     7ec:	ef 92       	push	r14
     7ee:	ff 92       	push	r15
     7f0:	0f 93       	push	r16
     7f2:	1f 93       	push	r17
     7f4:	6b 01       	movw	r12, r22
     7f6:	7c 01       	movw	r14, r24
	//tan(x) = sin(x)/cos(x)
	if (degrees == 90 || degrees == -90 || degrees == 270 || degrees == -270)//blows up
     7f8:	8a e5       	ldi	r24, 0x5A	; 90
     7fa:	c8 16       	cp	r12, r24
     7fc:	d1 04       	cpc	r13, r1
     7fe:	e1 04       	cpc	r14, r1
     800:	f1 04       	cpc	r15, r1
     802:	a1 f1       	breq	.+104    	; 0x86c <tan_SoR+0x84>
     804:	86 ea       	ldi	r24, 0xA6	; 166
     806:	c8 16       	cp	r12, r24
     808:	8f ef       	ldi	r24, 0xFF	; 255
     80a:	d8 06       	cpc	r13, r24
     80c:	8f ef       	ldi	r24, 0xFF	; 255
     80e:	e8 06       	cpc	r14, r24
     810:	8f ef       	ldi	r24, 0xFF	; 255
     812:	f8 06       	cpc	r15, r24
     814:	59 f1       	breq	.+86     	; 0x86c <tan_SoR+0x84>
     816:	8e e0       	ldi	r24, 0x0E	; 14
     818:	c8 16       	cp	r12, r24
     81a:	81 e0       	ldi	r24, 0x01	; 1
     81c:	d8 06       	cpc	r13, r24
     81e:	80 e0       	ldi	r24, 0x00	; 0
     820:	e8 06       	cpc	r14, r24
     822:	80 e0       	ldi	r24, 0x00	; 0
     824:	f8 06       	cpc	r15, r24
     826:	11 f1       	breq	.+68     	; 0x86c <tan_SoR+0x84>
     828:	82 ef       	ldi	r24, 0xF2	; 242
     82a:	c8 16       	cp	r12, r24
     82c:	8e ef       	ldi	r24, 0xFE	; 254
     82e:	d8 06       	cpc	r13, r24
     830:	8f ef       	ldi	r24, 0xFF	; 255
     832:	e8 06       	cpc	r14, r24
     834:	8f ef       	ldi	r24, 0xFF	; 255
     836:	f8 06       	cpc	r15, r24
     838:	c9 f0       	breq	.+50     	; 0x86c <tan_SoR+0x84>
		return 0;//what else should I return?!?!?
	return sin_SoR(degrees)/cos_SoR(degrees)*10;
     83a:	c7 01       	movw	r24, r14
     83c:	b6 01       	movw	r22, r12
     83e:	0e 94 c5 03 	call	0x78a	; 0x78a <sin_SoR>
     842:	8c 01       	movw	r16, r24
     844:	c7 01       	movw	r24, r14
     846:	b6 01       	movw	r22, r12
     848:	0e 94 9a 03 	call	0x734	; 0x734 <cos_SoR>
     84c:	bc 01       	movw	r22, r24
     84e:	c8 01       	movw	r24, r16
     850:	0e 94 2f 2e 	call	0x5c5e	; 0x5c5e <__divmodhi4>
     854:	cb 01       	movw	r24, r22
     856:	9b 01       	movw	r18, r22
     858:	73 e0       	ldi	r23, 0x03	; 3
     85a:	22 0f       	add	r18, r18
     85c:	33 1f       	adc	r19, r19
     85e:	7a 95       	dec	r23
     860:	e1 f7       	brne	.-8      	; 0x85a <tan_SoR+0x72>
     862:	88 0f       	add	r24, r24
     864:	99 1f       	adc	r25, r25
     866:	28 0f       	add	r18, r24
     868:	39 1f       	adc	r19, r25
     86a:	02 c0       	rjmp	.+4      	; 0x870 <tan_SoR+0x88>
     86c:	20 e0       	ldi	r18, 0x00	; 0
     86e:	30 e0       	ldi	r19, 0x00	; 0
	}
     870:	c9 01       	movw	r24, r18
     872:	1f 91       	pop	r17
     874:	0f 91       	pop	r16
     876:	ff 90       	pop	r15
     878:	ef 90       	pop	r14
     87a:	df 90       	pop	r13
     87c:	cf 90       	pop	r12
     87e:	08 95       	ret

00000880 <prvPWMSetup>:
//-----------------------------**&&**


void prvPWMSetup(){

	PWM_Init_timer3_E4(10); // Left wheel
     880:	8a e0       	ldi	r24, 0x0A	; 10
     882:	0e 94 63 01 	call	0x2c6	; 0x2c6 <PWM_Init_timer3_E4>
	PWM_Init_timer3_E3(10); // Right wheel
     886:	8a e0       	ldi	r24, 0x0A	; 10
     888:	0e 94 43 01 	call	0x286	; 0x286 <PWM_Init_timer3_E3>
	PWM_Init_timer4_H3(10);	// Left sprayer
     88c:	8a e0       	ldi	r24, 0x0A	; 10
     88e:	0e 94 a3 01 	call	0x346	; 0x346 <PWM_Init_timer4_H3>
	PWM_Init_timer4_H4(10);	// Right sprayer
     892:	8a e0       	ldi	r24, 0x0A	; 10
     894:	0e 94 c3 01 	call	0x386	; 0x386 <PWM_Init_timer4_H4>

}
     898:	08 95       	ret

0000089a <char2hex>:

char char2hex(char c){
     89a:	98 2f       	mov	r25, r24
	
	if((c > 47) && (c <58)){
     89c:	80 53       	subi	r24, 0x30	; 48
     89e:	8a 30       	cpi	r24, 0x0A	; 10
     8a0:	38 f0       	brcs	.+14     	; 0x8b0 <char2hex+0x16>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     8a2:	81 51       	subi	r24, 0x11	; 17
     8a4:	86 30       	cpi	r24, 0x06	; 6
     8a6:	10 f0       	brcs	.+4      	; 0x8ac <char2hex+0x12>
     8a8:	89 2f       	mov	r24, r25
     8aa:	08 95       	ret
		c -= 55;
     8ac:	89 2f       	mov	r24, r25
     8ae:	87 53       	subi	r24, 0x37	; 55
	}
	return c;
}
     8b0:	08 95       	ret

000008b2 <retConv_s16>:

s16 retConv_s16(char* ch_head){
     8b2:	fc 01       	movw	r30, r24

	s16 int_val = 0x0000;
	char iv1 = *(ch_head);
     8b4:	90 81       	ld	r25, Z
	char iv2 = *(ch_head + 1);
     8b6:	21 81       	ldd	r18, Z+1	; 0x01
	char iv3 = *(ch_head + 2);
     8b8:	42 81       	ldd	r20, Z+2	; 0x02
	char iv4 = *(ch_head + 3);
     8ba:	53 81       	ldd	r21, Z+3	; 0x03

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     8bc:	89 2f       	mov	r24, r25
     8be:	80 53       	subi	r24, 0x30	; 48
     8c0:	8a 30       	cpi	r24, 0x0A	; 10
     8c2:	10 f4       	brcc	.+4      	; 0x8c8 <retConv_s16+0x16>
     8c4:	98 2f       	mov	r25, r24
     8c6:	05 c0       	rjmp	.+10     	; 0x8d2 <retConv_s16+0x20>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     8c8:	89 2f       	mov	r24, r25
     8ca:	81 54       	subi	r24, 0x41	; 65
     8cc:	86 30       	cpi	r24, 0x06	; 6
     8ce:	08 f4       	brcc	.+2      	; 0x8d2 <retConv_s16+0x20>
		c -= 55;
     8d0:	97 53       	subi	r25, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     8d2:	82 2f       	mov	r24, r18
     8d4:	80 53       	subi	r24, 0x30	; 48
     8d6:	8a 30       	cpi	r24, 0x0A	; 10
     8d8:	10 f4       	brcc	.+4      	; 0x8de <retConv_s16+0x2c>
     8da:	28 2f       	mov	r18, r24
     8dc:	05 c0       	rjmp	.+10     	; 0x8e8 <retConv_s16+0x36>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     8de:	82 2f       	mov	r24, r18
     8e0:	81 54       	subi	r24, 0x41	; 65
     8e2:	86 30       	cpi	r24, 0x06	; 6
     8e4:	08 f4       	brcc	.+2      	; 0x8e8 <retConv_s16+0x36>
		c -= 55;
     8e6:	27 53       	subi	r18, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     8e8:	84 2f       	mov	r24, r20
     8ea:	80 53       	subi	r24, 0x30	; 48
     8ec:	8a 30       	cpi	r24, 0x0A	; 10
     8ee:	10 f4       	brcc	.+4      	; 0x8f4 <retConv_s16+0x42>
     8f0:	48 2f       	mov	r20, r24
     8f2:	05 c0       	rjmp	.+10     	; 0x8fe <retConv_s16+0x4c>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     8f4:	84 2f       	mov	r24, r20
     8f6:	81 54       	subi	r24, 0x41	; 65
     8f8:	86 30       	cpi	r24, 0x06	; 6
     8fa:	08 f4       	brcc	.+2      	; 0x8fe <retConv_s16+0x4c>
		c -= 55;
     8fc:	47 53       	subi	r20, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     8fe:	85 2f       	mov	r24, r21
     900:	80 53       	subi	r24, 0x30	; 48
     902:	8a 30       	cpi	r24, 0x0A	; 10
     904:	10 f4       	brcc	.+4      	; 0x90a <retConv_s16+0x58>
     906:	58 2f       	mov	r21, r24
     908:	05 c0       	rjmp	.+10     	; 0x914 <retConv_s16+0x62>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     90a:	85 2f       	mov	r24, r21
     90c:	81 54       	subi	r24, 0x41	; 65
     90e:	86 30       	cpi	r24, 0x06	; 6
     910:	08 f4       	brcc	.+2      	; 0x914 <retConv_s16+0x62>
		c -= 55;
     912:	57 53       	subi	r21, 0x37	; 55
	iv2 = char2hex(iv2);
	iv3 = char2hex(iv3);
	iv4 = char2hex(iv4);

	int_val = (int_val | iv1);
	int_val = ((int_val<<4) | iv2);
     914:	30 e0       	ldi	r19, 0x00	; 0
     916:	89 2f       	mov	r24, r25
     918:	90 e0       	ldi	r25, 0x00	; 0
     91a:	a4 e0       	ldi	r26, 0x04	; 4
     91c:	88 0f       	add	r24, r24
     91e:	99 1f       	adc	r25, r25
     920:	aa 95       	dec	r26
     922:	e1 f7       	brne	.-8      	; 0x91c <retConv_s16+0x6a>
     924:	28 2b       	or	r18, r24
     926:	39 2b       	or	r19, r25
	int_val = ((int_val<<4) | iv3);
     928:	f4 e0       	ldi	r31, 0x04	; 4
     92a:	22 0f       	add	r18, r18
     92c:	33 1f       	adc	r19, r19
     92e:	fa 95       	dec	r31
     930:	e1 f7       	brne	.-8      	; 0x92a <retConv_s16+0x78>
     932:	84 2f       	mov	r24, r20
     934:	90 e0       	ldi	r25, 0x00	; 0
     936:	82 2b       	or	r24, r18
     938:	93 2b       	or	r25, r19
	int_val = ((int_val<<4) | iv4);
     93a:	e4 e0       	ldi	r30, 0x04	; 4
     93c:	88 0f       	add	r24, r24
     93e:	99 1f       	adc	r25, r25
     940:	ea 95       	dec	r30
     942:	e1 f7       	brne	.-8      	; 0x93c <retConv_s16+0x8a>
     944:	25 2f       	mov	r18, r21
     946:	30 e0       	ldi	r19, 0x00	; 0
     948:	28 2b       	or	r18, r24
     94a:	39 2b       	or	r19, r25
	return int_val;
}
     94c:	c9 01       	movw	r24, r18
     94e:	08 95       	ret

00000950 <retConv_s32>:

s32 retConv_s32(char* ch_head){
     950:	ff 92       	push	r15
     952:	0f 93       	push	r16
     954:	1f 93       	push	r17
     956:	fc 01       	movw	r30, r24

	s32 int_val = 0x00000000;
	char iv1 = *(ch_head);
     958:	90 81       	ld	r25, Z
	char iv2 = *(ch_head + 1);
     95a:	21 81       	ldd	r18, Z+1	; 0x01
	char iv3 = *(ch_head + 2);
     95c:	62 81       	ldd	r22, Z+2	; 0x02
	char iv4 = *(ch_head + 3);
     95e:	73 81       	ldd	r23, Z+3	; 0x03
	char iv5 = *(ch_head + 4);
     960:	14 81       	ldd	r17, Z+4	; 0x04
	char iv6 = *(ch_head + 5);
     962:	05 81       	ldd	r16, Z+5	; 0x05
	char iv7 = *(ch_head + 6);
     964:	f6 80       	ldd	r15, Z+6	; 0x06
	char iv8 = *(ch_head + 7);
     966:	e7 81       	ldd	r30, Z+7	; 0x07

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     968:	89 2f       	mov	r24, r25
     96a:	80 53       	subi	r24, 0x30	; 48
     96c:	8a 30       	cpi	r24, 0x0A	; 10
     96e:	10 f4       	brcc	.+4      	; 0x974 <retConv_s32+0x24>
     970:	98 2f       	mov	r25, r24
     972:	05 c0       	rjmp	.+10     	; 0x97e <retConv_s32+0x2e>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     974:	89 2f       	mov	r24, r25
     976:	81 54       	subi	r24, 0x41	; 65
     978:	86 30       	cpi	r24, 0x06	; 6
     97a:	08 f4       	brcc	.+2      	; 0x97e <retConv_s32+0x2e>
		c -= 55;
     97c:	97 53       	subi	r25, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     97e:	82 2f       	mov	r24, r18
     980:	80 53       	subi	r24, 0x30	; 48
     982:	8a 30       	cpi	r24, 0x0A	; 10
     984:	10 f4       	brcc	.+4      	; 0x98a <retConv_s32+0x3a>
     986:	28 2f       	mov	r18, r24
     988:	05 c0       	rjmp	.+10     	; 0x994 <retConv_s32+0x44>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     98a:	82 2f       	mov	r24, r18
     98c:	81 54       	subi	r24, 0x41	; 65
     98e:	86 30       	cpi	r24, 0x06	; 6
     990:	08 f4       	brcc	.+2      	; 0x994 <retConv_s32+0x44>
		c -= 55;
     992:	27 53       	subi	r18, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     994:	86 2f       	mov	r24, r22
     996:	80 53       	subi	r24, 0x30	; 48
     998:	8a 30       	cpi	r24, 0x0A	; 10
     99a:	10 f4       	brcc	.+4      	; 0x9a0 <retConv_s32+0x50>
     99c:	68 2f       	mov	r22, r24
     99e:	05 c0       	rjmp	.+10     	; 0x9aa <retConv_s32+0x5a>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     9a0:	86 2f       	mov	r24, r22
     9a2:	81 54       	subi	r24, 0x41	; 65
     9a4:	86 30       	cpi	r24, 0x06	; 6
     9a6:	08 f4       	brcc	.+2      	; 0x9aa <retConv_s32+0x5a>
		c -= 55;
     9a8:	67 53       	subi	r22, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     9aa:	87 2f       	mov	r24, r23
     9ac:	80 53       	subi	r24, 0x30	; 48
     9ae:	8a 30       	cpi	r24, 0x0A	; 10
     9b0:	10 f4       	brcc	.+4      	; 0x9b6 <retConv_s32+0x66>
     9b2:	78 2f       	mov	r23, r24
     9b4:	05 c0       	rjmp	.+10     	; 0x9c0 <retConv_s32+0x70>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     9b6:	87 2f       	mov	r24, r23
     9b8:	81 54       	subi	r24, 0x41	; 65
     9ba:	86 30       	cpi	r24, 0x06	; 6
     9bc:	08 f4       	brcc	.+2      	; 0x9c0 <retConv_s32+0x70>
		c -= 55;
     9be:	77 53       	subi	r23, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     9c0:	81 2f       	mov	r24, r17
     9c2:	80 53       	subi	r24, 0x30	; 48
     9c4:	8a 30       	cpi	r24, 0x0A	; 10
     9c6:	10 f4       	brcc	.+4      	; 0x9cc <retConv_s32+0x7c>
     9c8:	18 2f       	mov	r17, r24
     9ca:	05 c0       	rjmp	.+10     	; 0x9d6 <retConv_s32+0x86>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     9cc:	81 2f       	mov	r24, r17
     9ce:	81 54       	subi	r24, 0x41	; 65
     9d0:	86 30       	cpi	r24, 0x06	; 6
     9d2:	08 f4       	brcc	.+2      	; 0x9d6 <retConv_s32+0x86>
		c -= 55;
     9d4:	17 53       	subi	r17, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     9d6:	80 2f       	mov	r24, r16
     9d8:	80 53       	subi	r24, 0x30	; 48
     9da:	8a 30       	cpi	r24, 0x0A	; 10
     9dc:	10 f4       	brcc	.+4      	; 0x9e2 <retConv_s32+0x92>
     9de:	08 2f       	mov	r16, r24
     9e0:	05 c0       	rjmp	.+10     	; 0x9ec <retConv_s32+0x9c>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     9e2:	80 2f       	mov	r24, r16
     9e4:	81 54       	subi	r24, 0x41	; 65
     9e6:	86 30       	cpi	r24, 0x06	; 6
     9e8:	08 f4       	brcc	.+2      	; 0x9ec <retConv_s32+0x9c>
		c -= 55;
     9ea:	07 53       	subi	r16, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     9ec:	8f 2d       	mov	r24, r15
     9ee:	80 53       	subi	r24, 0x30	; 48
     9f0:	8a 30       	cpi	r24, 0x0A	; 10
     9f2:	10 f4       	brcc	.+4      	; 0x9f8 <retConv_s32+0xa8>
     9f4:	f8 2e       	mov	r15, r24
     9f6:	06 c0       	rjmp	.+12     	; 0xa04 <retConv_s32+0xb4>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     9f8:	8f 2d       	mov	r24, r15
     9fa:	81 54       	subi	r24, 0x41	; 65
     9fc:	86 30       	cpi	r24, 0x06	; 6
     9fe:	10 f4       	brcc	.+4      	; 0xa04 <retConv_s32+0xb4>
		c -= 55;
     a00:	89 ec       	ldi	r24, 0xC9	; 201
     a02:	f8 0e       	add	r15, r24

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     a04:	8e 2f       	mov	r24, r30
     a06:	80 53       	subi	r24, 0x30	; 48
     a08:	8a 30       	cpi	r24, 0x0A	; 10
     a0a:	10 f4       	brcc	.+4      	; 0xa10 <retConv_s32+0xc0>
     a0c:	e8 2f       	mov	r30, r24
     a0e:	05 c0       	rjmp	.+10     	; 0xa1a <retConv_s32+0xca>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     a10:	8e 2f       	mov	r24, r30
     a12:	81 54       	subi	r24, 0x41	; 65
     a14:	86 30       	cpi	r24, 0x06	; 6
     a16:	08 f4       	brcc	.+2      	; 0xa1a <retConv_s32+0xca>
		c -= 55;
     a18:	e7 53       	subi	r30, 0x37	; 55
	iv6 = char2hex(iv6);
	iv7 = char2hex(iv7);
	iv8 = char2hex(iv8);

	int_val = (int_val | iv1);
	int_val = ((int_val<<4) | iv2);
     a1a:	30 e0       	ldi	r19, 0x00	; 0
     a1c:	40 e0       	ldi	r20, 0x00	; 0
     a1e:	50 e0       	ldi	r21, 0x00	; 0
     a20:	89 2f       	mov	r24, r25
     a22:	90 e0       	ldi	r25, 0x00	; 0
     a24:	a0 e0       	ldi	r26, 0x00	; 0
     a26:	b0 e0       	ldi	r27, 0x00	; 0
     a28:	f4 e0       	ldi	r31, 0x04	; 4
     a2a:	88 0f       	add	r24, r24
     a2c:	99 1f       	adc	r25, r25
     a2e:	aa 1f       	adc	r26, r26
     a30:	bb 1f       	adc	r27, r27
     a32:	fa 95       	dec	r31
     a34:	d1 f7       	brne	.-12     	; 0xa2a <retConv_s32+0xda>
     a36:	28 2b       	or	r18, r24
     a38:	39 2b       	or	r19, r25
     a3a:	4a 2b       	or	r20, r26
     a3c:	5b 2b       	or	r21, r27
	int_val = ((int_val<<4) | iv3);
     a3e:	a4 e0       	ldi	r26, 0x04	; 4
     a40:	22 0f       	add	r18, r18
     a42:	33 1f       	adc	r19, r19
     a44:	44 1f       	adc	r20, r20
     a46:	55 1f       	adc	r21, r21
     a48:	aa 95       	dec	r26
     a4a:	d1 f7       	brne	.-12     	; 0xa40 <retConv_s32+0xf0>
     a4c:	86 2f       	mov	r24, r22
     a4e:	90 e0       	ldi	r25, 0x00	; 0
     a50:	a0 e0       	ldi	r26, 0x00	; 0
     a52:	b0 e0       	ldi	r27, 0x00	; 0
     a54:	82 2b       	or	r24, r18
     a56:	93 2b       	or	r25, r19
     a58:	a4 2b       	or	r26, r20
     a5a:	b5 2b       	or	r27, r21
	int_val = ((int_val<<4) | iv4);
     a5c:	f4 e0       	ldi	r31, 0x04	; 4
     a5e:	88 0f       	add	r24, r24
     a60:	99 1f       	adc	r25, r25
     a62:	aa 1f       	adc	r26, r26
     a64:	bb 1f       	adc	r27, r27
     a66:	fa 95       	dec	r31
     a68:	d1 f7       	brne	.-12     	; 0xa5e <retConv_s32+0x10e>
     a6a:	27 2f       	mov	r18, r23
     a6c:	30 e0       	ldi	r19, 0x00	; 0
     a6e:	40 e0       	ldi	r20, 0x00	; 0
     a70:	50 e0       	ldi	r21, 0x00	; 0
     a72:	28 2b       	or	r18, r24
     a74:	39 2b       	or	r19, r25
     a76:	4a 2b       	or	r20, r26
     a78:	5b 2b       	or	r21, r27
	int_val = ((int_val<<4) | iv5);
     a7a:	64 e0       	ldi	r22, 0x04	; 4
     a7c:	22 0f       	add	r18, r18
     a7e:	33 1f       	adc	r19, r19
     a80:	44 1f       	adc	r20, r20
     a82:	55 1f       	adc	r21, r21
     a84:	6a 95       	dec	r22
     a86:	d1 f7       	brne	.-12     	; 0xa7c <retConv_s32+0x12c>
     a88:	81 2f       	mov	r24, r17
     a8a:	90 e0       	ldi	r25, 0x00	; 0
     a8c:	a0 e0       	ldi	r26, 0x00	; 0
     a8e:	b0 e0       	ldi	r27, 0x00	; 0
     a90:	82 2b       	or	r24, r18
     a92:	93 2b       	or	r25, r19
     a94:	a4 2b       	or	r26, r20
     a96:	b5 2b       	or	r27, r21
	int_val = ((int_val<<4) | iv6);
     a98:	24 e0       	ldi	r18, 0x04	; 4
     a9a:	88 0f       	add	r24, r24
     a9c:	99 1f       	adc	r25, r25
     a9e:	aa 1f       	adc	r26, r26
     aa0:	bb 1f       	adc	r27, r27
     aa2:	2a 95       	dec	r18
     aa4:	d1 f7       	brne	.-12     	; 0xa9a <retConv_s32+0x14a>
     aa6:	20 2f       	mov	r18, r16
     aa8:	30 e0       	ldi	r19, 0x00	; 0
     aaa:	40 e0       	ldi	r20, 0x00	; 0
     aac:	50 e0       	ldi	r21, 0x00	; 0
     aae:	28 2b       	or	r18, r24
     ab0:	39 2b       	or	r19, r25
     ab2:	4a 2b       	or	r20, r26
     ab4:	5b 2b       	or	r21, r27
	int_val = ((int_val<<4) | iv7);
     ab6:	04 e0       	ldi	r16, 0x04	; 4
     ab8:	22 0f       	add	r18, r18
     aba:	33 1f       	adc	r19, r19
     abc:	44 1f       	adc	r20, r20
     abe:	55 1f       	adc	r21, r21
     ac0:	0a 95       	dec	r16
     ac2:	d1 f7       	brne	.-12     	; 0xab8 <retConv_s32+0x168>
     ac4:	8f 2d       	mov	r24, r15
     ac6:	90 e0       	ldi	r25, 0x00	; 0
     ac8:	a0 e0       	ldi	r26, 0x00	; 0
     aca:	b0 e0       	ldi	r27, 0x00	; 0
     acc:	82 2b       	or	r24, r18
     ace:	93 2b       	or	r25, r19
     ad0:	a4 2b       	or	r26, r20
     ad2:	b5 2b       	or	r27, r21
	int_val = ((int_val<<4) | iv8);
     ad4:	14 e0       	ldi	r17, 0x04	; 4
     ad6:	88 0f       	add	r24, r24
     ad8:	99 1f       	adc	r25, r25
     ada:	aa 1f       	adc	r26, r26
     adc:	bb 1f       	adc	r27, r27
     ade:	1a 95       	dec	r17
     ae0:	d1 f7       	brne	.-12     	; 0xad6 <retConv_s32+0x186>
     ae2:	2e 2f       	mov	r18, r30
     ae4:	30 e0       	ldi	r19, 0x00	; 0
     ae6:	40 e0       	ldi	r20, 0x00	; 0
     ae8:	50 e0       	ldi	r21, 0x00	; 0
     aea:	28 2b       	or	r18, r24
     aec:	39 2b       	or	r19, r25
     aee:	4a 2b       	or	r20, r26
     af0:	5b 2b       	or	r21, r27
	return int_val;
}
     af2:	b9 01       	movw	r22, r18
     af4:	ca 01       	movw	r24, r20
     af6:	1f 91       	pop	r17
     af8:	0f 91       	pop	r16
     afa:	ff 90       	pop	r15
     afc:	08 95       	ret

00000afe <ubRcv>:
			//taskYIELD();
	//	}
}

void ubRcv(unsigned char c){
	if(c != 0xff){
     afe:	8f 3f       	cpi	r24, 0xFF	; 255
     b00:	b9 f0       	breq	.+46     	; 0xb30 <ubRcv+0x32>
		*ub_buffer_write_ndx = c;
     b02:	e0 91 f0 02 	lds	r30, 0x02F0
     b06:	f0 91 f1 02 	lds	r31, 0x02F1
     b0a:	80 83       	st	Z, r24
		ub_buffer_write_ndx++;		
     b0c:	80 91 f0 02 	lds	r24, 0x02F0
     b10:	90 91 f1 02 	lds	r25, 0x02F1
     b14:	01 96       	adiw	r24, 0x01	; 1
     b16:	90 93 f1 02 	sts	0x02F1, r25
     b1a:	80 93 f0 02 	sts	0x02F0, r24
		if(ub_buffer_write_ndx >= (ub_buffer + UB_BUFFER_SIZE)){ 
     b1e:	88 53       	subi	r24, 0x38	; 56
     b20:	94 41       	sbci	r25, 0x14	; 20
     b22:	30 f0       	brcs	.+12     	; 0xb30 <ubRcv+0x32>
			ub_buffer_write_ndx = ub_buffer;
     b24:	88 e3       	ldi	r24, 0x38	; 56
     b26:	92 e1       	ldi	r25, 0x12	; 18
     b28:	90 93 f1 02 	sts	0x02F1, r25
     b2c:	80 93 f0 02 	sts	0x02F0, r24
     b30:	08 95       	ret

00000b32 <init_ub_buffer>:
	}
	return data;
}

void init_ub_buffer(){
	ub_buffer_write_ndx = ub_buffer_read_ndx = ub_buffer;
     b32:	88 e3       	ldi	r24, 0x38	; 56
     b34:	92 e1       	ldi	r25, 0x12	; 18
     b36:	90 93 f3 02 	sts	0x02F3, r25
     b3a:	80 93 f2 02 	sts	0x02F2, r24
     b3e:	90 93 f1 02 	sts	0x02F1, r25
     b42:	80 93 f0 02 	sts	0x02F0, r24
}
     b46:	08 95       	ret

00000b48 <wheel_L>:
}

/*************************************************/


void wheel_L(float cmd_vel){
     b48:	ef 92       	push	r14
     b4a:	ff 92       	push	r15
     b4c:	0f 93       	push	r16
     b4e:	1f 93       	push	r17
     b50:	7b 01       	movw	r14, r22
     b52:	8c 01       	movw	r16, r24
		if(cmd_vel > 36){cmd_vel = 36;}
     b54:	20 e0       	ldi	r18, 0x00	; 0
     b56:	30 e0       	ldi	r19, 0x00	; 0
     b58:	40 e1       	ldi	r20, 0x10	; 16
     b5a:	52 e4       	ldi	r21, 0x42	; 66
     b5c:	0e 94 8b 2d 	call	0x5b16	; 0x5b16 <__gesf2>
     b60:	18 16       	cp	r1, r24
     b62:	5c f4       	brge	.+22     	; 0xb7a <wheel_L+0x32>
     b64:	0f 2e       	mov	r0, r31
     b66:	f0 e0       	ldi	r31, 0x00	; 0
     b68:	ef 2e       	mov	r14, r31
     b6a:	f0 e0       	ldi	r31, 0x00	; 0
     b6c:	ff 2e       	mov	r15, r31
     b6e:	f0 e1       	ldi	r31, 0x10	; 16
     b70:	0f 2f       	mov	r16, r31
     b72:	f2 e4       	ldi	r31, 0x42	; 66
     b74:	1f 2f       	mov	r17, r31
     b76:	f0 2d       	mov	r31, r0
     b78:	14 c0       	rjmp	.+40     	; 0xba2 <wheel_L+0x5a>
		if(cmd_vel < -36){cmd_vel = -36;}
     b7a:	c8 01       	movw	r24, r16
     b7c:	b7 01       	movw	r22, r14
     b7e:	20 e0       	ldi	r18, 0x00	; 0
     b80:	30 e0       	ldi	r19, 0x00	; 0
     b82:	40 e1       	ldi	r20, 0x10	; 16
     b84:	52 ec       	ldi	r21, 0xC2	; 194
     b86:	0e 94 c2 2b 	call	0x5784	; 0x5784 <__cmpsf2>
     b8a:	88 23       	and	r24, r24
     b8c:	54 f4       	brge	.+20     	; 0xba2 <wheel_L+0x5a>
     b8e:	0f 2e       	mov	r0, r31
     b90:	f0 e0       	ldi	r31, 0x00	; 0
     b92:	ef 2e       	mov	r14, r31
     b94:	f0 e0       	ldi	r31, 0x00	; 0
     b96:	ff 2e       	mov	r15, r31
     b98:	f0 e1       	ldi	r31, 0x10	; 16
     b9a:	0f 2f       	mov	r16, r31
     b9c:	f2 ec       	ldi	r31, 0xC2	; 194
     b9e:	1f 2f       	mov	r17, r31
     ba0:	f0 2d       	mov	r31, r0
		
		float s_out = -0.4928 * (cmd_vel) + 185.27;
		
		taskENTER_CRITICAL();
     ba2:	0f b6       	in	r0, 0x3f	; 63
     ba4:	f8 94       	cli
     ba6:	0f 92       	push	r0
		PWM_timer3_Set_E4((int)s_out);
     ba8:	c8 01       	movw	r24, r16
     baa:	b7 01       	movw	r22, r14
     bac:	28 e4       	ldi	r18, 0x48	; 72
     bae:	30 e5       	ldi	r19, 0x50	; 80
     bb0:	4c ef       	ldi	r20, 0xFC	; 252
     bb2:	5e eb       	ldi	r21, 0xBE	; 190
     bb4:	0e 94 96 2d 	call	0x5b2c	; 0x5b2c <__mulsf3>
     bb8:	2f e1       	ldi	r18, 0x1F	; 31
     bba:	35 e4       	ldi	r19, 0x45	; 69
     bbc:	49 e3       	ldi	r20, 0x39	; 57
     bbe:	53 e4       	ldi	r21, 0x43	; 67
     bc0:	0e 94 fc 2a 	call	0x55f8	; 0x55f8 <__addsf3>
     bc4:	0e 94 2e 2c 	call	0x585c	; 0x585c <__fixsfsi>
void PWM_timer2_Set_H6(u16 pwmDuty)
	{OCR2B = pwmDuty;}
void PWM_timer3_Set_E3(u16 pwmDuty)
	{OCR3A = pwmDuty;}
void PWM_timer3_Set_E4(u16 pwmDuty)
	{OCR3B = pwmDuty;}
     bc8:	70 93 9b 00 	sts	0x009B, r23
     bcc:	60 93 9a 00 	sts	0x009A, r22
		taskEXIT_CRITICAL();
     bd0:	0f 90       	pop	r0
     bd2:	0f be       	out	0x3f, r0	; 63


}
     bd4:	1f 91       	pop	r17
     bd6:	0f 91       	pop	r16
     bd8:	ff 90       	pop	r15
     bda:	ef 90       	pop	r14
     bdc:	08 95       	ret

00000bde <wheel_R>:

void wheel_R(float cmd_vel){
     bde:	ef 92       	push	r14
     be0:	ff 92       	push	r15
     be2:	0f 93       	push	r16
     be4:	1f 93       	push	r17
     be6:	7b 01       	movw	r14, r22
     be8:	8c 01       	movw	r16, r24
		if(cmd_vel > 36){cmd_vel = 36;}
     bea:	20 e0       	ldi	r18, 0x00	; 0
     bec:	30 e0       	ldi	r19, 0x00	; 0
     bee:	40 e1       	ldi	r20, 0x10	; 16
     bf0:	52 e4       	ldi	r21, 0x42	; 66
     bf2:	0e 94 8b 2d 	call	0x5b16	; 0x5b16 <__gesf2>
     bf6:	18 16       	cp	r1, r24
     bf8:	5c f4       	brge	.+22     	; 0xc10 <wheel_R+0x32>
     bfa:	0f 2e       	mov	r0, r31
     bfc:	f0 e0       	ldi	r31, 0x00	; 0
     bfe:	ef 2e       	mov	r14, r31
     c00:	f0 e0       	ldi	r31, 0x00	; 0
     c02:	ff 2e       	mov	r15, r31
     c04:	f0 e1       	ldi	r31, 0x10	; 16
     c06:	0f 2f       	mov	r16, r31
     c08:	f2 e4       	ldi	r31, 0x42	; 66
     c0a:	1f 2f       	mov	r17, r31
     c0c:	f0 2d       	mov	r31, r0
     c0e:	14 c0       	rjmp	.+40     	; 0xc38 <wheel_R+0x5a>
		if(cmd_vel < -36){cmd_vel = -36;}
     c10:	c8 01       	movw	r24, r16
     c12:	b7 01       	movw	r22, r14
     c14:	20 e0       	ldi	r18, 0x00	; 0
     c16:	30 e0       	ldi	r19, 0x00	; 0
     c18:	40 e1       	ldi	r20, 0x10	; 16
     c1a:	52 ec       	ldi	r21, 0xC2	; 194
     c1c:	0e 94 c2 2b 	call	0x5784	; 0x5784 <__cmpsf2>
     c20:	88 23       	and	r24, r24
     c22:	54 f4       	brge	.+20     	; 0xc38 <wheel_R+0x5a>
     c24:	0f 2e       	mov	r0, r31
     c26:	f0 e0       	ldi	r31, 0x00	; 0
     c28:	ef 2e       	mov	r14, r31
     c2a:	f0 e0       	ldi	r31, 0x00	; 0
     c2c:	ff 2e       	mov	r15, r31
     c2e:	f0 e1       	ldi	r31, 0x10	; 16
     c30:	0f 2f       	mov	r16, r31
     c32:	f2 ec       	ldi	r31, 0xC2	; 194
     c34:	1f 2f       	mov	r17, r31
     c36:	f0 2d       	mov	r31, r0
				
		float s_out = -0.5421 * (cmd_vel) + 188.41;

		taskENTER_CRITICAL();
     c38:	0f b6       	in	r0, 0x3f	; 63
     c3a:	f8 94       	cli
     c3c:	0f 92       	push	r0
		PWM_timer3_Set_E3((int)s_out);
     c3e:	c8 01       	movw	r24, r16
     c40:	b7 01       	movw	r22, r14
     c42:	21 e1       	ldi	r18, 0x11	; 17
     c44:	37 ec       	ldi	r19, 0xC7	; 199
     c46:	4a e0       	ldi	r20, 0x0A	; 10
     c48:	5f eb       	ldi	r21, 0xBF	; 191
     c4a:	0e 94 96 2d 	call	0x5b2c	; 0x5b2c <__mulsf3>
     c4e:	26 ef       	ldi	r18, 0xF6	; 246
     c50:	38 e6       	ldi	r19, 0x68	; 104
     c52:	4c e3       	ldi	r20, 0x3C	; 60
     c54:	53 e4       	ldi	r21, 0x43	; 67
     c56:	0e 94 fc 2a 	call	0x55f8	; 0x55f8 <__addsf3>
     c5a:	0e 94 2e 2c 	call	0x585c	; 0x585c <__fixsfsi>
void PWM_timer1_Set_LED(u16 pwmDuty)
	{OCR1B = pwmDuty;}
void PWM_timer2_Set_H6(u16 pwmDuty)
	{OCR2B = pwmDuty;}
void PWM_timer3_Set_E3(u16 pwmDuty)
	{OCR3A = pwmDuty;}
     c5e:	70 93 99 00 	sts	0x0099, r23
     c62:	60 93 98 00 	sts	0x0098, r22
		taskEXIT_CRITICAL();
     c66:	0f 90       	pop	r0
     c68:	0f be       	out	0x3f, r0	; 63


}
     c6a:	1f 91       	pop	r17
     c6c:	0f 91       	pop	r16
     c6e:	ff 90       	pop	r15
     c70:	ef 90       	pop	r14
     c72:	08 95       	ret

00000c74 <num2char>:
	}
}



char num2char(char c){
     c74:	98 2f       	mov	r25, r24
	
	if(c <10){
     c76:	8a 30       	cpi	r24, 0x0A	; 10
     c78:	10 f4       	brcc	.+4      	; 0xc7e <num2char+0xa>
		c += 48;
     c7a:	90 5d       	subi	r25, 0xD0	; 208
     c7c:	04 c0       	rjmp	.+8      	; 0xc86 <num2char+0x12>
	}
	else if((c >= 10) && (c <= 16)){
     c7e:	8a 50       	subi	r24, 0x0A	; 10
     c80:	87 30       	cpi	r24, 0x07	; 7
     c82:	08 f4       	brcc	.+2      	; 0xc86 <num2char+0x12>
		c += 55;
     c84:	99 5c       	subi	r25, 0xC9	; 201
	}
	return c;
}
     c86:	89 2f       	mov	r24, r25
     c88:	08 95       	ret

00000c8a <vUpdatePose>:
		
	vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
	}
}

void vUpdatePose(){
     c8a:	af 92       	push	r10
     c8c:	bf 92       	push	r11
     c8e:	cf 92       	push	r12
     c90:	df 92       	push	r13
     c92:	ef 92       	push	r14
     c94:	ff 92       	push	r15
     c96:	0f 93       	push	r16
     c98:	1f 93       	push	r17
	float CMD_K = 0.5;
	float COR_K = 1;
	uint8_t lds_char;

	for(;;){
		robot.heading = (180 * enc_heading) / M_PI; 
     c9a:	60 91 d8 02 	lds	r22, 0x02D8
     c9e:	70 91 d9 02 	lds	r23, 0x02D9
     ca2:	80 91 da 02 	lds	r24, 0x02DA
     ca6:	90 91 db 02 	lds	r25, 0x02DB
     caa:	20 e0       	ldi	r18, 0x00	; 0
     cac:	30 e0       	ldi	r19, 0x00	; 0
     cae:	44 e3       	ldi	r20, 0x34	; 52
     cb0:	53 e4       	ldi	r21, 0x43	; 67
     cb2:	0e 94 96 2d 	call	0x5b2c	; 0x5b2c <__mulsf3>
     cb6:	2b ed       	ldi	r18, 0xDB	; 219
     cb8:	3f e0       	ldi	r19, 0x0F	; 15
     cba:	49 e4       	ldi	r20, 0x49	; 73
     cbc:	50 e4       	ldi	r21, 0x40	; 64
     cbe:	0e 94 c6 2b 	call	0x578c	; 0x578c <__divsf3>
     cc2:	5b 01       	movw	r10, r22
     cc4:	6c 01       	movw	r12, r24
		robot.vel = (LEFTVel_current + (-RIGHTVel_current)) / 2;
     cc6:	80 91 be 02 	lds	r24, 0x02BE
     cca:	90 91 bf 02 	lds	r25, 0x02BF
     cce:	20 91 cb 02 	lds	r18, 0x02CB
     cd2:	30 91 cc 02 	lds	r19, 0x02CC
     cd6:	82 1b       	sub	r24, r18
     cd8:	93 0b       	sbc	r25, r19
     cda:	62 e0       	ldi	r22, 0x02	; 2
     cdc:	70 e0       	ldi	r23, 0x00	; 0
     cde:	0e 94 2f 2e 	call	0x5c5e	; 0x5c5e <__divmodhi4>
     ce2:	88 27       	eor	r24, r24
     ce4:	77 fd       	sbrc	r23, 7
     ce6:	80 95       	com	r24
     ce8:	98 2f       	mov	r25, r24
     cea:	0e 94 61 2c 	call	0x58c2	; 0x58c2 <__floatsisf>
     cee:	7b 01       	movw	r14, r22
     cf0:	8c 01       	movw	r16, r24
	float CMD_K = 0.5;
	float COR_K = 1;
	uint8_t lds_char;

	for(;;){
		robot.heading = (180 * enc_heading) / M_PI; 
     cf2:	c5 01       	movw	r24, r10
     cf4:	d6 01       	movw	r26, r12
     cf6:	80 93 38 14 	sts	0x1438, r24
     cfa:	90 93 39 14 	sts	0x1439, r25
     cfe:	a0 93 3a 14 	sts	0x143A, r26
     d02:	b0 93 3b 14 	sts	0x143B, r27
		robot.vel = (LEFTVel_current + (-RIGHTVel_current)) / 2;
     d06:	e0 92 3c 14 	sts	0x143C, r14
     d0a:	f0 92 3d 14 	sts	0x143D, r15
     d0e:	00 93 3e 14 	sts	0x143E, r16
     d12:	10 93 3f 14 	sts	0x143F, r17
     d16:	ed cf       	rjmp	.-38     	; 0xcf2 <vUpdatePose+0x68>

00000d18 <fwdSer_L>:
		
			//taskYIELD();
	//	}
		
}
void fwdSer_L(unsigned char c){
     d18:	98 2f       	mov	r25, r24
	static char d_flag;
	static char vel_rough[4];  //store ascii chars
	static char dis_rough[8];  //store ascii chars

		//rprintf("%c",c);
		if(c != 0xff){
     d1a:	8f 3f       	cpi	r24, 0xFF	; 255
     d1c:	09 f4       	brne	.+2      	; 0xd20 <fwdSer_L+0x8>
     d1e:	7c c0       	rjmp	.+248    	; 0xe18 <fwdSer_L+0x100>
		//if the data isn't whitespace (0xff), post it
		//	rprintf("%c",c);

			if(c == 0x0A){lf_flag = SET;} //line feed detected, the character will be a 'D' or a 'V'
     d20:	8a 30       	cpi	r24, 0x0A	; 10
     d22:	21 f4       	brne	.+8      	; 0xd2c <fwdSer_L+0x14>
     d24:	81 e0       	ldi	r24, 0x01	; 1
     d26:	80 93 0c 03 	sts	0x030C, r24
     d2a:	33 c0       	rjmp	.+102    	; 0xd92 <fwdSer_L+0x7a>
	
			else if((lf_flag) && (c == 'V')){ //set velocity flag
     d2c:	80 91 0c 03 	lds	r24, 0x030C
     d30:	88 23       	and	r24, r24
     d32:	91 f0       	breq	.+36     	; 0xd58 <fwdSer_L+0x40>
     d34:	96 35       	cpi	r25, 0x56	; 86
     d36:	31 f4       	brne	.+12     	; 0xd44 <fwdSer_L+0x2c>
				v_flag = SET;
     d38:	81 e0       	ldi	r24, 0x01	; 1
     d3a:	80 93 09 03 	sts	0x0309, r24
				v_iter = 0;
     d3e:	10 92 0b 03 	sts	0x030B, r1
     d42:	07 c0       	rjmp	.+14     	; 0xd52 <fwdSer_L+0x3a>
				lf_flag = UNSET;
				return;
			} 
			else if((lf_flag) && (c == 'D')){ //set distance flag
     d44:	94 34       	cpi	r25, 0x44	; 68
     d46:	41 f4       	brne	.+16     	; 0xd58 <fwdSer_L+0x40>
				d_flag = SET;
     d48:	81 e0       	ldi	r24, 0x01	; 1
     d4a:	80 93 08 03 	sts	0x0308, r24
				d_iter = 0;
     d4e:	10 92 0a 03 	sts	0x030A, r1
				lf_flag = UNSET;
     d52:	10 92 0c 03 	sts	0x030C, r1
     d56:	08 95       	ret
			//	rprintf("%c",c);
				return;
			}
			else if(v_flag){
     d58:	80 91 09 03 	lds	r24, 0x0309
     d5c:	88 23       	and	r24, r24
     d5e:	59 f0       	breq	.+22     	; 0xd76 <fwdSer_L+0x5e>
				vel_rough[v_iter++] = c;	//store then increment	
     d60:	80 91 0b 03 	lds	r24, 0x030B
     d64:	e8 2f       	mov	r30, r24
     d66:	f0 e0       	ldi	r31, 0x00	; 0
     d68:	ec 5f       	subi	r30, 0xFC	; 252
     d6a:	fc 4f       	sbci	r31, 0xFC	; 252
     d6c:	90 83       	st	Z, r25
     d6e:	8f 5f       	subi	r24, 0xFF	; 255
     d70:	80 93 0b 03 	sts	0x030B, r24
     d74:	0e c0       	rjmp	.+28     	; 0xd92 <fwdSer_L+0x7a>
				//rprintf("%c",c);
			}	
			else if(d_flag){
     d76:	80 91 08 03 	lds	r24, 0x0308
     d7a:	88 23       	and	r24, r24
     d7c:	51 f0       	breq	.+20     	; 0xd92 <fwdSer_L+0x7a>
				dis_rough[d_iter++] = c;	//store then increment	
     d7e:	80 91 0a 03 	lds	r24, 0x030A
     d82:	e8 2f       	mov	r30, r24
     d84:	f0 e0       	ldi	r31, 0x00	; 0
     d86:	e4 50       	subi	r30, 0x04	; 4
     d88:	fd 4f       	sbci	r31, 0xFD	; 253
     d8a:	90 83       	st	Z, r25
     d8c:	8f 5f       	subi	r24, 0xFF	; 255
     d8e:	80 93 0a 03 	sts	0x030A, r24
			//	rprintf("%c",c);
			}

			if(v_iter == 4){
     d92:	80 91 0b 03 	lds	r24, 0x030B
     d96:	84 30       	cpi	r24, 0x04	; 4
     d98:	01 f5       	brne	.+64     	; 0xdda <fwdSer_L+0xc2>
				LEFTVel_current = CM_TICK * retConv_s16(&vel_rough);
     d9a:	84 e0       	ldi	r24, 0x04	; 4
     d9c:	93 e0       	ldi	r25, 0x03	; 3
     d9e:	0e 94 59 04 	call	0x8b2	; 0x8b2 <retConv_s16>
     da2:	aa 27       	eor	r26, r26
     da4:	97 fd       	sbrc	r25, 7
     da6:	a0 95       	com	r26
     da8:	ba 2f       	mov	r27, r26
     daa:	bc 01       	movw	r22, r24
     dac:	cd 01       	movw	r24, r26
     dae:	0e 94 61 2c 	call	0x58c2	; 0x58c2 <__floatsisf>
     db2:	20 e0       	ldi	r18, 0x00	; 0
     db4:	30 e0       	ldi	r19, 0x00	; 0
     db6:	40 e8       	ldi	r20, 0x80	; 128
     db8:	5e e3       	ldi	r21, 0x3E	; 62
     dba:	0e 94 96 2d 	call	0x5b2c	; 0x5b2c <__mulsf3>
     dbe:	0e 94 2e 2c 	call	0x585c	; 0x585c <__fixsfsi>
     dc2:	70 93 bf 02 	sts	0x02BF, r23
     dc6:	60 93 be 02 	sts	0x02BE, r22
				v_flag = UNSET;
     dca:	10 92 09 03 	sts	0x0309, r1
				v_iter = 0;
     dce:	10 92 0b 03 	sts	0x030B, r1
				LEFTVel_ready = SET;
     dd2:	81 e0       	ldi	r24, 0x01	; 1
     dd4:	80 93 c0 02 	sts	0x02C0, r24
     dd8:	08 95       	ret
			//	rprintf("LEFTVel_ready: %d\n", LEFTVel_ready);
			//	rprintf("LLL VVV: ");
			//	rprintfu16(RIGHTVel_current);
			//	rprintf("\n");
			}
			else if(d_iter == 8){
     dda:	80 91 0a 03 	lds	r24, 0x030A
     dde:	88 30       	cpi	r24, 0x08	; 8
     de0:	51 f5       	brne	.+84     	; 0xe36 <fwdSer_L+0x11e>
				LEFTDis_current = CM_TICK * retConv_s32(&dis_rough);
     de2:	8c ef       	ldi	r24, 0xFC	; 252
     de4:	92 e0       	ldi	r25, 0x02	; 2
     de6:	0e 94 a8 04 	call	0x950	; 0x950 <retConv_s32>
     dea:	0e 94 61 2c 	call	0x58c2	; 0x58c2 <__floatsisf>
     dee:	20 e0       	ldi	r18, 0x00	; 0
     df0:	30 e0       	ldi	r19, 0x00	; 0
     df2:	40 e8       	ldi	r20, 0x80	; 128
     df4:	5e e3       	ldi	r21, 0x3E	; 62
     df6:	0e 94 96 2d 	call	0x5b2c	; 0x5b2c <__mulsf3>
     dfa:	0e 94 2e 2c 	call	0x585c	; 0x585c <__fixsfsi>
     dfe:	60 93 c1 02 	sts	0x02C1, r22
     e02:	70 93 c2 02 	sts	0x02C2, r23
     e06:	80 93 c3 02 	sts	0x02C3, r24
     e0a:	90 93 c4 02 	sts	0x02C4, r25
			//	rprintf("dL: %d\n",dLEFTDis);
				d_flag = UNSET;
     e0e:	10 92 08 03 	sts	0x0308, r1
				d_iter = 0;
     e12:	10 92 0a 03 	sts	0x030A, r1
     e16:	08 95       	ret
			//	rprintf("\n");
			}
		
		}

		else{rprintf("WR\n");}
     e18:	00 d0       	rcall	.+0      	; 0xe1a <fwdSer_L+0x102>
     e1a:	0f 92       	push	r0
     e1c:	81 e0       	ldi	r24, 0x01	; 1
     e1e:	ed b7       	in	r30, 0x3d	; 61
     e20:	fe b7       	in	r31, 0x3e	; 62
     e22:	81 83       	std	Z+1, r24	; 0x01
     e24:	86 e8       	ldi	r24, 0x86	; 134
     e26:	91 e0       	ldi	r25, 0x01	; 1
     e28:	93 83       	std	Z+3, r25	; 0x03
     e2a:	82 83       	std	Z+2, r24	; 0x02
     e2c:	0e 94 c2 27 	call	0x4f84	; 0x4f84 <rprintf1RamRom>
     e30:	0f 90       	pop	r0
     e32:	0f 90       	pop	r0
     e34:	0f 90       	pop	r0
     e36:	08 95       	ret

00000e38 <fwdSer_R>:
	int_val = ((int_val<<4) | iv8);
	return int_val;
}


void fwdSer_R(unsigned char c){
     e38:	98 2f       	mov	r25, r24
	static char d_flag;
	static char vel_rough[4];  //store ascii chars
	static char dis_rough[8];  //store ascii chars

		//rprintf("%c",c);
		if(c != 0xff){
     e3a:	8f 3f       	cpi	r24, 0xFF	; 255
     e3c:	09 f4       	brne	.+2      	; 0xe40 <fwdSer_R+0x8>
     e3e:	7c c0       	rjmp	.+248    	; 0xf38 <fwdSer_R+0x100>
		//if the data isn't whitespace (0xff), post it
		//	rprintf("%c",c);

			if(c == 0x0A){lf_flag = SET;} //line feed detected, the character will be a 'D' or a 'V'
     e40:	8a 30       	cpi	r24, 0x0A	; 10
     e42:	21 f4       	brne	.+8      	; 0xe4c <fwdSer_R+0x14>
     e44:	81 e0       	ldi	r24, 0x01	; 1
     e46:	80 93 1d 03 	sts	0x031D, r24
     e4a:	33 c0       	rjmp	.+102    	; 0xeb2 <fwdSer_R+0x7a>
	
			else if((lf_flag) && (c == 'V')){ //set velocity flag
     e4c:	80 91 1d 03 	lds	r24, 0x031D
     e50:	88 23       	and	r24, r24
     e52:	91 f0       	breq	.+36     	; 0xe78 <fwdSer_R+0x40>
     e54:	96 35       	cpi	r25, 0x56	; 86
     e56:	31 f4       	brne	.+12     	; 0xe64 <fwdSer_R+0x2c>
				v_flag = SET;
     e58:	81 e0       	ldi	r24, 0x01	; 1
     e5a:	80 93 1a 03 	sts	0x031A, r24
				v_iter = 0;
     e5e:	10 92 1c 03 	sts	0x031C, r1
     e62:	07 c0       	rjmp	.+14     	; 0xe72 <fwdSer_R+0x3a>
				lf_flag = UNSET;
				return;
			} 
			else if((lf_flag) && (c == 'D')){ //set distance flag
     e64:	94 34       	cpi	r25, 0x44	; 68
     e66:	41 f4       	brne	.+16     	; 0xe78 <fwdSer_R+0x40>
				d_flag = SET;
     e68:	81 e0       	ldi	r24, 0x01	; 1
     e6a:	80 93 19 03 	sts	0x0319, r24
				d_iter = 0;
     e6e:	10 92 1b 03 	sts	0x031B, r1
				lf_flag = UNSET;
     e72:	10 92 1d 03 	sts	0x031D, r1
     e76:	08 95       	ret
			//	rprintf("%c",c);
				return;
			}
			else if(v_flag){
     e78:	80 91 1a 03 	lds	r24, 0x031A
     e7c:	88 23       	and	r24, r24
     e7e:	59 f0       	breq	.+22     	; 0xe96 <fwdSer_R+0x5e>
				vel_rough[v_iter++] = c;	//store then increment	
     e80:	80 91 1c 03 	lds	r24, 0x031C
     e84:	e8 2f       	mov	r30, r24
     e86:	f0 e0       	ldi	r31, 0x00	; 0
     e88:	eb 5e       	subi	r30, 0xEB	; 235
     e8a:	fc 4f       	sbci	r31, 0xFC	; 252
     e8c:	90 83       	st	Z, r25
     e8e:	8f 5f       	subi	r24, 0xFF	; 255
     e90:	80 93 1c 03 	sts	0x031C, r24
     e94:	0e c0       	rjmp	.+28     	; 0xeb2 <fwdSer_R+0x7a>
				//rprintf("%c",c);
			}	
			else if(d_flag){
     e96:	80 91 19 03 	lds	r24, 0x0319
     e9a:	88 23       	and	r24, r24
     e9c:	51 f0       	breq	.+20     	; 0xeb2 <fwdSer_R+0x7a>
				dis_rough[d_iter++] = c;	//store then increment	
     e9e:	80 91 1b 03 	lds	r24, 0x031B
     ea2:	e8 2f       	mov	r30, r24
     ea4:	f0 e0       	ldi	r31, 0x00	; 0
     ea6:	e3 5f       	subi	r30, 0xF3	; 243
     ea8:	fc 4f       	sbci	r31, 0xFC	; 252
     eaa:	90 83       	st	Z, r25
     eac:	8f 5f       	subi	r24, 0xFF	; 255
     eae:	80 93 1b 03 	sts	0x031B, r24
			//	rprintf("%c",c);
			}

			if(v_iter == 4){
     eb2:	80 91 1c 03 	lds	r24, 0x031C
     eb6:	84 30       	cpi	r24, 0x04	; 4
     eb8:	01 f5       	brne	.+64     	; 0xefa <fwdSer_R+0xc2>
				RIGHTVel_current = CM_TICK * retConv_s16(&vel_rough);
     eba:	85 e1       	ldi	r24, 0x15	; 21
     ebc:	93 e0       	ldi	r25, 0x03	; 3
     ebe:	0e 94 59 04 	call	0x8b2	; 0x8b2 <retConv_s16>
     ec2:	aa 27       	eor	r26, r26
     ec4:	97 fd       	sbrc	r25, 7
     ec6:	a0 95       	com	r26
     ec8:	ba 2f       	mov	r27, r26
     eca:	bc 01       	movw	r22, r24
     ecc:	cd 01       	movw	r24, r26
     ece:	0e 94 61 2c 	call	0x58c2	; 0x58c2 <__floatsisf>
     ed2:	20 e0       	ldi	r18, 0x00	; 0
     ed4:	30 e0       	ldi	r19, 0x00	; 0
     ed6:	40 e8       	ldi	r20, 0x80	; 128
     ed8:	5e e3       	ldi	r21, 0x3E	; 62
     eda:	0e 94 96 2d 	call	0x5b2c	; 0x5b2c <__mulsf3>
     ede:	0e 94 2e 2c 	call	0x585c	; 0x585c <__fixsfsi>
     ee2:	70 93 cc 02 	sts	0x02CC, r23
     ee6:	60 93 cb 02 	sts	0x02CB, r22
				v_flag = UNSET;
     eea:	10 92 1a 03 	sts	0x031A, r1
				v_iter = 0;
     eee:	10 92 1c 03 	sts	0x031C, r1
				RIGHTVel_ready = SET;
     ef2:	81 e0       	ldi	r24, 0x01	; 1
     ef4:	80 93 cd 02 	sts	0x02CD, r24
     ef8:	08 95       	ret

			//	rprintf("RRR VVV: ");
			//	rprintfu16(RIGHTVel_current);
			//	rprintf("\n");
			}
			else if(d_iter == 8){
     efa:	80 91 1b 03 	lds	r24, 0x031B
     efe:	88 30       	cpi	r24, 0x08	; 8
     f00:	51 f5       	brne	.+84     	; 0xf56 <fwdSer_R+0x11e>
				RIGHTDis_current = CM_TICK * retConv_s32(&dis_rough);
     f02:	8d e0       	ldi	r24, 0x0D	; 13
     f04:	93 e0       	ldi	r25, 0x03	; 3
     f06:	0e 94 a8 04 	call	0x950	; 0x950 <retConv_s32>
     f0a:	0e 94 61 2c 	call	0x58c2	; 0x58c2 <__floatsisf>
     f0e:	20 e0       	ldi	r18, 0x00	; 0
     f10:	30 e0       	ldi	r19, 0x00	; 0
     f12:	40 e8       	ldi	r20, 0x80	; 128
     f14:	5e e3       	ldi	r21, 0x3E	; 62
     f16:	0e 94 96 2d 	call	0x5b2c	; 0x5b2c <__mulsf3>
     f1a:	0e 94 2e 2c 	call	0x585c	; 0x585c <__fixsfsi>
     f1e:	60 93 ce 02 	sts	0x02CE, r22
     f22:	70 93 cf 02 	sts	0x02CF, r23
     f26:	80 93 d0 02 	sts	0x02D0, r24
     f2a:	90 93 d1 02 	sts	0x02D1, r25
				//rprintf("dR: %d\n",dRIGHTDis);
				d_flag = UNSET;
     f2e:	10 92 19 03 	sts	0x0319, r1
				d_iter = 0;
     f32:	10 92 1b 03 	sts	0x031B, r1
     f36:	08 95       	ret
				//rprintf("\n");
			}
		
		}

		else{rprintf("WR\n");}
     f38:	00 d0       	rcall	.+0      	; 0xf3a <fwdSer_R+0x102>
     f3a:	0f 92       	push	r0
     f3c:	81 e0       	ldi	r24, 0x01	; 1
     f3e:	ed b7       	in	r30, 0x3d	; 61
     f40:	fe b7       	in	r31, 0x3e	; 62
     f42:	81 83       	std	Z+1, r24	; 0x01
     f44:	8a e8       	ldi	r24, 0x8A	; 138
     f46:	91 e0       	ldi	r25, 0x01	; 1
     f48:	93 83       	std	Z+3, r25	; 0x03
     f4a:	82 83       	std	Z+2, r24	; 0x02
     f4c:	0e 94 c2 27 	call	0x4f84	; 0x4f84 <rprintf1RamRom>
     f50:	0f 90       	pop	r0
     f52:	0f 90       	pop	r0
     f54:	0f 90       	pop	r0
     f56:	08 95       	ret

00000f58 <vScript>:
		
	}

}

void vScript(){
     f58:	3f 92       	push	r3
     f5a:	4f 92       	push	r4
     f5c:	5f 92       	push	r5
     f5e:	6f 92       	push	r6
     f60:	7f 92       	push	r7
     f62:	8f 92       	push	r8
     f64:	9f 92       	push	r9
     f66:	af 92       	push	r10
     f68:	bf 92       	push	r11
     f6a:	cf 92       	push	r12
     f6c:	df 92       	push	r13
     f6e:	ef 92       	push	r14
     f70:	ff 92       	push	r15
     f72:	0f 93       	push	r16
     f74:	1f 93       	push	r17
     f76:	df 93       	push	r29
     f78:	cf 93       	push	r28
     f7a:	00 d0       	rcall	.+0      	; 0xf7c <vScript+0x24>
     f7c:	cd b7       	in	r28, 0x3d	; 61
     f7e:	de b7       	in	r29, 0x3e	; 62
	const portTickType xTicksToWait = 10000 / portTICK_RATE_MS;
	portTickType xLastWakeTime;

	for(;;){
		cmd_angle = 0;
     f80:	0f 2e       	mov	r0, r31
     f82:	f0 e0       	ldi	r31, 0x00	; 0
     f84:	af 2e       	mov	r10, r31
     f86:	f0 e0       	ldi	r31, 0x00	; 0
     f88:	bf 2e       	mov	r11, r31
     f8a:	f0 e0       	ldi	r31, 0x00	; 0
     f8c:	cf 2e       	mov	r12, r31
     f8e:	f0 e0       	ldi	r31, 0x00	; 0
     f90:	df 2e       	mov	r13, r31
     f92:	f0 2d       	mov	r31, r0
		rprintf("cmd_angle: ");
     f94:	33 24       	eor	r3, r3
     f96:	33 94       	inc	r3
     f98:	b1 e4       	ldi	r27, 0x41	; 65
     f9a:	4b 2e       	mov	r4, r27
     f9c:	b1 e0       	ldi	r27, 0x01	; 1
     f9e:	5b 2e       	mov	r5, r27
		rprintfFloat(5, cmd_angle);
		rprintfCRLF();
		vTaskDelayUntil(&xLastWakeTime, xTicksToWait);
     fa0:	4e 01       	movw	r8, r28
     fa2:	08 94       	sec
     fa4:	81 1c       	adc	r8, r1
     fa6:	91 1c       	adc	r9, r1
		cmd_angle = 90*(M_PI/180);
     fa8:	0f 2e       	mov	r0, r31
     faa:	fb ed       	ldi	r31, 0xDB	; 219
     fac:	ef 2e       	mov	r14, r31
     fae:	ff e0       	ldi	r31, 0x0F	; 15
     fb0:	ff 2e       	mov	r15, r31
     fb2:	f9 ec       	ldi	r31, 0xC9	; 201
     fb4:	0f 2f       	mov	r16, r31
     fb6:	ff e3       	ldi	r31, 0x3F	; 63
     fb8:	1f 2f       	mov	r17, r31
     fba:	f0 2d       	mov	r31, r0
		rprintf("cmd_angle: ");
     fbc:	a5 e3       	ldi	r26, 0x35	; 53
     fbe:	6a 2e       	mov	r6, r26
     fc0:	a1 e0       	ldi	r26, 0x01	; 1
     fc2:	7a 2e       	mov	r7, r26
void vScript(){
	const portTickType xTicksToWait = 10000 / portTICK_RATE_MS;
	portTickType xLastWakeTime;

	for(;;){
		cmd_angle = 0;
     fc4:	a0 92 e4 02 	sts	0x02E4, r10
     fc8:	b0 92 e5 02 	sts	0x02E5, r11
     fcc:	c0 92 e6 02 	sts	0x02E6, r12
     fd0:	d0 92 e7 02 	sts	0x02E7, r13
		rprintf("cmd_angle: ");
     fd4:	00 d0       	rcall	.+0      	; 0xfd6 <vScript+0x7e>
     fd6:	0f 92       	push	r0
     fd8:	ed b7       	in	r30, 0x3d	; 61
     fda:	fe b7       	in	r31, 0x3e	; 62
     fdc:	31 82       	std	Z+1, r3	; 0x01
     fde:	53 82       	std	Z+3, r5	; 0x03
     fe0:	42 82       	std	Z+2, r4	; 0x02
     fe2:	0e 94 c2 27 	call	0x4f84	; 0x4f84 <rprintf1RamRom>
		rprintfFloat(5, cmd_angle);
     fe6:	0f 90       	pop	r0
     fe8:	0f 90       	pop	r0
     fea:	0f 90       	pop	r0
     fec:	40 91 e4 02 	lds	r20, 0x02E4
     ff0:	50 91 e5 02 	lds	r21, 0x02E5
     ff4:	60 91 e6 02 	lds	r22, 0x02E6
     ff8:	70 91 e7 02 	lds	r23, 0x02E7
     ffc:	85 e0       	ldi	r24, 0x05	; 5
     ffe:	0e 94 f9 26 	call	0x4df2	; 0x4df2 <rprintfFloat>
		rprintfCRLF();
    1002:	0e 94 02 26 	call	0x4c04	; 0x4c04 <rprintfCRLF>
		vTaskDelayUntil(&xLastWakeTime, xTicksToWait);
    1006:	c4 01       	movw	r24, r8
    1008:	60 e1       	ldi	r22, 0x10	; 16
    100a:	77 e2       	ldi	r23, 0x27	; 39
    100c:	0e 94 b8 13 	call	0x2770	; 0x2770 <vTaskDelayUntil>
		cmd_angle = 90*(M_PI/180);
    1010:	e0 92 e4 02 	sts	0x02E4, r14
    1014:	f0 92 e5 02 	sts	0x02E5, r15
    1018:	00 93 e6 02 	sts	0x02E6, r16
    101c:	10 93 e7 02 	sts	0x02E7, r17
		rprintf("cmd_angle: ");
    1020:	00 d0       	rcall	.+0      	; 0x1022 <vScript+0xca>
    1022:	0f 92       	push	r0
    1024:	ed b7       	in	r30, 0x3d	; 61
    1026:	fe b7       	in	r31, 0x3e	; 62
    1028:	31 82       	std	Z+1, r3	; 0x01
    102a:	73 82       	std	Z+3, r7	; 0x03
    102c:	62 82       	std	Z+2, r6	; 0x02
    102e:	0e 94 c2 27 	call	0x4f84	; 0x4f84 <rprintf1RamRom>
		rprintfFloat(5, cmd_angle);
    1032:	0f 90       	pop	r0
    1034:	0f 90       	pop	r0
    1036:	0f 90       	pop	r0
    1038:	40 91 e4 02 	lds	r20, 0x02E4
    103c:	50 91 e5 02 	lds	r21, 0x02E5
    1040:	60 91 e6 02 	lds	r22, 0x02E6
    1044:	70 91 e7 02 	lds	r23, 0x02E7
    1048:	85 e0       	ldi	r24, 0x05	; 5
    104a:	0e 94 f9 26 	call	0x4df2	; 0x4df2 <rprintfFloat>
		rprintfCRLF();
    104e:	0e 94 02 26 	call	0x4c04	; 0x4c04 <rprintfCRLF>
		vTaskDelayUntil(&xLastWakeTime, xTicksToWait);
    1052:	c4 01       	movw	r24, r8
    1054:	60 e1       	ldi	r22, 0x10	; 16
    1056:	77 e2       	ldi	r23, 0x27	; 39
    1058:	0e 94 b8 13 	call	0x2770	; 0x2770 <vTaskDelayUntil>
    105c:	b3 cf       	rjmp	.-154    	; 0xfc4 <vScript+0x6c>

0000105e <vLight1On>:
		PORT_OFF(PORTA, 0);
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
		
	}
}
void vLight1On(void *pvParameters){
    105e:	0f 93       	push	r16
    1060:	1f 93       	push	r17
    1062:	df 93       	push	r29
    1064:	cf 93       	push	r28
    1066:	00 d0       	rcall	.+0      	; 0x1068 <vLight1On+0xa>
    1068:	cd b7       	in	r28, 0x3d	; 61
    106a:	de b7       	in	r29, 0x3e	; 62
	portTickType xLastWakeTime;
	for(;;){
		LED_on();
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
    106c:	8e 01       	movw	r16, r28
    106e:	0f 5f       	subi	r16, 0xFF	; 255
    1070:	1f 4f       	sbci	r17, 0xFF	; 255
//***************STATUS LED**************
//tank test
void LED_off(void)
	{PORT_ON(PORTB,6);}
void LED_on(void)
	{PORT_OFF(PORTB,6);}
    1072:	2e 98       	cbi	0x05, 6	; 5
    1074:	c8 01       	movw	r24, r16
    1076:	62 e3       	ldi	r22, 0x32	; 50
    1078:	70 e0       	ldi	r23, 0x00	; 0
    107a:	0e 94 b8 13 	call	0x2770	; 0x2770 <vTaskDelayUntil>


//***************STATUS LED**************
//tank test
void LED_off(void)
	{PORT_ON(PORTB,6);}
    107e:	2e 9a       	sbi	0x05, 6	; 5
		LED_off();
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));	}
    1080:	c8 01       	movw	r24, r16
    1082:	62 e3       	ldi	r22, 0x32	; 50
    1084:	70 e0       	ldi	r23, 0x00	; 0
    1086:	0e 94 b8 13 	call	0x2770	; 0x2770 <vTaskDelayUntil>
    108a:	f3 cf       	rjmp	.-26     	; 0x1072 <vLight1On+0x14>

0000108c <vLight0On>:
		vTaskDelayUntil(&xLastWakeTime, (1 / portTICK_RATE_MS));
	}

}

void vLight0On(void *pvParameters){
    108c:	0f 93       	push	r16
    108e:	1f 93       	push	r17
    1090:	df 93       	push	r29
    1092:	cf 93       	push	r28
    1094:	00 d0       	rcall	.+0      	; 0x1096 <vLight0On+0xa>
    1096:	cd b7       	in	r28, 0x3d	; 61
    1098:	de b7       	in	r29, 0x3e	; 62
	portTickType xLastWakeTime;
	for(;;){
		PORT_ON(PORTA, 0);
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
    109a:	8e 01       	movw	r16, r28
    109c:	0f 5f       	subi	r16, 0xFF	; 255
    109e:	1f 4f       	sbci	r17, 0xFF	; 255
}

void vLight0On(void *pvParameters){
	portTickType xLastWakeTime;
	for(;;){
		PORT_ON(PORTA, 0);
    10a0:	10 9a       	sbi	0x02, 0	; 2
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
    10a2:	c8 01       	movw	r24, r16
    10a4:	62 e3       	ldi	r22, 0x32	; 50
    10a6:	70 e0       	ldi	r23, 0x00	; 0
    10a8:	0e 94 b8 13 	call	0x2770	; 0x2770 <vTaskDelayUntil>
		//taskYIELD();	
		PORT_OFF(PORTA, 0);
    10ac:	10 98       	cbi	0x02, 0	; 2
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
    10ae:	c8 01       	movw	r24, r16
    10b0:	62 e3       	ldi	r22, 0x32	; 50
    10b2:	70 e0       	ldi	r23, 0x00	; 0
    10b4:	0e 94 b8 13 	call	0x2770	; 0x2770 <vTaskDelayUntil>
    10b8:	f3 cf       	rjmp	.-26     	; 0x10a0 <vLight0On+0x14>

000010ba <vEnc_UpdatePose>:
	uart3SendByte('\n'); //line feed
}



void vEnc_UpdatePose(){
    10ba:	af 92       	push	r10
    10bc:	bf 92       	push	r11
    10be:	df 92       	push	r13
    10c0:	ef 92       	push	r14
    10c2:	ff 92       	push	r15
    10c4:	0f 93       	push	r16
    10c6:	1f 93       	push	r17
    10c8:	df 93       	push	r29
    10ca:	cf 93       	push	r28
    10cc:	00 d0       	rcall	.+0      	; 0x10ce <vEnc_UpdatePose+0x14>
    10ce:	cd b7       	in	r28, 0x3d	; 61
    10d0:	de b7       	in	r29, 0x3e	; 62
	portTickType xLastWakeTime;
	float elapsed_time;
	reset_timer0();
    10d2:	0e 94 f6 19 	call	0x33ec	; 0x33ec <reset_timer0>
		taskEXIT_CRITICAL();
		*/

		}
		
	vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
    10d6:	5e 01       	movw	r10, r28
    10d8:	08 94       	sec
    10da:	a1 1c       	adc	r10, r1
    10dc:	b1 1c       	adc	r11, r1
	portTickType xLastWakeTime;
	float elapsed_time;
	reset_timer0();

	for(;;){
		if(LEFTVel_ready || RIGHTVel_ready){
    10de:	80 91 c0 02 	lds	r24, 0x02C0
    10e2:	88 23       	and	r24, r24
    10e4:	29 f4       	brne	.+10     	; 0x10f0 <vEnc_UpdatePose+0x36>
    10e6:	80 91 cd 02 	lds	r24, 0x02CD
    10ea:	88 23       	and	r24, r24
    10ec:	09 f4       	brne	.+2      	; 0x10f0 <vEnc_UpdatePose+0x36>
    10ee:	a4 c0       	rjmp	.+328    	; 0x1238 <vEnc_UpdatePose+0x17e>
		//The below formula yields the encoder calculated angular velocity of the robot
		//as it rotates about some ICC(Instantaneous Center of Curvature)
		
		enc_ang_vel = ((-RIGHTVel_current) - LEFTVel_current) / ROBOT_DIAMETER;
    10f0:	60 91 cb 02 	lds	r22, 0x02CB
    10f4:	70 91 cc 02 	lds	r23, 0x02CC
    10f8:	70 95       	com	r23
    10fa:	61 95       	neg	r22
    10fc:	7f 4f       	sbci	r23, 0xFF	; 255
    10fe:	20 91 be 02 	lds	r18, 0x02BE
    1102:	30 91 bf 02 	lds	r19, 0x02BF
    1106:	62 1b       	sub	r22, r18
    1108:	73 0b       	sbc	r23, r19
    110a:	88 27       	eor	r24, r24
    110c:	77 fd       	sbrc	r23, 7
    110e:	80 95       	com	r24
    1110:	98 2f       	mov	r25, r24
    1112:	0e 94 61 2c 	call	0x58c2	; 0x58c2 <__floatsisf>
    1116:	26 e6       	ldi	r18, 0x66	; 102
    1118:	36 e6       	ldi	r19, 0x66	; 102
    111a:	46 e8       	ldi	r20, 0x86	; 134
    111c:	51 e4       	ldi	r21, 0x41	; 65
    111e:	0e 94 c6 2b 	call	0x578c	; 0x578c <__divsf3>
    1122:	60 93 dc 02 	sts	0x02DC, r22
    1126:	70 93 dd 02 	sts	0x02DD, r23
    112a:	80 93 de 02 	sts	0x02DE, r24
    112e:	90 93 df 02 	sts	0x02DF, r25
		
		//elapsed_time = ((get_timer0_overflow()*255 + TCNT0) * 0.256) / 1000;
		elapsed_time = ((get_timer0_overflow()*255 + TCNT0) * 0.0633) / 1000;
    1132:	0e 94 97 19 	call	0x332e	; 0x332e <get_timer0_overflow>
    1136:	7b 01       	movw	r14, r22
    1138:	8c 01       	movw	r16, r24
    113a:	d6 b4       	in	r13, 0x26	; 38
		reset_timer0();
    113c:	0e 94 f6 19 	call	0x33ec	; 0x33ec <reset_timer0>
		//dRL = dRIGHTDis - dLEFTDis;
		//dis_enc_heading += sin((dRL)/ ROBOT_DIAMETER);
		//dRIGHTDis = dLEFTDis = 0;
		enc_heading += enc_ang_vel * elapsed_time;
    1140:	c8 01       	movw	r24, r16
    1142:	b7 01       	movw	r22, r14
    1144:	2f ef       	ldi	r18, 0xFF	; 255
    1146:	30 e0       	ldi	r19, 0x00	; 0
    1148:	40 e0       	ldi	r20, 0x00	; 0
    114a:	50 e0       	ldi	r21, 0x00	; 0
    114c:	0e 94 fc 2d 	call	0x5bf8	; 0x5bf8 <__mulsi3>
    1150:	6d 0d       	add	r22, r13
    1152:	71 1d       	adc	r23, r1
    1154:	81 1d       	adc	r24, r1
    1156:	91 1d       	adc	r25, r1
    1158:	0e 94 5f 2c 	call	0x58be	; 0x58be <__floatunsisf>
    115c:	2e e6       	ldi	r18, 0x6E	; 110
    115e:	33 ea       	ldi	r19, 0xA3	; 163
    1160:	41 e8       	ldi	r20, 0x81	; 129
    1162:	5d e3       	ldi	r21, 0x3D	; 61
    1164:	0e 94 96 2d 	call	0x5b2c	; 0x5b2c <__mulsf3>
    1168:	20 e0       	ldi	r18, 0x00	; 0
    116a:	30 e0       	ldi	r19, 0x00	; 0
    116c:	4a e7       	ldi	r20, 0x7A	; 122
    116e:	54 e4       	ldi	r21, 0x44	; 68
    1170:	0e 94 c6 2b 	call	0x578c	; 0x578c <__divsf3>
    1174:	20 91 dc 02 	lds	r18, 0x02DC
    1178:	30 91 dd 02 	lds	r19, 0x02DD
    117c:	40 91 de 02 	lds	r20, 0x02DE
    1180:	50 91 df 02 	lds	r21, 0x02DF
    1184:	0e 94 96 2d 	call	0x5b2c	; 0x5b2c <__mulsf3>
    1188:	20 91 d8 02 	lds	r18, 0x02D8
    118c:	30 91 d9 02 	lds	r19, 0x02D9
    1190:	40 91 da 02 	lds	r20, 0x02DA
    1194:	50 91 db 02 	lds	r21, 0x02DB
    1198:	0e 94 fc 2a 	call	0x55f8	; 0x55f8 <__addsf3>
    119c:	7b 01       	movw	r14, r22
    119e:	8c 01       	movw	r16, r24
		// Limit the heading to 2pi
		enc_heading -= 2*M_PI*(1 + floor((enc_heading-M_PI)/(2*M_PI)));
    11a0:	2b ed       	ldi	r18, 0xDB	; 219
    11a2:	3f e0       	ldi	r19, 0x0F	; 15
    11a4:	49 e4       	ldi	r20, 0x49	; 73
    11a6:	50 e4       	ldi	r21, 0x40	; 64
    11a8:	0e 94 fb 2a 	call	0x55f6	; 0x55f6 <__subsf3>
    11ac:	2b ed       	ldi	r18, 0xDB	; 219
    11ae:	3f e0       	ldi	r19, 0x0F	; 15
    11b0:	49 ec       	ldi	r20, 0xC9	; 201
    11b2:	50 e4       	ldi	r21, 0x40	; 64
    11b4:	0e 94 c6 2b 	call	0x578c	; 0x578c <__divsf3>
    11b8:	0e 94 9c 2c 	call	0x5938	; 0x5938 <floor>
    11bc:	20 e0       	ldi	r18, 0x00	; 0
    11be:	30 e0       	ldi	r19, 0x00	; 0
    11c0:	40 e8       	ldi	r20, 0x80	; 128
    11c2:	5f e3       	ldi	r21, 0x3F	; 63
    11c4:	0e 94 fc 2a 	call	0x55f8	; 0x55f8 <__addsf3>
    11c8:	2b ed       	ldi	r18, 0xDB	; 219
    11ca:	3f e0       	ldi	r19, 0x0F	; 15
    11cc:	49 ec       	ldi	r20, 0xC9	; 201
    11ce:	50 ec       	ldi	r21, 0xC0	; 192
    11d0:	0e 94 96 2d 	call	0x5b2c	; 0x5b2c <__mulsf3>
    11d4:	9b 01       	movw	r18, r22
    11d6:	ac 01       	movw	r20, r24
    11d8:	c8 01       	movw	r24, r16
    11da:	b7 01       	movw	r22, r14
    11dc:	0e 94 fc 2a 	call	0x55f8	; 0x55f8 <__addsf3>
    11e0:	60 93 d8 02 	sts	0x02D8, r22
    11e4:	70 93 d9 02 	sts	0x02D9, r23
    11e8:	80 93 da 02 	sts	0x02DA, r24
    11ec:	90 93 db 02 	sts	0x02DB, r25
		//cmd_ang_vel = 3*pow(cmd_angle - enc_heading,2)/(pow(cmd_angle - enc_heading,2) + pow(3,2));
		cmd_ang_vel = -0.5*atan2(1*(enc_heading - cmd_angle) +0,1);
    11f0:	20 91 e4 02 	lds	r18, 0x02E4
    11f4:	30 91 e5 02 	lds	r19, 0x02E5
    11f8:	40 91 e6 02 	lds	r20, 0x02E6
    11fc:	50 91 e7 02 	lds	r21, 0x02E7
    1200:	0e 94 fb 2a 	call	0x55f6	; 0x55f6 <__subsf3>
    1204:	20 e0       	ldi	r18, 0x00	; 0
    1206:	30 e0       	ldi	r19, 0x00	; 0
    1208:	40 e0       	ldi	r20, 0x00	; 0
    120a:	50 e0       	ldi	r21, 0x00	; 0
    120c:	0e 94 fc 2a 	call	0x55f8	; 0x55f8 <__addsf3>
    1210:	20 e0       	ldi	r18, 0x00	; 0
    1212:	30 e0       	ldi	r19, 0x00	; 0
    1214:	40 e8       	ldi	r20, 0x80	; 128
    1216:	5f e3       	ldi	r21, 0x3F	; 63
    1218:	0e 94 6f 2b 	call	0x56de	; 0x56de <atan2>
    121c:	20 e0       	ldi	r18, 0x00	; 0
    121e:	30 e0       	ldi	r19, 0x00	; 0
    1220:	40 e0       	ldi	r20, 0x00	; 0
    1222:	5f eb       	ldi	r21, 0xBF	; 191
    1224:	0e 94 96 2d 	call	0x5b2c	; 0x5b2c <__mulsf3>
    1228:	60 93 e8 02 	sts	0x02E8, r22
    122c:	70 93 e9 02 	sts	0x02E9, r23
    1230:	80 93 ea 02 	sts	0x02EA, r24
    1234:	90 93 eb 02 	sts	0x02EB, r25
		taskEXIT_CRITICAL();
		*/

		}
		
	vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
    1238:	c5 01       	movw	r24, r10
    123a:	62 e3       	ldi	r22, 0x32	; 50
    123c:	70 e0       	ldi	r23, 0x00	; 0
    123e:	0e 94 b8 13 	call	0x2770	; 0x2770 <vTaskDelayUntil>
    1242:	4d cf       	rjmp	.-358    	; 0x10de <vEnc_UpdatePose+0x24>

00001244 <send_frame>:
	}
	return c;
}


void send_frame(char flag, int16_t data){
    1244:	ff 92       	push	r15
    1246:	0f 93       	push	r16
    1248:	1f 93       	push	r17
    124a:	cf 93       	push	r28
    124c:	df 93       	push	r29
    124e:	eb 01       	movw	r28, r22
	uint8_t r1 = 0;
	uint8_t r2 = 0;
	uint8_t r3 = 0;
	uint8_t r4 = 0;

	uart3SendByte(flag);
    1250:	0e 94 b7 20 	call	0x416e	; 0x416e <uart3SendByte>

	r1 = num2char(0x0F & (uint8_t)data);
    1254:	3f e0       	ldi	r19, 0x0F	; 15
    1256:	f3 2e       	mov	r15, r19
    1258:	fc 22       	and	r15, r28



char num2char(char c){
	
	if(c <10){
    125a:	89 e0       	ldi	r24, 0x09	; 9
    125c:	8f 15       	cp	r24, r15
    125e:	18 f0       	brcs	.+6      	; 0x1266 <send_frame+0x22>
		c += 48;
    1260:	90 e3       	ldi	r25, 0x30	; 48
    1262:	f9 0e       	add	r15, r25
    1264:	06 c0       	rjmp	.+12     	; 0x1272 <send_frame+0x2e>
	}
	else if((c >= 10) && (c <= 16)){
    1266:	8f 2d       	mov	r24, r15
    1268:	8a 50       	subi	r24, 0x0A	; 10
    126a:	87 30       	cpi	r24, 0x07	; 7
    126c:	10 f4       	brcc	.+4      	; 0x1272 <send_frame+0x2e>
		c += 55;
    126e:	87 e3       	ldi	r24, 0x37	; 55
    1270:	f8 0e       	add	r15, r24
	uint8_t r4 = 0;

	uart3SendByte(flag);

	r1 = num2char(0x0F & (uint8_t)data);
	r2 = num2char(0x0F & ((uint8_t)(data >> 4)) );
    1272:	ce 01       	movw	r24, r28
    1274:	24 e0       	ldi	r18, 0x04	; 4
    1276:	95 95       	asr	r25
    1278:	87 95       	ror	r24
    127a:	2a 95       	dec	r18
    127c:	e1 f7       	brne	.-8      	; 0x1276 <send_frame+0x32>
    127e:	08 2f       	mov	r16, r24
    1280:	0f 70       	andi	r16, 0x0F	; 15



char num2char(char c){
	
	if(c <10){
    1282:	0a 30       	cpi	r16, 0x0A	; 10
    1284:	10 f4       	brcc	.+4      	; 0x128a <send_frame+0x46>
		c += 48;
    1286:	00 5d       	subi	r16, 0xD0	; 208
    1288:	05 c0       	rjmp	.+10     	; 0x1294 <send_frame+0x50>
	}
	else if((c >= 10) && (c <= 16)){
    128a:	80 2f       	mov	r24, r16
    128c:	8a 50       	subi	r24, 0x0A	; 10
    128e:	87 30       	cpi	r24, 0x07	; 7
    1290:	08 f4       	brcc	.+2      	; 0x1294 <send_frame+0x50>
		c += 55;
    1292:	09 5c       	subi	r16, 0xC9	; 201

	uart3SendByte(flag);

	r1 = num2char(0x0F & (uint8_t)data);
	r2 = num2char(0x0F & ((uint8_t)(data >> 4)) );
	r3 = num2char(0x0F & ((uint8_t)(data >> 8)) );
    1294:	8d 2f       	mov	r24, r29
    1296:	99 27       	eor	r25, r25
    1298:	87 fd       	sbrc	r24, 7
    129a:	9a 95       	dec	r25
    129c:	18 2f       	mov	r17, r24
    129e:	1f 70       	andi	r17, 0x0F	; 15



char num2char(char c){
	
	if(c <10){
    12a0:	1a 30       	cpi	r17, 0x0A	; 10
    12a2:	10 f4       	brcc	.+4      	; 0x12a8 <send_frame+0x64>
		c += 48;
    12a4:	10 5d       	subi	r17, 0xD0	; 208
    12a6:	05 c0       	rjmp	.+10     	; 0x12b2 <send_frame+0x6e>
	}
	else if((c >= 10) && (c <= 16)){
    12a8:	81 2f       	mov	r24, r17
    12aa:	8a 50       	subi	r24, 0x0A	; 10
    12ac:	87 30       	cpi	r24, 0x07	; 7
    12ae:	08 f4       	brcc	.+2      	; 0x12b2 <send_frame+0x6e>
		c += 55;
    12b0:	19 5c       	subi	r17, 0xC9	; 201
	uart3SendByte(flag);

	r1 = num2char(0x0F & (uint8_t)data);
	r2 = num2char(0x0F & ((uint8_t)(data >> 4)) );
	r3 = num2char(0x0F & ((uint8_t)(data >> 8)) );
	r4 = num2char(0x0F & ((uint8_t)(data >> 12)) );
    12b2:	c0 e1       	ldi	r28, 0x10	; 16
    12b4:	dc 02       	muls	r29, r28
    12b6:	c1 2d       	mov	r28, r1
    12b8:	dd 0b       	sbc	r29, r29
    12ba:	11 24       	eor	r1, r1
    12bc:	ce 01       	movw	r24, r28
    12be:	8f 70       	andi	r24, 0x0F	; 15
    12c0:	68 2f       	mov	r22, r24



char num2char(char c){
	
	if(c <10){
    12c2:	8a 30       	cpi	r24, 0x0A	; 10
    12c4:	10 f4       	brcc	.+4      	; 0x12ca <send_frame+0x86>
		c += 48;
    12c6:	60 5d       	subi	r22, 0xD0	; 208
    12c8:	04 c0       	rjmp	.+8      	; 0x12d2 <send_frame+0x8e>
	}
	else if((c >= 10) && (c <= 16)){
    12ca:	8a 50       	subi	r24, 0x0A	; 10
    12cc:	87 30       	cpi	r24, 0x07	; 7
    12ce:	08 f4       	brcc	.+2      	; 0x12d2 <send_frame+0x8e>
		c += 55;
    12d0:	69 5c       	subi	r22, 0xC9	; 201
	r1 = num2char(0x0F & (uint8_t)data);
	r2 = num2char(0x0F & ((uint8_t)(data >> 4)) );
	r3 = num2char(0x0F & ((uint8_t)(data >> 8)) );
	r4 = num2char(0x0F & ((uint8_t)(data >> 12)) );

	uart3SendByte(r4);
    12d2:	86 2f       	mov	r24, r22
    12d4:	0e 94 b7 20 	call	0x416e	; 0x416e <uart3SendByte>
	uart3SendByte(r3);
    12d8:	81 2f       	mov	r24, r17
    12da:	0e 94 b7 20 	call	0x416e	; 0x416e <uart3SendByte>
	uart3SendByte(r2);
    12de:	80 2f       	mov	r24, r16
    12e0:	0e 94 b7 20 	call	0x416e	; 0x416e <uart3SendByte>
	uart3SendByte(r1);
    12e4:	8f 2d       	mov	r24, r15
    12e6:	0e 94 b7 20 	call	0x416e	; 0x416e <uart3SendByte>
	uart3SendByte('\n'); //line feed
    12ea:	8a e0       	ldi	r24, 0x0A	; 10
    12ec:	0e 94 b7 20 	call	0x416e	; 0x416e <uart3SendByte>
}
    12f0:	df 91       	pop	r29
    12f2:	cf 91       	pop	r28
    12f4:	1f 91       	pop	r17
    12f6:	0f 91       	pop	r16
    12f8:	ff 90       	pop	r15
    12fa:	08 95       	ret

000012fc <vServoOsc>:
	}

}


void vServoOsc(){
    12fc:	7f 92       	push	r7
    12fe:	8f 92       	push	r8
    1300:	9f 92       	push	r9
    1302:	af 92       	push	r10
    1304:	bf 92       	push	r11
    1306:	cf 92       	push	r12
    1308:	df 92       	push	r13
    130a:	ef 92       	push	r14
    130c:	ff 92       	push	r15
    130e:	0f 93       	push	r16
    1310:	1f 93       	push	r17
    1312:	df 93       	push	r29
    1314:	cf 93       	push	r28
    1316:	00 d0       	rcall	.+0      	; 0x1318 <vServoOsc+0x1c>
    1318:	cd b7       	in	r28, 0x3d	; 61
    131a:	de b7       	in	r29, 0x3e	; 62
	sbi(TCCR4A,COM4A1);
	cbi(TCCR4A,COM4A0);
}
void PWM_timer4_On_H4(void)
{
	sbi(TCCR4A,COM4B1);
    131c:	80 91 a0 00 	lds	r24, 0x00A0
    1320:	80 62       	ori	r24, 0x20	; 32
    1322:	80 93 a0 00 	sts	0x00A0, r24
	cbi(TCCR4A,COM4B0);
    1326:	80 91 a0 00 	lds	r24, 0x00A0
    132a:	8f 7e       	andi	r24, 0xEF	; 239
    132c:	80 93 a0 00 	sts	0x00A0, r24
	sbi(TCCR3A,COM3C1);
	cbi(TCCR3A,COM3C0);
}
void PWM_timer4_On_H3(void)
{
	sbi(TCCR4A,COM4A1);
    1330:	80 91 a0 00 	lds	r24, 0x00A0
    1334:	80 68       	ori	r24, 0x80	; 128
    1336:	80 93 a0 00 	sts	0x00A0, r24
	cbi(TCCR4A,COM4A0);
    133a:	80 91 a0 00 	lds	r24, 0x00A0
    133e:	8f 7b       	andi	r24, 0xBF	; 191
    1340:	80 93 a0 00 	sts	0x00A0, r24
    1344:	0a e7       	ldi	r16, 0x7A	; 122
    1346:	10 e0       	ldi	r17, 0x00	; 0
void PWM_timer3_Set_E5(u16 pwmDuty)
	{OCR3C = pwmDuty;}
void PWM_timer4_Set_H3(u16 pwmDuty)
	{OCR4A = pwmDuty;}
void PWM_timer4_Set_H4(u16 pwmDuty)
	{OCR4B = pwmDuty;}
    1348:	6c ec       	ldi	r22, 0xCC	; 204
    134a:	86 2e       	mov	r8, r22
    134c:	91 2c       	mov	r9, r1
		taskENTER_CRITICAL();
	//	PWM_timer3_Set_E3(i);	//right
		PWM_timer4_Set_H3(h3duty);	//left sprayer //originally 204
		PWM_timer4_Set_H4(204);	//right sprayer
		taskEXIT_CRITICAL();
		vTaskDelayUntil(&xLastWakeTime, (spray_time / portTICK_RATE_MS));
    134e:	5e 01       	movw	r10, r28
    1350:	08 94       	sec
    1352:	a1 1c       	adc	r10, r1
    1354:	b1 1c       	adc	r11, r1
		PWM_timer4_Set_H4(135);	
		taskEXIT_CRITICAL();
		vTaskDelayUntil(&xLastWakeTime, (spray_time / portTICK_RATE_MS));
		*/

		rprintf("%d", h3duty);
    1356:	77 24       	eor	r7, r7
    1358:	73 94       	inc	r7
    135a:	5f e4       	ldi	r21, 0x4F	; 79
    135c:	c5 2e       	mov	r12, r21
    135e:	51 e0       	ldi	r21, 0x01	; 1
    1360:	d5 2e       	mov	r13, r21
		//rprintf(",");
		//rprintfNum(10, 5, 1, ' ', LEFTVel_current);
		rprintf("\n");
    1362:	4d e4       	ldi	r20, 0x4D	; 77
    1364:	e4 2e       	mov	r14, r20
    1366:	41 e0       	ldi	r20, 0x01	; 1
    1368:	f4 2e       	mov	r15, r20
	spray_R_on();
	spray_L_on();
	uint16_t h3duty = 122;

	for(;;){
		if(h3duty > 1023){ h3duty = 0;}
    136a:	84 e0       	ldi	r24, 0x04	; 4
    136c:	00 30       	cpi	r16, 0x00	; 0
    136e:	18 07       	cpc	r17, r24
    1370:	10 f0       	brcs	.+4      	; 0x1376 <vServoOsc+0x7a>
    1372:	00 e0       	ldi	r16, 0x00	; 0
    1374:	10 e0       	ldi	r17, 0x00	; 0
		taskENTER_CRITICAL();
    1376:	0f b6       	in	r0, 0x3f	; 63
    1378:	f8 94       	cli
    137a:	0f 92       	push	r0
void PWM_timer3_Set_E4(u16 pwmDuty)
	{OCR3B = pwmDuty;}
void PWM_timer3_Set_E5(u16 pwmDuty)
	{OCR3C = pwmDuty;}
void PWM_timer4_Set_H3(u16 pwmDuty)
	{OCR4A = pwmDuty;}
    137c:	10 93 a9 00 	sts	0x00A9, r17
    1380:	00 93 a8 00 	sts	0x00A8, r16
void PWM_timer4_Set_H4(u16 pwmDuty)
	{OCR4B = pwmDuty;}
    1384:	90 92 ab 00 	sts	0x00AB, r9
    1388:	80 92 aa 00 	sts	0x00AA, r8
	//	PWM_timer3_Set_E3(i);	//right
		PWM_timer4_Set_H3(h3duty);	//left sprayer //originally 204
		PWM_timer4_Set_H4(204);	//right sprayer
		taskEXIT_CRITICAL();
    138c:	0f 90       	pop	r0
    138e:	0f be       	out	0x3f, r0	; 63
		vTaskDelayUntil(&xLastWakeTime, (spray_time / portTICK_RATE_MS));
    1390:	60 91 b7 02 	lds	r22, 0x02B7
    1394:	70 91 b8 02 	lds	r23, 0x02B8
    1398:	c5 01       	movw	r24, r10
    139a:	0e 94 b8 13 	call	0x2770	; 0x2770 <vTaskDelayUntil>
		adj = uart1GetByte();
    139e:	0e 94 6f 23 	call	0x46de	; 0x46de <uart1GetByte>
		if(adj == 'p'){ h3duty++;;}
    13a2:	80 37       	cpi	r24, 0x70	; 112
    13a4:	19 f4       	brne	.+6      	; 0x13ac <vServoOsc+0xb0>
    13a6:	0f 5f       	subi	r16, 0xFF	; 255
    13a8:	1f 4f       	sbci	r17, 0xFF	; 255
    13aa:	04 c0       	rjmp	.+8      	; 0x13b4 <vServoOsc+0xb8>
		else if(adj == 'l'){ h3duty--;}
    13ac:	8c 36       	cpi	r24, 0x6C	; 108
    13ae:	11 f4       	brne	.+4      	; 0x13b4 <vServoOsc+0xb8>
    13b0:	01 50       	subi	r16, 0x01	; 1
    13b2:	10 40       	sbci	r17, 0x00	; 0
		PWM_timer4_Set_H4(135);	
		taskEXIT_CRITICAL();
		vTaskDelayUntil(&xLastWakeTime, (spray_time / portTICK_RATE_MS));
		*/

		rprintf("%d", h3duty);
    13b4:	00 d0       	rcall	.+0      	; 0x13b6 <vServoOsc+0xba>
    13b6:	00 d0       	rcall	.+0      	; 0x13b8 <vServoOsc+0xbc>
    13b8:	0f 92       	push	r0
    13ba:	ed b7       	in	r30, 0x3d	; 61
    13bc:	fe b7       	in	r31, 0x3e	; 62
    13be:	31 96       	adiw	r30, 0x01	; 1
    13c0:	ad b7       	in	r26, 0x3d	; 61
    13c2:	be b7       	in	r27, 0x3e	; 62
    13c4:	11 96       	adiw	r26, 0x01	; 1
    13c6:	7c 92       	st	X, r7
    13c8:	d2 82       	std	Z+2, r13	; 0x02
    13ca:	c1 82       	std	Z+1, r12	; 0x01
    13cc:	14 83       	std	Z+4, r17	; 0x04
    13ce:	03 83       	std	Z+3, r16	; 0x03
    13d0:	0e 94 c2 27 	call	0x4f84	; 0x4f84 <rprintf1RamRom>
		//rprintf(",");
		//rprintfNum(10, 5, 1, ' ', LEFTVel_current);
		rprintf("\n");
    13d4:	0f 90       	pop	r0
    13d6:	0f 90       	pop	r0
    13d8:	ed b7       	in	r30, 0x3d	; 61
    13da:	fe b7       	in	r31, 0x3e	; 62
    13dc:	71 82       	std	Z+1, r7	; 0x01
    13de:	f3 82       	std	Z+3, r15	; 0x03
    13e0:	e2 82       	std	Z+2, r14	; 0x02
    13e2:	0e 94 c2 27 	call	0x4f84	; 0x4f84 <rprintf1RamRom>
	
		h3duty++;
    13e6:	0f 5f       	subi	r16, 0xFF	; 255
    13e8:	1f 4f       	sbci	r17, 0xFF	; 255
    13ea:	0f 90       	pop	r0
    13ec:	0f 90       	pop	r0
    13ee:	0f 90       	pop	r0
    13f0:	bc cf       	rjmp	.-136    	; 0x136a <vServoOsc+0x6e>

000013f2 <vServoTm>:
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
		LED_off();
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));	}
}

void vServoTm(){
    13f2:	1f 93       	push	r17
    13f4:	cf 93       	push	r28
    13f6:	df 93       	push	r29
	char adj;
	for(;;){
		adj = uart1GetByte();
		if(adj == 'p'){ spray_time++;}
		else if(adj == 'l'){ spray_time--;}
		rprintf("%d\n", spray_time);
    13f8:	11 e0       	ldi	r17, 0x01	; 1
    13fa:	c2 e5       	ldi	r28, 0x52	; 82
    13fc:	d1 e0       	ldi	r29, 0x01	; 1
}

void vServoTm(){
	char adj;
	for(;;){
		adj = uart1GetByte();
    13fe:	0e 94 6f 23 	call	0x46de	; 0x46de <uart1GetByte>
		if(adj == 'p'){ spray_time++;}
    1402:	80 37       	cpi	r24, 0x70	; 112
    1404:	31 f4       	brne	.+12     	; 0x1412 <vServoTm+0x20>
    1406:	80 91 b7 02 	lds	r24, 0x02B7
    140a:	90 91 b8 02 	lds	r25, 0x02B8
    140e:	01 96       	adiw	r24, 0x01	; 1
    1410:	07 c0       	rjmp	.+14     	; 0x1420 <vServoTm+0x2e>
		else if(adj == 'l'){ spray_time--;}
    1412:	8c 36       	cpi	r24, 0x6C	; 108
    1414:	49 f4       	brne	.+18     	; 0x1428 <vServoTm+0x36>
    1416:	80 91 b7 02 	lds	r24, 0x02B7
    141a:	90 91 b8 02 	lds	r25, 0x02B8
    141e:	01 97       	sbiw	r24, 0x01	; 1
    1420:	90 93 b8 02 	sts	0x02B8, r25
    1424:	80 93 b7 02 	sts	0x02B7, r24
		rprintf("%d\n", spray_time);
    1428:	00 d0       	rcall	.+0      	; 0x142a <vServoTm+0x38>
    142a:	00 d0       	rcall	.+0      	; 0x142c <vServoTm+0x3a>
    142c:	0f 92       	push	r0
    142e:	ed b7       	in	r30, 0x3d	; 61
    1430:	fe b7       	in	r31, 0x3e	; 62
    1432:	31 96       	adiw	r30, 0x01	; 1
    1434:	ad b7       	in	r26, 0x3d	; 61
    1436:	be b7       	in	r27, 0x3e	; 62
    1438:	11 96       	adiw	r26, 0x01	; 1
    143a:	1c 93       	st	X, r17
    143c:	d2 83       	std	Z+2, r29	; 0x02
    143e:	c1 83       	std	Z+1, r28	; 0x01
    1440:	80 91 b7 02 	lds	r24, 0x02B7
    1444:	90 91 b8 02 	lds	r25, 0x02B8
    1448:	94 83       	std	Z+4, r25	; 0x04
    144a:	83 83       	std	Z+3, r24	; 0x03
    144c:	0e 94 c2 27 	call	0x4f84	; 0x4f84 <rprintf1RamRom>
    1450:	0f 90       	pop	r0
    1452:	0f 90       	pop	r0
    1454:	0f 90       	pop	r0
    1456:	0f 90       	pop	r0
    1458:	0f 90       	pop	r0
    145a:	d1 cf       	rjmp	.-94     	; 0x13fe <vServoTm+0xc>

0000145c <vPID>:


}


void vPID(void* pvParameters){
    145c:	2f 92       	push	r2
    145e:	3f 92       	push	r3
    1460:	4f 92       	push	r4
    1462:	5f 92       	push	r5
    1464:	6f 92       	push	r6
    1466:	7f 92       	push	r7
    1468:	8f 92       	push	r8
    146a:	9f 92       	push	r9
    146c:	af 92       	push	r10
    146e:	bf 92       	push	r11
    1470:	cf 92       	push	r12
    1472:	df 92       	push	r13
    1474:	ef 92       	push	r14
    1476:	ff 92       	push	r15
    1478:	0f 93       	push	r16
    147a:	1f 93       	push	r17
    147c:	df 93       	push	r29
    147e:	cf 93       	push	r28
    1480:	cd b7       	in	r28, 0x3d	; 61
    1482:	de b7       	in	r29, 0x3e	; 62
    1484:	62 97       	sbiw	r28, 0x12	; 18
    1486:	0f b6       	in	r0, 0x3f	; 63
    1488:	f8 94       	cli
    148a:	de bf       	out	0x3e, r29	; 62
    148c:	0f be       	out	0x3f, r0	; 63
    148e:	cd bf       	out	0x3d, r28	; 61
	sbi(TCCR3A,COM3A1);
	cbi(TCCR3A,COM3A0);
}
void PWM_timer3_On_E4(void)
{
	sbi(TCCR3A,COM3B1);
    1490:	80 91 90 00 	lds	r24, 0x0090
    1494:	80 62       	ori	r24, 0x20	; 32
    1496:	80 93 90 00 	sts	0x0090, r24
	cbi(TCCR3A,COM3B0);
    149a:	80 91 90 00 	lds	r24, 0x0090
    149e:	8f 7e       	andi	r24, 0xEF	; 239
    14a0:	80 93 90 00 	sts	0x0090, r24
	sbi(TCCR2A,COM2B1);
	cbi(TCCR2A,COM2B0);
}
void PWM_timer3_On_E3(void)
{
	sbi(TCCR3A,COM3A1);
    14a4:	80 91 90 00 	lds	r24, 0x0090
    14a8:	80 68       	ori	r24, 0x80	; 128
    14aa:	80 93 90 00 	sts	0x0090, r24
	cbi(TCCR3A,COM3A0);
    14ae:	80 91 90 00 	lds	r24, 0x0090
    14b2:	8f 7b       	andi	r24, 0xBF	; 191
    14b4:	80 93 90 00 	sts	0x0090, r24
	float dt = 0;
	
	wheel_L_on();
	wheel_R_on();

	reset_timer2();
    14b8:	0e 94 0d 1a 	call	0x341a	; 0x341a <reset_timer2>
    14bc:	80 e0       	ldi	r24, 0x00	; 0
    14be:	90 e0       	ldi	r25, 0x00	; 0
    14c0:	a0 e0       	ldi	r26, 0x00	; 0
    14c2:	b0 e0       	ldi	r27, 0x00	; 0
    14c4:	8f 87       	std	Y+15, r24	; 0x0f
    14c6:	98 8b       	std	Y+16, r25	; 0x10
    14c8:	a9 8b       	std	Y+17, r26	; 0x11
    14ca:	ba 8b       	std	Y+18, r27	; 0x12
    14cc:	8f 83       	std	Y+7, r24	; 0x07
    14ce:	98 87       	std	Y+8, r25	; 0x08
    14d0:	a9 87       	std	Y+9, r26	; 0x09
    14d2:	ba 87       	std	Y+10, r27	; 0x0a
			v_left = (signed int)(v_command - cmd_ang_vel*ROBOT_RADIUS);
			v_right = (signed int)(v_command + cmd_ang_vel*ROBOT_RADIUS);
		}
	*/
	
		v_left = (v_command - cmd_ang_vel*ROBOT_RADIUS);
    14d4:	a0 90 e0 02 	lds	r10, 0x02E0
    14d8:	b0 90 e1 02 	lds	r11, 0x02E1
    14dc:	c0 90 e2 02 	lds	r12, 0x02E2
    14e0:	d0 90 e3 02 	lds	r13, 0x02E3
    14e4:	e0 90 e8 02 	lds	r14, 0x02E8
    14e8:	f0 90 e9 02 	lds	r15, 0x02E9
    14ec:	00 91 ea 02 	lds	r16, 0x02EA
    14f0:	10 91 eb 02 	lds	r17, 0x02EB
    14f4:	c8 01       	movw	r24, r16
    14f6:	b7 01       	movw	r22, r14
    14f8:	23 e3       	ldi	r18, 0x33	; 51
    14fa:	33 e3       	ldi	r19, 0x33	; 51
    14fc:	43 e0       	ldi	r20, 0x03	; 3
    14fe:	51 ec       	ldi	r21, 0xC1	; 193
    1500:	0e 94 96 2d 	call	0x5b2c	; 0x5b2c <__mulsf3>
    1504:	9b 01       	movw	r18, r22
    1506:	ac 01       	movw	r20, r24
    1508:	c6 01       	movw	r24, r12
    150a:	b5 01       	movw	r22, r10
    150c:	0e 94 fc 2a 	call	0x55f8	; 0x55f8 <__addsf3>
    1510:	1b 01       	movw	r2, r22
    1512:	2c 01       	movw	r4, r24
		v_right = (v_command + cmd_ang_vel*ROBOT_RADIUS);
    1514:	c8 01       	movw	r24, r16
    1516:	b7 01       	movw	r22, r14
    1518:	23 e3       	ldi	r18, 0x33	; 51
    151a:	33 e3       	ldi	r19, 0x33	; 51
    151c:	43 e0       	ldi	r20, 0x03	; 3
    151e:	51 e4       	ldi	r21, 0x41	; 65
    1520:	0e 94 96 2d 	call	0x5b2c	; 0x5b2c <__mulsf3>
    1524:	9b 01       	movw	r18, r22
    1526:	ac 01       	movw	r20, r24
    1528:	c6 01       	movw	r24, r12
    152a:	b5 01       	movw	r22, r10
    152c:	0e 94 fc 2a 	call	0x55f8	; 0x55f8 <__addsf3>
    1530:	6b 83       	std	Y+3, r22	; 0x03
    1532:	7c 83       	std	Y+4, r23	; 0x04
    1534:	8d 83       	std	Y+5, r24	; 0x05
    1536:	9e 83       	std	Y+6, r25	; 0x06

		dt = ((get_timer2_overflow()*255 + TCNT2) * 0.0633) / 1000;
    1538:	0e 94 ad 19 	call	0x335a	; 0x335a <get_timer2_overflow>
    153c:	10 91 b2 00 	lds	r17, 0x00B2
    1540:	2f ef       	ldi	r18, 0xFF	; 255
    1542:	30 e0       	ldi	r19, 0x00	; 0
    1544:	40 e0       	ldi	r20, 0x00	; 0
    1546:	50 e0       	ldi	r21, 0x00	; 0
    1548:	0e 94 fc 2d 	call	0x5bf8	; 0x5bf8 <__mulsi3>
    154c:	61 0f       	add	r22, r17
    154e:	71 1d       	adc	r23, r1
    1550:	81 1d       	adc	r24, r1
    1552:	91 1d       	adc	r25, r1
    1554:	0e 94 5f 2c 	call	0x58be	; 0x58be <__floatunsisf>
    1558:	2e e6       	ldi	r18, 0x6E	; 110
    155a:	33 ea       	ldi	r19, 0xA3	; 163
    155c:	41 e8       	ldi	r20, 0x81	; 129
    155e:	5d e3       	ldi	r21, 0x3D	; 61
    1560:	0e 94 96 2d 	call	0x5b2c	; 0x5b2c <__mulsf3>
    1564:	20 e0       	ldi	r18, 0x00	; 0
    1566:	30 e0       	ldi	r19, 0x00	; 0
    1568:	4a e7       	ldi	r20, 0x7A	; 122
    156a:	54 e4       	ldi	r21, 0x44	; 68
    156c:	0e 94 c6 2b 	call	0x578c	; 0x578c <__divsf3>
    1570:	3b 01       	movw	r6, r22
    1572:	4c 01       	movw	r8, r24
		reset_timer2();
    1574:	0e 94 0d 1a 	call	0x341a	; 0x341a <reset_timer2>
	
	// PID

		LEFTVel_ready = RIGHTVel_ready = UNSET;
    1578:	10 92 cd 02 	sts	0x02CD, r1
    157c:	10 92 c0 02 	sts	0x02C0, r1

		error_L = v_left - LEFTVel_current;
    1580:	60 91 be 02 	lds	r22, 0x02BE
    1584:	70 91 bf 02 	lds	r23, 0x02BF
    1588:	88 27       	eor	r24, r24
    158a:	77 fd       	sbrc	r23, 7
    158c:	80 95       	com	r24
    158e:	98 2f       	mov	r25, r24
    1590:	0e 94 61 2c 	call	0x58c2	; 0x58c2 <__floatsisf>
    1594:	9b 01       	movw	r18, r22
    1596:	ac 01       	movw	r20, r24
    1598:	c2 01       	movw	r24, r4
    159a:	b1 01       	movw	r22, r2
    159c:	0e 94 fb 2a 	call	0x55f6	; 0x55f6 <__subsf3>
    15a0:	5b 01       	movw	r10, r22
    15a2:	6c 01       	movw	r12, r24
		error_R = v_right - (-RIGHTVel_current);
    15a4:	60 91 cb 02 	lds	r22, 0x02CB
    15a8:	70 91 cc 02 	lds	r23, 0x02CC
    15ac:	70 95       	com	r23
    15ae:	61 95       	neg	r22
    15b0:	7f 4f       	sbci	r23, 0xFF	; 255
    15b2:	88 27       	eor	r24, r24
    15b4:	77 fd       	sbrc	r23, 7
    15b6:	80 95       	com	r24
    15b8:	98 2f       	mov	r25, r24
    15ba:	0e 94 61 2c 	call	0x58c2	; 0x58c2 <__floatsisf>
    15be:	9b 01       	movw	r18, r22
    15c0:	ac 01       	movw	r20, r24
    15c2:	6b 81       	ldd	r22, Y+3	; 0x03
    15c4:	7c 81       	ldd	r23, Y+4	; 0x04
    15c6:	8d 81       	ldd	r24, Y+5	; 0x05
    15c8:	9e 81       	ldd	r25, Y+6	; 0x06
    15ca:	0e 94 fb 2a 	call	0x55f6	; 0x55f6 <__subsf3>
    15ce:	6b 87       	std	Y+11, r22	; 0x0b
    15d0:	7c 87       	std	Y+12, r23	; 0x0c
    15d2:	8d 87       	std	Y+13, r24	; 0x0d
    15d4:	9e 87       	std	Y+14, r25	; 0x0e
			
		v_out_L = KP_L*error_L + KI_L*acc_error_L + (2/25)*v_left;
    15d6:	c6 01       	movw	r24, r12
    15d8:	b5 01       	movw	r22, r10
    15da:	22 ef       	ldi	r18, 0xF2	; 242
    15dc:	3c e5       	ldi	r19, 0x5C	; 92
    15de:	46 e6       	ldi	r20, 0x66	; 102
    15e0:	5d e3       	ldi	r21, 0x3D	; 61
    15e2:	0e 94 96 2d 	call	0x5b2c	; 0x5b2c <__mulsf3>
    15e6:	7b 01       	movw	r14, r22
    15e8:	8c 01       	movw	r16, r24
    15ea:	6f 85       	ldd	r22, Y+15	; 0x0f
    15ec:	78 89       	ldd	r23, Y+16	; 0x10
    15ee:	89 89       	ldd	r24, Y+17	; 0x11
    15f0:	9a 89       	ldd	r25, Y+18	; 0x12
    15f2:	28 eb       	ldi	r18, 0xB8	; 184
    15f4:	32 e4       	ldi	r19, 0x42	; 66
    15f6:	4f e0       	ldi	r20, 0x0F	; 15
    15f8:	5e e3       	ldi	r21, 0x3E	; 62
    15fa:	0e 94 96 2d 	call	0x5b2c	; 0x5b2c <__mulsf3>
    15fe:	9b 01       	movw	r18, r22
    1600:	ac 01       	movw	r20, r24
    1602:	c8 01       	movw	r24, r16
    1604:	b7 01       	movw	r22, r14
    1606:	0e 94 fc 2a 	call	0x55f8	; 0x55f8 <__addsf3>
    160a:	7b 01       	movw	r14, r22
    160c:	8c 01       	movw	r16, r24
    160e:	c2 01       	movw	r24, r4
    1610:	b1 01       	movw	r22, r2
    1612:	20 e0       	ldi	r18, 0x00	; 0
    1614:	30 e0       	ldi	r19, 0x00	; 0
    1616:	40 e0       	ldi	r20, 0x00	; 0
    1618:	50 e0       	ldi	r21, 0x00	; 0
    161a:	0e 94 96 2d 	call	0x5b2c	; 0x5b2c <__mulsf3>
    161e:	9b 01       	movw	r18, r22
    1620:	ac 01       	movw	r20, r24
    1622:	c8 01       	movw	r24, r16
    1624:	b7 01       	movw	r22, r14
    1626:	0e 94 fc 2a 	call	0x55f8	; 0x55f8 <__addsf3>
    162a:	7b 01       	movw	r14, r22
    162c:	8c 01       	movw	r16, r24
		v_out_R = KP_R*error_R + KI_R*acc_error_R + (2/25)*v_right;
		
		acc_error_L += error_L*dt;
    162e:	c6 01       	movw	r24, r12
    1630:	b5 01       	movw	r22, r10
    1632:	a4 01       	movw	r20, r8
    1634:	93 01       	movw	r18, r6
    1636:	0e 94 96 2d 	call	0x5b2c	; 0x5b2c <__mulsf3>
    163a:	9b 01       	movw	r18, r22
    163c:	ac 01       	movw	r20, r24
    163e:	6f 85       	ldd	r22, Y+15	; 0x0f
    1640:	78 89       	ldd	r23, Y+16	; 0x10
    1642:	89 89       	ldd	r24, Y+17	; 0x11
    1644:	9a 89       	ldd	r25, Y+18	; 0x12
    1646:	0e 94 fc 2a 	call	0x55f8	; 0x55f8 <__addsf3>
    164a:	6f 87       	std	Y+15, r22	; 0x0f
    164c:	78 8b       	std	Y+16, r23	; 0x10
    164e:	89 8b       	std	Y+17, r24	; 0x11
    1650:	9a 8b       	std	Y+18, r25	; 0x12
		acc_error_R += error_R*dt;
    1652:	6b 85       	ldd	r22, Y+11	; 0x0b
    1654:	7c 85       	ldd	r23, Y+12	; 0x0c
    1656:	8d 85       	ldd	r24, Y+13	; 0x0d
    1658:	9e 85       	ldd	r25, Y+14	; 0x0e
    165a:	a4 01       	movw	r20, r8
    165c:	93 01       	movw	r18, r6
    165e:	0e 94 96 2d 	call	0x5b2c	; 0x5b2c <__mulsf3>
    1662:	9b 01       	movw	r18, r22
    1664:	ac 01       	movw	r20, r24
    1666:	6f 81       	ldd	r22, Y+7	; 0x07
    1668:	78 85       	ldd	r23, Y+8	; 0x08
    166a:	89 85       	ldd	r24, Y+9	; 0x09
    166c:	9a 85       	ldd	r25, Y+10	; 0x0a
    166e:	0e 94 fc 2a 	call	0x55f8	; 0x55f8 <__addsf3>
    1672:	a6 2e       	mov	r10, r22
    1674:	67 2e       	mov	r6, r23
    1676:	28 2e       	mov	r2, r24
    1678:	d9 2e       	mov	r13, r25
			rprintfFloat(8,dt);
			rprintfCRLF();
			taskEXIT_CRITICAL();
*/
			
		taskENTER_CRITICAL();
    167a:	0f b6       	in	r0, 0x3f	; 63
    167c:	f8 94       	cli
    167e:	0f 92       	push	r0

/*************************************************/


void wheel_L(float cmd_vel){
		if(cmd_vel > 36){cmd_vel = 36;}
    1680:	c8 01       	movw	r24, r16
    1682:	b7 01       	movw	r22, r14
    1684:	20 e0       	ldi	r18, 0x00	; 0
    1686:	30 e0       	ldi	r19, 0x00	; 0
    1688:	40 e1       	ldi	r20, 0x10	; 16
    168a:	52 e4       	ldi	r21, 0x42	; 66
    168c:	0e 94 8b 2d 	call	0x5b16	; 0x5b16 <__gesf2>
    1690:	18 16       	cp	r1, r24
    1692:	5c f4       	brge	.+22     	; 0x16aa <vPID+0x24e>
    1694:	0f 2e       	mov	r0, r31
    1696:	f0 e0       	ldi	r31, 0x00	; 0
    1698:	ef 2e       	mov	r14, r31
    169a:	f0 e0       	ldi	r31, 0x00	; 0
    169c:	ff 2e       	mov	r15, r31
    169e:	f0 e1       	ldi	r31, 0x10	; 16
    16a0:	0f 2f       	mov	r16, r31
    16a2:	f2 e4       	ldi	r31, 0x42	; 66
    16a4:	1f 2f       	mov	r17, r31
    16a6:	f0 2d       	mov	r31, r0
    16a8:	14 c0       	rjmp	.+40     	; 0x16d2 <vPID+0x276>
		if(cmd_vel < -36){cmd_vel = -36;}
    16aa:	c8 01       	movw	r24, r16
    16ac:	b7 01       	movw	r22, r14
    16ae:	20 e0       	ldi	r18, 0x00	; 0
    16b0:	30 e0       	ldi	r19, 0x00	; 0
    16b2:	40 e1       	ldi	r20, 0x10	; 16
    16b4:	52 ec       	ldi	r21, 0xC2	; 194
    16b6:	0e 94 c2 2b 	call	0x5784	; 0x5784 <__cmpsf2>
    16ba:	88 23       	and	r24, r24
    16bc:	54 f4       	brge	.+20     	; 0x16d2 <vPID+0x276>
    16be:	0f 2e       	mov	r0, r31
    16c0:	f0 e0       	ldi	r31, 0x00	; 0
    16c2:	ef 2e       	mov	r14, r31
    16c4:	f0 e0       	ldi	r31, 0x00	; 0
    16c6:	ff 2e       	mov	r15, r31
    16c8:	f0 e1       	ldi	r31, 0x10	; 16
    16ca:	0f 2f       	mov	r16, r31
    16cc:	f2 ec       	ldi	r31, 0xC2	; 194
    16ce:	1f 2f       	mov	r17, r31
    16d0:	f0 2d       	mov	r31, r0
		
		float s_out = -0.4928 * (cmd_vel) + 185.27;
		
		taskENTER_CRITICAL();
    16d2:	0f b6       	in	r0, 0x3f	; 63
    16d4:	f8 94       	cli
    16d6:	0f 92       	push	r0
		PWM_timer3_Set_E4((int)s_out);
    16d8:	c8 01       	movw	r24, r16
    16da:	b7 01       	movw	r22, r14
    16dc:	28 e4       	ldi	r18, 0x48	; 72
    16de:	30 e5       	ldi	r19, 0x50	; 80
    16e0:	4c ef       	ldi	r20, 0xFC	; 252
    16e2:	5e eb       	ldi	r21, 0xBE	; 190
    16e4:	0e 94 96 2d 	call	0x5b2c	; 0x5b2c <__mulsf3>
    16e8:	2f e1       	ldi	r18, 0x1F	; 31
    16ea:	35 e4       	ldi	r19, 0x45	; 69
    16ec:	49 e3       	ldi	r20, 0x39	; 57
    16ee:	53 e4       	ldi	r21, 0x43	; 67
    16f0:	0e 94 fc 2a 	call	0x55f8	; 0x55f8 <__addsf3>
    16f4:	0e 94 2e 2c 	call	0x585c	; 0x585c <__fixsfsi>
void PWM_timer2_Set_H6(u16 pwmDuty)
	{OCR2B = pwmDuty;}
void PWM_timer3_Set_E3(u16 pwmDuty)
	{OCR3A = pwmDuty;}
void PWM_timer3_Set_E4(u16 pwmDuty)
	{OCR3B = pwmDuty;}
    16f8:	70 93 9b 00 	sts	0x009B, r23
    16fc:	60 93 9a 00 	sts	0x009A, r22
		taskEXIT_CRITICAL();
    1700:	0f 90       	pop	r0
    1702:	0f be       	out	0x3f, r0	; 63
			taskEXIT_CRITICAL();
*/
			
		taskENTER_CRITICAL();
		wheel_L(v_out_L);
		wheel_R(-v_out_R);
    1704:	6b 85       	ldd	r22, Y+11	; 0x0b
    1706:	7c 85       	ldd	r23, Y+12	; 0x0c
    1708:	8d 85       	ldd	r24, Y+13	; 0x0d
    170a:	9e 85       	ldd	r25, Y+14	; 0x0e
    170c:	20 eb       	ldi	r18, 0xB0	; 176
    170e:	34 eb       	ldi	r19, 0xB4	; 180
    1710:	4a e2       	ldi	r20, 0x2A	; 42
    1712:	5d e3       	ldi	r21, 0x3D	; 61
    1714:	0e 94 96 2d 	call	0x5b2c	; 0x5b2c <__mulsf3>
    1718:	7b 01       	movw	r14, r22
    171a:	8c 01       	movw	r16, r24
    171c:	6f 81       	ldd	r22, Y+7	; 0x07
    171e:	78 85       	ldd	r23, Y+8	; 0x08
    1720:	89 85       	ldd	r24, Y+9	; 0x09
    1722:	9a 85       	ldd	r25, Y+10	; 0x0a
    1724:	2c e5       	ldi	r18, 0x5C	; 92
    1726:	36 e5       	ldi	r19, 0x56	; 86
    1728:	40 ea       	ldi	r20, 0xA0	; 160
    172a:	5d e3       	ldi	r21, 0x3D	; 61
    172c:	0e 94 96 2d 	call	0x5b2c	; 0x5b2c <__mulsf3>
    1730:	9b 01       	movw	r18, r22
    1732:	ac 01       	movw	r20, r24
    1734:	c8 01       	movw	r24, r16
    1736:	b7 01       	movw	r22, r14
    1738:	0e 94 fc 2a 	call	0x55f8	; 0x55f8 <__addsf3>
    173c:	7b 01       	movw	r14, r22
    173e:	8c 01       	movw	r16, r24
    1740:	6b 81       	ldd	r22, Y+3	; 0x03
    1742:	7c 81       	ldd	r23, Y+4	; 0x04
    1744:	8d 81       	ldd	r24, Y+5	; 0x05
    1746:	9e 81       	ldd	r25, Y+6	; 0x06
    1748:	20 e0       	ldi	r18, 0x00	; 0
    174a:	30 e0       	ldi	r19, 0x00	; 0
    174c:	40 e0       	ldi	r20, 0x00	; 0
    174e:	50 e0       	ldi	r21, 0x00	; 0
    1750:	0e 94 96 2d 	call	0x5b2c	; 0x5b2c <__mulsf3>
    1754:	9b 01       	movw	r18, r22
    1756:	ac 01       	movw	r20, r24
    1758:	c8 01       	movw	r24, r16
    175a:	b7 01       	movw	r22, r14
    175c:	0e 94 fc 2a 	call	0x55f8	; 0x55f8 <__addsf3>
    1760:	7b 01       	movw	r14, r22
    1762:	8c 01       	movw	r16, r24
    1764:	17 fb       	bst	r17, 7
    1766:	10 95       	com	r17
    1768:	17 f9       	bld	r17, 7
    176a:	10 95       	com	r17


}

void wheel_R(float cmd_vel){
		if(cmd_vel > 36){cmd_vel = 36;}
    176c:	c8 01       	movw	r24, r16
    176e:	b7 01       	movw	r22, r14
    1770:	20 e0       	ldi	r18, 0x00	; 0
    1772:	30 e0       	ldi	r19, 0x00	; 0
    1774:	40 e1       	ldi	r20, 0x10	; 16
    1776:	52 e4       	ldi	r21, 0x42	; 66
    1778:	0e 94 8b 2d 	call	0x5b16	; 0x5b16 <__gesf2>
    177c:	18 16       	cp	r1, r24
    177e:	5c f4       	brge	.+22     	; 0x1796 <vPID+0x33a>
    1780:	0f 2e       	mov	r0, r31
    1782:	f0 e0       	ldi	r31, 0x00	; 0
    1784:	ef 2e       	mov	r14, r31
    1786:	f0 e0       	ldi	r31, 0x00	; 0
    1788:	ff 2e       	mov	r15, r31
    178a:	f0 e1       	ldi	r31, 0x10	; 16
    178c:	0f 2f       	mov	r16, r31
    178e:	f2 e4       	ldi	r31, 0x42	; 66
    1790:	1f 2f       	mov	r17, r31
    1792:	f0 2d       	mov	r31, r0
    1794:	14 c0       	rjmp	.+40     	; 0x17be <vPID+0x362>
		if(cmd_vel < -36){cmd_vel = -36;}
    1796:	c8 01       	movw	r24, r16
    1798:	b7 01       	movw	r22, r14
    179a:	20 e0       	ldi	r18, 0x00	; 0
    179c:	30 e0       	ldi	r19, 0x00	; 0
    179e:	40 e1       	ldi	r20, 0x10	; 16
    17a0:	52 ec       	ldi	r21, 0xC2	; 194
    17a2:	0e 94 c2 2b 	call	0x5784	; 0x5784 <__cmpsf2>
    17a6:	88 23       	and	r24, r24
    17a8:	54 f4       	brge	.+20     	; 0x17be <vPID+0x362>
    17aa:	0f 2e       	mov	r0, r31
    17ac:	f0 e0       	ldi	r31, 0x00	; 0
    17ae:	ef 2e       	mov	r14, r31
    17b0:	f0 e0       	ldi	r31, 0x00	; 0
    17b2:	ff 2e       	mov	r15, r31
    17b4:	f0 e1       	ldi	r31, 0x10	; 16
    17b6:	0f 2f       	mov	r16, r31
    17b8:	f2 ec       	ldi	r31, 0xC2	; 194
    17ba:	1f 2f       	mov	r17, r31
    17bc:	f0 2d       	mov	r31, r0
				
		float s_out = -0.5421 * (cmd_vel) + 188.41;

		taskENTER_CRITICAL();
    17be:	0f b6       	in	r0, 0x3f	; 63
    17c0:	f8 94       	cli
    17c2:	0f 92       	push	r0
		PWM_timer3_Set_E3((int)s_out);
    17c4:	c8 01       	movw	r24, r16
    17c6:	b7 01       	movw	r22, r14
    17c8:	21 e1       	ldi	r18, 0x11	; 17
    17ca:	37 ec       	ldi	r19, 0xC7	; 199
    17cc:	4a e0       	ldi	r20, 0x0A	; 10
    17ce:	5f eb       	ldi	r21, 0xBF	; 191
    17d0:	0e 94 96 2d 	call	0x5b2c	; 0x5b2c <__mulsf3>
    17d4:	26 ef       	ldi	r18, 0xF6	; 246
    17d6:	38 e6       	ldi	r19, 0x68	; 104
    17d8:	4c e3       	ldi	r20, 0x3C	; 60
    17da:	53 e4       	ldi	r21, 0x43	; 67
    17dc:	0e 94 fc 2a 	call	0x55f8	; 0x55f8 <__addsf3>
    17e0:	0e 94 2e 2c 	call	0x585c	; 0x585c <__fixsfsi>
void PWM_timer1_Set_LED(u16 pwmDuty)
	{OCR1B = pwmDuty;}
void PWM_timer2_Set_H6(u16 pwmDuty)
	{OCR2B = pwmDuty;}
void PWM_timer3_Set_E3(u16 pwmDuty)
	{OCR3A = pwmDuty;}
    17e4:	70 93 99 00 	sts	0x0099, r23
    17e8:	60 93 98 00 	sts	0x0098, r22
		taskEXIT_CRITICAL();
    17ec:	0f 90       	pop	r0
    17ee:	0f be       	out	0x3f, r0	; 63
*/
			
		taskENTER_CRITICAL();
		wheel_L(v_out_L);
		wheel_R(-v_out_R);
		PORT_ON(PORTL,1);
    17f0:	80 91 0b 01 	lds	r24, 0x010B
    17f4:	82 60       	ori	r24, 0x02	; 2
    17f6:	80 93 0b 01 	sts	0x010B, r24
		delay_us(50);
    17fa:	82 e3       	ldi	r24, 0x32	; 50
    17fc:	90 e0       	ldi	r25, 0x00	; 0
    17fe:	0e 94 3f 1a 	call	0x347e	; 0x347e <delay_us>
		PORT_OFF(PORTL,1);
    1802:	80 91 0b 01 	lds	r24, 0x010B
    1806:	8d 7f       	andi	r24, 0xFD	; 253
    1808:	80 93 0b 01 	sts	0x010B, r24
		taskEXIT_CRITICAL();
    180c:	0f 90       	pop	r0
    180e:	0f be       	out	0x3f, r0	; 63

		vTaskDelayUntil(&xLastWakeTime, (1 / portTICK_RATE_MS));
    1810:	ce 01       	movw	r24, r28
    1812:	01 96       	adiw	r24, 0x01	; 1
    1814:	61 e0       	ldi	r22, 0x01	; 1
    1816:	70 e0       	ldi	r23, 0x00	; 0
    1818:	0e 94 b8 13 	call	0x2770	; 0x2770 <vTaskDelayUntil>
    181c:	2a 2d       	mov	r18, r10
    181e:	36 2d       	mov	r19, r6
    1820:	42 2d       	mov	r20, r2
    1822:	5d 2d       	mov	r21, r13
    1824:	c9 01       	movw	r24, r18
    1826:	da 01       	movw	r26, r20
    1828:	51 ce       	rjmp	.-862    	; 0x14cc <vPID+0x70>

0000182a <read_ub>:
			ub_buffer_write_ndx = ub_buffer;
		}
	}	
}

uint8_t read_ub(){
    182a:	04 c0       	rjmp	.+8      	; 0x1834 <read_ub+0xa>
	while(ub_buffer_read_ndx == ub_buffer_write_ndx){ delay_us(10); };
    182c:	8a e0       	ldi	r24, 0x0A	; 10
    182e:	90 e0       	ldi	r25, 0x00	; 0
    1830:	0e 94 3f 1a 	call	0x347e	; 0x347e <delay_us>
    1834:	e0 91 f2 02 	lds	r30, 0x02F2
    1838:	f0 91 f3 02 	lds	r31, 0x02F3
    183c:	80 91 f0 02 	lds	r24, 0x02F0
    1840:	90 91 f1 02 	lds	r25, 0x02F1
    1844:	e8 17       	cp	r30, r24
    1846:	f9 07       	cpc	r31, r25
    1848:	89 f3       	breq	.-30     	; 0x182c <read_ub+0x2>
	uint8_t data = *ub_buffer_read_ndx;
    184a:	21 91       	ld	r18, Z+
	ub_buffer_read_ndx++;
    184c:	f0 93 f3 02 	sts	0x02F3, r31
    1850:	e0 93 f2 02 	sts	0x02F2, r30
	if(ub_buffer_read_ndx >= (ub_buffer + UB_BUFFER_SIZE)){ 
    1854:	e8 53       	subi	r30, 0x38	; 56
    1856:	f4 41       	sbci	r31, 0x14	; 20
    1858:	30 f0       	brcs	.+12     	; 0x1866 <read_ub+0x3c>
		ub_buffer_read_ndx = ub_buffer;
    185a:	88 e3       	ldi	r24, 0x38	; 56
    185c:	92 e1       	ldi	r25, 0x12	; 18
    185e:	90 93 f3 02 	sts	0x02F3, r25
    1862:	80 93 f2 02 	sts	0x02F2, r24
	}
	return data;
}
    1866:	82 2f       	mov	r24, r18
    1868:	08 95       	ret

0000186a <vUbRcv>:
		
	
	}
}

void vUbRcv(){
    186a:	2f 92       	push	r2
    186c:	3f 92       	push	r3
    186e:	4f 92       	push	r4
    1870:	5f 92       	push	r5
    1872:	6f 92       	push	r6
    1874:	7f 92       	push	r7
    1876:	8f 92       	push	r8
    1878:	9f 92       	push	r9
    187a:	af 92       	push	r10
    187c:	bf 92       	push	r11
    187e:	cf 92       	push	r12
    1880:	df 92       	push	r13
    1882:	ef 92       	push	r14
    1884:	ff 92       	push	r15
    1886:	0f 93       	push	r16
    1888:	1f 93       	push	r17
    188a:	df 93       	push	r29
    188c:	cf 93       	push	r28
    188e:	00 d0       	rcall	.+0      	; 0x1890 <vUbRcv+0x26>
    1890:	cd b7       	in	r28, 0x3d	; 61
    1892:	de b7       	in	r29, 0x3e	; 62
				
				
				rprintfCRLF();
				rprintf("Received Velocity: ");
				rprintfFloat(5,fltuint8_velocity.f_vel);
				rprintf(" Omega: ");
    1894:	78 e1       	ldi	r23, 0x18	; 24
    1896:	27 2e       	mov	r2, r23
    1898:	71 e0       	ldi	r23, 0x01	; 1
    189a:	37 2e       	mov	r3, r23
				rprintfFloat(5,fltuint8_omega.f_ome);
				rprintfCRLF();
			
			
		}
		vTaskDelayUntil(&xLastWakeTime, (1 / portTICK_RATE_MS));
    189c:	2e 01       	movw	r4, r28
    189e:	08 94       	sec
    18a0:	41 1c       	adc	r4, r1
    18a2:	51 1c       	adc	r5, r1
	union u_ome fltuint8_omega;
	uint8_t rcv_byte;
	uint8_t rcv_chk;
	uint8_t calc_chk;
	for(;;){
		rcv_byte = read_ub();
    18a4:	0e 94 15 0c 	call	0x182a	; 0x182a <read_ub>
		//rprintfu08(rcv_byte);
		if(rcv_byte == 0xFA){
    18a8:	8a 3f       	cpi	r24, 0xFA	; 250
    18aa:	09 f0       	breq	.+2      	; 0x18ae <vUbRcv+0x44>
    18ac:	7c c0       	rjmp	.+248    	; 0x19a6 <vUbRcv+0x13c>
		
			fltuint8_velocity.arr_vel[0] = read_ub();
    18ae:	0e 94 15 0c 	call	0x182a	; 0x182a <read_ub>
    18b2:	e8 2e       	mov	r14, r24
			fltuint8_velocity.arr_vel[1] = read_ub();
    18b4:	0e 94 15 0c 	call	0x182a	; 0x182a <read_ub>
    18b8:	f8 2e       	mov	r15, r24
			fltuint8_velocity.arr_vel[2] = read_ub();
    18ba:	0e 94 15 0c 	call	0x182a	; 0x182a <read_ub>
    18be:	08 2f       	mov	r16, r24
			fltuint8_velocity.arr_vel[3] = read_ub();
    18c0:	0e 94 15 0c 	call	0x182a	; 0x182a <read_ub>
    18c4:	18 2f       	mov	r17, r24
			

			fltuint8_omega.arr_ome[0] = read_ub();
    18c6:	0e 94 15 0c 	call	0x182a	; 0x182a <read_ub>
    18ca:	68 2e       	mov	r6, r24
			fltuint8_omega.arr_ome[1] = read_ub();
    18cc:	0e 94 15 0c 	call	0x182a	; 0x182a <read_ub>
    18d0:	78 2e       	mov	r7, r24
			fltuint8_omega.arr_ome[2] = read_ub();
    18d2:	0e 94 15 0c 	call	0x182a	; 0x182a <read_ub>
    18d6:	88 2e       	mov	r8, r24
			fltuint8_omega.arr_ome[3] = read_ub();
    18d8:	0e 94 15 0c 	call	0x182a	; 0x182a <read_ub>
    18dc:	98 2e       	mov	r9, r24
		

			rcv_chk = read_ub();
    18de:	0e 94 15 0c 	call	0x182a	; 0x182a <read_ub>

			calc_chk = fltuint8_velocity.arr_vel[0] + fltuint8_velocity.arr_vel[1] + fltuint8_velocity.arr_vel[2]
			+ fltuint8_velocity.arr_vel[3] + fltuint8_omega.arr_ome[0] + fltuint8_omega.arr_ome[1] 
			+ fltuint8_omega.arr_ome[2] + fltuint8_omega.arr_ome[3];
/**/
			rprintfu08(fltuint8_velocity.arr_vel[0]);
    18e2:	8e 2d       	mov	r24, r14
    18e4:	0e 94 11 26 	call	0x4c22	; 0x4c22 <rprintfu08>
			rprintfu08(fltuint8_velocity.arr_vel[1]);
    18e8:	8f 2d       	mov	r24, r15
    18ea:	0e 94 11 26 	call	0x4c22	; 0x4c22 <rprintfu08>
			rprintfu08(fltuint8_velocity.arr_vel[2]);
    18ee:	80 2f       	mov	r24, r16
    18f0:	0e 94 11 26 	call	0x4c22	; 0x4c22 <rprintfu08>
			rprintfu08(fltuint8_velocity.arr_vel[3]);
    18f4:	81 2f       	mov	r24, r17
    18f6:	0e 94 11 26 	call	0x4c22	; 0x4c22 <rprintfu08>

			rprintfu08(fltuint8_omega.arr_ome[0]);
    18fa:	86 2d       	mov	r24, r6
    18fc:	0e 94 11 26 	call	0x4c22	; 0x4c22 <rprintfu08>
			rprintfu08(fltuint8_omega.arr_ome[1]);
    1900:	87 2d       	mov	r24, r7
    1902:	0e 94 11 26 	call	0x4c22	; 0x4c22 <rprintfu08>
			rprintfu08(fltuint8_omega.arr_ome[2]);
    1906:	88 2d       	mov	r24, r8
    1908:	0e 94 11 26 	call	0x4c22	; 0x4c22 <rprintfu08>
			rprintfu08(fltuint8_omega.arr_ome[3]);
    190c:	89 2d       	mov	r24, r9
    190e:	0e 94 11 26 	call	0x4c22	; 0x4c22 <rprintfu08>

			if(calc_chk == rcv_chk){
			}
				v_command = fltuint8_velocity.f_vel;
    1912:	de 2c       	mov	r13, r14
    1914:	cf 2c       	mov	r12, r15
    1916:	b0 2e       	mov	r11, r16
    1918:	a1 2e       	mov	r10, r17
    191a:	8e 2d       	mov	r24, r14
    191c:	9f 2d       	mov	r25, r15
    191e:	a0 2f       	mov	r26, r16
    1920:	b1 2f       	mov	r27, r17
    1922:	80 93 e0 02 	sts	0x02E0, r24
    1926:	90 93 e1 02 	sts	0x02E1, r25
    192a:	a0 93 e2 02 	sts	0x02E2, r26
    192e:	b0 93 e3 02 	sts	0x02E3, r27
				cmd_ang_vel = fltuint8_omega.f_ome;
    1932:	86 2d       	mov	r24, r6
    1934:	97 2d       	mov	r25, r7
    1936:	a8 2d       	mov	r26, r8
    1938:	b9 2d       	mov	r27, r9
    193a:	80 93 e8 02 	sts	0x02E8, r24
    193e:	90 93 e9 02 	sts	0x02E9, r25
    1942:	a0 93 ea 02 	sts	0x02EA, r26
    1946:	b0 93 eb 02 	sts	0x02EB, r27
				
				
				rprintfCRLF();
    194a:	0e 94 02 26 	call	0x4c04	; 0x4c04 <rprintfCRLF>
				rprintf("Received Velocity: ");
    194e:	00 d0       	rcall	.+0      	; 0x1950 <vUbRcv+0xe6>
    1950:	0f 92       	push	r0
    1952:	81 e0       	ldi	r24, 0x01	; 1
    1954:	ed b7       	in	r30, 0x3d	; 61
    1956:	fe b7       	in	r31, 0x3e	; 62
    1958:	81 83       	std	Z+1, r24	; 0x01
    195a:	81 e2       	ldi	r24, 0x21	; 33
    195c:	91 e0       	ldi	r25, 0x01	; 1
    195e:	93 83       	std	Z+3, r25	; 0x03
    1960:	82 83       	std	Z+2, r24	; 0x02
    1962:	0e 94 c2 27 	call	0x4f84	; 0x4f84 <rprintf1RamRom>
				rprintfFloat(5,fltuint8_velocity.f_vel);
    1966:	0f 90       	pop	r0
    1968:	0f 90       	pop	r0
    196a:	0f 90       	pop	r0
    196c:	85 e0       	ldi	r24, 0x05	; 5
    196e:	4d 2d       	mov	r20, r13
    1970:	5c 2d       	mov	r21, r12
    1972:	6b 2d       	mov	r22, r11
    1974:	7a 2d       	mov	r23, r10
    1976:	0e 94 f9 26 	call	0x4df2	; 0x4df2 <rprintfFloat>
				rprintf(" Omega: ");
    197a:	00 d0       	rcall	.+0      	; 0x197c <vUbRcv+0x112>
    197c:	0f 92       	push	r0
    197e:	81 e0       	ldi	r24, 0x01	; 1
    1980:	ed b7       	in	r30, 0x3d	; 61
    1982:	fe b7       	in	r31, 0x3e	; 62
    1984:	81 83       	std	Z+1, r24	; 0x01
    1986:	33 82       	std	Z+3, r3	; 0x03
    1988:	22 82       	std	Z+2, r2	; 0x02
    198a:	0e 94 c2 27 	call	0x4f84	; 0x4f84 <rprintf1RamRom>
				rprintfFloat(5,fltuint8_omega.f_ome);
    198e:	0f 90       	pop	r0
    1990:	0f 90       	pop	r0
    1992:	0f 90       	pop	r0
    1994:	85 e0       	ldi	r24, 0x05	; 5
    1996:	46 2d       	mov	r20, r6
    1998:	57 2d       	mov	r21, r7
    199a:	68 2d       	mov	r22, r8
    199c:	79 2d       	mov	r23, r9
    199e:	0e 94 f9 26 	call	0x4df2	; 0x4df2 <rprintfFloat>
				rprintfCRLF();
    19a2:	0e 94 02 26 	call	0x4c04	; 0x4c04 <rprintfCRLF>
			
			
		}
		vTaskDelayUntil(&xLastWakeTime, (1 / portTICK_RATE_MS));
    19a6:	c2 01       	movw	r24, r4
    19a8:	61 e0       	ldi	r22, 0x01	; 1
    19aa:	70 e0       	ldi	r23, 0x00	; 0
    19ac:	0e 94 b8 13 	call	0x2770	; 0x2770 <vTaskDelayUntil>
    19b0:	79 cf       	rjmp	.-270    	; 0x18a4 <vUbRcv+0x3a>

000019b2 <prvSetupHardware>:

void init_ub_buffer(){
	ub_buffer_write_ndx = ub_buffer_read_ndx = ub_buffer;
}

void prvSetupHardware(){
    19b2:	0f 93       	push	r16
    19b4:	1f 93       	push	r17
    19b6:	cf 93       	push	r28
    19b8:	df 93       	push	r29
	delay_cycles(65535);
	delay_cycles(65535);
	
	

	uartInit();  // initialize the UART (serial port)
    19ba:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <uartInit>
    uartSetBaudRate(0, 38400); // Right Encoder
    19be:	80 e0       	ldi	r24, 0x00	; 0
    19c0:	40 e0       	ldi	r20, 0x00	; 0
    19c2:	56 e9       	ldi	r21, 0x96	; 150
    19c4:	60 e0       	ldi	r22, 0x00	; 0
    19c6:	70 e0       	ldi	r23, 0x00	; 0
    19c8:	0e 94 34 20 	call	0x4068	; 0x4068 <uartSetBaudRate>
    uartSetBaudRate(1, 115200); // USB connection
    19cc:	81 e0       	ldi	r24, 0x01	; 1
    19ce:	40 e0       	ldi	r20, 0x00	; 0
    19d0:	52 ec       	ldi	r21, 0xC2	; 194
    19d2:	61 e0       	ldi	r22, 0x01	; 1
    19d4:	70 e0       	ldi	r23, 0x00	; 0
    19d6:	0e 94 34 20 	call	0x4068	; 0x4068 <uartSetBaudRate>
    uartSetBaudRate(2, 38400); // Left Encoder
    19da:	82 e0       	ldi	r24, 0x02	; 2
    19dc:	40 e0       	ldi	r20, 0x00	; 0
    19de:	56 e9       	ldi	r21, 0x96	; 150
    19e0:	60 e0       	ldi	r22, 0x00	; 0
    19e2:	70 e0       	ldi	r23, 0x00	; 0
    19e4:	0e 94 34 20 	call	0x4068	; 0x4068 <uartSetBaudRate>
    uartSetBaudRate(3, 38400); // UB connection
    19e8:	83 e0       	ldi	r24, 0x03	; 3
    19ea:	40 e0       	ldi	r20, 0x00	; 0
    19ec:	56 e9       	ldi	r21, 0x96	; 150
    19ee:	60 e0       	ldi	r22, 0x00	; 0
    19f0:	70 e0       	ldi	r23, 0x00	; 0
    19f2:	0e 94 34 20 	call	0x4068	; 0x4068 <uartSetBaudRate>
	//G=Ground, T=Tx (connect to external Rx), R=Rx (connect to external Tx)

	rprintfInit(uart1SendByte);// initialize rprintf system and configure uart1 (USB) for rprintf
    19f6:	8d ea       	ldi	r24, 0xAD	; 173
    19f8:	90 e2       	ldi	r25, 0x20	; 32
    19fa:	0e 94 9e 25 	call	0x4b3c	; 0x4b3c <rprintfInit>

	configure_ports(); // configure which ports are analog, digital, etc.
    19fe:	0e 94 70 03 	call	0x6e0	; 0x6e0 <configure_ports>
	}
	return data;
}

void init_ub_buffer(){
	ub_buffer_write_ndx = ub_buffer_read_ndx = ub_buffer;
    1a02:	88 e3       	ldi	r24, 0x38	; 56
    1a04:	92 e1       	ldi	r25, 0x12	; 18
    1a06:	90 93 f3 02 	sts	0x02F3, r25
    1a0a:	80 93 f2 02 	sts	0x02F2, r24
    1a0e:	90 93 f1 02 	sts	0x02F1, r25
    1a12:	80 93 f0 02 	sts	0x02F0, r24
	
	//UART ISR *** UART ISR ***

	init_ub_buffer();
	
	uartSetRxHandler(2, &fwdSer_L);
    1a16:	82 e0       	ldi	r24, 0x02	; 2
    1a18:	6c e8       	ldi	r22, 0x8C	; 140
    1a1a:	76 e0       	ldi	r23, 0x06	; 6
    1a1c:	0e 94 29 20 	call	0x4052	; 0x4052 <uartSetRxHandler>
	uartSetRxHandler(0, &fwdSer_R);
    1a20:	80 e0       	ldi	r24, 0x00	; 0
    1a22:	6c e1       	ldi	r22, 0x1C	; 28
    1a24:	77 e0       	ldi	r23, 0x07	; 7
    1a26:	0e 94 29 20 	call	0x4052	; 0x4052 <uartSetRxHandler>
	uartSetRxHandler(3, &ubRcv);
    1a2a:	83 e0       	ldi	r24, 0x03	; 3
    1a2c:	6f e7       	ldi	r22, 0x7F	; 127
    1a2e:	75 e0       	ldi	r23, 0x05	; 5
    1a30:	0e 94 29 20 	call	0x4052	; 0x4052 <uartSetRxHandler>
void LED_on(void)
	{PORT_OFF(PORTB,6);}
    1a34:	2e 98       	cbi	0x05, 6	; 5

	//UART ISR *** UART ISR ***

	LED_on();

	rprintf("\r\nSystem Warmed Up");
    1a36:	00 d0       	rcall	.+0      	; 0x1a38 <prvSetupHardware+0x86>
    1a38:	0f 92       	push	r0
    1a3a:	81 e0       	ldi	r24, 0x01	; 1
    1a3c:	ed b7       	in	r30, 0x3d	; 61
    1a3e:	fe b7       	in	r31, 0x3e	; 62
    1a40:	81 83       	std	Z+1, r24	; 0x01
    1a42:	83 e7       	ldi	r24, 0x73	; 115
    1a44:	91 e0       	ldi	r25, 0x01	; 1
    1a46:	93 83       	std	Z+3, r25	; 0x03
    1a48:	82 83       	std	Z+2, r24	; 0x02
    1a4a:	0e 94 c2 27 	call	0x4f84	; 0x4f84 <rprintf1RamRom>

	// initialize the timer system
 	init_timer0(TIMER_CLK_1024);
    1a4e:	0f 90       	pop	r0
    1a50:	0f 90       	pop	r0
    1a52:	0f 90       	pop	r0
    1a54:	85 e0       	ldi	r24, 0x05	; 5
    1a56:	0e 94 40 1a 	call	0x3480	; 0x3480 <init_timer0>
// 	init_timer1(TIMER_CLK_64); // Timer 1 is initialized by FreeRTOS
 	//init_timer2(TIMER2_CLK_64);
	init_timer2(TIMER2_CLK_1024);
    1a5a:	87 e0       	ldi	r24, 0x07	; 7
    1a5c:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <init_timer2>
 	init_timer3(TIMER_CLK_64);
    1a60:	83 e0       	ldi	r24, 0x03	; 3
    1a62:	0e 94 70 1a 	call	0x34e0	; 0x34e0 <init_timer3>
 	init_timer4(TIMER_CLK_64);
    1a66:	83 e0       	ldi	r24, 0x03	; 3
    1a68:	0e 94 82 1a 	call	0x3504	; 0x3504 <init_timer4>
 	init_timer5(TIMER_CLK_64);
    1a6c:	83 e0       	ldi	r24, 0x03	; 3
    1a6e:	0e 94 94 1a 	call	0x3528	; 0x3528 <init_timer5>

	a2dInit(); // initialize analog to digital converter (ADC)
    1a72:	0e 94 13 25 	call	0x4a26	; 0x4a26 <a2dInit>
	a2dSetPrescaler(ADC_PRESCALE_DIV32); // configure ADC scaling
    1a76:	85 e0       	ldi	r24, 0x05	; 5
    1a78:	0e 94 38 25 	call	0x4a70	; 0x4a70 <a2dSetPrescaler>
	a2dSetReference(ADC_REFERENCE_AVCC); // configure ADC reference voltage
    1a7c:	81 e0       	ldi	r24, 0x01	; 1
    1a7e:	0e 94 3f 25 	call	0x4a7e	; 0x4a7e <a2dSetReference>
    1a82:	10 e0       	ldi	r17, 0x00	; 0
	//let system stabelize for X time
	for(i=0;i<16;i++)
		{
		j=a2dConvert8bit(i);//read each ADC once to get it working accurately
		delay_cycles(5000); //keep LED on long enough to see Axon reseting
		rprintf(".");
    1a84:	01 e0       	ldi	r16, 0x01	; 1
    1a86:	c1 e7       	ldi	r28, 0x71	; 113
    1a88:	d1 e0       	ldi	r29, 0x01	; 1
	a2dSetReference(ADC_REFERENCE_AVCC); // configure ADC reference voltage

	//let system stabelize for X time
	for(i=0;i<16;i++)
		{
		j=a2dConvert8bit(i);//read each ADC once to get it working accurately
    1a8a:	81 2f       	mov	r24, r17
    1a8c:	0e 94 88 25 	call	0x4b10	; 0x4b10 <a2dConvert8bit>
		delay_cycles(5000); //keep LED on long enough to see Axon reseting
		rprintf(".");
    1a90:	00 d0       	rcall	.+0      	; 0x1a92 <prvSetupHardware+0xe0>
    1a92:	0f 92       	push	r0
    1a94:	ed b7       	in	r30, 0x3d	; 61
    1a96:	fe b7       	in	r31, 0x3e	; 62
    1a98:	01 83       	std	Z+1, r16	; 0x01
    1a9a:	d3 83       	std	Z+3, r29	; 0x03
    1a9c:	c2 83       	std	Z+2, r28	; 0x02
    1a9e:	0e 94 c2 27 	call	0x4f84	; 0x4f84 <rprintf1RamRom>
    1aa2:	1f 5f       	subi	r17, 0xFF	; 255
	a2dInit(); // initialize analog to digital converter (ADC)
	a2dSetPrescaler(ADC_PRESCALE_DIV32); // configure ADC scaling
	a2dSetReference(ADC_REFERENCE_AVCC); // configure ADC reference voltage

	//let system stabelize for X time
	for(i=0;i<16;i++)
    1aa4:	0f 90       	pop	r0
    1aa6:	0f 90       	pop	r0
    1aa8:	0f 90       	pop	r0
    1aaa:	10 31       	cpi	r17, 0x10	; 16
    1aac:	71 f7       	brne	.-36     	; 0x1a8a <prvSetupHardware+0xd8>


//***************STATUS LED**************
//tank test
void LED_off(void)
	{PORT_ON(PORTB,6);}
    1aae:	2e 9a       	sbi	0x05, 6	; 5
		rprintf(".");
		}

	LED_off();

	rprintf("Initialization Complete \r\n");
    1ab0:	00 d0       	rcall	.+0      	; 0x1ab2 <prvSetupHardware+0x100>
    1ab2:	0f 92       	push	r0
    1ab4:	ed b7       	in	r30, 0x3d	; 61
    1ab6:	fe b7       	in	r31, 0x3e	; 62
    1ab8:	01 83       	std	Z+1, r16	; 0x01
    1aba:	86 e5       	ldi	r24, 0x56	; 86
    1abc:	91 e0       	ldi	r25, 0x01	; 1
    1abe:	93 83       	std	Z+3, r25	; 0x03
    1ac0:	82 83       	std	Z+2, r24	; 0x02
    1ac2:	0e 94 c2 27 	call	0x4f84	; 0x4f84 <rprintf1RamRom>

	//reset all timers to zero
	reset_timer0();
    1ac6:	0f 90       	pop	r0
    1ac8:	0f 90       	pop	r0
    1aca:	0f 90       	pop	r0
    1acc:	0e 94 f6 19 	call	0x33ec	; 0x33ec <reset_timer0>
	reset_timer1();
    1ad0:	0e 94 00 1a 	call	0x3400	; 0x3400 <reset_timer1>
	reset_timer2();
    1ad4:	0e 94 0d 1a 	call	0x341a	; 0x341a <reset_timer2>
	reset_timer3();
    1ad8:	0e 94 18 1a 	call	0x3430	; 0x3430 <reset_timer3>
	reset_timer4();
    1adc:	0e 94 25 1a 	call	0x344a	; 0x344a <reset_timer4>
	reset_timer5();
    1ae0:	0e 94 32 1a 	call	0x3464	; 0x3464 <reset_timer5>



	/********PWM Setup***********/
	prvPWMSetup();
    1ae4:	0e 94 40 04 	call	0x880	; 0x880 <prvPWMSetup>

}
    1ae8:	df 91       	pop	r29
    1aea:	cf 91       	pop	r28
    1aec:	1f 91       	pop	r17
    1aee:	0f 91       	pop	r16
    1af0:	08 95       	ret

00001af2 <main>:
float elapsed_time;
float current_time = 0;
float previous_time = 0;

int main(void)
{
    1af2:	af 92       	push	r10
    1af4:	bf 92       	push	r11
    1af6:	cf 92       	push	r12
    1af8:	df 92       	push	r13
    1afa:	ef 92       	push	r14
    1afc:	ff 92       	push	r15
    1afe:	0f 93       	push	r16
    1b00:	cf 93       	push	r28
    1b02:	df 93       	push	r29
	prvSetupHardware();
    1b04:	0e 94 d9 0c 	call	0x19b2	; 0x19b2 <prvSetupHardware>

	
	//delay_ms(500);


	v_command = 25;
    1b08:	80 e0       	ldi	r24, 0x00	; 0
    1b0a:	90 e0       	ldi	r25, 0x00	; 0
    1b0c:	a8 ec       	ldi	r26, 0xC8	; 200
    1b0e:	b1 e4       	ldi	r27, 0x41	; 65
    1b10:	80 93 e0 02 	sts	0x02E0, r24
    1b14:	90 93 e1 02 	sts	0x02E1, r25
    1b18:	a0 93 e2 02 	sts	0x02E2, r26
    1b1c:	b0 93 e3 02 	sts	0x02E3, r27
//	v_command = 0;
	cmd_ang_vel = 0;
    1b20:	80 e0       	ldi	r24, 0x00	; 0
    1b22:	90 e0       	ldi	r25, 0x00	; 0
    1b24:	a0 e0       	ldi	r26, 0x00	; 0
    1b26:	b0 e0       	ldi	r27, 0x00	; 0
    1b28:	80 93 e8 02 	sts	0x02E8, r24
    1b2c:	90 93 e9 02 	sts	0x02E9, r25
    1b30:	a0 93 ea 02 	sts	0x02EA, r26
    1b34:	b0 93 eb 02 	sts	0x02EB, r27


	xTaskCreate(vLight0On, "Light0", 100, NULL, 1, NULL);
    1b38:	86 e4       	ldi	r24, 0x46	; 70
    1b3a:	98 e0       	ldi	r25, 0x08	; 8
    1b3c:	60 e0       	ldi	r22, 0x00	; 0
    1b3e:	72 e0       	ldi	r23, 0x02	; 2
    1b40:	44 e6       	ldi	r20, 0x64	; 100
    1b42:	50 e0       	ldi	r21, 0x00	; 0
    1b44:	20 e0       	ldi	r18, 0x00	; 0
    1b46:	30 e0       	ldi	r19, 0x00	; 0
    1b48:	01 e0       	ldi	r16, 0x01	; 1
    1b4a:	ee 24       	eor	r14, r14
    1b4c:	ff 24       	eor	r15, r15
    1b4e:	cc 24       	eor	r12, r12
    1b50:	dd 24       	eor	r13, r13
    1b52:	aa 24       	eor	r10, r10
    1b54:	bb 24       	eor	r11, r11
    1b56:	0e 94 a2 14 	call	0x2944	; 0x2944 <xTaskGenericCreate>
	xTaskCreate(vLight1On, "Light1", 100, NULL, 1, NULL);
    1b5a:	8f e2       	ldi	r24, 0x2F	; 47
    1b5c:	98 e0       	ldi	r25, 0x08	; 8
    1b5e:	67 e0       	ldi	r22, 0x07	; 7
    1b60:	72 e0       	ldi	r23, 0x02	; 2
    1b62:	44 e6       	ldi	r20, 0x64	; 100
    1b64:	50 e0       	ldi	r21, 0x00	; 0
    1b66:	20 e0       	ldi	r18, 0x00	; 0
    1b68:	30 e0       	ldi	r19, 0x00	; 0
    1b6a:	0e 94 a2 14 	call	0x2944	; 0x2944 <xTaskGenericCreate>
	xTaskCreate(vUpdatePose, "UpdatePs", 500, NULL, 1, NULL);
    1b6e:	85 e4       	ldi	r24, 0x45	; 69
    1b70:	96 e0       	ldi	r25, 0x06	; 6
    1b72:	6e e0       	ldi	r22, 0x0E	; 14
    1b74:	72 e0       	ldi	r23, 0x02	; 2
    1b76:	44 ef       	ldi	r20, 0xF4	; 244
    1b78:	51 e0       	ldi	r21, 0x01	; 1
    1b7a:	20 e0       	ldi	r18, 0x00	; 0
    1b7c:	30 e0       	ldi	r19, 0x00	; 0
    1b7e:	0e 94 a2 14 	call	0x2944	; 0x2944 <xTaskGenericCreate>
	xTaskCreate(vEnc_UpdatePose, "enUpdtPs", 500, NULL, 1, NULL);
    1b82:	8d e5       	ldi	r24, 0x5D	; 93
    1b84:	98 e0       	ldi	r25, 0x08	; 8
    1b86:	67 e1       	ldi	r22, 0x17	; 23
    1b88:	72 e0       	ldi	r23, 0x02	; 2
    1b8a:	44 ef       	ldi	r20, 0xF4	; 244
    1b8c:	51 e0       	ldi	r21, 0x01	; 1
    1b8e:	20 e0       	ldi	r18, 0x00	; 0
    1b90:	30 e0       	ldi	r19, 0x00	; 0
    1b92:	0e 94 a2 14 	call	0x2944	; 0x2944 <xTaskGenericCreate>
//	xTaskCreate(vServoOsc, "ServoGo", 200, NULL, 1, NULL);
//	xTaskCreate(vServoTm, "ServoTm", 200, NULL, 1, NULL);
//	xTaskCreate(vUbRcv, "vUbRcv", 500, NULL, 1, NULL);
	xTaskCreate(vPID, "vPID", 500, NULL, 1, NULL);
    1b96:	8e e2       	ldi	r24, 0x2E	; 46
    1b98:	9a e0       	ldi	r25, 0x0A	; 10
    1b9a:	60 e2       	ldi	r22, 0x20	; 32
    1b9c:	72 e0       	ldi	r23, 0x02	; 2
    1b9e:	44 ef       	ldi	r20, 0xF4	; 244
    1ba0:	51 e0       	ldi	r21, 0x01	; 1
    1ba2:	20 e0       	ldi	r18, 0x00	; 0
    1ba4:	30 e0       	ldi	r19, 0x00	; 0
    1ba6:	0e 94 a2 14 	call	0x2944	; 0x2944 <xTaskGenericCreate>
//	xTaskCreate(vScript, "vScript", 100, NULL, 2, NULL);


	vTaskStartScheduler();
    1baa:	0e 94 c6 15 	call	0x2b8c	; 0x2b8c <vTaskStartScheduler>
	for(;;){rprintf("DEATH\n");}
    1bae:	c1 e1       	ldi	r28, 0x11	; 17
    1bb0:	d1 e0       	ldi	r29, 0x01	; 1
    1bb2:	00 d0       	rcall	.+0      	; 0x1bb4 <main+0xc2>
    1bb4:	0f 92       	push	r0
    1bb6:	ed b7       	in	r30, 0x3d	; 61
    1bb8:	fe b7       	in	r31, 0x3e	; 62
    1bba:	01 83       	std	Z+1, r16	; 0x01
    1bbc:	d3 83       	std	Z+3, r29	; 0x03
    1bbe:	c2 83       	std	Z+2, r28	; 0x02
    1bc0:	0e 94 c2 27 	call	0x4f84	; 0x4f84 <rprintf1RamRom>
    1bc4:	0f 90       	pop	r0
    1bc6:	0f 90       	pop	r0
    1bc8:	0f 90       	pop	r0
    1bca:	f3 cf       	rjmp	.-26     	; 0x1bb2 <main+0xc0>

00001bcc <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1bcc:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    1bce:	9c 01       	movw	r18, r24
    1bd0:	2d 5f       	subi	r18, 0xFD	; 253
    1bd2:	3f 4f       	sbci	r19, 0xFF	; 255
    1bd4:	32 83       	std	Z+2, r19	; 0x02
    1bd6:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1bd8:	8f ef       	ldi	r24, 0xFF	; 255
    1bda:	9f ef       	ldi	r25, 0xFF	; 255
    1bdc:	94 83       	std	Z+4, r25	; 0x04
    1bde:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1be0:	36 83       	std	Z+6, r19	; 0x06
    1be2:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1be4:	30 87       	std	Z+8, r19	; 0x08
    1be6:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = 0;
    1be8:	10 82       	st	Z, r1
}
    1bea:	08 95       	ret

00001bec <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1bec:	fc 01       	movw	r30, r24
    1bee:	11 86       	std	Z+9, r1	; 0x09
    1bf0:	10 86       	std	Z+8, r1	; 0x08
}
    1bf2:	08 95       	ret

00001bf4 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1bf4:	cf 93       	push	r28
    1bf6:	df 93       	push	r29
    1bf8:	ac 01       	movw	r20, r24
    1bfa:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1bfc:	ec 01       	movw	r28, r24
    1bfe:	29 81       	ldd	r18, Y+1	; 0x01
    1c00:	3a 81       	ldd	r19, Y+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    1c02:	f9 01       	movw	r30, r18
    1c04:	82 81       	ldd	r24, Z+2	; 0x02
    1c06:	93 81       	ldd	r25, Z+3	; 0x03
    1c08:	13 96       	adiw	r26, 0x03	; 3
    1c0a:	9c 93       	st	X, r25
    1c0c:	8e 93       	st	-X, r24
    1c0e:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1c10:	89 81       	ldd	r24, Y+1	; 0x01
    1c12:	9a 81       	ldd	r25, Y+2	; 0x02
    1c14:	15 96       	adiw	r26, 0x05	; 5
    1c16:	9c 93       	st	X, r25
    1c18:	8e 93       	st	-X, r24
    1c1a:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1c1c:	02 80       	ldd	r0, Z+2	; 0x02
    1c1e:	f3 81       	ldd	r31, Z+3	; 0x03
    1c20:	e0 2d       	mov	r30, r0
    1c22:	75 83       	std	Z+5, r23	; 0x05
    1c24:	64 83       	std	Z+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1c26:	e9 01       	movw	r28, r18
    1c28:	7b 83       	std	Y+3, r23	; 0x03
    1c2a:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    1c2c:	fa 01       	movw	r30, r20
    1c2e:	72 83       	std	Z+2, r23	; 0x02
    1c30:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1c32:	19 96       	adiw	r26, 0x09	; 9
    1c34:	5c 93       	st	X, r21
    1c36:	4e 93       	st	-X, r20
    1c38:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
    1c3a:	80 81       	ld	r24, Z
    1c3c:	8f 5f       	subi	r24, 0xFF	; 255
    1c3e:	80 83       	st	Z, r24
}
    1c40:	df 91       	pop	r29
    1c42:	cf 91       	pop	r28
    1c44:	08 95       	ret

00001c46 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    1c46:	cf 93       	push	r28
    1c48:	df 93       	push	r29
    1c4a:	9c 01       	movw	r18, r24
    1c4c:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    1c4e:	48 81       	ld	r20, Y
    1c50:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as 
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the 
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1c52:	8f ef       	ldi	r24, 0xFF	; 255
    1c54:	4f 3f       	cpi	r20, 0xFF	; 255
    1c56:	58 07       	cpc	r21, r24
    1c58:	21 f4       	brne	.+8      	; 0x1c62 <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1c5a:	f9 01       	movw	r30, r18
    1c5c:	a7 81       	ldd	r26, Z+7	; 0x07
    1c5e:	b0 85       	ldd	r27, Z+8	; 0x08
    1c60:	10 c0       	rjmp	.+32     	; 0x1c82 <vListInsert+0x3c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips. 
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    1c62:	d9 01       	movw	r26, r18
    1c64:	13 96       	adiw	r26, 0x03	; 3
    1c66:	04 c0       	rjmp	.+8      	; 0x1c70 <vListInsert+0x2a>
    1c68:	12 96       	adiw	r26, 0x02	; 2
    1c6a:	0d 90       	ld	r0, X+
    1c6c:	bc 91       	ld	r27, X
    1c6e:	a0 2d       	mov	r26, r0
    1c70:	12 96       	adiw	r26, 0x02	; 2
    1c72:	ed 91       	ld	r30, X+
    1c74:	fc 91       	ld	r31, X
    1c76:	13 97       	sbiw	r26, 0x03	; 3
    1c78:	80 81       	ld	r24, Z
    1c7a:	91 81       	ldd	r25, Z+1	; 0x01
    1c7c:	48 17       	cp	r20, r24
    1c7e:	59 07       	cpc	r21, r25
    1c80:	98 f7       	brcc	.-26     	; 0x1c68 <vListInsert+0x22>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1c82:	12 96       	adiw	r26, 0x02	; 2
    1c84:	ed 91       	ld	r30, X+
    1c86:	fc 91       	ld	r31, X
    1c88:	13 97       	sbiw	r26, 0x03	; 3
    1c8a:	fb 83       	std	Y+3, r31	; 0x03
    1c8c:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1c8e:	d5 83       	std	Z+5, r29	; 0x05
    1c90:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1c92:	bd 83       	std	Y+5, r27	; 0x05
    1c94:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1c96:	13 96       	adiw	r26, 0x03	; 3
    1c98:	dc 93       	st	X, r29
    1c9a:	ce 93       	st	-X, r28
    1c9c:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1c9e:	39 87       	std	Y+9, r19	; 0x09
    1ca0:	28 87       	std	Y+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    1ca2:	f9 01       	movw	r30, r18
    1ca4:	80 81       	ld	r24, Z
    1ca6:	8f 5f       	subi	r24, 0xFF	; 255
    1ca8:	80 83       	st	Z, r24
}
    1caa:	df 91       	pop	r29
    1cac:	cf 91       	pop	r28
    1cae:	08 95       	ret

00001cb0 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    1cb0:	cf 93       	push	r28
    1cb2:	df 93       	push	r29
    1cb4:	dc 01       	movw	r26, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1cb6:	12 96       	adiw	r26, 0x02	; 2
    1cb8:	ed 91       	ld	r30, X+
    1cba:	fc 91       	ld	r31, X
    1cbc:	13 97       	sbiw	r26, 0x03	; 3
    1cbe:	14 96       	adiw	r26, 0x04	; 4
    1cc0:	8d 91       	ld	r24, X+
    1cc2:	9c 91       	ld	r25, X
    1cc4:	15 97       	sbiw	r26, 0x05	; 5
    1cc6:	95 83       	std	Z+5, r25	; 0x05
    1cc8:	84 83       	std	Z+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1cca:	14 96       	adiw	r26, 0x04	; 4
    1ccc:	cd 91       	ld	r28, X+
    1cce:	dc 91       	ld	r29, X
    1cd0:	15 97       	sbiw	r26, 0x05	; 5
    1cd2:	fb 83       	std	Y+3, r31	; 0x03
    1cd4:	ea 83       	std	Y+2, r30	; 0x02
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1cd6:	18 96       	adiw	r26, 0x08	; 8
    1cd8:	ed 91       	ld	r30, X+
    1cda:	fc 91       	ld	r31, X
    1cdc:	19 97       	sbiw	r26, 0x09	; 9

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1cde:	81 81       	ldd	r24, Z+1	; 0x01
    1ce0:	92 81       	ldd	r25, Z+2	; 0x02
    1ce2:	8a 17       	cp	r24, r26
    1ce4:	9b 07       	cpc	r25, r27
    1ce6:	11 f4       	brne	.+4      	; 0x1cec <vListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1ce8:	d2 83       	std	Z+2, r29	; 0x02
    1cea:	c1 83       	std	Z+1, r28	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    1cec:	19 96       	adiw	r26, 0x09	; 9
    1cee:	1c 92       	st	X, r1
    1cf0:	1e 92       	st	-X, r1
    1cf2:	18 97       	sbiw	r26, 0x08	; 8
	( pxList->uxNumberOfItems )--;
    1cf4:	80 81       	ld	r24, Z
    1cf6:	81 50       	subi	r24, 0x01	; 1
    1cf8:	80 83       	st	Z, r24
}
    1cfa:	df 91       	pop	r29
    1cfc:	cf 91       	pop	r28
    1cfe:	08 95       	ret

00001d00 <uxQueueMessagesWaiting>:
	return xReturn;
}
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    1d00:	fc 01       	movw	r30, r24
unsigned portBASE_TYPE uxReturn;

	taskENTER_CRITICAL();
    1d02:	0f b6       	in	r0, 0x3f	; 63
    1d04:	f8 94       	cli
    1d06:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1d08:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    1d0a:	0f 90       	pop	r0
    1d0c:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    1d0e:	08 95       	ret

00001d10 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    1d10:	fc 01       	movw	r30, r24
unsigned portBASE_TYPE uxReturn;

	uxReturn = pxQueue->uxMessagesWaiting;
    1d12:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
    1d14:	08 95       	ret

00001d16 <xQueueIsQueueEmptyFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    1d16:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1d18:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d1a:	90 e0       	ldi	r25, 0x00	; 0
    1d1c:	88 23       	and	r24, r24
    1d1e:	09 f4       	brne	.+2      	; 0x1d22 <xQueueIsQueueEmptyFromISR+0xc>
    1d20:	91 e0       	ldi	r25, 0x01	; 1

	return xReturn;
}
    1d22:	89 2f       	mov	r24, r25
    1d24:	08 95       	ret

00001d26 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    1d26:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    1d28:	92 8d       	ldd	r25, Z+26	; 0x1a
    1d2a:	20 e0       	ldi	r18, 0x00	; 0
    1d2c:	83 8d       	ldd	r24, Z+27	; 0x1b
    1d2e:	98 17       	cp	r25, r24
    1d30:	09 f4       	brne	.+2      	; 0x1d34 <xQueueIsQueueFullFromISR+0xe>
    1d32:	21 e0       	ldi	r18, 0x01	; 1

	return xReturn;
}
    1d34:	82 2f       	mov	r24, r18
    1d36:	08 95       	ret

00001d38 <vQueueDelete>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    1d38:	0f 93       	push	r16
    1d3a:	1f 93       	push	r17
    1d3c:	8c 01       	movw	r16, r24
	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    1d3e:	fc 01       	movw	r30, r24
    1d40:	80 81       	ld	r24, Z
    1d42:	91 81       	ldd	r25, Z+1	; 0x01
    1d44:	0e 94 f5 18 	call	0x31ea	; 0x31ea <vPortFree>
	vPortFree( pxQueue );
    1d48:	c8 01       	movw	r24, r16
    1d4a:	0e 94 f5 18 	call	0x31ea	; 0x31ea <vPortFree>
}
    1d4e:	1f 91       	pop	r17
    1d50:	0f 91       	pop	r16
    1d52:	08 95       	ret

00001d54 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    1d54:	0f 93       	push	r16
    1d56:	1f 93       	push	r17
    1d58:	cf 93       	push	r28
    1d5a:	df 93       	push	r29
    1d5c:	ec 01       	movw	r28, r24
    1d5e:	fb 01       	movw	r30, r22
    1d60:	8a 01       	movw	r16, r20
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1d62:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1d64:	88 23       	and	r24, r24
    1d66:	81 f1       	breq	.+96     	; 0x1dc8 <xQueueReceiveFromISR+0x74>
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    1d68:	48 81       	ld	r20, Y
    1d6a:	59 81       	ldd	r21, Y+1	; 0x01
    1d6c:	41 15       	cp	r20, r1
    1d6e:	51 05       	cpc	r21, r1
    1d70:	a9 f0       	breq	.+42     	; 0x1d9c <xQueueReceiveFromISR+0x48>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    1d72:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1d74:	2e 81       	ldd	r18, Y+6	; 0x06
    1d76:	3f 81       	ldd	r19, Y+7	; 0x07
    1d78:	28 0f       	add	r18, r24
    1d7a:	31 1d       	adc	r19, r1
    1d7c:	3f 83       	std	Y+7, r19	; 0x07
    1d7e:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    1d80:	8a 81       	ldd	r24, Y+2	; 0x02
    1d82:	9b 81       	ldd	r25, Y+3	; 0x03
    1d84:	28 17       	cp	r18, r24
    1d86:	39 07       	cpc	r19, r25
    1d88:	10 f0       	brcs	.+4      	; 0x1d8e <xQueueReceiveFromISR+0x3a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    1d8a:	5f 83       	std	Y+7, r21	; 0x07
    1d8c:	4e 83       	std	Y+6, r20	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1d8e:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1d90:	6e 81       	ldd	r22, Y+6	; 0x06
    1d92:	7f 81       	ldd	r23, Y+7	; 0x07
    1d94:	cf 01       	movw	r24, r30
    1d96:	50 e0       	ldi	r21, 0x00	; 0
    1d98:	0e 94 dc 2a 	call	0x55b8	; 0x55b8 <memcpy>
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
			--( pxQueue->uxMessagesWaiting );
    1d9c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1d9e:	81 50       	subi	r24, 0x01	; 1
    1da0:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1da2:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1da4:	8f 3f       	cpi	r24, 0xFF	; 255
    1da6:	69 f4       	brne	.+26     	; 0x1dc2 <xQueueReceiveFromISR+0x6e>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
    1da8:	88 85       	ldd	r24, Y+8	; 0x08
    1daa:	88 23       	and	r24, r24
    1dac:	61 f0       	breq	.+24     	; 0x1dc6 <xQueueReceiveFromISR+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1dae:	ce 01       	movw	r24, r28
    1db0:	08 96       	adiw	r24, 0x08	; 8
    1db2:	0e 94 0a 12 	call	0x2414	; 0x2414 <xTaskRemoveFromEventList>
    1db6:	88 23       	and	r24, r24
    1db8:	31 f0       	breq	.+12     	; 0x1dc6 <xQueueReceiveFromISR+0x72>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    1dba:	81 e0       	ldi	r24, 0x01	; 1
    1dbc:	f8 01       	movw	r30, r16
    1dbe:	80 83       	st	Z, r24
    1dc0:	03 c0       	rjmp	.+6      	; 0x1dc8 <xQueueReceiveFromISR+0x74>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1dc2:	8f 5f       	subi	r24, 0xFF	; 255
    1dc4:	8d 8f       	std	Y+29, r24	; 0x1d
    1dc6:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1dc8:	df 91       	pop	r29
    1dca:	cf 91       	pop	r28
    1dcc:	1f 91       	pop	r17
    1dce:	0f 91       	pop	r16
    1dd0:	08 95       	ret

00001dd2 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    1dd2:	cf 93       	push	r28
    1dd4:	df 93       	push	r29
    1dd6:	ec 01       	movw	r28, r24
    1dd8:	84 2f       	mov	r24, r20
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    1dda:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1ddc:	44 23       	and	r20, r20
    1dde:	a1 f1       	breq	.+104    	; 0x1e48 <prvCopyDataToQueue+0x76>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    1de0:	88 23       	and	r24, r24
    1de2:	b1 f4       	brne	.+44     	; 0x1e10 <prvCopyDataToQueue+0x3e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1de4:	8c 81       	ldd	r24, Y+4	; 0x04
    1de6:	9d 81       	ldd	r25, Y+5	; 0x05
    1de8:	50 e0       	ldi	r21, 0x00	; 0
    1dea:	0e 94 dc 2a 	call	0x55b8	; 0x55b8 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    1dee:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1df0:	2c 81       	ldd	r18, Y+4	; 0x04
    1df2:	3d 81       	ldd	r19, Y+5	; 0x05
    1df4:	28 0f       	add	r18, r24
    1df6:	31 1d       	adc	r19, r1
    1df8:	3d 83       	std	Y+5, r19	; 0x05
    1dfa:	2c 83       	std	Y+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    1dfc:	8a 81       	ldd	r24, Y+2	; 0x02
    1dfe:	9b 81       	ldd	r25, Y+3	; 0x03
    1e00:	28 17       	cp	r18, r24
    1e02:	39 07       	cpc	r19, r25
    1e04:	08 f1       	brcs	.+66     	; 0x1e48 <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1e06:	88 81       	ld	r24, Y
    1e08:	99 81       	ldd	r25, Y+1	; 0x01
    1e0a:	9d 83       	std	Y+5, r25	; 0x05
    1e0c:	8c 83       	std	Y+4, r24	; 0x04
    1e0e:	1c c0       	rjmp	.+56     	; 0x1e48 <prvCopyDataToQueue+0x76>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1e10:	8e 81       	ldd	r24, Y+6	; 0x06
    1e12:	9f 81       	ldd	r25, Y+7	; 0x07
    1e14:	50 e0       	ldi	r21, 0x00	; 0
    1e16:	0e 94 dc 2a 	call	0x55b8	; 0x55b8 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    1e1a:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1e1c:	90 e0       	ldi	r25, 0x00	; 0
    1e1e:	44 27       	eor	r20, r20
    1e20:	55 27       	eor	r21, r21
    1e22:	48 1b       	sub	r20, r24
    1e24:	59 0b       	sbc	r21, r25
    1e26:	8e 81       	ldd	r24, Y+6	; 0x06
    1e28:	9f 81       	ldd	r25, Y+7	; 0x07
    1e2a:	84 0f       	add	r24, r20
    1e2c:	95 1f       	adc	r25, r21
    1e2e:	9f 83       	std	Y+7, r25	; 0x07
    1e30:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    1e32:	28 81       	ld	r18, Y
    1e34:	39 81       	ldd	r19, Y+1	; 0x01
    1e36:	82 17       	cp	r24, r18
    1e38:	93 07       	cpc	r25, r19
    1e3a:	30 f4       	brcc	.+12     	; 0x1e48 <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    1e3c:	8a 81       	ldd	r24, Y+2	; 0x02
    1e3e:	9b 81       	ldd	r25, Y+3	; 0x03
    1e40:	84 0f       	add	r24, r20
    1e42:	95 1f       	adc	r25, r21
    1e44:	9f 83       	std	Y+7, r25	; 0x07
    1e46:	8e 83       	std	Y+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    1e48:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1e4a:	8f 5f       	subi	r24, 0xFF	; 255
    1e4c:	8a 8f       	std	Y+26, r24	; 0x1a
}
    1e4e:	df 91       	pop	r29
    1e50:	cf 91       	pop	r28
    1e52:	08 95       	ret

00001e54 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    1e54:	0f 93       	push	r16
    1e56:	1f 93       	push	r17
    1e58:	cf 93       	push	r28
    1e5a:	df 93       	push	r29
    1e5c:	ec 01       	movw	r28, r24
    1e5e:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1e60:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1e62:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1e64:	98 17       	cp	r25, r24
    1e66:	10 f0       	brcs	.+4      	; 0x1e6c <xQueueGenericSendFromISR+0x18>
    1e68:	80 e0       	ldi	r24, 0x00	; 0
    1e6a:	17 c0       	rjmp	.+46     	; 0x1e9a <xQueueGenericSendFromISR+0x46>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1e6c:	ce 01       	movw	r24, r28
    1e6e:	42 2f       	mov	r20, r18
    1e70:	0e 94 e9 0e 	call	0x1dd2	; 0x1dd2 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1e74:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1e76:	8f 3f       	cpi	r24, 0xFF	; 255
    1e78:	69 f4       	brne	.+26     	; 0x1e94 <xQueueGenericSendFromISR+0x40>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    1e7a:	89 89       	ldd	r24, Y+17	; 0x11
    1e7c:	88 23       	and	r24, r24
    1e7e:	61 f0       	breq	.+24     	; 0x1e98 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1e80:	ce 01       	movw	r24, r28
    1e82:	41 96       	adiw	r24, 0x11	; 17
    1e84:	0e 94 0a 12 	call	0x2414	; 0x2414 <xTaskRemoveFromEventList>
    1e88:	88 23       	and	r24, r24
    1e8a:	31 f0       	breq	.+12     	; 0x1e98 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    1e8c:	81 e0       	ldi	r24, 0x01	; 1
    1e8e:	f8 01       	movw	r30, r16
    1e90:	80 83       	st	Z, r24
    1e92:	03 c0       	rjmp	.+6      	; 0x1e9a <xQueueGenericSendFromISR+0x46>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1e94:	8f 5f       	subi	r24, 0xFF	; 255
    1e96:	8e 8f       	std	Y+30, r24	; 0x1e
    1e98:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1e9a:	df 91       	pop	r29
    1e9c:	cf 91       	pop	r28
    1e9e:	1f 91       	pop	r17
    1ea0:	0f 91       	pop	r16
    1ea2:	08 95       	ret

00001ea4 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    1ea4:	0f 93       	push	r16
    1ea6:	1f 93       	push	r17
    1ea8:	cf 93       	push	r28
    1eaa:	df 93       	push	r29
    1eac:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1eae:	0f b6       	in	r0, 0x3f	; 63
    1eb0:	f8 94       	cli
    1eb2:	0f 92       	push	r0
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1eb4:	8c 01       	movw	r16, r24
    1eb6:	0f 5e       	subi	r16, 0xEF	; 239
    1eb8:	1f 4f       	sbci	r17, 0xFF	; 255
    1eba:	0d c0       	rjmp	.+26     	; 0x1ed6 <prvUnlockQueue+0x32>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    1ebc:	89 89       	ldd	r24, Y+17	; 0x11
    1ebe:	88 23       	and	r24, r24
    1ec0:	69 f0       	breq	.+26     	; 0x1edc <prvUnlockQueue+0x38>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1ec2:	c8 01       	movw	r24, r16
    1ec4:	0e 94 0a 12 	call	0x2414	; 0x2414 <xTaskRemoveFromEventList>
    1ec8:	88 23       	and	r24, r24
    1eca:	11 f0       	breq	.+4      	; 0x1ed0 <prvUnlockQueue+0x2c>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    1ecc:	0e 94 06 12 	call	0x240c	; 0x240c <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    1ed0:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1ed2:	81 50       	subi	r24, 0x01	; 1
    1ed4:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1ed6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1ed8:	18 16       	cp	r1, r24
    1eda:	84 f3       	brlt	.-32     	; 0x1ebc <prvUnlockQueue+0x18>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    1edc:	8f ef       	ldi	r24, 0xFF	; 255
    1ede:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1ee0:	0f 90       	pop	r0
    1ee2:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1ee4:	0f b6       	in	r0, 0x3f	; 63
    1ee6:	f8 94       	cli
    1ee8:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1eea:	8e 01       	movw	r16, r28
    1eec:	08 5f       	subi	r16, 0xF8	; 248
    1eee:	1f 4f       	sbci	r17, 0xFF	; 255
    1ef0:	0d c0       	rjmp	.+26     	; 0x1f0c <prvUnlockQueue+0x68>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
    1ef2:	88 85       	ldd	r24, Y+8	; 0x08
    1ef4:	88 23       	and	r24, r24
    1ef6:	69 f0       	breq	.+26     	; 0x1f12 <prvUnlockQueue+0x6e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1ef8:	c8 01       	movw	r24, r16
    1efa:	0e 94 0a 12 	call	0x2414	; 0x2414 <xTaskRemoveFromEventList>
    1efe:	88 23       	and	r24, r24
    1f00:	11 f0       	breq	.+4      	; 0x1f06 <prvUnlockQueue+0x62>
				{
					vTaskMissedYield();
    1f02:	0e 94 06 12 	call	0x240c	; 0x240c <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    1f06:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1f08:	81 50       	subi	r24, 0x01	; 1
    1f0a:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1f0c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1f0e:	18 16       	cp	r1, r24
    1f10:	84 f3       	brlt	.-32     	; 0x1ef2 <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    1f12:	8f ef       	ldi	r24, 0xFF	; 255
    1f14:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1f16:	0f 90       	pop	r0
    1f18:	0f be       	out	0x3f, r0	; 63
}
    1f1a:	df 91       	pop	r29
    1f1c:	cf 91       	pop	r28
    1f1e:	1f 91       	pop	r17
    1f20:	0f 91       	pop	r16
    1f22:	08 95       	ret

00001f24 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    1f24:	7f 92       	push	r7
    1f26:	8f 92       	push	r8
    1f28:	9f 92       	push	r9
    1f2a:	af 92       	push	r10
    1f2c:	bf 92       	push	r11
    1f2e:	cf 92       	push	r12
    1f30:	df 92       	push	r13
    1f32:	ef 92       	push	r14
    1f34:	ff 92       	push	r15
    1f36:	0f 93       	push	r16
    1f38:	1f 93       	push	r17
    1f3a:	df 93       	push	r29
    1f3c:	cf 93       	push	r28
    1f3e:	00 d0       	rcall	.+0      	; 0x1f40 <xQueueGenericReceive+0x1c>
    1f40:	00 d0       	rcall	.+0      	; 0x1f42 <xQueueGenericReceive+0x1e>
    1f42:	0f 92       	push	r0
    1f44:	cd b7       	in	r28, 0x3d	; 61
    1f46:	de b7       	in	r29, 0x3e	; 62
    1f48:	8c 01       	movw	r16, r24
    1f4a:	96 2e       	mov	r9, r22
    1f4c:	87 2e       	mov	r8, r23
    1f4e:	5d 83       	std	Y+5, r21	; 0x05
    1f50:	4c 83       	std	Y+4, r20	; 0x04
    1f52:	72 2e       	mov	r7, r18
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1f54:	91 e1       	ldi	r25, 0x11	; 17
    1f56:	c9 2e       	mov	r12, r25
    1f58:	d1 2c       	mov	r13, r1
    1f5a:	c0 0e       	add	r12, r16
    1f5c:	d1 1e       	adc	r13, r17
    1f5e:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1f60:	7e 01       	movw	r14, r28
    1f62:	08 94       	sec
    1f64:	e1 1c       	adc	r14, r1
    1f66:	f1 1c       	adc	r15, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1f68:	84 e0       	ldi	r24, 0x04	; 4
    1f6a:	a8 2e       	mov	r10, r24
    1f6c:	b1 2c       	mov	r11, r1
    1f6e:	ac 0e       	add	r10, r28
    1f70:	bd 1e       	adc	r11, r29
    1f72:	01 c0       	rjmp	.+2      	; 0x1f76 <xQueueGenericReceive+0x52>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1f74:	21 e0       	ldi	r18, 0x01	; 1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1f76:	0f b6       	in	r0, 0x3f	; 63
    1f78:	f8 94       	cli
    1f7a:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1f7c:	f8 01       	movw	r30, r16
    1f7e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f80:	88 23       	and	r24, r24
    1f82:	09 f4       	brne	.+2      	; 0x1f86 <xQueueGenericReceive+0x62>
    1f84:	3e c0       	rjmp	.+124    	; 0x2002 <xQueueGenericReceive+0xde>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1f86:	e6 80       	ldd	r14, Z+6	; 0x06
    1f88:	f7 80       	ldd	r15, Z+7	; 0x07
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    1f8a:	40 81       	ld	r20, Z
    1f8c:	51 81       	ldd	r21, Z+1	; 0x01
    1f8e:	41 15       	cp	r20, r1
    1f90:	51 05       	cpc	r21, r1
    1f92:	b1 f0       	breq	.+44     	; 0x1fc0 <xQueueGenericReceive+0x9c>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    1f94:	84 8d       	ldd	r24, Z+28	; 0x1c
    1f96:	97 01       	movw	r18, r14
    1f98:	28 0f       	add	r18, r24
    1f9a:	31 1d       	adc	r19, r1
    1f9c:	37 83       	std	Z+7, r19	; 0x07
    1f9e:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    1fa0:	82 81       	ldd	r24, Z+2	; 0x02
    1fa2:	93 81       	ldd	r25, Z+3	; 0x03
    1fa4:	28 17       	cp	r18, r24
    1fa6:	39 07       	cpc	r19, r25
    1fa8:	10 f0       	brcs	.+4      	; 0x1fae <xQueueGenericReceive+0x8a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    1faa:	57 83       	std	Z+7, r21	; 0x07
    1fac:	46 83       	std	Z+6, r20	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1fae:	f8 01       	movw	r30, r16
    1fb0:	44 8d       	ldd	r20, Z+28	; 0x1c
    1fb2:	66 81       	ldd	r22, Z+6	; 0x06
    1fb4:	77 81       	ldd	r23, Z+7	; 0x07
    1fb6:	89 2d       	mov	r24, r9
    1fb8:	98 2d       	mov	r25, r8
    1fba:	50 e0       	ldi	r21, 0x00	; 0
    1fbc:	0e 94 dc 2a 	call	0x55b8	; 0x55b8 <memcpy>
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
    1fc0:	77 20       	and	r7, r7
    1fc2:	71 f4       	brne	.+28     	; 0x1fe0 <xQueueGenericReceive+0xbc>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1fc4:	f8 01       	movw	r30, r16
    1fc6:	82 8d       	ldd	r24, Z+26	; 0x1a
    1fc8:	81 50       	subi	r24, 0x01	; 1
    1fca:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1fcc:	80 85       	ldd	r24, Z+8	; 0x08
    1fce:	88 23       	and	r24, r24
    1fd0:	a1 f0       	breq	.+40     	; 0x1ffa <xQueueGenericReceive+0xd6>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1fd2:	c8 01       	movw	r24, r16
    1fd4:	08 96       	adiw	r24, 0x08	; 8
    1fd6:	0e 94 0a 12 	call	0x2414	; 0x2414 <xTaskRemoveFromEventList>
    1fda:	81 30       	cpi	r24, 0x01	; 1
    1fdc:	71 f4       	brne	.+28     	; 0x1ffa <xQueueGenericReceive+0xd6>
    1fde:	0b c0       	rjmp	.+22     	; 0x1ff6 <xQueueGenericReceive+0xd2>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    1fe0:	f8 01       	movw	r30, r16
    1fe2:	f7 82       	std	Z+7, r15	; 0x07
    1fe4:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    1fe6:	81 89       	ldd	r24, Z+17	; 0x11
    1fe8:	88 23       	and	r24, r24
    1fea:	39 f0       	breq	.+14     	; 0x1ffa <xQueueGenericReceive+0xd6>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1fec:	c6 01       	movw	r24, r12
    1fee:	0e 94 0a 12 	call	0x2414	; 0x2414 <xTaskRemoveFromEventList>
    1ff2:	88 23       	and	r24, r24
    1ff4:	11 f0       	breq	.+4      	; 0x1ffa <xQueueGenericReceive+0xd6>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    1ff6:	0e 94 d2 16 	call	0x2da4	; 0x2da4 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    1ffa:	0f 90       	pop	r0
    1ffc:	0f be       	out	0x3f, r0	; 63
    1ffe:	81 e0       	ldi	r24, 0x01	; 1
    2000:	4a c0       	rjmp	.+148    	; 0x2096 <xQueueGenericReceive+0x172>
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    2002:	8c 81       	ldd	r24, Y+4	; 0x04
    2004:	9d 81       	ldd	r25, Y+5	; 0x05
    2006:	89 2b       	or	r24, r25
    2008:	19 f4       	brne	.+6      	; 0x2010 <xQueueGenericReceive+0xec>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    200a:	0f 90       	pop	r0
    200c:	0f be       	out	0x3f, r0	; 63
    200e:	42 c0       	rjmp	.+132    	; 0x2094 <xQueueGenericReceive+0x170>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    2010:	22 23       	and	r18, r18
    2012:	19 f4       	brne	.+6      	; 0x201a <xQueueGenericReceive+0xf6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2014:	c7 01       	movw	r24, r14
    2016:	0e 94 c1 11 	call	0x2382	; 0x2382 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    201a:	0f 90       	pop	r0
    201c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    201e:	0e 94 65 11 	call	0x22ca	; 0x22ca <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2022:	0f b6       	in	r0, 0x3f	; 63
    2024:	f8 94       	cli
    2026:	0f 92       	push	r0
    2028:	f8 01       	movw	r30, r16
    202a:	85 8d       	ldd	r24, Z+29	; 0x1d
    202c:	8f 3f       	cpi	r24, 0xFF	; 255
    202e:	09 f4       	brne	.+2      	; 0x2032 <xQueueGenericReceive+0x10e>
    2030:	15 8e       	std	Z+29, r1	; 0x1d
    2032:	f8 01       	movw	r30, r16
    2034:	86 8d       	ldd	r24, Z+30	; 0x1e
    2036:	8f 3f       	cpi	r24, 0xFF	; 255
    2038:	09 f4       	brne	.+2      	; 0x203c <xQueueGenericReceive+0x118>
    203a:	16 8e       	std	Z+30, r1	; 0x1e
    203c:	0f 90       	pop	r0
    203e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2040:	c7 01       	movw	r24, r14
    2042:	b5 01       	movw	r22, r10
    2044:	0e 94 cc 11 	call	0x2398	; 0x2398 <xTaskCheckForTimeOut>
    2048:	88 23       	and	r24, r24
    204a:	f9 f4       	brne	.+62     	; 0x208a <xQueueGenericReceive+0x166>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    204c:	0f b6       	in	r0, 0x3f	; 63
    204e:	f8 94       	cli
    2050:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    2052:	f8 01       	movw	r30, r16
    2054:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    2056:	0f 90       	pop	r0
    2058:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
    205a:	88 23       	and	r24, r24
    205c:	81 f4       	brne	.+32     	; 0x207e <xQueueGenericReceive+0x15a>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    205e:	6c 81       	ldd	r22, Y+4	; 0x04
    2060:	7d 81       	ldd	r23, Y+5	; 0x05
    2062:	c6 01       	movw	r24, r12
    2064:	0e 94 c3 12 	call	0x2586	; 0x2586 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2068:	c8 01       	movw	r24, r16
    206a:	0e 94 52 0f 	call	0x1ea4	; 0x1ea4 <prvUnlockQueue>
				if( !xTaskResumeAll() )
    206e:	0e 94 fc 12 	call	0x25f8	; 0x25f8 <xTaskResumeAll>
    2072:	88 23       	and	r24, r24
    2074:	09 f0       	breq	.+2      	; 0x2078 <xQueueGenericReceive+0x154>
    2076:	7e cf       	rjmp	.-260    	; 0x1f74 <xQueueGenericReceive+0x50>
				{
					portYIELD_WITHIN_API();
    2078:	0e 94 d2 16 	call	0x2da4	; 0x2da4 <vPortYield>
    207c:	7b cf       	rjmp	.-266    	; 0x1f74 <xQueueGenericReceive+0x50>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    207e:	c8 01       	movw	r24, r16
    2080:	0e 94 52 0f 	call	0x1ea4	; 0x1ea4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2084:	0e 94 fc 12 	call	0x25f8	; 0x25f8 <xTaskResumeAll>
    2088:	75 cf       	rjmp	.-278    	; 0x1f74 <xQueueGenericReceive+0x50>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    208a:	c8 01       	movw	r24, r16
    208c:	0e 94 52 0f 	call	0x1ea4	; 0x1ea4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2090:	0e 94 fc 12 	call	0x25f8	; 0x25f8 <xTaskResumeAll>
    2094:	80 e0       	ldi	r24, 0x00	; 0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
    2096:	0f 90       	pop	r0
    2098:	0f 90       	pop	r0
    209a:	0f 90       	pop	r0
    209c:	0f 90       	pop	r0
    209e:	0f 90       	pop	r0
    20a0:	cf 91       	pop	r28
    20a2:	df 91       	pop	r29
    20a4:	1f 91       	pop	r17
    20a6:	0f 91       	pop	r16
    20a8:	ff 90       	pop	r15
    20aa:	ef 90       	pop	r14
    20ac:	df 90       	pop	r13
    20ae:	cf 90       	pop	r12
    20b0:	bf 90       	pop	r11
    20b2:	af 90       	pop	r10
    20b4:	9f 90       	pop	r9
    20b6:	8f 90       	pop	r8
    20b8:	7f 90       	pop	r7
    20ba:	08 95       	ret

000020bc <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    20bc:	7f 92       	push	r7
    20be:	8f 92       	push	r8
    20c0:	9f 92       	push	r9
    20c2:	af 92       	push	r10
    20c4:	bf 92       	push	r11
    20c6:	cf 92       	push	r12
    20c8:	df 92       	push	r13
    20ca:	ef 92       	push	r14
    20cc:	ff 92       	push	r15
    20ce:	0f 93       	push	r16
    20d0:	1f 93       	push	r17
    20d2:	df 93       	push	r29
    20d4:	cf 93       	push	r28
    20d6:	00 d0       	rcall	.+0      	; 0x20d8 <xQueueGenericSend+0x1c>
    20d8:	00 d0       	rcall	.+0      	; 0x20da <xQueueGenericSend+0x1e>
    20da:	0f 92       	push	r0
    20dc:	cd b7       	in	r28, 0x3d	; 61
    20de:	de b7       	in	r29, 0x3e	; 62
    20e0:	8c 01       	movw	r16, r24
    20e2:	6b 01       	movw	r12, r22
    20e4:	5d 83       	std	Y+5, r21	; 0x05
    20e6:	4c 83       	std	Y+4, r20	; 0x04
    20e8:	72 2e       	mov	r7, r18
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    20ea:	48 e0       	ldi	r20, 0x08	; 8
    20ec:	e4 2e       	mov	r14, r20
    20ee:	f1 2c       	mov	r15, r1
    20f0:	e8 0e       	add	r14, r24
    20f2:	f9 1e       	adc	r15, r25
    20f4:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    20f6:	5e 01       	movw	r10, r28
    20f8:	08 94       	sec
    20fa:	a1 1c       	adc	r10, r1
    20fc:	b1 1c       	adc	r11, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    20fe:	34 e0       	ldi	r19, 0x04	; 4
    2100:	83 2e       	mov	r8, r19
    2102:	91 2c       	mov	r9, r1
    2104:	8c 0e       	add	r8, r28
    2106:	9d 1e       	adc	r9, r29
    2108:	01 c0       	rjmp	.+2      	; 0x210c <xQueueGenericSend+0x50>
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    210a:	21 e0       	ldi	r18, 0x01	; 1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    210c:	0f b6       	in	r0, 0x3f	; 63
    210e:	f8 94       	cli
    2110:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    2112:	f8 01       	movw	r30, r16
    2114:	92 8d       	ldd	r25, Z+26	; 0x1a
    2116:	83 8d       	ldd	r24, Z+27	; 0x1b
    2118:	98 17       	cp	r25, r24
    211a:	a8 f4       	brcc	.+42     	; 0x2146 <xQueueGenericSend+0x8a>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    211c:	c8 01       	movw	r24, r16
    211e:	b6 01       	movw	r22, r12
    2120:	47 2d       	mov	r20, r7
    2122:	0e 94 e9 0e 	call	0x1dd2	; 0x1dd2 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2126:	f8 01       	movw	r30, r16
    2128:	81 89       	ldd	r24, Z+17	; 0x11
    212a:	88 23       	and	r24, r24
    212c:	41 f0       	breq	.+16     	; 0x213e <xQueueGenericSend+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    212e:	c8 01       	movw	r24, r16
    2130:	41 96       	adiw	r24, 0x11	; 17
    2132:	0e 94 0a 12 	call	0x2414	; 0x2414 <xTaskRemoveFromEventList>
    2136:	81 30       	cpi	r24, 0x01	; 1
    2138:	11 f4       	brne	.+4      	; 0x213e <xQueueGenericSend+0x82>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    213a:	0e 94 d2 16 	call	0x2da4	; 0x2da4 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    213e:	0f 90       	pop	r0
    2140:	0f be       	out	0x3f, r0	; 63
    2142:	81 e0       	ldi	r24, 0x01	; 1
    2144:	4c c0       	rjmp	.+152    	; 0x21de <xQueueGenericSend+0x122>
				function. */
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    2146:	8c 81       	ldd	r24, Y+4	; 0x04
    2148:	9d 81       	ldd	r25, Y+5	; 0x05
    214a:	89 2b       	or	r24, r25
    214c:	19 f4       	brne	.+6      	; 0x2154 <xQueueGenericSend+0x98>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    214e:	0f 90       	pop	r0
    2150:	0f be       	out	0x3f, r0	; 63
    2152:	44 c0       	rjmp	.+136    	; 0x21dc <xQueueGenericSend+0x120>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    2154:	22 23       	and	r18, r18
    2156:	19 f4       	brne	.+6      	; 0x215e <xQueueGenericSend+0xa2>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2158:	c5 01       	movw	r24, r10
    215a:	0e 94 c1 11 	call	0x2382	; 0x2382 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    215e:	0f 90       	pop	r0
    2160:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2162:	0e 94 65 11 	call	0x22ca	; 0x22ca <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2166:	0f b6       	in	r0, 0x3f	; 63
    2168:	f8 94       	cli
    216a:	0f 92       	push	r0
    216c:	f8 01       	movw	r30, r16
    216e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2170:	8f 3f       	cpi	r24, 0xFF	; 255
    2172:	09 f4       	brne	.+2      	; 0x2176 <xQueueGenericSend+0xba>
    2174:	15 8e       	std	Z+29, r1	; 0x1d
    2176:	f8 01       	movw	r30, r16
    2178:	86 8d       	ldd	r24, Z+30	; 0x1e
    217a:	8f 3f       	cpi	r24, 0xFF	; 255
    217c:	09 f4       	brne	.+2      	; 0x2180 <xQueueGenericSend+0xc4>
    217e:	16 8e       	std	Z+30, r1	; 0x1e
    2180:	0f 90       	pop	r0
    2182:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2184:	c5 01       	movw	r24, r10
    2186:	b4 01       	movw	r22, r8
    2188:	0e 94 cc 11 	call	0x2398	; 0x2398 <xTaskCheckForTimeOut>
    218c:	88 23       	and	r24, r24
    218e:	09 f5       	brne	.+66     	; 0x21d2 <xQueueGenericSend+0x116>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    2190:	0f b6       	in	r0, 0x3f	; 63
    2192:	f8 94       	cli
    2194:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    2196:	f8 01       	movw	r30, r16
    2198:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    219a:	0f 90       	pop	r0
    219c:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
    219e:	f8 01       	movw	r30, r16
    21a0:	83 8d       	ldd	r24, Z+27	; 0x1b
    21a2:	98 17       	cp	r25, r24
    21a4:	81 f4       	brne	.+32     	; 0x21c6 <xQueueGenericSend+0x10a>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    21a6:	6c 81       	ldd	r22, Y+4	; 0x04
    21a8:	7d 81       	ldd	r23, Y+5	; 0x05
    21aa:	c7 01       	movw	r24, r14
    21ac:	0e 94 c3 12 	call	0x2586	; 0x2586 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    21b0:	c8 01       	movw	r24, r16
    21b2:	0e 94 52 0f 	call	0x1ea4	; 0x1ea4 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
    21b6:	0e 94 fc 12 	call	0x25f8	; 0x25f8 <xTaskResumeAll>
    21ba:	88 23       	and	r24, r24
    21bc:	09 f0       	breq	.+2      	; 0x21c0 <xQueueGenericSend+0x104>
    21be:	a5 cf       	rjmp	.-182    	; 0x210a <xQueueGenericSend+0x4e>
				{
					portYIELD_WITHIN_API();
    21c0:	0e 94 d2 16 	call	0x2da4	; 0x2da4 <vPortYield>
    21c4:	a2 cf       	rjmp	.-188    	; 0x210a <xQueueGenericSend+0x4e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    21c6:	c8 01       	movw	r24, r16
    21c8:	0e 94 52 0f 	call	0x1ea4	; 0x1ea4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    21cc:	0e 94 fc 12 	call	0x25f8	; 0x25f8 <xTaskResumeAll>
    21d0:	9c cf       	rjmp	.-200    	; 0x210a <xQueueGenericSend+0x4e>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    21d2:	c8 01       	movw	r24, r16
    21d4:	0e 94 52 0f 	call	0x1ea4	; 0x1ea4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    21d8:	0e 94 fc 12 	call	0x25f8	; 0x25f8 <xTaskResumeAll>
    21dc:	80 e0       	ldi	r24, 0x00	; 0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
    21de:	0f 90       	pop	r0
    21e0:	0f 90       	pop	r0
    21e2:	0f 90       	pop	r0
    21e4:	0f 90       	pop	r0
    21e6:	0f 90       	pop	r0
    21e8:	cf 91       	pop	r28
    21ea:	df 91       	pop	r29
    21ec:	1f 91       	pop	r17
    21ee:	0f 91       	pop	r16
    21f0:	ff 90       	pop	r15
    21f2:	ef 90       	pop	r14
    21f4:	df 90       	pop	r13
    21f6:	cf 90       	pop	r12
    21f8:	bf 90       	pop	r11
    21fa:	af 90       	pop	r10
    21fc:	9f 90       	pop	r9
    21fe:	8f 90       	pop	r8
    2200:	7f 90       	pop	r7
    2202:	08 95       	ret

00002204 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    2204:	8f 92       	push	r8
    2206:	9f 92       	push	r9
    2208:	af 92       	push	r10
    220a:	bf 92       	push	r11
    220c:	cf 92       	push	r12
    220e:	df 92       	push	r13
    2210:	ef 92       	push	r14
    2212:	ff 92       	push	r15
    2214:	0f 93       	push	r16
    2216:	1f 93       	push	r17
    2218:	cf 93       	push	r28
    221a:	df 93       	push	r29
    221c:	98 2e       	mov	r9, r24
    221e:	86 2e       	mov	r8, r22
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    2220:	88 23       	and	r24, r24
    2222:	09 f4       	brne	.+2      	; 0x2226 <xQueueCreate+0x22>
    2224:	42 c0       	rjmp	.+132    	; 0x22aa <xQueueCreate+0xa6>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    2226:	8f e1       	ldi	r24, 0x1F	; 31
    2228:	90 e0       	ldi	r25, 0x00	; 0
    222a:	0e 94 05 19 	call	0x320a	; 0x320a <pvPortMalloc>
    222e:	8c 01       	movw	r16, r24
    2230:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    2232:	00 97       	sbiw	r24, 0x00	; 0
    2234:	e1 f1       	breq	.+120    	; 0x22ae <xQueueCreate+0xaa>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    2236:	c9 2c       	mov	r12, r9
    2238:	dd 24       	eor	r13, r13
    223a:	a8 2c       	mov	r10, r8
    223c:	bb 24       	eor	r11, r11
    223e:	ac 9c       	mul	r10, r12
    2240:	70 01       	movw	r14, r0
    2242:	ad 9c       	mul	r10, r13
    2244:	f0 0c       	add	r15, r0
    2246:	bc 9c       	mul	r11, r12
    2248:	f0 0c       	add	r15, r0
    224a:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    224c:	c7 01       	movw	r24, r14
    224e:	01 96       	adiw	r24, 0x01	; 1
    2250:	0e 94 05 19 	call	0x320a	; 0x320a <pvPortMalloc>
    2254:	9c 01       	movw	r18, r24
    2256:	99 83       	std	Y+1, r25	; 0x01
    2258:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    225a:	00 97       	sbiw	r24, 0x00	; 0
    225c:	19 f1       	breq	.+70     	; 0x22a4 <xQueueCreate+0xa0>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    225e:	e8 0e       	add	r14, r24
    2260:	f9 1e       	adc	r15, r25
    2262:	fb 82       	std	Y+3, r15	; 0x03
    2264:	ea 82       	std	Y+2, r14	; 0x02
				pxNewQueue->uxMessagesWaiting = 0;
    2266:	1a 8e       	std	Y+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    2268:	9d 83       	std	Y+5, r25	; 0x05
    226a:	8c 83       	std	Y+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
    226c:	08 94       	sec
    226e:	c1 08       	sbc	r12, r1
    2270:	d1 08       	sbc	r13, r1
    2272:	ca 9c       	mul	r12, r10
    2274:	c0 01       	movw	r24, r0
    2276:	cb 9c       	mul	r12, r11
    2278:	90 0d       	add	r25, r0
    227a:	da 9c       	mul	r13, r10
    227c:	90 0d       	add	r25, r0
    227e:	11 24       	eor	r1, r1
    2280:	28 0f       	add	r18, r24
    2282:	39 1f       	adc	r19, r25
    2284:	3f 83       	std	Y+7, r19	; 0x07
    2286:	2e 83       	std	Y+6, r18	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    2288:	9b 8e       	std	Y+27, r9	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    228a:	8c 8e       	std	Y+28, r8	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    228c:	8f ef       	ldi	r24, 0xFF	; 255
    228e:	8d 8f       	std	Y+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    2290:	8e 8f       	std	Y+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    2292:	c8 01       	movw	r24, r16
    2294:	08 96       	adiw	r24, 0x08	; 8
    2296:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    229a:	c8 01       	movw	r24, r16
    229c:	41 96       	adiw	r24, 0x11	; 17
    229e:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <vListInitialise>
    22a2:	05 c0       	rjmp	.+10     	; 0x22ae <xQueueCreate+0xaa>
				return  pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    22a4:	c8 01       	movw	r24, r16
    22a6:	0e 94 f5 18 	call	0x31ea	; 0x31ea <vPortFree>
    22aa:	c0 e0       	ldi	r28, 0x00	; 0
    22ac:	d0 e0       	ldi	r29, 0x00	; 0
	}

	/* Will only reach here if we could not allocate enough memory or no memory
	was required. */
	return NULL;
}
    22ae:	ce 01       	movw	r24, r28
    22b0:	df 91       	pop	r29
    22b2:	cf 91       	pop	r28
    22b4:	1f 91       	pop	r17
    22b6:	0f 91       	pop	r16
    22b8:	ff 90       	pop	r15
    22ba:	ef 90       	pop	r14
    22bc:	df 90       	pop	r13
    22be:	cf 90       	pop	r12
    22c0:	bf 90       	pop	r11
    22c2:	af 90       	pop	r10
    22c4:	9f 90       	pop	r9
    22c6:	8f 90       	pop	r8
    22c8:	08 95       	ret

000022ca <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    22ca:	80 91 24 03 	lds	r24, 0x0324
    22ce:	8f 5f       	subi	r24, 0xFF	; 255
    22d0:	80 93 24 03 	sts	0x0324, r24
}
    22d4:	08 95       	ret

000022d6 <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portENTER_CRITICAL();
    22d6:	0f b6       	in	r0, 0x3f	; 63
    22d8:	f8 94       	cli
    22da:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    22dc:	20 91 22 03 	lds	r18, 0x0322
    22e0:	30 91 23 03 	lds	r19, 0x0323
	}
	portEXIT_CRITICAL();
    22e4:	0f 90       	pop	r0
    22e6:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    22e8:	c9 01       	movw	r24, r18
    22ea:	08 95       	ret

000022ec <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
	return xTickCount;
    22ec:	20 91 22 03 	lds	r18, 0x0322
    22f0:	30 91 23 03 	lds	r19, 0x0323
}
    22f4:	c9 01       	movw	r24, r18
    22f6:	08 95       	ret

000022f8 <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    22f8:	80 91 27 03 	lds	r24, 0x0327
}
    22fc:	08 95       	ret

000022fe <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    22fe:	80 91 24 03 	lds	r24, 0x0324
    2302:	88 23       	and	r24, r24
    2304:	51 f0       	breq	.+20     	; 0x231a <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2306:	81 e0       	ldi	r24, 0x01	; 1
    2308:	80 93 20 03 	sts	0x0320, r24
    230c:	08 95       	ret
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
	{
		--uxTopReadyPriority;
    230e:	80 91 25 03 	lds	r24, 0x0325
    2312:	81 50       	subi	r24, 0x01	; 1
    2314:	80 93 25 03 	sts	0x0325, r24
    2318:	01 c0       	rjmp	.+2      	; 0x231c <vTaskSwitchContext+0x1e>

	taskFIRST_CHECK_FOR_STACK_OVERFLOW();
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    231a:	99 e0       	ldi	r25, 0x09	; 9
    231c:	e0 91 25 03 	lds	r30, 0x0325
    2320:	e9 9f       	mul	r30, r25
    2322:	f0 01       	movw	r30, r0
    2324:	11 24       	eor	r1, r1
    2326:	e4 5d       	subi	r30, 0xD4	; 212
    2328:	fc 4f       	sbci	r31, 0xFC	; 252
    232a:	80 81       	ld	r24, Z
    232c:	88 23       	and	r24, r24
    232e:	79 f3       	breq	.-34     	; 0x230e <vTaskSwitchContext+0x10>
		--uxTopReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2330:	90 91 25 03 	lds	r25, 0x0325
    2334:	89 e0       	ldi	r24, 0x09	; 9
    2336:	98 9f       	mul	r25, r24
    2338:	d0 01       	movw	r26, r0
    233a:	11 24       	eor	r1, r1
    233c:	a4 5d       	subi	r26, 0xD4	; 212
    233e:	bc 4f       	sbci	r27, 0xFC	; 252
    2340:	11 96       	adiw	r26, 0x01	; 1
    2342:	ed 91       	ld	r30, X+
    2344:	fc 91       	ld	r31, X
    2346:	12 97       	sbiw	r26, 0x02	; 2
    2348:	02 80       	ldd	r0, Z+2	; 0x02
    234a:	f3 81       	ldd	r31, Z+3	; 0x03
    234c:	e0 2d       	mov	r30, r0
    234e:	12 96       	adiw	r26, 0x02	; 2
    2350:	fc 93       	st	X, r31
    2352:	ee 93       	st	-X, r30
    2354:	11 97       	sbiw	r26, 0x01	; 1
    2356:	cd 01       	movw	r24, r26
    2358:	03 96       	adiw	r24, 0x03	; 3
    235a:	e8 17       	cp	r30, r24
    235c:	f9 07       	cpc	r31, r25
    235e:	31 f4       	brne	.+12     	; 0x236c <vTaskSwitchContext+0x6e>
    2360:	82 81       	ldd	r24, Z+2	; 0x02
    2362:	93 81       	ldd	r25, Z+3	; 0x03
    2364:	12 96       	adiw	r26, 0x02	; 2
    2366:	9c 93       	st	X, r25
    2368:	8e 93       	st	-X, r24
    236a:	11 97       	sbiw	r26, 0x01	; 1
    236c:	11 96       	adiw	r26, 0x01	; 1
    236e:	ed 91       	ld	r30, X+
    2370:	fc 91       	ld	r31, X
    2372:	12 97       	sbiw	r26, 0x02	; 2
    2374:	86 81       	ldd	r24, Z+6	; 0x06
    2376:	97 81       	ldd	r25, Z+7	; 0x07
    2378:	90 93 1f 03 	sts	0x031F, r25
    237c:	80 93 1e 03 	sts	0x031E, r24
    2380:	08 95       	ret

00002382 <vTaskSetTimeOutState>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    2382:	fc 01       	movw	r30, r24
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2384:	80 91 21 03 	lds	r24, 0x0321
    2388:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    238a:	80 91 22 03 	lds	r24, 0x0322
    238e:	90 91 23 03 	lds	r25, 0x0323
    2392:	92 83       	std	Z+2, r25	; 0x02
    2394:	81 83       	std	Z+1, r24	; 0x01
}
    2396:	08 95       	ret

00002398 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    2398:	fc 01       	movw	r30, r24
    239a:	db 01       	movw	r26, r22
portBASE_TYPE xReturn;

	portENTER_CRITICAL();
    239c:	0f b6       	in	r0, 0x3f	; 63
    239e:	f8 94       	cli
    23a0:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    23a2:	90 91 21 03 	lds	r25, 0x0321
    23a6:	80 81       	ld	r24, Z
    23a8:	98 17       	cp	r25, r24
    23aa:	49 f0       	breq	.+18     	; 0x23be <xTaskCheckForTimeOut+0x26>
    23ac:	20 91 22 03 	lds	r18, 0x0322
    23b0:	30 91 23 03 	lds	r19, 0x0323
    23b4:	81 81       	ldd	r24, Z+1	; 0x01
    23b6:	92 81       	ldd	r25, Z+2	; 0x02
    23b8:	28 17       	cp	r18, r24
    23ba:	39 07       	cpc	r19, r25
    23bc:	18 f5       	brcc	.+70     	; 0x2404 <xTaskCheckForTimeOut+0x6c>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    23be:	80 91 22 03 	lds	r24, 0x0322
    23c2:	90 91 23 03 	lds	r25, 0x0323
    23c6:	21 81       	ldd	r18, Z+1	; 0x01
    23c8:	32 81       	ldd	r19, Z+2	; 0x02
    23ca:	4d 91       	ld	r20, X+
    23cc:	5c 91       	ld	r21, X
    23ce:	11 97       	sbiw	r26, 0x01	; 1
    23d0:	82 1b       	sub	r24, r18
    23d2:	93 0b       	sbc	r25, r19
    23d4:	84 17       	cp	r24, r20
    23d6:	95 07       	cpc	r25, r21
    23d8:	a8 f4       	brcc	.+42     	; 0x2404 <xTaskCheckForTimeOut+0x6c>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    23da:	80 91 22 03 	lds	r24, 0x0322
    23de:	90 91 23 03 	lds	r25, 0x0323
    23e2:	28 1b       	sub	r18, r24
    23e4:	39 0b       	sbc	r19, r25
    23e6:	24 0f       	add	r18, r20
    23e8:	35 1f       	adc	r19, r21
    23ea:	2d 93       	st	X+, r18
    23ec:	3c 93       	st	X, r19
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    23ee:	80 91 21 03 	lds	r24, 0x0321
    23f2:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    23f4:	80 91 22 03 	lds	r24, 0x0322
    23f8:	90 91 23 03 	lds	r25, 0x0323
    23fc:	92 83       	std	Z+2, r25	; 0x02
    23fe:	81 83       	std	Z+1, r24	; 0x01
    2400:	80 e0       	ldi	r24, 0x00	; 0
    2402:	01 c0       	rjmp	.+2      	; 0x2406 <xTaskCheckForTimeOut+0x6e>
    2404:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			xReturn = pdTRUE;
		}
	}
	portEXIT_CRITICAL();
    2406:	0f 90       	pop	r0
    2408:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    240a:	08 95       	ret

0000240c <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    240c:	81 e0       	ldi	r24, 0x01	; 1
    240e:	80 93 20 03 	sts	0x0320, r24
}
    2412:	08 95       	ret

00002414 <xTaskRemoveFromEventList>:
	#endif
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2414:	0f 93       	push	r16
    2416:	1f 93       	push	r17
    2418:	cf 93       	push	r28
    241a:	df 93       	push	r29
    241c:	fc 01       	movw	r30, r24
	it to the ready list.

	If an event is for a queue that is locked then this function will never
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    241e:	80 81       	ld	r24, Z
    2420:	88 23       	and	r24, r24
    2422:	19 f4       	brne	.+6      	; 0x242a <xTaskRemoveFromEventList+0x16>
    2424:	c0 e0       	ldi	r28, 0x00	; 0
    2426:	d0 e0       	ldi	r29, 0x00	; 0
    2428:	05 c0       	rjmp	.+10     	; 0x2434 <xTaskRemoveFromEventList+0x20>
    242a:	05 80       	ldd	r0, Z+5	; 0x05
    242c:	f6 81       	ldd	r31, Z+6	; 0x06
    242e:	e0 2d       	mov	r30, r0
    2430:	c6 81       	ldd	r28, Z+6	; 0x06
    2432:	d7 81       	ldd	r29, Z+7	; 0x07
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2434:	8e 01       	movw	r16, r28
    2436:	04 5f       	subi	r16, 0xF4	; 244
    2438:	1f 4f       	sbci	r17, 0xFF	; 255
    243a:	c8 01       	movw	r24, r16
    243c:	0e 94 58 0e 	call	0x1cb0	; 0x1cb0 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2440:	80 91 24 03 	lds	r24, 0x0324
    2444:	88 23       	and	r24, r24
    2446:	a1 f4       	brne	.+40     	; 0x2470 <xTaskRemoveFromEventList+0x5c>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2448:	8e 01       	movw	r16, r28
    244a:	0e 5f       	subi	r16, 0xFE	; 254
    244c:	1f 4f       	sbci	r17, 0xFF	; 255
    244e:	c8 01       	movw	r24, r16
    2450:	0e 94 58 0e 	call	0x1cb0	; 0x1cb0 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2454:	9e 89       	ldd	r25, Y+22	; 0x16
    2456:	80 91 25 03 	lds	r24, 0x0325
    245a:	89 17       	cp	r24, r25
    245c:	10 f4       	brcc	.+4      	; 0x2462 <xTaskRemoveFromEventList+0x4e>
    245e:	90 93 25 03 	sts	0x0325, r25
    2462:	89 e0       	ldi	r24, 0x09	; 9
    2464:	98 9f       	mul	r25, r24
    2466:	c0 01       	movw	r24, r0
    2468:	11 24       	eor	r1, r1
    246a:	84 5d       	subi	r24, 0xD4	; 212
    246c:	9c 4f       	sbci	r25, 0xFC	; 252
    246e:	02 c0       	rjmp	.+4      	; 0x2474 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2470:	86 e6       	ldi	r24, 0x66	; 102
    2472:	93 e0       	ldi	r25, 0x03	; 3
    2474:	b8 01       	movw	r22, r16
    2476:	0e 94 fa 0d 	call	0x1bf4	; 0x1bf4 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    247a:	e0 91 1e 03 	lds	r30, 0x031E
    247e:	f0 91 1f 03 	lds	r31, 0x031F
    2482:	20 e0       	ldi	r18, 0x00	; 0
    2484:	9e 89       	ldd	r25, Y+22	; 0x16
    2486:	86 89       	ldd	r24, Z+22	; 0x16
    2488:	98 17       	cp	r25, r24
    248a:	08 f0       	brcs	.+2      	; 0x248e <xTaskRemoveFromEventList+0x7a>
    248c:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    248e:	82 2f       	mov	r24, r18
    2490:	df 91       	pop	r29
    2492:	cf 91       	pop	r28
    2494:	1f 91       	pop	r17
    2496:	0f 91       	pop	r16
    2498:	08 95       	ret

0000249a <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
    249a:	ff 92       	push	r15
    249c:	0f 93       	push	r16
    249e:	1f 93       	push	r17
    24a0:	cf 93       	push	r28
    24a2:	df 93       	push	r29
	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    24a4:	80 91 24 03 	lds	r24, 0x0324
    24a8:	88 23       	and	r24, r24
    24aa:	09 f0       	breq	.+2      	; 0x24ae <vTaskIncrementTick+0x14>
    24ac:	61 c0       	rjmp	.+194    	; 0x2570 <vTaskIncrementTick+0xd6>
	{
		++xTickCount;
    24ae:	80 91 22 03 	lds	r24, 0x0322
    24b2:	90 91 23 03 	lds	r25, 0x0323
    24b6:	01 96       	adiw	r24, 0x01	; 1
    24b8:	90 93 23 03 	sts	0x0323, r25
    24bc:	80 93 22 03 	sts	0x0322, r24
		if( xTickCount == ( portTickType ) 0 )
    24c0:	80 91 22 03 	lds	r24, 0x0322
    24c4:	90 91 23 03 	lds	r25, 0x0323
    24c8:	89 2b       	or	r24, r25
    24ca:	e9 f5       	brne	.+122    	; 0x2546 <vTaskIncrementTick+0xac>
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			pxTemp = pxDelayedTaskList;
    24cc:	80 91 62 03 	lds	r24, 0x0362
    24d0:	90 91 63 03 	lds	r25, 0x0363
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    24d4:	20 91 64 03 	lds	r18, 0x0364
    24d8:	30 91 65 03 	lds	r19, 0x0365
    24dc:	30 93 63 03 	sts	0x0363, r19
    24e0:	20 93 62 03 	sts	0x0362, r18
			pxOverflowDelayedTaskList = pxTemp;
    24e4:	90 93 65 03 	sts	0x0365, r25
    24e8:	80 93 64 03 	sts	0x0364, r24
			xNumOfOverflows++;
    24ec:	80 91 21 03 	lds	r24, 0x0321
    24f0:	8f 5f       	subi	r24, 0xFF	; 255
    24f2:	80 93 21 03 	sts	0x0321, r24
    24f6:	27 c0       	rjmp	.+78     	; 0x2546 <vTaskIncrementTick+0xac>
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    24f8:	20 91 22 03 	lds	r18, 0x0322
    24fc:	30 91 23 03 	lds	r19, 0x0323
    2500:	8a 81       	ldd	r24, Y+2	; 0x02
    2502:	9b 81       	ldd	r25, Y+3	; 0x03
    2504:	28 17       	cp	r18, r24
    2506:	39 07       	cpc	r19, r25
    2508:	c0 f1       	brcs	.+112    	; 0x257a <vTaskIncrementTick+0xe0>
    250a:	8e 01       	movw	r16, r28
    250c:	0e 5f       	subi	r16, 0xFE	; 254
    250e:	1f 4f       	sbci	r17, 0xFF	; 255
    2510:	c8 01       	movw	r24, r16
    2512:	0e 94 58 0e 	call	0x1cb0	; 0x1cb0 <vListRemove>
    2516:	8c 89       	ldd	r24, Y+20	; 0x14
    2518:	9d 89       	ldd	r25, Y+21	; 0x15
    251a:	89 2b       	or	r24, r25
    251c:	21 f0       	breq	.+8      	; 0x2526 <vTaskIncrementTick+0x8c>
    251e:	ce 01       	movw	r24, r28
    2520:	0c 96       	adiw	r24, 0x0c	; 12
    2522:	0e 94 58 0e 	call	0x1cb0	; 0x1cb0 <vListRemove>
    2526:	9e 89       	ldd	r25, Y+22	; 0x16
    2528:	80 91 25 03 	lds	r24, 0x0325
    252c:	89 17       	cp	r24, r25
    252e:	10 f4       	brcc	.+4      	; 0x2534 <vTaskIncrementTick+0x9a>
    2530:	90 93 25 03 	sts	0x0325, r25
    2534:	9f 9d       	mul	r25, r15
    2536:	c0 01       	movw	r24, r0
    2538:	11 24       	eor	r1, r1
    253a:	84 5d       	subi	r24, 0xD4	; 212
    253c:	9c 4f       	sbci	r25, 0xFC	; 252
    253e:	b8 01       	movw	r22, r16
    2540:	0e 94 fa 0d 	call	0x1bf4	; 0x1bf4 <vListInsertEnd>
    2544:	02 c0       	rjmp	.+4      	; 0x254a <vTaskIncrementTick+0xb0>
    2546:	89 e0       	ldi	r24, 0x09	; 9
    2548:	f8 2e       	mov	r15, r24
    254a:	e0 91 62 03 	lds	r30, 0x0362
    254e:	f0 91 63 03 	lds	r31, 0x0363
    2552:	80 81       	ld	r24, Z
    2554:	88 23       	and	r24, r24
    2556:	89 f0       	breq	.+34     	; 0x257a <vTaskIncrementTick+0xe0>
    2558:	e0 91 62 03 	lds	r30, 0x0362
    255c:	f0 91 63 03 	lds	r31, 0x0363
    2560:	05 80       	ldd	r0, Z+5	; 0x05
    2562:	f6 81       	ldd	r31, Z+6	; 0x06
    2564:	e0 2d       	mov	r30, r0
    2566:	c6 81       	ldd	r28, Z+6	; 0x06
    2568:	d7 81       	ldd	r29, Z+7	; 0x07
    256a:	20 97       	sbiw	r28, 0x00	; 0
    256c:	29 f6       	brne	.-118    	; 0x24f8 <vTaskIncrementTick+0x5e>
    256e:	05 c0       	rjmp	.+10     	; 0x257a <vTaskIncrementTick+0xe0>
	}
	else
	{
		++uxMissedTicks;
    2570:	80 91 26 03 	lds	r24, 0x0326
    2574:	8f 5f       	subi	r24, 0xFF	; 255
    2576:	80 93 26 03 	sts	0x0326, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    257a:	df 91       	pop	r29
    257c:	cf 91       	pop	r28
    257e:	1f 91       	pop	r17
    2580:	0f 91       	pop	r16
    2582:	ff 90       	pop	r15
    2584:	08 95       	ret

00002586 <vTaskPlaceOnEventList>:
	vWriteTraceToBuffer();
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2586:	0f 93       	push	r16
    2588:	1f 93       	push	r17
    258a:	8b 01       	movw	r16, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    258c:	60 91 1e 03 	lds	r22, 0x031E
    2590:	70 91 1f 03 	lds	r23, 0x031F
    2594:	64 5f       	subi	r22, 0xF4	; 244
    2596:	7f 4f       	sbci	r23, 0xFF	; 255
    2598:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    259c:	80 91 1e 03 	lds	r24, 0x031E
    25a0:	90 91 1f 03 	lds	r25, 0x031F
    25a4:	02 96       	adiw	r24, 0x02	; 2
    25a6:	0e 94 58 0e 	call	0x1cb0	; 0x1cb0 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    25aa:	80 91 22 03 	lds	r24, 0x0322
    25ae:	90 91 23 03 	lds	r25, 0x0323
    25b2:	80 0f       	add	r24, r16
    25b4:	91 1f       	adc	r25, r17

			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    25b6:	e0 91 1e 03 	lds	r30, 0x031E
    25ba:	f0 91 1f 03 	lds	r31, 0x031F
    25be:	93 83       	std	Z+3, r25	; 0x03
    25c0:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xTickCount )
    25c2:	20 91 22 03 	lds	r18, 0x0322
    25c6:	30 91 23 03 	lds	r19, 0x0323
    25ca:	82 17       	cp	r24, r18
    25cc:	93 07       	cpc	r25, r19
    25ce:	28 f4       	brcc	.+10     	; 0x25da <vTaskPlaceOnEventList+0x54>
			{
				/* Wake time has overflowed.  Place this item in the overflow list. */
				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    25d0:	80 91 64 03 	lds	r24, 0x0364
    25d4:	90 91 65 03 	lds	r25, 0x0365
    25d8:	04 c0       	rjmp	.+8      	; 0x25e2 <vTaskPlaceOnEventList+0x5c>
			}
			else
			{
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    25da:	80 91 62 03 	lds	r24, 0x0362
    25de:	90 91 63 03 	lds	r25, 0x0363
    25e2:	60 91 1e 03 	lds	r22, 0x031E
    25e6:	70 91 1f 03 	lds	r23, 0x031F
    25ea:	6e 5f       	subi	r22, 0xFE	; 254
    25ec:	7f 4f       	sbci	r23, 0xFF	; 255
    25ee:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <vListInsert>
			}
	}
	#endif
}
    25f2:	1f 91       	pop	r17
    25f4:	0f 91       	pop	r16
    25f6:	08 95       	ret

000025f8 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    25f8:	cf 92       	push	r12
    25fa:	df 92       	push	r13
    25fc:	ff 92       	push	r15
    25fe:	0f 93       	push	r16
    2600:	1f 93       	push	r17
    2602:	df 93       	push	r29
    2604:	cf 93       	push	r28
    2606:	0f 92       	push	r0
    2608:	cd b7       	in	r28, 0x3d	; 61
    260a:	de b7       	in	r29, 0x3e	; 62
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	portENTER_CRITICAL();
    260c:	0f b6       	in	r0, 0x3f	; 63
    260e:	f8 94       	cli
    2610:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2612:	80 91 24 03 	lds	r24, 0x0324
    2616:	81 50       	subi	r24, 0x01	; 1
    2618:	80 93 24 03 	sts	0x0324, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    261c:	80 91 24 03 	lds	r24, 0x0324
    2620:	88 23       	and	r24, r24
    2622:	09 f0       	breq	.+2      	; 0x2626 <xTaskResumeAll+0x2e>
    2624:	5b c0       	rjmp	.+182    	; 0x26dc <xTaskResumeAll+0xe4>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
    2626:	80 91 27 03 	lds	r24, 0x0327
    262a:	88 23       	and	r24, r24
    262c:	09 f4       	brne	.+2      	; 0x2630 <xTaskResumeAll+0x38>
    262e:	56 c0       	rjmp	.+172    	; 0x26dc <xTaskResumeAll+0xe4>
    2630:	19 82       	std	Y+1, r1	; 0x01
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    2632:	99 e0       	ldi	r25, 0x09	; 9
    2634:	f9 2e       	mov	r15, r25
    2636:	27 c0       	rjmp	.+78     	; 0x2686 <xTaskResumeAll+0x8e>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
    2638:	c6 01       	movw	r24, r12
    263a:	0c 96       	adiw	r24, 0x0c	; 12
    263c:	0e 94 58 0e 	call	0x1cb0	; 0x1cb0 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    2640:	86 01       	movw	r16, r12
    2642:	0e 5f       	subi	r16, 0xFE	; 254
    2644:	1f 4f       	sbci	r17, 0xFF	; 255
    2646:	c8 01       	movw	r24, r16
    2648:	0e 94 58 0e 	call	0x1cb0	; 0x1cb0 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    264c:	d6 01       	movw	r26, r12
    264e:	56 96       	adiw	r26, 0x16	; 22
    2650:	9c 91       	ld	r25, X
    2652:	80 91 25 03 	lds	r24, 0x0325
    2656:	89 17       	cp	r24, r25
    2658:	10 f4       	brcc	.+4      	; 0x265e <xTaskResumeAll+0x66>
    265a:	90 93 25 03 	sts	0x0325, r25
    265e:	9f 9d       	mul	r25, r15
    2660:	c0 01       	movw	r24, r0
    2662:	11 24       	eor	r1, r1
    2664:	84 5d       	subi	r24, 0xD4	; 212
    2666:	9c 4f       	sbci	r25, 0xFC	; 252
    2668:	b8 01       	movw	r22, r16
    266a:	0e 94 fa 0d 	call	0x1bf4	; 0x1bf4 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    266e:	e0 91 1e 03 	lds	r30, 0x031E
    2672:	f0 91 1f 03 	lds	r31, 0x031F
    2676:	d6 01       	movw	r26, r12
    2678:	56 96       	adiw	r26, 0x16	; 22
    267a:	9c 91       	ld	r25, X
    267c:	86 89       	ldd	r24, Z+22	; 0x16
    267e:	98 17       	cp	r25, r24
    2680:	10 f0       	brcs	.+4      	; 0x2686 <xTaskResumeAll+0x8e>
    2682:	b1 e0       	ldi	r27, 0x01	; 1
    2684:	b9 83       	std	Y+1, r27	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
    2686:	80 91 66 03 	lds	r24, 0x0366
    268a:	88 23       	and	r24, r24
    268c:	49 f0       	breq	.+18     	; 0x26a0 <xTaskResumeAll+0xa8>
    268e:	e0 91 6b 03 	lds	r30, 0x036B
    2692:	f0 91 6c 03 	lds	r31, 0x036C
    2696:	c6 80       	ldd	r12, Z+6	; 0x06
    2698:	d7 80       	ldd	r13, Z+7	; 0x07
    269a:	c1 14       	cp	r12, r1
    269c:	d1 04       	cpc	r13, r1
    269e:	61 f6       	brne	.-104    	; 0x2638 <xTaskResumeAll+0x40>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    26a0:	80 91 26 03 	lds	r24, 0x0326
    26a4:	88 23       	and	r24, r24
    26a6:	41 f4       	brne	.+16     	; 0x26b8 <xTaskResumeAll+0xc0>
    26a8:	0c c0       	rjmp	.+24     	; 0x26c2 <xTaskResumeAll+0xca>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
    26aa:	0e 94 4d 12 	call	0x249a	; 0x249a <vTaskIncrementTick>
						--uxMissedTicks;
    26ae:	80 91 26 03 	lds	r24, 0x0326
    26b2:	81 50       	subi	r24, 0x01	; 1
    26b4:	80 93 26 03 	sts	0x0326, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    26b8:	80 91 26 03 	lds	r24, 0x0326
    26bc:	88 23       	and	r24, r24
    26be:	a9 f7       	brne	.-22     	; 0x26aa <xTaskResumeAll+0xb2>
    26c0:	07 c0       	rjmp	.+14     	; 0x26d0 <xTaskResumeAll+0xd8>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    26c2:	e9 81       	ldd	r30, Y+1	; 0x01
    26c4:	e1 30       	cpi	r30, 0x01	; 1
    26c6:	21 f0       	breq	.+8      	; 0x26d0 <xTaskResumeAll+0xd8>
    26c8:	80 91 20 03 	lds	r24, 0x0320
    26cc:	81 30       	cpi	r24, 0x01	; 1
    26ce:	31 f4       	brne	.+12     	; 0x26dc <xTaskResumeAll+0xe4>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    26d0:	10 92 20 03 	sts	0x0320, r1
					portYIELD_WITHIN_API();
    26d4:	0e 94 d2 16 	call	0x2da4	; 0x2da4 <vPortYield>
    26d8:	81 e0       	ldi	r24, 0x01	; 1
    26da:	01 c0       	rjmp	.+2      	; 0x26de <xTaskResumeAll+0xe6>
    26dc:	80 e0       	ldi	r24, 0x00	; 0
				}
			}
		}
	}
	portEXIT_CRITICAL();
    26de:	0f 90       	pop	r0
    26e0:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    26e2:	0f 90       	pop	r0
    26e4:	cf 91       	pop	r28
    26e6:	df 91       	pop	r29
    26e8:	1f 91       	pop	r17
    26ea:	0f 91       	pop	r16
    26ec:	ff 90       	pop	r15
    26ee:	df 90       	pop	r13
    26f0:	cf 90       	pop	r12
    26f2:	08 95       	ret

000026f4 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    26f4:	0f 93       	push	r16
    26f6:	1f 93       	push	r17
    26f8:	9c 01       	movw	r18, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
    26fa:	00 97       	sbiw	r24, 0x00	; 0
    26fc:	a1 f1       	breq	.+104    	; 0x2766 <vTaskDelay+0x72>

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    26fe:	80 91 24 03 	lds	r24, 0x0324
    2702:	8f 5f       	subi	r24, 0xFF	; 255
    2704:	80 93 24 03 	sts	0x0324, r24
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2708:	00 91 22 03 	lds	r16, 0x0322
    270c:	10 91 23 03 	lds	r17, 0x0323
    2710:	02 0f       	add	r16, r18
    2712:	13 1f       	adc	r17, r19

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2714:	80 91 1e 03 	lds	r24, 0x031E
    2718:	90 91 1f 03 	lds	r25, 0x031F
    271c:	02 96       	adiw	r24, 0x02	; 2
    271e:	0e 94 58 0e 	call	0x1cb0	; 0x1cb0 <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    2722:	e0 91 1e 03 	lds	r30, 0x031E
    2726:	f0 91 1f 03 	lds	r31, 0x031F
    272a:	13 83       	std	Z+3, r17	; 0x03
    272c:	02 83       	std	Z+2, r16	; 0x02

				if( xTimeToWake < xTickCount )
    272e:	80 91 22 03 	lds	r24, 0x0322
    2732:	90 91 23 03 	lds	r25, 0x0323
    2736:	08 17       	cp	r16, r24
    2738:	19 07       	cpc	r17, r25
    273a:	28 f4       	brcc	.+10     	; 0x2746 <vTaskDelay+0x52>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    273c:	80 91 64 03 	lds	r24, 0x0364
    2740:	90 91 65 03 	lds	r25, 0x0365
    2744:	04 c0       	rjmp	.+8      	; 0x274e <vTaskDelay+0x5a>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2746:	80 91 62 03 	lds	r24, 0x0362
    274a:	90 91 63 03 	lds	r25, 0x0363
    274e:	60 91 1e 03 	lds	r22, 0x031E
    2752:	70 91 1f 03 	lds	r23, 0x031F
    2756:	6e 5f       	subi	r22, 0xFE	; 254
    2758:	7f 4f       	sbci	r23, 0xFF	; 255
    275a:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <vListInsert>
				}
			}
			xAlreadyYielded = xTaskResumeAll();
    275e:	0e 94 fc 12 	call	0x25f8	; 0x25f8 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
    2762:	88 23       	and	r24, r24
    2764:	11 f4       	brne	.+4      	; 0x276a <vTaskDelay+0x76>
		{
			portYIELD_WITHIN_API();
    2766:	0e 94 d2 16 	call	0x2da4	; 0x2da4 <vPortYield>
		}
	}
    276a:	1f 91       	pop	r17
    276c:	0f 91       	pop	r16
    276e:	08 95       	ret

00002770 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    2770:	cf 93       	push	r28
    2772:	df 93       	push	r29
    2774:	fc 01       	movw	r30, r24
    2776:	eb 01       	movw	r28, r22

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    2778:	80 91 24 03 	lds	r24, 0x0324
    277c:	8f 5f       	subi	r24, 0xFF	; 255
    277e:	80 93 24 03 	sts	0x0324, r24
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		vTaskSuspendAll();
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2782:	20 81       	ld	r18, Z
    2784:	31 81       	ldd	r19, Z+1	; 0x01
    2786:	c2 0f       	add	r28, r18
    2788:	d3 1f       	adc	r29, r19

			if( xTickCount < *pxPreviousWakeTime )
    278a:	80 91 22 03 	lds	r24, 0x0322
    278e:	90 91 23 03 	lds	r25, 0x0323
    2792:	82 17       	cp	r24, r18
    2794:	93 07       	cpc	r25, r19
    2796:	28 f4       	brcc	.+10     	; 0x27a2 <vTaskDelayUntil+0x32>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    2798:	c2 17       	cp	r28, r18
    279a:	d3 07       	cpc	r29, r19
    279c:	28 f0       	brcs	.+10     	; 0x27a8 <vTaskDelayUntil+0x38>
    279e:	20 e0       	ldi	r18, 0x00	; 0
    27a0:	0c c0       	rjmp	.+24     	; 0x27ba <vTaskDelayUntil+0x4a>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    27a2:	c2 17       	cp	r28, r18
    27a4:	d3 07       	cpc	r29, r19
    27a6:	40 f0       	brcs	.+16     	; 0x27b8 <vTaskDelayUntil+0x48>
    27a8:	80 91 22 03 	lds	r24, 0x0322
    27ac:	90 91 23 03 	lds	r25, 0x0323
    27b0:	20 e0       	ldi	r18, 0x00	; 0
    27b2:	8c 17       	cp	r24, r28
    27b4:	9d 07       	cpc	r25, r29
    27b6:	08 f4       	brcc	.+2      	; 0x27ba <vTaskDelayUntil+0x4a>
    27b8:	21 e0       	ldi	r18, 0x01	; 1
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    27ba:	d1 83       	std	Z+1, r29	; 0x01
    27bc:	c0 83       	st	Z, r28

			if( xShouldDelay )
    27be:	22 23       	and	r18, r18
    27c0:	29 f1       	breq	.+74     	; 0x280c <vTaskDelayUntil+0x9c>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    27c2:	80 91 1e 03 	lds	r24, 0x031E
    27c6:	90 91 1f 03 	lds	r25, 0x031F
    27ca:	02 96       	adiw	r24, 0x02	; 2
    27cc:	0e 94 58 0e 	call	0x1cb0	; 0x1cb0 <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    27d0:	e0 91 1e 03 	lds	r30, 0x031E
    27d4:	f0 91 1f 03 	lds	r31, 0x031F
    27d8:	d3 83       	std	Z+3, r29	; 0x03
    27da:	c2 83       	std	Z+2, r28	; 0x02

				if( xTimeToWake < xTickCount )
    27dc:	80 91 22 03 	lds	r24, 0x0322
    27e0:	90 91 23 03 	lds	r25, 0x0323
    27e4:	c8 17       	cp	r28, r24
    27e6:	d9 07       	cpc	r29, r25
    27e8:	28 f4       	brcc	.+10     	; 0x27f4 <vTaskDelayUntil+0x84>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    27ea:	80 91 64 03 	lds	r24, 0x0364
    27ee:	90 91 65 03 	lds	r25, 0x0365
    27f2:	04 c0       	rjmp	.+8      	; 0x27fc <vTaskDelayUntil+0x8c>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    27f4:	80 91 62 03 	lds	r24, 0x0362
    27f8:	90 91 63 03 	lds	r25, 0x0363
    27fc:	60 91 1e 03 	lds	r22, 0x031E
    2800:	70 91 1f 03 	lds	r23, 0x031F
    2804:	6e 5f       	subi	r22, 0xFE	; 254
    2806:	7f 4f       	sbci	r23, 0xFF	; 255
    2808:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <vListInsert>
				}
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    280c:	0e 94 fc 12 	call	0x25f8	; 0x25f8 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
    2810:	88 23       	and	r24, r24
    2812:	11 f4       	brne	.+4      	; 0x2818 <vTaskDelayUntil+0xa8>
		{
			portYIELD_WITHIN_API();
    2814:	0e 94 d2 16 	call	0x2da4	; 0x2da4 <vPortYield>
		}
	}
    2818:	df 91       	pop	r29
    281a:	cf 91       	pop	r28
    281c:	08 95       	ret

0000281e <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    281e:	ef 92       	push	r14
    2820:	ff 92       	push	r15
    2822:	0f 93       	push	r16
    2824:	1f 93       	push	r17
    2826:	cf 93       	push	r28
    2828:	df 93       	push	r29
    282a:	8c 01       	movw	r16, r24
	tskTCB *pxTCB;

		portENTER_CRITICAL();
    282c:	0f b6       	in	r0, 0x3f	; 63
    282e:	f8 94       	cli
    2830:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    2832:	80 91 1e 03 	lds	r24, 0x031E
    2836:	90 91 1f 03 	lds	r25, 0x031F
    283a:	08 17       	cp	r16, r24
    283c:	19 07       	cpc	r17, r25
    283e:	19 f4       	brne	.+6      	; 0x2846 <vTaskDelete+0x28>
    2840:	00 e0       	ldi	r16, 0x00	; 0
    2842:	10 e0       	ldi	r17, 0x00	; 0
    2844:	03 c0       	rjmp	.+6      	; 0x284c <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    2846:	01 15       	cp	r16, r1
    2848:	11 05       	cpc	r17, r1
    284a:	29 f4       	brne	.+10     	; 0x2856 <vTaskDelete+0x38>
    284c:	c0 91 1e 03 	lds	r28, 0x031E
    2850:	d0 91 1f 03 	lds	r29, 0x031F
    2854:	01 c0       	rjmp	.+2      	; 0x2858 <vTaskDelete+0x3a>
    2856:	e8 01       	movw	r28, r16

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    2858:	22 e0       	ldi	r18, 0x02	; 2
    285a:	e2 2e       	mov	r14, r18
    285c:	f1 2c       	mov	r15, r1
    285e:	ec 0e       	add	r14, r28
    2860:	fd 1e       	adc	r15, r29
    2862:	c7 01       	movw	r24, r14
    2864:	0e 94 58 0e 	call	0x1cb0	; 0x1cb0 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer )
    2868:	8c 89       	ldd	r24, Y+20	; 0x14
    286a:	9d 89       	ldd	r25, Y+21	; 0x15
    286c:	89 2b       	or	r24, r25
    286e:	21 f0       	breq	.+8      	; 0x2878 <vTaskDelete+0x5a>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    2870:	ce 01       	movw	r24, r28
    2872:	0c 96       	adiw	r24, 0x0c	; 12
    2874:	0e 94 58 0e 	call	0x1cb0	; 0x1cb0 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    2878:	8f e6       	ldi	r24, 0x6F	; 111
    287a:	93 e0       	ldi	r25, 0x03	; 3
    287c:	b7 01       	movw	r22, r14
    287e:	0e 94 fa 0d 	call	0x1bf4	; 0x1bf4 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    2882:	80 91 29 03 	lds	r24, 0x0329
    2886:	8f 5f       	subi	r24, 0xFF	; 255
    2888:	80 93 29 03 	sts	0x0329, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    288c:	80 91 2a 03 	lds	r24, 0x032A
    2890:	8f 5f       	subi	r24, 0xFF	; 255
    2892:	80 93 2a 03 	sts	0x032A, r24

			traceTASK_DELETE( pxTCB );
		}
		portEXIT_CRITICAL();
    2896:	0f 90       	pop	r0
    2898:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    289a:	80 91 28 03 	lds	r24, 0x0328
    289e:	88 23       	and	r24, r24
    28a0:	21 f0       	breq	.+8      	; 0x28aa <vTaskDelete+0x8c>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    28a2:	01 2b       	or	r16, r17
    28a4:	11 f4       	brne	.+4      	; 0x28aa <vTaskDelete+0x8c>
			{
				portYIELD_WITHIN_API();
    28a6:	0e 94 d2 16 	call	0x2da4	; 0x2da4 <vPortYield>
			}
		}
	}
    28aa:	df 91       	pop	r29
    28ac:	cf 91       	pop	r28
    28ae:	1f 91       	pop	r17
    28b0:	0f 91       	pop	r16
    28b2:	ff 90       	pop	r15
    28b4:	ef 90       	pop	r14
    28b6:	08 95       	ret

000028b8 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    28b8:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    28ba:	10 92 28 03 	sts	0x0328, r1
	vPortEndScheduler();
    28be:	0e 94 73 16 	call	0x2ce6	; 0x2ce6 <vPortEndScheduler>
}
    28c2:	08 95       	ret

000028c4 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    28c4:	1f 93       	push	r17
    28c6:	cf 93       	push	r28
    28c8:	df 93       	push	r29
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
    28ca:	80 91 29 03 	lds	r24, 0x0329
    28ce:	88 23       	and	r24, r24
    28d0:	91 f1       	breq	.+100    	; 0x2936 <prvIdleTask+0x72>

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    28d2:	80 91 24 03 	lds	r24, 0x0324
    28d6:	8f 5f       	subi	r24, 0xFF	; 255
    28d8:	80 93 24 03 	sts	0x0324, r24
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    28dc:	10 91 6f 03 	lds	r17, 0x036F
			xTaskResumeAll();
    28e0:	0e 94 fc 12 	call	0x25f8	; 0x25f8 <xTaskResumeAll>

			if( !xListIsEmpty )
    28e4:	11 23       	and	r17, r17
    28e6:	39 f1       	breq	.+78     	; 0x2936 <prvIdleTask+0x72>
			{
				tskTCB *pxTCB;

				portENTER_CRITICAL();
    28e8:	0f b6       	in	r0, 0x3f	; 63
    28ea:	f8 94       	cli
    28ec:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    28ee:	80 91 6f 03 	lds	r24, 0x036F
    28f2:	88 23       	and	r24, r24
    28f4:	19 f4       	brne	.+6      	; 0x28fc <prvIdleTask+0x38>
    28f6:	c0 e0       	ldi	r28, 0x00	; 0
    28f8:	d0 e0       	ldi	r29, 0x00	; 0
    28fa:	06 c0       	rjmp	.+12     	; 0x2908 <prvIdleTask+0x44>
    28fc:	e0 91 74 03 	lds	r30, 0x0374
    2900:	f0 91 75 03 	lds	r31, 0x0375
    2904:	c6 81       	ldd	r28, Z+6	; 0x06
    2906:	d7 81       	ldd	r29, Z+7	; 0x07
					vListRemove( &( pxTCB->xGenericListItem ) );
    2908:	ce 01       	movw	r24, r28
    290a:	02 96       	adiw	r24, 0x02	; 2
    290c:	0e 94 58 0e 	call	0x1cb0	; 0x1cb0 <vListRemove>
					--uxCurrentNumberOfTasks;
    2910:	80 91 27 03 	lds	r24, 0x0327
    2914:	81 50       	subi	r24, 0x01	; 1
    2916:	80 93 27 03 	sts	0x0327, r24
					--uxTasksDeleted;
    291a:	80 91 29 03 	lds	r24, 0x0329
    291e:	81 50       	subi	r24, 0x01	; 1
    2920:	80 93 29 03 	sts	0x0329, r24
				}
				portEXIT_CRITICAL();
    2924:	0f 90       	pop	r0
    2926:	0f be       	out	0x3f, r0	; 63

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    2928:	8f 89       	ldd	r24, Y+23	; 0x17
    292a:	98 8d       	ldd	r25, Y+24	; 0x18
    292c:	0e 94 f5 18 	call	0x31ea	; 0x31ea <vPortFree>
		vPortFree( pxTCB );
    2930:	ce 01       	movw	r24, r28
    2932:	0e 94 f5 18 	call	0x31ea	; 0x31ea <vPortFree>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    2936:	80 91 2c 03 	lds	r24, 0x032C
    293a:	82 30       	cpi	r24, 0x02	; 2
    293c:	30 f2       	brcs	.-116    	; 0x28ca <prvIdleTask+0x6>
			{
				taskYIELD();
    293e:	0e 94 d2 16 	call	0x2da4	; 0x2da4 <vPortYield>
    2942:	c3 cf       	rjmp	.-122    	; 0x28ca <prvIdleTask+0x6>

00002944 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    2944:	2f 92       	push	r2
    2946:	3f 92       	push	r3
    2948:	5f 92       	push	r5
    294a:	6f 92       	push	r6
    294c:	7f 92       	push	r7
    294e:	8f 92       	push	r8
    2950:	9f 92       	push	r9
    2952:	af 92       	push	r10
    2954:	bf 92       	push	r11
    2956:	cf 92       	push	r12
    2958:	df 92       	push	r13
    295a:	ef 92       	push	r14
    295c:	ff 92       	push	r15
    295e:	0f 93       	push	r16
    2960:	1f 93       	push	r17
    2962:	df 93       	push	r29
    2964:	cf 93       	push	r28
    2966:	00 d0       	rcall	.+0      	; 0x2968 <xTaskGenericCreate+0x24>
    2968:	00 d0       	rcall	.+0      	; 0x296a <xTaskGenericCreate+0x26>
    296a:	cd b7       	in	r28, 0x3d	; 61
    296c:	de b7       	in	r29, 0x3e	; 62
    296e:	9a 83       	std	Y+2, r25	; 0x02
    2970:	89 83       	std	Y+1, r24	; 0x01
    2972:	4b 01       	movw	r8, r22
    2974:	5a 01       	movw	r10, r20
    2976:	19 01       	movw	r2, r18
    2978:	50 2e       	mov	r5, r16
    297a:	37 01       	movw	r6, r14
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    297c:	81 e2       	ldi	r24, 0x21	; 33
    297e:	90 e0       	ldi	r25, 0x00	; 0
    2980:	0e 94 05 19 	call	0x320a	; 0x320a <pvPortMalloc>
    2984:	8b 83       	std	Y+3, r24	; 0x03
    2986:	9c 83       	std	Y+4, r25	; 0x04

	if( pxNewTCB != NULL )
    2988:	8b 81       	ldd	r24, Y+3	; 0x03
    298a:	9c 81       	ldd	r25, Y+4	; 0x04
    298c:	89 2b       	or	r24, r25
    298e:	89 f0       	breq	.+34     	; 0x29b2 <xTaskGenericCreate+0x6e>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    2990:	c1 14       	cp	r12, r1
    2992:	d1 04       	cpc	r13, r1
    2994:	21 f4       	brne	.+8      	; 0x299e <xTaskGenericCreate+0x5a>
    2996:	c5 01       	movw	r24, r10
    2998:	0e 94 05 19 	call	0x320a	; 0x320a <pvPortMalloc>
    299c:	6c 01       	movw	r12, r24
    299e:	eb 81       	ldd	r30, Y+3	; 0x03
    29a0:	fc 81       	ldd	r31, Y+4	; 0x04
    29a2:	d0 8e       	std	Z+24, r13	; 0x18
    29a4:	c7 8a       	std	Z+23, r12	; 0x17

		if( pxNewTCB->pxStack == NULL )
    29a6:	c1 14       	cp	r12, r1
    29a8:	d1 04       	cpc	r13, r1
    29aa:	29 f4       	brne	.+10     	; 0x29b6 <xTaskGenericCreate+0x72>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    29ac:	cf 01       	movw	r24, r30
    29ae:	0e 94 f5 18 	call	0x31ea	; 0x31ea <vPortFree>
    29b2:	8f ef       	ldi	r24, 0xFF	; 255
    29b4:	d5 c0       	rjmp	.+426    	; 0x2b60 <xTaskGenericCreate+0x21c>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
    29b6:	c6 01       	movw	r24, r12
    29b8:	65 ea       	ldi	r22, 0xA5	; 165
    29ba:	70 e0       	ldi	r23, 0x00	; 0
    29bc:	a5 01       	movw	r20, r10
    29be:	0e 94 e5 2a 	call	0x55ca	; 0x55ca <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
    29c2:	08 94       	sec
    29c4:	a1 08       	sbc	r10, r1
    29c6:	b1 08       	sbc	r11, r1
    29c8:	eb 81       	ldd	r30, Y+3	; 0x03
    29ca:	fc 81       	ldd	r31, Y+4	; 0x04
    29cc:	e7 88       	ldd	r14, Z+23	; 0x17
    29ce:	f0 8c       	ldd	r15, Z+24	; 0x18
    29d0:	ea 0c       	add	r14, r10
    29d2:	fb 1c       	adc	r15, r11
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    29d4:	cf 01       	movw	r24, r30
    29d6:	49 96       	adiw	r24, 0x19	; 25
    29d8:	b4 01       	movw	r22, r8
    29da:	48 e0       	ldi	r20, 0x08	; 8
    29dc:	50 e0       	ldi	r21, 0x00	; 0
    29de:	0e 94 ec 2a 	call	0x55d8	; 0x55d8 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
    29e2:	eb 81       	ldd	r30, Y+3	; 0x03
    29e4:	fc 81       	ldd	r31, Y+4	; 0x04
    29e6:	10 a2       	std	Z+32, r1	; 0x20
    29e8:	05 2d       	mov	r16, r5
    29ea:	f3 e0       	ldi	r31, 0x03	; 3
    29ec:	f5 15       	cp	r31, r5
    29ee:	08 f4       	brcc	.+2      	; 0x29f2 <xTaskGenericCreate+0xae>
    29f0:	03 e0       	ldi	r16, 0x03	; 3
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - 1;
	}

	pxTCB->uxPriority = uxPriority;
    29f2:	eb 81       	ldd	r30, Y+3	; 0x03
    29f4:	fc 81       	ldd	r31, Y+4	; 0x04
    29f6:	06 8b       	std	Z+22, r16	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    29f8:	42 e0       	ldi	r20, 0x02	; 2
    29fa:	c4 2e       	mov	r12, r20
    29fc:	d1 2c       	mov	r13, r1
    29fe:	ce 0e       	add	r12, r30
    2a00:	df 1e       	adc	r13, r31
    2a02:	c6 01       	movw	r24, r12
    2a04:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    2a08:	8b 81       	ldd	r24, Y+3	; 0x03
    2a0a:	9c 81       	ldd	r25, Y+4	; 0x04
    2a0c:	0c 96       	adiw	r24, 0x0c	; 12
    2a0e:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    2a12:	8b 81       	ldd	r24, Y+3	; 0x03
    2a14:	9c 81       	ldd	r25, Y+4	; 0x04
    2a16:	fc 01       	movw	r30, r24
    2a18:	91 87       	std	Z+9, r25	; 0x09
    2a1a:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    2a1c:	84 e0       	ldi	r24, 0x04	; 4
    2a1e:	90 e0       	ldi	r25, 0x00	; 0
    2a20:	80 1b       	sub	r24, r16
    2a22:	91 09       	sbc	r25, r1
    2a24:	95 87       	std	Z+13, r25	; 0x0d
    2a26:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    2a28:	f3 8b       	std	Z+19, r31	; 0x13
    2a2a:	e2 8b       	std	Z+18, r30	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    2a2c:	c7 01       	movw	r24, r14
    2a2e:	69 81       	ldd	r22, Y+1	; 0x01
    2a30:	7a 81       	ldd	r23, Y+2	; 0x02
    2a32:	a1 01       	movw	r20, r2
    2a34:	0e 94 f1 15 	call	0x2be2	; 0x2be2 <pxPortInitialiseStack>
    2a38:	eb 81       	ldd	r30, Y+3	; 0x03
    2a3a:	fc 81       	ldd	r31, Y+4	; 0x04
    2a3c:	91 83       	std	Z+1, r25	; 0x01
    2a3e:	80 83       	st	Z, r24
		}
		#endif

		if( ( void * ) pxCreatedTask != NULL )
    2a40:	61 14       	cp	r6, r1
    2a42:	71 04       	cpc	r7, r1
    2a44:	21 f0       	breq	.+8      	; 0x2a4e <xTaskGenericCreate+0x10a>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    2a46:	cf 01       	movw	r24, r30
    2a48:	f3 01       	movw	r30, r6
    2a4a:	91 83       	std	Z+1, r25	; 0x01
    2a4c:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		portENTER_CRITICAL();
    2a4e:	0f b6       	in	r0, 0x3f	; 63
    2a50:	f8 94       	cli
    2a52:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    2a54:	80 91 27 03 	lds	r24, 0x0327
    2a58:	8f 5f       	subi	r24, 0xFF	; 255
    2a5a:	80 93 27 03 	sts	0x0327, r24
			if( pxCurrentTCB == NULL )
    2a5e:	80 91 1e 03 	lds	r24, 0x031E
    2a62:	90 91 1f 03 	lds	r25, 0x031F
    2a66:	89 2b       	or	r24, r25
    2a68:	b9 f5       	brne	.+110    	; 0x2ad8 <xTaskGenericCreate+0x194>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    2a6a:	eb 81       	ldd	r30, Y+3	; 0x03
    2a6c:	fc 81       	ldd	r31, Y+4	; 0x04
    2a6e:	f0 93 1f 03 	sts	0x031F, r31
    2a72:	e0 93 1e 03 	sts	0x031E, r30

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    2a76:	80 91 27 03 	lds	r24, 0x0327
    2a7a:	81 30       	cpi	r24, 0x01	; 1
    2a7c:	f1 f5       	brne	.+124    	; 0x2afa <xTaskGenericCreate+0x1b6>
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    2a7e:	8c e2       	ldi	r24, 0x2C	; 44
    2a80:	93 e0       	ldi	r25, 0x03	; 3
    2a82:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <vListInitialise>
    2a86:	85 e3       	ldi	r24, 0x35	; 53
    2a88:	93 e0       	ldi	r25, 0x03	; 3
    2a8a:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <vListInitialise>
    2a8e:	8e e3       	ldi	r24, 0x3E	; 62
    2a90:	93 e0       	ldi	r25, 0x03	; 3
    2a92:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <vListInitialise>
    2a96:	87 e4       	ldi	r24, 0x47	; 71
    2a98:	93 e0       	ldi	r25, 0x03	; 3
    2a9a:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    2a9e:	30 e5       	ldi	r19, 0x50	; 80
    2aa0:	e3 2e       	mov	r14, r19
    2aa2:	33 e0       	ldi	r19, 0x03	; 3
    2aa4:	f3 2e       	mov	r15, r19
    2aa6:	c7 01       	movw	r24, r14
    2aa8:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    2aac:	09 e5       	ldi	r16, 0x59	; 89
    2aae:	13 e0       	ldi	r17, 0x03	; 3
    2ab0:	c8 01       	movw	r24, r16
    2ab2:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    2ab6:	86 e6       	ldi	r24, 0x66	; 102
    2ab8:	93 e0       	ldi	r25, 0x03	; 3
    2aba:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    2abe:	8f e6       	ldi	r24, 0x6F	; 111
    2ac0:	93 e0       	ldi	r25, 0x03	; 3
    2ac2:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    2ac6:	f0 92 63 03 	sts	0x0363, r15
    2aca:	e0 92 62 03 	sts	0x0362, r14
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    2ace:	10 93 65 03 	sts	0x0365, r17
    2ad2:	00 93 64 03 	sts	0x0364, r16
    2ad6:	11 c0       	rjmp	.+34     	; 0x2afa <xTaskGenericCreate+0x1b6>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    2ad8:	80 91 28 03 	lds	r24, 0x0328
    2adc:	88 23       	and	r24, r24
    2ade:	69 f4       	brne	.+26     	; 0x2afa <xTaskGenericCreate+0x1b6>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    2ae0:	e0 91 1e 03 	lds	r30, 0x031E
    2ae4:	f0 91 1f 03 	lds	r31, 0x031F
    2ae8:	86 89       	ldd	r24, Z+22	; 0x16
    2aea:	58 16       	cp	r5, r24
    2aec:	30 f0       	brcs	.+12     	; 0x2afa <xTaskGenericCreate+0x1b6>
					{
						pxCurrentTCB = pxNewTCB;
    2aee:	8b 81       	ldd	r24, Y+3	; 0x03
    2af0:	9c 81       	ldd	r25, Y+4	; 0x04
    2af2:	90 93 1f 03 	sts	0x031F, r25
    2af6:	80 93 1e 03 	sts	0x031E, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    2afa:	eb 81       	ldd	r30, Y+3	; 0x03
    2afc:	fc 81       	ldd	r31, Y+4	; 0x04
    2afe:	96 89       	ldd	r25, Z+22	; 0x16
    2b00:	80 91 2b 03 	lds	r24, 0x032B
    2b04:	89 17       	cp	r24, r25
    2b06:	10 f4       	brcc	.+4      	; 0x2b0c <xTaskGenericCreate+0x1c8>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    2b08:	90 93 2b 03 	sts	0x032B, r25
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    2b0c:	80 91 2a 03 	lds	r24, 0x032A
    2b10:	8f 5f       	subi	r24, 0xFF	; 255
    2b12:	80 93 2a 03 	sts	0x032A, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    2b16:	eb 81       	ldd	r30, Y+3	; 0x03
    2b18:	fc 81       	ldd	r31, Y+4	; 0x04
    2b1a:	96 89       	ldd	r25, Z+22	; 0x16
    2b1c:	80 91 25 03 	lds	r24, 0x0325
    2b20:	89 17       	cp	r24, r25
    2b22:	10 f4       	brcc	.+4      	; 0x2b28 <xTaskGenericCreate+0x1e4>
    2b24:	90 93 25 03 	sts	0x0325, r25
    2b28:	eb 81       	ldd	r30, Y+3	; 0x03
    2b2a:	fc 81       	ldd	r31, Y+4	; 0x04
    2b2c:	86 89       	ldd	r24, Z+22	; 0x16
    2b2e:	29 e0       	ldi	r18, 0x09	; 9
    2b30:	82 9f       	mul	r24, r18
    2b32:	c0 01       	movw	r24, r0
    2b34:	11 24       	eor	r1, r1
    2b36:	84 5d       	subi	r24, 0xD4	; 212
    2b38:	9c 4f       	sbci	r25, 0xFC	; 252
    2b3a:	b6 01       	movw	r22, r12
    2b3c:	0e 94 fa 0d 	call	0x1bf4	; 0x1bf4 <vListInsertEnd>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		portEXIT_CRITICAL();
    2b40:	0f 90       	pop	r0
    2b42:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED( pxNewTCB );
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    2b44:	80 91 28 03 	lds	r24, 0x0328
    2b48:	88 23       	and	r24, r24
    2b4a:	49 f0       	breq	.+18     	; 0x2b5e <xTaskGenericCreate+0x21a>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    2b4c:	e0 91 1e 03 	lds	r30, 0x031E
    2b50:	f0 91 1f 03 	lds	r31, 0x031F
    2b54:	86 89       	ldd	r24, Z+22	; 0x16
    2b56:	85 15       	cp	r24, r5
    2b58:	10 f4       	brcc	.+4      	; 0x2b5e <xTaskGenericCreate+0x21a>
			{
				portYIELD_WITHIN_API();
    2b5a:	0e 94 d2 16 	call	0x2da4	; 0x2da4 <vPortYield>
    2b5e:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    2b60:	0f 90       	pop	r0
    2b62:	0f 90       	pop	r0
    2b64:	0f 90       	pop	r0
    2b66:	0f 90       	pop	r0
    2b68:	cf 91       	pop	r28
    2b6a:	df 91       	pop	r29
    2b6c:	1f 91       	pop	r17
    2b6e:	0f 91       	pop	r16
    2b70:	ff 90       	pop	r15
    2b72:	ef 90       	pop	r14
    2b74:	df 90       	pop	r13
    2b76:	cf 90       	pop	r12
    2b78:	bf 90       	pop	r11
    2b7a:	af 90       	pop	r10
    2b7c:	9f 90       	pop	r9
    2b7e:	8f 90       	pop	r8
    2b80:	7f 90       	pop	r7
    2b82:	6f 90       	pop	r6
    2b84:	5f 90       	pop	r5
    2b86:	3f 90       	pop	r3
    2b88:	2f 90       	pop	r2
    2b8a:	08 95       	ret

00002b8c <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    2b8c:	af 92       	push	r10
    2b8e:	bf 92       	push	r11
    2b90:	cf 92       	push	r12
    2b92:	df 92       	push	r13
    2b94:	ef 92       	push	r14
    2b96:	ff 92       	push	r15
    2b98:	0f 93       	push	r16
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
    2b9a:	82 e6       	ldi	r24, 0x62	; 98
    2b9c:	94 e1       	ldi	r25, 0x14	; 20
    2b9e:	69 eb       	ldi	r22, 0xB9	; 185
    2ba0:	72 e0       	ldi	r23, 0x02	; 2
    2ba2:	45 e5       	ldi	r20, 0x55	; 85
    2ba4:	50 e0       	ldi	r21, 0x00	; 0
    2ba6:	20 e0       	ldi	r18, 0x00	; 0
    2ba8:	30 e0       	ldi	r19, 0x00	; 0
    2baa:	00 e0       	ldi	r16, 0x00	; 0
    2bac:	ee 24       	eor	r14, r14
    2bae:	ff 24       	eor	r15, r15
    2bb0:	cc 24       	eor	r12, r12
    2bb2:	dd 24       	eor	r13, r13
    2bb4:	aa 24       	eor	r10, r10
    2bb6:	bb 24       	eor	r11, r11
    2bb8:	0e 94 a2 14 	call	0x2944	; 0x2944 <xTaskGenericCreate>

	if( xReturn == pdPASS )
    2bbc:	81 30       	cpi	r24, 0x01	; 1
    2bbe:	49 f4       	brne	.+18     	; 0x2bd2 <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    2bc0:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    2bc2:	80 93 28 03 	sts	0x0328, r24
		xTickCount = ( portTickType ) 0;
    2bc6:	10 92 23 03 	sts	0x0323, r1
    2bca:	10 92 22 03 	sts	0x0322, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
    2bce:	0e 94 39 16 	call	0x2c72	; 0x2c72 <xPortStartScheduler>
		else
		{
			/* Should only reach here if a task calls xTaskEndScheduler(). */
		}
	}
}
    2bd2:	0f 91       	pop	r16
    2bd4:	ff 90       	pop	r15
    2bd6:	ef 90       	pop	r14
    2bd8:	df 90       	pop	r13
    2bda:	cf 90       	pop	r12
    2bdc:	bf 90       	pop	r11
    2bde:	af 90       	pop	r10
    2be0:	08 95       	ret

00002be2 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    2be2:	fc 01       	movw	r30, r24
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    2be4:	91 e1       	ldi	r25, 0x11	; 17
    2be6:	90 83       	st	Z, r25
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    2be8:	22 e2       	ldi	r18, 0x22	; 34
    2bea:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    2bec:	83 e3       	ldi	r24, 0x33	; 51
    2bee:	82 93       	st	-Z, r24
	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	

	usAddress = ( unsigned short ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2bf0:	62 93       	st	-Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2bf2:	72 93       	st	-Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    2bf4:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    2bf6:	80 e8       	ldi	r24, 0x80	; 128
    2bf8:	82 93       	st	-Z, r24
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    2bfa:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    2bfc:	82 e0       	ldi	r24, 0x02	; 2
    2bfe:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    2c00:	83 e0       	ldi	r24, 0x03	; 3
    2c02:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    2c04:	84 e0       	ldi	r24, 0x04	; 4
    2c06:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    2c08:	85 e0       	ldi	r24, 0x05	; 5
    2c0a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    2c0c:	86 e0       	ldi	r24, 0x06	; 6
    2c0e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    2c10:	87 e0       	ldi	r24, 0x07	; 7
    2c12:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    2c14:	88 e0       	ldi	r24, 0x08	; 8
    2c16:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    2c18:	89 e0       	ldi	r24, 0x09	; 9
    2c1a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    2c1c:	80 e1       	ldi	r24, 0x10	; 16
    2c1e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    2c20:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    2c22:	82 e1       	ldi	r24, 0x12	; 18
    2c24:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    2c26:	83 e1       	ldi	r24, 0x13	; 19
    2c28:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    2c2a:	84 e1       	ldi	r24, 0x14	; 20
    2c2c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    2c2e:	85 e1       	ldi	r24, 0x15	; 21
    2c30:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    2c32:	86 e1       	ldi	r24, 0x16	; 22
    2c34:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    2c36:	87 e1       	ldi	r24, 0x17	; 23
    2c38:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    2c3a:	88 e1       	ldi	r24, 0x18	; 24
    2c3c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    2c3e:	89 e1       	ldi	r24, 0x19	; 25
    2c40:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    2c42:	80 e2       	ldi	r24, 0x20	; 32
    2c44:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    2c46:	81 e2       	ldi	r24, 0x21	; 33
    2c48:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    2c4a:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    2c4c:	83 e2       	ldi	r24, 0x23	; 35
    2c4e:	82 93       	st	-Z, r24
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */

	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2c50:	42 93       	st	-Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2c52:	52 93       	st	-Z, r21
	pxTopOfStack--;


	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    2c54:	86 e2       	ldi	r24, 0x26	; 38
    2c56:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    2c58:	87 e2       	ldi	r24, 0x27	; 39
    2c5a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    2c5c:	88 e2       	ldi	r24, 0x28	; 40
    2c5e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    2c60:	89 e2       	ldi	r24, 0x29	; 41
    2c62:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    2c64:	80 e3       	ldi	r24, 0x30	; 48
    2c66:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    2c68:	81 e3       	ldi	r24, 0x31	; 49
    2c6a:	82 93       	st	-Z, r24
    2c6c:	31 97       	sbiw	r30, 0x01	; 1
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    2c6e:	cf 01       	movw	r24, r30
    2c70:	08 95       	ret

00002c72 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	OCR1AH = ucHighByte;
    2c72:	10 92 89 00 	sts	0x0089, r1
	OCR1AL = ucLowByte;
    2c76:	89 ef       	ldi	r24, 0xF9	; 249
    2c78:	80 93 88 00 	sts	0x0088, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    2c7c:	8b e0       	ldi	r24, 0x0B	; 11
    2c7e:	80 93 81 00 	sts	0x0081, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
    2c82:	ef e6       	ldi	r30, 0x6F	; 111
    2c84:	f0 e0       	ldi	r31, 0x00	; 0
    2c86:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    2c88:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
    2c8a:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    2c8c:	a0 91 1e 03 	lds	r26, 0x031E
    2c90:	b0 91 1f 03 	lds	r27, 0x031F
    2c94:	cd 91       	ld	r28, X+
    2c96:	cd bf       	out	0x3d, r28	; 61
    2c98:	dd 91       	ld	r29, X+
    2c9a:	de bf       	out	0x3e, r29	; 62
    2c9c:	ff 91       	pop	r31
    2c9e:	ef 91       	pop	r30
    2ca0:	df 91       	pop	r29
    2ca2:	cf 91       	pop	r28
    2ca4:	bf 91       	pop	r27
    2ca6:	af 91       	pop	r26
    2ca8:	9f 91       	pop	r25
    2caa:	8f 91       	pop	r24
    2cac:	7f 91       	pop	r23
    2cae:	6f 91       	pop	r22
    2cb0:	5f 91       	pop	r21
    2cb2:	4f 91       	pop	r20
    2cb4:	3f 91       	pop	r19
    2cb6:	2f 91       	pop	r18
    2cb8:	1f 91       	pop	r17
    2cba:	0f 91       	pop	r16
    2cbc:	ff 90       	pop	r15
    2cbe:	ef 90       	pop	r14
    2cc0:	df 90       	pop	r13
    2cc2:	cf 90       	pop	r12
    2cc4:	bf 90       	pop	r11
    2cc6:	af 90       	pop	r10
    2cc8:	9f 90       	pop	r9
    2cca:	8f 90       	pop	r8
    2ccc:	7f 90       	pop	r7
    2cce:	6f 90       	pop	r6
    2cd0:	5f 90       	pop	r5
    2cd2:	4f 90       	pop	r4
    2cd4:	3f 90       	pop	r3
    2cd6:	2f 90       	pop	r2
    2cd8:	1f 90       	pop	r1
    2cda:	0f 90       	pop	r0
    2cdc:	0f be       	out	0x3f, r0	; 63
    2cde:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    2ce0:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    2ce2:	81 e0       	ldi	r24, 0x01	; 1
    2ce4:	08 95       	ret

00002ce6 <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    2ce6:	08 95       	ret

00002ce8 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2ce8:	0f 92       	push	r0
    2cea:	0f b6       	in	r0, 0x3f	; 63
    2cec:	f8 94       	cli
    2cee:	0f 92       	push	r0
    2cf0:	1f 92       	push	r1
    2cf2:	11 24       	eor	r1, r1
    2cf4:	2f 92       	push	r2
    2cf6:	3f 92       	push	r3
    2cf8:	4f 92       	push	r4
    2cfa:	5f 92       	push	r5
    2cfc:	6f 92       	push	r6
    2cfe:	7f 92       	push	r7
    2d00:	8f 92       	push	r8
    2d02:	9f 92       	push	r9
    2d04:	af 92       	push	r10
    2d06:	bf 92       	push	r11
    2d08:	cf 92       	push	r12
    2d0a:	df 92       	push	r13
    2d0c:	ef 92       	push	r14
    2d0e:	ff 92       	push	r15
    2d10:	0f 93       	push	r16
    2d12:	1f 93       	push	r17
    2d14:	2f 93       	push	r18
    2d16:	3f 93       	push	r19
    2d18:	4f 93       	push	r20
    2d1a:	5f 93       	push	r21
    2d1c:	6f 93       	push	r22
    2d1e:	7f 93       	push	r23
    2d20:	8f 93       	push	r24
    2d22:	9f 93       	push	r25
    2d24:	af 93       	push	r26
    2d26:	bf 93       	push	r27
    2d28:	cf 93       	push	r28
    2d2a:	df 93       	push	r29
    2d2c:	ef 93       	push	r30
    2d2e:	ff 93       	push	r31
    2d30:	a0 91 1e 03 	lds	r26, 0x031E
    2d34:	b0 91 1f 03 	lds	r27, 0x031F
    2d38:	0d b6       	in	r0, 0x3d	; 61
    2d3a:	0d 92       	st	X+, r0
    2d3c:	0e b6       	in	r0, 0x3e	; 62
    2d3e:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    2d40:	0e 94 4d 12 	call	0x249a	; 0x249a <vTaskIncrementTick>
	vTaskSwitchContext();
    2d44:	0e 94 7f 11 	call	0x22fe	; 0x22fe <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2d48:	a0 91 1e 03 	lds	r26, 0x031E
    2d4c:	b0 91 1f 03 	lds	r27, 0x031F
    2d50:	cd 91       	ld	r28, X+
    2d52:	cd bf       	out	0x3d, r28	; 61
    2d54:	dd 91       	ld	r29, X+
    2d56:	de bf       	out	0x3e, r29	; 62
    2d58:	ff 91       	pop	r31
    2d5a:	ef 91       	pop	r30
    2d5c:	df 91       	pop	r29
    2d5e:	cf 91       	pop	r28
    2d60:	bf 91       	pop	r27
    2d62:	af 91       	pop	r26
    2d64:	9f 91       	pop	r25
    2d66:	8f 91       	pop	r24
    2d68:	7f 91       	pop	r23
    2d6a:	6f 91       	pop	r22
    2d6c:	5f 91       	pop	r21
    2d6e:	4f 91       	pop	r20
    2d70:	3f 91       	pop	r19
    2d72:	2f 91       	pop	r18
    2d74:	1f 91       	pop	r17
    2d76:	0f 91       	pop	r16
    2d78:	ff 90       	pop	r15
    2d7a:	ef 90       	pop	r14
    2d7c:	df 90       	pop	r13
    2d7e:	cf 90       	pop	r12
    2d80:	bf 90       	pop	r11
    2d82:	af 90       	pop	r10
    2d84:	9f 90       	pop	r9
    2d86:	8f 90       	pop	r8
    2d88:	7f 90       	pop	r7
    2d8a:	6f 90       	pop	r6
    2d8c:	5f 90       	pop	r5
    2d8e:	4f 90       	pop	r4
    2d90:	3f 90       	pop	r3
    2d92:	2f 90       	pop	r2
    2d94:	1f 90       	pop	r1
    2d96:	0f 90       	pop	r0
    2d98:	0f be       	out	0x3f, r0	; 63
    2d9a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2d9c:	08 95       	ret

00002d9e <__vector_17>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    2d9e:	0e 94 74 16 	call	0x2ce8	; 0x2ce8 <vPortYieldFromTick>
		asm volatile ( "reti" );
    2da2:	18 95       	reti

00002da4 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2da4:	0f 92       	push	r0
    2da6:	0f b6       	in	r0, 0x3f	; 63
    2da8:	f8 94       	cli
    2daa:	0f 92       	push	r0
    2dac:	1f 92       	push	r1
    2dae:	11 24       	eor	r1, r1
    2db0:	2f 92       	push	r2
    2db2:	3f 92       	push	r3
    2db4:	4f 92       	push	r4
    2db6:	5f 92       	push	r5
    2db8:	6f 92       	push	r6
    2dba:	7f 92       	push	r7
    2dbc:	8f 92       	push	r8
    2dbe:	9f 92       	push	r9
    2dc0:	af 92       	push	r10
    2dc2:	bf 92       	push	r11
    2dc4:	cf 92       	push	r12
    2dc6:	df 92       	push	r13
    2dc8:	ef 92       	push	r14
    2dca:	ff 92       	push	r15
    2dcc:	0f 93       	push	r16
    2dce:	1f 93       	push	r17
    2dd0:	2f 93       	push	r18
    2dd2:	3f 93       	push	r19
    2dd4:	4f 93       	push	r20
    2dd6:	5f 93       	push	r21
    2dd8:	6f 93       	push	r22
    2dda:	7f 93       	push	r23
    2ddc:	8f 93       	push	r24
    2dde:	9f 93       	push	r25
    2de0:	af 93       	push	r26
    2de2:	bf 93       	push	r27
    2de4:	cf 93       	push	r28
    2de6:	df 93       	push	r29
    2de8:	ef 93       	push	r30
    2dea:	ff 93       	push	r31
    2dec:	a0 91 1e 03 	lds	r26, 0x031E
    2df0:	b0 91 1f 03 	lds	r27, 0x031F
    2df4:	0d b6       	in	r0, 0x3d	; 61
    2df6:	0d 92       	st	X+, r0
    2df8:	0e b6       	in	r0, 0x3e	; 62
    2dfa:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2dfc:	0e 94 7f 11 	call	0x22fe	; 0x22fe <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2e00:	a0 91 1e 03 	lds	r26, 0x031E
    2e04:	b0 91 1f 03 	lds	r27, 0x031F
    2e08:	cd 91       	ld	r28, X+
    2e0a:	cd bf       	out	0x3d, r28	; 61
    2e0c:	dd 91       	ld	r29, X+
    2e0e:	de bf       	out	0x3e, r29	; 62
    2e10:	ff 91       	pop	r31
    2e12:	ef 91       	pop	r30
    2e14:	df 91       	pop	r29
    2e16:	cf 91       	pop	r28
    2e18:	bf 91       	pop	r27
    2e1a:	af 91       	pop	r26
    2e1c:	9f 91       	pop	r25
    2e1e:	8f 91       	pop	r24
    2e20:	7f 91       	pop	r23
    2e22:	6f 91       	pop	r22
    2e24:	5f 91       	pop	r21
    2e26:	4f 91       	pop	r20
    2e28:	3f 91       	pop	r19
    2e2a:	2f 91       	pop	r18
    2e2c:	1f 91       	pop	r17
    2e2e:	0f 91       	pop	r16
    2e30:	ff 90       	pop	r15
    2e32:	ef 90       	pop	r14
    2e34:	df 90       	pop	r13
    2e36:	cf 90       	pop	r12
    2e38:	bf 90       	pop	r11
    2e3a:	af 90       	pop	r10
    2e3c:	9f 90       	pop	r9
    2e3e:	8f 90       	pop	r8
    2e40:	7f 90       	pop	r7
    2e42:	6f 90       	pop	r6
    2e44:	5f 90       	pop	r5
    2e46:	4f 90       	pop	r4
    2e48:	3f 90       	pop	r3
    2e4a:	2f 90       	pop	r2
    2e4c:	1f 90       	pop	r1
    2e4e:	0f 90       	pop	r0
    2e50:	0f be       	out	0x3f, r0	; 63
    2e52:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2e54:	08 95       	ret

00002e56 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    2e56:	0f 93       	push	r16
    2e58:	1f 93       	push	r17
    2e5a:	cf 93       	push	r28
    2e5c:	df 93       	push	r29
    2e5e:	fc 01       	movw	r30, r24
corCRCB *pxUnblockedCRCB;
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2e60:	80 81       	ld	r24, Z
    2e62:	88 23       	and	r24, r24
    2e64:	19 f4       	brne	.+6      	; 0x2e6c <xCoRoutineRemoveFromEventList+0x16>
    2e66:	c0 e0       	ldi	r28, 0x00	; 0
    2e68:	d0 e0       	ldi	r29, 0x00	; 0
    2e6a:	05 c0       	rjmp	.+10     	; 0x2e76 <xCoRoutineRemoveFromEventList+0x20>
    2e6c:	05 80       	ldd	r0, Z+5	; 0x05
    2e6e:	f6 81       	ldd	r31, Z+6	; 0x06
    2e70:	e0 2d       	mov	r30, r0
    2e72:	c6 81       	ldd	r28, Z+6	; 0x06
    2e74:	d7 81       	ldd	r29, Z+7	; 0x07
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2e76:	8e 01       	movw	r16, r28
    2e78:	04 5f       	subi	r16, 0xF4	; 244
    2e7a:	1f 4f       	sbci	r17, 0xFF	; 255
    2e7c:	c8 01       	movw	r24, r16
    2e7e:	0e 94 58 0e 	call	0x1cb0	; 0x1cb0 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    2e82:	89 ea       	ldi	r24, 0xA9	; 169
    2e84:	93 e0       	ldi	r25, 0x03	; 3
    2e86:	b8 01       	movw	r22, r16
    2e88:	0e 94 fa 0d 	call	0x1bf4	; 0x1bf4 <vListInsertEnd>
    2e8c:	20 e0       	ldi	r18, 0x00	; 0
    2e8e:	e0 91 78 03 	lds	r30, 0x0378
    2e92:	f0 91 79 03 	lds	r31, 0x0379
    2e96:	9e 89       	ldd	r25, Y+22	; 0x16
    2e98:	86 89       	ldd	r24, Z+22	; 0x16
    2e9a:	98 17       	cp	r25, r24
    2e9c:	08 f0       	brcs	.+2      	; 0x2ea0 <xCoRoutineRemoveFromEventList+0x4a>
    2e9e:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    2ea0:	82 2f       	mov	r24, r18
    2ea2:	df 91       	pop	r29
    2ea4:	cf 91       	pop	r28
    2ea6:	1f 91       	pop	r17
    2ea8:	0f 91       	pop	r16
    2eaa:	08 95       	ret

00002eac <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    2eac:	ff 92       	push	r15
    2eae:	0f 93       	push	r16
    2eb0:	1f 93       	push	r17
    2eb2:	cf 93       	push	r28
    2eb4:	df 93       	push	r29
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    2eb6:	99 e0       	ldi	r25, 0x09	; 9
    2eb8:	f9 2e       	mov	r15, r25
    2eba:	28 c0       	rjmp	.+80     	; 0x2f0c <vCoRoutineSchedule+0x60>
	while( !listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    2ebc:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    2ebe:	80 91 a9 03 	lds	r24, 0x03A9
    2ec2:	88 23       	and	r24, r24
    2ec4:	19 f4       	brne	.+6      	; 0x2ecc <vCoRoutineSchedule+0x20>
    2ec6:	c0 e0       	ldi	r28, 0x00	; 0
    2ec8:	d0 e0       	ldi	r29, 0x00	; 0
    2eca:	06 c0       	rjmp	.+12     	; 0x2ed8 <vCoRoutineSchedule+0x2c>
    2ecc:	e0 91 ae 03 	lds	r30, 0x03AE
    2ed0:	f0 91 af 03 	lds	r31, 0x03AF
    2ed4:	c6 81       	ldd	r28, Z+6	; 0x06
    2ed6:	d7 81       	ldd	r29, Z+7	; 0x07
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2ed8:	ce 01       	movw	r24, r28
    2eda:	0c 96       	adiw	r24, 0x0c	; 12
    2edc:	0e 94 58 0e 	call	0x1cb0	; 0x1cb0 <vListRemove>
		}
		portENABLE_INTERRUPTS();
    2ee0:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    2ee2:	8e 01       	movw	r16, r28
    2ee4:	0e 5f       	subi	r16, 0xFE	; 254
    2ee6:	1f 4f       	sbci	r17, 0xFF	; 255
    2ee8:	c8 01       	movw	r24, r16
    2eea:	0e 94 58 0e 	call	0x1cb0	; 0x1cb0 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    2eee:	9e 89       	ldd	r25, Y+22	; 0x16
    2ef0:	80 91 7a 03 	lds	r24, 0x037A
    2ef4:	89 17       	cp	r24, r25
    2ef6:	10 f4       	brcc	.+4      	; 0x2efc <vCoRoutineSchedule+0x50>
    2ef8:	90 93 7a 03 	sts	0x037A, r25
    2efc:	9f 9d       	mul	r25, r15
    2efe:	c0 01       	movw	r24, r0
    2f00:	11 24       	eor	r1, r1
    2f02:	8f 57       	subi	r24, 0x7F	; 127
    2f04:	9c 4f       	sbci	r25, 0xFC	; 252
    2f06:	b8 01       	movw	r22, r16
    2f08:	0e 94 fa 0d 	call	0x1bf4	; 0x1bf4 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( !listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) )
    2f0c:	80 91 a9 03 	lds	r24, 0x03A9
    2f10:	88 23       	and	r24, r24
    2f12:	a1 f6       	brne	.-88     	; 0x2ebc <vCoRoutineSchedule+0x10>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    2f14:	0e 94 6b 11 	call	0x22d6	; 0x22d6 <xTaskGetTickCount>
    2f18:	20 91 7b 03 	lds	r18, 0x037B
    2f1c:	30 91 7c 03 	lds	r19, 0x037C
    2f20:	82 1b       	sub	r24, r18
    2f22:	93 0b       	sbc	r25, r19
    2f24:	90 93 7e 03 	sts	0x037E, r25
    2f28:	80 93 7d 03 	sts	0x037D, r24
					vListRemove( &( pxCRCB->xEventListItem ) );											
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    2f2c:	89 e0       	ldi	r24, 0x09	; 9
    2f2e:	f8 2e       	mov	r15, r24
    2f30:	54 c0       	rjmp	.+168    	; 0x2fda <vCoRoutineSchedule+0x12e>
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    2f32:	01 96       	adiw	r24, 0x01	; 1
    2f34:	90 93 80 03 	sts	0x0380, r25
    2f38:	80 93 7f 03 	sts	0x037F, r24
		xPassedTicks--;
    2f3c:	21 50       	subi	r18, 0x01	; 1
    2f3e:	30 40       	sbci	r19, 0x00	; 0
    2f40:	30 93 7e 03 	sts	0x037E, r19
    2f44:	20 93 7d 03 	sts	0x037D, r18

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    2f48:	89 2b       	or	r24, r25
    2f4a:	c9 f5       	brne	.+114    	; 0x2fbe <vCoRoutineSchedule+0x112>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    2f4c:	20 91 a5 03 	lds	r18, 0x03A5
    2f50:	30 91 a6 03 	lds	r19, 0x03A6
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    2f54:	80 91 a7 03 	lds	r24, 0x03A7
    2f58:	90 91 a8 03 	lds	r25, 0x03A8
    2f5c:	90 93 a6 03 	sts	0x03A6, r25
    2f60:	80 93 a5 03 	sts	0x03A5, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    2f64:	30 93 a8 03 	sts	0x03A8, r19
    2f68:	20 93 a7 03 	sts	0x03A7, r18
    2f6c:	28 c0       	rjmp	.+80     	; 0x2fbe <vCoRoutineSchedule+0x112>
		}

		/* See if this tick has made a timeout expire. */
		while( ( pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList ) ) != NULL )
		{	
			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    2f6e:	20 91 7f 03 	lds	r18, 0x037F
    2f72:	30 91 80 03 	lds	r19, 0x0380
    2f76:	8a 81       	ldd	r24, Y+2	; 0x02
    2f78:	9b 81       	ldd	r25, Y+3	; 0x03
    2f7a:	28 17       	cp	r18, r24
    2f7c:	39 07       	cpc	r19, r25
    2f7e:	68 f1       	brcs	.+90     	; 0x2fda <vCoRoutineSchedule+0x12e>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    2f80:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    2f82:	8e 01       	movw	r16, r28
    2f84:	0e 5f       	subi	r16, 0xFE	; 254
    2f86:	1f 4f       	sbci	r17, 0xFF	; 255
    2f88:	c8 01       	movw	r24, r16
    2f8a:	0e 94 58 0e 	call	0x1cb0	; 0x1cb0 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    2f8e:	8c 89       	ldd	r24, Y+20	; 0x14
    2f90:	9d 89       	ldd	r25, Y+21	; 0x15
    2f92:	89 2b       	or	r24, r25
    2f94:	21 f0       	breq	.+8      	; 0x2f9e <vCoRoutineSchedule+0xf2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    2f96:	ce 01       	movw	r24, r28
    2f98:	0c 96       	adiw	r24, 0x0c	; 12
    2f9a:	0e 94 58 0e 	call	0x1cb0	; 0x1cb0 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    2f9e:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    2fa0:	9e 89       	ldd	r25, Y+22	; 0x16
    2fa2:	80 91 7a 03 	lds	r24, 0x037A
    2fa6:	89 17       	cp	r24, r25
    2fa8:	10 f4       	brcc	.+4      	; 0x2fae <vCoRoutineSchedule+0x102>
    2faa:	90 93 7a 03 	sts	0x037A, r25
    2fae:	9f 9d       	mul	r25, r15
    2fb0:	c0 01       	movw	r24, r0
    2fb2:	11 24       	eor	r1, r1
    2fb4:	8f 57       	subi	r24, 0x7F	; 127
    2fb6:	9c 4f       	sbci	r25, 0xFC	; 252
    2fb8:	b8 01       	movw	r22, r16
    2fba:	0e 94 fa 0d 	call	0x1bf4	; 0x1bf4 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( ( pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList ) ) != NULL )
    2fbe:	e0 91 a5 03 	lds	r30, 0x03A5
    2fc2:	f0 91 a6 03 	lds	r31, 0x03A6
    2fc6:	80 81       	ld	r24, Z
    2fc8:	88 23       	and	r24, r24
    2fca:	39 f0       	breq	.+14     	; 0x2fda <vCoRoutineSchedule+0x12e>
    2fcc:	05 80       	ldd	r0, Z+5	; 0x05
    2fce:	f6 81       	ldd	r31, Z+6	; 0x06
    2fd0:	e0 2d       	mov	r30, r0
    2fd2:	c6 81       	ldd	r28, Z+6	; 0x06
    2fd4:	d7 81       	ldd	r29, Z+7	; 0x07
    2fd6:	20 97       	sbiw	r28, 0x00	; 0
    2fd8:	51 f6       	brne	.-108    	; 0x2f6e <vCoRoutineSchedule+0xc2>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    2fda:	20 91 7d 03 	lds	r18, 0x037D
    2fde:	30 91 7e 03 	lds	r19, 0x037E
    2fe2:	80 91 7f 03 	lds	r24, 0x037F
    2fe6:	90 91 80 03 	lds	r25, 0x0380
    2fea:	21 15       	cp	r18, r1
    2fec:	31 05       	cpc	r19, r1
    2fee:	09 f0       	breq	.+2      	; 0x2ff2 <vCoRoutineSchedule+0x146>
    2ff0:	a0 cf       	rjmp	.-192    	; 0x2f32 <vCoRoutineSchedule+0x86>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    2ff2:	90 93 7c 03 	sts	0x037C, r25
    2ff6:	80 93 7b 03 	sts	0x037B, r24
    2ffa:	90 91 7a 03 	lds	r25, 0x037A

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    2ffe:	29 e0       	ldi	r18, 0x09	; 9
    3000:	06 c0       	rjmp	.+12     	; 0x300e <vCoRoutineSchedule+0x162>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    3002:	99 23       	and	r25, r25
    3004:	19 f4       	brne	.+6      	; 0x300c <vCoRoutineSchedule+0x160>
    3006:	10 92 7a 03 	sts	0x037A, r1
    300a:	32 c0       	rjmp	.+100    	; 0x3070 <vCoRoutineSchedule+0x1c4>
    300c:	91 50       	subi	r25, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    300e:	92 9f       	mul	r25, r18
    3010:	d0 01       	movw	r26, r0
    3012:	11 24       	eor	r1, r1
    3014:	af 57       	subi	r26, 0x7F	; 127
    3016:	bc 4f       	sbci	r27, 0xFC	; 252
    3018:	8c 91       	ld	r24, X
    301a:	88 23       	and	r24, r24
    301c:	91 f3       	breq	.-28     	; 0x3002 <vCoRoutineSchedule+0x156>
    301e:	90 93 7a 03 	sts	0x037A, r25
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    3022:	11 96       	adiw	r26, 0x01	; 1
    3024:	ed 91       	ld	r30, X+
    3026:	fc 91       	ld	r31, X
    3028:	12 97       	sbiw	r26, 0x02	; 2
    302a:	02 80       	ldd	r0, Z+2	; 0x02
    302c:	f3 81       	ldd	r31, Z+3	; 0x03
    302e:	e0 2d       	mov	r30, r0
    3030:	12 96       	adiw	r26, 0x02	; 2
    3032:	fc 93       	st	X, r31
    3034:	ee 93       	st	-X, r30
    3036:	11 97       	sbiw	r26, 0x01	; 1
    3038:	cd 01       	movw	r24, r26
    303a:	03 96       	adiw	r24, 0x03	; 3
    303c:	e8 17       	cp	r30, r24
    303e:	f9 07       	cpc	r31, r25
    3040:	31 f4       	brne	.+12     	; 0x304e <vCoRoutineSchedule+0x1a2>
    3042:	82 81       	ldd	r24, Z+2	; 0x02
    3044:	93 81       	ldd	r25, Z+3	; 0x03
    3046:	12 96       	adiw	r26, 0x02	; 2
    3048:	9c 93       	st	X, r25
    304a:	8e 93       	st	-X, r24
    304c:	11 97       	sbiw	r26, 0x01	; 1
    304e:	11 96       	adiw	r26, 0x01	; 1
    3050:	ed 91       	ld	r30, X+
    3052:	fc 91       	ld	r31, X
    3054:	12 97       	sbiw	r26, 0x02	; 2
    3056:	06 80       	ldd	r0, Z+6	; 0x06
    3058:	f7 81       	ldd	r31, Z+7	; 0x07
    305a:	e0 2d       	mov	r30, r0
    305c:	f0 93 79 03 	sts	0x0379, r31
    3060:	e0 93 78 03 	sts	0x0378, r30

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    3064:	20 81       	ld	r18, Z
    3066:	31 81       	ldd	r19, Z+1	; 0x01
    3068:	cf 01       	movw	r24, r30
    306a:	67 89       	ldd	r22, Z+23	; 0x17
    306c:	f9 01       	movw	r30, r18
    306e:	09 95       	icall

	return;
}
    3070:	df 91       	pop	r29
    3072:	cf 91       	pop	r28
    3074:	1f 91       	pop	r17
    3076:	0f 91       	pop	r16
    3078:	ff 90       	pop	r15
    307a:	08 95       	ret

0000307c <vCoRoutineAddToDelayedList>:
	return xReturn;	
}
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    307c:	0f 93       	push	r16
    307e:	1f 93       	push	r17
    3080:	cf 93       	push	r28
    3082:	df 93       	push	r29
    3084:	eb 01       	movw	r28, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    3086:	00 91 7f 03 	lds	r16, 0x037F
    308a:	10 91 80 03 	lds	r17, 0x0380
    308e:	08 0f       	add	r16, r24
    3090:	19 1f       	adc	r17, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    3092:	80 91 78 03 	lds	r24, 0x0378
    3096:	90 91 79 03 	lds	r25, 0x0379
    309a:	02 96       	adiw	r24, 0x02	; 2
    309c:	0e 94 58 0e 	call	0x1cb0	; 0x1cb0 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    30a0:	e0 91 78 03 	lds	r30, 0x0378
    30a4:	f0 91 79 03 	lds	r31, 0x0379
    30a8:	13 83       	std	Z+3, r17	; 0x03
    30aa:	02 83       	std	Z+2, r16	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    30ac:	80 91 7f 03 	lds	r24, 0x037F
    30b0:	90 91 80 03 	lds	r25, 0x0380
    30b4:	bf 01       	movw	r22, r30
    30b6:	6e 5f       	subi	r22, 0xFE	; 254
    30b8:	7f 4f       	sbci	r23, 0xFF	; 255
    30ba:	08 17       	cp	r16, r24
    30bc:	19 07       	cpc	r17, r25
    30be:	28 f4       	brcc	.+10     	; 0x30ca <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    30c0:	80 91 a7 03 	lds	r24, 0x03A7
    30c4:	90 91 a8 03 	lds	r25, 0x03A8
    30c8:	04 c0       	rjmp	.+8      	; 0x30d2 <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    30ca:	80 91 a5 03 	lds	r24, 0x03A5
    30ce:	90 91 a6 03 	lds	r25, 0x03A6
    30d2:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <vListInsert>
	}

	if( pxEventList )
    30d6:	20 97       	sbiw	r28, 0x00	; 0
    30d8:	49 f0       	breq	.+18     	; 0x30ec <vCoRoutineAddToDelayedList+0x70>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    30da:	60 91 78 03 	lds	r22, 0x0378
    30de:	70 91 79 03 	lds	r23, 0x0379
    30e2:	64 5f       	subi	r22, 0xF4	; 244
    30e4:	7f 4f       	sbci	r23, 0xFF	; 255
    30e6:	ce 01       	movw	r24, r28
    30e8:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <vListInsert>
	}
}
    30ec:	df 91       	pop	r29
    30ee:	cf 91       	pop	r28
    30f0:	1f 91       	pop	r17
    30f2:	0f 91       	pop	r16
    30f4:	08 95       	ret

000030f6 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    30f6:	af 92       	push	r10
    30f8:	bf 92       	push	r11
    30fa:	cf 92       	push	r12
    30fc:	df 92       	push	r13
    30fe:	ef 92       	push	r14
    3100:	ff 92       	push	r15
    3102:	0f 93       	push	r16
    3104:	1f 93       	push	r17
    3106:	cf 93       	push	r28
    3108:	df 93       	push	r29
    310a:	6c 01       	movw	r12, r24
    310c:	b6 2e       	mov	r11, r22
    310e:	a4 2e       	mov	r10, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    3110:	8a e1       	ldi	r24, 0x1A	; 26
    3112:	90 e0       	ldi	r25, 0x00	; 0
    3114:	0e 94 05 19 	call	0x320a	; 0x320a <pvPortMalloc>
    3118:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
    311a:	00 97       	sbiw	r24, 0x00	; 0
    311c:	11 f4       	brne	.+4      	; 0x3122 <xCoRoutineCreate+0x2c>
    311e:	8f ef       	ldi	r24, 0xFF	; 255
    3120:	59 c0       	rjmp	.+178    	; 0x31d4 <xCoRoutineCreate+0xde>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    3122:	80 91 78 03 	lds	r24, 0x0378
    3126:	90 91 79 03 	lds	r25, 0x0379
    312a:	89 2b       	or	r24, r25
    312c:	21 f5       	brne	.+72     	; 0x3176 <xCoRoutineCreate+0x80>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    312e:	d0 93 79 03 	sts	0x0379, r29
    3132:	c0 93 78 03 	sts	0x0378, r28
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    3136:	81 e8       	ldi	r24, 0x81	; 129
    3138:	93 e0       	ldi	r25, 0x03	; 3
    313a:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <vListInitialise>
    313e:	8a e8       	ldi	r24, 0x8A	; 138
    3140:	93 e0       	ldi	r25, 0x03	; 3
    3142:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    3146:	23 e9       	ldi	r18, 0x93	; 147
    3148:	e2 2e       	mov	r14, r18
    314a:	23 e0       	ldi	r18, 0x03	; 3
    314c:	f2 2e       	mov	r15, r18
    314e:	c7 01       	movw	r24, r14
    3150:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    3154:	0c e9       	ldi	r16, 0x9C	; 156
    3156:	13 e0       	ldi	r17, 0x03	; 3
    3158:	c8 01       	movw	r24, r16
    315a:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    315e:	89 ea       	ldi	r24, 0xA9	; 169
    3160:	93 e0       	ldi	r25, 0x03	; 3
    3162:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    3166:	f0 92 a6 03 	sts	0x03A6, r15
    316a:	e0 92 a5 03 	sts	0x03A5, r14
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    316e:	10 93 a8 03 	sts	0x03A8, r17
    3172:	00 93 a7 03 	sts	0x03A7, r16
    3176:	eb 2c       	mov	r14, r11
    3178:	bb 20       	and	r11, r11
    317a:	11 f0       	breq	.+4      	; 0x3180 <xCoRoutineCreate+0x8a>
    317c:	ee 24       	eor	r14, r14
    317e:	e3 94       	inc	r14
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    3180:	19 8e       	std	Y+25, r1	; 0x19
    3182:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    3184:	ee 8a       	std	Y+22, r14	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    3186:	af 8a       	std	Y+23, r10	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    3188:	fe 01       	movw	r30, r28
    318a:	c1 92       	st	Z+, r12
    318c:	d1 92       	st	Z+, r13
    318e:	8f 01       	movw	r16, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    3190:	cf 01       	movw	r24, r30
    3192:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    3196:	ce 01       	movw	r24, r28
    3198:	0c 96       	adiw	r24, 0x0c	; 12
    319a:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    319e:	d9 87       	std	Y+9, r29	; 0x09
    31a0:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    31a2:	db 8b       	std	Y+19, r29	; 0x13
    31a4:	ca 8b       	std	Y+18, r28	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    31a6:	84 e0       	ldi	r24, 0x04	; 4
    31a8:	90 e0       	ldi	r25, 0x00	; 0
    31aa:	8e 19       	sub	r24, r14
    31ac:	91 09       	sbc	r25, r1
    31ae:	9d 87       	std	Y+13, r25	; 0x0d
    31b0:	8c 87       	std	Y+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    31b2:	9e 89       	ldd	r25, Y+22	; 0x16
    31b4:	80 91 7a 03 	lds	r24, 0x037A
    31b8:	89 17       	cp	r24, r25
    31ba:	10 f4       	brcc	.+4      	; 0x31c0 <xCoRoutineCreate+0xca>
    31bc:	90 93 7a 03 	sts	0x037A, r25
    31c0:	89 e0       	ldi	r24, 0x09	; 9
    31c2:	98 9f       	mul	r25, r24
    31c4:	c0 01       	movw	r24, r0
    31c6:	11 24       	eor	r1, r1
    31c8:	8f 57       	subi	r24, 0x7F	; 127
    31ca:	9c 4f       	sbci	r25, 0xFC	; 252
    31cc:	b8 01       	movw	r22, r16
    31ce:	0e 94 fa 0d 	call	0x1bf4	; 0x1bf4 <vListInsertEnd>
    31d2:	81 e0       	ldi	r24, 0x01	; 1
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
	}
	
	return xReturn;	
}
    31d4:	df 91       	pop	r29
    31d6:	cf 91       	pop	r28
    31d8:	1f 91       	pop	r17
    31da:	0f 91       	pop	r16
    31dc:	ff 90       	pop	r15
    31de:	ef 90       	pop	r14
    31e0:	df 90       	pop	r13
    31e2:	cf 90       	pop	r12
    31e4:	bf 90       	pop	r11
    31e6:	af 90       	pop	r10
    31e8:	08 95       	ret

000031ea <vPortFree>:
{
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    31ea:	08 95       	ret

000031ec <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    31ec:	10 92 b3 03 	sts	0x03B3, r1
    31f0:	10 92 b2 03 	sts	0x03B2, r1
}
    31f4:	08 95       	ret

000031f6 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    31f6:	28 eb       	ldi	r18, 0xB8	; 184
    31f8:	3b e0       	ldi	r19, 0x0B	; 11
    31fa:	80 91 b2 03 	lds	r24, 0x03B2
    31fe:	90 91 b3 03 	lds	r25, 0x03B3
    3202:	28 1b       	sub	r18, r24
    3204:	39 0b       	sbc	r19, r25
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
}
    3206:	c9 01       	movw	r24, r18
    3208:	08 95       	ret

0000320a <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    320a:	0f 93       	push	r16
    320c:	1f 93       	push	r17
    320e:	cf 93       	push	r28
    3210:	df 93       	push	r29
    3212:	8c 01       	movw	r16, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    3214:	0e 94 65 11 	call	0x22ca	; 0x22ca <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    3218:	80 91 b2 03 	lds	r24, 0x03B2
    321c:	90 91 b3 03 	lds	r25, 0x03B3
    3220:	98 01       	movw	r18, r16
    3222:	28 0f       	add	r18, r24
    3224:	39 1f       	adc	r19, r25
    3226:	4b e0       	ldi	r20, 0x0B	; 11
    3228:	28 3b       	cpi	r18, 0xB8	; 184
    322a:	34 07       	cpc	r19, r20
    322c:	58 f4       	brcc	.+22     	; 0x3244 <pvPortMalloc+0x3a>
    322e:	82 17       	cp	r24, r18
    3230:	93 07       	cpc	r25, r19
    3232:	40 f4       	brcc	.+16     	; 0x3244 <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    3234:	ec 01       	movw	r28, r24
    3236:	cc 54       	subi	r28, 0x4C	; 76
    3238:	dc 4f       	sbci	r29, 0xFC	; 252
			xNextFreeByte += xWantedSize;			
    323a:	30 93 b3 03 	sts	0x03B3, r19
    323e:	20 93 b2 03 	sts	0x03B2, r18
    3242:	02 c0       	rjmp	.+4      	; 0x3248 <pvPortMalloc+0x3e>
    3244:	c0 e0       	ldi	r28, 0x00	; 0
    3246:	d0 e0       	ldi	r29, 0x00	; 0
		}	
	}
	xTaskResumeAll();
    3248:	0e 94 fc 12 	call	0x25f8	; 0x25f8 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
    324c:	ce 01       	movw	r24, r28
    324e:	df 91       	pop	r29
    3250:	cf 91       	pop	r28
    3252:	1f 91       	pop	r17
    3254:	0f 91       	pop	r16
    3256:	08 95       	ret

00003258 <prescaler_hex_to_value>:
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    3258:	e8 2f       	mov	r30, r24
    325a:	f0 e0       	ldi	r31, 0x00	; 0
    325c:	e7 70       	andi	r30, 0x07	; 7
    325e:	f0 70       	andi	r31, 0x00	; 0
    3260:	ee 0f       	add	r30, r30
    3262:	ff 1f       	adc	r31, r31
    3264:	e2 57       	subi	r30, 0x72	; 114
    3266:	fe 4f       	sbci	r31, 0xFE	; 254
    3268:	25 91       	lpm	r18, Z+
    326a:	34 91       	lpm	r19, Z+
}
    326c:	c9 01       	movw	r24, r18
    326e:	08 95       	ret

00003270 <prescaler_hex_to_value_for_timer2>:
uint16_t prescaler_hex_to_value_for_timer2(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to Timer2PrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(Timer2PrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    3270:	e8 2f       	mov	r30, r24
    3272:	f0 e0       	ldi	r31, 0x00	; 0
    3274:	e7 70       	andi	r30, 0x07	; 7
    3276:	f0 70       	andi	r31, 0x00	; 0
    3278:	ee 0f       	add	r30, r30
    327a:	ff 1f       	adc	r31, r31
    327c:	e6 56       	subi	r30, 0x66	; 102
    327e:	fe 4f       	sbci	r31, 0xFE	; 254
    3280:	25 91       	lpm	r18, Z+
    3282:	34 91       	lpm	r19, Z+
}
    3284:	c9 01       	movw	r24, r18
    3286:	08 95       	ret

00003288 <get_timer0_prescaler>:

uint16_t get_timer0_prescaler(void)
{
  return prescaler_hex_to_value(TCCR0B);
    3288:	85 b5       	in	r24, 0x25	; 37
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    328a:	e8 2f       	mov	r30, r24
    328c:	f0 e0       	ldi	r31, 0x00	; 0
    328e:	e7 70       	andi	r30, 0x07	; 7
    3290:	f0 70       	andi	r31, 0x00	; 0
    3292:	ee 0f       	add	r30, r30
    3294:	ff 1f       	adc	r31, r31
    3296:	e2 57       	subi	r30, 0x72	; 114
    3298:	fe 4f       	sbci	r31, 0xFE	; 254
    329a:	25 91       	lpm	r18, Z+
    329c:	34 91       	lpm	r19, Z+
}

uint16_t get_timer0_prescaler(void)
{
  return prescaler_hex_to_value(TCCR0B);
}
    329e:	c9 01       	movw	r24, r18
    32a0:	08 95       	ret

000032a2 <get_timer1_prescaler>:
uint16_t get_timer1_prescaler(void)
{
  return prescaler_hex_to_value(TCCR1B);
    32a2:	80 91 81 00 	lds	r24, 0x0081
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    32a6:	e8 2f       	mov	r30, r24
    32a8:	f0 e0       	ldi	r31, 0x00	; 0
    32aa:	e7 70       	andi	r30, 0x07	; 7
    32ac:	f0 70       	andi	r31, 0x00	; 0
    32ae:	ee 0f       	add	r30, r30
    32b0:	ff 1f       	adc	r31, r31
    32b2:	e2 57       	subi	r30, 0x72	; 114
    32b4:	fe 4f       	sbci	r31, 0xFE	; 254
    32b6:	25 91       	lpm	r18, Z+
    32b8:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR0B);
}
uint16_t get_timer1_prescaler(void)
{
  return prescaler_hex_to_value(TCCR1B);
}
    32ba:	c9 01       	movw	r24, r18
    32bc:	08 95       	ret

000032be <get_timer2_prescaler>:
uint16_t get_timer2_prescaler(void)
{
  return prescaler_hex_to_value_for_timer2(TCCR2B);
    32be:	80 91 b1 00 	lds	r24, 0x00B1
uint16_t prescaler_hex_to_value_for_timer2(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to Timer2PrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(Timer2PrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    32c2:	e8 2f       	mov	r30, r24
    32c4:	f0 e0       	ldi	r31, 0x00	; 0
    32c6:	e7 70       	andi	r30, 0x07	; 7
    32c8:	f0 70       	andi	r31, 0x00	; 0
    32ca:	ee 0f       	add	r30, r30
    32cc:	ff 1f       	adc	r31, r31
    32ce:	e6 56       	subi	r30, 0x66	; 102
    32d0:	fe 4f       	sbci	r31, 0xFE	; 254
    32d2:	25 91       	lpm	r18, Z+
    32d4:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR1B);
}
uint16_t get_timer2_prescaler(void)
{
  return prescaler_hex_to_value_for_timer2(TCCR2B);
}
    32d6:	c9 01       	movw	r24, r18
    32d8:	08 95       	ret

000032da <get_timer3_prescaler>:
uint16_t get_timer3_prescaler(void)
{
  return prescaler_hex_to_value(TCCR3B);
    32da:	80 91 91 00 	lds	r24, 0x0091
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    32de:	e8 2f       	mov	r30, r24
    32e0:	f0 e0       	ldi	r31, 0x00	; 0
    32e2:	e7 70       	andi	r30, 0x07	; 7
    32e4:	f0 70       	andi	r31, 0x00	; 0
    32e6:	ee 0f       	add	r30, r30
    32e8:	ff 1f       	adc	r31, r31
    32ea:	e2 57       	subi	r30, 0x72	; 114
    32ec:	fe 4f       	sbci	r31, 0xFE	; 254
    32ee:	25 91       	lpm	r18, Z+
    32f0:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value_for_timer2(TCCR2B);
}
uint16_t get_timer3_prescaler(void)
{
  return prescaler_hex_to_value(TCCR3B);
}
    32f2:	c9 01       	movw	r24, r18
    32f4:	08 95       	ret

000032f6 <get_timer4_prescaler>:
uint16_t get_timer4_prescaler(void)
{
  return prescaler_hex_to_value(TCCR4B);
    32f6:	80 91 a1 00 	lds	r24, 0x00A1
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    32fa:	e8 2f       	mov	r30, r24
    32fc:	f0 e0       	ldi	r31, 0x00	; 0
    32fe:	e7 70       	andi	r30, 0x07	; 7
    3300:	f0 70       	andi	r31, 0x00	; 0
    3302:	ee 0f       	add	r30, r30
    3304:	ff 1f       	adc	r31, r31
    3306:	e2 57       	subi	r30, 0x72	; 114
    3308:	fe 4f       	sbci	r31, 0xFE	; 254
    330a:	25 91       	lpm	r18, Z+
    330c:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR3B);
}
uint16_t get_timer4_prescaler(void)
{
  return prescaler_hex_to_value(TCCR4B);
}
    330e:	c9 01       	movw	r24, r18
    3310:	08 95       	ret

00003312 <get_timer5_prescaler>:
uint16_t get_timer5_prescaler(void)
{
  return prescaler_hex_to_value(TCCR5B);
    3312:	80 91 21 01 	lds	r24, 0x0121
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    3316:	e8 2f       	mov	r30, r24
    3318:	f0 e0       	ldi	r31, 0x00	; 0
    331a:	e7 70       	andi	r30, 0x07	; 7
    331c:	f0 70       	andi	r31, 0x00	; 0
    331e:	ee 0f       	add	r30, r30
    3320:	ff 1f       	adc	r31, r31
    3322:	e2 57       	subi	r30, 0x72	; 114
    3324:	fe 4f       	sbci	r31, 0xFE	; 254
    3326:	25 91       	lpm	r18, Z+
    3328:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR4B);
}
uint16_t get_timer5_prescaler(void)
{
  return prescaler_hex_to_value(TCCR5B);
}
    332a:	c9 01       	movw	r24, r18
    332c:	08 95       	ret

0000332e <get_timer0_overflow>:

const uint32_t get_timer0_overflow(void)
{
    return timer0_ovrflow_cnt;
    332e:	20 91 53 14 	lds	r18, 0x1453
    3332:	30 91 54 14 	lds	r19, 0x1454
    3336:	40 91 55 14 	lds	r20, 0x1455
    333a:	50 91 56 14 	lds	r21, 0x1456
}
    333e:	b9 01       	movw	r22, r18
    3340:	ca 01       	movw	r24, r20
    3342:	08 95       	ret

00003344 <get_timer1_overflow>:
const uint32_t get_timer1_overflow(void)
{
    return timer1_ovrflow_cnt;
    3344:	20 91 4f 14 	lds	r18, 0x144F
    3348:	30 91 50 14 	lds	r19, 0x1450
    334c:	40 91 51 14 	lds	r20, 0x1451
    3350:	50 91 52 14 	lds	r21, 0x1452
}
    3354:	b9 01       	movw	r22, r18
    3356:	ca 01       	movw	r24, r20
    3358:	08 95       	ret

0000335a <get_timer2_overflow>:
const uint32_t get_timer2_overflow(void)
{
    return timer2_ovrflow_cnt;
    335a:	20 91 57 14 	lds	r18, 0x1457
    335e:	30 91 58 14 	lds	r19, 0x1458
    3362:	40 91 59 14 	lds	r20, 0x1459
    3366:	50 91 5a 14 	lds	r21, 0x145A
}
    336a:	b9 01       	movw	r22, r18
    336c:	ca 01       	movw	r24, r20
    336e:	08 95       	ret

00003370 <get_timer3_overflow>:
const uint32_t get_timer3_overflow(void)
{
    return timer3_ovrflow_cnt;
    3370:	20 91 5f 14 	lds	r18, 0x145F
    3374:	30 91 60 14 	lds	r19, 0x1460
    3378:	40 91 61 14 	lds	r20, 0x1461
    337c:	50 91 62 14 	lds	r21, 0x1462
}
    3380:	b9 01       	movw	r22, r18
    3382:	ca 01       	movw	r24, r20
    3384:	08 95       	ret

00003386 <get_timer4_overflow>:
const uint32_t get_timer4_overflow(void)
{
    return timer4_ovrflow_cnt;
    3386:	20 91 4b 14 	lds	r18, 0x144B
    338a:	30 91 4c 14 	lds	r19, 0x144C
    338e:	40 91 4d 14 	lds	r20, 0x144D
    3392:	50 91 4e 14 	lds	r21, 0x144E
}
    3396:	b9 01       	movw	r22, r18
    3398:	ca 01       	movw	r24, r20
    339a:	08 95       	ret

0000339c <get_timer5_overflow>:
const uint32_t get_timer5_overflow(void)
{
    return timer5_ovrflow_cnt;
    339c:	20 91 63 14 	lds	r18, 0x1463
    33a0:	30 91 64 14 	lds	r19, 0x1464
    33a4:	40 91 65 14 	lds	r20, 0x1465
    33a8:	50 91 66 14 	lds	r21, 0x1466
}
    33ac:	b9 01       	movw	r22, r18
    33ae:	ca 01       	movw	r24, r20
    33b0:	08 95       	ret

000033b2 <get_timer0_counter>:

const uint8_t get_timer0_counter(void)
{
    return TCNT0;
    33b2:	86 b5       	in	r24, 0x26	; 38
}
    33b4:	08 95       	ret

000033b6 <get_timer1_counter>:
const uint16_t get_timer1_counter(void)
{
    return TCNT1;
    33b6:	20 91 84 00 	lds	r18, 0x0084
    33ba:	30 91 85 00 	lds	r19, 0x0085
}
    33be:	c9 01       	movw	r24, r18
    33c0:	08 95       	ret

000033c2 <get_timer2_counter>:
const uint8_t get_timer2_counter(void)
{
    return TCNT2;
    33c2:	80 91 b2 00 	lds	r24, 0x00B2
}
    33c6:	08 95       	ret

000033c8 <get_timer3_counter>:
const uint16_t get_timer3_counter(void)
{
    return TCNT3;
    33c8:	20 91 94 00 	lds	r18, 0x0094
    33cc:	30 91 95 00 	lds	r19, 0x0095
}
    33d0:	c9 01       	movw	r24, r18
    33d2:	08 95       	ret

000033d4 <get_timer4_counter>:
const uint16_t get_timer4_counter(void)
{
    return TCNT4;
    33d4:	20 91 a4 00 	lds	r18, 0x00A4
    33d8:	30 91 a5 00 	lds	r19, 0x00A5
}
    33dc:	c9 01       	movw	r24, r18
    33de:	08 95       	ret

000033e0 <get_timer5_counter>:
const uint16_t get_timer5_counter(void)
{
    return TCNT5;
    33e0:	20 91 24 01 	lds	r18, 0x0124
    33e4:	30 91 25 01 	lds	r19, 0x0125
}
    33e8:	c9 01       	movw	r24, r18
    33ea:	08 95       	ret

000033ec <reset_timer0>:

void reset_timer0(void)
{
    TCNT0 = timer0_ovrflow_cnt = 0;
    33ec:	10 92 53 14 	sts	0x1453, r1
    33f0:	10 92 54 14 	sts	0x1454, r1
    33f4:	10 92 55 14 	sts	0x1455, r1
    33f8:	10 92 56 14 	sts	0x1456, r1
    33fc:	16 bc       	out	0x26, r1	; 38
}
    33fe:	08 95       	ret

00003400 <reset_timer1>:
void reset_timer1(void)
{
    TCNT1 = timer1_ovrflow_cnt = 0;
    3400:	10 92 4f 14 	sts	0x144F, r1
    3404:	10 92 50 14 	sts	0x1450, r1
    3408:	10 92 51 14 	sts	0x1451, r1
    340c:	10 92 52 14 	sts	0x1452, r1
    3410:	10 92 85 00 	sts	0x0085, r1
    3414:	10 92 84 00 	sts	0x0084, r1
}
    3418:	08 95       	ret

0000341a <reset_timer2>:
void reset_timer2(void)
{
    TCNT2 = timer2_ovrflow_cnt = 0;
    341a:	10 92 57 14 	sts	0x1457, r1
    341e:	10 92 58 14 	sts	0x1458, r1
    3422:	10 92 59 14 	sts	0x1459, r1
    3426:	10 92 5a 14 	sts	0x145A, r1
    342a:	10 92 b2 00 	sts	0x00B2, r1
}
    342e:	08 95       	ret

00003430 <reset_timer3>:
void reset_timer3(void)
{
    TCNT3 = timer3_ovrflow_cnt = 0;
    3430:	10 92 5f 14 	sts	0x145F, r1
    3434:	10 92 60 14 	sts	0x1460, r1
    3438:	10 92 61 14 	sts	0x1461, r1
    343c:	10 92 62 14 	sts	0x1462, r1
    3440:	10 92 95 00 	sts	0x0095, r1
    3444:	10 92 94 00 	sts	0x0094, r1
}
    3448:	08 95       	ret

0000344a <reset_timer4>:
void reset_timer4(void)
{
    TCNT4 = timer4_ovrflow_cnt = 0;
    344a:	10 92 4b 14 	sts	0x144B, r1
    344e:	10 92 4c 14 	sts	0x144C, r1
    3452:	10 92 4d 14 	sts	0x144D, r1
    3456:	10 92 4e 14 	sts	0x144E, r1
    345a:	10 92 a5 00 	sts	0x00A5, r1
    345e:	10 92 a4 00 	sts	0x00A4, r1
}
    3462:	08 95       	ret

00003464 <reset_timer5>:
void reset_timer5(void)
{
    TCNT5 = timer5_ovrflow_cnt = 0;
    3464:	10 92 63 14 	sts	0x1463, r1
    3468:	10 92 64 14 	sts	0x1464, r1
    346c:	10 92 65 14 	sts	0x1465, r1
    3470:	10 92 66 14 	sts	0x1466, r1
    3474:	10 92 25 01 	sts	0x0125, r1
    3478:	10 92 24 01 	sts	0x0124, r1
}
    347c:	08 95       	ret

0000347e <delay_us>:

	delay_loops = ((time_us * CYCLES_PER_US)+3) / 5; // +3 for rounding up (dirty) 

	// one loop takes 5 cpu cycles 
	for (i=0; i < delay_loops; i++) {};
}
    347e:	08 95       	ret

00003480 <init_timer0>:

void init_timer0(const uint8_t prescaler)
{
  TCCR0B = prescaler;
    3480:	85 bd       	out	0x25, r24	; 37
  TIMSK0 = _BV(TOIE0); // enable interrupts
    3482:	81 e0       	ldi	r24, 0x01	; 1
    3484:	80 93 6e 00 	sts	0x006E, r24
    return TCNT5;
}

void reset_timer0(void)
{
    TCNT0 = timer0_ovrflow_cnt = 0;
    3488:	10 92 53 14 	sts	0x1453, r1
    348c:	10 92 54 14 	sts	0x1454, r1
    3490:	10 92 55 14 	sts	0x1455, r1
    3494:	10 92 56 14 	sts	0x1456, r1
    3498:	16 bc       	out	0x26, r1	; 38
void init_timer0(const uint8_t prescaler)
{
  TCCR0B = prescaler;
  TIMSK0 = _BV(TOIE0); // enable interrupts
  reset_timer0(); // reset counter
}
    349a:	08 95       	ret

0000349c <init_timer1>:
void init_timer1(const uint8_t prescaler)
{
  TCCR1B = prescaler;
    349c:	80 93 81 00 	sts	0x0081, r24
  TIMSK1 = _BV(TOIE1); // enable interrupts
    34a0:	81 e0       	ldi	r24, 0x01	; 1
    34a2:	80 93 6f 00 	sts	0x006F, r24
{
    TCNT0 = timer0_ovrflow_cnt = 0;
}
void reset_timer1(void)
{
    TCNT1 = timer1_ovrflow_cnt = 0;
    34a6:	10 92 4f 14 	sts	0x144F, r1
    34aa:	10 92 50 14 	sts	0x1450, r1
    34ae:	10 92 51 14 	sts	0x1451, r1
    34b2:	10 92 52 14 	sts	0x1452, r1
    34b6:	10 92 85 00 	sts	0x0085, r1
    34ba:	10 92 84 00 	sts	0x0084, r1
void init_timer1(const uint8_t prescaler)
{
  TCCR1B = prescaler;
  TIMSK1 = _BV(TOIE1); // enable interrupts
  reset_timer1(); // reset counter
}
    34be:	08 95       	ret

000034c0 <init_timer2>:
void init_timer2(const uint8_t prescaler)
{
  TCCR2B = prescaler;
    34c0:	80 93 b1 00 	sts	0x00B1, r24
  TIMSK2 = _BV(TOIE2); // enable interrupts
    34c4:	81 e0       	ldi	r24, 0x01	; 1
    34c6:	80 93 70 00 	sts	0x0070, r24
{
    TCNT1 = timer1_ovrflow_cnt = 0;
}
void reset_timer2(void)
{
    TCNT2 = timer2_ovrflow_cnt = 0;
    34ca:	10 92 57 14 	sts	0x1457, r1
    34ce:	10 92 58 14 	sts	0x1458, r1
    34d2:	10 92 59 14 	sts	0x1459, r1
    34d6:	10 92 5a 14 	sts	0x145A, r1
    34da:	10 92 b2 00 	sts	0x00B2, r1
void init_timer2(const uint8_t prescaler)
{
  TCCR2B = prescaler;
  TIMSK2 = _BV(TOIE2); // enable interrupts
  reset_timer2(); // reset counter
}
    34de:	08 95       	ret

000034e0 <init_timer3>:
void init_timer3(const uint8_t prescaler)
{
  TCCR3B = prescaler;
    34e0:	80 93 91 00 	sts	0x0091, r24
  TIMSK3 = _BV(TOIE3); // enable interrupts
    34e4:	81 e0       	ldi	r24, 0x01	; 1
    34e6:	80 93 71 00 	sts	0x0071, r24
{
    TCNT2 = timer2_ovrflow_cnt = 0;
}
void reset_timer3(void)
{
    TCNT3 = timer3_ovrflow_cnt = 0;
    34ea:	10 92 5f 14 	sts	0x145F, r1
    34ee:	10 92 60 14 	sts	0x1460, r1
    34f2:	10 92 61 14 	sts	0x1461, r1
    34f6:	10 92 62 14 	sts	0x1462, r1
    34fa:	10 92 95 00 	sts	0x0095, r1
    34fe:	10 92 94 00 	sts	0x0094, r1
void init_timer3(const uint8_t prescaler)
{
  TCCR3B = prescaler;
  TIMSK3 = _BV(TOIE3); // enable interrupts
  reset_timer3(); // reset counter
}
    3502:	08 95       	ret

00003504 <init_timer4>:
void init_timer4(const uint8_t prescaler)
{
  TCCR4B = prescaler;
    3504:	80 93 a1 00 	sts	0x00A1, r24
  TIMSK4 = _BV(TOIE4); // enable interrupts
    3508:	81 e0       	ldi	r24, 0x01	; 1
    350a:	80 93 72 00 	sts	0x0072, r24
{
    TCNT3 = timer3_ovrflow_cnt = 0;
}
void reset_timer4(void)
{
    TCNT4 = timer4_ovrflow_cnt = 0;
    350e:	10 92 4b 14 	sts	0x144B, r1
    3512:	10 92 4c 14 	sts	0x144C, r1
    3516:	10 92 4d 14 	sts	0x144D, r1
    351a:	10 92 4e 14 	sts	0x144E, r1
    351e:	10 92 a5 00 	sts	0x00A5, r1
    3522:	10 92 a4 00 	sts	0x00A4, r1
void init_timer4(const uint8_t prescaler)
{
  TCCR4B = prescaler;
  TIMSK4 = _BV(TOIE4); // enable interrupts
  reset_timer4(); // reset counter
}
    3526:	08 95       	ret

00003528 <init_timer5>:
void init_timer5(const uint8_t prescaler)
{
  TCCR5B = prescaler;
    3528:	80 93 21 01 	sts	0x0121, r24
  TIMSK5 = _BV(TOIE5); // enable interrupts
    352c:	81 e0       	ldi	r24, 0x01	; 1
    352e:	80 93 73 00 	sts	0x0073, r24
{
    TCNT4 = timer4_ovrflow_cnt = 0;
}
void reset_timer5(void)
{
    TCNT5 = timer5_ovrflow_cnt = 0;
    3532:	10 92 63 14 	sts	0x1463, r1
    3536:	10 92 64 14 	sts	0x1464, r1
    353a:	10 92 65 14 	sts	0x1465, r1
    353e:	10 92 66 14 	sts	0x1466, r1
    3542:	10 92 25 01 	sts	0x0125, r1
    3546:	10 92 24 01 	sts	0x0124, r1
void init_timer5(const uint8_t prescaler)
{
  TCCR5B = prescaler;
  TIMSK5 = _BV(TOIE5); // enable interrupts
  reset_timer5(); // reset counter
}
    354a:	08 95       	ret

0000354c <timer_attach>:

void timer_attach(TimerInterrupt_t interrupt, void (*user_func)(void) )
{
  // set the interrupt function to run
  // the supplied user's function
  TimerIntFunc[interrupt] = user_func;
    354c:	e8 2f       	mov	r30, r24
    354e:	f0 e0       	ldi	r31, 0x00	; 0
    3550:	ee 0f       	add	r30, r30
    3552:	ff 1f       	adc	r31, r31
    3554:	e4 59       	subi	r30, 0x94	; 148
    3556:	f0 4f       	sbci	r31, 0xF0	; 240
    3558:	71 83       	std	Z+1, r23	; 0x01
    355a:	60 83       	st	Z, r22
}
    355c:	08 95       	ret

0000355e <timer_detach>:

void timer_detach(TimerInterrupt_t interrupt)
{
  // clear the user defined interrupt function
  TimerIntFunc[interrupt] = NULL;
    355e:	e8 2f       	mov	r30, r24
    3560:	f0 e0       	ldi	r31, 0x00	; 0
    3562:	ee 0f       	add	r30, r30
    3564:	ff 1f       	adc	r31, r31
    3566:	e4 59       	subi	r30, 0x94	; 148
    3568:	f0 4f       	sbci	r31, 0xF0	; 240
    356a:	11 82       	std	Z+1, r1	; 0x01
    356c:	10 82       	st	Z, r1
}
    356e:	08 95       	ret

00003570 <_delay_loop_2>:

void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3570:	01 97       	sbiw	r24, 0x01	; 1
    3572:	f1 f7       	brne	.-4      	; 0x3570 <_delay_loop_2>
		"1: sbiw %0,1" "\n\t"
		"brne 1b"
		: "=w" (__count)
		: "0" (__count)
	);
}
    3574:	08 95       	ret

00003576 <sleep>:

void sleep(uint16_t time_ms)
{
    3576:	af 92       	push	r10
    3578:	bf 92       	push	r11
    357a:	cf 92       	push	r12
    357c:	df 92       	push	r13
    357e:	ef 92       	push	r14
    3580:	ff 92       	push	r15
    3582:	0f 93       	push	r16
    3584:	1f 93       	push	r17
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * time_ms;
    3586:	a0 e0       	ldi	r26, 0x00	; 0
    3588:	b0 e0       	ldi	r27, 0x00	; 0
    358a:	bc 01       	movw	r22, r24
    358c:	cd 01       	movw	r24, r26
    358e:	0e 94 5f 2c 	call	0x58be	; 0x58be <__floatunsisf>
    3592:	5b 01       	movw	r10, r22
    3594:	6c 01       	movw	r12, r24
    3596:	20 e0       	ldi	r18, 0x00	; 0
    3598:	30 e0       	ldi	r19, 0x00	; 0
    359a:	4a e7       	ldi	r20, 0x7A	; 122
    359c:	55 e4       	ldi	r21, 0x45	; 69
    359e:	0e 94 96 2d 	call	0x5b2c	; 0x5b2c <__mulsf3>
    35a2:	7b 01       	movw	r14, r22
    35a4:	8c 01       	movw	r16, r24
	if (__tmp < 1.0)
    35a6:	20 e0       	ldi	r18, 0x00	; 0
    35a8:	30 e0       	ldi	r19, 0x00	; 0
    35aa:	40 e8       	ldi	r20, 0x80	; 128
    35ac:	5f e3       	ldi	r21, 0x3F	; 63
    35ae:	0e 94 c2 2b 	call	0x5784	; 0x5784 <__cmpsf2>
    35b2:	88 23       	and	r24, r24
    35b4:	1c f4       	brge	.+6      	; 0x35bc <sleep+0x46>
    35b6:	61 e0       	ldi	r22, 0x01	; 1
    35b8:	70 e0       	ldi	r23, 0x00	; 0
    35ba:	24 c0       	rjmp	.+72     	; 0x3604 <sleep+0x8e>
		__ticks = 1;
	else if (__tmp > 65535)
    35bc:	c8 01       	movw	r24, r16
    35be:	b7 01       	movw	r22, r14
    35c0:	20 e0       	ldi	r18, 0x00	; 0
    35c2:	3f ef       	ldi	r19, 0xFF	; 255
    35c4:	4f e7       	ldi	r20, 0x7F	; 127
    35c6:	57 e4       	ldi	r21, 0x47	; 71
    35c8:	0e 94 8b 2d 	call	0x5b16	; 0x5b16 <__gesf2>
    35cc:	18 16       	cp	r1, r24
    35ce:	b4 f4       	brge	.+44     	; 0x35fc <sleep+0x86>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (time_ms * 10.0);
    35d0:	c6 01       	movw	r24, r12
    35d2:	b5 01       	movw	r22, r10
    35d4:	20 e0       	ldi	r18, 0x00	; 0
    35d6:	30 e0       	ldi	r19, 0x00	; 0
    35d8:	40 e2       	ldi	r20, 0x20	; 32
    35da:	51 e4       	ldi	r21, 0x41	; 65
    35dc:	0e 94 96 2d 	call	0x5b2c	; 0x5b2c <__mulsf3>
    35e0:	0e 94 33 2c 	call	0x5866	; 0x5866 <__fixunssfsi>
}

void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    35e4:	80 e9       	ldi	r24, 0x90	; 144
    35e6:	91 e0       	ldi	r25, 0x01	; 1
    35e8:	05 c0       	rjmp	.+10     	; 0x35f4 <sleep+0x7e>
    35ea:	fc 01       	movw	r30, r24
    35ec:	31 97       	sbiw	r30, 0x01	; 1
    35ee:	f1 f7       	brne	.-4      	; 0x35ec <sleep+0x76>
		__ticks = (uint16_t) (time_ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    35f0:	61 50       	subi	r22, 0x01	; 1
    35f2:	70 40       	sbci	r23, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (time_ms * 10.0);
		while(__ticks)
    35f4:	61 15       	cp	r22, r1
    35f6:	71 05       	cpc	r23, r1
    35f8:	c1 f7       	brne	.-16     	; 0x35ea <sleep+0x74>
    35fa:	07 c0       	rjmp	.+14     	; 0x360a <sleep+0x94>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    35fc:	c8 01       	movw	r24, r16
    35fe:	b7 01       	movw	r22, r14
    3600:	0e 94 33 2c 	call	0x5866	; 0x5866 <__fixunssfsi>
}

void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3604:	cb 01       	movw	r24, r22
    3606:	01 97       	sbiw	r24, 0x01	; 1
    3608:	f1 f7       	brne	.-4      	; 0x3606 <sleep+0x90>
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
	_delay_loop_2(__ticks);
}
    360a:	1f 91       	pop	r17
    360c:	0f 91       	pop	r16
    360e:	ff 90       	pop	r15
    3610:	ef 90       	pop	r14
    3612:	df 90       	pop	r13
    3614:	cf 90       	pop	r12
    3616:	bf 90       	pop	r11
    3618:	af 90       	pop	r10
    361a:	08 95       	ret

0000361c <__vector_23>:
    }
  }
}*/

ISR(TIMER0_OVF_vect) 
{
    361c:	1f 92       	push	r1
    361e:	0f 92       	push	r0
    3620:	0f b6       	in	r0, 0x3f	; 63
    3622:	0f 92       	push	r0
    3624:	11 24       	eor	r1, r1
    3626:	2f 93       	push	r18
    3628:	3f 93       	push	r19
    362a:	4f 93       	push	r20
    362c:	5f 93       	push	r21
    362e:	6f 93       	push	r22
    3630:	7f 93       	push	r23
    3632:	8f 93       	push	r24
    3634:	9f 93       	push	r25
    3636:	af 93       	push	r26
    3638:	bf 93       	push	r27
    363a:	ef 93       	push	r30
    363c:	ff 93       	push	r31
  timer0_ovrflow_cnt++;
    363e:	80 91 53 14 	lds	r24, 0x1453
    3642:	90 91 54 14 	lds	r25, 0x1454
    3646:	a0 91 55 14 	lds	r26, 0x1455
    364a:	b0 91 56 14 	lds	r27, 0x1456
    364e:	01 96       	adiw	r24, 0x01	; 1
    3650:	a1 1d       	adc	r26, r1
    3652:	b1 1d       	adc	r27, r1
    3654:	80 93 53 14 	sts	0x1453, r24
    3658:	90 93 54 14 	sts	0x1454, r25
    365c:	a0 93 55 14 	sts	0x1455, r26
    3660:	b0 93 56 14 	sts	0x1456, r27
  timer_sleep_cnt++;
    3664:	80 91 5b 14 	lds	r24, 0x145B
    3668:	90 91 5c 14 	lds	r25, 0x145C
    366c:	a0 91 5d 14 	lds	r26, 0x145D
    3670:	b0 91 5e 14 	lds	r27, 0x145E
    3674:	01 96       	adiw	r24, 0x01	; 1
    3676:	a1 1d       	adc	r26, r1
    3678:	b1 1d       	adc	r27, r1
    367a:	80 93 5b 14 	sts	0x145B, r24
    367e:	90 93 5c 14 	sts	0x145C, r25
    3682:	a0 93 5d 14 	sts	0x145D, r26
    3686:	b0 93 5e 14 	sts	0x145E, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER0_OVF_interrupt);
    368a:	80 91 70 0f 	lds	r24, 0x0F70
    368e:	90 91 71 0f 	lds	r25, 0x0F71
    3692:	89 2b       	or	r24, r25
    3694:	29 f0       	breq	.+10     	; 0x36a0 <__vector_23+0x84>
    3696:	e0 91 70 0f 	lds	r30, 0x0F70
    369a:	f0 91 71 0f 	lds	r31, 0x0F71
    369e:	09 95       	icall
}
    36a0:	ff 91       	pop	r31
    36a2:	ef 91       	pop	r30
    36a4:	bf 91       	pop	r27
    36a6:	af 91       	pop	r26
    36a8:	9f 91       	pop	r25
    36aa:	8f 91       	pop	r24
    36ac:	7f 91       	pop	r23
    36ae:	6f 91       	pop	r22
    36b0:	5f 91       	pop	r21
    36b2:	4f 91       	pop	r20
    36b4:	3f 91       	pop	r19
    36b6:	2f 91       	pop	r18
    36b8:	0f 90       	pop	r0
    36ba:	0f be       	out	0x3f, r0	; 63
    36bc:	0f 90       	pop	r0
    36be:	1f 90       	pop	r1
    36c0:	18 95       	reti

000036c2 <__vector_20>:
ISR(TIMER1_OVF_vect) 
{
    36c2:	1f 92       	push	r1
    36c4:	0f 92       	push	r0
    36c6:	0f b6       	in	r0, 0x3f	; 63
    36c8:	0f 92       	push	r0
    36ca:	11 24       	eor	r1, r1
    36cc:	2f 93       	push	r18
    36ce:	3f 93       	push	r19
    36d0:	4f 93       	push	r20
    36d2:	5f 93       	push	r21
    36d4:	6f 93       	push	r22
    36d6:	7f 93       	push	r23
    36d8:	8f 93       	push	r24
    36da:	9f 93       	push	r25
    36dc:	af 93       	push	r26
    36de:	bf 93       	push	r27
    36e0:	ef 93       	push	r30
    36e2:	ff 93       	push	r31
  timer1_ovrflow_cnt++;
    36e4:	80 91 4f 14 	lds	r24, 0x144F
    36e8:	90 91 50 14 	lds	r25, 0x1450
    36ec:	a0 91 51 14 	lds	r26, 0x1451
    36f0:	b0 91 52 14 	lds	r27, 0x1452
    36f4:	01 96       	adiw	r24, 0x01	; 1
    36f6:	a1 1d       	adc	r26, r1
    36f8:	b1 1d       	adc	r27, r1
    36fa:	80 93 4f 14 	sts	0x144F, r24
    36fe:	90 93 50 14 	sts	0x1450, r25
    3702:	a0 93 51 14 	sts	0x1451, r26
    3706:	b0 93 52 14 	sts	0x1452, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER1_OVF_interrupt);
    370a:	80 91 7a 0f 	lds	r24, 0x0F7A
    370e:	90 91 7b 0f 	lds	r25, 0x0F7B
    3712:	89 2b       	or	r24, r25
    3714:	29 f0       	breq	.+10     	; 0x3720 <__vector_20+0x5e>
    3716:	e0 91 7a 0f 	lds	r30, 0x0F7A
    371a:	f0 91 7b 0f 	lds	r31, 0x0F7B
    371e:	09 95       	icall
}
    3720:	ff 91       	pop	r31
    3722:	ef 91       	pop	r30
    3724:	bf 91       	pop	r27
    3726:	af 91       	pop	r26
    3728:	9f 91       	pop	r25
    372a:	8f 91       	pop	r24
    372c:	7f 91       	pop	r23
    372e:	6f 91       	pop	r22
    3730:	5f 91       	pop	r21
    3732:	4f 91       	pop	r20
    3734:	3f 91       	pop	r19
    3736:	2f 91       	pop	r18
    3738:	0f 90       	pop	r0
    373a:	0f be       	out	0x3f, r0	; 63
    373c:	0f 90       	pop	r0
    373e:	1f 90       	pop	r1
    3740:	18 95       	reti

00003742 <__vector_15>:
ISR(TIMER2_OVF_vect) 
{
    3742:	1f 92       	push	r1
    3744:	0f 92       	push	r0
    3746:	0f b6       	in	r0, 0x3f	; 63
    3748:	0f 92       	push	r0
    374a:	11 24       	eor	r1, r1
    374c:	2f 93       	push	r18
    374e:	3f 93       	push	r19
    3750:	4f 93       	push	r20
    3752:	5f 93       	push	r21
    3754:	6f 93       	push	r22
    3756:	7f 93       	push	r23
    3758:	8f 93       	push	r24
    375a:	9f 93       	push	r25
    375c:	af 93       	push	r26
    375e:	bf 93       	push	r27
    3760:	ef 93       	push	r30
    3762:	ff 93       	push	r31
  timer2_ovrflow_cnt++;
    3764:	80 91 57 14 	lds	r24, 0x1457
    3768:	90 91 58 14 	lds	r25, 0x1458
    376c:	a0 91 59 14 	lds	r26, 0x1459
    3770:	b0 91 5a 14 	lds	r27, 0x145A
    3774:	01 96       	adiw	r24, 0x01	; 1
    3776:	a1 1d       	adc	r26, r1
    3778:	b1 1d       	adc	r27, r1
    377a:	80 93 57 14 	sts	0x1457, r24
    377e:	90 93 58 14 	sts	0x1458, r25
    3782:	a0 93 59 14 	sts	0x1459, r26
    3786:	b0 93 5a 14 	sts	0x145A, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER2_OVF_interrupt);
    378a:	80 91 80 0f 	lds	r24, 0x0F80
    378e:	90 91 81 0f 	lds	r25, 0x0F81
    3792:	89 2b       	or	r24, r25
    3794:	29 f0       	breq	.+10     	; 0x37a0 <__vector_15+0x5e>
    3796:	e0 91 80 0f 	lds	r30, 0x0F80
    379a:	f0 91 81 0f 	lds	r31, 0x0F81
    379e:	09 95       	icall
}
    37a0:	ff 91       	pop	r31
    37a2:	ef 91       	pop	r30
    37a4:	bf 91       	pop	r27
    37a6:	af 91       	pop	r26
    37a8:	9f 91       	pop	r25
    37aa:	8f 91       	pop	r24
    37ac:	7f 91       	pop	r23
    37ae:	6f 91       	pop	r22
    37b0:	5f 91       	pop	r21
    37b2:	4f 91       	pop	r20
    37b4:	3f 91       	pop	r19
    37b6:	2f 91       	pop	r18
    37b8:	0f 90       	pop	r0
    37ba:	0f be       	out	0x3f, r0	; 63
    37bc:	0f 90       	pop	r0
    37be:	1f 90       	pop	r1
    37c0:	18 95       	reti

000037c2 <__vector_35>:
ISR(TIMER3_OVF_vect) 
{
    37c2:	1f 92       	push	r1
    37c4:	0f 92       	push	r0
    37c6:	0f b6       	in	r0, 0x3f	; 63
    37c8:	0f 92       	push	r0
    37ca:	11 24       	eor	r1, r1
    37cc:	2f 93       	push	r18
    37ce:	3f 93       	push	r19
    37d0:	4f 93       	push	r20
    37d2:	5f 93       	push	r21
    37d4:	6f 93       	push	r22
    37d6:	7f 93       	push	r23
    37d8:	8f 93       	push	r24
    37da:	9f 93       	push	r25
    37dc:	af 93       	push	r26
    37de:	bf 93       	push	r27
    37e0:	ef 93       	push	r30
    37e2:	ff 93       	push	r31
  timer3_ovrflow_cnt++;
    37e4:	80 91 5f 14 	lds	r24, 0x145F
    37e8:	90 91 60 14 	lds	r25, 0x1460
    37ec:	a0 91 61 14 	lds	r26, 0x1461
    37f0:	b0 91 62 14 	lds	r27, 0x1462
    37f4:	01 96       	adiw	r24, 0x01	; 1
    37f6:	a1 1d       	adc	r26, r1
    37f8:	b1 1d       	adc	r27, r1
    37fa:	80 93 5f 14 	sts	0x145F, r24
    37fe:	90 93 60 14 	sts	0x1460, r25
    3802:	a0 93 61 14 	sts	0x1461, r26
    3806:	b0 93 62 14 	sts	0x1462, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER3_OVF_interrupt);
    380a:	80 91 8a 0f 	lds	r24, 0x0F8A
    380e:	90 91 8b 0f 	lds	r25, 0x0F8B
    3812:	89 2b       	or	r24, r25
    3814:	29 f0       	breq	.+10     	; 0x3820 <__vector_35+0x5e>
    3816:	e0 91 8a 0f 	lds	r30, 0x0F8A
    381a:	f0 91 8b 0f 	lds	r31, 0x0F8B
    381e:	09 95       	icall
}
    3820:	ff 91       	pop	r31
    3822:	ef 91       	pop	r30
    3824:	bf 91       	pop	r27
    3826:	af 91       	pop	r26
    3828:	9f 91       	pop	r25
    382a:	8f 91       	pop	r24
    382c:	7f 91       	pop	r23
    382e:	6f 91       	pop	r22
    3830:	5f 91       	pop	r21
    3832:	4f 91       	pop	r20
    3834:	3f 91       	pop	r19
    3836:	2f 91       	pop	r18
    3838:	0f 90       	pop	r0
    383a:	0f be       	out	0x3f, r0	; 63
    383c:	0f 90       	pop	r0
    383e:	1f 90       	pop	r1
    3840:	18 95       	reti

00003842 <__vector_45>:
ISR(TIMER4_OVF_vect) 
{
    3842:	1f 92       	push	r1
    3844:	0f 92       	push	r0
    3846:	0f b6       	in	r0, 0x3f	; 63
    3848:	0f 92       	push	r0
    384a:	11 24       	eor	r1, r1
    384c:	2f 93       	push	r18
    384e:	3f 93       	push	r19
    3850:	4f 93       	push	r20
    3852:	5f 93       	push	r21
    3854:	6f 93       	push	r22
    3856:	7f 93       	push	r23
    3858:	8f 93       	push	r24
    385a:	9f 93       	push	r25
    385c:	af 93       	push	r26
    385e:	bf 93       	push	r27
    3860:	ef 93       	push	r30
    3862:	ff 93       	push	r31
  timer4_ovrflow_cnt++;
    3864:	80 91 4b 14 	lds	r24, 0x144B
    3868:	90 91 4c 14 	lds	r25, 0x144C
    386c:	a0 91 4d 14 	lds	r26, 0x144D
    3870:	b0 91 4e 14 	lds	r27, 0x144E
    3874:	01 96       	adiw	r24, 0x01	; 1
    3876:	a1 1d       	adc	r26, r1
    3878:	b1 1d       	adc	r27, r1
    387a:	80 93 4b 14 	sts	0x144B, r24
    387e:	90 93 4c 14 	sts	0x144C, r25
    3882:	a0 93 4d 14 	sts	0x144D, r26
    3886:	b0 93 4e 14 	sts	0x144E, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER4_OVF_interrupt);
    388a:	80 91 94 0f 	lds	r24, 0x0F94
    388e:	90 91 95 0f 	lds	r25, 0x0F95
    3892:	89 2b       	or	r24, r25
    3894:	29 f0       	breq	.+10     	; 0x38a0 <__vector_45+0x5e>
    3896:	e0 91 94 0f 	lds	r30, 0x0F94
    389a:	f0 91 95 0f 	lds	r31, 0x0F95
    389e:	09 95       	icall
}
    38a0:	ff 91       	pop	r31
    38a2:	ef 91       	pop	r30
    38a4:	bf 91       	pop	r27
    38a6:	af 91       	pop	r26
    38a8:	9f 91       	pop	r25
    38aa:	8f 91       	pop	r24
    38ac:	7f 91       	pop	r23
    38ae:	6f 91       	pop	r22
    38b0:	5f 91       	pop	r21
    38b2:	4f 91       	pop	r20
    38b4:	3f 91       	pop	r19
    38b6:	2f 91       	pop	r18
    38b8:	0f 90       	pop	r0
    38ba:	0f be       	out	0x3f, r0	; 63
    38bc:	0f 90       	pop	r0
    38be:	1f 90       	pop	r1
    38c0:	18 95       	reti

000038c2 <__vector_50>:
ISR(TIMER5_OVF_vect) 
{
    38c2:	1f 92       	push	r1
    38c4:	0f 92       	push	r0
    38c6:	0f b6       	in	r0, 0x3f	; 63
    38c8:	0f 92       	push	r0
    38ca:	11 24       	eor	r1, r1
    38cc:	2f 93       	push	r18
    38ce:	3f 93       	push	r19
    38d0:	4f 93       	push	r20
    38d2:	5f 93       	push	r21
    38d4:	6f 93       	push	r22
    38d6:	7f 93       	push	r23
    38d8:	8f 93       	push	r24
    38da:	9f 93       	push	r25
    38dc:	af 93       	push	r26
    38de:	bf 93       	push	r27
    38e0:	ef 93       	push	r30
    38e2:	ff 93       	push	r31
  timer5_ovrflow_cnt++;
    38e4:	80 91 63 14 	lds	r24, 0x1463
    38e8:	90 91 64 14 	lds	r25, 0x1464
    38ec:	a0 91 65 14 	lds	r26, 0x1465
    38f0:	b0 91 66 14 	lds	r27, 0x1466
    38f4:	01 96       	adiw	r24, 0x01	; 1
    38f6:	a1 1d       	adc	r26, r1
    38f8:	b1 1d       	adc	r27, r1
    38fa:	80 93 63 14 	sts	0x1463, r24
    38fe:	90 93 64 14 	sts	0x1464, r25
    3902:	a0 93 65 14 	sts	0x1465, r26
    3906:	b0 93 66 14 	sts	0x1466, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER5_OVF_interrupt);
    390a:	80 91 9e 0f 	lds	r24, 0x0F9E
    390e:	90 91 9f 0f 	lds	r25, 0x0F9F
    3912:	89 2b       	or	r24, r25
    3914:	29 f0       	breq	.+10     	; 0x3920 <__vector_50+0x5e>
    3916:	e0 91 9e 0f 	lds	r30, 0x0F9E
    391a:	f0 91 9f 0f 	lds	r31, 0x0F9F
    391e:	09 95       	icall
}
    3920:	ff 91       	pop	r31
    3922:	ef 91       	pop	r30
    3924:	bf 91       	pop	r27
    3926:	af 91       	pop	r26
    3928:	9f 91       	pop	r25
    392a:	8f 91       	pop	r24
    392c:	7f 91       	pop	r23
    392e:	6f 91       	pop	r22
    3930:	5f 91       	pop	r21
    3932:	4f 91       	pop	r20
    3934:	3f 91       	pop	r19
    3936:	2f 91       	pop	r18
    3938:	0f 90       	pop	r0
    393a:	0f be       	out	0x3f, r0	; 63
    393c:	0f 90       	pop	r0
    393e:	1f 90       	pop	r1
    3940:	18 95       	reti

00003942 <__vector_21>:
ISR(TIMER0_COMPA_vect)
{
    3942:	1f 92       	push	r1
    3944:	0f 92       	push	r0
    3946:	0f b6       	in	r0, 0x3f	; 63
    3948:	0f 92       	push	r0
    394a:	11 24       	eor	r1, r1
    394c:	2f 93       	push	r18
    394e:	3f 93       	push	r19
    3950:	4f 93       	push	r20
    3952:	5f 93       	push	r21
    3954:	6f 93       	push	r22
    3956:	7f 93       	push	r23
    3958:	8f 93       	push	r24
    395a:	9f 93       	push	r25
    395c:	af 93       	push	r26
    395e:	bf 93       	push	r27
    3960:	ef 93       	push	r30
    3962:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER0_COMPA_interrupt);
    3964:	80 91 6c 0f 	lds	r24, 0x0F6C
    3968:	90 91 6d 0f 	lds	r25, 0x0F6D
    396c:	89 2b       	or	r24, r25
    396e:	29 f0       	breq	.+10     	; 0x397a <__vector_21+0x38>
    3970:	e0 91 6c 0f 	lds	r30, 0x0F6C
    3974:	f0 91 6d 0f 	lds	r31, 0x0F6D
    3978:	09 95       	icall
}
    397a:	ff 91       	pop	r31
    397c:	ef 91       	pop	r30
    397e:	bf 91       	pop	r27
    3980:	af 91       	pop	r26
    3982:	9f 91       	pop	r25
    3984:	8f 91       	pop	r24
    3986:	7f 91       	pop	r23
    3988:	6f 91       	pop	r22
    398a:	5f 91       	pop	r21
    398c:	4f 91       	pop	r20
    398e:	3f 91       	pop	r19
    3990:	2f 91       	pop	r18
    3992:	0f 90       	pop	r0
    3994:	0f be       	out	0x3f, r0	; 63
    3996:	0f 90       	pop	r0
    3998:	1f 90       	pop	r1
    399a:	18 95       	reti

0000399c <__vector_22>:
ISR(TIMER0_COMPB_vect)
{
    399c:	1f 92       	push	r1
    399e:	0f 92       	push	r0
    39a0:	0f b6       	in	r0, 0x3f	; 63
    39a2:	0f 92       	push	r0
    39a4:	11 24       	eor	r1, r1
    39a6:	2f 93       	push	r18
    39a8:	3f 93       	push	r19
    39aa:	4f 93       	push	r20
    39ac:	5f 93       	push	r21
    39ae:	6f 93       	push	r22
    39b0:	7f 93       	push	r23
    39b2:	8f 93       	push	r24
    39b4:	9f 93       	push	r25
    39b6:	af 93       	push	r26
    39b8:	bf 93       	push	r27
    39ba:	ef 93       	push	r30
    39bc:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER0_COMPB_interrupt);
    39be:	80 91 6e 0f 	lds	r24, 0x0F6E
    39c2:	90 91 6f 0f 	lds	r25, 0x0F6F
    39c6:	89 2b       	or	r24, r25
    39c8:	29 f0       	breq	.+10     	; 0x39d4 <__vector_22+0x38>
    39ca:	e0 91 6e 0f 	lds	r30, 0x0F6E
    39ce:	f0 91 6f 0f 	lds	r31, 0x0F6F
    39d2:	09 95       	icall
}
    39d4:	ff 91       	pop	r31
    39d6:	ef 91       	pop	r30
    39d8:	bf 91       	pop	r27
    39da:	af 91       	pop	r26
    39dc:	9f 91       	pop	r25
    39de:	8f 91       	pop	r24
    39e0:	7f 91       	pop	r23
    39e2:	6f 91       	pop	r22
    39e4:	5f 91       	pop	r21
    39e6:	4f 91       	pop	r20
    39e8:	3f 91       	pop	r19
    39ea:	2f 91       	pop	r18
    39ec:	0f 90       	pop	r0
    39ee:	0f be       	out	0x3f, r0	; 63
    39f0:	0f 90       	pop	r0
    39f2:	1f 90       	pop	r1
    39f4:	18 95       	reti

000039f6 <__vector_16>:
ISR(TIMER1_CAPT_vect)
{
    39f6:	1f 92       	push	r1
    39f8:	0f 92       	push	r0
    39fa:	0f b6       	in	r0, 0x3f	; 63
    39fc:	0f 92       	push	r0
    39fe:	11 24       	eor	r1, r1
    3a00:	2f 93       	push	r18
    3a02:	3f 93       	push	r19
    3a04:	4f 93       	push	r20
    3a06:	5f 93       	push	r21
    3a08:	6f 93       	push	r22
    3a0a:	7f 93       	push	r23
    3a0c:	8f 93       	push	r24
    3a0e:	9f 93       	push	r25
    3a10:	af 93       	push	r26
    3a12:	bf 93       	push	r27
    3a14:	ef 93       	push	r30
    3a16:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER1_CAPT_interrupt);
    3a18:	80 91 72 0f 	lds	r24, 0x0F72
    3a1c:	90 91 73 0f 	lds	r25, 0x0F73
    3a20:	89 2b       	or	r24, r25
    3a22:	29 f0       	breq	.+10     	; 0x3a2e <__vector_16+0x38>
    3a24:	e0 91 72 0f 	lds	r30, 0x0F72
    3a28:	f0 91 73 0f 	lds	r31, 0x0F73
    3a2c:	09 95       	icall
}
    3a2e:	ff 91       	pop	r31
    3a30:	ef 91       	pop	r30
    3a32:	bf 91       	pop	r27
    3a34:	af 91       	pop	r26
    3a36:	9f 91       	pop	r25
    3a38:	8f 91       	pop	r24
    3a3a:	7f 91       	pop	r23
    3a3c:	6f 91       	pop	r22
    3a3e:	5f 91       	pop	r21
    3a40:	4f 91       	pop	r20
    3a42:	3f 91       	pop	r19
    3a44:	2f 91       	pop	r18
    3a46:	0f 90       	pop	r0
    3a48:	0f be       	out	0x3f, r0	; 63
    3a4a:	0f 90       	pop	r0
    3a4c:	1f 90       	pop	r1
    3a4e:	18 95       	reti

00003a50 <__vector_18>:
{
  RUN_USER_DEFINE_INTERRUPT(TIMER1_COMPA_interrupt);
}
*/
ISR(TIMER1_COMPB_vect)
{
    3a50:	1f 92       	push	r1
    3a52:	0f 92       	push	r0
    3a54:	0f b6       	in	r0, 0x3f	; 63
    3a56:	0f 92       	push	r0
    3a58:	11 24       	eor	r1, r1
    3a5a:	2f 93       	push	r18
    3a5c:	3f 93       	push	r19
    3a5e:	4f 93       	push	r20
    3a60:	5f 93       	push	r21
    3a62:	6f 93       	push	r22
    3a64:	7f 93       	push	r23
    3a66:	8f 93       	push	r24
    3a68:	9f 93       	push	r25
    3a6a:	af 93       	push	r26
    3a6c:	bf 93       	push	r27
    3a6e:	ef 93       	push	r30
    3a70:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER1_COMPB_interrupt);
    3a72:	80 91 76 0f 	lds	r24, 0x0F76
    3a76:	90 91 77 0f 	lds	r25, 0x0F77
    3a7a:	89 2b       	or	r24, r25
    3a7c:	29 f0       	breq	.+10     	; 0x3a88 <__vector_18+0x38>
    3a7e:	e0 91 76 0f 	lds	r30, 0x0F76
    3a82:	f0 91 77 0f 	lds	r31, 0x0F77
    3a86:	09 95       	icall
}
    3a88:	ff 91       	pop	r31
    3a8a:	ef 91       	pop	r30
    3a8c:	bf 91       	pop	r27
    3a8e:	af 91       	pop	r26
    3a90:	9f 91       	pop	r25
    3a92:	8f 91       	pop	r24
    3a94:	7f 91       	pop	r23
    3a96:	6f 91       	pop	r22
    3a98:	5f 91       	pop	r21
    3a9a:	4f 91       	pop	r20
    3a9c:	3f 91       	pop	r19
    3a9e:	2f 91       	pop	r18
    3aa0:	0f 90       	pop	r0
    3aa2:	0f be       	out	0x3f, r0	; 63
    3aa4:	0f 90       	pop	r0
    3aa6:	1f 90       	pop	r1
    3aa8:	18 95       	reti

00003aaa <__vector_19>:
ISR(TIMER1_COMPC_vect)
{
    3aaa:	1f 92       	push	r1
    3aac:	0f 92       	push	r0
    3aae:	0f b6       	in	r0, 0x3f	; 63
    3ab0:	0f 92       	push	r0
    3ab2:	11 24       	eor	r1, r1
    3ab4:	2f 93       	push	r18
    3ab6:	3f 93       	push	r19
    3ab8:	4f 93       	push	r20
    3aba:	5f 93       	push	r21
    3abc:	6f 93       	push	r22
    3abe:	7f 93       	push	r23
    3ac0:	8f 93       	push	r24
    3ac2:	9f 93       	push	r25
    3ac4:	af 93       	push	r26
    3ac6:	bf 93       	push	r27
    3ac8:	ef 93       	push	r30
    3aca:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER1_COMPC_interrupt);
    3acc:	80 91 78 0f 	lds	r24, 0x0F78
    3ad0:	90 91 79 0f 	lds	r25, 0x0F79
    3ad4:	89 2b       	or	r24, r25
    3ad6:	29 f0       	breq	.+10     	; 0x3ae2 <__vector_19+0x38>
    3ad8:	e0 91 78 0f 	lds	r30, 0x0F78
    3adc:	f0 91 79 0f 	lds	r31, 0x0F79
    3ae0:	09 95       	icall
}
    3ae2:	ff 91       	pop	r31
    3ae4:	ef 91       	pop	r30
    3ae6:	bf 91       	pop	r27
    3ae8:	af 91       	pop	r26
    3aea:	9f 91       	pop	r25
    3aec:	8f 91       	pop	r24
    3aee:	7f 91       	pop	r23
    3af0:	6f 91       	pop	r22
    3af2:	5f 91       	pop	r21
    3af4:	4f 91       	pop	r20
    3af6:	3f 91       	pop	r19
    3af8:	2f 91       	pop	r18
    3afa:	0f 90       	pop	r0
    3afc:	0f be       	out	0x3f, r0	; 63
    3afe:	0f 90       	pop	r0
    3b00:	1f 90       	pop	r1
    3b02:	18 95       	reti

00003b04 <__vector_13>:
ISR(TIMER2_COMPA_vect)
{
    3b04:	1f 92       	push	r1
    3b06:	0f 92       	push	r0
    3b08:	0f b6       	in	r0, 0x3f	; 63
    3b0a:	0f 92       	push	r0
    3b0c:	11 24       	eor	r1, r1
    3b0e:	2f 93       	push	r18
    3b10:	3f 93       	push	r19
    3b12:	4f 93       	push	r20
    3b14:	5f 93       	push	r21
    3b16:	6f 93       	push	r22
    3b18:	7f 93       	push	r23
    3b1a:	8f 93       	push	r24
    3b1c:	9f 93       	push	r25
    3b1e:	af 93       	push	r26
    3b20:	bf 93       	push	r27
    3b22:	ef 93       	push	r30
    3b24:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER2_COMPA_interrupt);
    3b26:	80 91 7c 0f 	lds	r24, 0x0F7C
    3b2a:	90 91 7d 0f 	lds	r25, 0x0F7D
    3b2e:	89 2b       	or	r24, r25
    3b30:	29 f0       	breq	.+10     	; 0x3b3c <__vector_13+0x38>
    3b32:	e0 91 7c 0f 	lds	r30, 0x0F7C
    3b36:	f0 91 7d 0f 	lds	r31, 0x0F7D
    3b3a:	09 95       	icall
}
    3b3c:	ff 91       	pop	r31
    3b3e:	ef 91       	pop	r30
    3b40:	bf 91       	pop	r27
    3b42:	af 91       	pop	r26
    3b44:	9f 91       	pop	r25
    3b46:	8f 91       	pop	r24
    3b48:	7f 91       	pop	r23
    3b4a:	6f 91       	pop	r22
    3b4c:	5f 91       	pop	r21
    3b4e:	4f 91       	pop	r20
    3b50:	3f 91       	pop	r19
    3b52:	2f 91       	pop	r18
    3b54:	0f 90       	pop	r0
    3b56:	0f be       	out	0x3f, r0	; 63
    3b58:	0f 90       	pop	r0
    3b5a:	1f 90       	pop	r1
    3b5c:	18 95       	reti

00003b5e <__vector_14>:
ISR(TIMER2_COMPB_vect)
{
    3b5e:	1f 92       	push	r1
    3b60:	0f 92       	push	r0
    3b62:	0f b6       	in	r0, 0x3f	; 63
    3b64:	0f 92       	push	r0
    3b66:	11 24       	eor	r1, r1
    3b68:	2f 93       	push	r18
    3b6a:	3f 93       	push	r19
    3b6c:	4f 93       	push	r20
    3b6e:	5f 93       	push	r21
    3b70:	6f 93       	push	r22
    3b72:	7f 93       	push	r23
    3b74:	8f 93       	push	r24
    3b76:	9f 93       	push	r25
    3b78:	af 93       	push	r26
    3b7a:	bf 93       	push	r27
    3b7c:	ef 93       	push	r30
    3b7e:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER2_COMPB_interrupt);
    3b80:	80 91 7e 0f 	lds	r24, 0x0F7E
    3b84:	90 91 7f 0f 	lds	r25, 0x0F7F
    3b88:	89 2b       	or	r24, r25
    3b8a:	29 f0       	breq	.+10     	; 0x3b96 <__vector_14+0x38>
    3b8c:	e0 91 7e 0f 	lds	r30, 0x0F7E
    3b90:	f0 91 7f 0f 	lds	r31, 0x0F7F
    3b94:	09 95       	icall
}
    3b96:	ff 91       	pop	r31
    3b98:	ef 91       	pop	r30
    3b9a:	bf 91       	pop	r27
    3b9c:	af 91       	pop	r26
    3b9e:	9f 91       	pop	r25
    3ba0:	8f 91       	pop	r24
    3ba2:	7f 91       	pop	r23
    3ba4:	6f 91       	pop	r22
    3ba6:	5f 91       	pop	r21
    3ba8:	4f 91       	pop	r20
    3baa:	3f 91       	pop	r19
    3bac:	2f 91       	pop	r18
    3bae:	0f 90       	pop	r0
    3bb0:	0f be       	out	0x3f, r0	; 63
    3bb2:	0f 90       	pop	r0
    3bb4:	1f 90       	pop	r1
    3bb6:	18 95       	reti

00003bb8 <__vector_31>:
ISR(TIMER3_CAPT_vect)
{
    3bb8:	1f 92       	push	r1
    3bba:	0f 92       	push	r0
    3bbc:	0f b6       	in	r0, 0x3f	; 63
    3bbe:	0f 92       	push	r0
    3bc0:	11 24       	eor	r1, r1
    3bc2:	2f 93       	push	r18
    3bc4:	3f 93       	push	r19
    3bc6:	4f 93       	push	r20
    3bc8:	5f 93       	push	r21
    3bca:	6f 93       	push	r22
    3bcc:	7f 93       	push	r23
    3bce:	8f 93       	push	r24
    3bd0:	9f 93       	push	r25
    3bd2:	af 93       	push	r26
    3bd4:	bf 93       	push	r27
    3bd6:	ef 93       	push	r30
    3bd8:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_CAPT_interrupt);
    3bda:	80 91 82 0f 	lds	r24, 0x0F82
    3bde:	90 91 83 0f 	lds	r25, 0x0F83
    3be2:	89 2b       	or	r24, r25
    3be4:	29 f0       	breq	.+10     	; 0x3bf0 <__vector_31+0x38>
    3be6:	e0 91 82 0f 	lds	r30, 0x0F82
    3bea:	f0 91 83 0f 	lds	r31, 0x0F83
    3bee:	09 95       	icall
}
    3bf0:	ff 91       	pop	r31
    3bf2:	ef 91       	pop	r30
    3bf4:	bf 91       	pop	r27
    3bf6:	af 91       	pop	r26
    3bf8:	9f 91       	pop	r25
    3bfa:	8f 91       	pop	r24
    3bfc:	7f 91       	pop	r23
    3bfe:	6f 91       	pop	r22
    3c00:	5f 91       	pop	r21
    3c02:	4f 91       	pop	r20
    3c04:	3f 91       	pop	r19
    3c06:	2f 91       	pop	r18
    3c08:	0f 90       	pop	r0
    3c0a:	0f be       	out	0x3f, r0	; 63
    3c0c:	0f 90       	pop	r0
    3c0e:	1f 90       	pop	r1
    3c10:	18 95       	reti

00003c12 <__vector_32>:
ISR(TIMER3_COMPA_vect)
{
    3c12:	1f 92       	push	r1
    3c14:	0f 92       	push	r0
    3c16:	0f b6       	in	r0, 0x3f	; 63
    3c18:	0f 92       	push	r0
    3c1a:	11 24       	eor	r1, r1
    3c1c:	2f 93       	push	r18
    3c1e:	3f 93       	push	r19
    3c20:	4f 93       	push	r20
    3c22:	5f 93       	push	r21
    3c24:	6f 93       	push	r22
    3c26:	7f 93       	push	r23
    3c28:	8f 93       	push	r24
    3c2a:	9f 93       	push	r25
    3c2c:	af 93       	push	r26
    3c2e:	bf 93       	push	r27
    3c30:	ef 93       	push	r30
    3c32:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_COMPA_interrupt);
    3c34:	80 91 84 0f 	lds	r24, 0x0F84
    3c38:	90 91 85 0f 	lds	r25, 0x0F85
    3c3c:	89 2b       	or	r24, r25
    3c3e:	29 f0       	breq	.+10     	; 0x3c4a <__vector_32+0x38>
    3c40:	e0 91 84 0f 	lds	r30, 0x0F84
    3c44:	f0 91 85 0f 	lds	r31, 0x0F85
    3c48:	09 95       	icall
}
    3c4a:	ff 91       	pop	r31
    3c4c:	ef 91       	pop	r30
    3c4e:	bf 91       	pop	r27
    3c50:	af 91       	pop	r26
    3c52:	9f 91       	pop	r25
    3c54:	8f 91       	pop	r24
    3c56:	7f 91       	pop	r23
    3c58:	6f 91       	pop	r22
    3c5a:	5f 91       	pop	r21
    3c5c:	4f 91       	pop	r20
    3c5e:	3f 91       	pop	r19
    3c60:	2f 91       	pop	r18
    3c62:	0f 90       	pop	r0
    3c64:	0f be       	out	0x3f, r0	; 63
    3c66:	0f 90       	pop	r0
    3c68:	1f 90       	pop	r1
    3c6a:	18 95       	reti

00003c6c <__vector_33>:
ISR(TIMER3_COMPB_vect)
{
    3c6c:	1f 92       	push	r1
    3c6e:	0f 92       	push	r0
    3c70:	0f b6       	in	r0, 0x3f	; 63
    3c72:	0f 92       	push	r0
    3c74:	11 24       	eor	r1, r1
    3c76:	2f 93       	push	r18
    3c78:	3f 93       	push	r19
    3c7a:	4f 93       	push	r20
    3c7c:	5f 93       	push	r21
    3c7e:	6f 93       	push	r22
    3c80:	7f 93       	push	r23
    3c82:	8f 93       	push	r24
    3c84:	9f 93       	push	r25
    3c86:	af 93       	push	r26
    3c88:	bf 93       	push	r27
    3c8a:	ef 93       	push	r30
    3c8c:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_COMPB_interrupt);
    3c8e:	80 91 86 0f 	lds	r24, 0x0F86
    3c92:	90 91 87 0f 	lds	r25, 0x0F87
    3c96:	89 2b       	or	r24, r25
    3c98:	29 f0       	breq	.+10     	; 0x3ca4 <__vector_33+0x38>
    3c9a:	e0 91 86 0f 	lds	r30, 0x0F86
    3c9e:	f0 91 87 0f 	lds	r31, 0x0F87
    3ca2:	09 95       	icall
}
    3ca4:	ff 91       	pop	r31
    3ca6:	ef 91       	pop	r30
    3ca8:	bf 91       	pop	r27
    3caa:	af 91       	pop	r26
    3cac:	9f 91       	pop	r25
    3cae:	8f 91       	pop	r24
    3cb0:	7f 91       	pop	r23
    3cb2:	6f 91       	pop	r22
    3cb4:	5f 91       	pop	r21
    3cb6:	4f 91       	pop	r20
    3cb8:	3f 91       	pop	r19
    3cba:	2f 91       	pop	r18
    3cbc:	0f 90       	pop	r0
    3cbe:	0f be       	out	0x3f, r0	; 63
    3cc0:	0f 90       	pop	r0
    3cc2:	1f 90       	pop	r1
    3cc4:	18 95       	reti

00003cc6 <__vector_34>:
ISR(TIMER3_COMPC_vect)
{
    3cc6:	1f 92       	push	r1
    3cc8:	0f 92       	push	r0
    3cca:	0f b6       	in	r0, 0x3f	; 63
    3ccc:	0f 92       	push	r0
    3cce:	11 24       	eor	r1, r1
    3cd0:	2f 93       	push	r18
    3cd2:	3f 93       	push	r19
    3cd4:	4f 93       	push	r20
    3cd6:	5f 93       	push	r21
    3cd8:	6f 93       	push	r22
    3cda:	7f 93       	push	r23
    3cdc:	8f 93       	push	r24
    3cde:	9f 93       	push	r25
    3ce0:	af 93       	push	r26
    3ce2:	bf 93       	push	r27
    3ce4:	ef 93       	push	r30
    3ce6:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_COMPC_interrupt);
    3ce8:	80 91 88 0f 	lds	r24, 0x0F88
    3cec:	90 91 89 0f 	lds	r25, 0x0F89
    3cf0:	89 2b       	or	r24, r25
    3cf2:	29 f0       	breq	.+10     	; 0x3cfe <__vector_34+0x38>
    3cf4:	e0 91 88 0f 	lds	r30, 0x0F88
    3cf8:	f0 91 89 0f 	lds	r31, 0x0F89
    3cfc:	09 95       	icall
}
    3cfe:	ff 91       	pop	r31
    3d00:	ef 91       	pop	r30
    3d02:	bf 91       	pop	r27
    3d04:	af 91       	pop	r26
    3d06:	9f 91       	pop	r25
    3d08:	8f 91       	pop	r24
    3d0a:	7f 91       	pop	r23
    3d0c:	6f 91       	pop	r22
    3d0e:	5f 91       	pop	r21
    3d10:	4f 91       	pop	r20
    3d12:	3f 91       	pop	r19
    3d14:	2f 91       	pop	r18
    3d16:	0f 90       	pop	r0
    3d18:	0f be       	out	0x3f, r0	; 63
    3d1a:	0f 90       	pop	r0
    3d1c:	1f 90       	pop	r1
    3d1e:	18 95       	reti

00003d20 <__vector_41>:
ISR(TIMER4_CAPT_vect)
{
    3d20:	1f 92       	push	r1
    3d22:	0f 92       	push	r0
    3d24:	0f b6       	in	r0, 0x3f	; 63
    3d26:	0f 92       	push	r0
    3d28:	11 24       	eor	r1, r1
    3d2a:	2f 93       	push	r18
    3d2c:	3f 93       	push	r19
    3d2e:	4f 93       	push	r20
    3d30:	5f 93       	push	r21
    3d32:	6f 93       	push	r22
    3d34:	7f 93       	push	r23
    3d36:	8f 93       	push	r24
    3d38:	9f 93       	push	r25
    3d3a:	af 93       	push	r26
    3d3c:	bf 93       	push	r27
    3d3e:	ef 93       	push	r30
    3d40:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_CAPT_interrupt);
    3d42:	80 91 8c 0f 	lds	r24, 0x0F8C
    3d46:	90 91 8d 0f 	lds	r25, 0x0F8D
    3d4a:	89 2b       	or	r24, r25
    3d4c:	29 f0       	breq	.+10     	; 0x3d58 <__vector_41+0x38>
    3d4e:	e0 91 8c 0f 	lds	r30, 0x0F8C
    3d52:	f0 91 8d 0f 	lds	r31, 0x0F8D
    3d56:	09 95       	icall
}
    3d58:	ff 91       	pop	r31
    3d5a:	ef 91       	pop	r30
    3d5c:	bf 91       	pop	r27
    3d5e:	af 91       	pop	r26
    3d60:	9f 91       	pop	r25
    3d62:	8f 91       	pop	r24
    3d64:	7f 91       	pop	r23
    3d66:	6f 91       	pop	r22
    3d68:	5f 91       	pop	r21
    3d6a:	4f 91       	pop	r20
    3d6c:	3f 91       	pop	r19
    3d6e:	2f 91       	pop	r18
    3d70:	0f 90       	pop	r0
    3d72:	0f be       	out	0x3f, r0	; 63
    3d74:	0f 90       	pop	r0
    3d76:	1f 90       	pop	r1
    3d78:	18 95       	reti

00003d7a <__vector_42>:
ISR(TIMER4_COMPA_vect)
{
    3d7a:	1f 92       	push	r1
    3d7c:	0f 92       	push	r0
    3d7e:	0f b6       	in	r0, 0x3f	; 63
    3d80:	0f 92       	push	r0
    3d82:	11 24       	eor	r1, r1
    3d84:	2f 93       	push	r18
    3d86:	3f 93       	push	r19
    3d88:	4f 93       	push	r20
    3d8a:	5f 93       	push	r21
    3d8c:	6f 93       	push	r22
    3d8e:	7f 93       	push	r23
    3d90:	8f 93       	push	r24
    3d92:	9f 93       	push	r25
    3d94:	af 93       	push	r26
    3d96:	bf 93       	push	r27
    3d98:	ef 93       	push	r30
    3d9a:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_COMPA_interrupt);
    3d9c:	80 91 8e 0f 	lds	r24, 0x0F8E
    3da0:	90 91 8f 0f 	lds	r25, 0x0F8F
    3da4:	89 2b       	or	r24, r25
    3da6:	29 f0       	breq	.+10     	; 0x3db2 <__vector_42+0x38>
    3da8:	e0 91 8e 0f 	lds	r30, 0x0F8E
    3dac:	f0 91 8f 0f 	lds	r31, 0x0F8F
    3db0:	09 95       	icall
}
    3db2:	ff 91       	pop	r31
    3db4:	ef 91       	pop	r30
    3db6:	bf 91       	pop	r27
    3db8:	af 91       	pop	r26
    3dba:	9f 91       	pop	r25
    3dbc:	8f 91       	pop	r24
    3dbe:	7f 91       	pop	r23
    3dc0:	6f 91       	pop	r22
    3dc2:	5f 91       	pop	r21
    3dc4:	4f 91       	pop	r20
    3dc6:	3f 91       	pop	r19
    3dc8:	2f 91       	pop	r18
    3dca:	0f 90       	pop	r0
    3dcc:	0f be       	out	0x3f, r0	; 63
    3dce:	0f 90       	pop	r0
    3dd0:	1f 90       	pop	r1
    3dd2:	18 95       	reti

00003dd4 <__vector_43>:
ISR(TIMER4_COMPB_vect)
{
    3dd4:	1f 92       	push	r1
    3dd6:	0f 92       	push	r0
    3dd8:	0f b6       	in	r0, 0x3f	; 63
    3dda:	0f 92       	push	r0
    3ddc:	11 24       	eor	r1, r1
    3dde:	2f 93       	push	r18
    3de0:	3f 93       	push	r19
    3de2:	4f 93       	push	r20
    3de4:	5f 93       	push	r21
    3de6:	6f 93       	push	r22
    3de8:	7f 93       	push	r23
    3dea:	8f 93       	push	r24
    3dec:	9f 93       	push	r25
    3dee:	af 93       	push	r26
    3df0:	bf 93       	push	r27
    3df2:	ef 93       	push	r30
    3df4:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_COMPB_interrupt);
    3df6:	80 91 90 0f 	lds	r24, 0x0F90
    3dfa:	90 91 91 0f 	lds	r25, 0x0F91
    3dfe:	89 2b       	or	r24, r25
    3e00:	29 f0       	breq	.+10     	; 0x3e0c <__vector_43+0x38>
    3e02:	e0 91 90 0f 	lds	r30, 0x0F90
    3e06:	f0 91 91 0f 	lds	r31, 0x0F91
    3e0a:	09 95       	icall
}
    3e0c:	ff 91       	pop	r31
    3e0e:	ef 91       	pop	r30
    3e10:	bf 91       	pop	r27
    3e12:	af 91       	pop	r26
    3e14:	9f 91       	pop	r25
    3e16:	8f 91       	pop	r24
    3e18:	7f 91       	pop	r23
    3e1a:	6f 91       	pop	r22
    3e1c:	5f 91       	pop	r21
    3e1e:	4f 91       	pop	r20
    3e20:	3f 91       	pop	r19
    3e22:	2f 91       	pop	r18
    3e24:	0f 90       	pop	r0
    3e26:	0f be       	out	0x3f, r0	; 63
    3e28:	0f 90       	pop	r0
    3e2a:	1f 90       	pop	r1
    3e2c:	18 95       	reti

00003e2e <__vector_44>:
ISR(TIMER4_COMPC_vect)
{
    3e2e:	1f 92       	push	r1
    3e30:	0f 92       	push	r0
    3e32:	0f b6       	in	r0, 0x3f	; 63
    3e34:	0f 92       	push	r0
    3e36:	11 24       	eor	r1, r1
    3e38:	2f 93       	push	r18
    3e3a:	3f 93       	push	r19
    3e3c:	4f 93       	push	r20
    3e3e:	5f 93       	push	r21
    3e40:	6f 93       	push	r22
    3e42:	7f 93       	push	r23
    3e44:	8f 93       	push	r24
    3e46:	9f 93       	push	r25
    3e48:	af 93       	push	r26
    3e4a:	bf 93       	push	r27
    3e4c:	ef 93       	push	r30
    3e4e:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_COMPC_interrupt);
    3e50:	80 91 92 0f 	lds	r24, 0x0F92
    3e54:	90 91 93 0f 	lds	r25, 0x0F93
    3e58:	89 2b       	or	r24, r25
    3e5a:	29 f0       	breq	.+10     	; 0x3e66 <__vector_44+0x38>
    3e5c:	e0 91 92 0f 	lds	r30, 0x0F92
    3e60:	f0 91 93 0f 	lds	r31, 0x0F93
    3e64:	09 95       	icall
}
    3e66:	ff 91       	pop	r31
    3e68:	ef 91       	pop	r30
    3e6a:	bf 91       	pop	r27
    3e6c:	af 91       	pop	r26
    3e6e:	9f 91       	pop	r25
    3e70:	8f 91       	pop	r24
    3e72:	7f 91       	pop	r23
    3e74:	6f 91       	pop	r22
    3e76:	5f 91       	pop	r21
    3e78:	4f 91       	pop	r20
    3e7a:	3f 91       	pop	r19
    3e7c:	2f 91       	pop	r18
    3e7e:	0f 90       	pop	r0
    3e80:	0f be       	out	0x3f, r0	; 63
    3e82:	0f 90       	pop	r0
    3e84:	1f 90       	pop	r1
    3e86:	18 95       	reti

00003e88 <__vector_46>:
ISR(TIMER5_CAPT_vect)
{
    3e88:	1f 92       	push	r1
    3e8a:	0f 92       	push	r0
    3e8c:	0f b6       	in	r0, 0x3f	; 63
    3e8e:	0f 92       	push	r0
    3e90:	11 24       	eor	r1, r1
    3e92:	2f 93       	push	r18
    3e94:	3f 93       	push	r19
    3e96:	4f 93       	push	r20
    3e98:	5f 93       	push	r21
    3e9a:	6f 93       	push	r22
    3e9c:	7f 93       	push	r23
    3e9e:	8f 93       	push	r24
    3ea0:	9f 93       	push	r25
    3ea2:	af 93       	push	r26
    3ea4:	bf 93       	push	r27
    3ea6:	ef 93       	push	r30
    3ea8:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_CAPT_interrupt);
    3eaa:	80 91 96 0f 	lds	r24, 0x0F96
    3eae:	90 91 97 0f 	lds	r25, 0x0F97
    3eb2:	89 2b       	or	r24, r25
    3eb4:	29 f0       	breq	.+10     	; 0x3ec0 <__vector_46+0x38>
    3eb6:	e0 91 96 0f 	lds	r30, 0x0F96
    3eba:	f0 91 97 0f 	lds	r31, 0x0F97
    3ebe:	09 95       	icall
}
    3ec0:	ff 91       	pop	r31
    3ec2:	ef 91       	pop	r30
    3ec4:	bf 91       	pop	r27
    3ec6:	af 91       	pop	r26
    3ec8:	9f 91       	pop	r25
    3eca:	8f 91       	pop	r24
    3ecc:	7f 91       	pop	r23
    3ece:	6f 91       	pop	r22
    3ed0:	5f 91       	pop	r21
    3ed2:	4f 91       	pop	r20
    3ed4:	3f 91       	pop	r19
    3ed6:	2f 91       	pop	r18
    3ed8:	0f 90       	pop	r0
    3eda:	0f be       	out	0x3f, r0	; 63
    3edc:	0f 90       	pop	r0
    3ede:	1f 90       	pop	r1
    3ee0:	18 95       	reti

00003ee2 <__vector_47>:
ISR(TIMER5_COMPA_vect)
{
    3ee2:	1f 92       	push	r1
    3ee4:	0f 92       	push	r0
    3ee6:	0f b6       	in	r0, 0x3f	; 63
    3ee8:	0f 92       	push	r0
    3eea:	11 24       	eor	r1, r1
    3eec:	2f 93       	push	r18
    3eee:	3f 93       	push	r19
    3ef0:	4f 93       	push	r20
    3ef2:	5f 93       	push	r21
    3ef4:	6f 93       	push	r22
    3ef6:	7f 93       	push	r23
    3ef8:	8f 93       	push	r24
    3efa:	9f 93       	push	r25
    3efc:	af 93       	push	r26
    3efe:	bf 93       	push	r27
    3f00:	ef 93       	push	r30
    3f02:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_COMPA_interrupt);
    3f04:	80 91 98 0f 	lds	r24, 0x0F98
    3f08:	90 91 99 0f 	lds	r25, 0x0F99
    3f0c:	89 2b       	or	r24, r25
    3f0e:	29 f0       	breq	.+10     	; 0x3f1a <__vector_47+0x38>
    3f10:	e0 91 98 0f 	lds	r30, 0x0F98
    3f14:	f0 91 99 0f 	lds	r31, 0x0F99
    3f18:	09 95       	icall
}
    3f1a:	ff 91       	pop	r31
    3f1c:	ef 91       	pop	r30
    3f1e:	bf 91       	pop	r27
    3f20:	af 91       	pop	r26
    3f22:	9f 91       	pop	r25
    3f24:	8f 91       	pop	r24
    3f26:	7f 91       	pop	r23
    3f28:	6f 91       	pop	r22
    3f2a:	5f 91       	pop	r21
    3f2c:	4f 91       	pop	r20
    3f2e:	3f 91       	pop	r19
    3f30:	2f 91       	pop	r18
    3f32:	0f 90       	pop	r0
    3f34:	0f be       	out	0x3f, r0	; 63
    3f36:	0f 90       	pop	r0
    3f38:	1f 90       	pop	r1
    3f3a:	18 95       	reti

00003f3c <__vector_48>:
ISR(TIMER5_COMPB_vect)
{
    3f3c:	1f 92       	push	r1
    3f3e:	0f 92       	push	r0
    3f40:	0f b6       	in	r0, 0x3f	; 63
    3f42:	0f 92       	push	r0
    3f44:	11 24       	eor	r1, r1
    3f46:	2f 93       	push	r18
    3f48:	3f 93       	push	r19
    3f4a:	4f 93       	push	r20
    3f4c:	5f 93       	push	r21
    3f4e:	6f 93       	push	r22
    3f50:	7f 93       	push	r23
    3f52:	8f 93       	push	r24
    3f54:	9f 93       	push	r25
    3f56:	af 93       	push	r26
    3f58:	bf 93       	push	r27
    3f5a:	ef 93       	push	r30
    3f5c:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_COMPB_interrupt);
    3f5e:	80 91 9a 0f 	lds	r24, 0x0F9A
    3f62:	90 91 9b 0f 	lds	r25, 0x0F9B
    3f66:	89 2b       	or	r24, r25
    3f68:	29 f0       	breq	.+10     	; 0x3f74 <__vector_48+0x38>
    3f6a:	e0 91 9a 0f 	lds	r30, 0x0F9A
    3f6e:	f0 91 9b 0f 	lds	r31, 0x0F9B
    3f72:	09 95       	icall
}
    3f74:	ff 91       	pop	r31
    3f76:	ef 91       	pop	r30
    3f78:	bf 91       	pop	r27
    3f7a:	af 91       	pop	r26
    3f7c:	9f 91       	pop	r25
    3f7e:	8f 91       	pop	r24
    3f80:	7f 91       	pop	r23
    3f82:	6f 91       	pop	r22
    3f84:	5f 91       	pop	r21
    3f86:	4f 91       	pop	r20
    3f88:	3f 91       	pop	r19
    3f8a:	2f 91       	pop	r18
    3f8c:	0f 90       	pop	r0
    3f8e:	0f be       	out	0x3f, r0	; 63
    3f90:	0f 90       	pop	r0
    3f92:	1f 90       	pop	r1
    3f94:	18 95       	reti

00003f96 <__vector_49>:
ISR(TIMER5_COMPC_vect)
{
    3f96:	1f 92       	push	r1
    3f98:	0f 92       	push	r0
    3f9a:	0f b6       	in	r0, 0x3f	; 63
    3f9c:	0f 92       	push	r0
    3f9e:	11 24       	eor	r1, r1
    3fa0:	2f 93       	push	r18
    3fa2:	3f 93       	push	r19
    3fa4:	4f 93       	push	r20
    3fa6:	5f 93       	push	r21
    3fa8:	6f 93       	push	r22
    3faa:	7f 93       	push	r23
    3fac:	8f 93       	push	r24
    3fae:	9f 93       	push	r25
    3fb0:	af 93       	push	r26
    3fb2:	bf 93       	push	r27
    3fb4:	ef 93       	push	r30
    3fb6:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_COMPC_interrupt);
    3fb8:	80 91 9c 0f 	lds	r24, 0x0F9C
    3fbc:	90 91 9d 0f 	lds	r25, 0x0F9D
    3fc0:	89 2b       	or	r24, r25
    3fc2:	29 f0       	breq	.+10     	; 0x3fce <__vector_49+0x38>
    3fc4:	e0 91 9c 0f 	lds	r30, 0x0F9C
    3fc8:	f0 91 9d 0f 	lds	r31, 0x0F9D
    3fcc:	09 95       	icall
}
    3fce:	ff 91       	pop	r31
    3fd0:	ef 91       	pop	r30
    3fd2:	bf 91       	pop	r27
    3fd4:	af 91       	pop	r26
    3fd6:	9f 91       	pop	r25
    3fd8:	8f 91       	pop	r24
    3fda:	7f 91       	pop	r23
    3fdc:	6f 91       	pop	r22
    3fde:	5f 91       	pop	r21
    3fe0:	4f 91       	pop	r20
    3fe2:	3f 91       	pop	r19
    3fe4:	2f 91       	pop	r18
    3fe6:	0f 90       	pop	r0
    3fe8:	0f be       	out	0x3f, r0	; 63
    3fea:	0f 90       	pop	r0
    3fec:	1f 90       	pop	r1
    3fee:	18 95       	reti

00003ff0 <__vector_default>:

ISR(BADISR_vect)
{
    3ff0:	1f 92       	push	r1
    3ff2:	0f 92       	push	r0
    3ff4:	0f b6       	in	r0, 0x3f	; 63
    3ff6:	0f 92       	push	r0
    3ff8:	11 24       	eor	r1, r1
    3ffa:	2f 93       	push	r18
    3ffc:	3f 93       	push	r19
    3ffe:	4f 93       	push	r20
    4000:	5f 93       	push	r21
    4002:	6f 93       	push	r22
    4004:	7f 93       	push	r23
    4006:	8f 93       	push	r24
    4008:	9f 93       	push	r25
    400a:	af 93       	push	r26
    400c:	bf 93       	push	r27
    400e:	ef 93       	push	r30
    4010:	ff 93       	push	r31
  rprintf("BAD_vect called!");
    4012:	00 d0       	rcall	.+0      	; 0x4014 <__vector_default+0x24>
    4014:	0f 92       	push	r0
    4016:	81 e0       	ldi	r24, 0x01	; 1
    4018:	ed b7       	in	r30, 0x3d	; 61
    401a:	fe b7       	in	r31, 0x3e	; 62
    401c:	81 83       	std	Z+1, r24	; 0x01
    401e:	8a ea       	ldi	r24, 0xAA	; 170
    4020:	91 e0       	ldi	r25, 0x01	; 1
    4022:	93 83       	std	Z+3, r25	; 0x03
    4024:	82 83       	std	Z+2, r24	; 0x02
    4026:	0e 94 c2 27 	call	0x4f84	; 0x4f84 <rprintf1RamRom>
    402a:	0f 90       	pop	r0
    402c:	0f 90       	pop	r0
    402e:	0f 90       	pop	r0
}
    4030:	ff 91       	pop	r31
    4032:	ef 91       	pop	r30
    4034:	bf 91       	pop	r27
    4036:	af 91       	pop	r26
    4038:	9f 91       	pop	r25
    403a:	8f 91       	pop	r24
    403c:	7f 91       	pop	r23
    403e:	6f 91       	pop	r22
    4040:	5f 91       	pop	r21
    4042:	4f 91       	pop	r20
    4044:	3f 91       	pop	r19
    4046:	2f 91       	pop	r18
    4048:	0f 90       	pop	r0
    404a:	0f be       	out	0x3f, r0	; 63
    404c:	0f 90       	pop	r0
    404e:	1f 90       	pop	r1
    4050:	18 95       	reti

00004052 <uartSetRxHandler>:
}

void uartSetRxHandler(u08 nUart, void (*rx_func)(unsigned char c))
{
	// make sure the uart number is within bounds
	if(nUart < 4)
    4052:	84 30       	cpi	r24, 0x04	; 4
    4054:	40 f4       	brcc	.+16     	; 0x4066 <uartSetRxHandler+0x14>
	{
		// set the receive interrupt to run the supplied user function
		UartRxFunc[nUart] = rx_func;
    4056:	e8 2f       	mov	r30, r24
    4058:	f0 e0       	ldi	r31, 0x00	; 0
    405a:	ee 0f       	add	r30, r30
    405c:	ff 1f       	adc	r31, r31
    405e:	e0 52       	subi	r30, 0x20	; 32
    4060:	fe 4e       	sbci	r31, 0xEE	; 238
    4062:	71 83       	std	Z+1, r23	; 0x01
    4064:	60 83       	st	Z, r22
    4066:	08 95       	ret

00004068 <uartSetBaudRate>:
	}
}

void uartSetBaudRate(u08 nUart, u32 baudrate)
{
    4068:	1f 93       	push	r17
    406a:	18 2f       	mov	r17, r24
    406c:	9a 01       	movw	r18, r20
    406e:	ab 01       	movw	r20, r22
	// calculate division factor for requested baud rate, and set it
	u16 bauddiv = ((F_CPU+(baudrate*8L))/(baudrate*16L)-1);
    4070:	ca 01       	movw	r24, r20
    4072:	b9 01       	movw	r22, r18
    4074:	60 58       	subi	r22, 0x80	; 128
    4076:	7b 47       	sbci	r23, 0x7B	; 123
    4078:	81 4e       	sbci	r24, 0xE1	; 225
    407a:	9f 4f       	sbci	r25, 0xFF	; 255
    407c:	f3 e0       	ldi	r31, 0x03	; 3
    407e:	66 0f       	add	r22, r22
    4080:	77 1f       	adc	r23, r23
    4082:	88 1f       	adc	r24, r24
    4084:	99 1f       	adc	r25, r25
    4086:	fa 95       	dec	r31
    4088:	d1 f7       	brne	.-12     	; 0x407e <uartSetBaudRate+0x16>
    408a:	e4 e0       	ldi	r30, 0x04	; 4
    408c:	22 0f       	add	r18, r18
    408e:	33 1f       	adc	r19, r19
    4090:	44 1f       	adc	r20, r20
    4092:	55 1f       	adc	r21, r21
    4094:	ea 95       	dec	r30
    4096:	d1 f7       	brne	.-12     	; 0x408c <uartSetBaudRate+0x24>
    4098:	0e 94 42 2e 	call	0x5c84	; 0x5c84 <__udivmodsi4>
    409c:	21 50       	subi	r18, 0x01	; 1
    409e:	30 40       	sbci	r19, 0x00	; 0
	if(nUart==3)
    40a0:	13 30       	cpi	r17, 0x03	; 3
    40a2:	29 f4       	brne	.+10     	; 0x40ae <uartSetBaudRate+0x46>
	{
		outb(UBRR3L, bauddiv);
    40a4:	20 93 34 01 	sts	0x0134, r18
		#ifdef UBRR3H
		outb(UBRR3H, bauddiv>>8);
    40a8:	30 93 35 01 	sts	0x0135, r19
    40ac:	12 c0       	rjmp	.+36     	; 0x40d2 <uartSetBaudRate+0x6a>
		#endif
	}
	else if(nUart==2)
    40ae:	12 30       	cpi	r17, 0x02	; 2
    40b0:	29 f4       	brne	.+10     	; 0x40bc <uartSetBaudRate+0x54>
	{
		outb(UBRR2L, bauddiv);
    40b2:	20 93 d4 00 	sts	0x00D4, r18
		#ifdef UBRR2H
		outb(UBRR2H, bauddiv>>8);
    40b6:	30 93 d5 00 	sts	0x00D5, r19
    40ba:	0b c0       	rjmp	.+22     	; 0x40d2 <uartSetBaudRate+0x6a>
		#endif
	}
	else if(nUart==1)
    40bc:	11 30       	cpi	r17, 0x01	; 1
    40be:	29 f4       	brne	.+10     	; 0x40ca <uartSetBaudRate+0x62>
	{
		outb(UBRR1L, bauddiv);
    40c0:	20 93 cc 00 	sts	0x00CC, r18
		#ifdef UBRR1H
		outb(UBRR1H, bauddiv>>8);
    40c4:	30 93 cd 00 	sts	0x00CD, r19
    40c8:	04 c0       	rjmp	.+8      	; 0x40d2 <uartSetBaudRate+0x6a>
		#endif
	}
	else
	{
		outb(UBRR0L, bauddiv);
    40ca:	20 93 c4 00 	sts	0x00C4, r18
		#ifdef UBRR0H
		outb(UBRR0H, bauddiv>>8);
    40ce:	30 93 c5 00 	sts	0x00C5, r19
		#endif
	}
}
    40d2:	1f 91       	pop	r17
    40d4:	08 95       	ret

000040d6 <uartGetRxBuffer>:

cBuffer* uartGetRxBuffer(u08 nUart)
{
    40d6:	28 2f       	mov	r18, r24
    40d8:	30 e0       	ldi	r19, 0x00	; 0
    40da:	a3 e0       	ldi	r26, 0x03	; 3
    40dc:	22 0f       	add	r18, r18
    40de:	33 1f       	adc	r19, r19
    40e0:	aa 95       	dec	r26
    40e2:	e1 f7       	brne	.-8      	; 0x40dc <uartGetRxBuffer+0x6>
    40e4:	25 59       	subi	r18, 0x95	; 149
    40e6:	3b 4e       	sbci	r19, 0xEB	; 235
	// return rx buffer pointer
	return &uartRxBuffer[nUart];
}
    40e8:	c9 01       	movw	r24, r18
    40ea:	08 95       	ret

000040ec <uartGetTxBuffer>:

cBuffer* uartGetTxBuffer(u08 nUart)
{
    40ec:	28 2f       	mov	r18, r24
    40ee:	30 e0       	ldi	r19, 0x00	; 0
    40f0:	b3 e0       	ldi	r27, 0x03	; 3
    40f2:	22 0f       	add	r18, r18
    40f4:	33 1f       	adc	r19, r19
    40f6:	ba 95       	dec	r27
    40f8:	e1 f7       	brne	.-8      	; 0x40f2 <uartGetTxBuffer+0x6>
    40fa:	21 57       	subi	r18, 0x71	; 113
    40fc:	3b 4e       	sbci	r19, 0xEB	; 235
	// return tx buffer pointer
	return &uartTxBuffer[nUart];
}
    40fe:	c9 01       	movw	r24, r18
    4100:	08 95       	ret

00004102 <uartSendByte>:

void uartSendByte(u08 nUart, u08 txData)
{
    4102:	e8 2f       	mov	r30, r24
	// wait for the transmitter to be ready
//	while(!uartReadyTx[nUart]);
	// send byte
	if(nUart==3)
    4104:	83 30       	cpi	r24, 0x03	; 3
    4106:	39 f4       	brne	.+14     	; 0x4116 <uartSendByte+0x14>
	{
		while(!(UCSR3A & (1<<UDRE3)));
    4108:	80 91 30 01 	lds	r24, 0x0130
    410c:	85 ff       	sbrs	r24, 5
    410e:	fc cf       	rjmp	.-8      	; 0x4108 <uartSendByte+0x6>
		outb(UDR3, txData);
    4110:	60 93 36 01 	sts	0x0136, r22
    4114:	18 c0       	rjmp	.+48     	; 0x4146 <uartSendByte+0x44>
	}
	else if(nUart==2)
    4116:	82 30       	cpi	r24, 0x02	; 2
    4118:	39 f4       	brne	.+14     	; 0x4128 <uartSendByte+0x26>
	{
		while(!(UCSR2A & (1<<UDRE2)));
    411a:	80 91 d0 00 	lds	r24, 0x00D0
    411e:	85 ff       	sbrs	r24, 5
    4120:	fc cf       	rjmp	.-8      	; 0x411a <uartSendByte+0x18>
		outb(UDR2, txData);
    4122:	60 93 d6 00 	sts	0x00D6, r22
    4126:	0f c0       	rjmp	.+30     	; 0x4146 <uartSendByte+0x44>
	}
	else if(nUart==1)
    4128:	81 30       	cpi	r24, 0x01	; 1
    412a:	39 f4       	brne	.+14     	; 0x413a <uartSendByte+0x38>
	{
		while(!(UCSR1A & (1<<UDRE1)));
    412c:	80 91 c8 00 	lds	r24, 0x00C8
    4130:	85 ff       	sbrs	r24, 5
    4132:	fc cf       	rjmp	.-8      	; 0x412c <uartSendByte+0x2a>
		outb(UDR1, txData);
    4134:	60 93 ce 00 	sts	0x00CE, r22
    4138:	06 c0       	rjmp	.+12     	; 0x4146 <uartSendByte+0x44>
	}
	else
	{
		while(!(UCSR0A & (1<<UDRE0)));
    413a:	80 91 c0 00 	lds	r24, 0x00C0
    413e:	85 ff       	sbrs	r24, 5
    4140:	fc cf       	rjmp	.-8      	; 0x413a <uartSendByte+0x38>
		outb(UDR0, txData);
    4142:	60 93 c6 00 	sts	0x00C6, r22
	}
	// set ready state to FALSE
	uartReadyTx[nUart] = FALSE;
    4146:	f0 e0       	ldi	r31, 0x00	; 0
    4148:	e9 59       	subi	r30, 0x99	; 153
    414a:	fb 4e       	sbci	r31, 0xEB	; 235
    414c:	10 82       	st	Z, r1
}
    414e:	08 95       	ret

00004150 <uart0SendByte>:

void uart0SendByte(u08 data)
{
    4150:	68 2f       	mov	r22, r24
	// send byte on UART0
	uartSendByte(0, data);
    4152:	80 e0       	ldi	r24, 0x00	; 0
    4154:	0e 94 81 20 	call	0x4102	; 0x4102 <uartSendByte>
}
    4158:	08 95       	ret

0000415a <uart1SendByte>:

void uart1SendByte(u08 data)
{
    415a:	68 2f       	mov	r22, r24
	// send byte on UART1
	uartSendByte(1, data);
    415c:	81 e0       	ldi	r24, 0x01	; 1
    415e:	0e 94 81 20 	call	0x4102	; 0x4102 <uartSendByte>
}
    4162:	08 95       	ret

00004164 <uart2SendByte>:

void uart2SendByte(u08 data)
{
    4164:	68 2f       	mov	r22, r24
	// send byte on UART2
	uartSendByte(2, data);
    4166:	82 e0       	ldi	r24, 0x02	; 2
    4168:	0e 94 81 20 	call	0x4102	; 0x4102 <uartSendByte>
}
    416c:	08 95       	ret

0000416e <uart3SendByte>:

void uart3SendByte(u08 data)
{
    416e:	68 2f       	mov	r22, r24
	// send byte on UART3
	uartSendByte(3, data);
    4170:	83 e0       	ldi	r24, 0x03	; 3
    4172:	0e 94 81 20 	call	0x4102	; 0x4102 <uartSendByte>
}
    4176:	08 95       	ret

00004178 <uartReceiveBufferIsEmpty>:
	// flush all data from receive buffer
	bufferFlush(&uartRxBuffer[nUart]);
}

u08 uartReceiveBufferIsEmpty(u08 nUart)
{
    4178:	20 e0       	ldi	r18, 0x00	; 0
    417a:	e8 2f       	mov	r30, r24
    417c:	f0 e0       	ldi	r31, 0x00	; 0
    417e:	83 e0       	ldi	r24, 0x03	; 3
    4180:	ee 0f       	add	r30, r30
    4182:	ff 1f       	adc	r31, r31
    4184:	8a 95       	dec	r24
    4186:	e1 f7       	brne	.-8      	; 0x4180 <uartReceiveBufferIsEmpty+0x8>
    4188:	e1 59       	subi	r30, 0x91	; 145
    418a:	fb 4e       	sbci	r31, 0xEB	; 235
    418c:	80 81       	ld	r24, Z
    418e:	91 81       	ldd	r25, Z+1	; 0x01
    4190:	89 2b       	or	r24, r25
    4192:	09 f4       	brne	.+2      	; 0x4196 <uartReceiveBufferIsEmpty+0x1e>
    4194:	21 e0       	ldi	r18, 0x01	; 1
	return (uartRxBuffer[nUart].datalength == 0);
}
    4196:	82 2f       	mov	r24, r18
    4198:	08 95       	ret

0000419a <uartReceiveService>:
	}
}

// UART Receive Complete Interrupt Function
void uartReceiveService(u08 nUart)
{
    419a:	cf 93       	push	r28
    419c:	df 93       	push	r29
	u08 c;
	// get received char
	if(nUart==3)
    419e:	83 30       	cpi	r24, 0x03	; 3
    41a0:	19 f4       	brne	.+6      	; 0x41a8 <uartReceiveService+0xe>
		c = inb(UDR3);
    41a2:	60 91 36 01 	lds	r22, 0x0136
    41a6:	0c c0       	rjmp	.+24     	; 0x41c0 <uartReceiveService+0x26>
	else if(nUart==2)
    41a8:	82 30       	cpi	r24, 0x02	; 2
    41aa:	19 f4       	brne	.+6      	; 0x41b2 <uartReceiveService+0x18>
		c = inb(UDR2);
    41ac:	60 91 d6 00 	lds	r22, 0x00D6
    41b0:	07 c0       	rjmp	.+14     	; 0x41c0 <uartReceiveService+0x26>
	else if(nUart==1)
    41b2:	81 30       	cpi	r24, 0x01	; 1
    41b4:	19 f4       	brne	.+6      	; 0x41bc <uartReceiveService+0x22>
		c = inb(UDR1);
    41b6:	60 91 ce 00 	lds	r22, 0x00CE
    41ba:	02 c0       	rjmp	.+4      	; 0x41c0 <uartReceiveService+0x26>
	else
		c = inb(UDR0);
    41bc:	60 91 c6 00 	lds	r22, 0x00C6

	// if there's a user function to handle this receive event
	if(UartRxFunc[nUart])
    41c0:	28 2f       	mov	r18, r24
    41c2:	30 e0       	ldi	r19, 0x00	; 0
    41c4:	e9 01       	movw	r28, r18
    41c6:	cc 0f       	add	r28, r28
    41c8:	dd 1f       	adc	r29, r29
    41ca:	fe 01       	movw	r30, r28
    41cc:	e0 52       	subi	r30, 0x20	; 32
    41ce:	fe 4e       	sbci	r31, 0xEE	; 238
    41d0:	80 81       	ld	r24, Z
    41d2:	91 81       	ldd	r25, Z+1	; 0x01
    41d4:	89 2b       	or	r24, r25
    41d6:	31 f0       	breq	.+12     	; 0x41e4 <uartReceiveService+0x4a>
	{
		// call it and pass the received data
		UartRxFunc[nUart](c);
    41d8:	01 90       	ld	r0, Z+
    41da:	f0 81       	ld	r31, Z
    41dc:	e0 2d       	mov	r30, r0
    41de:	86 2f       	mov	r24, r22
    41e0:	09 95       	icall
    41e2:	14 c0       	rjmp	.+40     	; 0x420c <uartReceiveService+0x72>
	else
	{
		// otherwise do default processing
		// put received char in buffer
		// check if there's space
		if( !bufferAddToEnd(&uartRxBuffer[nUart], c) )
    41e4:	93 e0       	ldi	r25, 0x03	; 3
    41e6:	22 0f       	add	r18, r18
    41e8:	33 1f       	adc	r19, r19
    41ea:	9a 95       	dec	r25
    41ec:	e1 f7       	brne	.-8      	; 0x41e6 <uartReceiveService+0x4c>
    41ee:	c9 01       	movw	r24, r18
    41f0:	85 59       	subi	r24, 0x95	; 149
    41f2:	9b 4e       	sbci	r25, 0xEB	; 235
    41f4:	0e 94 d9 24 	call	0x49b2	; 0x49b2 <bufferAddToEnd>
    41f8:	88 23       	and	r24, r24
    41fa:	41 f4       	brne	.+16     	; 0x420c <uartReceiveService+0x72>
		{
			// no space in buffer
			// count overflow
			uartRxOverflow[nUart]++;
    41fc:	fe 01       	movw	r30, r28
    41fe:	e1 55       	subi	r30, 0x51	; 81
    4200:	fb 4e       	sbci	r31, 0xEB	; 235
    4202:	80 81       	ld	r24, Z
    4204:	91 81       	ldd	r25, Z+1	; 0x01
    4206:	01 96       	adiw	r24, 0x01	; 1
    4208:	91 83       	std	Z+1, r25	; 0x01
    420a:	80 83       	st	Z, r24
		}
	}
}
    420c:	df 91       	pop	r29
    420e:	cf 91       	pop	r28
    4210:	08 95       	ret

00004212 <__vector_54>:
{
	uartReceiveService(2);
}

UART_INTERRUPT_HANDLER(SIG_USART3_RECV)      
{
    4212:	1f 92       	push	r1
    4214:	0f 92       	push	r0
    4216:	0f b6       	in	r0, 0x3f	; 63
    4218:	0f 92       	push	r0
    421a:	11 24       	eor	r1, r1
    421c:	2f 93       	push	r18
    421e:	3f 93       	push	r19
    4220:	4f 93       	push	r20
    4222:	5f 93       	push	r21
    4224:	6f 93       	push	r22
    4226:	7f 93       	push	r23
    4228:	8f 93       	push	r24
    422a:	9f 93       	push	r25
    422c:	af 93       	push	r26
    422e:	bf 93       	push	r27
    4230:	ef 93       	push	r30
    4232:	ff 93       	push	r31
	uartReceiveService(3);
    4234:	83 e0       	ldi	r24, 0x03	; 3
    4236:	0e 94 cd 20 	call	0x419a	; 0x419a <uartReceiveService>
}
    423a:	ff 91       	pop	r31
    423c:	ef 91       	pop	r30
    423e:	bf 91       	pop	r27
    4240:	af 91       	pop	r26
    4242:	9f 91       	pop	r25
    4244:	8f 91       	pop	r24
    4246:	7f 91       	pop	r23
    4248:	6f 91       	pop	r22
    424a:	5f 91       	pop	r21
    424c:	4f 91       	pop	r20
    424e:	3f 91       	pop	r19
    4250:	2f 91       	pop	r18
    4252:	0f 90       	pop	r0
    4254:	0f be       	out	0x3f, r0	; 63
    4256:	0f 90       	pop	r0
    4258:	1f 90       	pop	r1
    425a:	18 95       	reti

0000425c <__vector_51>:
{
	uartReceiveService(1);
}

UART_INTERRUPT_HANDLER(SIG_USART2_RECV)      
{
    425c:	1f 92       	push	r1
    425e:	0f 92       	push	r0
    4260:	0f b6       	in	r0, 0x3f	; 63
    4262:	0f 92       	push	r0
    4264:	11 24       	eor	r1, r1
    4266:	2f 93       	push	r18
    4268:	3f 93       	push	r19
    426a:	4f 93       	push	r20
    426c:	5f 93       	push	r21
    426e:	6f 93       	push	r22
    4270:	7f 93       	push	r23
    4272:	8f 93       	push	r24
    4274:	9f 93       	push	r25
    4276:	af 93       	push	r26
    4278:	bf 93       	push	r27
    427a:	ef 93       	push	r30
    427c:	ff 93       	push	r31
	uartReceiveService(2);
    427e:	82 e0       	ldi	r24, 0x02	; 2
    4280:	0e 94 cd 20 	call	0x419a	; 0x419a <uartReceiveService>
}
    4284:	ff 91       	pop	r31
    4286:	ef 91       	pop	r30
    4288:	bf 91       	pop	r27
    428a:	af 91       	pop	r26
    428c:	9f 91       	pop	r25
    428e:	8f 91       	pop	r24
    4290:	7f 91       	pop	r23
    4292:	6f 91       	pop	r22
    4294:	5f 91       	pop	r21
    4296:	4f 91       	pop	r20
    4298:	3f 91       	pop	r19
    429a:	2f 91       	pop	r18
    429c:	0f 90       	pop	r0
    429e:	0f be       	out	0x3f, r0	; 63
    42a0:	0f 90       	pop	r0
    42a2:	1f 90       	pop	r1
    42a4:	18 95       	reti

000042a6 <__vector_36>:
{
	uartReceiveService(0);
}

UART_INTERRUPT_HANDLER(SIG_USART1_RECV)      
{
    42a6:	1f 92       	push	r1
    42a8:	0f 92       	push	r0
    42aa:	0f b6       	in	r0, 0x3f	; 63
    42ac:	0f 92       	push	r0
    42ae:	11 24       	eor	r1, r1
    42b0:	2f 93       	push	r18
    42b2:	3f 93       	push	r19
    42b4:	4f 93       	push	r20
    42b6:	5f 93       	push	r21
    42b8:	6f 93       	push	r22
    42ba:	7f 93       	push	r23
    42bc:	8f 93       	push	r24
    42be:	9f 93       	push	r25
    42c0:	af 93       	push	r26
    42c2:	bf 93       	push	r27
    42c4:	ef 93       	push	r30
    42c6:	ff 93       	push	r31
	uartReceiveService(1);
    42c8:	81 e0       	ldi	r24, 0x01	; 1
    42ca:	0e 94 cd 20 	call	0x419a	; 0x419a <uartReceiveService>
}
    42ce:	ff 91       	pop	r31
    42d0:	ef 91       	pop	r30
    42d2:	bf 91       	pop	r27
    42d4:	af 91       	pop	r26
    42d6:	9f 91       	pop	r25
    42d8:	8f 91       	pop	r24
    42da:	7f 91       	pop	r23
    42dc:	6f 91       	pop	r22
    42de:	5f 91       	pop	r21
    42e0:	4f 91       	pop	r20
    42e2:	3f 91       	pop	r19
    42e4:	2f 91       	pop	r18
    42e6:	0f 90       	pop	r0
    42e8:	0f be       	out	0x3f, r0	; 63
    42ea:	0f 90       	pop	r0
    42ec:	1f 90       	pop	r1
    42ee:	18 95       	reti

000042f0 <__vector_25>:
	uartTransmitService(3);
}

	// service UART receive interrupt
UART_INTERRUPT_HANDLER(SIG_USART0_RECV)      
{
    42f0:	1f 92       	push	r1
    42f2:	0f 92       	push	r0
    42f4:	0f b6       	in	r0, 0x3f	; 63
    42f6:	0f 92       	push	r0
    42f8:	11 24       	eor	r1, r1
    42fa:	2f 93       	push	r18
    42fc:	3f 93       	push	r19
    42fe:	4f 93       	push	r20
    4300:	5f 93       	push	r21
    4302:	6f 93       	push	r22
    4304:	7f 93       	push	r23
    4306:	8f 93       	push	r24
    4308:	9f 93       	push	r25
    430a:	af 93       	push	r26
    430c:	bf 93       	push	r27
    430e:	ef 93       	push	r30
    4310:	ff 93       	push	r31
	uartReceiveService(0);
    4312:	80 e0       	ldi	r24, 0x00	; 0
    4314:	0e 94 cd 20 	call	0x419a	; 0x419a <uartReceiveService>
}
    4318:	ff 91       	pop	r31
    431a:	ef 91       	pop	r30
    431c:	bf 91       	pop	r27
    431e:	af 91       	pop	r26
    4320:	9f 91       	pop	r25
    4322:	8f 91       	pop	r24
    4324:	7f 91       	pop	r23
    4326:	6f 91       	pop	r22
    4328:	5f 91       	pop	r21
    432a:	4f 91       	pop	r20
    432c:	3f 91       	pop	r19
    432e:	2f 91       	pop	r18
    4330:	0f 90       	pop	r0
    4332:	0f be       	out	0x3f, r0	; 63
    4334:	0f 90       	pop	r0
    4336:	1f 90       	pop	r1
    4338:	18 95       	reti

0000433a <uartSendBuffer>:
	// send the first byte to get things going by interrupts
	uartSendByte(nUart, bufferGetFromFront(&uartTxBuffer[nUart]));
}

u08 uartSendBuffer(u08 nUart, char *buffer, u16 nBytes)
{
    433a:	8f 92       	push	r8
    433c:	9f 92       	push	r9
    433e:	af 92       	push	r10
    4340:	bf 92       	push	r11
    4342:	cf 92       	push	r12
    4344:	df 92       	push	r13
    4346:	ef 92       	push	r14
    4348:	ff 92       	push	r15
    434a:	0f 93       	push	r16
    434c:	1f 93       	push	r17
    434e:	cf 93       	push	r28
    4350:	df 93       	push	r29
    4352:	88 2e       	mov	r8, r24
    4354:	db 01       	movw	r26, r22
	register u08 first;
	register u16 i;

	// check if there's space (and that we have any bytes to send at all)
	if((uartTxBuffer[nUart].datalength + nBytes < uartTxBuffer[nUart].size) && nBytes)
    4356:	c8 2e       	mov	r12, r24
    4358:	dd 24       	eor	r13, r13
    435a:	f6 01       	movw	r30, r12
    435c:	13 e0       	ldi	r17, 0x03	; 3
    435e:	ee 0f       	add	r30, r30
    4360:	ff 1f       	adc	r31, r31
    4362:	1a 95       	dec	r17
    4364:	e1 f7       	brne	.-8      	; 0x435e <uartSendBuffer+0x24>
    4366:	ed 56       	subi	r30, 0x6D	; 109
    4368:	fb 4e       	sbci	r31, 0xEB	; 235
    436a:	20 81       	ld	r18, Z
    436c:	31 81       	ldd	r19, Z+1	; 0x01
    436e:	24 0f       	add	r18, r20
    4370:	35 1f       	adc	r19, r21
    4372:	f6 01       	movw	r30, r12
    4374:	73 e0       	ldi	r23, 0x03	; 3
    4376:	ee 0f       	add	r30, r30
    4378:	ff 1f       	adc	r31, r31
    437a:	7a 95       	dec	r23
    437c:	e1 f7       	brne	.-8      	; 0x4376 <uartSendBuffer+0x3c>
    437e:	ef 56       	subi	r30, 0x6F	; 111
    4380:	fb 4e       	sbci	r31, 0xEB	; 235
    4382:	80 81       	ld	r24, Z
    4384:	91 81       	ldd	r25, Z+1	; 0x01
    4386:	28 17       	cp	r18, r24
    4388:	39 07       	cpc	r19, r25
    438a:	70 f5       	brcc	.+92     	; 0x43e8 <uartSendBuffer+0xae>
    438c:	41 15       	cp	r20, r1
    438e:	51 05       	cpc	r21, r1
    4390:	59 f1       	breq	.+86     	; 0x43e8 <uartSendBuffer+0xae>
	{
		// grab first character
		first = *buffer++;
    4392:	9c 90       	ld	r9, X
		// copy user buffer to uart transmit buffer
		for(i = 0; i < nBytes-1; i++)
		{
			// put data bytes at end of buffer
			bufferAddToEnd(&uartTxBuffer[nUart], *buffer++);
    4394:	76 01       	movw	r14, r12
    4396:	63 e0       	ldi	r22, 0x03	; 3
    4398:	ee 0c       	add	r14, r14
    439a:	ff 1c       	adc	r15, r15
    439c:	6a 95       	dec	r22
    439e:	e1 f7       	brne	.-8      	; 0x4398 <uartSendBuffer+0x5e>
    43a0:	8f e8       	ldi	r24, 0x8F	; 143
    43a2:	94 e1       	ldi	r25, 0x14	; 20
    43a4:	e8 0e       	add	r14, r24
    43a6:	f9 1e       	adc	r15, r25
    43a8:	8d 01       	movw	r16, r26
    43aa:	c0 e0       	ldi	r28, 0x00	; 0
    43ac:	d0 e0       	ldi	r29, 0x00	; 0
	if((uartTxBuffer[nUart].datalength + nBytes < uartTxBuffer[nUart].size) && nBytes)
	{
		// grab first character
		first = *buffer++;
		// copy user buffer to uart transmit buffer
		for(i = 0; i < nBytes-1; i++)
    43ae:	5a 01       	movw	r10, r20
    43b0:	08 94       	sec
    43b2:	a1 08       	sbc	r10, r1
    43b4:	b1 08       	sbc	r11, r1
    43b6:	06 c0       	rjmp	.+12     	; 0x43c4 <uartSendBuffer+0x8a>
    43b8:	c7 01       	movw	r24, r14
    43ba:	f8 01       	movw	r30, r16
    43bc:	60 81       	ld	r22, Z
    43be:	0e 94 d9 24 	call	0x49b2	; 0x49b2 <bufferAddToEnd>
    43c2:	21 96       	adiw	r28, 0x01	; 1
    43c4:	0f 5f       	subi	r16, 0xFF	; 255
    43c6:	1f 4f       	sbci	r17, 0xFF	; 255
    43c8:	ca 15       	cp	r28, r10
    43ca:	db 05       	cpc	r29, r11
    43cc:	a8 f3       	brcs	.-22     	; 0x43b8 <uartSendBuffer+0x7e>
			// put data bytes at end of buffer
			bufferAddToEnd(&uartTxBuffer[nUart], *buffer++);
		}

		// send the first byte to get things going by interrupts
		uartBufferedTx[nUart] = TRUE;
    43ce:	8b e8       	ldi	r24, 0x8B	; 139
    43d0:	94 e1       	ldi	r25, 0x14	; 20
    43d2:	c8 0e       	add	r12, r24
    43d4:	d9 1e       	adc	r13, r25
    43d6:	8f ef       	ldi	r24, 0xFF	; 255
    43d8:	f6 01       	movw	r30, r12
    43da:	80 83       	st	Z, r24
		uartSendByte(nUart, first);
    43dc:	88 2d       	mov	r24, r8
    43de:	69 2d       	mov	r22, r9
    43e0:	0e 94 81 20 	call	0x4102	; 0x4102 <uartSendByte>
    43e4:	8f ef       	ldi	r24, 0xFF	; 255
    43e6:	01 c0       	rjmp	.+2      	; 0x43ea <uartSendBuffer+0xb0>
		// return success
		return TRUE;
    43e8:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		// return failure
		return FALSE;
	}
}
    43ea:	df 91       	pop	r29
    43ec:	cf 91       	pop	r28
    43ee:	1f 91       	pop	r17
    43f0:	0f 91       	pop	r16
    43f2:	ff 90       	pop	r15
    43f4:	ef 90       	pop	r14
    43f6:	df 90       	pop	r13
    43f8:	cf 90       	pop	r12
    43fa:	bf 90       	pop	r11
    43fc:	af 90       	pop	r10
    43fe:	9f 90       	pop	r9
    4400:	8f 90       	pop	r8
    4402:	08 95       	ret

00004404 <uartAddToTxBuffer>:
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    4404:	90 e0       	ldi	r25, 0x00	; 0
    4406:	23 e0       	ldi	r18, 0x03	; 3
    4408:	88 0f       	add	r24, r24
    440a:	99 1f       	adc	r25, r25
    440c:	2a 95       	dec	r18
    440e:	e1 f7       	brne	.-8      	; 0x4408 <uartAddToTxBuffer+0x4>
    4410:	81 57       	subi	r24, 0x71	; 113
    4412:	9b 4e       	sbci	r25, 0xEB	; 235
    4414:	0e 94 d9 24 	call	0x49b2	; 0x49b2 <bufferAddToEnd>
}
    4418:	08 95       	ret

0000441a <uart3AddToTxBuffer>:
{
	uartAddToTxBuffer(2,data);
}

void uart3AddToTxBuffer(u08 data)
{
    441a:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    441c:	87 ea       	ldi	r24, 0xA7	; 167
    441e:	94 e1       	ldi	r25, 0x14	; 20
    4420:	0e 94 d9 24 	call	0x49b2	; 0x49b2 <bufferAddToEnd>
}

void uart3AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(3,data);
}
    4424:	08 95       	ret

00004426 <uart2AddToTxBuffer>:
{
	uartAddToTxBuffer(1,data);
}

void uart2AddToTxBuffer(u08 data)
{
    4426:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    4428:	8f e9       	ldi	r24, 0x9F	; 159
    442a:	94 e1       	ldi	r25, 0x14	; 20
    442c:	0e 94 d9 24 	call	0x49b2	; 0x49b2 <bufferAddToEnd>
}

void uart2AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(2,data);
}
    4430:	08 95       	ret

00004432 <uart1AddToTxBuffer>:
{
	uartAddToTxBuffer(0,data);
}

void uart1AddToTxBuffer(u08 data)
{
    4432:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    4434:	87 e9       	ldi	r24, 0x97	; 151
    4436:	94 e1       	ldi	r25, 0x14	; 20
    4438:	0e 94 d9 24 	call	0x49b2	; 0x49b2 <bufferAddToEnd>
}

void uart1AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(1,data);
}
    443c:	08 95       	ret

0000443e <uart0AddToTxBuffer>:
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
}

void uart0AddToTxBuffer(u08 data)
{
    443e:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    4440:	8f e8       	ldi	r24, 0x8F	; 143
    4442:	94 e1       	ldi	r25, 0x14	; 20
    4444:	0e 94 d9 24 	call	0x49b2	; 0x49b2 <bufferAddToEnd>
}

void uart0AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(0,data);
}
    4448:	08 95       	ret

0000444a <uartTransmitService>:
	}
}

// UART Transmit Complete Interrupt Function
void uartTransmitService(u08 nUart)
{
    444a:	cf 93       	push	r28
    444c:	df 93       	push	r29
    444e:	28 2f       	mov	r18, r24
	// check if buffered tx is enabled
	if(uartBufferedTx[nUart])
    4450:	a8 2f       	mov	r26, r24
    4452:	b0 e0       	ldi	r27, 0x00	; 0
    4454:	ed 01       	movw	r28, r26
    4456:	c5 57       	subi	r28, 0x75	; 117
    4458:	db 4e       	sbci	r29, 0xEB	; 235
    445a:	88 81       	ld	r24, Y
    445c:	88 23       	and	r24, r24
    445e:	79 f1       	breq	.+94     	; 0x44be <uartTransmitService+0x74>
	{
		// check if there's data left in the buffer
		if(uartTxBuffer[nUart].datalength)
    4460:	fd 01       	movw	r30, r26
    4462:	33 e0       	ldi	r19, 0x03	; 3
    4464:	ee 0f       	add	r30, r30
    4466:	ff 1f       	adc	r31, r31
    4468:	3a 95       	dec	r19
    446a:	e1 f7       	brne	.-8      	; 0x4464 <uartTransmitService+0x1a>
    446c:	ed 56       	subi	r30, 0x6D	; 109
    446e:	fb 4e       	sbci	r31, 0xEB	; 235
    4470:	80 81       	ld	r24, Z
    4472:	91 81       	ldd	r25, Z+1	; 0x01
    4474:	89 2b       	or	r24, r25
    4476:	11 f1       	breq	.+68     	; 0x44bc <uartTransmitService+0x72>
		{
			// send byte from top of buffer
			if(nUart==3)
    4478:	23 30       	cpi	r18, 0x03	; 3
    447a:	39 f4       	brne	.+14     	; 0x448a <uartTransmitService+0x40>
				outb(UDR3,  bufferGetFromFront(&uartTxBuffer[3]) );
    447c:	87 ea       	ldi	r24, 0xA7	; 167
    447e:	94 e1       	ldi	r25, 0x14	; 20
    4480:	0e 94 70 24 	call	0x48e0	; 0x48e0 <bufferGetFromFront>
    4484:	80 93 36 01 	sts	0x0136, r24
    4488:	1e c0       	rjmp	.+60     	; 0x44c6 <uartTransmitService+0x7c>
			else if(nUart==2)
    448a:	22 30       	cpi	r18, 0x02	; 2
    448c:	39 f4       	brne	.+14     	; 0x449c <uartTransmitService+0x52>
				outb(UDR2,  bufferGetFromFront(&uartTxBuffer[2]) );
    448e:	8f e9       	ldi	r24, 0x9F	; 159
    4490:	94 e1       	ldi	r25, 0x14	; 20
    4492:	0e 94 70 24 	call	0x48e0	; 0x48e0 <bufferGetFromFront>
    4496:	80 93 d6 00 	sts	0x00D6, r24
    449a:	15 c0       	rjmp	.+42     	; 0x44c6 <uartTransmitService+0x7c>
			else if(nUart==1)
    449c:	21 30       	cpi	r18, 0x01	; 1
    449e:	39 f4       	brne	.+14     	; 0x44ae <uartTransmitService+0x64>
				outb(UDR1,  bufferGetFromFront(&uartTxBuffer[1]) );
    44a0:	87 e9       	ldi	r24, 0x97	; 151
    44a2:	94 e1       	ldi	r25, 0x14	; 20
    44a4:	0e 94 70 24 	call	0x48e0	; 0x48e0 <bufferGetFromFront>
    44a8:	80 93 ce 00 	sts	0x00CE, r24
    44ac:	0c c0       	rjmp	.+24     	; 0x44c6 <uartTransmitService+0x7c>
			else
				outb(UDR0,  bufferGetFromFront(&uartTxBuffer[0]) );
    44ae:	8f e8       	ldi	r24, 0x8F	; 143
    44b0:	94 e1       	ldi	r25, 0x14	; 20
    44b2:	0e 94 70 24 	call	0x48e0	; 0x48e0 <bufferGetFromFront>
    44b6:	80 93 c6 00 	sts	0x00C6, r24
    44ba:	05 c0       	rjmp	.+10     	; 0x44c6 <uartTransmitService+0x7c>
		}
		else
		{
			// no data left
			uartBufferedTx[nUart] = FALSE;
    44bc:	18 82       	st	Y, r1
	}
	else
	{
		// we're using single-byte tx mode
		// indicate transmit complete, back to ready
		uartReadyTx[nUart] = TRUE;
    44be:	a9 59       	subi	r26, 0x99	; 153
    44c0:	bb 4e       	sbci	r27, 0xEB	; 235
    44c2:	8f ef       	ldi	r24, 0xFF	; 255
    44c4:	8c 93       	st	X, r24
	}
}
    44c6:	df 91       	pop	r29
    44c8:	cf 91       	pop	r28
    44ca:	08 95       	ret

000044cc <__vector_56>:
{
	uartTransmitService(2);
}

UART_INTERRUPT_HANDLER(SIG_USART3_TRANS)      
{
    44cc:	1f 92       	push	r1
    44ce:	0f 92       	push	r0
    44d0:	0f b6       	in	r0, 0x3f	; 63
    44d2:	0f 92       	push	r0
    44d4:	11 24       	eor	r1, r1
    44d6:	2f 93       	push	r18
    44d8:	3f 93       	push	r19
    44da:	4f 93       	push	r20
    44dc:	5f 93       	push	r21
    44de:	6f 93       	push	r22
    44e0:	7f 93       	push	r23
    44e2:	8f 93       	push	r24
    44e4:	9f 93       	push	r25
    44e6:	af 93       	push	r26
    44e8:	bf 93       	push	r27
    44ea:	ef 93       	push	r30
    44ec:	ff 93       	push	r31
	uartTransmitService(3);
    44ee:	83 e0       	ldi	r24, 0x03	; 3
    44f0:	0e 94 25 22 	call	0x444a	; 0x444a <uartTransmitService>
}
    44f4:	ff 91       	pop	r31
    44f6:	ef 91       	pop	r30
    44f8:	bf 91       	pop	r27
    44fa:	af 91       	pop	r26
    44fc:	9f 91       	pop	r25
    44fe:	8f 91       	pop	r24
    4500:	7f 91       	pop	r23
    4502:	6f 91       	pop	r22
    4504:	5f 91       	pop	r21
    4506:	4f 91       	pop	r20
    4508:	3f 91       	pop	r19
    450a:	2f 91       	pop	r18
    450c:	0f 90       	pop	r0
    450e:	0f be       	out	0x3f, r0	; 63
    4510:	0f 90       	pop	r0
    4512:	1f 90       	pop	r1
    4514:	18 95       	reti

00004516 <__vector_53>:
{
	uartTransmitService(1);
}

UART_INTERRUPT_HANDLER(SIG_USART2_TRANS)      
{
    4516:	1f 92       	push	r1
    4518:	0f 92       	push	r0
    451a:	0f b6       	in	r0, 0x3f	; 63
    451c:	0f 92       	push	r0
    451e:	11 24       	eor	r1, r1
    4520:	2f 93       	push	r18
    4522:	3f 93       	push	r19
    4524:	4f 93       	push	r20
    4526:	5f 93       	push	r21
    4528:	6f 93       	push	r22
    452a:	7f 93       	push	r23
    452c:	8f 93       	push	r24
    452e:	9f 93       	push	r25
    4530:	af 93       	push	r26
    4532:	bf 93       	push	r27
    4534:	ef 93       	push	r30
    4536:	ff 93       	push	r31
	uartTransmitService(2);
    4538:	82 e0       	ldi	r24, 0x02	; 2
    453a:	0e 94 25 22 	call	0x444a	; 0x444a <uartTransmitService>
}
    453e:	ff 91       	pop	r31
    4540:	ef 91       	pop	r30
    4542:	bf 91       	pop	r27
    4544:	af 91       	pop	r26
    4546:	9f 91       	pop	r25
    4548:	8f 91       	pop	r24
    454a:	7f 91       	pop	r23
    454c:	6f 91       	pop	r22
    454e:	5f 91       	pop	r21
    4550:	4f 91       	pop	r20
    4552:	3f 91       	pop	r19
    4554:	2f 91       	pop	r18
    4556:	0f 90       	pop	r0
    4558:	0f be       	out	0x3f, r0	; 63
    455a:	0f 90       	pop	r0
    455c:	1f 90       	pop	r1
    455e:	18 95       	reti

00004560 <__vector_38>:
{
	uartTransmitService(0);
}

UART_INTERRUPT_HANDLER(SIG_USART1_TRANS)      
{
    4560:	1f 92       	push	r1
    4562:	0f 92       	push	r0
    4564:	0f b6       	in	r0, 0x3f	; 63
    4566:	0f 92       	push	r0
    4568:	11 24       	eor	r1, r1
    456a:	2f 93       	push	r18
    456c:	3f 93       	push	r19
    456e:	4f 93       	push	r20
    4570:	5f 93       	push	r21
    4572:	6f 93       	push	r22
    4574:	7f 93       	push	r23
    4576:	8f 93       	push	r24
    4578:	9f 93       	push	r25
    457a:	af 93       	push	r26
    457c:	bf 93       	push	r27
    457e:	ef 93       	push	r30
    4580:	ff 93       	push	r31
	uartTransmitService(1);
    4582:	81 e0       	ldi	r24, 0x01	; 1
    4584:	0e 94 25 22 	call	0x444a	; 0x444a <uartTransmitService>
}
    4588:	ff 91       	pop	r31
    458a:	ef 91       	pop	r30
    458c:	bf 91       	pop	r27
    458e:	af 91       	pop	r26
    4590:	9f 91       	pop	r25
    4592:	8f 91       	pop	r24
    4594:	7f 91       	pop	r23
    4596:	6f 91       	pop	r22
    4598:	5f 91       	pop	r21
    459a:	4f 91       	pop	r20
    459c:	3f 91       	pop	r19
    459e:	2f 91       	pop	r18
    45a0:	0f 90       	pop	r0
    45a2:	0f be       	out	0x3f, r0	; 63
    45a4:	0f 90       	pop	r0
    45a6:	1f 90       	pop	r1
    45a8:	18 95       	reti

000045aa <__vector_27>:
	}
}

	// service UART transmit interrupt
UART_INTERRUPT_HANDLER(SIG_USART0_TRANS)      
{
    45aa:	1f 92       	push	r1
    45ac:	0f 92       	push	r0
    45ae:	0f b6       	in	r0, 0x3f	; 63
    45b0:	0f 92       	push	r0
    45b2:	11 24       	eor	r1, r1
    45b4:	2f 93       	push	r18
    45b6:	3f 93       	push	r19
    45b8:	4f 93       	push	r20
    45ba:	5f 93       	push	r21
    45bc:	6f 93       	push	r22
    45be:	7f 93       	push	r23
    45c0:	8f 93       	push	r24
    45c2:	9f 93       	push	r25
    45c4:	af 93       	push	r26
    45c6:	bf 93       	push	r27
    45c8:	ef 93       	push	r30
    45ca:	ff 93       	push	r31
	uartTransmitService(0);
    45cc:	80 e0       	ldi	r24, 0x00	; 0
    45ce:	0e 94 25 22 	call	0x444a	; 0x444a <uartTransmitService>
}
    45d2:	ff 91       	pop	r31
    45d4:	ef 91       	pop	r30
    45d6:	bf 91       	pop	r27
    45d8:	af 91       	pop	r26
    45da:	9f 91       	pop	r25
    45dc:	8f 91       	pop	r24
    45de:	7f 91       	pop	r23
    45e0:	6f 91       	pop	r22
    45e2:	5f 91       	pop	r21
    45e4:	4f 91       	pop	r20
    45e6:	3f 91       	pop	r19
    45e8:	2f 91       	pop	r18
    45ea:	0f 90       	pop	r0
    45ec:	0f be       	out	0x3f, r0	; 63
    45ee:	0f 90       	pop	r0
    45f0:	1f 90       	pop	r1
    45f2:	18 95       	reti

000045f4 <uartSendTxBuffer>:
{
	uartAddToTxBuffer(3,data);
}

void uartSendTxBuffer(u08 nUart)
{
    45f4:	1f 93       	push	r17
    45f6:	18 2f       	mov	r17, r24
	// turn on buffered transmit
	uartBufferedTx[nUart] = TRUE;
    45f8:	90 e0       	ldi	r25, 0x00	; 0
    45fa:	fc 01       	movw	r30, r24
    45fc:	e5 57       	subi	r30, 0x75	; 117
    45fe:	fb 4e       	sbci	r31, 0xEB	; 235
    4600:	2f ef       	ldi	r18, 0xFF	; 255
    4602:	20 83       	st	Z, r18
	// send the first byte to get things going by interrupts
	uartSendByte(nUart, bufferGetFromFront(&uartTxBuffer[nUart]));
    4604:	43 e0       	ldi	r20, 0x03	; 3
    4606:	88 0f       	add	r24, r24
    4608:	99 1f       	adc	r25, r25
    460a:	4a 95       	dec	r20
    460c:	e1 f7       	brne	.-8      	; 0x4606 <uartSendTxBuffer+0x12>
    460e:	81 57       	subi	r24, 0x71	; 113
    4610:	9b 4e       	sbci	r25, 0xEB	; 235
    4612:	0e 94 70 24 	call	0x48e0	; 0x48e0 <bufferGetFromFront>
    4616:	68 2f       	mov	r22, r24
    4618:	81 2f       	mov	r24, r17
    461a:	0e 94 81 20 	call	0x4102	; 0x4102 <uartSendByte>
}
    461e:	1f 91       	pop	r17
    4620:	08 95       	ret

00004622 <uartReceiveByte>:
		return -1;
}


u08 uartReceiveByte(u08 nUart, u08* rxData)
{
    4622:	cf 93       	push	r28
    4624:	df 93       	push	r29
    4626:	eb 01       	movw	r28, r22
	// make sure we have a receive buffer
	if(uartRxBuffer[nUart].size)
    4628:	28 2f       	mov	r18, r24
    462a:	30 e0       	ldi	r19, 0x00	; 0
    462c:	f9 01       	movw	r30, r18
    462e:	73 e0       	ldi	r23, 0x03	; 3
    4630:	ee 0f       	add	r30, r30
    4632:	ff 1f       	adc	r31, r31
    4634:	7a 95       	dec	r23
    4636:	e1 f7       	brne	.-8      	; 0x4630 <uartReceiveByte+0xe>
    4638:	e3 59       	subi	r30, 0x93	; 147
    463a:	fb 4e       	sbci	r31, 0xEB	; 235
    463c:	80 81       	ld	r24, Z
    463e:	91 81       	ldd	r25, Z+1	; 0x01
    4640:	89 2b       	or	r24, r25
    4642:	c9 f0       	breq	.+50     	; 0x4676 <uartReceiveByte+0x54>
	{
		// make sure we have data
		if(uartRxBuffer[nUart].datalength)
    4644:	f9 01       	movw	r30, r18
    4646:	63 e0       	ldi	r22, 0x03	; 3
    4648:	ee 0f       	add	r30, r30
    464a:	ff 1f       	adc	r31, r31
    464c:	6a 95       	dec	r22
    464e:	e1 f7       	brne	.-8      	; 0x4648 <uartReceiveByte+0x26>
    4650:	e1 59       	subi	r30, 0x91	; 145
    4652:	fb 4e       	sbci	r31, 0xEB	; 235
    4654:	80 81       	ld	r24, Z
    4656:	91 81       	ldd	r25, Z+1	; 0x01
    4658:	89 2b       	or	r24, r25
    465a:	69 f0       	breq	.+26     	; 0x4676 <uartReceiveByte+0x54>
		{
			// get byte from beginning of buffer
			*rxData = bufferGetFromFront(&uartRxBuffer[nUart]);
    465c:	53 e0       	ldi	r21, 0x03	; 3
    465e:	22 0f       	add	r18, r18
    4660:	33 1f       	adc	r19, r19
    4662:	5a 95       	dec	r21
    4664:	e1 f7       	brne	.-8      	; 0x465e <uartReceiveByte+0x3c>
    4666:	c9 01       	movw	r24, r18
    4668:	85 59       	subi	r24, 0x95	; 149
    466a:	9b 4e       	sbci	r25, 0xEB	; 235
    466c:	0e 94 70 24 	call	0x48e0	; 0x48e0 <bufferGetFromFront>
    4670:	88 83       	st	Y, r24
    4672:	8f ef       	ldi	r24, 0xFF	; 255
    4674:	01 c0       	rjmp	.+2      	; 0x4678 <uartReceiveByte+0x56>
			return TRUE;
    4676:	80 e0       	ldi	r24, 0x00	; 0
		else
			return FALSE;			// no data
	}
	else
		return FALSE;				// no buffer
}
    4678:	df 91       	pop	r29
    467a:	cf 91       	pop	r28
    467c:	08 95       	ret

0000467e <uart3GetByte>:
	else
		return -1;
}

int uart3GetByte(void)
{
    467e:	df 93       	push	r29
    4680:	cf 93       	push	r28
    4682:	0f 92       	push	r0
    4684:	cd b7       	in	r28, 0x3d	; 61
    4686:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(3,&c))
    4688:	83 e0       	ldi	r24, 0x03	; 3
    468a:	be 01       	movw	r22, r28
    468c:	6f 5f       	subi	r22, 0xFF	; 255
    468e:	7f 4f       	sbci	r23, 0xFF	; 255
    4690:	0e 94 11 23 	call	0x4622	; 0x4622 <uartReceiveByte>
    4694:	88 23       	and	r24, r24
    4696:	19 f4       	brne	.+6      	; 0x469e <uart3GetByte+0x20>
    4698:	2f ef       	ldi	r18, 0xFF	; 255
    469a:	3f ef       	ldi	r19, 0xFF	; 255
    469c:	03 c0       	rjmp	.+6      	; 0x46a4 <uart3GetByte+0x26>
		return c;
    469e:	89 81       	ldd	r24, Y+1	; 0x01
    46a0:	28 2f       	mov	r18, r24
    46a2:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    46a4:	c9 01       	movw	r24, r18
    46a6:	0f 90       	pop	r0
    46a8:	cf 91       	pop	r28
    46aa:	df 91       	pop	r29
    46ac:	08 95       	ret

000046ae <uart2GetByte>:
	else
		return -1;
}

int uart2GetByte(void)
{
    46ae:	df 93       	push	r29
    46b0:	cf 93       	push	r28
    46b2:	0f 92       	push	r0
    46b4:	cd b7       	in	r28, 0x3d	; 61
    46b6:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(2,&c))
    46b8:	82 e0       	ldi	r24, 0x02	; 2
    46ba:	be 01       	movw	r22, r28
    46bc:	6f 5f       	subi	r22, 0xFF	; 255
    46be:	7f 4f       	sbci	r23, 0xFF	; 255
    46c0:	0e 94 11 23 	call	0x4622	; 0x4622 <uartReceiveByte>
    46c4:	88 23       	and	r24, r24
    46c6:	19 f4       	brne	.+6      	; 0x46ce <uart2GetByte+0x20>
    46c8:	2f ef       	ldi	r18, 0xFF	; 255
    46ca:	3f ef       	ldi	r19, 0xFF	; 255
    46cc:	03 c0       	rjmp	.+6      	; 0x46d4 <uart2GetByte+0x26>
		return c;
    46ce:	89 81       	ldd	r24, Y+1	; 0x01
    46d0:	28 2f       	mov	r18, r24
    46d2:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    46d4:	c9 01       	movw	r24, r18
    46d6:	0f 90       	pop	r0
    46d8:	cf 91       	pop	r28
    46da:	df 91       	pop	r29
    46dc:	08 95       	ret

000046de <uart1GetByte>:
	else
		return -1;
}

int uart1GetByte(void)
{
    46de:	df 93       	push	r29
    46e0:	cf 93       	push	r28
    46e2:	0f 92       	push	r0
    46e4:	cd b7       	in	r28, 0x3d	; 61
    46e6:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(1,&c))
    46e8:	81 e0       	ldi	r24, 0x01	; 1
    46ea:	be 01       	movw	r22, r28
    46ec:	6f 5f       	subi	r22, 0xFF	; 255
    46ee:	7f 4f       	sbci	r23, 0xFF	; 255
    46f0:	0e 94 11 23 	call	0x4622	; 0x4622 <uartReceiveByte>
    46f4:	88 23       	and	r24, r24
    46f6:	19 f4       	brne	.+6      	; 0x46fe <uart1GetByte+0x20>
    46f8:	2f ef       	ldi	r18, 0xFF	; 255
    46fa:	3f ef       	ldi	r19, 0xFF	; 255
    46fc:	03 c0       	rjmp	.+6      	; 0x4704 <uart1GetByte+0x26>
		return c;
    46fe:	89 81       	ldd	r24, Y+1	; 0x01
    4700:	28 2f       	mov	r18, r24
    4702:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    4704:	c9 01       	movw	r24, r18
    4706:	0f 90       	pop	r0
    4708:	cf 91       	pop	r28
    470a:	df 91       	pop	r29
    470c:	08 95       	ret

0000470e <uart0GetByte>:
	// send byte on UART3
	uartSendByte(3, data);
}

int uart0GetByte(void)
{
    470e:	df 93       	push	r29
    4710:	cf 93       	push	r28
    4712:	0f 92       	push	r0
    4714:	cd b7       	in	r28, 0x3d	; 61
    4716:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(0,&c))
    4718:	80 e0       	ldi	r24, 0x00	; 0
    471a:	be 01       	movw	r22, r28
    471c:	6f 5f       	subi	r22, 0xFF	; 255
    471e:	7f 4f       	sbci	r23, 0xFF	; 255
    4720:	0e 94 11 23 	call	0x4622	; 0x4622 <uartReceiveByte>
    4724:	88 23       	and	r24, r24
    4726:	19 f4       	brne	.+6      	; 0x472e <uart0GetByte+0x20>
    4728:	2f ef       	ldi	r18, 0xFF	; 255
    472a:	3f ef       	ldi	r19, 0xFF	; 255
    472c:	03 c0       	rjmp	.+6      	; 0x4734 <uart0GetByte+0x26>
		return c;
    472e:	89 81       	ldd	r24, Y+1	; 0x01
    4730:	28 2f       	mov	r18, r24
    4732:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    4734:	c9 01       	movw	r24, r18
    4736:	0f 90       	pop	r0
    4738:	cf 91       	pop	r28
    473a:	df 91       	pop	r29
    473c:	08 95       	ret

0000473e <uartFlushReceiveBuffer>:
}

void uartFlushReceiveBuffer(u08 nUart)
{
	// flush all data from receive buffer
	bufferFlush(&uartRxBuffer[nUart]);
    473e:	90 e0       	ldi	r25, 0x00	; 0
    4740:	e3 e0       	ldi	r30, 0x03	; 3
    4742:	88 0f       	add	r24, r24
    4744:	99 1f       	adc	r25, r25
    4746:	ea 95       	dec	r30
    4748:	e1 f7       	brne	.-8      	; 0x4742 <uartFlushReceiveBuffer+0x4>
    474a:	85 59       	subi	r24, 0x95	; 149
    474c:	9b 4e       	sbci	r25, 0xEB	; 235
    474e:	0e 94 0c 25 	call	0x4a18	; 0x4a18 <bufferFlush>
}
    4752:	08 95       	ret

00004754 <uart3InitBuffers>:

void uart3InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART3 buffers
		bufferInit(&uartRxBuffer[3], (u08*) uart3RxData, UART3_RX_BUFFER_SIZE);
    4754:	83 e8       	ldi	r24, 0x83	; 131
    4756:	94 e1       	ldi	r25, 0x14	; 20
    4758:	60 e5       	ldi	r22, 0x50	; 80
    475a:	71 e1       	ldi	r23, 0x11	; 17
    475c:	40 e8       	ldi	r20, 0x80	; 128
    475e:	50 e0       	ldi	r21, 0x00	; 0
    4760:	0e 94 63 24 	call	0x48c6	; 0x48c6 <bufferInit>
		bufferInit(&uartTxBuffer[3], (u08*) uart3TxData, UART3_TX_BUFFER_SIZE);
    4764:	87 ea       	ldi	r24, 0xA7	; 167
    4766:	94 e1       	ldi	r25, 0x14	; 20
    4768:	60 ed       	ldi	r22, 0xD0	; 208
    476a:	71 e1       	ldi	r23, 0x11	; 17
    476c:	40 e1       	ldi	r20, 0x10	; 16
    476e:	50 e0       	ldi	r21, 0x00	; 0
    4770:	0e 94 63 24 	call	0x48c6	; 0x48c6 <bufferInit>
	#else
		// initialize the UART3 buffers
		bufferInit(&uartRxBuffer[3], (u08*) UART3_RX_BUFFER_ADDR, UART3_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[3], (u08*) UART3_TX_BUFFER_ADDR, UART3_TX_BUFFER_SIZE);
	#endif
}
    4774:	08 95       	ret

00004776 <uart3Init>:
}

void uart3Init(void)
{
	// initialize the buffers
	uart3InitBuffers();
    4776:	0e 94 aa 23 	call	0x4754	; 0x4754 <uart3InitBuffers>
	// initialize user receive handlers
	UartRxFunc[3] = 0;
    477a:	10 92 e7 11 	sts	0x11E7, r1
    477e:	10 92 e6 11 	sts	0x11E6, r1
	// enable RxD/TxD and interrupts
	outb(UCSR3B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    4782:	88 ed       	ldi	r24, 0xD8	; 216
    4784:	80 93 31 01 	sts	0x0131, r24
	// set default baud rate
	uartSetBaudRate(3, UART3_DEFAULT_BAUD_RATE);
    4788:	83 e0       	ldi	r24, 0x03	; 3
    478a:	40 e8       	ldi	r20, 0x80	; 128
    478c:	55 e2       	ldi	r21, 0x25	; 37
    478e:	60 e0       	ldi	r22, 0x00	; 0
    4790:	70 e0       	ldi	r23, 0x00	; 0
    4792:	0e 94 34 20 	call	0x4068	; 0x4068 <uartSetBaudRate>
	// initialize states
	uartReadyTx[3] = TRUE;
    4796:	8f ef       	ldi	r24, 0xFF	; 255
    4798:	80 93 6a 14 	sts	0x146A, r24
	uartBufferedTx[3] = FALSE;
    479c:	10 92 8e 14 	sts	0x148E, r1
	// clear overflow count
	uartRxOverflow[3] = 0;
    47a0:	10 92 b6 14 	sts	0x14B6, r1
    47a4:	10 92 b5 14 	sts	0x14B5, r1
	// enable interrupts
	sei();
    47a8:	78 94       	sei
}
    47aa:	08 95       	ret

000047ac <uart2InitBuffers>:

void uart2InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART2 buffers
		bufferInit(&uartRxBuffer[2], (u08*) uart2RxData, UART2_RX_BUFFER_SIZE);
    47ac:	8b e7       	ldi	r24, 0x7B	; 123
    47ae:	94 e1       	ldi	r25, 0x14	; 20
    47b0:	60 ec       	ldi	r22, 0xC0	; 192
    47b2:	70 e1       	ldi	r23, 0x10	; 16
    47b4:	40 e8       	ldi	r20, 0x80	; 128
    47b6:	50 e0       	ldi	r21, 0x00	; 0
    47b8:	0e 94 63 24 	call	0x48c6	; 0x48c6 <bufferInit>
		bufferInit(&uartTxBuffer[2], (u08*) uart2TxData, UART2_TX_BUFFER_SIZE);
    47bc:	8f e9       	ldi	r24, 0x9F	; 159
    47be:	94 e1       	ldi	r25, 0x14	; 20
    47c0:	60 e4       	ldi	r22, 0x40	; 64
    47c2:	71 e1       	ldi	r23, 0x11	; 17
    47c4:	40 e1       	ldi	r20, 0x10	; 16
    47c6:	50 e0       	ldi	r21, 0x00	; 0
    47c8:	0e 94 63 24 	call	0x48c6	; 0x48c6 <bufferInit>
	#else
		// initialize the UART2 buffers
		bufferInit(&uartRxBuffer[2], (u08*) UART2_RX_BUFFER_ADDR, UART2_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[2], (u08*) UART2_TX_BUFFER_ADDR, UART2_TX_BUFFER_SIZE);
	#endif
}
    47cc:	08 95       	ret

000047ce <uart2Init>:
}

void uart2Init(void)
{
	// initialize the buffers
	uart2InitBuffers();
    47ce:	0e 94 d6 23 	call	0x47ac	; 0x47ac <uart2InitBuffers>
	// initialize user receive handlers
	UartRxFunc[2] = 0;
    47d2:	10 92 e5 11 	sts	0x11E5, r1
    47d6:	10 92 e4 11 	sts	0x11E4, r1
	// enable RxD/TxD and interrupts
	outb(UCSR2B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    47da:	88 ed       	ldi	r24, 0xD8	; 216
    47dc:	80 93 d1 00 	sts	0x00D1, r24
	// set default baud rate
	uartSetBaudRate(2, UART2_DEFAULT_BAUD_RATE);
    47e0:	82 e0       	ldi	r24, 0x02	; 2
    47e2:	40 e8       	ldi	r20, 0x80	; 128
    47e4:	55 e2       	ldi	r21, 0x25	; 37
    47e6:	60 e0       	ldi	r22, 0x00	; 0
    47e8:	70 e0       	ldi	r23, 0x00	; 0
    47ea:	0e 94 34 20 	call	0x4068	; 0x4068 <uartSetBaudRate>
	// initialize states
	uartReadyTx[2] = TRUE;
    47ee:	8f ef       	ldi	r24, 0xFF	; 255
    47f0:	80 93 69 14 	sts	0x1469, r24
	uartBufferedTx[2] = FALSE;
    47f4:	10 92 8d 14 	sts	0x148D, r1
	// clear overflow count
	uartRxOverflow[2] = 0;
    47f8:	10 92 b4 14 	sts	0x14B4, r1
    47fc:	10 92 b3 14 	sts	0x14B3, r1
	// enable interrupts
	sei();
    4800:	78 94       	sei
}
    4802:	08 95       	ret

00004804 <uart1InitBuffers>:

void uart1InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART1 buffers
		bufferInit(&uartRxBuffer[1], (u08*) uart1RxData, UART1_RX_BUFFER_SIZE);
    4804:	83 e7       	ldi	r24, 0x73	; 115
    4806:	94 e1       	ldi	r25, 0x14	; 20
    4808:	60 e3       	ldi	r22, 0x30	; 48
    480a:	70 e1       	ldi	r23, 0x10	; 16
    480c:	40 e8       	ldi	r20, 0x80	; 128
    480e:	50 e0       	ldi	r21, 0x00	; 0
    4810:	0e 94 63 24 	call	0x48c6	; 0x48c6 <bufferInit>
		bufferInit(&uartTxBuffer[1], (u08*) uart1TxData, UART1_TX_BUFFER_SIZE);
    4814:	87 e9       	ldi	r24, 0x97	; 151
    4816:	94 e1       	ldi	r25, 0x14	; 20
    4818:	60 eb       	ldi	r22, 0xB0	; 176
    481a:	70 e1       	ldi	r23, 0x10	; 16
    481c:	40 e1       	ldi	r20, 0x10	; 16
    481e:	50 e0       	ldi	r21, 0x00	; 0
    4820:	0e 94 63 24 	call	0x48c6	; 0x48c6 <bufferInit>
	#else
		// initialize the UART1 buffers
		bufferInit(&uartRxBuffer[1], (u08*) UART1_RX_BUFFER_ADDR, UART1_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[1], (u08*) UART1_TX_BUFFER_ADDR, UART1_TX_BUFFER_SIZE);
	#endif
}
    4824:	08 95       	ret

00004826 <uart1Init>:
}

void uart1Init(void)
{
	// initialize the buffers
	uart1InitBuffers();
    4826:	0e 94 02 24 	call	0x4804	; 0x4804 <uart1InitBuffers>
	// initialize user receive handlers
	UartRxFunc[1] = 0;
    482a:	10 92 e3 11 	sts	0x11E3, r1
    482e:	10 92 e2 11 	sts	0x11E2, r1
	// enable RxD/TxD and interrupts
	outb(UCSR1B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    4832:	88 ed       	ldi	r24, 0xD8	; 216
    4834:	80 93 c9 00 	sts	0x00C9, r24
	// set default baud rate
	uartSetBaudRate(1, UART1_DEFAULT_BAUD_RATE);
    4838:	81 e0       	ldi	r24, 0x01	; 1
    483a:	40 e8       	ldi	r20, 0x80	; 128
    483c:	55 e2       	ldi	r21, 0x25	; 37
    483e:	60 e0       	ldi	r22, 0x00	; 0
    4840:	70 e0       	ldi	r23, 0x00	; 0
    4842:	0e 94 34 20 	call	0x4068	; 0x4068 <uartSetBaudRate>
	// initialize states
	uartReadyTx[1] = TRUE;
    4846:	8f ef       	ldi	r24, 0xFF	; 255
    4848:	80 93 68 14 	sts	0x1468, r24
	uartBufferedTx[1] = FALSE;
    484c:	10 92 8c 14 	sts	0x148C, r1
	// clear overflow count
	uartRxOverflow[1] = 0;
    4850:	10 92 b2 14 	sts	0x14B2, r1
    4854:	10 92 b1 14 	sts	0x14B1, r1
	// enable interrupts
	sei();
    4858:	78 94       	sei
}
    485a:	08 95       	ret

0000485c <uart0InitBuffers>:

void uart0InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART0 buffers
		bufferInit(&uartRxBuffer[0], (u08*) uart0RxData, UART0_RX_BUFFER_SIZE);
    485c:	8b e6       	ldi	r24, 0x6B	; 107
    485e:	94 e1       	ldi	r25, 0x14	; 20
    4860:	60 ea       	ldi	r22, 0xA0	; 160
    4862:	7f e0       	ldi	r23, 0x0F	; 15
    4864:	40 e8       	ldi	r20, 0x80	; 128
    4866:	50 e0       	ldi	r21, 0x00	; 0
    4868:	0e 94 63 24 	call	0x48c6	; 0x48c6 <bufferInit>
		bufferInit(&uartTxBuffer[0], (u08*) uart0TxData, UART0_TX_BUFFER_SIZE);
    486c:	8f e8       	ldi	r24, 0x8F	; 143
    486e:	94 e1       	ldi	r25, 0x14	; 20
    4870:	60 e2       	ldi	r22, 0x20	; 32
    4872:	70 e1       	ldi	r23, 0x10	; 16
    4874:	40 e1       	ldi	r20, 0x10	; 16
    4876:	50 e0       	ldi	r21, 0x00	; 0
    4878:	0e 94 63 24 	call	0x48c6	; 0x48c6 <bufferInit>
	#else
		// initialize the UART0 buffers
		bufferInit(&uartRxBuffer[0], (u08*) UART0_RX_BUFFER_ADDR, UART0_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[0], (u08*) UART0_TX_BUFFER_ADDR, UART0_TX_BUFFER_SIZE);
	#endif
}
    487c:	08 95       	ret

0000487e <uart0Init>:
}

void uart0Init(void)
{
	// initialize the buffers
	uart0InitBuffers();
    487e:	0e 94 2e 24 	call	0x485c	; 0x485c <uart0InitBuffers>
	// initialize user receive handlers
	UartRxFunc[0] = 0;
    4882:	10 92 e1 11 	sts	0x11E1, r1
    4886:	10 92 e0 11 	sts	0x11E0, r1
	// enable RxD/TxD and interrupts
	outb(UCSR0B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    488a:	88 ed       	ldi	r24, 0xD8	; 216
    488c:	80 93 c1 00 	sts	0x00C1, r24
	// set default baud rate
	uartSetBaudRate(0, UART0_DEFAULT_BAUD_RATE); 
    4890:	80 e0       	ldi	r24, 0x00	; 0
    4892:	40 e8       	ldi	r20, 0x80	; 128
    4894:	55 e2       	ldi	r21, 0x25	; 37
    4896:	60 e0       	ldi	r22, 0x00	; 0
    4898:	70 e0       	ldi	r23, 0x00	; 0
    489a:	0e 94 34 20 	call	0x4068	; 0x4068 <uartSetBaudRate>
	// initialize states
	uartReadyTx[0] = TRUE;
    489e:	8f ef       	ldi	r24, 0xFF	; 255
    48a0:	80 93 67 14 	sts	0x1467, r24
	uartBufferedTx[0] = FALSE;
    48a4:	10 92 8b 14 	sts	0x148B, r1
	// clear overflow count
	uartRxOverflow[0] = 0;
    48a8:	10 92 b0 14 	sts	0x14B0, r1
    48ac:	10 92 af 14 	sts	0x14AF, r1
	// enable interrupts
	sei();
    48b0:	78 94       	sei
}
    48b2:	08 95       	ret

000048b4 <uartInit>:
volatile static voidFuncPtru08 UartRxFunc[4];

void uartInit(void)
{
	// initialize all uarts
	uart0Init();
    48b4:	0e 94 3f 24 	call	0x487e	; 0x487e <uart0Init>
	uart1Init();
    48b8:	0e 94 13 24 	call	0x4826	; 0x4826 <uart1Init>
	uart2Init();
    48bc:	0e 94 e7 23 	call	0x47ce	; 0x47ce <uart2Init>
	uart3Init();
    48c0:	0e 94 bb 23 	call	0x4776	; 0x4776 <uart3Init>
}
    48c4:	08 95       	ret

000048c6 <bufferInit>:
// global variables

// initialization

void bufferInit(cBuffer* buffer, unsigned char *start, unsigned short size)
{
    48c6:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    48c8:	8f b7       	in	r24, 0x3f	; 63
    48ca:	f8 94       	cli
	// set start pointer of the buffer
	buffer->dataptr = start;
    48cc:	71 83       	std	Z+1, r23	; 0x01
    48ce:	60 83       	st	Z, r22
	buffer->size = size;
    48d0:	53 83       	std	Z+3, r21	; 0x03
    48d2:	42 83       	std	Z+2, r20	; 0x02
	// initialize index and length
	buffer->dataindex = 0;
    48d4:	17 82       	std	Z+7, r1	; 0x07
    48d6:	16 82       	std	Z+6, r1	; 0x06
	buffer->datalength = 0;
    48d8:	15 82       	std	Z+5, r1	; 0x05
    48da:	14 82       	std	Z+4, r1	; 0x04
	// end critical section
	CRITICAL_SECTION_END;
    48dc:	8f bf       	out	0x3f, r24	; 63
}
    48de:	08 95       	ret

000048e0 <bufferGetFromFront>:

// access routines
unsigned char  bufferGetFromFront(cBuffer* buffer)
{
    48e0:	dc 01       	movw	r26, r24
	unsigned char data = 0;
	// begin critical section
	CRITICAL_SECTION_START;
    48e2:	4f b7       	in	r20, 0x3f	; 63
    48e4:	f8 94       	cli
	// check to see if there's data in the buffer
	if(buffer->datalength)
    48e6:	14 96       	adiw	r26, 0x04	; 4
    48e8:	8d 91       	ld	r24, X+
    48ea:	9c 91       	ld	r25, X
    48ec:	15 97       	sbiw	r26, 0x05	; 5
    48ee:	89 2b       	or	r24, r25
    48f0:	11 f4       	brne	.+4      	; 0x48f6 <bufferGetFromFront+0x16>
    48f2:	e0 e0       	ldi	r30, 0x00	; 0
    48f4:	25 c0       	rjmp	.+74     	; 0x4940 <bufferGetFromFront+0x60>
	{
		// get the first character from buffer
		data = buffer->dataptr[buffer->dataindex];
    48f6:	16 96       	adiw	r26, 0x06	; 6
    48f8:	8d 91       	ld	r24, X+
    48fa:	9c 91       	ld	r25, X
    48fc:	17 97       	sbiw	r26, 0x07	; 7
    48fe:	ed 91       	ld	r30, X+
    4900:	fc 91       	ld	r31, X
    4902:	11 97       	sbiw	r26, 0x01	; 1
    4904:	e8 0f       	add	r30, r24
    4906:	f9 1f       	adc	r31, r25
    4908:	e0 81       	ld	r30, Z
		// move index down and decrement length
		buffer->dataindex++;
    490a:	01 96       	adiw	r24, 0x01	; 1
    490c:	17 96       	adiw	r26, 0x07	; 7
    490e:	9c 93       	st	X, r25
    4910:	8e 93       	st	-X, r24
    4912:	16 97       	sbiw	r26, 0x06	; 6
		if(buffer->dataindex >= buffer->size)
    4914:	12 96       	adiw	r26, 0x02	; 2
    4916:	2d 91       	ld	r18, X+
    4918:	3c 91       	ld	r19, X
    491a:	13 97       	sbiw	r26, 0x03	; 3
    491c:	82 17       	cp	r24, r18
    491e:	93 07       	cpc	r25, r19
    4920:	30 f0       	brcs	.+12     	; 0x492e <bufferGetFromFront+0x4e>
		{
			buffer->dataindex -= buffer->size;
    4922:	82 1b       	sub	r24, r18
    4924:	93 0b       	sbc	r25, r19
    4926:	17 96       	adiw	r26, 0x07	; 7
    4928:	9c 93       	st	X, r25
    492a:	8e 93       	st	-X, r24
    492c:	16 97       	sbiw	r26, 0x06	; 6
		}
		buffer->datalength--;
    492e:	14 96       	adiw	r26, 0x04	; 4
    4930:	8d 91       	ld	r24, X+
    4932:	9c 91       	ld	r25, X
    4934:	15 97       	sbiw	r26, 0x05	; 5
    4936:	01 97       	sbiw	r24, 0x01	; 1
    4938:	15 96       	adiw	r26, 0x05	; 5
    493a:	9c 93       	st	X, r25
    493c:	8e 93       	st	-X, r24
    493e:	14 97       	sbiw	r26, 0x04	; 4
	}
	// end critical section
	CRITICAL_SECTION_END;
    4940:	4f bf       	out	0x3f, r20	; 63
	// return
	return data;
}
    4942:	8e 2f       	mov	r24, r30
    4944:	08 95       	ret

00004946 <bufferDumpFromFront>:

void bufferDumpFromFront(cBuffer* buffer, unsigned short numbytes)
{
    4946:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    4948:	4f b7       	in	r20, 0x3f	; 63
    494a:	f8 94       	cli
	// dump numbytes from the front of the buffer
	// are we dumping less than the entire buffer?
	if(numbytes < buffer->datalength)
    494c:	84 81       	ldd	r24, Z+4	; 0x04
    494e:	95 81       	ldd	r25, Z+5	; 0x05
    4950:	68 17       	cp	r22, r24
    4952:	79 07       	cpc	r23, r25
    4954:	b0 f4       	brcc	.+44     	; 0x4982 <bufferDumpFromFront+0x3c>
	{
		// move index down by numbytes and decrement length by numbytes
		buffer->dataindex += numbytes;
    4956:	86 81       	ldd	r24, Z+6	; 0x06
    4958:	97 81       	ldd	r25, Z+7	; 0x07
    495a:	86 0f       	add	r24, r22
    495c:	97 1f       	adc	r25, r23
    495e:	97 83       	std	Z+7, r25	; 0x07
    4960:	86 83       	std	Z+6, r24	; 0x06
		if(buffer->dataindex >= buffer->size)
    4962:	22 81       	ldd	r18, Z+2	; 0x02
    4964:	33 81       	ldd	r19, Z+3	; 0x03
    4966:	82 17       	cp	r24, r18
    4968:	93 07       	cpc	r25, r19
    496a:	20 f0       	brcs	.+8      	; 0x4974 <bufferDumpFromFront+0x2e>
		{
			buffer->dataindex -= buffer->size;
    496c:	82 1b       	sub	r24, r18
    496e:	93 0b       	sbc	r25, r19
    4970:	97 83       	std	Z+7, r25	; 0x07
    4972:	86 83       	std	Z+6, r24	; 0x06
		}
		buffer->datalength -= numbytes;
    4974:	84 81       	ldd	r24, Z+4	; 0x04
    4976:	95 81       	ldd	r25, Z+5	; 0x05
    4978:	86 1b       	sub	r24, r22
    497a:	97 0b       	sbc	r25, r23
    497c:	95 83       	std	Z+5, r25	; 0x05
    497e:	84 83       	std	Z+4, r24	; 0x04
    4980:	02 c0       	rjmp	.+4      	; 0x4986 <bufferDumpFromFront+0x40>
	}
	else
	{
		// flush the whole buffer
		buffer->datalength = 0;
    4982:	15 82       	std	Z+5, r1	; 0x05
    4984:	14 82       	std	Z+4, r1	; 0x04
	}
	// end critical section
	CRITICAL_SECTION_END;
    4986:	4f bf       	out	0x3f, r20	; 63
}
    4988:	08 95       	ret

0000498a <bufferGetAtIndex>:

unsigned char bufferGetAtIndex(cBuffer* buffer, unsigned short index)
{
    498a:	fc 01       	movw	r30, r24
    498c:	cb 01       	movw	r24, r22
	// begin critical section
	CRITICAL_SECTION_START;
    498e:	2f b7       	in	r18, 0x3f	; 63
    4990:	f8 94       	cli
	// return character at index in buffer
	unsigned char data = buffer->dataptr[(buffer->dataindex+index)%(buffer->size)];
	// end critical section
	CRITICAL_SECTION_END;
    4992:	2f bf       	out	0x3f, r18	; 63
    4994:	26 81       	ldd	r18, Z+6	; 0x06
    4996:	37 81       	ldd	r19, Z+7	; 0x07
    4998:	62 81       	ldd	r22, Z+2	; 0x02
    499a:	73 81       	ldd	r23, Z+3	; 0x03
    499c:	82 0f       	add	r24, r18
    499e:	93 1f       	adc	r25, r19
    49a0:	0e 94 1b 2e 	call	0x5c36	; 0x5c36 <__udivmodhi4>
    49a4:	01 90       	ld	r0, Z+
    49a6:	f0 81       	ld	r31, Z
    49a8:	e0 2d       	mov	r30, r0
    49aa:	e8 0f       	add	r30, r24
    49ac:	f9 1f       	adc	r31, r25
	return data;
}
    49ae:	80 81       	ld	r24, Z
    49b0:	08 95       	ret

000049b2 <bufferAddToEnd>:

unsigned char bufferAddToEnd(cBuffer* buffer, unsigned char data)
{
    49b2:	1f 93       	push	r17
    49b4:	cf 93       	push	r28
    49b6:	df 93       	push	r29
    49b8:	ec 01       	movw	r28, r24
    49ba:	16 2f       	mov	r17, r22
	// begin critical section
	CRITICAL_SECTION_START;
    49bc:	4f b7       	in	r20, 0x3f	; 63
    49be:	f8 94       	cli
	// make sure the buffer has room
	if(buffer->datalength < buffer->size)
    49c0:	2c 81       	ldd	r18, Y+4	; 0x04
    49c2:	3d 81       	ldd	r19, Y+5	; 0x05
    49c4:	6a 81       	ldd	r22, Y+2	; 0x02
    49c6:	7b 81       	ldd	r23, Y+3	; 0x03
    49c8:	26 17       	cp	r18, r22
    49ca:	37 07       	cpc	r19, r23
    49cc:	98 f4       	brcc	.+38     	; 0x49f4 <bufferAddToEnd+0x42>
	{
		// save data byte at end of buffer
		buffer->dataptr[(buffer->dataindex + buffer->datalength) % buffer->size] = data;
    49ce:	8e 81       	ldd	r24, Y+6	; 0x06
    49d0:	9f 81       	ldd	r25, Y+7	; 0x07
    49d2:	82 0f       	add	r24, r18
    49d4:	93 1f       	adc	r25, r19
    49d6:	0e 94 1b 2e 	call	0x5c36	; 0x5c36 <__udivmodhi4>
    49da:	e8 81       	ld	r30, Y
    49dc:	f9 81       	ldd	r31, Y+1	; 0x01
    49de:	e8 0f       	add	r30, r24
    49e0:	f9 1f       	adc	r31, r25
    49e2:	10 83       	st	Z, r17
		// increment the length
		buffer->datalength++;
    49e4:	8c 81       	ldd	r24, Y+4	; 0x04
    49e6:	9d 81       	ldd	r25, Y+5	; 0x05
    49e8:	01 96       	adiw	r24, 0x01	; 1
    49ea:	9d 83       	std	Y+5, r25	; 0x05
    49ec:	8c 83       	std	Y+4, r24	; 0x04
		// end critical section
		CRITICAL_SECTION_END;
    49ee:	4f bf       	out	0x3f, r20	; 63
    49f0:	8f ef       	ldi	r24, 0xFF	; 255
    49f2:	02 c0       	rjmp	.+4      	; 0x49f8 <bufferAddToEnd+0x46>
		// return success
		return -1;
	}
	// end critical section
	CRITICAL_SECTION_END;
    49f4:	4f bf       	out	0x3f, r20	; 63
    49f6:	80 e0       	ldi	r24, 0x00	; 0
	// return failure
	return 0;
}
    49f8:	df 91       	pop	r29
    49fa:	cf 91       	pop	r28
    49fc:	1f 91       	pop	r17
    49fe:	08 95       	ret

00004a00 <bufferIsNotFull>:

unsigned short bufferIsNotFull(cBuffer* buffer)
{
    4a00:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    4a02:	8f b7       	in	r24, 0x3f	; 63
    4a04:	f8 94       	cli
	// check to see if the buffer has room
	// return true if there is room
	unsigned short bytesleft = (buffer->size - buffer->datalength);
	// end critical section
	CRITICAL_SECTION_END;
    4a06:	8f bf       	out	0x3f, r24	; 63
    4a08:	22 81       	ldd	r18, Z+2	; 0x02
    4a0a:	33 81       	ldd	r19, Z+3	; 0x03
    4a0c:	84 81       	ldd	r24, Z+4	; 0x04
    4a0e:	95 81       	ldd	r25, Z+5	; 0x05
    4a10:	28 1b       	sub	r18, r24
    4a12:	39 0b       	sbc	r19, r25
	return bytesleft;
}
    4a14:	c9 01       	movw	r24, r18
    4a16:	08 95       	ret

00004a18 <bufferFlush>:

void bufferFlush(cBuffer* buffer)
{
    4a18:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    4a1a:	8f b7       	in	r24, 0x3f	; 63
    4a1c:	f8 94       	cli
	// flush contents of the buffer
	buffer->datalength = 0;
    4a1e:	15 82       	std	Z+5, r1	; 0x05
    4a20:	14 82       	std	Z+4, r1	; 0x04
	// end critical section
	CRITICAL_SECTION_END;
    4a22:	8f bf       	out	0x3f, r24	; 63
}
    4a24:	08 95       	ret

00004a26 <a2dInit>:
// functions

// initialize a2d converter
void a2dInit(void)
{
	sbi(ADCSR, ADEN);				// enable ADC (turn on ADC power)
    4a26:	aa e7       	ldi	r26, 0x7A	; 122
    4a28:	b0 e0       	ldi	r27, 0x00	; 0
    4a2a:	8c 91       	ld	r24, X
    4a2c:	80 68       	ori	r24, 0x80	; 128
    4a2e:	8c 93       	st	X, r24
	cbi(ADCSR, ADFR);				// default to single sample convert mode
    4a30:	8c 91       	ld	r24, X
    4a32:	8f 7d       	andi	r24, 0xDF	; 223
    4a34:	8c 93       	st	X, r24
}

// configure A2D converter clock division (prescaling)
void a2dSetPrescaler(unsigned char prescale)
{
	outb(ADCSR, ((inb(ADCSR) & ~ADC_PRESCALE_MASK) | prescale));
    4a36:	8c 91       	ld	r24, X
    4a38:	88 7f       	andi	r24, 0xF8	; 248
    4a3a:	86 60       	ori	r24, 0x06	; 6
    4a3c:	8c 93       	st	X, r24
}

// configure A2D converter voltage reference
void a2dSetReference(unsigned char ref)
{
	outb(ADMUX, ((inb(ADMUX) & ~ADC_REFERENCE_MASK) | (ref<<6)));
    4a3e:	ec e7       	ldi	r30, 0x7C	; 124
    4a40:	f0 e0       	ldi	r31, 0x00	; 0
    4a42:	80 81       	ld	r24, Z
    4a44:	8f 73       	andi	r24, 0x3F	; 63
    4a46:	80 64       	ori	r24, 0x40	; 64
    4a48:	80 83       	st	Z, r24
{
	sbi(ADCSR, ADEN);				// enable ADC (turn on ADC power)
	cbi(ADCSR, ADFR);				// default to single sample convert mode
	a2dSetPrescaler(ADC_PRESCALE);	// set default prescaler
	a2dSetReference(ADC_REFERENCE);	// set default reference
	cbi(ADMUX, ADLAR);				// set to right-adjusted result
    4a4a:	80 81       	ld	r24, Z
    4a4c:	8f 7d       	andi	r24, 0xDF	; 223
    4a4e:	80 83       	st	Z, r24

	sbi(ADCSR, ADIE);				// enable ADC interrupts
    4a50:	8c 91       	ld	r24, X
    4a52:	88 60       	ori	r24, 0x08	; 8
    4a54:	8c 93       	st	X, r24

	a2dCompleteFlag = FALSE;		// clear conversion complete flag
    4a56:	10 92 b7 14 	sts	0x14B7, r1
	sei();							// turn on interrupts (if not already on)
    4a5a:	78 94       	sei
}
    4a5c:	08 95       	ret

00004a5e <a2dOff>:

// turn off a2d converter
void a2dOff(void)
{
	cbi(ADCSR, ADIE);				// disable ADC interrupts
    4a5e:	ea e7       	ldi	r30, 0x7A	; 122
    4a60:	f0 e0       	ldi	r31, 0x00	; 0
    4a62:	80 81       	ld	r24, Z
    4a64:	87 7f       	andi	r24, 0xF7	; 247
    4a66:	80 83       	st	Z, r24
	cbi(ADCSR, ADEN);				// disable ADC (turn off ADC power)
    4a68:	80 81       	ld	r24, Z
    4a6a:	8f 77       	andi	r24, 0x7F	; 127
    4a6c:	80 83       	st	Z, r24
}
    4a6e:	08 95       	ret

00004a70 <a2dSetPrescaler>:

// configure A2D converter clock division (prescaling)
void a2dSetPrescaler(unsigned char prescale)
{
	outb(ADCSR, ((inb(ADCSR) & ~ADC_PRESCALE_MASK) | prescale));
    4a70:	ea e7       	ldi	r30, 0x7A	; 122
    4a72:	f0 e0       	ldi	r31, 0x00	; 0
    4a74:	90 81       	ld	r25, Z
    4a76:	98 7f       	andi	r25, 0xF8	; 248
    4a78:	98 2b       	or	r25, r24
    4a7a:	90 83       	st	Z, r25
}
    4a7c:	08 95       	ret

00004a7e <a2dSetReference>:

// configure A2D converter voltage reference
void a2dSetReference(unsigned char ref)
{
	outb(ADMUX, ((inb(ADMUX) & ~ADC_REFERENCE_MASK) | (ref<<6)));
    4a7e:	ec e7       	ldi	r30, 0x7C	; 124
    4a80:	f0 e0       	ldi	r31, 0x00	; 0
    4a82:	90 81       	ld	r25, Z
    4a84:	82 95       	swap	r24
    4a86:	88 0f       	add	r24, r24
    4a88:	88 0f       	add	r24, r24
    4a8a:	80 7c       	andi	r24, 0xC0	; 192
    4a8c:	9f 73       	andi	r25, 0x3F	; 63
    4a8e:	98 2b       	or	r25, r24
    4a90:	90 83       	st	Z, r25
}
    4a92:	08 95       	ret

00004a94 <a2dSetChannel>:

// sets the a2d input channel
void a2dSetChannel(unsigned char ch)
{
	outb(ADMUX, (inb(ADMUX) & ~ADC_MUX_MASK) | (ch & ADC_MUX_MASK));	// set channel
    4a94:	ec e7       	ldi	r30, 0x7C	; 124
    4a96:	f0 e0       	ldi	r31, 0x00	; 0
    4a98:	90 81       	ld	r25, Z
    4a9a:	8f 71       	andi	r24, 0x1F	; 31
    4a9c:	90 7e       	andi	r25, 0xE0	; 224
    4a9e:	89 2b       	or	r24, r25
    4aa0:	80 83       	st	Z, r24
}
    4aa2:	08 95       	ret

00004aa4 <a2dStartConvert>:

// start a conversion on the current a2d input channel
void a2dStartConvert(void)
{
	sbi(ADCSR, ADIF);	// clear hardware "conversion complete" flag 
    4aa4:	ea e7       	ldi	r30, 0x7A	; 122
    4aa6:	f0 e0       	ldi	r31, 0x00	; 0
    4aa8:	80 81       	ld	r24, Z
    4aaa:	80 61       	ori	r24, 0x10	; 16
    4aac:	80 83       	st	Z, r24
	sbi(ADCSR, ADSC);	// start conversion
    4aae:	80 81       	ld	r24, Z
    4ab0:	80 64       	ori	r24, 0x40	; 64
    4ab2:	80 83       	st	Z, r24
}
    4ab4:	08 95       	ret

00004ab6 <a2dIsComplete>:

// return TRUE if conversion is complete
u08 a2dIsComplete(void)
{
	return bit_is_set(ADCSR, ADSC);
    4ab6:	80 91 7a 00 	lds	r24, 0x007A
}
    4aba:	80 74       	andi	r24, 0x40	; 64
    4abc:	08 95       	ret

00004abe <a2dConvert10bit>:

// Perform a 10-bit conversion
// starts conversion, waits until conversion is done, and returns result
unsigned short a2dConvert10bit(unsigned char ch)
{
    4abe:	98 2f       	mov	r25, r24
	a2dCompleteFlag = FALSE;				// clear conversion complete flag
    4ac0:	10 92 b7 14 	sts	0x14B7, r1

if (ch >= 8)
    4ac4:	88 30       	cpi	r24, 0x08	; 8
    4ac6:	20 f0       	brcs	.+8      	; 0x4ad0 <a2dConvert10bit+0x12>
    ADCSRB |= _BV(MUX5);
    4ac8:	80 91 7b 00 	lds	r24, 0x007B
    4acc:	88 60       	ori	r24, 0x08	; 8
    4ace:	03 c0       	rjmp	.+6      	; 0x4ad6 <a2dConvert10bit+0x18>
else
    ADCSRB &= ~_BV(MUX5);
    4ad0:	80 91 7b 00 	lds	r24, 0x007B
    4ad4:	87 7f       	andi	r24, 0xF7	; 247
    4ad6:	80 93 7b 00 	sts	0x007B, r24

   outb(ADMUX, (inb(ADMUX) & ~7) | (ch & 7));   // set channel
    4ada:	80 91 7c 00 	lds	r24, 0x007C
    4ade:	97 70       	andi	r25, 0x07	; 7
    4ae0:	88 7f       	andi	r24, 0xF8	; 248
    4ae2:	89 2b       	or	r24, r25
    4ae4:	80 93 7c 00 	sts	0x007C, r24

	//outb(ADMUX, (inb(ADMUX) & ~ADC_MUX_MASK) | (ch & ADC_MUX_MASK));	// set channel
	sbi(ADCSR, ADIF);						// clear hardware "conversion complete" flag 
    4ae8:	80 91 7a 00 	lds	r24, 0x007A
    4aec:	80 61       	ori	r24, 0x10	; 16
    4aee:	80 93 7a 00 	sts	0x007A, r24
	sbi(ADCSR, ADSC);						// start conversion
    4af2:	80 91 7a 00 	lds	r24, 0x007A
    4af6:	80 64       	ori	r24, 0x40	; 64
    4af8:	80 93 7a 00 	sts	0x007A, r24
	//while(!a2dCompleteFlag);				// wait until conversion complete
	//while( bit_is_clear(ADCSR, ADIF) );		// wait until conversion complete
	while( bit_is_set(ADCSR, ADSC) );		// wait until conversion complete
    4afc:	80 91 7a 00 	lds	r24, 0x007A
    4b00:	86 fd       	sbrc	r24, 6
    4b02:	fc cf       	rjmp	.-8      	; 0x4afc <a2dConvert10bit+0x3e>

	// CAUTION: MUST READ ADCL BEFORE ADCH!!!
	//return (inb(ADCL) | (inb(ADCH)<<8));	// read ADC (full 10 bits) //old version
	return ADC;//new version code
    4b04:	20 91 78 00 	lds	r18, 0x0078
    4b08:	30 91 79 00 	lds	r19, 0x0079
}
    4b0c:	c9 01       	movw	r24, r18
    4b0e:	08 95       	ret

00004b10 <a2dConvert8bit>:
// Perform a 8-bit conversion.
// starts conversion, waits until conversion is done, and returns result
unsigned char a2dConvert8bit(unsigned char ch)
{
	// do 10-bit conversion and return highest 8 bits
	return a2dConvert10bit(ch)>>2;			// return ADC MSB byte
    4b10:	0e 94 5f 25 	call	0x4abe	; 0x4abe <a2dConvert10bit>
    4b14:	96 95       	lsr	r25
    4b16:	87 95       	ror	r24
    4b18:	96 95       	lsr	r25
    4b1a:	87 95       	ror	r24
}
    4b1c:	08 95       	ret

00004b1e <__vector_29>:

//! Interrupt handler for ADC complete interrupt.
SIGNAL(SIG_ADC)
{
    4b1e:	1f 92       	push	r1
    4b20:	0f 92       	push	r0
    4b22:	0f b6       	in	r0, 0x3f	; 63
    4b24:	0f 92       	push	r0
    4b26:	11 24       	eor	r1, r1
    4b28:	8f 93       	push	r24
	// set the a2d conversion flag to indicate "complete"
	a2dCompleteFlag = TRUE;
    4b2a:	8f ef       	ldi	r24, 0xFF	; 255
    4b2c:	80 93 b7 14 	sts	0x14B7, r24
}
    4b30:	8f 91       	pop	r24
    4b32:	0f 90       	pop	r0
    4b34:	0f be       	out	0x3f, r0	; 63
    4b36:	0f 90       	pop	r0
    4b38:	1f 90       	pop	r1
    4b3a:	18 95       	reti

00004b3c <rprintfInit>:
// *** rprintf initialization ***
// you must call this function once and supply the character output
// routine before using other functions in this library
void rprintfInit(void (*putchar_func)(unsigned char c))
{
	rputchar = putchar_func;
    4b3c:	90 93 e9 11 	sts	0x11E9, r25
    4b40:	80 93 e8 11 	sts	0x11E8, r24
}
    4b44:	08 95       	ret

00004b46 <rprintfChar>:

// *** rprintfChar ***
// send a character/byte to the current output device
void rprintfChar(unsigned char c)
{
    4b46:	1f 93       	push	r17
    4b48:	18 2f       	mov	r17, r24
	// do LF -> CR/LF translation
	if(c == '\n')
    4b4a:	8a 30       	cpi	r24, 0x0A	; 10
    4b4c:	31 f4       	brne	.+12     	; 0x4b5a <rprintfChar+0x14>
		rputchar('\r');
    4b4e:	e0 91 e8 11 	lds	r30, 0x11E8
    4b52:	f0 91 e9 11 	lds	r31, 0x11E9
    4b56:	8d e0       	ldi	r24, 0x0D	; 13
    4b58:	09 95       	icall
	// send character
	rputchar(c);
    4b5a:	e0 91 e8 11 	lds	r30, 0x11E8
    4b5e:	f0 91 e9 11 	lds	r31, 0x11E9
    4b62:	81 2f       	mov	r24, r17
    4b64:	09 95       	icall
}
    4b66:	1f 91       	pop	r17
    4b68:	08 95       	ret

00004b6a <rprintfStr>:

// *** rprintfStr ***
// prints a null-terminated string stored in RAM
void rprintfStr(char str[])
{
    4b6a:	cf 93       	push	r28
    4b6c:	df 93       	push	r29
    4b6e:	ec 01       	movw	r28, r24
	// send a string stored in RAM
	// check to make sure we have a good pointer
	if (!str) return;
    4b70:	00 97       	sbiw	r24, 0x00	; 0
    4b72:	21 f4       	brne	.+8      	; 0x4b7c <rprintfStr+0x12>
    4b74:	06 c0       	rjmp	.+12     	; 0x4b82 <rprintfStr+0x18>

	// print the string until a null-terminator
	while (*str)
		rprintfChar(*str++);
    4b76:	21 96       	adiw	r28, 0x01	; 1
    4b78:	0e 94 a3 25 	call	0x4b46	; 0x4b46 <rprintfChar>
	// send a string stored in RAM
	// check to make sure we have a good pointer
	if (!str) return;

	// print the string until a null-terminator
	while (*str)
    4b7c:	88 81       	ld	r24, Y
    4b7e:	88 23       	and	r24, r24
    4b80:	d1 f7       	brne	.-12     	; 0x4b76 <rprintfStr+0xc>
		rprintfChar(*str++);
}
    4b82:	df 91       	pop	r29
    4b84:	cf 91       	pop	r28
    4b86:	08 95       	ret

00004b88 <rprintfStrLen>:
// *** rprintfStrLen ***
// prints a section of a string stored in RAM
// begins printing at position indicated by <start>
// prints number of characters indicated by <len>
void rprintfStrLen(char str[], unsigned int start, unsigned int len)
{
    4b88:	ef 92       	push	r14
    4b8a:	ff 92       	push	r15
    4b8c:	0f 93       	push	r16
    4b8e:	1f 93       	push	r17
    4b90:	cf 93       	push	r28
    4b92:	df 93       	push	r29
    4b94:	8c 01       	movw	r16, r24
    4b96:	7a 01       	movw	r14, r20
	register int i=0;

	// check to make sure we have a good pointer
	if (!str) return;
    4b98:	00 97       	sbiw	r24, 0x00	; 0
    4b9a:	e9 f0       	breq	.+58     	; 0x4bd6 <rprintfStrLen+0x4e>
    4b9c:	20 e0       	ldi	r18, 0x00	; 0
    4b9e:	30 e0       	ldi	r19, 0x00	; 0
	// spin through characters up to requested start
	// keep going as long as there's no null
	while((i++<start) && (*str++));
    4ba0:	26 17       	cp	r18, r22
    4ba2:	37 07       	cpc	r19, r23
    4ba4:	38 f4       	brcc	.+14     	; 0x4bb4 <rprintfStrLen+0x2c>
    4ba6:	f8 01       	movw	r30, r16
    4ba8:	81 91       	ld	r24, Z+
    4baa:	8f 01       	movw	r16, r30
    4bac:	2f 5f       	subi	r18, 0xFF	; 255
    4bae:	3f 4f       	sbci	r19, 0xFF	; 255
    4bb0:	88 23       	and	r24, r24
    4bb2:	b1 f7       	brne	.-20     	; 0x4ba0 <rprintfStrLen+0x18>
    4bb4:	c0 e0       	ldi	r28, 0x00	; 0
    4bb6:	d0 e0       	ldi	r29, 0x00	; 0
    4bb8:	0b c0       	rjmp	.+22     	; 0x4bd0 <rprintfStrLen+0x48>
	// then print exactly len characters
	for(i=0; i<len; i++)
	{
		// print data out of the string as long as we haven't reached a null yet
		// at the null, start printing spaces
		if(*str)
    4bba:	f8 01       	movw	r30, r16
    4bbc:	80 81       	ld	r24, Z
    4bbe:	88 23       	and	r24, r24
    4bc0:	19 f0       	breq	.+6      	; 0x4bc8 <rprintfStrLen+0x40>
			rprintfChar(*str++);
    4bc2:	0f 5f       	subi	r16, 0xFF	; 255
    4bc4:	1f 4f       	sbci	r17, 0xFF	; 255
    4bc6:	01 c0       	rjmp	.+2      	; 0x4bca <rprintfStrLen+0x42>
		else
			rprintfChar(' ');
    4bc8:	80 e2       	ldi	r24, 0x20	; 32
    4bca:	0e 94 a3 25 	call	0x4b46	; 0x4b46 <rprintfChar>
//		// keep steping through string as long as there's no null
//		if(*str) str++;
//	}

	// then print exactly len characters
	for(i=0; i<len; i++)
    4bce:	21 96       	adiw	r28, 0x01	; 1
    4bd0:	ce 15       	cp	r28, r14
    4bd2:	df 05       	cpc	r29, r15
    4bd4:	90 f3       	brcs	.-28     	; 0x4bba <rprintfStrLen+0x32>
			rprintfChar(*str++);
		else
			rprintfChar(' ');
	}

}
    4bd6:	df 91       	pop	r29
    4bd8:	cf 91       	pop	r28
    4bda:	1f 91       	pop	r17
    4bdc:	0f 91       	pop	r16
    4bde:	ff 90       	pop	r15
    4be0:	ef 90       	pop	r14
    4be2:	08 95       	ret

00004be4 <rprintfProgStr>:

// *** rprintfProgStr ***
// prints a null-terminated string stored in program ROM
void rprintfProgStr(const prog_char str[])
{
    4be4:	cf 93       	push	r28
    4be6:	df 93       	push	r29
    4be8:	ec 01       	movw	r28, r24
	// print a string stored in program memory
	register char c;

	// check to make sure we have a good pointer
	if (!str) return;
    4bea:	00 97       	sbiw	r24, 0x00	; 0
    4bec:	19 f4       	brne	.+6      	; 0x4bf4 <rprintfProgStr+0x10>
    4bee:	07 c0       	rjmp	.+14     	; 0x4bfe <rprintfProgStr+0x1a>
	
	// print the string until the null-terminator
	while((c = pgm_read_byte(str++)))
		rprintfChar(c);
    4bf0:	0e 94 a3 25 	call	0x4b46	; 0x4b46 <rprintfChar>
    4bf4:	fe 01       	movw	r30, r28

	// check to make sure we have a good pointer
	if (!str) return;
	
	// print the string until the null-terminator
	while((c = pgm_read_byte(str++)))
    4bf6:	21 96       	adiw	r28, 0x01	; 1
    4bf8:	84 91       	lpm	r24, Z+
    4bfa:	88 23       	and	r24, r24
    4bfc:	c9 f7       	brne	.-14     	; 0x4bf0 <rprintfProgStr+0xc>
		rprintfChar(c);
}
    4bfe:	df 91       	pop	r29
    4c00:	cf 91       	pop	r28
    4c02:	08 95       	ret

00004c04 <rprintfCRLF>:
void rprintfCRLF(void)
{
	// print CR/LF
	//rprintfChar('\r');
	// LF -> CR/LF translation built-in to rprintfChar()
	rprintfChar('\n');
    4c04:	8a e0       	ldi	r24, 0x0A	; 10
    4c06:	0e 94 a3 25 	call	0x4b46	; 0x4b46 <rprintfChar>
}
    4c0a:	08 95       	ret

00004c0c <rprintfu04>:
//	char Character = data&0x0f;
//	if (Character>9)
//		Character+='A'-10;
//	else
//		Character+='0';
	rprintfChar(hexchar(data));
    4c0c:	e8 2f       	mov	r30, r24
    4c0e:	f0 e0       	ldi	r31, 0x00	; 0
    4c10:	ef 70       	andi	r30, 0x0F	; 15
    4c12:	f0 70       	andi	r31, 0x00	; 0
    4c14:	e5 54       	subi	r30, 0x45	; 69
    4c16:	fe 4f       	sbci	r31, 0xFE	; 254
    4c18:	e4 91       	lpm	r30, Z+
    4c1a:	8e 2f       	mov	r24, r30
    4c1c:	0e 94 a3 25 	call	0x4b46	; 0x4b46 <rprintfChar>
}
    4c20:	08 95       	ret

00004c22 <rprintfu08>:

// *** rprintfu08 ***
// prints an unsigned 8-bit number in hex (2 digits)
void rprintfu08(unsigned char data)
{
    4c22:	1f 93       	push	r17
    4c24:	18 2f       	mov	r17, r24
	// print 8-bit hex value
	rprintfu04(data>>4);
    4c26:	82 95       	swap	r24
    4c28:	8f 70       	andi	r24, 0x0F	; 15
    4c2a:	0e 94 06 26 	call	0x4c0c	; 0x4c0c <rprintfu04>
	rprintfu04(data);
    4c2e:	81 2f       	mov	r24, r17
    4c30:	0e 94 06 26 	call	0x4c0c	; 0x4c0c <rprintfu04>
}
    4c34:	1f 91       	pop	r17
    4c36:	08 95       	ret

00004c38 <rprintfu16>:

// *** rprintfu16 ***
// prints an unsigned 16-bit number in hex (4 digits)
void rprintfu16(unsigned short data)
{
    4c38:	1f 93       	push	r17
    4c3a:	18 2f       	mov	r17, r24
	// print 16-bit hex value
	rprintfu08(data>>8);
    4c3c:	89 2f       	mov	r24, r25
    4c3e:	0e 94 11 26 	call	0x4c22	; 0x4c22 <rprintfu08>
	rprintfu08(data);
    4c42:	81 2f       	mov	r24, r17
    4c44:	0e 94 11 26 	call	0x4c22	; 0x4c22 <rprintfu08>
}
    4c48:	1f 91       	pop	r17
    4c4a:	08 95       	ret

00004c4c <rprintfu32>:

// *** rprintfu32 ***
// prints an unsigned 32-bit number in hex (8 digits)
void rprintfu32(unsigned long data)
{
    4c4c:	ef 92       	push	r14
    4c4e:	ff 92       	push	r15
    4c50:	0f 93       	push	r16
    4c52:	1f 93       	push	r17
    4c54:	7b 01       	movw	r14, r22
    4c56:	8c 01       	movw	r16, r24
	// print 32-bit hex value
	rprintfu16(data>>16);
    4c58:	c8 01       	movw	r24, r16
    4c5a:	aa 27       	eor	r26, r26
    4c5c:	bb 27       	eor	r27, r27
    4c5e:	0e 94 1c 26 	call	0x4c38	; 0x4c38 <rprintfu16>
	rprintfu16(data);
    4c62:	c7 01       	movw	r24, r14
    4c64:	0e 94 1c 26 	call	0x4c38	; 0x4c38 <rprintfu16>
}
    4c68:	1f 91       	pop	r17
    4c6a:	0f 91       	pop	r16
    4c6c:	ff 90       	pop	r15
    4c6e:	ef 90       	pop	r14
    4c70:	08 95       	ret

00004c72 <rprintfNum>:
//	Examples:
//	uartPrintfNum(10, 6,  TRUE, ' ',   1234);  -->  " +1234"
//	uartPrintfNum(10, 6, FALSE, '0',   1234);  -->  "001234"
//	uartPrintfNum(16, 6, FALSE, '.', 0x5AA5);  -->  "..5AA5"
void rprintfNum(char base, char numDigits, char isSigned, char padchar, long n)
{
    4c72:	2f 92       	push	r2
    4c74:	3f 92       	push	r3
    4c76:	4f 92       	push	r4
    4c78:	5f 92       	push	r5
    4c7a:	6f 92       	push	r6
    4c7c:	7f 92       	push	r7
    4c7e:	8f 92       	push	r8
    4c80:	9f 92       	push	r9
    4c82:	af 92       	push	r10
    4c84:	bf 92       	push	r11
    4c86:	cf 92       	push	r12
    4c88:	df 92       	push	r13
    4c8a:	ef 92       	push	r14
    4c8c:	ff 92       	push	r15
    4c8e:	0f 93       	push	r16
    4c90:	1f 93       	push	r17
    4c92:	df 93       	push	r29
    4c94:	cf 93       	push	r28
    4c96:	cd b7       	in	r28, 0x3d	; 61
    4c98:	de b7       	in	r29, 0x3e	; 62
    4c9a:	a3 97       	sbiw	r28, 0x23	; 35
    4c9c:	0f b6       	in	r0, 0x3f	; 63
    4c9e:	f8 94       	cli
    4ca0:	de bf       	out	0x3e, r29	; 62
    4ca2:	0f be       	out	0x3f, r0	; 63
    4ca4:	cd bf       	out	0x3d, r28	; 61
    4ca6:	6a a3       	std	Y+34, r22	; 0x22
    4ca8:	24 2e       	mov	r2, r20
    4caa:	2b a3       	std	Y+35, r18	; 0x23
    4cac:	37 01       	movw	r6, r14
    4cae:	48 01       	movw	r8, r16
	char *p, buf[32];
	unsigned long x;
	unsigned char count;

	// prepare negative number
	if( isSigned && (n < 0) )
    4cb0:	44 23       	and	r20, r20
    4cb2:	51 f0       	breq	.+20     	; 0x4cc8 <rprintfNum+0x56>
    4cb4:	17 ff       	sbrs	r17, 7
    4cb6:	08 c0       	rjmp	.+16     	; 0x4cc8 <rprintfNum+0x56>
	{
		x = -n;
    4cb8:	ee 24       	eor	r14, r14
    4cba:	ff 24       	eor	r15, r15
    4cbc:	87 01       	movw	r16, r14
    4cbe:	e6 18       	sub	r14, r6
    4cc0:	f7 08       	sbc	r15, r7
    4cc2:	08 09       	sbc	r16, r8
    4cc4:	19 09       	sbc	r17, r9
    4cc6:	02 c0       	rjmp	.+4      	; 0x4ccc <rprintfNum+0x5a>
	}
	else
	{
	 	x = n;
    4cc8:	84 01       	movw	r16, r8
    4cca:	73 01       	movw	r14, r6
	}

	// setup little string buffer
	count = (numDigits-1)-(isSigned?1:0);
    4ccc:	2a a1       	ldd	r18, Y+34	; 0x22
    4cce:	21 50       	subi	r18, 0x01	; 1
    4cd0:	90 e0       	ldi	r25, 0x00	; 0
    4cd2:	21 10       	cpse	r2, r1
    4cd4:	91 e0       	ldi	r25, 0x01	; 1
    4cd6:	29 1b       	sub	r18, r25
    4cd8:	29 a3       	std	Y+33, r18	; 0x21
  	p = buf + sizeof (buf);
  	*--p = '\0';
    4cda:	18 a2       	std	Y+32, r1	; 0x20
	
	// force calculation of first digit
	// (to prevent zero from not printing at all!!!)
	*--p = hexchar(x%base); x /= base;
    4cdc:	a8 2e       	mov	r10, r24
    4cde:	bb 24       	eor	r11, r11
    4ce0:	cc 24       	eor	r12, r12
    4ce2:	dd 24       	eor	r13, r13
    4ce4:	c8 01       	movw	r24, r16
    4ce6:	b7 01       	movw	r22, r14
    4ce8:	a6 01       	movw	r20, r12
    4cea:	95 01       	movw	r18, r10
    4cec:	0e 94 42 2e 	call	0x5c84	; 0x5c84 <__udivmodsi4>
    4cf0:	fb 01       	movw	r30, r22
    4cf2:	ef 70       	andi	r30, 0x0F	; 15
    4cf4:	f0 70       	andi	r31, 0x00	; 0
    4cf6:	e5 54       	subi	r30, 0x45	; 69
    4cf8:	fe 4f       	sbci	r31, 0xFE	; 254
    4cfa:	64 91       	lpm	r22, Z+
    4cfc:	6f 8f       	std	Y+31, r22	; 0x1f
    4cfe:	c8 01       	movw	r24, r16
    4d00:	b7 01       	movw	r22, r14
    4d02:	a6 01       	movw	r20, r12
    4d04:	95 01       	movw	r18, r10
    4d06:	0e 94 42 2e 	call	0x5c84	; 0x5c84 <__udivmodsi4>
    4d0a:	c9 01       	movw	r24, r18
    4d0c:	da 01       	movw	r26, r20
    4d0e:	7c 01       	movw	r14, r24
    4d10:	8d 01       	movw	r16, r26
    4d12:	9e e1       	ldi	r25, 0x1E	; 30
    4d14:	49 2e       	mov	r4, r25
    4d16:	51 2c       	mov	r5, r1
    4d18:	4c 0e       	add	r4, r28
    4d1a:	5d 1e       	adc	r5, r29
    4d1c:	39 a0       	ldd	r3, Y+33	; 0x21
    4d1e:	25 c0       	rjmp	.+74     	; 0x4d6a <rprintfNum+0xf8>
	// calculate remaining digits
	while(count--)
	{
		if(x != 0)
    4d20:	e1 14       	cp	r14, r1
    4d22:	f1 04       	cpc	r15, r1
    4d24:	01 05       	cpc	r16, r1
    4d26:	11 05       	cpc	r17, r1
    4d28:	c9 f0       	breq	.+50     	; 0x4d5c <rprintfNum+0xea>
		{
			// calculate next digit
			*--p = hexchar(x%base); x /= base;
    4d2a:	c8 01       	movw	r24, r16
    4d2c:	b7 01       	movw	r22, r14
    4d2e:	a6 01       	movw	r20, r12
    4d30:	95 01       	movw	r18, r10
    4d32:	0e 94 42 2e 	call	0x5c84	; 0x5c84 <__udivmodsi4>
    4d36:	fb 01       	movw	r30, r22
    4d38:	ef 70       	andi	r30, 0x0F	; 15
    4d3a:	f0 70       	andi	r31, 0x00	; 0
    4d3c:	e5 54       	subi	r30, 0x45	; 69
    4d3e:	fe 4f       	sbci	r31, 0xFE	; 254
    4d40:	64 91       	lpm	r22, Z+
    4d42:	f2 01       	movw	r30, r4
    4d44:	60 83       	st	Z, r22
    4d46:	c8 01       	movw	r24, r16
    4d48:	b7 01       	movw	r22, r14
    4d4a:	a6 01       	movw	r20, r12
    4d4c:	95 01       	movw	r18, r10
    4d4e:	0e 94 42 2e 	call	0x5c84	; 0x5c84 <__udivmodsi4>
    4d52:	c9 01       	movw	r24, r18
    4d54:	da 01       	movw	r26, r20
    4d56:	7c 01       	movw	r14, r24
    4d58:	8d 01       	movw	r16, r26
    4d5a:	03 c0       	rjmp	.+6      	; 0x4d62 <rprintfNum+0xf0>
		}
		else
		{
			// no more digits left, pad out to desired length
			*--p = padchar;
    4d5c:	2b a1       	ldd	r18, Y+35	; 0x23
    4d5e:	f2 01       	movw	r30, r4
    4d60:	20 83       	st	Z, r18
    4d62:	3a 94       	dec	r3
    4d64:	08 94       	sec
    4d66:	41 08       	sbc	r4, r1
    4d68:	51 08       	sbc	r5, r1
	
	// force calculation of first digit
	// (to prevent zero from not printing at all!!!)
	*--p = hexchar(x%base); x /= base;
	// calculate remaining digits
	while(count--)
    4d6a:	33 20       	and	r3, r3
    4d6c:	c9 f6       	brne	.-78     	; 0x4d20 <rprintfNum+0xae>
    4d6e:	ce 01       	movw	r24, r28
    4d70:	4f 96       	adiw	r24, 0x1f	; 31
    4d72:	8c 01       	movw	r16, r24
    4d74:	e9 a1       	ldd	r30, Y+33	; 0x21
    4d76:	0e 1b       	sub	r16, r30
    4d78:	11 09       	sbc	r17, r1
			*--p = padchar;
		}
	}

	// apply signed notation if requested
	if( isSigned )
    4d7a:	22 20       	and	r2, r2
    4d7c:	f1 f0       	breq	.+60     	; 0x4dba <rprintfNum+0x148>
	{
		if(n < 0)
    4d7e:	97 fe       	sbrs	r9, 7
    4d80:	05 c0       	rjmp	.+10     	; 0x4d8c <rprintfNum+0x11a>
		{
   			*--p = '-';
    4d82:	8d e2       	ldi	r24, 0x2D	; 45
    4d84:	f8 01       	movw	r30, r16
    4d86:	82 93       	st	-Z, r24
    4d88:	8f 01       	movw	r16, r30
    4d8a:	17 c0       	rjmp	.+46     	; 0x4dba <rprintfNum+0x148>
    4d8c:	c8 01       	movw	r24, r16
    4d8e:	01 97       	sbiw	r24, 0x01	; 1
		}
		else if(n > 0)
    4d90:	61 14       	cp	r6, r1
    4d92:	71 04       	cpc	r7, r1
    4d94:	81 04       	cpc	r8, r1
    4d96:	91 04       	cpc	r9, r1
    4d98:	19 f0       	breq	.+6      	; 0x4da0 <rprintfNum+0x12e>
		{
	   		*--p = '+';
    4d9a:	8c 01       	movw	r16, r24
    4d9c:	8b e2       	ldi	r24, 0x2B	; 43
    4d9e:	02 c0       	rjmp	.+4      	; 0x4da4 <rprintfNum+0x132>
		}
		else
		{
	   		*--p = ' ';
    4da0:	8c 01       	movw	r16, r24
    4da2:	80 e2       	ldi	r24, 0x20	; 32
    4da4:	f8 01       	movw	r30, r16
    4da6:	80 83       	st	Z, r24
    4da8:	08 c0       	rjmp	.+16     	; 0x4dba <rprintfNum+0x148>

	// print the string right-justified
	count = numDigits;
	while(count--)
	{
		rprintfChar(*p++);
    4daa:	f8 01       	movw	r30, r16
    4dac:	81 91       	ld	r24, Z+
    4dae:	8f 01       	movw	r16, r30
    4db0:	0e 94 a3 25 	call	0x4b46	; 0x4b46 <rprintfChar>
    4db4:	fa a1       	ldd	r31, Y+34	; 0x22
    4db6:	f1 50       	subi	r31, 0x01	; 1
    4db8:	fa a3       	std	Y+34, r31	; 0x22
		}
	}

	// print the string right-justified
	count = numDigits;
	while(count--)
    4dba:	2a a1       	ldd	r18, Y+34	; 0x22
    4dbc:	22 23       	and	r18, r18
    4dbe:	a9 f7       	brne	.-22     	; 0x4daa <rprintfNum+0x138>
	{
		rprintfChar(*p++);
	}
}
    4dc0:	a3 96       	adiw	r28, 0x23	; 35
    4dc2:	0f b6       	in	r0, 0x3f	; 63
    4dc4:	f8 94       	cli
    4dc6:	de bf       	out	0x3e, r29	; 62
    4dc8:	0f be       	out	0x3f, r0	; 63
    4dca:	cd bf       	out	0x3d, r28	; 61
    4dcc:	cf 91       	pop	r28
    4dce:	df 91       	pop	r29
    4dd0:	1f 91       	pop	r17
    4dd2:	0f 91       	pop	r16
    4dd4:	ff 90       	pop	r15
    4dd6:	ef 90       	pop	r14
    4dd8:	df 90       	pop	r13
    4dda:	cf 90       	pop	r12
    4ddc:	bf 90       	pop	r11
    4dde:	af 90       	pop	r10
    4de0:	9f 90       	pop	r9
    4de2:	8f 90       	pop	r8
    4de4:	7f 90       	pop	r7
    4de6:	6f 90       	pop	r6
    4de8:	5f 90       	pop	r5
    4dea:	4f 90       	pop	r4
    4dec:	3f 90       	pop	r3
    4dee:	2f 90       	pop	r2
    4df0:	08 95       	ret

00004df2 <rprintfFloat>:

#ifdef RPRINTF_FLOAT
// *** rprintfFloat ***
// floating-point print
void rprintfFloat(char numDigits, double x)
{
    4df2:	4f 92       	push	r4
    4df4:	5f 92       	push	r5
    4df6:	6f 92       	push	r6
    4df8:	7f 92       	push	r7
    4dfa:	8f 92       	push	r8
    4dfc:	9f 92       	push	r9
    4dfe:	af 92       	push	r10
    4e00:	bf 92       	push	r11
    4e02:	cf 92       	push	r12
    4e04:	df 92       	push	r13
    4e06:	ef 92       	push	r14
    4e08:	ff 92       	push	r15
    4e0a:	0f 93       	push	r16
    4e0c:	1f 93       	push	r17
    4e0e:	cf 93       	push	r28
    4e10:	df 93       	push	r29
    4e12:	48 2e       	mov	r4, r24
    4e14:	5a 01       	movw	r10, r20
    4e16:	6b 01       	movw	r12, r22
	double place = 1.0;
	
	// save sign
	negative = (x<0);
	// convert to absolute value
	x = (x>0)?(x):(-x);
    4e18:	cb 01       	movw	r24, r22
    4e1a:	ba 01       	movw	r22, r20
    4e1c:	20 e0       	ldi	r18, 0x00	; 0
    4e1e:	30 e0       	ldi	r19, 0x00	; 0
    4e20:	40 e0       	ldi	r20, 0x00	; 0
    4e22:	50 e0       	ldi	r21, 0x00	; 0
    4e24:	0e 94 8b 2d 	call	0x5b16	; 0x5b16 <__gesf2>
    4e28:	18 16       	cp	r1, r24
    4e2a:	1c f4       	brge	.+6      	; 0x4e32 <rprintfFloat+0x40>
    4e2c:	35 01       	movw	r6, r10
    4e2e:	46 01       	movw	r8, r12
    4e30:	06 c0       	rjmp	.+12     	; 0x4e3e <rprintfFloat+0x4c>
    4e32:	35 01       	movw	r6, r10
    4e34:	46 01       	movw	r8, r12
    4e36:	97 fa       	bst	r9, 7
    4e38:	90 94       	com	r9
    4e3a:	97 f8       	bld	r9, 7
    4e3c:	90 94       	com	r9
    4e3e:	0f 2e       	mov	r0, r31
    4e40:	f0 e0       	ldi	r31, 0x00	; 0
    4e42:	ef 2e       	mov	r14, r31
    4e44:	f0 e0       	ldi	r31, 0x00	; 0
    4e46:	ff 2e       	mov	r15, r31
    4e48:	f0 e8       	ldi	r31, 0x80	; 128
    4e4a:	0f 2f       	mov	r16, r31
    4e4c:	ff e3       	ldi	r31, 0x3F	; 63
    4e4e:	1f 2f       	mov	r17, r31
    4e50:	f0 2d       	mov	r31, r0
    4e52:	55 24       	eor	r5, r5
	
	// find starting digit place
	for(i=0; i<15; i++)
	{
		if((x/place) < 10.0)
    4e54:	c4 01       	movw	r24, r8
    4e56:	b3 01       	movw	r22, r6
    4e58:	a8 01       	movw	r20, r16
    4e5a:	97 01       	movw	r18, r14
    4e5c:	0e 94 c6 2b 	call	0x578c	; 0x578c <__divsf3>
    4e60:	20 e0       	ldi	r18, 0x00	; 0
    4e62:	30 e0       	ldi	r19, 0x00	; 0
    4e64:	40 e2       	ldi	r20, 0x20	; 32
    4e66:	51 e4       	ldi	r21, 0x41	; 65
    4e68:	0e 94 c2 2b 	call	0x5784	; 0x5784 <__cmpsf2>
    4e6c:	87 fd       	sbrc	r24, 7
    4e6e:	0e c0       	rjmp	.+28     	; 0x4e8c <rprintfFloat+0x9a>
			break;
		else
			place *= 10.0;
    4e70:	c8 01       	movw	r24, r16
    4e72:	b7 01       	movw	r22, r14
    4e74:	20 e0       	ldi	r18, 0x00	; 0
    4e76:	30 e0       	ldi	r19, 0x00	; 0
    4e78:	40 e2       	ldi	r20, 0x20	; 32
    4e7a:	51 e4       	ldi	r21, 0x41	; 65
    4e7c:	0e 94 96 2d 	call	0x5b2c	; 0x5b2c <__mulsf3>
    4e80:	7b 01       	movw	r14, r22
    4e82:	8c 01       	movw	r16, r24
	negative = (x<0);
	// convert to absolute value
	x = (x>0)?(x):(-x);
	
	// find starting digit place
	for(i=0; i<15; i++)
    4e84:	53 94       	inc	r5
    4e86:	8f e0       	ldi	r24, 0x0F	; 15
    4e88:	58 16       	cp	r5, r24
    4e8a:	21 f7       	brne	.-56     	; 0x4e54 <rprintfFloat+0x62>
			break;
		else
			place *= 10.0;
	}
	// print polarity character
	if(negative)
    4e8c:	c6 01       	movw	r24, r12
    4e8e:	b5 01       	movw	r22, r10
    4e90:	20 e0       	ldi	r18, 0x00	; 0
    4e92:	30 e0       	ldi	r19, 0x00	; 0
    4e94:	40 e0       	ldi	r20, 0x00	; 0
    4e96:	50 e0       	ldi	r21, 0x00	; 0
    4e98:	0e 94 c2 2b 	call	0x5784	; 0x5784 <__cmpsf2>
    4e9c:	88 23       	and	r24, r24
    4e9e:	14 f4       	brge	.+4      	; 0x4ea4 <rprintfFloat+0xb2>
		rprintfChar('-');
    4ea0:	8d e2       	ldi	r24, 0x2D	; 45
    4ea2:	01 c0       	rjmp	.+2      	; 0x4ea6 <rprintfFloat+0xb4>
	else
		rprintfChar('+');
    4ea4:	8b e2       	ldi	r24, 0x2B	; 43
    4ea6:	0e 94 a3 25 	call	0x4b46	; 0x4b46 <rprintfChar>
    4eaa:	dd 24       	eor	r13, r13
    4eac:	aa 24       	eor	r10, r10
    4eae:	56 c0       	rjmp	.+172    	; 0x4f5c <rprintfFloat+0x16a>

	// print digits
	for(i=0; i<numDigits; i++)
	{
		digit = (x/place);
    4eb0:	c4 01       	movw	r24, r8
    4eb2:	b3 01       	movw	r22, r6
    4eb4:	a8 01       	movw	r20, r16
    4eb6:	97 01       	movw	r18, r14
    4eb8:	0e 94 c6 2b 	call	0x578c	; 0x578c <__divsf3>
    4ebc:	0e 94 33 2c 	call	0x5866	; 0x5866 <__fixunssfsi>
    4ec0:	b6 2e       	mov	r11, r22

		if(digit | firstplace | (place == 1.0))
    4ec2:	d6 2a       	or	r13, r22
    4ec4:	cd 2d       	mov	r28, r13
    4ec6:	d0 e0       	ldi	r29, 0x00	; 0
    4ec8:	cc 24       	eor	r12, r12
    4eca:	dd 24       	eor	r13, r13
    4ecc:	c8 01       	movw	r24, r16
    4ece:	b7 01       	movw	r22, r14
    4ed0:	20 e0       	ldi	r18, 0x00	; 0
    4ed2:	30 e0       	ldi	r19, 0x00	; 0
    4ed4:	40 e8       	ldi	r20, 0x80	; 128
    4ed6:	5f e3       	ldi	r21, 0x3F	; 63
    4ed8:	0e 94 c2 2b 	call	0x5784	; 0x5784 <__cmpsf2>
    4edc:	88 23       	and	r24, r24
    4ede:	19 f4       	brne	.+6      	; 0x4ee6 <rprintfFloat+0xf4>
    4ee0:	21 e0       	ldi	r18, 0x01	; 1
    4ee2:	c2 2e       	mov	r12, r18
    4ee4:	d1 2c       	mov	r13, r1
    4ee6:	cc 29       	or	r28, r12
    4ee8:	dd 29       	or	r29, r13
    4eea:	cd 2b       	or	r28, r29
    4eec:	39 f0       	breq	.+14     	; 0x4efc <rprintfFloat+0x10a>
		{
			firstplace = TRUE;
			rprintfChar(digit+0x30);
    4eee:	8b 2d       	mov	r24, r11
    4ef0:	80 5d       	subi	r24, 0xD0	; 208
    4ef2:	0e 94 a3 25 	call	0x4b46	; 0x4b46 <rprintfChar>
    4ef6:	dd 24       	eor	r13, r13
    4ef8:	da 94       	dec	r13
    4efa:	04 c0       	rjmp	.+8      	; 0x4f04 <rprintfFloat+0x112>
		}
		else
			rprintfChar(' ');
    4efc:	80 e2       	ldi	r24, 0x20	; 32
    4efe:	0e 94 a3 25 	call	0x4b46	; 0x4b46 <rprintfChar>
    4f02:	dd 24       	eor	r13, r13
		
		if(place == 1.0)
    4f04:	c8 01       	movw	r24, r16
    4f06:	b7 01       	movw	r22, r14
    4f08:	20 e0       	ldi	r18, 0x00	; 0
    4f0a:	30 e0       	ldi	r19, 0x00	; 0
    4f0c:	40 e8       	ldi	r20, 0x80	; 128
    4f0e:	5f e3       	ldi	r21, 0x3F	; 63
    4f10:	0e 94 c2 2b 	call	0x5784	; 0x5784 <__cmpsf2>
    4f14:	88 23       	and	r24, r24
    4f16:	19 f4       	brne	.+6      	; 0x4f1e <rprintfFloat+0x12c>
		{
			rprintfChar('.');
    4f18:	8e e2       	ldi	r24, 0x2E	; 46
    4f1a:	0e 94 a3 25 	call	0x4b46	; 0x4b46 <rprintfChar>
		}
		
		x -= (digit*place);
    4f1e:	6b 2d       	mov	r22, r11
    4f20:	70 e0       	ldi	r23, 0x00	; 0
    4f22:	88 27       	eor	r24, r24
    4f24:	77 fd       	sbrc	r23, 7
    4f26:	80 95       	com	r24
    4f28:	98 2f       	mov	r25, r24
    4f2a:	0e 94 61 2c 	call	0x58c2	; 0x58c2 <__floatsisf>
    4f2e:	a8 01       	movw	r20, r16
    4f30:	97 01       	movw	r18, r14
    4f32:	0e 94 96 2d 	call	0x5b2c	; 0x5b2c <__mulsf3>
    4f36:	9b 01       	movw	r18, r22
    4f38:	ac 01       	movw	r20, r24
    4f3a:	c4 01       	movw	r24, r8
    4f3c:	b3 01       	movw	r22, r6
    4f3e:	0e 94 fb 2a 	call	0x55f6	; 0x55f6 <__subsf3>
    4f42:	3b 01       	movw	r6, r22
    4f44:	4c 01       	movw	r8, r24
		place /= 10.0;
    4f46:	c8 01       	movw	r24, r16
    4f48:	b7 01       	movw	r22, r14
    4f4a:	20 e0       	ldi	r18, 0x00	; 0
    4f4c:	30 e0       	ldi	r19, 0x00	; 0
    4f4e:	40 e2       	ldi	r20, 0x20	; 32
    4f50:	51 e4       	ldi	r21, 0x41	; 65
    4f52:	0e 94 c6 2b 	call	0x578c	; 0x578c <__divsf3>
    4f56:	7b 01       	movw	r14, r22
    4f58:	8c 01       	movw	r16, r24
		rprintfChar('-');
	else
		rprintfChar('+');

	// print digits
	for(i=0; i<numDigits; i++)
    4f5a:	a3 94       	inc	r10
    4f5c:	a4 14       	cp	r10, r4
    4f5e:	08 f4       	brcc	.+2      	; 0x4f62 <rprintfFloat+0x170>
    4f60:	a7 cf       	rjmp	.-178    	; 0x4eb0 <rprintfFloat+0xbe>
		}
		
		x -= (digit*place);
		place /= 10.0;
	}
}
    4f62:	df 91       	pop	r29
    4f64:	cf 91       	pop	r28
    4f66:	1f 91       	pop	r17
    4f68:	0f 91       	pop	r16
    4f6a:	ff 90       	pop	r15
    4f6c:	ef 90       	pop	r14
    4f6e:	df 90       	pop	r13
    4f70:	cf 90       	pop	r12
    4f72:	bf 90       	pop	r11
    4f74:	af 90       	pop	r10
    4f76:	9f 90       	pop	r9
    4f78:	8f 90       	pop	r8
    4f7a:	7f 90       	pop	r7
    4f7c:	6f 90       	pop	r6
    4f7e:	5f 90       	pop	r5
    4f80:	4f 90       	pop	r4
    4f82:	08 95       	ret

00004f84 <rprintf1RamRom>:
// Supports:
// %d - decimal
// %x - hex
// %c - character
int rprintf1RamRom(unsigned char stringInRom, const char *format, ...)
{
    4f84:	7f 92       	push	r7
    4f86:	8f 92       	push	r8
    4f88:	9f 92       	push	r9
    4f8a:	af 92       	push	r10
    4f8c:	bf 92       	push	r11
    4f8e:	cf 92       	push	r12
    4f90:	df 92       	push	r13
    4f92:	ef 92       	push	r14
    4f94:	ff 92       	push	r15
    4f96:	0f 93       	push	r16
    4f98:	1f 93       	push	r17
    4f9a:	df 93       	push	r29
    4f9c:	cf 93       	push	r28
    4f9e:	cd b7       	in	r28, 0x3d	; 61
    4fa0:	de b7       	in	r29, 0x3e	; 62
    4fa2:	78 88       	ldd	r7, Y+16	; 0x10
    4fa4:	c9 88       	ldd	r12, Y+17	; 0x11
    4fa6:	da 88       	ldd	r13, Y+18	; 0x12
    4fa8:	63 e1       	ldi	r22, 0x13	; 19
    4faa:	e6 2e       	mov	r14, r22
    4fac:	f1 2c       	mov	r15, r1
    4fae:	ec 0e       	add	r14, r28
    4fb0:	fd 1e       	adc	r15, r29
    4fb2:	14 c0       	rjmp	.+40     	; 0x4fdc <rprintf1RamRom+0x58>
	va_start(ap, format);
	for (;;)
	{
		while ((format_flag = READMEMBYTE(stringInRom,format++) ) != '%')
		{	// Until '%' or '\0'
			if (!format_flag)
    4fb4:	88 23       	and	r24, r24
    4fb6:	81 f4       	brne	.+32     	; 0x4fd8 <rprintf1RamRom+0x54>
				div_val /= base;
			} while (div_val);
		}
	}
	va_end(ap);
}
    4fb8:	80 e0       	ldi	r24, 0x00	; 0
    4fba:	90 e0       	ldi	r25, 0x00	; 0
    4fbc:	cf 91       	pop	r28
    4fbe:	df 91       	pop	r29
    4fc0:	1f 91       	pop	r17
    4fc2:	0f 91       	pop	r16
    4fc4:	ff 90       	pop	r15
    4fc6:	ef 90       	pop	r14
    4fc8:	df 90       	pop	r13
    4fca:	cf 90       	pop	r12
    4fcc:	bf 90       	pop	r11
    4fce:	af 90       	pop	r10
    4fd0:	9f 90       	pop	r9
    4fd2:	8f 90       	pop	r8
    4fd4:	7f 90       	pop	r7
    4fd6:	08 95       	ret
			if (!format_flag)
			{
				va_end(ap);
				return(0);
			}
			rprintfChar(format_flag);
    4fd8:	0e 94 a3 25 	call	0x4b46	; 0x4b46 <rprintfChar>
    4fdc:	96 01       	movw	r18, r12
    4fde:	2f 5f       	subi	r18, 0xFF	; 255
    4fe0:	3f 4f       	sbci	r19, 0xFF	; 255
	va_list ap;

	va_start(ap, format);
	for (;;)
	{
		while ((format_flag = READMEMBYTE(stringInRom,format++) ) != '%')
    4fe2:	77 20       	and	r7, r7
    4fe4:	21 f0       	breq	.+8      	; 0x4fee <rprintf1RamRom+0x6a>
    4fe6:	f6 01       	movw	r30, r12
    4fe8:	69 01       	movw	r12, r18
    4fea:	84 91       	lpm	r24, Z+
    4fec:	03 c0       	rjmp	.+6      	; 0x4ff4 <rprintf1RamRom+0x70>
    4fee:	f6 01       	movw	r30, r12
    4ff0:	80 81       	ld	r24, Z
    4ff2:	69 01       	movw	r12, r18
    4ff4:	85 32       	cpi	r24, 0x25	; 37
    4ff6:	f1 f6       	brne	.-68     	; 0x4fb4 <rprintf1RamRom+0x30>
    4ff8:	2f 5f       	subi	r18, 0xFF	; 255
    4ffa:	3f 4f       	sbci	r19, 0xFF	; 255
				return(0);
			}
			rprintfChar(format_flag);
		}

		switch (format_flag = READMEMBYTE(stringInRom,format++) )
    4ffc:	77 20       	and	r7, r7
    4ffe:	21 f0       	breq	.+8      	; 0x5008 <rprintf1RamRom+0x84>
    5000:	f6 01       	movw	r30, r12
    5002:	69 01       	movw	r12, r18
    5004:	84 91       	lpm	r24, Z+
    5006:	03 c0       	rjmp	.+6      	; 0x500e <rprintf1RamRom+0x8a>
    5008:	f6 01       	movw	r30, r12
    500a:	80 81       	ld	r24, Z
    500c:	69 01       	movw	r12, r18
    500e:	84 36       	cpi	r24, 0x64	; 100
    5010:	29 f0       	breq	.+10     	; 0x501c <rprintf1RamRom+0x98>
    5012:	88 37       	cpi	r24, 0x78	; 120
    5014:	81 f0       	breq	.+32     	; 0x5036 <rprintf1RamRom+0xb2>
    5016:	83 36       	cpi	r24, 0x63	; 99
    5018:	f9 f6       	brne	.-66     	; 0x4fd8 <rprintf1RamRom+0x54>
    501a:	06 c0       	rjmp	.+12     	; 0x5028 <rprintf1RamRom+0xa4>
    501c:	00 e1       	ldi	r16, 0x10	; 16
    501e:	17 e2       	ldi	r17, 0x27	; 39
    5020:	5a e0       	ldi	r21, 0x0A	; 10
    5022:	a5 2e       	mov	r10, r21
    5024:	b1 2c       	mov	r11, r1
    5026:	0c c0       	rjmp	.+24     	; 0x5040 <rprintf1RamRom+0xbc>
		{
			case 'c': format_flag = va_arg(ap,int);
    5028:	f7 01       	movw	r30, r14
    502a:	80 81       	ld	r24, Z
    502c:	22 e0       	ldi	r18, 0x02	; 2
    502e:	30 e0       	ldi	r19, 0x00	; 0
    5030:	e2 0e       	add	r14, r18
    5032:	f3 1e       	adc	r15, r19
    5034:	d1 cf       	rjmp	.-94     	; 0x4fd8 <rprintf1RamRom+0x54>
			default:  rprintfChar(format_flag); continue;
    5036:	00 e0       	ldi	r16, 0x00	; 0
    5038:	10 e1       	ldi	r17, 0x10	; 16
    503a:	40 e1       	ldi	r20, 0x10	; 16
    503c:	a4 2e       	mov	r10, r20
    503e:	b1 2c       	mov	r11, r1
			case 'd': base = 10; div_val = 10000; goto CONVERSION_LOOP;
//			case 'x': base = 16; div_val = 0x10;
			case 'x': base = 16; div_val = 0x1000;

			CONVERSION_LOOP:
			u_val = va_arg(ap,int);
    5040:	32 e0       	ldi	r19, 0x02	; 2
    5042:	83 2e       	mov	r8, r19
    5044:	91 2c       	mov	r9, r1
    5046:	8e 0c       	add	r8, r14
    5048:	9f 1c       	adc	r9, r15
    504a:	f7 01       	movw	r30, r14
    504c:	e0 80       	ld	r14, Z
    504e:	f1 80       	ldd	r15, Z+1	; 0x01
			if (format_flag == 'd')
    5050:	84 36       	cpi	r24, 0x64	; 100
    5052:	b1 f4       	brne	.+44     	; 0x5080 <rprintf1RamRom+0xfc>
			{
				if (((int)u_val) < 0)
    5054:	f7 fe       	sbrs	r15, 7
    5056:	11 c0       	rjmp	.+34     	; 0x507a <rprintf1RamRom+0xf6>
				{
					u_val = - u_val;
    5058:	f0 94       	com	r15
    505a:	e1 94       	neg	r14
    505c:	f1 08       	sbc	r15, r1
    505e:	f3 94       	inc	r15
					rprintfChar('-');
    5060:	8d e2       	ldi	r24, 0x2D	; 45
    5062:	0e 94 a3 25 	call	0x4b46	; 0x4b46 <rprintfChar>
    5066:	09 c0       	rjmp	.+18     	; 0x507a <rprintf1RamRom+0xf6>
				}
				while (div_val > 1 && div_val > u_val) div_val /= 10;
    5068:	c8 01       	movw	r24, r16
    506a:	6a e0       	ldi	r22, 0x0A	; 10
    506c:	70 e0       	ldi	r23, 0x00	; 0
    506e:	0e 94 1b 2e 	call	0x5c36	; 0x5c36 <__udivmodhi4>
    5072:	8b 01       	movw	r16, r22
    5074:	62 30       	cpi	r22, 0x02	; 2
    5076:	71 05       	cpc	r23, r1
    5078:	18 f0       	brcs	.+6      	; 0x5080 <rprintf1RamRom+0xfc>
    507a:	e0 16       	cp	r14, r16
    507c:	f1 06       	cpc	r15, r17
    507e:	a0 f3       	brcs	.-24     	; 0x5068 <rprintf1RamRom+0xe4>
			}
			do
			{
				//rprintfChar(pgm_read_byte(HexChars+(u_val/div_val)));
				rprintfu04(u_val/div_val);
    5080:	c7 01       	movw	r24, r14
    5082:	b8 01       	movw	r22, r16
    5084:	0e 94 1b 2e 	call	0x5c36	; 0x5c36 <__udivmodhi4>
    5088:	86 2f       	mov	r24, r22
    508a:	0e 94 06 26 	call	0x4c0c	; 0x4c0c <rprintfu04>
				u_val %= div_val;
    508e:	c7 01       	movw	r24, r14
    5090:	b8 01       	movw	r22, r16
    5092:	0e 94 1b 2e 	call	0x5c36	; 0x5c36 <__udivmodhi4>
    5096:	7c 01       	movw	r14, r24
				div_val /= base;
    5098:	c8 01       	movw	r24, r16
    509a:	b5 01       	movw	r22, r10
    509c:	0e 94 1b 2e 	call	0x5c36	; 0x5c36 <__udivmodhi4>
    50a0:	8b 01       	movw	r16, r22
			} while (div_val);
    50a2:	61 15       	cp	r22, r1
    50a4:	71 05       	cpc	r23, r1
    50a6:	61 f7       	brne	.-40     	; 0x5080 <rprintf1RamRom+0xfc>
    50a8:	74 01       	movw	r14, r8
    50aa:	98 cf       	rjmp	.-208    	; 0x4fdc <rprintf1RamRom+0x58>

000050ac <i2cSetBitrate>:
	// SCL freq = F_CPU/(16+2*TWBR))
	#ifdef TWPS0
		// for processors with additional bitrate division (mega128)
		// SCL freq = F_CPU/(16+2*TWBR*4^TWPS)
		// set TWPS to zero
		cbi(TWSR, TWPS0);
    50ac:	20 91 b9 00 	lds	r18, 0x00B9
    50b0:	2e 7f       	andi	r18, 0xFE	; 254
    50b2:	20 93 b9 00 	sts	0x00B9, r18
		cbi(TWSR, TWPS1);
    50b6:	20 91 b9 00 	lds	r18, 0x00B9
    50ba:	2d 7f       	andi	r18, 0xFD	; 253
    50bc:	20 93 b9 00 	sts	0x00B9, r18
	#endif
	// calculate bitrate division	
	bitrate_div = ((F_CPU/1000l)/bitrateKHz);
    50c0:	9c 01       	movw	r18, r24
    50c2:	40 e0       	ldi	r20, 0x00	; 0
    50c4:	50 e0       	ldi	r21, 0x00	; 0
    50c6:	60 e8       	ldi	r22, 0x80	; 128
    50c8:	7e e3       	ldi	r23, 0x3E	; 62
    50ca:	80 e0       	ldi	r24, 0x00	; 0
    50cc:	90 e0       	ldi	r25, 0x00	; 0
    50ce:	0e 94 64 2e 	call	0x5cc8	; 0x5cc8 <__divmodsi4>
	if(bitrate_div >= 16)
    50d2:	20 31       	cpi	r18, 0x10	; 16
    50d4:	30 f0       	brcs	.+12     	; 0x50e2 <i2cSetBitrate+0x36>
		bitrate_div = (bitrate_div-16)/2;
    50d6:	82 2f       	mov	r24, r18
    50d8:	90 e0       	ldi	r25, 0x00	; 0
    50da:	40 97       	sbiw	r24, 0x10	; 16
    50dc:	95 95       	asr	r25
    50de:	87 95       	ror	r24
    50e0:	28 2f       	mov	r18, r24
	outb(TWBR, bitrate_div);
    50e2:	20 93 b8 00 	sts	0x00B8, r18
}
    50e6:	08 95       	ret

000050e8 <i2cInit>:

// functions
void i2cInit(void)
{
	// set pull-up resistors on I2C bus pins
	sbi(PORTD, 0);	// i2c SCL on 640
    50e8:	58 9a       	sbi	0x0b, 0	; 11
	sbi(PORTD, 1);	// i2c SDA on 640
    50ea:	59 9a       	sbi	0x0b, 1	; 11

	// clear SlaveReceive and SlaveTransmit handler to null
	i2cSlaveReceive = 0;
    50ec:	10 92 31 12 	sts	0x1231, r1
    50f0:	10 92 30 12 	sts	0x1230, r1
	i2cSlaveTransmit = 0;
    50f4:	10 92 33 12 	sts	0x1233, r1
    50f8:	10 92 32 12 	sts	0x1232, r1
	// set i2c bit rate to 100KHz
	i2cSetBitrate(100);
    50fc:	84 e6       	ldi	r24, 0x64	; 100
    50fe:	90 e0       	ldi	r25, 0x00	; 0
    5100:	0e 94 56 28 	call	0x50ac	; 0x50ac <i2cSetBitrate>
	// enable TWI (two-wire interface)
	sbi(TWCR, TWEN);
    5104:	ec eb       	ldi	r30, 0xBC	; 188
    5106:	f0 e0       	ldi	r31, 0x00	; 0
    5108:	80 81       	ld	r24, Z
    510a:	84 60       	ori	r24, 0x04	; 4
    510c:	80 83       	st	Z, r24
	// set state
	I2cState = I2C_IDLE;
    510e:	10 92 ea 11 	sts	0x11EA, r1
	// enable TWI interrupt and slave address ACK
	sbi(TWCR, TWIE);
    5112:	80 81       	ld	r24, Z
    5114:	81 60       	ori	r24, 0x01	; 1
    5116:	80 83       	st	Z, r24
	sbi(TWCR, TWEA);
    5118:	80 81       	ld	r24, Z
    511a:	80 64       	ori	r24, 0x40	; 64
    511c:	80 83       	st	Z, r24
	//outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
	// enable interrupts
	sei();
    511e:	78 94       	sei
}
    5120:	08 95       	ret

00005122 <i2cSetLocalDeviceAddr>:
}

void i2cSetLocalDeviceAddr(u08 deviceAddr, u08 genCallEn)
{
	// set local device address (used in slave mode only)
	outb(TWAR, ((deviceAddr&0xFE) | (genCallEn?1:0)) );
    5122:	90 e0       	ldi	r25, 0x00	; 0
    5124:	61 11       	cpse	r22, r1
    5126:	91 e0       	ldi	r25, 0x01	; 1
    5128:	8e 7f       	andi	r24, 0xFE	; 254
    512a:	98 2b       	or	r25, r24
    512c:	90 93 ba 00 	sts	0x00BA, r25
}
    5130:	08 95       	ret

00005132 <i2cSetSlaveReceiveHandler>:

void i2cSetSlaveReceiveHandler(void (*i2cSlaveRx_func)(u08 receiveDataLength, u08* recieveData))
{
	i2cSlaveReceive = i2cSlaveRx_func;
    5132:	90 93 31 12 	sts	0x1231, r25
    5136:	80 93 30 12 	sts	0x1230, r24
}
    513a:	08 95       	ret

0000513c <i2cSetSlaveTransmitHandler>:

void i2cSetSlaveTransmitHandler(u08 (*i2cSlaveTx_func)(u08 transmitDataLengthMax, u08* transmitData))
{
	i2cSlaveTransmit = i2cSlaveTx_func;
    513c:	90 93 33 12 	sts	0x1233, r25
    5140:	80 93 32 12 	sts	0x1232, r24
}
    5144:	08 95       	ret

00005146 <i2cSendStart>:

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    5146:	ec eb       	ldi	r30, 0xBC	; 188
    5148:	f0 e0       	ldi	r31, 0x00	; 0
    514a:	80 81       	ld	r24, Z
    514c:	8f 70       	andi	r24, 0x0F	; 15
    514e:	80 6a       	ori	r24, 0xA0	; 160
    5150:	80 83       	st	Z, r24
}
    5152:	08 95       	ret

00005154 <i2cSendStop>:

inline void i2cSendStop(void)
{
	// transmit stop condition
	// leave with TWEA on for slave receiving
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA)|BV(TWSTO));
    5154:	ec eb       	ldi	r30, 0xBC	; 188
    5156:	f0 e0       	ldi	r31, 0x00	; 0
    5158:	80 81       	ld	r24, Z
    515a:	8f 70       	andi	r24, 0x0F	; 15
    515c:	80 6d       	ori	r24, 0xD0	; 208
    515e:	80 83       	st	Z, r24
}
    5160:	08 95       	ret

00005162 <i2cWaitForComplete>:

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    5162:	80 91 bc 00 	lds	r24, 0x00BC
    5166:	87 ff       	sbrs	r24, 7
    5168:	fc cf       	rjmp	.-8      	; 0x5162 <i2cWaitForComplete>
}
    516a:	08 95       	ret

0000516c <i2cSendByte>:

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    516c:	80 93 bb 00 	sts	0x00BB, r24
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    5170:	ec eb       	ldi	r30, 0xBC	; 188
    5172:	f0 e0       	ldi	r31, 0x00	; 0
    5174:	80 81       	ld	r24, Z
    5176:	8f 70       	andi	r24, 0x0F	; 15
    5178:	80 68       	ori	r24, 0x80	; 128
    517a:	80 83       	st	Z, r24
}
    517c:	08 95       	ret

0000517e <i2cReceiveByte>:

inline void i2cReceiveByte(u08 ackFlag)
{
	// begin receive over i2c
	if( ackFlag )
    517e:	88 23       	and	r24, r24
    5180:	29 f0       	breq	.+10     	; 0x518c <i2cReceiveByte+0xe>
	{
		// ackFlag = TRUE: ACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    5182:	80 91 bc 00 	lds	r24, 0x00BC
    5186:	8f 70       	andi	r24, 0x0F	; 15
    5188:	80 6c       	ori	r24, 0xC0	; 192
    518a:	04 c0       	rjmp	.+8      	; 0x5194 <i2cReceiveByte+0x16>
	}
	else
	{
		// ackFlag = FALSE: NACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    518c:	80 91 bc 00 	lds	r24, 0x00BC
    5190:	8f 70       	andi	r24, 0x0F	; 15
    5192:	80 68       	ori	r24, 0x80	; 128
    5194:	80 93 bc 00 	sts	0x00BC, r24
    5198:	08 95       	ret

0000519a <i2cGetReceivedByte>:
}

inline u08 i2cGetReceivedByte(void)
{
	// retieve received data byte from i2c TWDR
	return( inb(TWDR) );
    519a:	80 91 bb 00 	lds	r24, 0x00BB
}
    519e:	08 95       	ret

000051a0 <i2cGetStatus>:

inline u08 i2cGetStatus(void)
{
	// retieve current i2c status from i2c TWSR
	return( inb(TWSR) );
    51a0:	80 91 b9 00 	lds	r24, 0x00B9
}
    51a4:	08 95       	ret

000051a6 <i2cMasterSend>:

void i2cMasterSend(u08 deviceAddr, u08 length, u08* data)
{
    51a6:	98 2f       	mov	r25, r24
	u08 i;
	// wait for interface to be ready
	while(I2cState);
    51a8:	80 91 ea 11 	lds	r24, 0x11EA
    51ac:	88 23       	and	r24, r24
    51ae:	e1 f7       	brne	.-8      	; 0x51a8 <i2cMasterSend+0x2>
	// set state
	I2cState = I2C_MASTER_TX;
    51b0:	82 e0       	ldi	r24, 0x02	; 2
    51b2:	80 93 ea 11 	sts	0x11EA, r24
	// save data
	I2cDeviceAddrRW = (deviceAddr & 0xFE);	// RW cleared: write operation
    51b6:	9e 7f       	andi	r25, 0xFE	; 254
    51b8:	90 93 eb 11 	sts	0x11EB, r25
    51bc:	ac ee       	ldi	r26, 0xEC	; 236
    51be:	b1 e1       	ldi	r27, 0x11	; 17
    51c0:	fa 01       	movw	r30, r20
    51c2:	02 c0       	rjmp	.+4      	; 0x51c8 <i2cMasterSend+0x22>
	for(i=0; i<length; i++)
		I2cSendData[i] = *data++;
    51c4:	81 91       	ld	r24, Z+
    51c6:	8d 93       	st	X+, r24
	while(I2cState);
	// set state
	I2cState = I2C_MASTER_TX;
	// save data
	I2cDeviceAddrRW = (deviceAddr & 0xFE);	// RW cleared: write operation
	for(i=0; i<length; i++)
    51c8:	8e 2f       	mov	r24, r30
    51ca:	84 1b       	sub	r24, r20
    51cc:	86 17       	cp	r24, r22
    51ce:	d0 f3       	brcs	.-12     	; 0x51c4 <i2cMasterSend+0x1e>
		I2cSendData[i] = *data++;
	I2cSendDataIndex = 0;
    51d0:	10 92 0c 12 	sts	0x120C, r1
	I2cSendDataLength = length;
    51d4:	60 93 0d 12 	sts	0x120D, r22
}

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    51d8:	80 91 bc 00 	lds	r24, 0x00BC
    51dc:	8f 70       	andi	r24, 0x0F	; 15
    51de:	80 6a       	ori	r24, 0xA0	; 160
    51e0:	80 93 bc 00 	sts	0x00BC, r24
		I2cSendData[i] = *data++;
	I2cSendDataIndex = 0;
	I2cSendDataLength = length;
	// send start condition
	i2cSendStart();
}
    51e4:	08 95       	ret

000051e6 <i2cMasterReceive>:

void i2cMasterReceive(u08 deviceAddr, u08 length, u08* data)
{
    51e6:	98 2f       	mov	r25, r24
	u08 i;
	// wait for interface to be ready
	while(I2cState);
    51e8:	80 91 ea 11 	lds	r24, 0x11EA
    51ec:	88 23       	and	r24, r24
    51ee:	e1 f7       	brne	.-8      	; 0x51e8 <i2cMasterReceive+0x2>
	// set state
	I2cState = I2C_MASTER_RX;
    51f0:	83 e0       	ldi	r24, 0x03	; 3
    51f2:	80 93 ea 11 	sts	0x11EA, r24
	// save data
	I2cDeviceAddrRW = (deviceAddr|0x01);	// RW set: read operation
    51f6:	91 60       	ori	r25, 0x01	; 1
    51f8:	90 93 eb 11 	sts	0x11EB, r25
	I2cReceiveDataIndex = 0;
    51fc:	10 92 2e 12 	sts	0x122E, r1
	I2cReceiveDataLength = length;
    5200:	60 93 2f 12 	sts	0x122F, r22
}

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    5204:	80 91 bc 00 	lds	r24, 0x00BC
    5208:	8f 70       	andi	r24, 0x0F	; 15
    520a:	80 6a       	ori	r24, 0xA0	; 160
    520c:	80 93 bc 00 	sts	0x00BC, r24
	I2cReceiveDataIndex = 0;
	I2cReceiveDataLength = length;
	// send start condition
	i2cSendStart();
	// wait for data
	while(I2cState);
    5210:	80 91 ea 11 	lds	r24, 0x11EA
    5214:	88 23       	and	r24, r24
    5216:	e1 f7       	brne	.-8      	; 0x5210 <i2cMasterReceive+0x2a>
    5218:	ae e0       	ldi	r26, 0x0E	; 14
    521a:	b2 e1       	ldi	r27, 0x12	; 18
    521c:	fa 01       	movw	r30, r20
    521e:	02 c0       	rjmp	.+4      	; 0x5224 <i2cMasterReceive+0x3e>
	// return data
	for(i=0; i<length; i++)
		*data++ = I2cReceiveData[i];
    5220:	8d 91       	ld	r24, X+
    5222:	81 93       	st	Z+, r24
	// send start condition
	i2cSendStart();
	// wait for data
	while(I2cState);
	// return data
	for(i=0; i<length; i++)
    5224:	8e 2f       	mov	r24, r30
    5226:	84 1b       	sub	r24, r20
    5228:	86 17       	cp	r24, r22
    522a:	d0 f3       	brcs	.-12     	; 0x5220 <i2cMasterReceive+0x3a>
		*data++ = I2cReceiveData[i];
}
    522c:	08 95       	ret

0000522e <i2cMasterSendNI>:

u08 i2cMasterSendNI(u08 deviceAddr, u08 length, u08* data)
{
    522e:	98 2f       	mov	r25, r24
    5230:	fa 01       	movw	r30, r20
	u08 retval = I2C_OK;

	// disable TWI interrupt
	cbi(TWCR, TWIE);
    5232:	80 91 bc 00 	lds	r24, 0x00BC
    5236:	8e 7f       	andi	r24, 0xFE	; 254
    5238:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    523c:	80 91 bc 00 	lds	r24, 0x00BC
    5240:	8f 70       	andi	r24, 0x0F	; 15
    5242:	80 6a       	ori	r24, 0xA0	; 160
    5244:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    5248:	80 91 bc 00 	lds	r24, 0x00BC
    524c:	87 ff       	sbrs	r24, 7
    524e:	fc cf       	rjmp	.-8      	; 0x5248 <i2cMasterSendNI+0x1a>
	// send start condition
	i2cSendStart();
	i2cWaitForComplete();

	// send device address with write
	i2cSendByte( deviceAddr & 0xFE );
    5250:	9e 7f       	andi	r25, 0xFE	; 254
}

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    5252:	90 93 bb 00 	sts	0x00BB, r25
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    5256:	80 91 bc 00 	lds	r24, 0x00BC
    525a:	8f 70       	andi	r24, 0x0F	; 15
    525c:	80 68       	ori	r24, 0x80	; 128
    525e:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    5262:	80 91 bc 00 	lds	r24, 0x00BC
    5266:	87 ff       	sbrs	r24, 7
    5268:	fc cf       	rjmp	.-8      	; 0x5262 <i2cMasterSendNI+0x34>
	// send device address with write
	i2cSendByte( deviceAddr & 0xFE );
	i2cWaitForComplete();

	// check if device is present and live
	if( inb(TWSR) == TW_MT_SLA_ACK)
    526a:	80 91 b9 00 	lds	r24, 0x00B9
    526e:	88 31       	cpi	r24, 0x18	; 24
    5270:	89 f0       	breq	.+34     	; 0x5294 <i2cMasterSendNI+0x66>
    5272:	91 e0       	ldi	r25, 0x01	; 1
    5274:	12 c0       	rjmp	.+36     	; 0x529a <i2cMasterSendNI+0x6c>
	{
		// send data
		while(length)
		{
			i2cSendByte( *data++ );
    5276:	80 81       	ld	r24, Z
}

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    5278:	80 93 bb 00 	sts	0x00BB, r24
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    527c:	80 91 bc 00 	lds	r24, 0x00BC
    5280:	8f 70       	andi	r24, 0x0F	; 15
    5282:	80 68       	ori	r24, 0x80	; 128
    5284:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    5288:	80 91 bc 00 	lds	r24, 0x00BC
    528c:	87 ff       	sbrs	r24, 7
    528e:	fc cf       	rjmp	.-8      	; 0x5288 <i2cMasterSendNI+0x5a>
	if( inb(TWSR) == TW_MT_SLA_ACK)
	{
		// send data
		while(length)
		{
			i2cSendByte( *data++ );
    5290:	31 96       	adiw	r30, 0x01	; 1
			i2cWaitForComplete();
			length--;
    5292:	61 50       	subi	r22, 0x01	; 1

	// check if device is present and live
	if( inb(TWSR) == TW_MT_SLA_ACK)
	{
		// send data
		while(length)
    5294:	66 23       	and	r22, r22
    5296:	79 f7       	brne	.-34     	; 0x5276 <i2cMasterSendNI+0x48>
    5298:	90 e0       	ldi	r25, 0x00	; 0

inline void i2cSendStop(void)
{
	// transmit stop condition
	// leave with TWEA on for slave receiving
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA)|BV(TWSTO));
    529a:	80 91 bc 00 	lds	r24, 0x00BC
    529e:	8f 70       	andi	r24, 0x0F	; 15
    52a0:	80 6d       	ori	r24, 0xD0	; 208
    52a2:	80 93 bc 00 	sts	0x00BC, r24
	}

	// transmit stop condition
	// leave with TWEA on for slave receiving
	i2cSendStop();
	while( !(inb(TWCR) & BV(TWSTO)) );
    52a6:	80 91 bc 00 	lds	r24, 0x00BC
    52aa:	84 ff       	sbrs	r24, 4
    52ac:	fc cf       	rjmp	.-8      	; 0x52a6 <i2cMasterSendNI+0x78>

	// enable TWI interrupt
	sbi(TWCR, TWIE);
    52ae:	80 91 bc 00 	lds	r24, 0x00BC
    52b2:	81 60       	ori	r24, 0x01	; 1
    52b4:	80 93 bc 00 	sts	0x00BC, r24

	return retval;
}
    52b8:	89 2f       	mov	r24, r25
    52ba:	08 95       	ret

000052bc <i2cMasterReceiveNI>:

u08 i2cMasterReceiveNI(u08 deviceAddr, u08 length, u08 *data)
{
    52bc:	98 2f       	mov	r25, r24
    52be:	fa 01       	movw	r30, r20
	u08 retval = I2C_OK;

	// disable TWI interrupt
	cbi(TWCR, TWIE);
    52c0:	80 91 bc 00 	lds	r24, 0x00BC
    52c4:	8e 7f       	andi	r24, 0xFE	; 254
    52c6:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    52ca:	80 91 bc 00 	lds	r24, 0x00BC
    52ce:	8f 70       	andi	r24, 0x0F	; 15
    52d0:	80 6a       	ori	r24, 0xA0	; 160
    52d2:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    52d6:	80 91 bc 00 	lds	r24, 0x00BC
    52da:	87 ff       	sbrs	r24, 7
    52dc:	fc cf       	rjmp	.-8      	; 0x52d6 <i2cMasterReceiveNI+0x1a>
	// send start condition
	i2cSendStart();
	i2cWaitForComplete();

	// send device address with read
	i2cSendByte( deviceAddr | 0x01 );
    52de:	91 60       	ori	r25, 0x01	; 1
}

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    52e0:	90 93 bb 00 	sts	0x00BB, r25
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    52e4:	80 91 bc 00 	lds	r24, 0x00BC
    52e8:	8f 70       	andi	r24, 0x0F	; 15
    52ea:	80 68       	ori	r24, 0x80	; 128
    52ec:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    52f0:	80 91 bc 00 	lds	r24, 0x00BC
    52f4:	87 ff       	sbrs	r24, 7
    52f6:	fc cf       	rjmp	.-8      	; 0x52f0 <i2cMasterReceiveNI+0x34>
	// send device address with read
	i2cSendByte( deviceAddr | 0x01 );
	i2cWaitForComplete();

	// check if device is present and live
	if( inb(TWSR) == TW_MR_SLA_ACK)
    52f8:	80 91 b9 00 	lds	r24, 0x00B9
    52fc:	80 34       	cpi	r24, 0x40	; 64
    52fe:	81 f0       	breq	.+32     	; 0x5320 <i2cMasterReceiveNI+0x64>
    5300:	91 e0       	ldi	r25, 0x01	; 1
    5302:	1e c0       	rjmp	.+60     	; 0x5340 <i2cMasterReceiveNI+0x84>
{
	// begin receive over i2c
	if( ackFlag )
	{
		// ackFlag = TRUE: ACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    5304:	80 91 bc 00 	lds	r24, 0x00BC
    5308:	8f 70       	andi	r24, 0x0F	; 15
    530a:	80 6c       	ori	r24, 0xC0	; 192
    530c:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    5310:	80 91 bc 00 	lds	r24, 0x00BC
    5314:	87 ff       	sbrs	r24, 7
    5316:	fc cf       	rjmp	.-8      	; 0x5310 <i2cMasterReceiveNI+0x54>
}

inline u08 i2cGetReceivedByte(void)
{
	// retieve received data byte from i2c TWDR
	return( inb(TWDR) );
    5318:	80 91 bb 00 	lds	r24, 0x00BB
		// accept receive data and ack it
		while(length > 1)
		{
			i2cReceiveByte(TRUE);
			i2cWaitForComplete();
			*data++ = i2cGetReceivedByte();
    531c:	81 93       	st	Z+, r24
			// decrement length
			length--;
    531e:	61 50       	subi	r22, 0x01	; 1

	// check if device is present and live
	if( inb(TWSR) == TW_MR_SLA_ACK)
	{
		// accept receive data and ack it
		while(length > 1)
    5320:	62 30       	cpi	r22, 0x02	; 2
    5322:	80 f7       	brcc	.-32     	; 0x5304 <i2cMasterReceiveNI+0x48>
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
	}
	else
	{
		// ackFlag = FALSE: NACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    5324:	80 91 bc 00 	lds	r24, 0x00BC
    5328:	8f 70       	andi	r24, 0x0F	; 15
    532a:	80 68       	ori	r24, 0x80	; 128
    532c:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    5330:	80 91 bc 00 	lds	r24, 0x00BC
    5334:	87 ff       	sbrs	r24, 7
    5336:	fc cf       	rjmp	.-8      	; 0x5330 <i2cMasterReceiveNI+0x74>
}

inline u08 i2cGetReceivedByte(void)
{
	// retieve received data byte from i2c TWDR
	return( inb(TWDR) );
    5338:	80 91 bb 00 	lds	r24, 0x00BB
		}

		// accept receive data and nack it (last-byte signal)
		i2cReceiveByte(FALSE);
		i2cWaitForComplete();
		*data++ = i2cGetReceivedByte();
    533c:	80 83       	st	Z, r24
    533e:	90 e0       	ldi	r25, 0x00	; 0

inline void i2cSendStop(void)
{
	// transmit stop condition
	// leave with TWEA on for slave receiving
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA)|BV(TWSTO));
    5340:	80 91 bc 00 	lds	r24, 0x00BC
    5344:	8f 70       	andi	r24, 0x0F	; 15
    5346:	80 6d       	ori	r24, 0xD0	; 208
    5348:	80 93 bc 00 	sts	0x00BC, r24
	// transmit stop condition
	// leave with TWEA on for slave receiving
	i2cSendStop();

	// enable TWI interrupt
	sbi(TWCR, TWIE);
    534c:	80 91 bc 00 	lds	r24, 0x00BC
    5350:	81 60       	ori	r24, 0x01	; 1
    5352:	80 93 bc 00 	sts	0x00BC, r24

	return retval;
}
    5356:	89 2f       	mov	r24, r25
    5358:	08 95       	ret

0000535a <__vector_39>:
}
*/

//! I2C (TWI) interrupt service routine
SIGNAL(SIG_2WIRE_SERIAL)
{
    535a:	1f 92       	push	r1
    535c:	0f 92       	push	r0
    535e:	0f b6       	in	r0, 0x3f	; 63
    5360:	0f 92       	push	r0
    5362:	11 24       	eor	r1, r1
    5364:	2f 93       	push	r18
    5366:	3f 93       	push	r19
    5368:	4f 93       	push	r20
    536a:	5f 93       	push	r21
    536c:	6f 93       	push	r22
    536e:	7f 93       	push	r23
    5370:	8f 93       	push	r24
    5372:	9f 93       	push	r25
    5374:	af 93       	push	r26
    5376:	bf 93       	push	r27
    5378:	ef 93       	push	r30
    537a:	ff 93       	push	r31
	// read status bits
	u08 status = inb(TWSR) & TWSR_STATUS_MASK;
    537c:	80 91 b9 00 	lds	r24, 0x00B9

	switch(status)
    5380:	88 7f       	andi	r24, 0xF8	; 248
    5382:	80 36       	cpi	r24, 0x60	; 96
    5384:	09 f4       	brne	.+2      	; 0x5388 <__vector_39+0x2e>
    5386:	a0 c0       	rjmp	.+320    	; 0x54c8 <__vector_39+0x16e>
    5388:	81 36       	cpi	r24, 0x61	; 97
    538a:	70 f5       	brcc	.+92     	; 0x53e8 <__vector_39+0x8e>
    538c:	88 32       	cpi	r24, 0x28	; 40
    538e:	09 f4       	brne	.+2      	; 0x5392 <__vector_39+0x38>
    5390:	5f c0       	rjmp	.+190    	; 0x5450 <__vector_39+0xf6>
    5392:	89 32       	cpi	r24, 0x29	; 41
    5394:	98 f4       	brcc	.+38     	; 0x53bc <__vector_39+0x62>
    5396:	80 31       	cpi	r24, 0x10	; 16
    5398:	09 f4       	brne	.+2      	; 0x539c <__vector_39+0x42>
    539a:	57 c0       	rjmp	.+174    	; 0x544a <__vector_39+0xf0>
    539c:	81 31       	cpi	r24, 0x11	; 17
    539e:	38 f4       	brcc	.+14     	; 0x53ae <__vector_39+0x54>
    53a0:	88 23       	and	r24, r24
    53a2:	09 f4       	brne	.+2      	; 0x53a6 <__vector_39+0x4c>
    53a4:	ea c0       	rjmp	.+468    	; 0x557a <__vector_39+0x220>
    53a6:	88 30       	cpi	r24, 0x08	; 8
    53a8:	09 f0       	breq	.+2      	; 0x53ac <__vector_39+0x52>
    53aa:	ef c0       	rjmp	.+478    	; 0x558a <__vector_39+0x230>
    53ac:	4e c0       	rjmp	.+156    	; 0x544a <__vector_39+0xf0>
    53ae:	88 31       	cpi	r24, 0x18	; 24
    53b0:	09 f4       	brne	.+2      	; 0x53b4 <__vector_39+0x5a>
    53b2:	4e c0       	rjmp	.+156    	; 0x5450 <__vector_39+0xf6>
    53b4:	80 32       	cpi	r24, 0x20	; 32
    53b6:	09 f0       	breq	.+2      	; 0x53ba <__vector_39+0x60>
    53b8:	e8 c0       	rjmp	.+464    	; 0x558a <__vector_39+0x230>
    53ba:	df c0       	rjmp	.+446    	; 0x557a <__vector_39+0x220>
    53bc:	80 34       	cpi	r24, 0x40	; 64
    53be:	09 f4       	brne	.+2      	; 0x53c2 <__vector_39+0x68>
    53c0:	77 c0       	rjmp	.+238    	; 0x54b0 <__vector_39+0x156>
    53c2:	81 34       	cpi	r24, 0x41	; 65
    53c4:	38 f4       	brcc	.+14     	; 0x53d4 <__vector_39+0x7a>
    53c6:	80 33       	cpi	r24, 0x30	; 48
    53c8:	09 f4       	brne	.+2      	; 0x53cc <__vector_39+0x72>
    53ca:	d7 c0       	rjmp	.+430    	; 0x557a <__vector_39+0x220>
    53cc:	88 33       	cpi	r24, 0x38	; 56
    53ce:	09 f0       	breq	.+2      	; 0x53d2 <__vector_39+0x78>
    53d0:	dc c0       	rjmp	.+440    	; 0x558a <__vector_39+0x230>
    53d2:	5d c0       	rjmp	.+186    	; 0x548e <__vector_39+0x134>
    53d4:	80 35       	cpi	r24, 0x50	; 80
    53d6:	09 f4       	brne	.+2      	; 0x53da <__vector_39+0x80>
    53d8:	5f c0       	rjmp	.+190    	; 0x5498 <__vector_39+0x13e>
    53da:	88 35       	cpi	r24, 0x58	; 88
    53dc:	09 f4       	brne	.+2      	; 0x53e0 <__vector_39+0x86>
    53de:	4a c0       	rjmp	.+148    	; 0x5474 <__vector_39+0x11a>
    53e0:	88 34       	cpi	r24, 0x48	; 72
    53e2:	09 f0       	breq	.+2      	; 0x53e6 <__vector_39+0x8c>
    53e4:	d2 c0       	rjmp	.+420    	; 0x558a <__vector_39+0x230>
    53e6:	c9 c0       	rjmp	.+402    	; 0x557a <__vector_39+0x220>
    53e8:	88 39       	cpi	r24, 0x98	; 152
    53ea:	09 f4       	brne	.+2      	; 0x53ee <__vector_39+0x94>
    53ec:	ba c0       	rjmp	.+372    	; 0x5562 <__vector_39+0x208>
    53ee:	89 39       	cpi	r24, 0x99	; 153
    53f0:	b0 f4       	brcc	.+44     	; 0x541e <__vector_39+0xc4>
    53f2:	88 37       	cpi	r24, 0x78	; 120
    53f4:	09 f4       	brne	.+2      	; 0x53f8 <__vector_39+0x9e>
    53f6:	68 c0       	rjmp	.+208    	; 0x54c8 <__vector_39+0x16e>
    53f8:	89 37       	cpi	r24, 0x79	; 121
    53fa:	38 f4       	brcc	.+14     	; 0x540a <__vector_39+0xb0>
    53fc:	88 36       	cpi	r24, 0x68	; 104
    53fe:	09 f4       	brne	.+2      	; 0x5402 <__vector_39+0xa8>
    5400:	63 c0       	rjmp	.+198    	; 0x54c8 <__vector_39+0x16e>
    5402:	80 37       	cpi	r24, 0x70	; 112
    5404:	09 f0       	breq	.+2      	; 0x5408 <__vector_39+0xae>
    5406:	c1 c0       	rjmp	.+386    	; 0x558a <__vector_39+0x230>
    5408:	5f c0       	rjmp	.+190    	; 0x54c8 <__vector_39+0x16e>
    540a:	88 38       	cpi	r24, 0x88	; 136
    540c:	09 f4       	brne	.+2      	; 0x5410 <__vector_39+0xb6>
    540e:	a9 c0       	rjmp	.+338    	; 0x5562 <__vector_39+0x208>
    5410:	80 39       	cpi	r24, 0x90	; 144
    5412:	09 f4       	brne	.+2      	; 0x5416 <__vector_39+0xbc>
    5414:	5f c0       	rjmp	.+190    	; 0x54d4 <__vector_39+0x17a>
    5416:	80 38       	cpi	r24, 0x80	; 128
    5418:	09 f0       	breq	.+2      	; 0x541c <__vector_39+0xc2>
    541a:	b7 c0       	rjmp	.+366    	; 0x558a <__vector_39+0x230>
    541c:	5b c0       	rjmp	.+182    	; 0x54d4 <__vector_39+0x17a>
    541e:	80 3b       	cpi	r24, 0xB0	; 176
    5420:	09 f4       	brne	.+2      	; 0x5424 <__vector_39+0xca>
    5422:	79 c0       	rjmp	.+242    	; 0x5516 <__vector_39+0x1bc>
    5424:	81 3b       	cpi	r24, 0xB1	; 177
    5426:	38 f4       	brcc	.+14     	; 0x5436 <__vector_39+0xdc>
    5428:	80 3a       	cpi	r24, 0xA0	; 160
    542a:	09 f4       	brne	.+2      	; 0x542e <__vector_39+0xd4>
    542c:	62 c0       	rjmp	.+196    	; 0x54f2 <__vector_39+0x198>
    542e:	88 3a       	cpi	r24, 0xA8	; 168
    5430:	09 f0       	breq	.+2      	; 0x5434 <__vector_39+0xda>
    5432:	ab c0       	rjmp	.+342    	; 0x558a <__vector_39+0x230>
    5434:	70 c0       	rjmp	.+224    	; 0x5516 <__vector_39+0x1bc>
    5436:	80 3c       	cpi	r24, 0xC0	; 192
    5438:	09 f4       	brne	.+2      	; 0x543c <__vector_39+0xe2>
    543a:	9a c0       	rjmp	.+308    	; 0x5570 <__vector_39+0x216>
    543c:	88 3c       	cpi	r24, 0xC8	; 200
    543e:	09 f4       	brne	.+2      	; 0x5442 <__vector_39+0xe8>
    5440:	97 c0       	rjmp	.+302    	; 0x5570 <__vector_39+0x216>
    5442:	88 3b       	cpi	r24, 0xB8	; 184
    5444:	09 f0       	breq	.+2      	; 0x5448 <__vector_39+0xee>
    5446:	a1 c0       	rjmp	.+322    	; 0x558a <__vector_39+0x230>
    5448:	77 c0       	rjmp	.+238    	; 0x5538 <__vector_39+0x1de>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: M->START\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// send device address
		i2cSendByte(I2cDeviceAddrRW);
    544a:	80 91 eb 11 	lds	r24, 0x11EB
    544e:	0f c0       	rjmp	.+30     	; 0x546e <__vector_39+0x114>
		#ifdef I2C_DEBUG
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MT->SLA_ACK or DATA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		if(I2cSendDataIndex < I2cSendDataLength)
    5450:	90 91 0c 12 	lds	r25, 0x120C
    5454:	80 91 0d 12 	lds	r24, 0x120D
    5458:	98 17       	cp	r25, r24
    545a:	08 f0       	brcs	.+2      	; 0x545e <__vector_39+0x104>
    545c:	8e c0       	rjmp	.+284    	; 0x557a <__vector_39+0x220>
		{
			// send data
			i2cSendByte( I2cSendData[I2cSendDataIndex++] );
    545e:	e9 2f       	mov	r30, r25
    5460:	f0 e0       	ldi	r31, 0x00	; 0
    5462:	e4 51       	subi	r30, 0x14	; 20
    5464:	fe 4e       	sbci	r31, 0xEE	; 238
    5466:	80 81       	ld	r24, Z
    5468:	9f 5f       	subi	r25, 0xFF	; 255
    546a:	90 93 0c 12 	sts	0x120C, r25
}

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    546e:	80 93 bb 00 	sts	0x00BB, r24
    5472:	77 c0       	rjmp	.+238    	; 0x5562 <__vector_39+0x208>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MR->DATA_NACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// store final received data byte
		I2cReceiveData[I2cReceiveDataIndex++] = inb(TWDR);
    5474:	80 91 2e 12 	lds	r24, 0x122E
    5478:	90 91 bb 00 	lds	r25, 0x00BB
    547c:	e8 2f       	mov	r30, r24
    547e:	f0 e0       	ldi	r31, 0x00	; 0
    5480:	e2 5f       	subi	r30, 0xF2	; 242
    5482:	fd 4e       	sbci	r31, 0xED	; 237
    5484:	90 83       	st	Z, r25
    5486:	8f 5f       	subi	r24, 0xFF	; 255
    5488:	80 93 2e 12 	sts	0x122E, r24
    548c:	76 c0       	rjmp	.+236    	; 0x557a <__vector_39+0x220>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MT->ARB_LOST\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// release bus
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    548e:	80 91 bc 00 	lds	r24, 0x00BC
    5492:	8f 70       	andi	r24, 0x0F	; 15
    5494:	80 68       	ori	r24, 0x80	; 128
    5496:	75 c0       	rjmp	.+234    	; 0x5582 <__vector_39+0x228>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MR->DATA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// store received data byte
		I2cReceiveData[I2cReceiveDataIndex++] = inb(TWDR);
    5498:	80 91 2e 12 	lds	r24, 0x122E
    549c:	90 91 bb 00 	lds	r25, 0x00BB
    54a0:	e8 2f       	mov	r30, r24
    54a2:	f0 e0       	ldi	r31, 0x00	; 0
    54a4:	e2 5f       	subi	r30, 0xF2	; 242
    54a6:	fd 4e       	sbci	r31, 0xED	; 237
    54a8:	90 83       	st	Z, r25
    54aa:	8f 5f       	subi	r24, 0xFF	; 255
    54ac:	80 93 2e 12 	sts	0x122E, r24
		#ifdef I2C_DEBUG
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MR->SLA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		if(I2cReceiveDataIndex < (I2cReceiveDataLength-1))
    54b0:	20 91 2e 12 	lds	r18, 0x122E
    54b4:	30 e0       	ldi	r19, 0x00	; 0
    54b6:	80 91 2f 12 	lds	r24, 0x122F
    54ba:	90 e0       	ldi	r25, 0x00	; 0
    54bc:	01 97       	sbiw	r24, 0x01	; 1
    54be:	28 17       	cp	r18, r24
    54c0:	39 07       	cpc	r19, r25
    54c2:	0c f0       	brlt	.+2      	; 0x54c6 <__vector_39+0x16c>
    54c4:	4e c0       	rjmp	.+156    	; 0x5562 <__vector_39+0x208>
    54c6:	48 c0       	rjmp	.+144    	; 0x5558 <__vector_39+0x1fe>
		rprintf("I2C: SR->SLA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// we are being addressed as slave for writing (data will be received from master)
		// set state
		I2cState = I2C_SLAVE_RX;
    54c8:	85 e0       	ldi	r24, 0x05	; 5
    54ca:	80 93 ea 11 	sts	0x11EA, r24
		// prepare buffer
		I2cReceiveDataIndex = 0;
    54ce:	10 92 2e 12 	sts	0x122E, r1
    54d2:	42 c0       	rjmp	.+132    	; 0x5558 <__vector_39+0x1fe>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: SR->DATA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// get previously received data byte
		I2cReceiveData[I2cReceiveDataIndex++] = inb(TWDR);
    54d4:	80 91 2e 12 	lds	r24, 0x122E
    54d8:	90 91 bb 00 	lds	r25, 0x00BB
    54dc:	e8 2f       	mov	r30, r24
    54de:	f0 e0       	ldi	r31, 0x00	; 0
    54e0:	e2 5f       	subi	r30, 0xF2	; 242
    54e2:	fd 4e       	sbci	r31, 0xED	; 237
    54e4:	90 83       	st	Z, r25
    54e6:	8f 5f       	subi	r24, 0xFF	; 255
    54e8:	80 93 2e 12 	sts	0x122E, r24
		// check receive buffer status
		if(I2cReceiveDataIndex < I2C_RECEIVE_DATA_BUFFER_SIZE)
    54ec:	80 32       	cpi	r24, 0x20	; 32
    54ee:	c8 f5       	brcc	.+114    	; 0x5562 <__vector_39+0x208>
    54f0:	33 c0       	rjmp	.+102    	; 0x5558 <__vector_39+0x1fe>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: SR->SR_STOP\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// switch to SR mode with SLA ACK
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    54f2:	80 91 bc 00 	lds	r24, 0x00BC
    54f6:	8f 70       	andi	r24, 0x0F	; 15
    54f8:	80 6c       	ori	r24, 0xC0	; 192
    54fa:	80 93 bc 00 	sts	0x00BC, r24
		// i2c receive is complete, call i2cSlaveReceive
		if(i2cSlaveReceive) i2cSlaveReceive(I2cReceiveDataIndex, I2cReceiveData);
    54fe:	e0 91 30 12 	lds	r30, 0x1230
    5502:	f0 91 31 12 	lds	r31, 0x1231
    5506:	30 97       	sbiw	r30, 0x00	; 0
    5508:	f1 f1       	breq	.+124    	; 0x5586 <__vector_39+0x22c>
    550a:	80 91 2e 12 	lds	r24, 0x122E
    550e:	6e e0       	ldi	r22, 0x0E	; 14
    5510:	72 e1       	ldi	r23, 0x12	; 18
    5512:	09 95       	icall
    5514:	38 c0       	rjmp	.+112    	; 0x5586 <__vector_39+0x22c>
		rprintf("I2C: ST->SLA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// we are being addressed as slave for reading (data must be transmitted back to master)
		// set state
		I2cState = I2C_SLAVE_TX;
    5516:	84 e0       	ldi	r24, 0x04	; 4
    5518:	80 93 ea 11 	sts	0x11EA, r24
		// request data from application
		if(i2cSlaveTransmit) I2cSendDataLength = i2cSlaveTransmit(I2C_SEND_DATA_BUFFER_SIZE, I2cSendData);
    551c:	e0 91 32 12 	lds	r30, 0x1232
    5520:	f0 91 33 12 	lds	r31, 0x1233
    5524:	30 97       	sbiw	r30, 0x00	; 0
    5526:	31 f0       	breq	.+12     	; 0x5534 <__vector_39+0x1da>
    5528:	80 e2       	ldi	r24, 0x20	; 32
    552a:	6c ee       	ldi	r22, 0xEC	; 236
    552c:	71 e1       	ldi	r23, 0x11	; 17
    552e:	09 95       	icall
    5530:	80 93 0d 12 	sts	0x120D, r24
		// reset data index
		I2cSendDataIndex = 0;
    5534:	10 92 0c 12 	sts	0x120C, r1
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: ST->DATA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// transmit data byte
		outb(TWDR, I2cSendData[I2cSendDataIndex++]);
    5538:	90 91 0c 12 	lds	r25, 0x120C
    553c:	e9 2f       	mov	r30, r25
    553e:	f0 e0       	ldi	r31, 0x00	; 0
    5540:	e4 51       	subi	r30, 0x14	; 20
    5542:	fe 4e       	sbci	r31, 0xEE	; 238
    5544:	80 81       	ld	r24, Z
    5546:	80 93 bb 00 	sts	0x00BB, r24
    554a:	9f 5f       	subi	r25, 0xFF	; 255
    554c:	90 93 0c 12 	sts	0x120C, r25
		if(I2cSendDataIndex < I2cSendDataLength)
    5550:	80 91 0d 12 	lds	r24, 0x120D
    5554:	98 17       	cp	r25, r24
    5556:	28 f4       	brcc	.+10     	; 0x5562 <__vector_39+0x208>
			// expect ACK to data byte
			outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    5558:	80 91 bc 00 	lds	r24, 0x00BC
    555c:	8f 70       	andi	r24, 0x0F	; 15
    555e:	80 6c       	ori	r24, 0xC0	; 192
    5560:	04 c0       	rjmp	.+8      	; 0x556a <__vector_39+0x210>
		else
			// expect NACK to data byte
			outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    5562:	80 91 bc 00 	lds	r24, 0x00BC
    5566:	8f 70       	andi	r24, 0x0F	; 15
    5568:	80 68       	ori	r24, 0x80	; 128
    556a:	80 93 bc 00 	sts	0x00BC, r24
    556e:	0d c0       	rjmp	.+26     	; 0x558a <__vector_39+0x230>
		rprintf("I2C: ST->DATA_NACK or LAST_DATA\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// all done
		// switch to open slave
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    5570:	80 91 bc 00 	lds	r24, 0x00BC
    5574:	8f 70       	andi	r24, 0x0F	; 15
    5576:	80 6c       	ori	r24, 0xC0	; 192
    5578:	04 c0       	rjmp	.+8      	; 0x5582 <__vector_39+0x228>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: BUS_ERROR\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// reset internal hardware and release bus
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTO)|BV(TWEA));
    557a:	80 91 bc 00 	lds	r24, 0x00BC
    557e:	8f 70       	andi	r24, 0x0F	; 15
    5580:	80 6d       	ori	r24, 0xD0	; 208
    5582:	80 93 bc 00 	sts	0x00BC, r24
		// set state
		I2cState = I2C_IDLE;
    5586:	10 92 ea 11 	sts	0x11EA, r1
		break;
	}
}
    558a:	ff 91       	pop	r31
    558c:	ef 91       	pop	r30
    558e:	bf 91       	pop	r27
    5590:	af 91       	pop	r26
    5592:	9f 91       	pop	r25
    5594:	8f 91       	pop	r24
    5596:	7f 91       	pop	r23
    5598:	6f 91       	pop	r22
    559a:	5f 91       	pop	r21
    559c:	4f 91       	pop	r20
    559e:	3f 91       	pop	r19
    55a0:	2f 91       	pop	r18
    55a2:	0f 90       	pop	r0
    55a4:	0f be       	out	0x3f, r0	; 63
    55a6:	0f 90       	pop	r0
    55a8:	1f 90       	pop	r1
    55aa:	18 95       	reti

000055ac <i2cGetState>:

eI2cStateType i2cGetState(void)
{
	return I2cState;
    55ac:	80 91 ea 11 	lds	r24, 0x11EA
}
    55b0:	08 95       	ret

000055b2 <exit>:
    55b2:	f8 94       	cli
    55b4:	0c 94 7f 2e 	jmp	0x5cfe	; 0x5cfe <_exit>

000055b8 <memcpy>:
    55b8:	fb 01       	movw	r30, r22
    55ba:	dc 01       	movw	r26, r24
    55bc:	02 c0       	rjmp	.+4      	; 0x55c2 <memcpy+0xa>
    55be:	01 90       	ld	r0, Z+
    55c0:	0d 92       	st	X+, r0
    55c2:	41 50       	subi	r20, 0x01	; 1
    55c4:	50 40       	sbci	r21, 0x00	; 0
    55c6:	d8 f7       	brcc	.-10     	; 0x55be <memcpy+0x6>
    55c8:	08 95       	ret

000055ca <memset>:
    55ca:	dc 01       	movw	r26, r24
    55cc:	01 c0       	rjmp	.+2      	; 0x55d0 <memset+0x6>
    55ce:	6d 93       	st	X+, r22
    55d0:	41 50       	subi	r20, 0x01	; 1
    55d2:	50 40       	sbci	r21, 0x00	; 0
    55d4:	e0 f7       	brcc	.-8      	; 0x55ce <memset+0x4>
    55d6:	08 95       	ret

000055d8 <strncpy>:
    55d8:	fb 01       	movw	r30, r22
    55da:	dc 01       	movw	r26, r24
    55dc:	41 50       	subi	r20, 0x01	; 1
    55de:	50 40       	sbci	r21, 0x00	; 0
    55e0:	48 f0       	brcs	.+18     	; 0x55f4 <strncpy+0x1c>
    55e2:	01 90       	ld	r0, Z+
    55e4:	0d 92       	st	X+, r0
    55e6:	00 20       	and	r0, r0
    55e8:	c9 f7       	brne	.-14     	; 0x55dc <strncpy+0x4>
    55ea:	01 c0       	rjmp	.+2      	; 0x55ee <strncpy+0x16>
    55ec:	1d 92       	st	X+, r1
    55ee:	41 50       	subi	r20, 0x01	; 1
    55f0:	50 40       	sbci	r21, 0x00	; 0
    55f2:	e0 f7       	brcc	.-8      	; 0x55ec <strncpy+0x14>
    55f4:	08 95       	ret

000055f6 <__subsf3>:
    55f6:	50 58       	subi	r21, 0x80	; 128

000055f8 <__addsf3>:
    55f8:	bb 27       	eor	r27, r27
    55fa:	aa 27       	eor	r26, r26
    55fc:	0e d0       	rcall	.+28     	; 0x561a <__addsf3x>
    55fe:	3a c2       	rjmp	.+1140   	; 0x5a74 <__fp_round>
    5600:	2b d2       	rcall	.+1110   	; 0x5a58 <__fp_pscA>
    5602:	30 f0       	brcs	.+12     	; 0x5610 <__addsf3+0x18>
    5604:	30 d2       	rcall	.+1120   	; 0x5a66 <__fp_pscB>
    5606:	20 f0       	brcs	.+8      	; 0x5610 <__addsf3+0x18>
    5608:	31 f4       	brne	.+12     	; 0x5616 <__addsf3+0x1e>
    560a:	9f 3f       	cpi	r25, 0xFF	; 255
    560c:	11 f4       	brne	.+4      	; 0x5612 <__addsf3+0x1a>
    560e:	1e f4       	brtc	.+6      	; 0x5616 <__addsf3+0x1e>
    5610:	fb c1       	rjmp	.+1014   	; 0x5a08 <__fp_nan>
    5612:	0e f4       	brtc	.+2      	; 0x5616 <__addsf3+0x1e>
    5614:	e0 95       	com	r30
    5616:	e7 fb       	bst	r30, 7
    5618:	c6 c1       	rjmp	.+908    	; 0x59a6 <__fp_inf>

0000561a <__addsf3x>:
    561a:	e9 2f       	mov	r30, r25
    561c:	3c d2       	rcall	.+1144   	; 0x5a96 <__fp_split3>
    561e:	80 f3       	brcs	.-32     	; 0x5600 <__addsf3+0x8>
    5620:	ba 17       	cp	r27, r26
    5622:	62 07       	cpc	r22, r18
    5624:	73 07       	cpc	r23, r19
    5626:	84 07       	cpc	r24, r20
    5628:	95 07       	cpc	r25, r21
    562a:	18 f0       	brcs	.+6      	; 0x5632 <__addsf3x+0x18>
    562c:	71 f4       	brne	.+28     	; 0x564a <__addsf3x+0x30>
    562e:	9e f5       	brtc	.+102    	; 0x5696 <__addsf3x+0x7c>
    5630:	6b c2       	rjmp	.+1238   	; 0x5b08 <__fp_zero>
    5632:	0e f4       	brtc	.+2      	; 0x5636 <__addsf3x+0x1c>
    5634:	e0 95       	com	r30
    5636:	0b 2e       	mov	r0, r27
    5638:	ba 2f       	mov	r27, r26
    563a:	a0 2d       	mov	r26, r0
    563c:	0b 01       	movw	r0, r22
    563e:	b9 01       	movw	r22, r18
    5640:	90 01       	movw	r18, r0
    5642:	0c 01       	movw	r0, r24
    5644:	ca 01       	movw	r24, r20
    5646:	a0 01       	movw	r20, r0
    5648:	11 24       	eor	r1, r1
    564a:	ff 27       	eor	r31, r31
    564c:	59 1b       	sub	r21, r25
    564e:	99 f0       	breq	.+38     	; 0x5676 <__addsf3x+0x5c>
    5650:	59 3f       	cpi	r21, 0xF9	; 249
    5652:	50 f4       	brcc	.+20     	; 0x5668 <__addsf3x+0x4e>
    5654:	50 3e       	cpi	r21, 0xE0	; 224
    5656:	68 f1       	brcs	.+90     	; 0x56b2 <__addsf3x+0x98>
    5658:	1a 16       	cp	r1, r26
    565a:	f0 40       	sbci	r31, 0x00	; 0
    565c:	a2 2f       	mov	r26, r18
    565e:	23 2f       	mov	r18, r19
    5660:	34 2f       	mov	r19, r20
    5662:	44 27       	eor	r20, r20
    5664:	58 5f       	subi	r21, 0xF8	; 248
    5666:	f3 cf       	rjmp	.-26     	; 0x564e <__addsf3x+0x34>
    5668:	46 95       	lsr	r20
    566a:	37 95       	ror	r19
    566c:	27 95       	ror	r18
    566e:	a7 95       	ror	r26
    5670:	f0 40       	sbci	r31, 0x00	; 0
    5672:	53 95       	inc	r21
    5674:	c9 f7       	brne	.-14     	; 0x5668 <__addsf3x+0x4e>
    5676:	7e f4       	brtc	.+30     	; 0x5696 <__addsf3x+0x7c>
    5678:	1f 16       	cp	r1, r31
    567a:	ba 0b       	sbc	r27, r26
    567c:	62 0b       	sbc	r22, r18
    567e:	73 0b       	sbc	r23, r19
    5680:	84 0b       	sbc	r24, r20
    5682:	ba f0       	brmi	.+46     	; 0x56b2 <__addsf3x+0x98>
    5684:	91 50       	subi	r25, 0x01	; 1
    5686:	a1 f0       	breq	.+40     	; 0x56b0 <__addsf3x+0x96>
    5688:	ff 0f       	add	r31, r31
    568a:	bb 1f       	adc	r27, r27
    568c:	66 1f       	adc	r22, r22
    568e:	77 1f       	adc	r23, r23
    5690:	88 1f       	adc	r24, r24
    5692:	c2 f7       	brpl	.-16     	; 0x5684 <__addsf3x+0x6a>
    5694:	0e c0       	rjmp	.+28     	; 0x56b2 <__addsf3x+0x98>
    5696:	ba 0f       	add	r27, r26
    5698:	62 1f       	adc	r22, r18
    569a:	73 1f       	adc	r23, r19
    569c:	84 1f       	adc	r24, r20
    569e:	48 f4       	brcc	.+18     	; 0x56b2 <__addsf3x+0x98>
    56a0:	87 95       	ror	r24
    56a2:	77 95       	ror	r23
    56a4:	67 95       	ror	r22
    56a6:	b7 95       	ror	r27
    56a8:	f7 95       	ror	r31
    56aa:	9e 3f       	cpi	r25, 0xFE	; 254
    56ac:	08 f0       	brcs	.+2      	; 0x56b0 <__addsf3x+0x96>
    56ae:	b3 cf       	rjmp	.-154    	; 0x5616 <__addsf3+0x1e>
    56b0:	93 95       	inc	r25
    56b2:	88 0f       	add	r24, r24
    56b4:	08 f0       	brcs	.+2      	; 0x56b8 <__addsf3x+0x9e>
    56b6:	99 27       	eor	r25, r25
    56b8:	ee 0f       	add	r30, r30
    56ba:	97 95       	ror	r25
    56bc:	87 95       	ror	r24
    56be:	08 95       	ret
    56c0:	cb d1       	rcall	.+918    	; 0x5a58 <__fp_pscA>
    56c2:	58 f0       	brcs	.+22     	; 0x56da <__addsf3x+0xc0>
    56c4:	80 e8       	ldi	r24, 0x80	; 128
    56c6:	91 e0       	ldi	r25, 0x01	; 1
    56c8:	09 f4       	brne	.+2      	; 0x56cc <__addsf3x+0xb2>
    56ca:	9e ef       	ldi	r25, 0xFE	; 254
    56cc:	cc d1       	rcall	.+920    	; 0x5a66 <__fp_pscB>
    56ce:	28 f0       	brcs	.+10     	; 0x56da <__addsf3x+0xc0>
    56d0:	40 e8       	ldi	r20, 0x80	; 128
    56d2:	51 e0       	ldi	r21, 0x01	; 1
    56d4:	59 f4       	brne	.+22     	; 0x56ec <atan2+0xe>
    56d6:	5e ef       	ldi	r21, 0xFE	; 254
    56d8:	09 c0       	rjmp	.+18     	; 0x56ec <atan2+0xe>
    56da:	96 c1       	rjmp	.+812    	; 0x5a08 <__fp_nan>
    56dc:	15 c2       	rjmp	.+1066   	; 0x5b08 <__fp_zero>

000056de <atan2>:
    56de:	e9 2f       	mov	r30, r25
    56e0:	e0 78       	andi	r30, 0x80	; 128
    56e2:	d9 d1       	rcall	.+946    	; 0x5a96 <__fp_split3>
    56e4:	68 f3       	brcs	.-38     	; 0x56c0 <__addsf3x+0xa6>
    56e6:	09 2e       	mov	r0, r25
    56e8:	05 2a       	or	r0, r21
    56ea:	c1 f3       	breq	.-16     	; 0x56dc <__addsf3x+0xc2>
    56ec:	26 17       	cp	r18, r22
    56ee:	37 07       	cpc	r19, r23
    56f0:	48 07       	cpc	r20, r24
    56f2:	59 07       	cpc	r21, r25
    56f4:	38 f0       	brcs	.+14     	; 0x5704 <atan2+0x26>
    56f6:	0e 2e       	mov	r0, r30
    56f8:	07 f8       	bld	r0, 7
    56fa:	e0 25       	eor	r30, r0
    56fc:	69 f0       	breq	.+26     	; 0x5718 <atan2+0x3a>
    56fe:	e0 25       	eor	r30, r0
    5700:	e0 64       	ori	r30, 0x40	; 64
    5702:	0a c0       	rjmp	.+20     	; 0x5718 <atan2+0x3a>
    5704:	ef 63       	ori	r30, 0x3F	; 63
    5706:	07 f8       	bld	r0, 7
    5708:	00 94       	com	r0
    570a:	07 fa       	bst	r0, 7
    570c:	db 01       	movw	r26, r22
    570e:	b9 01       	movw	r22, r18
    5710:	9d 01       	movw	r18, r26
    5712:	dc 01       	movw	r26, r24
    5714:	ca 01       	movw	r24, r20
    5716:	ad 01       	movw	r20, r26
    5718:	ef 93       	push	r30
    571a:	47 d0       	rcall	.+142    	; 0x57aa <__divsf3_pse>
    571c:	ab d1       	rcall	.+854    	; 0x5a74 <__fp_round>
    571e:	0a d0       	rcall	.+20     	; 0x5734 <atan>
    5720:	5f 91       	pop	r21
    5722:	55 23       	and	r21, r21
    5724:	31 f0       	breq	.+12     	; 0x5732 <atan2+0x54>
    5726:	2b ed       	ldi	r18, 0xDB	; 219
    5728:	3f e0       	ldi	r19, 0x0F	; 15
    572a:	49 e4       	ldi	r20, 0x49	; 73
    572c:	50 fd       	sbrc	r21, 0
    572e:	49 ec       	ldi	r20, 0xC9	; 201
    5730:	63 cf       	rjmp	.-314    	; 0x55f8 <__addsf3>
    5732:	08 95       	ret

00005734 <atan>:
    5734:	df 93       	push	r29
    5736:	dd 27       	eor	r29, r29
    5738:	b9 2f       	mov	r27, r25
    573a:	bf 77       	andi	r27, 0x7F	; 127
    573c:	40 e8       	ldi	r20, 0x80	; 128
    573e:	5f e3       	ldi	r21, 0x3F	; 63
    5740:	16 16       	cp	r1, r22
    5742:	17 06       	cpc	r1, r23
    5744:	48 07       	cpc	r20, r24
    5746:	5b 07       	cpc	r21, r27
    5748:	10 f4       	brcc	.+4      	; 0x574e <atan+0x1a>
    574a:	d9 2f       	mov	r29, r25
    574c:	e8 d1       	rcall	.+976    	; 0x5b1e <inverse>
    574e:	9f 93       	push	r25
    5750:	8f 93       	push	r24
    5752:	7f 93       	push	r23
    5754:	6f 93       	push	r22
    5756:	4d d2       	rcall	.+1178   	; 0x5bf2 <square>
    5758:	e4 ee       	ldi	r30, 0xE4	; 228
    575a:	f0 e0       	ldi	r31, 0x00	; 0
    575c:	58 d1       	rcall	.+688    	; 0x5a0e <__fp_powser>
    575e:	8a d1       	rcall	.+788    	; 0x5a74 <__fp_round>
    5760:	2f 91       	pop	r18
    5762:	3f 91       	pop	r19
    5764:	4f 91       	pop	r20
    5766:	5f 91       	pop	r21
    5768:	ed d1       	rcall	.+986    	; 0x5b44 <__mulsf3x>
    576a:	dd 23       	and	r29, r29
    576c:	49 f0       	breq	.+18     	; 0x5780 <atan+0x4c>
    576e:	90 58       	subi	r25, 0x80	; 128
    5770:	a2 ea       	ldi	r26, 0xA2	; 162
    5772:	2a ed       	ldi	r18, 0xDA	; 218
    5774:	3f e0       	ldi	r19, 0x0F	; 15
    5776:	49 ec       	ldi	r20, 0xC9	; 201
    5778:	5f e3       	ldi	r21, 0x3F	; 63
    577a:	d0 78       	andi	r29, 0x80	; 128
    577c:	5d 27       	eor	r21, r29
    577e:	4d df       	rcall	.-358    	; 0x561a <__addsf3x>
    5780:	df 91       	pop	r29
    5782:	78 c1       	rjmp	.+752    	; 0x5a74 <__fp_round>

00005784 <__cmpsf2>:
    5784:	ec d0       	rcall	.+472    	; 0x595e <__fp_cmp>
    5786:	08 f4       	brcc	.+2      	; 0x578a <__cmpsf2+0x6>
    5788:	81 e0       	ldi	r24, 0x01	; 1
    578a:	08 95       	ret

0000578c <__divsf3>:
    578c:	0c d0       	rcall	.+24     	; 0x57a6 <__divsf3x>
    578e:	72 c1       	rjmp	.+740    	; 0x5a74 <__fp_round>
    5790:	6a d1       	rcall	.+724    	; 0x5a66 <__fp_pscB>
    5792:	40 f0       	brcs	.+16     	; 0x57a4 <__divsf3+0x18>
    5794:	61 d1       	rcall	.+706    	; 0x5a58 <__fp_pscA>
    5796:	30 f0       	brcs	.+12     	; 0x57a4 <__divsf3+0x18>
    5798:	21 f4       	brne	.+8      	; 0x57a2 <__divsf3+0x16>
    579a:	5f 3f       	cpi	r21, 0xFF	; 255
    579c:	19 f0       	breq	.+6      	; 0x57a4 <__divsf3+0x18>
    579e:	03 c1       	rjmp	.+518    	; 0x59a6 <__fp_inf>
    57a0:	51 11       	cpse	r21, r1
    57a2:	b3 c1       	rjmp	.+870    	; 0x5b0a <__fp_szero>
    57a4:	31 c1       	rjmp	.+610    	; 0x5a08 <__fp_nan>

000057a6 <__divsf3x>:
    57a6:	77 d1       	rcall	.+750    	; 0x5a96 <__fp_split3>
    57a8:	98 f3       	brcs	.-26     	; 0x5790 <__divsf3+0x4>

000057aa <__divsf3_pse>:
    57aa:	99 23       	and	r25, r25
    57ac:	c9 f3       	breq	.-14     	; 0x57a0 <__divsf3+0x14>
    57ae:	55 23       	and	r21, r21
    57b0:	b1 f3       	breq	.-20     	; 0x579e <__divsf3+0x12>
    57b2:	95 1b       	sub	r25, r21
    57b4:	55 0b       	sbc	r21, r21
    57b6:	bb 27       	eor	r27, r27
    57b8:	aa 27       	eor	r26, r26
    57ba:	62 17       	cp	r22, r18
    57bc:	73 07       	cpc	r23, r19
    57be:	84 07       	cpc	r24, r20
    57c0:	38 f0       	brcs	.+14     	; 0x57d0 <__divsf3_pse+0x26>
    57c2:	9f 5f       	subi	r25, 0xFF	; 255
    57c4:	5f 4f       	sbci	r21, 0xFF	; 255
    57c6:	22 0f       	add	r18, r18
    57c8:	33 1f       	adc	r19, r19
    57ca:	44 1f       	adc	r20, r20
    57cc:	aa 1f       	adc	r26, r26
    57ce:	a9 f3       	breq	.-22     	; 0x57ba <__divsf3_pse+0x10>
    57d0:	33 d0       	rcall	.+102    	; 0x5838 <__divsf3_pse+0x8e>
    57d2:	0e 2e       	mov	r0, r30
    57d4:	3a f0       	brmi	.+14     	; 0x57e4 <__divsf3_pse+0x3a>
    57d6:	e0 e8       	ldi	r30, 0x80	; 128
    57d8:	30 d0       	rcall	.+96     	; 0x583a <__divsf3_pse+0x90>
    57da:	91 50       	subi	r25, 0x01	; 1
    57dc:	50 40       	sbci	r21, 0x00	; 0
    57de:	e6 95       	lsr	r30
    57e0:	00 1c       	adc	r0, r0
    57e2:	ca f7       	brpl	.-14     	; 0x57d6 <__divsf3_pse+0x2c>
    57e4:	29 d0       	rcall	.+82     	; 0x5838 <__divsf3_pse+0x8e>
    57e6:	fe 2f       	mov	r31, r30
    57e8:	27 d0       	rcall	.+78     	; 0x5838 <__divsf3_pse+0x8e>
    57ea:	66 0f       	add	r22, r22
    57ec:	77 1f       	adc	r23, r23
    57ee:	88 1f       	adc	r24, r24
    57f0:	bb 1f       	adc	r27, r27
    57f2:	26 17       	cp	r18, r22
    57f4:	37 07       	cpc	r19, r23
    57f6:	48 07       	cpc	r20, r24
    57f8:	ab 07       	cpc	r26, r27
    57fa:	b0 e8       	ldi	r27, 0x80	; 128
    57fc:	09 f0       	breq	.+2      	; 0x5800 <__divsf3_pse+0x56>
    57fe:	bb 0b       	sbc	r27, r27
    5800:	80 2d       	mov	r24, r0
    5802:	bf 01       	movw	r22, r30
    5804:	ff 27       	eor	r31, r31
    5806:	93 58       	subi	r25, 0x83	; 131
    5808:	5f 4f       	sbci	r21, 0xFF	; 255
    580a:	2a f0       	brmi	.+10     	; 0x5816 <__divsf3_pse+0x6c>
    580c:	9e 3f       	cpi	r25, 0xFE	; 254
    580e:	51 05       	cpc	r21, r1
    5810:	68 f0       	brcs	.+26     	; 0x582c <__divsf3_pse+0x82>
    5812:	c9 c0       	rjmp	.+402    	; 0x59a6 <__fp_inf>
    5814:	7a c1       	rjmp	.+756    	; 0x5b0a <__fp_szero>
    5816:	5f 3f       	cpi	r21, 0xFF	; 255
    5818:	ec f3       	brlt	.-6      	; 0x5814 <__divsf3_pse+0x6a>
    581a:	98 3e       	cpi	r25, 0xE8	; 232
    581c:	dc f3       	brlt	.-10     	; 0x5814 <__divsf3_pse+0x6a>
    581e:	86 95       	lsr	r24
    5820:	77 95       	ror	r23
    5822:	67 95       	ror	r22
    5824:	b7 95       	ror	r27
    5826:	f7 95       	ror	r31
    5828:	9f 5f       	subi	r25, 0xFF	; 255
    582a:	c9 f7       	brne	.-14     	; 0x581e <__divsf3_pse+0x74>
    582c:	88 0f       	add	r24, r24
    582e:	91 1d       	adc	r25, r1
    5830:	96 95       	lsr	r25
    5832:	87 95       	ror	r24
    5834:	97 f9       	bld	r25, 7
    5836:	08 95       	ret
    5838:	e1 e0       	ldi	r30, 0x01	; 1
    583a:	66 0f       	add	r22, r22
    583c:	77 1f       	adc	r23, r23
    583e:	88 1f       	adc	r24, r24
    5840:	bb 1f       	adc	r27, r27
    5842:	62 17       	cp	r22, r18
    5844:	73 07       	cpc	r23, r19
    5846:	84 07       	cpc	r24, r20
    5848:	ba 07       	cpc	r27, r26
    584a:	20 f0       	brcs	.+8      	; 0x5854 <__divsf3_pse+0xaa>
    584c:	62 1b       	sub	r22, r18
    584e:	73 0b       	sbc	r23, r19
    5850:	84 0b       	sbc	r24, r20
    5852:	ba 0b       	sbc	r27, r26
    5854:	ee 1f       	adc	r30, r30
    5856:	88 f7       	brcc	.-30     	; 0x583a <__divsf3_pse+0x90>
    5858:	e0 95       	com	r30
    585a:	08 95       	ret

0000585c <__fixsfsi>:
    585c:	04 d0       	rcall	.+8      	; 0x5866 <__fixunssfsi>
    585e:	68 94       	set
    5860:	b1 11       	cpse	r27, r1
    5862:	53 c1       	rjmp	.+678    	; 0x5b0a <__fp_szero>
    5864:	08 95       	ret

00005866 <__fixunssfsi>:
    5866:	1f d1       	rcall	.+574    	; 0x5aa6 <__fp_splitA>
    5868:	88 f0       	brcs	.+34     	; 0x588c <__fixunssfsi+0x26>
    586a:	9f 57       	subi	r25, 0x7F	; 127
    586c:	90 f0       	brcs	.+36     	; 0x5892 <__fixunssfsi+0x2c>
    586e:	b9 2f       	mov	r27, r25
    5870:	99 27       	eor	r25, r25
    5872:	b7 51       	subi	r27, 0x17	; 23
    5874:	a0 f0       	brcs	.+40     	; 0x589e <__fixunssfsi+0x38>
    5876:	d1 f0       	breq	.+52     	; 0x58ac <__fixunssfsi+0x46>
    5878:	66 0f       	add	r22, r22
    587a:	77 1f       	adc	r23, r23
    587c:	88 1f       	adc	r24, r24
    587e:	99 1f       	adc	r25, r25
    5880:	1a f0       	brmi	.+6      	; 0x5888 <__fixunssfsi+0x22>
    5882:	ba 95       	dec	r27
    5884:	c9 f7       	brne	.-14     	; 0x5878 <__fixunssfsi+0x12>
    5886:	12 c0       	rjmp	.+36     	; 0x58ac <__fixunssfsi+0x46>
    5888:	b1 30       	cpi	r27, 0x01	; 1
    588a:	81 f0       	breq	.+32     	; 0x58ac <__fixunssfsi+0x46>
    588c:	3d d1       	rcall	.+634    	; 0x5b08 <__fp_zero>
    588e:	b1 e0       	ldi	r27, 0x01	; 1
    5890:	08 95       	ret
    5892:	3a c1       	rjmp	.+628    	; 0x5b08 <__fp_zero>
    5894:	67 2f       	mov	r22, r23
    5896:	78 2f       	mov	r23, r24
    5898:	88 27       	eor	r24, r24
    589a:	b8 5f       	subi	r27, 0xF8	; 248
    589c:	39 f0       	breq	.+14     	; 0x58ac <__fixunssfsi+0x46>
    589e:	b9 3f       	cpi	r27, 0xF9	; 249
    58a0:	cc f3       	brlt	.-14     	; 0x5894 <__fixunssfsi+0x2e>
    58a2:	86 95       	lsr	r24
    58a4:	77 95       	ror	r23
    58a6:	67 95       	ror	r22
    58a8:	b3 95       	inc	r27
    58aa:	d9 f7       	brne	.-10     	; 0x58a2 <__fixunssfsi+0x3c>
    58ac:	3e f4       	brtc	.+14     	; 0x58bc <__fixunssfsi+0x56>
    58ae:	90 95       	com	r25
    58b0:	80 95       	com	r24
    58b2:	70 95       	com	r23
    58b4:	61 95       	neg	r22
    58b6:	7f 4f       	sbci	r23, 0xFF	; 255
    58b8:	8f 4f       	sbci	r24, 0xFF	; 255
    58ba:	9f 4f       	sbci	r25, 0xFF	; 255
    58bc:	08 95       	ret

000058be <__floatunsisf>:
    58be:	e8 94       	clt
    58c0:	09 c0       	rjmp	.+18     	; 0x58d4 <__floatsisf+0x12>

000058c2 <__floatsisf>:
    58c2:	97 fb       	bst	r25, 7
    58c4:	3e f4       	brtc	.+14     	; 0x58d4 <__floatsisf+0x12>
    58c6:	90 95       	com	r25
    58c8:	80 95       	com	r24
    58ca:	70 95       	com	r23
    58cc:	61 95       	neg	r22
    58ce:	7f 4f       	sbci	r23, 0xFF	; 255
    58d0:	8f 4f       	sbci	r24, 0xFF	; 255
    58d2:	9f 4f       	sbci	r25, 0xFF	; 255
    58d4:	99 23       	and	r25, r25
    58d6:	a9 f0       	breq	.+42     	; 0x5902 <__floatsisf+0x40>
    58d8:	f9 2f       	mov	r31, r25
    58da:	96 e9       	ldi	r25, 0x96	; 150
    58dc:	bb 27       	eor	r27, r27
    58de:	93 95       	inc	r25
    58e0:	f6 95       	lsr	r31
    58e2:	87 95       	ror	r24
    58e4:	77 95       	ror	r23
    58e6:	67 95       	ror	r22
    58e8:	b7 95       	ror	r27
    58ea:	f1 11       	cpse	r31, r1
    58ec:	f8 cf       	rjmp	.-16     	; 0x58de <__floatsisf+0x1c>
    58ee:	fa f4       	brpl	.+62     	; 0x592e <__floatsisf+0x6c>
    58f0:	bb 0f       	add	r27, r27
    58f2:	11 f4       	brne	.+4      	; 0x58f8 <__floatsisf+0x36>
    58f4:	60 ff       	sbrs	r22, 0
    58f6:	1b c0       	rjmp	.+54     	; 0x592e <__floatsisf+0x6c>
    58f8:	6f 5f       	subi	r22, 0xFF	; 255
    58fa:	7f 4f       	sbci	r23, 0xFF	; 255
    58fc:	8f 4f       	sbci	r24, 0xFF	; 255
    58fe:	9f 4f       	sbci	r25, 0xFF	; 255
    5900:	16 c0       	rjmp	.+44     	; 0x592e <__floatsisf+0x6c>
    5902:	88 23       	and	r24, r24
    5904:	11 f0       	breq	.+4      	; 0x590a <__floatsisf+0x48>
    5906:	96 e9       	ldi	r25, 0x96	; 150
    5908:	11 c0       	rjmp	.+34     	; 0x592c <__floatsisf+0x6a>
    590a:	77 23       	and	r23, r23
    590c:	21 f0       	breq	.+8      	; 0x5916 <__floatsisf+0x54>
    590e:	9e e8       	ldi	r25, 0x8E	; 142
    5910:	87 2f       	mov	r24, r23
    5912:	76 2f       	mov	r23, r22
    5914:	05 c0       	rjmp	.+10     	; 0x5920 <__floatsisf+0x5e>
    5916:	66 23       	and	r22, r22
    5918:	71 f0       	breq	.+28     	; 0x5936 <__floatsisf+0x74>
    591a:	96 e8       	ldi	r25, 0x86	; 134
    591c:	86 2f       	mov	r24, r22
    591e:	70 e0       	ldi	r23, 0x00	; 0
    5920:	60 e0       	ldi	r22, 0x00	; 0
    5922:	2a f0       	brmi	.+10     	; 0x592e <__floatsisf+0x6c>
    5924:	9a 95       	dec	r25
    5926:	66 0f       	add	r22, r22
    5928:	77 1f       	adc	r23, r23
    592a:	88 1f       	adc	r24, r24
    592c:	da f7       	brpl	.-10     	; 0x5924 <__floatsisf+0x62>
    592e:	88 0f       	add	r24, r24
    5930:	96 95       	lsr	r25
    5932:	87 95       	ror	r24
    5934:	97 f9       	bld	r25, 7
    5936:	08 95       	ret

00005938 <floor>:
    5938:	d0 d0       	rcall	.+416    	; 0x5ada <__fp_trunc>
    593a:	80 f0       	brcs	.+32     	; 0x595c <floor+0x24>
    593c:	9f 37       	cpi	r25, 0x7F	; 127
    593e:	40 f4       	brcc	.+16     	; 0x5950 <floor+0x18>
    5940:	91 11       	cpse	r25, r1
    5942:	0e f0       	brts	.+2      	; 0x5946 <floor+0xe>
    5944:	e2 c0       	rjmp	.+452    	; 0x5b0a <__fp_szero>
    5946:	60 e0       	ldi	r22, 0x00	; 0
    5948:	70 e0       	ldi	r23, 0x00	; 0
    594a:	80 e8       	ldi	r24, 0x80	; 128
    594c:	9f eb       	ldi	r25, 0xBF	; 191
    594e:	08 95       	ret
    5950:	26 f4       	brtc	.+8      	; 0x595a <floor+0x22>
    5952:	1b 16       	cp	r1, r27
    5954:	61 1d       	adc	r22, r1
    5956:	71 1d       	adc	r23, r1
    5958:	81 1d       	adc	r24, r1
    595a:	2b c0       	rjmp	.+86     	; 0x59b2 <__fp_mintl>
    595c:	45 c0       	rjmp	.+138    	; 0x59e8 <__fp_mpack>

0000595e <__fp_cmp>:
    595e:	99 0f       	add	r25, r25
    5960:	00 08       	sbc	r0, r0
    5962:	55 0f       	add	r21, r21
    5964:	aa 0b       	sbc	r26, r26
    5966:	e0 e8       	ldi	r30, 0x80	; 128
    5968:	fe ef       	ldi	r31, 0xFE	; 254
    596a:	16 16       	cp	r1, r22
    596c:	17 06       	cpc	r1, r23
    596e:	e8 07       	cpc	r30, r24
    5970:	f9 07       	cpc	r31, r25
    5972:	c0 f0       	brcs	.+48     	; 0x59a4 <__fp_cmp+0x46>
    5974:	12 16       	cp	r1, r18
    5976:	13 06       	cpc	r1, r19
    5978:	e4 07       	cpc	r30, r20
    597a:	f5 07       	cpc	r31, r21
    597c:	98 f0       	brcs	.+38     	; 0x59a4 <__fp_cmp+0x46>
    597e:	62 1b       	sub	r22, r18
    5980:	73 0b       	sbc	r23, r19
    5982:	84 0b       	sbc	r24, r20
    5984:	95 0b       	sbc	r25, r21
    5986:	39 f4       	brne	.+14     	; 0x5996 <__fp_cmp+0x38>
    5988:	0a 26       	eor	r0, r26
    598a:	61 f0       	breq	.+24     	; 0x59a4 <__fp_cmp+0x46>
    598c:	23 2b       	or	r18, r19
    598e:	24 2b       	or	r18, r20
    5990:	25 2b       	or	r18, r21
    5992:	21 f4       	brne	.+8      	; 0x599c <__fp_cmp+0x3e>
    5994:	08 95       	ret
    5996:	0a 26       	eor	r0, r26
    5998:	09 f4       	brne	.+2      	; 0x599c <__fp_cmp+0x3e>
    599a:	a1 40       	sbci	r26, 0x01	; 1
    599c:	a6 95       	lsr	r26
    599e:	8f ef       	ldi	r24, 0xFF	; 255
    59a0:	81 1d       	adc	r24, r1
    59a2:	81 1d       	adc	r24, r1
    59a4:	08 95       	ret

000059a6 <__fp_inf>:
    59a6:	97 f9       	bld	r25, 7
    59a8:	9f 67       	ori	r25, 0x7F	; 127
    59aa:	80 e8       	ldi	r24, 0x80	; 128
    59ac:	70 e0       	ldi	r23, 0x00	; 0
    59ae:	60 e0       	ldi	r22, 0x00	; 0
    59b0:	08 95       	ret

000059b2 <__fp_mintl>:
    59b2:	88 23       	and	r24, r24
    59b4:	71 f4       	brne	.+28     	; 0x59d2 <__fp_mintl+0x20>
    59b6:	77 23       	and	r23, r23
    59b8:	21 f0       	breq	.+8      	; 0x59c2 <__fp_mintl+0x10>
    59ba:	98 50       	subi	r25, 0x08	; 8
    59bc:	87 2b       	or	r24, r23
    59be:	76 2f       	mov	r23, r22
    59c0:	07 c0       	rjmp	.+14     	; 0x59d0 <__fp_mintl+0x1e>
    59c2:	66 23       	and	r22, r22
    59c4:	11 f4       	brne	.+4      	; 0x59ca <__fp_mintl+0x18>
    59c6:	99 27       	eor	r25, r25
    59c8:	0d c0       	rjmp	.+26     	; 0x59e4 <__fp_mintl+0x32>
    59ca:	90 51       	subi	r25, 0x10	; 16
    59cc:	86 2b       	or	r24, r22
    59ce:	70 e0       	ldi	r23, 0x00	; 0
    59d0:	60 e0       	ldi	r22, 0x00	; 0
    59d2:	2a f0       	brmi	.+10     	; 0x59de <__fp_mintl+0x2c>
    59d4:	9a 95       	dec	r25
    59d6:	66 0f       	add	r22, r22
    59d8:	77 1f       	adc	r23, r23
    59da:	88 1f       	adc	r24, r24
    59dc:	da f7       	brpl	.-10     	; 0x59d4 <__fp_mintl+0x22>
    59de:	88 0f       	add	r24, r24
    59e0:	96 95       	lsr	r25
    59e2:	87 95       	ror	r24
    59e4:	97 f9       	bld	r25, 7
    59e6:	08 95       	ret

000059e8 <__fp_mpack>:
    59e8:	9f 3f       	cpi	r25, 0xFF	; 255
    59ea:	49 f0       	breq	.+18     	; 0x59fe <__fp_mpack+0x16>
    59ec:	91 50       	subi	r25, 0x01	; 1
    59ee:	28 f4       	brcc	.+10     	; 0x59fa <__fp_mpack+0x12>
    59f0:	86 95       	lsr	r24
    59f2:	77 95       	ror	r23
    59f4:	67 95       	ror	r22
    59f6:	b7 95       	ror	r27
    59f8:	9f 5f       	subi	r25, 0xFF	; 255
    59fa:	80 38       	cpi	r24, 0x80	; 128
    59fc:	9f 4f       	sbci	r25, 0xFF	; 255
    59fe:	88 0f       	add	r24, r24
    5a00:	96 95       	lsr	r25
    5a02:	87 95       	ror	r24
    5a04:	97 f9       	bld	r25, 7
    5a06:	08 95       	ret

00005a08 <__fp_nan>:
    5a08:	9f ef       	ldi	r25, 0xFF	; 255
    5a0a:	80 ec       	ldi	r24, 0xC0	; 192
    5a0c:	08 95       	ret

00005a0e <__fp_powser>:
    5a0e:	df 93       	push	r29
    5a10:	cf 93       	push	r28
    5a12:	1f 93       	push	r17
    5a14:	0f 93       	push	r16
    5a16:	ff 92       	push	r15
    5a18:	ef 92       	push	r14
    5a1a:	df 92       	push	r13
    5a1c:	7b 01       	movw	r14, r22
    5a1e:	8c 01       	movw	r16, r24
    5a20:	68 94       	set
    5a22:	05 c0       	rjmp	.+10     	; 0x5a2e <__fp_powser+0x20>
    5a24:	da 2e       	mov	r13, r26
    5a26:	ef 01       	movw	r28, r30
    5a28:	8d d0       	rcall	.+282    	; 0x5b44 <__mulsf3x>
    5a2a:	fe 01       	movw	r30, r28
    5a2c:	e8 94       	clt
    5a2e:	a5 91       	lpm	r26, Z+
    5a30:	25 91       	lpm	r18, Z+
    5a32:	35 91       	lpm	r19, Z+
    5a34:	45 91       	lpm	r20, Z+
    5a36:	55 91       	lpm	r21, Z+
    5a38:	ae f3       	brts	.-22     	; 0x5a24 <__fp_powser+0x16>
    5a3a:	ef 01       	movw	r28, r30
    5a3c:	ee dd       	rcall	.-1060   	; 0x561a <__addsf3x>
    5a3e:	fe 01       	movw	r30, r28
    5a40:	97 01       	movw	r18, r14
    5a42:	a8 01       	movw	r20, r16
    5a44:	da 94       	dec	r13
    5a46:	79 f7       	brne	.-34     	; 0x5a26 <__fp_powser+0x18>
    5a48:	df 90       	pop	r13
    5a4a:	ef 90       	pop	r14
    5a4c:	ff 90       	pop	r15
    5a4e:	0f 91       	pop	r16
    5a50:	1f 91       	pop	r17
    5a52:	cf 91       	pop	r28
    5a54:	df 91       	pop	r29
    5a56:	08 95       	ret

00005a58 <__fp_pscA>:
    5a58:	00 24       	eor	r0, r0
    5a5a:	0a 94       	dec	r0
    5a5c:	16 16       	cp	r1, r22
    5a5e:	17 06       	cpc	r1, r23
    5a60:	18 06       	cpc	r1, r24
    5a62:	09 06       	cpc	r0, r25
    5a64:	08 95       	ret

00005a66 <__fp_pscB>:
    5a66:	00 24       	eor	r0, r0
    5a68:	0a 94       	dec	r0
    5a6a:	12 16       	cp	r1, r18
    5a6c:	13 06       	cpc	r1, r19
    5a6e:	14 06       	cpc	r1, r20
    5a70:	05 06       	cpc	r0, r21
    5a72:	08 95       	ret

00005a74 <__fp_round>:
    5a74:	09 2e       	mov	r0, r25
    5a76:	03 94       	inc	r0
    5a78:	00 0c       	add	r0, r0
    5a7a:	11 f4       	brne	.+4      	; 0x5a80 <__fp_round+0xc>
    5a7c:	88 23       	and	r24, r24
    5a7e:	52 f0       	brmi	.+20     	; 0x5a94 <__fp_round+0x20>
    5a80:	bb 0f       	add	r27, r27
    5a82:	40 f4       	brcc	.+16     	; 0x5a94 <__fp_round+0x20>
    5a84:	bf 2b       	or	r27, r31
    5a86:	11 f4       	brne	.+4      	; 0x5a8c <__fp_round+0x18>
    5a88:	60 ff       	sbrs	r22, 0
    5a8a:	04 c0       	rjmp	.+8      	; 0x5a94 <__fp_round+0x20>
    5a8c:	6f 5f       	subi	r22, 0xFF	; 255
    5a8e:	7f 4f       	sbci	r23, 0xFF	; 255
    5a90:	8f 4f       	sbci	r24, 0xFF	; 255
    5a92:	9f 4f       	sbci	r25, 0xFF	; 255
    5a94:	08 95       	ret

00005a96 <__fp_split3>:
    5a96:	57 fd       	sbrc	r21, 7
    5a98:	90 58       	subi	r25, 0x80	; 128
    5a9a:	44 0f       	add	r20, r20
    5a9c:	55 1f       	adc	r21, r21
    5a9e:	59 f0       	breq	.+22     	; 0x5ab6 <__fp_splitA+0x10>
    5aa0:	5f 3f       	cpi	r21, 0xFF	; 255
    5aa2:	71 f0       	breq	.+28     	; 0x5ac0 <__fp_splitA+0x1a>
    5aa4:	47 95       	ror	r20

00005aa6 <__fp_splitA>:
    5aa6:	88 0f       	add	r24, r24
    5aa8:	97 fb       	bst	r25, 7
    5aaa:	99 1f       	adc	r25, r25
    5aac:	61 f0       	breq	.+24     	; 0x5ac6 <__fp_splitA+0x20>
    5aae:	9f 3f       	cpi	r25, 0xFF	; 255
    5ab0:	79 f0       	breq	.+30     	; 0x5ad0 <__fp_splitA+0x2a>
    5ab2:	87 95       	ror	r24
    5ab4:	08 95       	ret
    5ab6:	12 16       	cp	r1, r18
    5ab8:	13 06       	cpc	r1, r19
    5aba:	14 06       	cpc	r1, r20
    5abc:	55 1f       	adc	r21, r21
    5abe:	f2 cf       	rjmp	.-28     	; 0x5aa4 <__fp_split3+0xe>
    5ac0:	46 95       	lsr	r20
    5ac2:	f1 df       	rcall	.-30     	; 0x5aa6 <__fp_splitA>
    5ac4:	08 c0       	rjmp	.+16     	; 0x5ad6 <__fp_splitA+0x30>
    5ac6:	16 16       	cp	r1, r22
    5ac8:	17 06       	cpc	r1, r23
    5aca:	18 06       	cpc	r1, r24
    5acc:	99 1f       	adc	r25, r25
    5ace:	f1 cf       	rjmp	.-30     	; 0x5ab2 <__fp_splitA+0xc>
    5ad0:	86 95       	lsr	r24
    5ad2:	71 05       	cpc	r23, r1
    5ad4:	61 05       	cpc	r22, r1
    5ad6:	08 94       	sec
    5ad8:	08 95       	ret

00005ada <__fp_trunc>:
    5ada:	e5 df       	rcall	.-54     	; 0x5aa6 <__fp_splitA>
    5adc:	a0 f0       	brcs	.+40     	; 0x5b06 <__fp_trunc+0x2c>
    5ade:	be e7       	ldi	r27, 0x7E	; 126
    5ae0:	b9 17       	cp	r27, r25
    5ae2:	88 f4       	brcc	.+34     	; 0x5b06 <__fp_trunc+0x2c>
    5ae4:	bb 27       	eor	r27, r27
    5ae6:	9f 38       	cpi	r25, 0x8F	; 143
    5ae8:	60 f4       	brcc	.+24     	; 0x5b02 <__fp_trunc+0x28>
    5aea:	16 16       	cp	r1, r22
    5aec:	b1 1d       	adc	r27, r1
    5aee:	67 2f       	mov	r22, r23
    5af0:	78 2f       	mov	r23, r24
    5af2:	88 27       	eor	r24, r24
    5af4:	98 5f       	subi	r25, 0xF8	; 248
    5af6:	f7 cf       	rjmp	.-18     	; 0x5ae6 <__fp_trunc+0xc>
    5af8:	86 95       	lsr	r24
    5afa:	77 95       	ror	r23
    5afc:	67 95       	ror	r22
    5afe:	b1 1d       	adc	r27, r1
    5b00:	93 95       	inc	r25
    5b02:	96 39       	cpi	r25, 0x96	; 150
    5b04:	c8 f3       	brcs	.-14     	; 0x5af8 <__fp_trunc+0x1e>
    5b06:	08 95       	ret

00005b08 <__fp_zero>:
    5b08:	e8 94       	clt

00005b0a <__fp_szero>:
    5b0a:	bb 27       	eor	r27, r27
    5b0c:	66 27       	eor	r22, r22
    5b0e:	77 27       	eor	r23, r23
    5b10:	cb 01       	movw	r24, r22
    5b12:	97 f9       	bld	r25, 7
    5b14:	08 95       	ret

00005b16 <__gesf2>:
    5b16:	23 df       	rcall	.-442    	; 0x595e <__fp_cmp>
    5b18:	08 f4       	brcc	.+2      	; 0x5b1c <__gesf2+0x6>
    5b1a:	8f ef       	ldi	r24, 0xFF	; 255
    5b1c:	08 95       	ret

00005b1e <inverse>:
    5b1e:	9b 01       	movw	r18, r22
    5b20:	ac 01       	movw	r20, r24
    5b22:	60 e0       	ldi	r22, 0x00	; 0
    5b24:	70 e0       	ldi	r23, 0x00	; 0
    5b26:	80 e8       	ldi	r24, 0x80	; 128
    5b28:	9f e3       	ldi	r25, 0x3F	; 63
    5b2a:	30 ce       	rjmp	.-928    	; 0x578c <__divsf3>

00005b2c <__mulsf3>:
    5b2c:	0b d0       	rcall	.+22     	; 0x5b44 <__mulsf3x>
    5b2e:	a2 cf       	rjmp	.-188    	; 0x5a74 <__fp_round>
    5b30:	93 df       	rcall	.-218    	; 0x5a58 <__fp_pscA>
    5b32:	28 f0       	brcs	.+10     	; 0x5b3e <__mulsf3+0x12>
    5b34:	98 df       	rcall	.-208    	; 0x5a66 <__fp_pscB>
    5b36:	18 f0       	brcs	.+6      	; 0x5b3e <__mulsf3+0x12>
    5b38:	95 23       	and	r25, r21
    5b3a:	09 f0       	breq	.+2      	; 0x5b3e <__mulsf3+0x12>
    5b3c:	34 cf       	rjmp	.-408    	; 0x59a6 <__fp_inf>
    5b3e:	64 cf       	rjmp	.-312    	; 0x5a08 <__fp_nan>
    5b40:	11 24       	eor	r1, r1
    5b42:	e3 cf       	rjmp	.-58     	; 0x5b0a <__fp_szero>

00005b44 <__mulsf3x>:
    5b44:	a8 df       	rcall	.-176    	; 0x5a96 <__fp_split3>
    5b46:	a0 f3       	brcs	.-24     	; 0x5b30 <__mulsf3+0x4>

00005b48 <__mulsf3_pse>:
    5b48:	95 9f       	mul	r25, r21
    5b4a:	d1 f3       	breq	.-12     	; 0x5b40 <__mulsf3+0x14>
    5b4c:	95 0f       	add	r25, r21
    5b4e:	50 e0       	ldi	r21, 0x00	; 0
    5b50:	55 1f       	adc	r21, r21
    5b52:	62 9f       	mul	r22, r18
    5b54:	f0 01       	movw	r30, r0
    5b56:	72 9f       	mul	r23, r18
    5b58:	bb 27       	eor	r27, r27
    5b5a:	f0 0d       	add	r31, r0
    5b5c:	b1 1d       	adc	r27, r1
    5b5e:	63 9f       	mul	r22, r19
    5b60:	aa 27       	eor	r26, r26
    5b62:	f0 0d       	add	r31, r0
    5b64:	b1 1d       	adc	r27, r1
    5b66:	aa 1f       	adc	r26, r26
    5b68:	64 9f       	mul	r22, r20
    5b6a:	66 27       	eor	r22, r22
    5b6c:	b0 0d       	add	r27, r0
    5b6e:	a1 1d       	adc	r26, r1
    5b70:	66 1f       	adc	r22, r22
    5b72:	82 9f       	mul	r24, r18
    5b74:	22 27       	eor	r18, r18
    5b76:	b0 0d       	add	r27, r0
    5b78:	a1 1d       	adc	r26, r1
    5b7a:	62 1f       	adc	r22, r18
    5b7c:	73 9f       	mul	r23, r19
    5b7e:	b0 0d       	add	r27, r0
    5b80:	a1 1d       	adc	r26, r1
    5b82:	62 1f       	adc	r22, r18
    5b84:	83 9f       	mul	r24, r19
    5b86:	a0 0d       	add	r26, r0
    5b88:	61 1d       	adc	r22, r1
    5b8a:	22 1f       	adc	r18, r18
    5b8c:	74 9f       	mul	r23, r20
    5b8e:	33 27       	eor	r19, r19
    5b90:	a0 0d       	add	r26, r0
    5b92:	61 1d       	adc	r22, r1
    5b94:	23 1f       	adc	r18, r19
    5b96:	84 9f       	mul	r24, r20
    5b98:	60 0d       	add	r22, r0
    5b9a:	21 1d       	adc	r18, r1
    5b9c:	82 2f       	mov	r24, r18
    5b9e:	76 2f       	mov	r23, r22
    5ba0:	6a 2f       	mov	r22, r26
    5ba2:	11 24       	eor	r1, r1
    5ba4:	9f 57       	subi	r25, 0x7F	; 127
    5ba6:	50 40       	sbci	r21, 0x00	; 0
    5ba8:	8a f0       	brmi	.+34     	; 0x5bcc <__mulsf3_pse+0x84>
    5baa:	e1 f0       	breq	.+56     	; 0x5be4 <__mulsf3_pse+0x9c>
    5bac:	88 23       	and	r24, r24
    5bae:	4a f0       	brmi	.+18     	; 0x5bc2 <__mulsf3_pse+0x7a>
    5bb0:	ee 0f       	add	r30, r30
    5bb2:	ff 1f       	adc	r31, r31
    5bb4:	bb 1f       	adc	r27, r27
    5bb6:	66 1f       	adc	r22, r22
    5bb8:	77 1f       	adc	r23, r23
    5bba:	88 1f       	adc	r24, r24
    5bbc:	91 50       	subi	r25, 0x01	; 1
    5bbe:	50 40       	sbci	r21, 0x00	; 0
    5bc0:	a9 f7       	brne	.-22     	; 0x5bac <__mulsf3_pse+0x64>
    5bc2:	9e 3f       	cpi	r25, 0xFE	; 254
    5bc4:	51 05       	cpc	r21, r1
    5bc6:	70 f0       	brcs	.+28     	; 0x5be4 <__mulsf3_pse+0x9c>
    5bc8:	ee ce       	rjmp	.-548    	; 0x59a6 <__fp_inf>
    5bca:	9f cf       	rjmp	.-194    	; 0x5b0a <__fp_szero>
    5bcc:	5f 3f       	cpi	r21, 0xFF	; 255
    5bce:	ec f3       	brlt	.-6      	; 0x5bca <__mulsf3_pse+0x82>
    5bd0:	98 3e       	cpi	r25, 0xE8	; 232
    5bd2:	dc f3       	brlt	.-10     	; 0x5bca <__mulsf3_pse+0x82>
    5bd4:	86 95       	lsr	r24
    5bd6:	77 95       	ror	r23
    5bd8:	67 95       	ror	r22
    5bda:	b7 95       	ror	r27
    5bdc:	f7 95       	ror	r31
    5bde:	e7 95       	ror	r30
    5be0:	9f 5f       	subi	r25, 0xFF	; 255
    5be2:	c1 f7       	brne	.-16     	; 0x5bd4 <__mulsf3_pse+0x8c>
    5be4:	fe 2b       	or	r31, r30
    5be6:	88 0f       	add	r24, r24
    5be8:	91 1d       	adc	r25, r1
    5bea:	96 95       	lsr	r25
    5bec:	87 95       	ror	r24
    5bee:	97 f9       	bld	r25, 7
    5bf0:	08 95       	ret

00005bf2 <square>:
    5bf2:	9b 01       	movw	r18, r22
    5bf4:	ac 01       	movw	r20, r24
    5bf6:	9a cf       	rjmp	.-204    	; 0x5b2c <__mulsf3>

00005bf8 <__mulsi3>:
    5bf8:	62 9f       	mul	r22, r18
    5bfa:	d0 01       	movw	r26, r0
    5bfc:	73 9f       	mul	r23, r19
    5bfe:	f0 01       	movw	r30, r0
    5c00:	82 9f       	mul	r24, r18
    5c02:	e0 0d       	add	r30, r0
    5c04:	f1 1d       	adc	r31, r1
    5c06:	64 9f       	mul	r22, r20
    5c08:	e0 0d       	add	r30, r0
    5c0a:	f1 1d       	adc	r31, r1
    5c0c:	92 9f       	mul	r25, r18
    5c0e:	f0 0d       	add	r31, r0
    5c10:	83 9f       	mul	r24, r19
    5c12:	f0 0d       	add	r31, r0
    5c14:	74 9f       	mul	r23, r20
    5c16:	f0 0d       	add	r31, r0
    5c18:	65 9f       	mul	r22, r21
    5c1a:	f0 0d       	add	r31, r0
    5c1c:	99 27       	eor	r25, r25
    5c1e:	72 9f       	mul	r23, r18
    5c20:	b0 0d       	add	r27, r0
    5c22:	e1 1d       	adc	r30, r1
    5c24:	f9 1f       	adc	r31, r25
    5c26:	63 9f       	mul	r22, r19
    5c28:	b0 0d       	add	r27, r0
    5c2a:	e1 1d       	adc	r30, r1
    5c2c:	f9 1f       	adc	r31, r25
    5c2e:	bd 01       	movw	r22, r26
    5c30:	cf 01       	movw	r24, r30
    5c32:	11 24       	eor	r1, r1
    5c34:	08 95       	ret

00005c36 <__udivmodhi4>:
    5c36:	aa 1b       	sub	r26, r26
    5c38:	bb 1b       	sub	r27, r27
    5c3a:	51 e1       	ldi	r21, 0x11	; 17
    5c3c:	07 c0       	rjmp	.+14     	; 0x5c4c <__udivmodhi4_ep>

00005c3e <__udivmodhi4_loop>:
    5c3e:	aa 1f       	adc	r26, r26
    5c40:	bb 1f       	adc	r27, r27
    5c42:	a6 17       	cp	r26, r22
    5c44:	b7 07       	cpc	r27, r23
    5c46:	10 f0       	brcs	.+4      	; 0x5c4c <__udivmodhi4_ep>
    5c48:	a6 1b       	sub	r26, r22
    5c4a:	b7 0b       	sbc	r27, r23

00005c4c <__udivmodhi4_ep>:
    5c4c:	88 1f       	adc	r24, r24
    5c4e:	99 1f       	adc	r25, r25
    5c50:	5a 95       	dec	r21
    5c52:	a9 f7       	brne	.-22     	; 0x5c3e <__udivmodhi4_loop>
    5c54:	80 95       	com	r24
    5c56:	90 95       	com	r25
    5c58:	bc 01       	movw	r22, r24
    5c5a:	cd 01       	movw	r24, r26
    5c5c:	08 95       	ret

00005c5e <__divmodhi4>:
    5c5e:	97 fb       	bst	r25, 7
    5c60:	09 2e       	mov	r0, r25
    5c62:	07 26       	eor	r0, r23
    5c64:	0a d0       	rcall	.+20     	; 0x5c7a <__divmodhi4_neg1>
    5c66:	77 fd       	sbrc	r23, 7
    5c68:	04 d0       	rcall	.+8      	; 0x5c72 <__divmodhi4_neg2>
    5c6a:	e5 df       	rcall	.-54     	; 0x5c36 <__udivmodhi4>
    5c6c:	06 d0       	rcall	.+12     	; 0x5c7a <__divmodhi4_neg1>
    5c6e:	00 20       	and	r0, r0
    5c70:	1a f4       	brpl	.+6      	; 0x5c78 <__divmodhi4_exit>

00005c72 <__divmodhi4_neg2>:
    5c72:	70 95       	com	r23
    5c74:	61 95       	neg	r22
    5c76:	7f 4f       	sbci	r23, 0xFF	; 255

00005c78 <__divmodhi4_exit>:
    5c78:	08 95       	ret

00005c7a <__divmodhi4_neg1>:
    5c7a:	f6 f7       	brtc	.-4      	; 0x5c78 <__divmodhi4_exit>
    5c7c:	90 95       	com	r25
    5c7e:	81 95       	neg	r24
    5c80:	9f 4f       	sbci	r25, 0xFF	; 255
    5c82:	08 95       	ret

00005c84 <__udivmodsi4>:
    5c84:	a1 e2       	ldi	r26, 0x21	; 33
    5c86:	1a 2e       	mov	r1, r26
    5c88:	aa 1b       	sub	r26, r26
    5c8a:	bb 1b       	sub	r27, r27
    5c8c:	fd 01       	movw	r30, r26
    5c8e:	0d c0       	rjmp	.+26     	; 0x5caa <__udivmodsi4_ep>

00005c90 <__udivmodsi4_loop>:
    5c90:	aa 1f       	adc	r26, r26
    5c92:	bb 1f       	adc	r27, r27
    5c94:	ee 1f       	adc	r30, r30
    5c96:	ff 1f       	adc	r31, r31
    5c98:	a2 17       	cp	r26, r18
    5c9a:	b3 07       	cpc	r27, r19
    5c9c:	e4 07       	cpc	r30, r20
    5c9e:	f5 07       	cpc	r31, r21
    5ca0:	20 f0       	brcs	.+8      	; 0x5caa <__udivmodsi4_ep>
    5ca2:	a2 1b       	sub	r26, r18
    5ca4:	b3 0b       	sbc	r27, r19
    5ca6:	e4 0b       	sbc	r30, r20
    5ca8:	f5 0b       	sbc	r31, r21

00005caa <__udivmodsi4_ep>:
    5caa:	66 1f       	adc	r22, r22
    5cac:	77 1f       	adc	r23, r23
    5cae:	88 1f       	adc	r24, r24
    5cb0:	99 1f       	adc	r25, r25
    5cb2:	1a 94       	dec	r1
    5cb4:	69 f7       	brne	.-38     	; 0x5c90 <__udivmodsi4_loop>
    5cb6:	60 95       	com	r22
    5cb8:	70 95       	com	r23
    5cba:	80 95       	com	r24
    5cbc:	90 95       	com	r25
    5cbe:	9b 01       	movw	r18, r22
    5cc0:	ac 01       	movw	r20, r24
    5cc2:	bd 01       	movw	r22, r26
    5cc4:	cf 01       	movw	r24, r30
    5cc6:	08 95       	ret

00005cc8 <__divmodsi4>:
    5cc8:	97 fb       	bst	r25, 7
    5cca:	09 2e       	mov	r0, r25
    5ccc:	05 26       	eor	r0, r21
    5cce:	0e d0       	rcall	.+28     	; 0x5cec <__divmodsi4_neg1>
    5cd0:	57 fd       	sbrc	r21, 7
    5cd2:	04 d0       	rcall	.+8      	; 0x5cdc <__divmodsi4_neg2>
    5cd4:	d7 df       	rcall	.-82     	; 0x5c84 <__udivmodsi4>
    5cd6:	0a d0       	rcall	.+20     	; 0x5cec <__divmodsi4_neg1>
    5cd8:	00 1c       	adc	r0, r0
    5cda:	38 f4       	brcc	.+14     	; 0x5cea <__divmodsi4_exit>

00005cdc <__divmodsi4_neg2>:
    5cdc:	50 95       	com	r21
    5cde:	40 95       	com	r20
    5ce0:	30 95       	com	r19
    5ce2:	21 95       	neg	r18
    5ce4:	3f 4f       	sbci	r19, 0xFF	; 255
    5ce6:	4f 4f       	sbci	r20, 0xFF	; 255
    5ce8:	5f 4f       	sbci	r21, 0xFF	; 255

00005cea <__divmodsi4_exit>:
    5cea:	08 95       	ret

00005cec <__divmodsi4_neg1>:
    5cec:	f6 f7       	brtc	.-4      	; 0x5cea <__divmodsi4_exit>
    5cee:	90 95       	com	r25
    5cf0:	80 95       	com	r24
    5cf2:	70 95       	com	r23
    5cf4:	61 95       	neg	r22
    5cf6:	7f 4f       	sbci	r23, 0xFF	; 255
    5cf8:	8f 4f       	sbci	r24, 0xFF	; 255
    5cfa:	9f 4f       	sbci	r25, 0xFF	; 255
    5cfc:	08 95       	ret

00005cfe <_exit>:
    5cfe:	f8 94       	cli

00005d00 <__stop_program>:
    5d00:	ff cf       	rjmp	.-2      	; 0x5d00 <__stop_program>

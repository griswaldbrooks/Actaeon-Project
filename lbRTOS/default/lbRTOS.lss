
lbRTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000be  00800200  00005ca4  00005d38  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00005ca4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00001403  008002be  008002be  00005df6  2**0
                  ALLOC
  3 .debug_aranges 000001a0  00000000  00000000  00005df6  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00001892  00000000  00000000  00005f96  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00005a3a  00000000  00000000  00007828  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001728  00000000  00000000  0000d262  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000491e  00000000  00000000  0000e98a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000011e0  00000000  00000000  000132a8  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00002477  00000000  00000000  00014488  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00002ac4  00000000  00000000  000168ff  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000030  00000000  00000000  000193c3  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 d8 00 	jmp	0x1b0	; 0x1b0 <__ctors_end>
       4:	0c 94 f5 00 	jmp	0x1ea	; 0x1ea <__bad_interrupt>
       8:	0c 94 f5 00 	jmp	0x1ea	; 0x1ea <__bad_interrupt>
       c:	0c 94 f5 00 	jmp	0x1ea	; 0x1ea <__bad_interrupt>
      10:	0c 94 f5 00 	jmp	0x1ea	; 0x1ea <__bad_interrupt>
      14:	0c 94 f5 00 	jmp	0x1ea	; 0x1ea <__bad_interrupt>
      18:	0c 94 f5 00 	jmp	0x1ea	; 0x1ea <__bad_interrupt>
      1c:	0c 94 f5 00 	jmp	0x1ea	; 0x1ea <__bad_interrupt>
      20:	0c 94 f5 00 	jmp	0x1ea	; 0x1ea <__bad_interrupt>
      24:	0c 94 f5 00 	jmp	0x1ea	; 0x1ea <__bad_interrupt>
      28:	0c 94 f5 00 	jmp	0x1ea	; 0x1ea <__bad_interrupt>
      2c:	0c 94 f5 00 	jmp	0x1ea	; 0x1ea <__bad_interrupt>
      30:	0c 94 f5 00 	jmp	0x1ea	; 0x1ea <__bad_interrupt>
      34:	0c 94 53 1d 	jmp	0x3aa6	; 0x3aa6 <__vector_13>
      38:	0c 94 80 1d 	jmp	0x3b00	; 0x3b00 <__vector_14>
      3c:	0c 94 72 1b 	jmp	0x36e4	; 0x36e4 <__vector_15>
      40:	0c 94 cc 1c 	jmp	0x3998	; 0x3998 <__vector_16>
      44:	0c 94 a0 16 	jmp	0x2d40	; 0x2d40 <__vector_17>
      48:	0c 94 f9 1c 	jmp	0x39f2	; 0x39f2 <__vector_18>
      4c:	0c 94 26 1d 	jmp	0x3a4c	; 0x3a4c <__vector_19>
      50:	0c 94 32 1b 	jmp	0x3664	; 0x3664 <__vector_20>
      54:	0c 94 72 1c 	jmp	0x38e4	; 0x38e4 <__vector_21>
      58:	0c 94 9f 1c 	jmp	0x393e	; 0x393e <__vector_22>
      5c:	0c 94 df 1a 	jmp	0x35be	; 0x35be <__vector_23>
      60:	0c 94 f5 00 	jmp	0x1ea	; 0x1ea <__bad_interrupt>
      64:	0c 94 49 21 	jmp	0x4292	; 0x4292 <__vector_25>
      68:	0c 94 f5 00 	jmp	0x1ea	; 0x1ea <__bad_interrupt>
      6c:	0c 94 a6 22 	jmp	0x454c	; 0x454c <__vector_27>
      70:	0c 94 f5 00 	jmp	0x1ea	; 0x1ea <__bad_interrupt>
      74:	0c 94 60 25 	jmp	0x4ac0	; 0x4ac0 <__vector_29>
      78:	0c 94 f5 00 	jmp	0x1ea	; 0x1ea <__bad_interrupt>
      7c:	0c 94 ad 1d 	jmp	0x3b5a	; 0x3b5a <__vector_31>
      80:	0c 94 da 1d 	jmp	0x3bb4	; 0x3bb4 <__vector_32>
      84:	0c 94 07 1e 	jmp	0x3c0e	; 0x3c0e <__vector_33>
      88:	0c 94 34 1e 	jmp	0x3c68	; 0x3c68 <__vector_34>
      8c:	0c 94 b2 1b 	jmp	0x3764	; 0x3764 <__vector_35>
      90:	0c 94 24 21 	jmp	0x4248	; 0x4248 <__vector_36>
      94:	0c 94 f5 00 	jmp	0x1ea	; 0x1ea <__bad_interrupt>
      98:	0c 94 81 22 	jmp	0x4502	; 0x4502 <__vector_38>
      9c:	0c 94 7e 29 	jmp	0x52fc	; 0x52fc <__vector_39>
      a0:	0c 94 f5 00 	jmp	0x1ea	; 0x1ea <__bad_interrupt>
      a4:	0c 94 61 1e 	jmp	0x3cc2	; 0x3cc2 <__vector_41>
      a8:	0c 94 8e 1e 	jmp	0x3d1c	; 0x3d1c <__vector_42>
      ac:	0c 94 bb 1e 	jmp	0x3d76	; 0x3d76 <__vector_43>
      b0:	0c 94 e8 1e 	jmp	0x3dd0	; 0x3dd0 <__vector_44>
      b4:	0c 94 f2 1b 	jmp	0x37e4	; 0x37e4 <__vector_45>
      b8:	0c 94 15 1f 	jmp	0x3e2a	; 0x3e2a <__vector_46>
      bc:	0c 94 42 1f 	jmp	0x3e84	; 0x3e84 <__vector_47>
      c0:	0c 94 6f 1f 	jmp	0x3ede	; 0x3ede <__vector_48>
      c4:	0c 94 9c 1f 	jmp	0x3f38	; 0x3f38 <__vector_49>
      c8:	0c 94 32 1c 	jmp	0x3864	; 0x3864 <__vector_50>
      cc:	0c 94 ff 20 	jmp	0x41fe	; 0x41fe <__vector_51>
      d0:	0c 94 f5 00 	jmp	0x1ea	; 0x1ea <__bad_interrupt>
      d4:	0c 94 5c 22 	jmp	0x44b8	; 0x44b8 <__vector_53>
      d8:	0c 94 da 20 	jmp	0x41b4	; 0x41b4 <__vector_54>
      dc:	0c 94 f5 00 	jmp	0x1ea	; 0x1ea <__bad_interrupt>
      e0:	0c 94 37 22 	jmp	0x446e	; 0x446e <__vector_56>
      e4:	08 4a       	sbci	r16, 0xA8	; 168
      e6:	d7 3b       	cpi	r29, 0xB7	; 183
      e8:	3b ce       	rjmp	.-906    	; 0xfffffd60 <__eeprom_end+0xff7efd60>
      ea:	01 6e       	ori	r16, 0xE1	; 225
      ec:	84 bc       	out	0x24, r8	; 36
      ee:	bf fd       	.word	0xfdbf	; ????
      f0:	c1 2f       	mov	r28, r17
      f2:	3d 6c       	ori	r19, 0xCD	; 205
      f4:	74 31       	cpi	r23, 0x14	; 20
      f6:	9a bd       	out	0x2a, r25	; 42
      f8:	56 83       	std	Z+6, r21	; 0x06
      fa:	3d da       	rcall	.-2950   	; 0xfffff576 <__eeprom_end+0xff7ef576>
      fc:	3d 00       	.word	0x003d	; ????
      fe:	c7 7f       	andi	r28, 0xF7	; 247
     100:	11 be       	out	0x31, r1	; 49
     102:	d9 e4       	ldi	r29, 0x49	; 73
     104:	bb 4c       	sbci	r27, 0xCB	; 203
     106:	3e 91       	ld	r19, -X
     108:	6b aa       	std	Y+51, r6	; 0x33
     10a:	aa be       	out	0x3a, r10	; 58
     10c:	00 00       	nop
     10e:	00 80       	ld	r0, Z
     110:	3f 44       	sbci	r19, 0x4F	; 79

00000111 <__c.3339>:
     111:	44 45 41 54 48 0a 00                                DEATH..

00000118 <__c.3328>:
     118:	63 6d 64 5f 61 6e 67 6c 65 3a 20 00                 cmd_angle: .

00000124 <__c.3326>:
     124:	63 6d 64 5f 61 6e 67 6c 65 3a 20 00                 cmd_angle: .

00000130 <__c.3220>:
     130:	0a 00                                               ..

00000132 <__c.3218>:
     132:	25 64 00                                            %d.

00000135 <__c.3206>:
     135:	25 64 0a 00                                         %d..

00000139 <__c.3121>:
     139:	49 6e 69 74 69 61 6c 69 7a 61 74 69 6f 6e 20 43     Initialization C
     149:	6f 6d 70 6c 65 74 65 20 0d 0a 00                    omplete ...

00000154 <__c.3116>:
     154:	2e 00                                               ..

00000156 <__c.3114>:
     156:	0d 0a 53 79 73 74 65 6d 20 57 61 72 6d 65 64 20     ..System Warmed 
     166:	55 70 00                                            Up.

00000169 <__c.3045>:
     169:	57 52 0a 00                                         WR..

0000016d <__c.3014>:
     16d:	57 52 0a 00                                         WR..

00000171 <TimerPrescaleFactor>:
     171:	00 00 01 00 08 00 40 00 00 01 00 04                 ......@.....

0000017d <Timer2PrescaleFactor>:
     17d:	00 00 01 00 08 00 20 00 40 00 80 00 00 01 00 04     ...... .@.......

0000018d <__c.1991>:
     18d:	42 41 44 5f 76 65 63 74 20 63 61 6c 6c 65 64 21     BAD_vect called!
	...

0000019e <HexChars>:
     19e:	30 31 32 33 34 35 36 37 38 39 41 42 43 44 45 46     0123456789ABCDEF
	...

000001b0 <__ctors_end>:
     1b0:	11 24       	eor	r1, r1
     1b2:	1f be       	out	0x3f, r1	; 63
     1b4:	cf ef       	ldi	r28, 0xFF	; 255
     1b6:	d1 e2       	ldi	r29, 0x21	; 33
     1b8:	de bf       	out	0x3e, r29	; 62
     1ba:	cd bf       	out	0x3d, r28	; 61

000001bc <__do_copy_data>:
     1bc:	12 e0       	ldi	r17, 0x02	; 2
     1be:	a0 e0       	ldi	r26, 0x00	; 0
     1c0:	b2 e0       	ldi	r27, 0x02	; 2
     1c2:	e4 ea       	ldi	r30, 0xA4	; 164
     1c4:	fc e5       	ldi	r31, 0x5C	; 92
     1c6:	02 c0       	rjmp	.+4      	; 0x1cc <.do_copy_data_start>

000001c8 <.do_copy_data_loop>:
     1c8:	05 90       	lpm	r0, Z+
     1ca:	0d 92       	st	X+, r0

000001cc <.do_copy_data_start>:
     1cc:	ae 3b       	cpi	r26, 0xBE	; 190
     1ce:	b1 07       	cpc	r27, r17
     1d0:	d9 f7       	brne	.-10     	; 0x1c8 <.do_copy_data_loop>

000001d2 <__do_clear_bss>:
     1d2:	16 e1       	ldi	r17, 0x16	; 22
     1d4:	ae eb       	ldi	r26, 0xBE	; 190
     1d6:	b2 e0       	ldi	r27, 0x02	; 2
     1d8:	01 c0       	rjmp	.+2      	; 0x1dc <.do_clear_bss_start>

000001da <.do_clear_bss_loop>:
     1da:	1d 92       	st	X+, r1

000001dc <.do_clear_bss_start>:
     1dc:	a1 3c       	cpi	r26, 0xC1	; 193
     1de:	b1 07       	cpc	r27, r17
     1e0:	e1 f7       	brne	.-8      	; 0x1da <.do_clear_bss_loop>
     1e2:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <main>
     1e6:	0c 94 aa 2a 	jmp	0x5554	; 0x5554 <exit>

000001ea <__bad_interrupt>:
     1ea:	0c 94 c9 1f 	jmp	0x3f92	; 0x3f92 <__vector_default>

000001ee <PWM_Init_timer1_LED>:

//OC1B  pin B6 (attached to green LED)
void PWM_Init_timer1_LED(u08 bitRes)
{
	// enable timer2 as 8,9,10bit PWM
	if(bitRes == 9)
     1ee:	89 30       	cpi	r24, 0x09	; 9
     1f0:	49 f4       	brne	.+18     	; 0x204 <PWM_Init_timer1_LED+0x16>
	{	// 9bit mode
		sbi(TCCR1A,PWM11);
     1f2:	80 91 80 00 	lds	r24, 0x0080
     1f6:	82 60       	ori	r24, 0x02	; 2
     1f8:	80 93 80 00 	sts	0x0080, r24
		cbi(TCCR1A,PWM10);
     1fc:	80 91 80 00 	lds	r24, 0x0080
     200:	8e 7f       	andi	r24, 0xFE	; 254
     202:	0e c0       	rjmp	.+28     	; 0x220 <PWM_Init_timer1_LED+0x32>
	}
	else if( bitRes == 10 )
     204:	8a 30       	cpi	r24, 0x0A	; 10
     206:	21 f4       	brne	.+8      	; 0x210 <PWM_Init_timer1_LED+0x22>
	{	// 10bit mode
		sbi(TCCR1A,PWM11);
     208:	80 91 80 00 	lds	r24, 0x0080
     20c:	82 60       	ori	r24, 0x02	; 2
     20e:	03 c0       	rjmp	.+6      	; 0x216 <PWM_Init_timer1_LED+0x28>
		sbi(TCCR1A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR1A,PWM11);
     210:	80 91 80 00 	lds	r24, 0x0080
     214:	8d 7f       	andi	r24, 0xFD	; 253
     216:	80 93 80 00 	sts	0x0080, r24
		sbi(TCCR1A,PWM10);
     21a:	80 91 80 00 	lds	r24, 0x0080
     21e:	81 60       	ori	r24, 0x01	; 1
     220:	80 93 80 00 	sts	0x0080, r24
	}
	// clear output compare values
	OCR1B = 0;
     224:	10 92 8b 00 	sts	0x008B, r1
     228:	10 92 8a 00 	sts	0x008A, r1
}
     22c:	08 95       	ret

0000022e <PWM_Init_timer2_H6>:
//pin H6, timer2
void PWM_Init_timer2_H6(u08 bitRes)
{
	// enable timer2 as 8,9,10bit PWM
	if(bitRes == 9)
     22e:	89 30       	cpi	r24, 0x09	; 9
     230:	49 f4       	brne	.+18     	; 0x244 <PWM_Init_timer2_H6+0x16>
	{	// 9bit mode
		sbi(TCCR2A,PWM11);
     232:	80 91 b0 00 	lds	r24, 0x00B0
     236:	82 60       	ori	r24, 0x02	; 2
     238:	80 93 b0 00 	sts	0x00B0, r24
		cbi(TCCR2A,PWM10);
     23c:	80 91 b0 00 	lds	r24, 0x00B0
     240:	8e 7f       	andi	r24, 0xFE	; 254
     242:	0e c0       	rjmp	.+28     	; 0x260 <PWM_Init_timer2_H6+0x32>
	}
	else if( bitRes == 10 )
     244:	8a 30       	cpi	r24, 0x0A	; 10
     246:	21 f4       	brne	.+8      	; 0x250 <PWM_Init_timer2_H6+0x22>
	{	// 10bit mode
		sbi(TCCR2A,PWM11);
     248:	80 91 b0 00 	lds	r24, 0x00B0
     24c:	82 60       	ori	r24, 0x02	; 2
     24e:	03 c0       	rjmp	.+6      	; 0x256 <PWM_Init_timer2_H6+0x28>
		sbi(TCCR2A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR2A,PWM11);
     250:	80 91 b0 00 	lds	r24, 0x00B0
     254:	8d 7f       	andi	r24, 0xFD	; 253
     256:	80 93 b0 00 	sts	0x00B0, r24
		sbi(TCCR2A,PWM10);
     25a:	80 91 b0 00 	lds	r24, 0x00B0
     25e:	81 60       	ori	r24, 0x01	; 1
     260:	80 93 b0 00 	sts	0x00B0, r24
	}
	// clear output compare values
	OCR2B = 0;
     264:	10 92 b4 00 	sts	0x00B4, r1
}
     268:	08 95       	ret

0000026a <PWM_Init_timer3_E3>:
//pin E3
void PWM_Init_timer3_E3(u08 bitRes)
{
	// enable timer3 as 8,9,10bit PWM
	if(bitRes == 9)
     26a:	89 30       	cpi	r24, 0x09	; 9
     26c:	49 f4       	brne	.+18     	; 0x280 <PWM_Init_timer3_E3+0x16>
	{	// 9bit mode
		sbi(TCCR3A,PWM11);
     26e:	80 91 90 00 	lds	r24, 0x0090
     272:	82 60       	ori	r24, 0x02	; 2
     274:	80 93 90 00 	sts	0x0090, r24
		cbi(TCCR3A,PWM10);
     278:	80 91 90 00 	lds	r24, 0x0090
     27c:	8e 7f       	andi	r24, 0xFE	; 254
     27e:	0e c0       	rjmp	.+28     	; 0x29c <PWM_Init_timer3_E3+0x32>
	}
	else if( bitRes == 10 )
     280:	8a 30       	cpi	r24, 0x0A	; 10
     282:	21 f4       	brne	.+8      	; 0x28c <PWM_Init_timer3_E3+0x22>
	{	// 10bit mode
		sbi(TCCR3A,PWM11);
     284:	80 91 90 00 	lds	r24, 0x0090
     288:	82 60       	ori	r24, 0x02	; 2
     28a:	03 c0       	rjmp	.+6      	; 0x292 <PWM_Init_timer3_E3+0x28>
		sbi(TCCR3A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR3A,PWM11);
     28c:	80 91 90 00 	lds	r24, 0x0090
     290:	8d 7f       	andi	r24, 0xFD	; 253
     292:	80 93 90 00 	sts	0x0090, r24
		sbi(TCCR3A,PWM10);
     296:	80 91 90 00 	lds	r24, 0x0090
     29a:	81 60       	ori	r24, 0x01	; 1
     29c:	80 93 90 00 	sts	0x0090, r24
	}
	// clear output compare values
	OCR3A = 0;
     2a0:	10 92 99 00 	sts	0x0099, r1
     2a4:	10 92 98 00 	sts	0x0098, r1
	//timer3PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     2a8:	08 95       	ret

000002aa <PWM_Init_timer3_E4>:
//pin E4
void PWM_Init_timer3_E4(u08 bitRes)
{
	// enable timer3 as 8,9,10bit PWM
	if(bitRes == 9)
     2aa:	89 30       	cpi	r24, 0x09	; 9
     2ac:	49 f4       	brne	.+18     	; 0x2c0 <PWM_Init_timer3_E4+0x16>
	{	// 9bit mode
		sbi(TCCR3B,PWM11);
     2ae:	80 91 91 00 	lds	r24, 0x0091
     2b2:	82 60       	ori	r24, 0x02	; 2
     2b4:	80 93 91 00 	sts	0x0091, r24
		cbi(TCCR3B,PWM10);
     2b8:	80 91 91 00 	lds	r24, 0x0091
     2bc:	8e 7f       	andi	r24, 0xFE	; 254
     2be:	0e c0       	rjmp	.+28     	; 0x2dc <PWM_Init_timer3_E4+0x32>
	}
	else if( bitRes == 10 )
     2c0:	8a 30       	cpi	r24, 0x0A	; 10
     2c2:	21 f4       	brne	.+8      	; 0x2cc <PWM_Init_timer3_E4+0x22>
	{	// 10bit mode
		sbi(TCCR3B,PWM11);
     2c4:	80 91 91 00 	lds	r24, 0x0091
     2c8:	82 60       	ori	r24, 0x02	; 2
     2ca:	03 c0       	rjmp	.+6      	; 0x2d2 <PWM_Init_timer3_E4+0x28>
		sbi(TCCR3B,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR3B,PWM11);
     2cc:	80 91 91 00 	lds	r24, 0x0091
     2d0:	8d 7f       	andi	r24, 0xFD	; 253
     2d2:	80 93 91 00 	sts	0x0091, r24
		sbi(TCCR3B,PWM10);
     2d6:	80 91 91 00 	lds	r24, 0x0091
     2da:	81 60       	ori	r24, 0x01	; 1
     2dc:	80 93 91 00 	sts	0x0091, r24
	}
	// clear output compare values
	OCR3B = 0;
     2e0:	10 92 9b 00 	sts	0x009B, r1
     2e4:	10 92 9a 00 	sts	0x009A, r1
	//timer3PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     2e8:	08 95       	ret

000002ea <PWM_Init_timer3_E5>:
//pin E5
void PWM_Init_timer3_E5(u08 bitRes)
{
	// enable timer3 as 8,9,10bit PWM
	if(bitRes == 9)
     2ea:	89 30       	cpi	r24, 0x09	; 9
     2ec:	49 f4       	brne	.+18     	; 0x300 <PWM_Init_timer3_E5+0x16>
	{	// 9bit mode
		sbi(TCCR3C,PWM11);
     2ee:	80 91 92 00 	lds	r24, 0x0092
     2f2:	82 60       	ori	r24, 0x02	; 2
     2f4:	80 93 92 00 	sts	0x0092, r24
		cbi(TCCR3C,PWM10);
     2f8:	80 91 92 00 	lds	r24, 0x0092
     2fc:	8e 7f       	andi	r24, 0xFE	; 254
     2fe:	0e c0       	rjmp	.+28     	; 0x31c <PWM_Init_timer3_E5+0x32>
	}
	else if( bitRes == 10 )
     300:	8a 30       	cpi	r24, 0x0A	; 10
     302:	21 f4       	brne	.+8      	; 0x30c <PWM_Init_timer3_E5+0x22>
	{	// 10bit mode
		sbi(TCCR3C,PWM11);
     304:	80 91 92 00 	lds	r24, 0x0092
     308:	82 60       	ori	r24, 0x02	; 2
     30a:	03 c0       	rjmp	.+6      	; 0x312 <PWM_Init_timer3_E5+0x28>
		sbi(TCCR3C,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR3C,PWM11);
     30c:	80 91 92 00 	lds	r24, 0x0092
     310:	8d 7f       	andi	r24, 0xFD	; 253
     312:	80 93 92 00 	sts	0x0092, r24
		sbi(TCCR3C,PWM10);
     316:	80 91 92 00 	lds	r24, 0x0092
     31a:	81 60       	ori	r24, 0x01	; 1
     31c:	80 93 92 00 	sts	0x0092, r24
	}
	// clear output compare values
	OCR3C = 0;
     320:	10 92 9d 00 	sts	0x009D, r1
     324:	10 92 9c 00 	sts	0x009C, r1
	//timer3PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     328:	08 95       	ret

0000032a <PWM_Init_timer4_H3>:
//pin H3, timer4
void PWM_Init_timer4_H3(u08 bitRes)
{
	// enable timer4 as 8,9,10bit PWM
	if(bitRes == 9)
     32a:	89 30       	cpi	r24, 0x09	; 9
     32c:	49 f4       	brne	.+18     	; 0x340 <PWM_Init_timer4_H3+0x16>
	{	// 9bit mode
		sbi(TCCR4A,PWM11);
     32e:	80 91 a0 00 	lds	r24, 0x00A0
     332:	82 60       	ori	r24, 0x02	; 2
     334:	80 93 a0 00 	sts	0x00A0, r24
		cbi(TCCR4A,PWM10);
     338:	80 91 a0 00 	lds	r24, 0x00A0
     33c:	8e 7f       	andi	r24, 0xFE	; 254
     33e:	0e c0       	rjmp	.+28     	; 0x35c <PWM_Init_timer4_H3+0x32>
	}
	else if( bitRes == 10 )
     340:	8a 30       	cpi	r24, 0x0A	; 10
     342:	21 f4       	brne	.+8      	; 0x34c <PWM_Init_timer4_H3+0x22>
	{	// 10bit mode
		sbi(TCCR4A,PWM11);
     344:	80 91 a0 00 	lds	r24, 0x00A0
     348:	82 60       	ori	r24, 0x02	; 2
     34a:	03 c0       	rjmp	.+6      	; 0x352 <PWM_Init_timer4_H3+0x28>
		sbi(TCCR4A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR4A,PWM11);
     34c:	80 91 a0 00 	lds	r24, 0x00A0
     350:	8d 7f       	andi	r24, 0xFD	; 253
     352:	80 93 a0 00 	sts	0x00A0, r24
		sbi(TCCR4A,PWM10);
     356:	80 91 a0 00 	lds	r24, 0x00A0
     35a:	81 60       	ori	r24, 0x01	; 1
     35c:	80 93 a0 00 	sts	0x00A0, r24
	}
	// clear output compare values
	OCR4A = 0;
     360:	10 92 a9 00 	sts	0x00A9, r1
     364:	10 92 a8 00 	sts	0x00A8, r1
	//timer4PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     368:	08 95       	ret

0000036a <PWM_Init_timer4_H4>:
//pin H4, timer4
void PWM_Init_timer4_H4(u08 bitRes)
{
	// enable timer4 as 8,9,10bit PWM
	if(bitRes == 9)
     36a:	89 30       	cpi	r24, 0x09	; 9
     36c:	49 f4       	brne	.+18     	; 0x380 <PWM_Init_timer4_H4+0x16>
	{	// 9bit mode
		sbi(TCCR4B,PWM11);
     36e:	80 91 a1 00 	lds	r24, 0x00A1
     372:	82 60       	ori	r24, 0x02	; 2
     374:	80 93 a1 00 	sts	0x00A1, r24
		cbi(TCCR4B,PWM10);
     378:	80 91 a1 00 	lds	r24, 0x00A1
     37c:	8e 7f       	andi	r24, 0xFE	; 254
     37e:	0e c0       	rjmp	.+28     	; 0x39c <PWM_Init_timer4_H4+0x32>
	}
	else if( bitRes == 10 )
     380:	8a 30       	cpi	r24, 0x0A	; 10
     382:	21 f4       	brne	.+8      	; 0x38c <PWM_Init_timer4_H4+0x22>
	{	// 10bit mode
		sbi(TCCR4B,PWM11);
     384:	80 91 a1 00 	lds	r24, 0x00A1
     388:	82 60       	ori	r24, 0x02	; 2
     38a:	03 c0       	rjmp	.+6      	; 0x392 <PWM_Init_timer4_H4+0x28>
		sbi(TCCR4B,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR4B,PWM11);
     38c:	80 91 a1 00 	lds	r24, 0x00A1
     390:	8d 7f       	andi	r24, 0xFD	; 253
     392:	80 93 a1 00 	sts	0x00A1, r24
		sbi(TCCR4B,PWM10);
     396:	80 91 a1 00 	lds	r24, 0x00A1
     39a:	81 60       	ori	r24, 0x01	; 1
     39c:	80 93 a1 00 	sts	0x00A1, r24
	}
	// clear output compare values
	OCR4B = 0;
     3a0:	10 92 ab 00 	sts	0x00AB, r1
     3a4:	10 92 aa 00 	sts	0x00AA, r1
	//timer4PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     3a8:	08 95       	ret

000003aa <PWM_Init_timer4_H5>:
//pin H5, timer4
void PWM_Init_timer4_H5(u08 bitRes)
{
	// enable timer4 as 8,9,10bit PWM
	if(bitRes == 9)
     3aa:	89 30       	cpi	r24, 0x09	; 9
     3ac:	49 f4       	brne	.+18     	; 0x3c0 <PWM_Init_timer4_H5+0x16>
	{	// 9bit mode
		sbi(TCCR4A,PWM11);
     3ae:	80 91 a0 00 	lds	r24, 0x00A0
     3b2:	82 60       	ori	r24, 0x02	; 2
     3b4:	80 93 a0 00 	sts	0x00A0, r24
		cbi(TCCR4A,PWM10);
     3b8:	80 91 a0 00 	lds	r24, 0x00A0
     3bc:	8e 7f       	andi	r24, 0xFE	; 254
     3be:	0e c0       	rjmp	.+28     	; 0x3dc <PWM_Init_timer4_H5+0x32>
	}
	else if( bitRes == 10 )
     3c0:	8a 30       	cpi	r24, 0x0A	; 10
     3c2:	21 f4       	brne	.+8      	; 0x3cc <PWM_Init_timer4_H5+0x22>
	{	// 10bit mode
		sbi(TCCR4A,PWM11);
     3c4:	80 91 a0 00 	lds	r24, 0x00A0
     3c8:	82 60       	ori	r24, 0x02	; 2
     3ca:	03 c0       	rjmp	.+6      	; 0x3d2 <PWM_Init_timer4_H5+0x28>
		sbi(TCCR4A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR4A,PWM11);
     3cc:	80 91 a0 00 	lds	r24, 0x00A0
     3d0:	8d 7f       	andi	r24, 0xFD	; 253
     3d2:	80 93 a0 00 	sts	0x00A0, r24
		sbi(TCCR4A,PWM10);
     3d6:	80 91 a0 00 	lds	r24, 0x00A0
     3da:	81 60       	ori	r24, 0x01	; 1
     3dc:	80 93 a0 00 	sts	0x00A0, r24
	}
	// clear output compare values
	OCR4C = 0;
     3e0:	10 92 ad 00 	sts	0x00AD, r1
     3e4:	10 92 ac 00 	sts	0x00AC, r1
	//timer4PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     3e8:	08 95       	ret

000003ea <timer1PWMInitICR>:
// include support for arbitrary top-count PWM
// on new AVR processors that support it
void timer1PWMInitICR(u16 topcount)
{
	// set PWM mode with ICR top-count
	cbi(TCCR1A,WGM10);
     3ea:	e0 e8       	ldi	r30, 0x80	; 128
     3ec:	f0 e0       	ldi	r31, 0x00	; 0
     3ee:	20 81       	ld	r18, Z
     3f0:	2e 7f       	andi	r18, 0xFE	; 254
     3f2:	20 83       	st	Z, r18
	sbi(TCCR1A,WGM11);
     3f4:	20 81       	ld	r18, Z
     3f6:	22 60       	ori	r18, 0x02	; 2
     3f8:	20 83       	st	Z, r18
	sbi(TCCR1B,WGM12);
     3fa:	e1 e8       	ldi	r30, 0x81	; 129
     3fc:	f0 e0       	ldi	r31, 0x00	; 0
     3fe:	20 81       	ld	r18, Z
     400:	28 60       	ori	r18, 0x08	; 8
     402:	20 83       	st	Z, r18
	sbi(TCCR1B,WGM13);
     404:	20 81       	ld	r18, Z
     406:	20 61       	ori	r18, 0x10	; 16
     408:	20 83       	st	Z, r18
	
	// set top count value
	ICR1 = topcount;
     40a:	90 93 87 00 	sts	0x0087, r25
     40e:	80 93 86 00 	sts	0x0086, r24
	
	// clear output compare values
	OCR1A = 0;
     412:	10 92 89 00 	sts	0x0089, r1
     416:	10 92 88 00 	sts	0x0088, r1
	OCR1B = 0;
     41a:	10 92 8b 00 	sts	0x008B, r1
     41e:	10 92 8a 00 	sts	0x008A, r1
	OCR1C = 0;
     422:	10 92 8d 00 	sts	0x008D, r1
     426:	10 92 8c 00 	sts	0x008C, r1
}
     42a:	08 95       	ret

0000042c <timer3PWMInitICR>:
void timer3PWMInitICR(u16 topcount)
{
	// set PWM mode with ICR top-count
	cbi(TCCR3A,WGM10);
     42c:	e0 e9       	ldi	r30, 0x90	; 144
     42e:	f0 e0       	ldi	r31, 0x00	; 0
     430:	20 81       	ld	r18, Z
     432:	2e 7f       	andi	r18, 0xFE	; 254
     434:	20 83       	st	Z, r18
	sbi(TCCR3A,WGM11);
     436:	20 81       	ld	r18, Z
     438:	22 60       	ori	r18, 0x02	; 2
     43a:	20 83       	st	Z, r18
	sbi(TCCR3B,WGM12);
     43c:	e1 e9       	ldi	r30, 0x91	; 145
     43e:	f0 e0       	ldi	r31, 0x00	; 0
     440:	20 81       	ld	r18, Z
     442:	28 60       	ori	r18, 0x08	; 8
     444:	20 83       	st	Z, r18
	sbi(TCCR3B,WGM13);
     446:	20 81       	ld	r18, Z
     448:	20 61       	ori	r18, 0x10	; 16
     44a:	20 83       	st	Z, r18
	
	// set top count value
	ICR3 = topcount;
     44c:	90 93 97 00 	sts	0x0097, r25
     450:	80 93 96 00 	sts	0x0096, r24
	
	// clear output compare values
	OCR3A = 0;
     454:	10 92 99 00 	sts	0x0099, r1
     458:	10 92 98 00 	sts	0x0098, r1
	OCR3B = 0;
     45c:	10 92 9b 00 	sts	0x009B, r1
     460:	10 92 9a 00 	sts	0x009A, r1
	OCR3C = 0;
     464:	10 92 9d 00 	sts	0x009D, r1
     468:	10 92 9c 00 	sts	0x009C, r1
}
     46c:	08 95       	ret

0000046e <timer4PWMInitICR>:
void timer4PWMInitICR(u16 topcount)
{
	// set PWM mode with ICR top-count
	cbi(TCCR4A,WGM10);
     46e:	e0 ea       	ldi	r30, 0xA0	; 160
     470:	f0 e0       	ldi	r31, 0x00	; 0
     472:	20 81       	ld	r18, Z
     474:	2e 7f       	andi	r18, 0xFE	; 254
     476:	20 83       	st	Z, r18
	sbi(TCCR4A,WGM11);
     478:	20 81       	ld	r18, Z
     47a:	22 60       	ori	r18, 0x02	; 2
     47c:	20 83       	st	Z, r18
	sbi(TCCR4B,WGM12);
     47e:	e1 ea       	ldi	r30, 0xA1	; 161
     480:	f0 e0       	ldi	r31, 0x00	; 0
     482:	20 81       	ld	r18, Z
     484:	28 60       	ori	r18, 0x08	; 8
     486:	20 83       	st	Z, r18
	sbi(TCCR4B,WGM13);
     488:	20 81       	ld	r18, Z
     48a:	20 61       	ori	r18, 0x10	; 16
     48c:	20 83       	st	Z, r18
	
	// set top count value
	ICR4 = topcount;
     48e:	90 93 a7 00 	sts	0x00A7, r25
     492:	80 93 a6 00 	sts	0x00A6, r24
	
	// clear output compare values
	OCR4A = 0;
     496:	10 92 a9 00 	sts	0x00A9, r1
     49a:	10 92 a8 00 	sts	0x00A8, r1
	OCR4B = 0;
     49e:	10 92 ab 00 	sts	0x00AB, r1
     4a2:	10 92 aa 00 	sts	0x00AA, r1
	OCR4C = 0;
     4a6:	10 92 ad 00 	sts	0x00AD, r1
     4aa:	10 92 ac 00 	sts	0x00AC, r1
}
     4ae:	08 95       	ret

000004b0 <PWM_timer1_On_LED>:
#endif

//on commands
void PWM_timer1_On_LED(void)
{
	sbi(TCCR1A,COM1B1);
     4b0:	e0 e8       	ldi	r30, 0x80	; 128
     4b2:	f0 e0       	ldi	r31, 0x00	; 0
     4b4:	80 81       	ld	r24, Z
     4b6:	80 62       	ori	r24, 0x20	; 32
     4b8:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B0);
     4ba:	80 81       	ld	r24, Z
     4bc:	8f 7e       	andi	r24, 0xEF	; 239
     4be:	80 83       	st	Z, r24
}
     4c0:	08 95       	ret

000004c2 <PWM_timer2_On_H6>:
void PWM_timer2_On_H6(void)
{
	sbi(TCCR2A,COM2B1);
     4c2:	e0 eb       	ldi	r30, 0xB0	; 176
     4c4:	f0 e0       	ldi	r31, 0x00	; 0
     4c6:	80 81       	ld	r24, Z
     4c8:	80 62       	ori	r24, 0x20	; 32
     4ca:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B0);
     4cc:	80 81       	ld	r24, Z
     4ce:	8f 7e       	andi	r24, 0xEF	; 239
     4d0:	80 83       	st	Z, r24
}
     4d2:	08 95       	ret

000004d4 <PWM_timer3_On_E3>:
void PWM_timer3_On_E3(void)
{
	sbi(TCCR3A,COM3A1);
     4d4:	e0 e9       	ldi	r30, 0x90	; 144
     4d6:	f0 e0       	ldi	r31, 0x00	; 0
     4d8:	80 81       	ld	r24, Z
     4da:	80 68       	ori	r24, 0x80	; 128
     4dc:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3A0);
     4de:	80 81       	ld	r24, Z
     4e0:	8f 7b       	andi	r24, 0xBF	; 191
     4e2:	80 83       	st	Z, r24
}
     4e4:	08 95       	ret

000004e6 <PWM_timer3_On_E4>:
void PWM_timer3_On_E4(void)
{
	sbi(TCCR3A,COM3B1);
     4e6:	e0 e9       	ldi	r30, 0x90	; 144
     4e8:	f0 e0       	ldi	r31, 0x00	; 0
     4ea:	80 81       	ld	r24, Z
     4ec:	80 62       	ori	r24, 0x20	; 32
     4ee:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3B0);
     4f0:	80 81       	ld	r24, Z
     4f2:	8f 7e       	andi	r24, 0xEF	; 239
     4f4:	80 83       	st	Z, r24
}
     4f6:	08 95       	ret

000004f8 <PWM_timer3_On_E5>:
void PWM_timer3_On_E5(void)
{
	sbi(TCCR3A,COM3C1);
     4f8:	e0 e9       	ldi	r30, 0x90	; 144
     4fa:	f0 e0       	ldi	r31, 0x00	; 0
     4fc:	80 81       	ld	r24, Z
     4fe:	88 60       	ori	r24, 0x08	; 8
     500:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C0);
     502:	80 81       	ld	r24, Z
     504:	8b 7f       	andi	r24, 0xFB	; 251
     506:	80 83       	st	Z, r24
}
     508:	08 95       	ret

0000050a <PWM_timer4_On_H3>:
void PWM_timer4_On_H3(void)
{
	sbi(TCCR4A,COM4A1);
     50a:	e0 ea       	ldi	r30, 0xA0	; 160
     50c:	f0 e0       	ldi	r31, 0x00	; 0
     50e:	80 81       	ld	r24, Z
     510:	80 68       	ori	r24, 0x80	; 128
     512:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4A0);
     514:	80 81       	ld	r24, Z
     516:	8f 7b       	andi	r24, 0xBF	; 191
     518:	80 83       	st	Z, r24
}
     51a:	08 95       	ret

0000051c <PWM_timer4_On_H4>:
void PWM_timer4_On_H4(void)
{
	sbi(TCCR4A,COM4B1);
     51c:	e0 ea       	ldi	r30, 0xA0	; 160
     51e:	f0 e0       	ldi	r31, 0x00	; 0
     520:	80 81       	ld	r24, Z
     522:	80 62       	ori	r24, 0x20	; 32
     524:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4B0);
     526:	80 81       	ld	r24, Z
     528:	8f 7e       	andi	r24, 0xEF	; 239
     52a:	80 83       	st	Z, r24
}
     52c:	08 95       	ret

0000052e <PWM_timer4_On_H5>:
void PWM_timer4_On_H5(void)
{
	sbi(TCCR4A,COM4C1);
     52e:	e0 ea       	ldi	r30, 0xA0	; 160
     530:	f0 e0       	ldi	r31, 0x00	; 0
     532:	80 81       	ld	r24, Z
     534:	88 60       	ori	r24, 0x08	; 8
     536:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4C0);
     538:	80 81       	ld	r24, Z
     53a:	8b 7f       	andi	r24, 0xFB	; 251
     53c:	80 83       	st	Z, r24
}
     53e:	08 95       	ret

00000540 <PWM_timer1_Off_LED>:

//off commands
void PWM_timer1_Off_LED(void)
{
	cbi(TCCR1A,COM1B1);
     540:	e0 e8       	ldi	r30, 0x80	; 128
     542:	f0 e0       	ldi	r31, 0x00	; 0
     544:	80 81       	ld	r24, Z
     546:	8f 7d       	andi	r24, 0xDF	; 223
     548:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B0);
     54a:	80 81       	ld	r24, Z
     54c:	8f 7e       	andi	r24, 0xEF	; 239
     54e:	80 83       	st	Z, r24
}
     550:	08 95       	ret

00000552 <PWM_timer2_Off_H6>:
void PWM_timer2_Off_H6(void)
{
	cbi(TCCR2A,COM2B1);
     552:	e0 eb       	ldi	r30, 0xB0	; 176
     554:	f0 e0       	ldi	r31, 0x00	; 0
     556:	80 81       	ld	r24, Z
     558:	8f 7d       	andi	r24, 0xDF	; 223
     55a:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B0);
     55c:	80 81       	ld	r24, Z
     55e:	8f 7e       	andi	r24, 0xEF	; 239
     560:	80 83       	st	Z, r24
}
     562:	08 95       	ret

00000564 <PWM_timer3_Off_E3>:
void PWM_timer3_Off_E3(void)
{
	cbi(TCCR3A,COM3A1);
     564:	e0 e9       	ldi	r30, 0x90	; 144
     566:	f0 e0       	ldi	r31, 0x00	; 0
     568:	80 81       	ld	r24, Z
     56a:	8f 77       	andi	r24, 0x7F	; 127
     56c:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3A0);
     56e:	80 81       	ld	r24, Z
     570:	8f 7b       	andi	r24, 0xBF	; 191
     572:	80 83       	st	Z, r24
}
     574:	08 95       	ret

00000576 <PWM_timer3_Off_E4>:
void PWM_timer3_Off_E4(void)
{
	cbi(TCCR3A,COM3B1);
     576:	e0 e9       	ldi	r30, 0x90	; 144
     578:	f0 e0       	ldi	r31, 0x00	; 0
     57a:	80 81       	ld	r24, Z
     57c:	8f 7d       	andi	r24, 0xDF	; 223
     57e:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3B0);
     580:	80 81       	ld	r24, Z
     582:	8f 7e       	andi	r24, 0xEF	; 239
     584:	80 83       	st	Z, r24
}
     586:	08 95       	ret

00000588 <PWM_timer3_Off_E5>:
void PWM_timer3_Off_E5(void)
{
	cbi(TCCR3A,COM3C1);
     588:	e0 e9       	ldi	r30, 0x90	; 144
     58a:	f0 e0       	ldi	r31, 0x00	; 0
     58c:	80 81       	ld	r24, Z
     58e:	87 7f       	andi	r24, 0xF7	; 247
     590:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C0);
     592:	80 81       	ld	r24, Z
     594:	8b 7f       	andi	r24, 0xFB	; 251
     596:	80 83       	st	Z, r24
}
     598:	08 95       	ret

0000059a <PWM_timer4_Off_H3>:
void PWM_timer4_Off_H3(void)
{
	cbi(TCCR4A,COM4A1);
     59a:	e0 ea       	ldi	r30, 0xA0	; 160
     59c:	f0 e0       	ldi	r31, 0x00	; 0
     59e:	80 81       	ld	r24, Z
     5a0:	8f 77       	andi	r24, 0x7F	; 127
     5a2:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4A0);
     5a4:	80 81       	ld	r24, Z
     5a6:	8f 7b       	andi	r24, 0xBF	; 191
     5a8:	80 83       	st	Z, r24
}
     5aa:	08 95       	ret

000005ac <PWM_timer4_Off_H4>:
void PWM_timer4_Off_H4(void)
{
	cbi(TCCR4A,COM4B1);
     5ac:	e0 ea       	ldi	r30, 0xA0	; 160
     5ae:	f0 e0       	ldi	r31, 0x00	; 0
     5b0:	80 81       	ld	r24, Z
     5b2:	8f 7d       	andi	r24, 0xDF	; 223
     5b4:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4B0);
     5b6:	80 81       	ld	r24, Z
     5b8:	8f 7e       	andi	r24, 0xEF	; 239
     5ba:	80 83       	st	Z, r24
}
     5bc:	08 95       	ret

000005be <PWM_timer4_Off_H5>:
void PWM_timer4_Off_H5(void)
{
	cbi(TCCR4A,COM4C1);
     5be:	e0 ea       	ldi	r30, 0xA0	; 160
     5c0:	f0 e0       	ldi	r31, 0x00	; 0
     5c2:	80 81       	ld	r24, Z
     5c4:	87 7f       	andi	r24, 0xF7	; 247
     5c6:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4C0);
     5c8:	80 81       	ld	r24, Z
     5ca:	8b 7f       	andi	r24, 0xFB	; 251
     5cc:	80 83       	st	Z, r24
}
     5ce:	08 95       	ret

000005d0 <PWM_timer1_Off_All>:


void PWM_timer1_Off_All(void)
{
	cbi(TCCR1A,PWM11);
     5d0:	e0 e8       	ldi	r30, 0x80	; 128
     5d2:	f0 e0       	ldi	r31, 0x00	; 0
     5d4:	80 81       	ld	r24, Z
     5d6:	8d 7f       	andi	r24, 0xFD	; 253
     5d8:	80 83       	st	Z, r24
	cbi(TCCR1A,PWM10);
     5da:	80 81       	ld	r24, Z
     5dc:	8e 7f       	andi	r24, 0xFE	; 254
     5de:	80 83       	st	Z, r24
}

//off commands
void PWM_timer1_Off_LED(void)
{
	cbi(TCCR1A,COM1B1);
     5e0:	80 81       	ld	r24, Z
     5e2:	8f 7d       	andi	r24, 0xDF	; 223
     5e4:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B0);
     5e6:	80 81       	ld	r24, Z
     5e8:	8f 7e       	andi	r24, 0xEF	; 239
     5ea:	80 83       	st	Z, r24
	cbi(TCCR1A,PWM11);
	cbi(TCCR1A,PWM10);
	//timer2PWMAOff();
	PWM_timer1_Off_LED();
	//timer2PWMCOff();
}
     5ec:	08 95       	ret

000005ee <PWM_timer2_Off_All>:
void PWM_timer2_Off_All(void)
{
	cbi(TCCR2A,PWM11);
     5ee:	e0 eb       	ldi	r30, 0xB0	; 176
     5f0:	f0 e0       	ldi	r31, 0x00	; 0
     5f2:	80 81       	ld	r24, Z
     5f4:	8d 7f       	andi	r24, 0xFD	; 253
     5f6:	80 83       	st	Z, r24
	cbi(TCCR2A,PWM10);
     5f8:	80 81       	ld	r24, Z
     5fa:	8e 7f       	andi	r24, 0xFE	; 254
     5fc:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B1);
	cbi(TCCR1A,COM1B0);
}
void PWM_timer2_Off_H6(void)
{
	cbi(TCCR2A,COM2B1);
     5fe:	80 81       	ld	r24, Z
     600:	8f 7d       	andi	r24, 0xDF	; 223
     602:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B0);
     604:	80 81       	ld	r24, Z
     606:	8f 7e       	andi	r24, 0xEF	; 239
     608:	80 83       	st	Z, r24
	cbi(TCCR2A,PWM11);
	cbi(TCCR2A,PWM10);
	//timer2PWMAOff();
	PWM_timer2_Off_H6();
	//timer2PWMCOff();
}
     60a:	08 95       	ret

0000060c <PWM_timer3_Off_All>:
void PWM_timer3_Off_All(void)
{
	cbi(TCCR3A,PWM11);
     60c:	e0 e9       	ldi	r30, 0x90	; 144
     60e:	f0 e0       	ldi	r31, 0x00	; 0
     610:	80 81       	ld	r24, Z
     612:	8d 7f       	andi	r24, 0xFD	; 253
     614:	80 83       	st	Z, r24
	cbi(TCCR3A,PWM10);
     616:	80 81       	ld	r24, Z
     618:	8e 7f       	andi	r24, 0xFE	; 254
     61a:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B1);
	cbi(TCCR2A,COM2B0);
}
void PWM_timer3_Off_E3(void)
{
	cbi(TCCR3A,COM3A1);
     61c:	80 81       	ld	r24, Z
     61e:	8f 77       	andi	r24, 0x7F	; 127
     620:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3A0);
     622:	80 81       	ld	r24, Z
     624:	8f 7b       	andi	r24, 0xBF	; 191
     626:	80 83       	st	Z, r24
}
void PWM_timer3_Off_E4(void)
{
	cbi(TCCR3A,COM3B1);
     628:	80 81       	ld	r24, Z
     62a:	8f 7d       	andi	r24, 0xDF	; 223
     62c:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3B0);
     62e:	80 81       	ld	r24, Z
     630:	8f 7e       	andi	r24, 0xEF	; 239
     632:	80 83       	st	Z, r24
}
void PWM_timer3_Off_E5(void)
{
	cbi(TCCR3A,COM3C1);
     634:	80 81       	ld	r24, Z
     636:	87 7f       	andi	r24, 0xF7	; 247
     638:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C0);
     63a:	80 81       	ld	r24, Z
     63c:	8b 7f       	andi	r24, 0xFB	; 251
     63e:	80 83       	st	Z, r24
	//timer2PWMAOff();
	PWM_timer3_Off_E3();
	PWM_timer3_Off_E4();
	PWM_timer3_Off_E5();
	//timer2PWMCOff();
}
     640:	08 95       	ret

00000642 <PWM_timer4_Off_All>:
void PWM_timer4_Off_All(void)
{
	cbi(TCCR4A,PWM11);
     642:	e0 ea       	ldi	r30, 0xA0	; 160
     644:	f0 e0       	ldi	r31, 0x00	; 0
     646:	80 81       	ld	r24, Z
     648:	8d 7f       	andi	r24, 0xFD	; 253
     64a:	80 83       	st	Z, r24
	cbi(TCCR4A,PWM10);
     64c:	80 81       	ld	r24, Z
     64e:	8e 7f       	andi	r24, 0xFE	; 254
     650:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C1);
	cbi(TCCR3A,COM3C0);
}
void PWM_timer4_Off_H3(void)
{
	cbi(TCCR4A,COM4A1);
     652:	80 81       	ld	r24, Z
     654:	8f 77       	andi	r24, 0x7F	; 127
     656:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4A0);
     658:	80 81       	ld	r24, Z
     65a:	8f 7b       	andi	r24, 0xBF	; 191
     65c:	80 83       	st	Z, r24
}
void PWM_timer4_Off_H4(void)
{
	cbi(TCCR4A,COM4B1);
     65e:	80 81       	ld	r24, Z
     660:	8f 7d       	andi	r24, 0xDF	; 223
     662:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4B0);
     664:	80 81       	ld	r24, Z
     666:	8f 7e       	andi	r24, 0xEF	; 239
     668:	80 83       	st	Z, r24
}
void PWM_timer4_Off_H5(void)
{
	cbi(TCCR4A,COM4C1);
     66a:	80 81       	ld	r24, Z
     66c:	87 7f       	andi	r24, 0xF7	; 247
     66e:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4C0);
     670:	80 81       	ld	r24, Z
     672:	8b 7f       	andi	r24, 0xFB	; 251
     674:	80 83       	st	Z, r24
	//timer2PWMAOff();
	PWM_timer4_Off_H3();
	PWM_timer4_Off_H4();
	PWM_timer4_Off_H5();
	//timer2PWMCOff();
}
     676:	08 95       	ret

00000678 <PWM_timer1_Set_LED>:
// this PWM output is generated on OC2B pin
// NOTE:	pwmDuty should be in the range 0-255 for 8bit PWM
//			pwmDuty should be in the range 0-511 for 9bit PWM
//			pwmDuty should be in the range 0-1023 for 10bit PWM
void PWM_timer1_Set_LED(u16 pwmDuty)
	{OCR1B = pwmDuty;}
     678:	90 93 8b 00 	sts	0x008B, r25
     67c:	80 93 8a 00 	sts	0x008A, r24
     680:	08 95       	ret

00000682 <PWM_timer2_Set_H6>:
void PWM_timer2_Set_H6(u16 pwmDuty)
	{OCR2B = pwmDuty;}
     682:	80 93 b4 00 	sts	0x00B4, r24
     686:	08 95       	ret

00000688 <PWM_timer3_Set_E3>:
void PWM_timer3_Set_E3(u16 pwmDuty)
	{OCR3A = pwmDuty;}
     688:	90 93 99 00 	sts	0x0099, r25
     68c:	80 93 98 00 	sts	0x0098, r24
     690:	08 95       	ret

00000692 <PWM_timer3_Set_E4>:
void PWM_timer3_Set_E4(u16 pwmDuty)
	{OCR3B = pwmDuty;}
     692:	90 93 9b 00 	sts	0x009B, r25
     696:	80 93 9a 00 	sts	0x009A, r24
     69a:	08 95       	ret

0000069c <PWM_timer3_Set_E5>:
void PWM_timer3_Set_E5(u16 pwmDuty)
	{OCR3C = pwmDuty;}
     69c:	90 93 9d 00 	sts	0x009D, r25
     6a0:	80 93 9c 00 	sts	0x009C, r24
     6a4:	08 95       	ret

000006a6 <PWM_timer4_Set_H3>:
void PWM_timer4_Set_H3(u16 pwmDuty)
	{OCR4A = pwmDuty;}
     6a6:	90 93 a9 00 	sts	0x00A9, r25
     6aa:	80 93 a8 00 	sts	0x00A8, r24
     6ae:	08 95       	ret

000006b0 <PWM_timer4_Set_H4>:
void PWM_timer4_Set_H4(u16 pwmDuty)
	{OCR4B = pwmDuty;}
     6b0:	90 93 ab 00 	sts	0x00AB, r25
     6b4:	80 93 aa 00 	sts	0x00AA, r24
     6b8:	08 95       	ret

000006ba <PWM_timer4_Set_H5>:
void PWM_timer4_Set_H5(u16 pwmDuty)
	{OCR4C = pwmDuty;}
     6ba:	90 93 ad 00 	sts	0x00AD, r25
     6be:	80 93 ac 00 	sts	0x00AC, r24
     6c2:	08 95       	ret

000006c4 <configure_ports>:
	//cbi(DDRG, PG5);  //set G5 as input pin

	//ANALOG PORTS
	//useful for sensors, SharpIR, photoresistors, etc.
	//analog ports can be configured as digital ports if desired
	DDRF = 0b00000000;  //configure all F ports for input				0x00
     6c4:	10 ba       	out	0x10, r1	; 16
	PORTF = 0b00000000; //make sure pull-up resistors are turned off	0x00
     6c6:	11 ba       	out	0x11, r1	; 17
	DDRK = 0b00000000;  //configure all K ports for input				0x00
     6c8:	10 92 07 01 	sts	0x0107, r1
	PORTK = 0b00000000; //make sure pull-up resistors are turned off	0x00
     6cc:	10 92 08 01 	sts	0x0108, r1

	//DIGITAL PORTS
	//useful for servos, PWM, LED's, UART, interrupts, timers
	DDRA = 0b11111111;  //configure ports for output
     6d0:	9f ef       	ldi	r25, 0xFF	; 255
     6d2:	91 b9       	out	0x01, r25	; 1
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	//PORTB reserved for programmer (use programmer pins if you know what you are doing)
	DDRB = _BV (PB6);	//PB6 is LED, hold low to turn it on
     6d4:	80 e4       	ldi	r24, 0x40	; 64
     6d6:	84 b9       	out	0x04, r24	; 4
	DDRC = 0b11111111;  //configure ports for output
     6d8:	97 b9       	out	0x07, r25	; 7
	//       ||||\______3: 
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 	
	sbi(PORTD, PD0); // SCL pull-up
     6da:	58 9a       	sbi	0x0b, 0	; 11
	sbi(PORTD, PD1); // SDA pull-up
     6dc:	59 9a       	sbi	0x0b, 1	; 11
	DDRD = 0b11110011;  //configure ports for output
     6de:	83 ef       	ldi	r24, 0xF3	; 243
     6e0:	8a b9       	out	0x0a, r24	; 10
	//       ||||\______3: serial TXD1, output -> 1
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: timer0
	DDRE = 0b11111110;  //configure ports for output
     6e2:	8e ef       	ldi	r24, 0xFE	; 254
     6e4:	8d b9       	out	0x0d, r24	; 13
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	//cbi(PORTG, PG5);  // disable pull-up resistor for Axon v1e and earlier
	sbi(PORTG, PG5);  // enable pull-up resistor for v1f and later
     6e6:	a5 9a       	sbi	0x14, 5	; 20
	cbi(DDRG, PG5);	//PG5 is for the button, make a digital input
     6e8:	9d 98       	cbi	0x13, 5	; 19
	//note that button actions are inverted between both versions!!!
	DDRH = 0b11111110;  //configure ports for output
     6ea:	80 93 01 01 	sts	0x0101, r24
	//       ||||\______3: 
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	DDRJ = 0b11111110;  //configure ports for output
     6ee:	80 93 04 01 	sts	0x0104, r24
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	//PORTL has no headers
	};
     6f2:	08 95       	ret

000006f4 <delay_cycles>:
void delay_cycles(unsigned long int cycles)
	{
	cycles=cycles;//doubled frequency but too lazy to change times
	while(cycles > 0)
		cycles--;
	}
     6f4:	08 95       	ret

000006f6 <LED_off>:


//***************STATUS LED**************
//tank test
void LED_off(void)
	{PORT_ON(PORTB,6);}
     6f6:	2e 9a       	sbi	0x05, 6	; 5
     6f8:	08 95       	ret

000006fa <LED_on>:
void LED_on(void)
	{PORT_OFF(PORTB,6);}
     6fa:	2e 98       	cbi	0x05, 6	; 5
     6fc:	08 95       	ret

000006fe <button_pressed>:


//*****************BUTTON****************
int button_pressed(void)
	{
	return (bit_is_clear(PING, 5));
     6fe:	22 b3       	in	r18, 0x12	; 18
     700:	30 e0       	ldi	r19, 0x00	; 0
     702:	85 e0       	ldi	r24, 0x05	; 5
     704:	36 95       	lsr	r19
     706:	27 95       	ror	r18
     708:	8a 95       	dec	r24
     70a:	e1 f7       	brne	.-8      	; 0x704 <button_pressed+0x6>
     70c:	20 95       	com	r18
     70e:	30 95       	com	r19
     710:	21 70       	andi	r18, 0x01	; 1
     712:	30 70       	andi	r19, 0x00	; 0
	//return ((PING) & (1<<PG5));//old version, went high when button pushed
	}
     714:	c9 01       	movw	r24, r18
     716:	08 95       	ret

00000718 <cos_SoR>:
signed int angtable[73]={100,100,98,97,94,91,87,82,77,71,64,57,50,42,34,26,17,9,0,-9,-17,-26,-34,-42,-50,-57,-64,-71,-77,-82,-87,-91,-94,-97,-98,-100,
						 -100,-100,-98,-97,-94,-91,-87,-82,-77,-71,-64,-57,-50,-42,-34,-26,-17,-9,0,9,17,26,34,42,50,57,64,71,77,82,87,91,94,97,98,100,100};

signed int cos_SoR(long signed int degrees)//returns cos*100
	{
	if (degrees >= 0)//positive angles
     718:	97 fd       	sbrc	r25, 7
     71a:	10 c0       	rjmp	.+32     	; 0x73c <cos_SoR+0x24>
		return angtable[degrees/5];
     71c:	25 e0       	ldi	r18, 0x05	; 5
     71e:	30 e0       	ldi	r19, 0x00	; 0
     720:	40 e0       	ldi	r20, 0x00	; 0
     722:	50 e0       	ldi	r21, 0x00	; 0
     724:	0e 94 35 2e 	call	0x5c6a	; 0x5c6a <__divmodsi4>
     728:	da 01       	movw	r26, r20
     72a:	c9 01       	movw	r24, r18
     72c:	88 0f       	add	r24, r24
     72e:	99 1f       	adc	r25, r25
     730:	8b 5d       	subi	r24, 0xDB	; 219
     732:	9d 4f       	sbci	r25, 0xFD	; 253
     734:	fc 01       	movw	r30, r24
     736:	20 81       	ld	r18, Z
     738:	31 81       	ldd	r19, Z+1	; 0x01
     73a:	17 c0       	rjmp	.+46     	; 0x76a <cos_SoR+0x52>
	else
		return -angtable[72-(-degrees)/5];
     73c:	25 e0       	ldi	r18, 0x05	; 5
     73e:	30 e0       	ldi	r19, 0x00	; 0
     740:	40 e0       	ldi	r20, 0x00	; 0
     742:	50 e0       	ldi	r21, 0x00	; 0
     744:	0e 94 35 2e 	call	0x5c6a	; 0x5c6a <__divmodsi4>
     748:	da 01       	movw	r26, r20
     74a:	c9 01       	movw	r24, r18
     74c:	88 5b       	subi	r24, 0xB8	; 184
     74e:	9f 4f       	sbci	r25, 0xFF	; 255
     750:	af 4f       	sbci	r26, 0xFF	; 255
     752:	bf 4f       	sbci	r27, 0xFF	; 255
     754:	88 0f       	add	r24, r24
     756:	99 1f       	adc	r25, r25
     758:	8b 5d       	subi	r24, 0xDB	; 219
     75a:	9d 4f       	sbci	r25, 0xFD	; 253
     75c:	fc 01       	movw	r30, r24
     75e:	80 81       	ld	r24, Z
     760:	91 81       	ldd	r25, Z+1	; 0x01
     762:	22 27       	eor	r18, r18
     764:	33 27       	eor	r19, r19
     766:	28 1b       	sub	r18, r24
     768:	39 0b       	sbc	r19, r25
	}
     76a:	c9 01       	movw	r24, r18
     76c:	08 95       	ret

0000076e <sin_SoR>:

signed int sin_SoR(long signed int degrees)//returns sin*100
	{
	degrees=degrees - 90;//phase shift 90 degrees
     76e:	6a 55       	subi	r22, 0x5A	; 90
     770:	70 40       	sbci	r23, 0x00	; 0
     772:	80 40       	sbci	r24, 0x00	; 0
     774:	90 40       	sbci	r25, 0x00	; 0

	if (degrees >= 0)//positive angles
     776:	97 fd       	sbrc	r25, 7
     778:	10 c0       	rjmp	.+32     	; 0x79a <sin_SoR+0x2c>
		return angtable[degrees/5];
     77a:	25 e0       	ldi	r18, 0x05	; 5
     77c:	30 e0       	ldi	r19, 0x00	; 0
     77e:	40 e0       	ldi	r20, 0x00	; 0
     780:	50 e0       	ldi	r21, 0x00	; 0
     782:	0e 94 35 2e 	call	0x5c6a	; 0x5c6a <__divmodsi4>
     786:	da 01       	movw	r26, r20
     788:	c9 01       	movw	r24, r18
     78a:	88 0f       	add	r24, r24
     78c:	99 1f       	adc	r25, r25
     78e:	8b 5d       	subi	r24, 0xDB	; 219
     790:	9d 4f       	sbci	r25, 0xFD	; 253
     792:	fc 01       	movw	r30, r24
     794:	20 81       	ld	r18, Z
     796:	31 81       	ldd	r19, Z+1	; 0x01
     798:	17 c0       	rjmp	.+46     	; 0x7c8 <sin_SoR+0x5a>
	else
		return -angtable[72-(-degrees)/5];
     79a:	25 e0       	ldi	r18, 0x05	; 5
     79c:	30 e0       	ldi	r19, 0x00	; 0
     79e:	40 e0       	ldi	r20, 0x00	; 0
     7a0:	50 e0       	ldi	r21, 0x00	; 0
     7a2:	0e 94 35 2e 	call	0x5c6a	; 0x5c6a <__divmodsi4>
     7a6:	da 01       	movw	r26, r20
     7a8:	c9 01       	movw	r24, r18
     7aa:	88 5b       	subi	r24, 0xB8	; 184
     7ac:	9f 4f       	sbci	r25, 0xFF	; 255
     7ae:	af 4f       	sbci	r26, 0xFF	; 255
     7b0:	bf 4f       	sbci	r27, 0xFF	; 255
     7b2:	88 0f       	add	r24, r24
     7b4:	99 1f       	adc	r25, r25
     7b6:	8b 5d       	subi	r24, 0xDB	; 219
     7b8:	9d 4f       	sbci	r25, 0xFD	; 253
     7ba:	fc 01       	movw	r30, r24
     7bc:	80 81       	ld	r24, Z
     7be:	91 81       	ldd	r25, Z+1	; 0x01
     7c0:	22 27       	eor	r18, r18
     7c2:	33 27       	eor	r19, r19
     7c4:	28 1b       	sub	r18, r24
     7c6:	39 0b       	sbc	r19, r25
	}
     7c8:	c9 01       	movw	r24, r18
     7ca:	08 95       	ret

000007cc <tan_SoR>:

signed int tan_SoR(long signed int degrees)//returns tan * 10
	{
     7cc:	cf 92       	push	r12
     7ce:	df 92       	push	r13
     7d0:	ef 92       	push	r14
     7d2:	ff 92       	push	r15
     7d4:	0f 93       	push	r16
     7d6:	1f 93       	push	r17
     7d8:	6b 01       	movw	r12, r22
     7da:	7c 01       	movw	r14, r24
	//tan(x) = sin(x)/cos(x)
	if (degrees == 90 || degrees == -90 || degrees == 270 || degrees == -270)//blows up
     7dc:	8a e5       	ldi	r24, 0x5A	; 90
     7de:	c8 16       	cp	r12, r24
     7e0:	d1 04       	cpc	r13, r1
     7e2:	e1 04       	cpc	r14, r1
     7e4:	f1 04       	cpc	r15, r1
     7e6:	a1 f1       	breq	.+104    	; 0x850 <tan_SoR+0x84>
     7e8:	86 ea       	ldi	r24, 0xA6	; 166
     7ea:	c8 16       	cp	r12, r24
     7ec:	8f ef       	ldi	r24, 0xFF	; 255
     7ee:	d8 06       	cpc	r13, r24
     7f0:	8f ef       	ldi	r24, 0xFF	; 255
     7f2:	e8 06       	cpc	r14, r24
     7f4:	8f ef       	ldi	r24, 0xFF	; 255
     7f6:	f8 06       	cpc	r15, r24
     7f8:	59 f1       	breq	.+86     	; 0x850 <tan_SoR+0x84>
     7fa:	8e e0       	ldi	r24, 0x0E	; 14
     7fc:	c8 16       	cp	r12, r24
     7fe:	81 e0       	ldi	r24, 0x01	; 1
     800:	d8 06       	cpc	r13, r24
     802:	80 e0       	ldi	r24, 0x00	; 0
     804:	e8 06       	cpc	r14, r24
     806:	80 e0       	ldi	r24, 0x00	; 0
     808:	f8 06       	cpc	r15, r24
     80a:	11 f1       	breq	.+68     	; 0x850 <tan_SoR+0x84>
     80c:	82 ef       	ldi	r24, 0xF2	; 242
     80e:	c8 16       	cp	r12, r24
     810:	8e ef       	ldi	r24, 0xFE	; 254
     812:	d8 06       	cpc	r13, r24
     814:	8f ef       	ldi	r24, 0xFF	; 255
     816:	e8 06       	cpc	r14, r24
     818:	8f ef       	ldi	r24, 0xFF	; 255
     81a:	f8 06       	cpc	r15, r24
     81c:	c9 f0       	breq	.+50     	; 0x850 <tan_SoR+0x84>
		return 0;//what else should I return?!?!?
	return sin_SoR(degrees)/cos_SoR(degrees)*10;
     81e:	c7 01       	movw	r24, r14
     820:	b6 01       	movw	r22, r12
     822:	0e 94 b7 03 	call	0x76e	; 0x76e <sin_SoR>
     826:	8c 01       	movw	r16, r24
     828:	c7 01       	movw	r24, r14
     82a:	b6 01       	movw	r22, r12
     82c:	0e 94 8c 03 	call	0x718	; 0x718 <cos_SoR>
     830:	bc 01       	movw	r22, r24
     832:	c8 01       	movw	r24, r16
     834:	0e 94 00 2e 	call	0x5c00	; 0x5c00 <__divmodhi4>
     838:	cb 01       	movw	r24, r22
     83a:	9b 01       	movw	r18, r22
     83c:	73 e0       	ldi	r23, 0x03	; 3
     83e:	22 0f       	add	r18, r18
     840:	33 1f       	adc	r19, r19
     842:	7a 95       	dec	r23
     844:	e1 f7       	brne	.-8      	; 0x83e <tan_SoR+0x72>
     846:	88 0f       	add	r24, r24
     848:	99 1f       	adc	r25, r25
     84a:	28 0f       	add	r18, r24
     84c:	39 1f       	adc	r19, r25
     84e:	02 c0       	rjmp	.+4      	; 0x854 <tan_SoR+0x88>
     850:	20 e0       	ldi	r18, 0x00	; 0
     852:	30 e0       	ldi	r19, 0x00	; 0
	}
     854:	c9 01       	movw	r24, r18
     856:	1f 91       	pop	r17
     858:	0f 91       	pop	r16
     85a:	ff 90       	pop	r15
     85c:	ef 90       	pop	r14
     85e:	df 90       	pop	r13
     860:	cf 90       	pop	r12
     862:	08 95       	ret

00000864 <prvPWMSetup>:
//-----------------------------**&&**


void prvPWMSetup(){

	PWM_Init_timer3_E4(10); // Left wheel
     864:	8a e0       	ldi	r24, 0x0A	; 10
     866:	0e 94 55 01 	call	0x2aa	; 0x2aa <PWM_Init_timer3_E4>
	PWM_Init_timer3_E3(10); // Right wheel
     86a:	8a e0       	ldi	r24, 0x0A	; 10
     86c:	0e 94 35 01 	call	0x26a	; 0x26a <PWM_Init_timer3_E3>
	PWM_Init_timer4_H3(10);	// Left sprayer
     870:	8a e0       	ldi	r24, 0x0A	; 10
     872:	0e 94 95 01 	call	0x32a	; 0x32a <PWM_Init_timer4_H3>
	PWM_Init_timer4_H4(10);	// Right sprayer
     876:	8a e0       	ldi	r24, 0x0A	; 10
     878:	0e 94 b5 01 	call	0x36a	; 0x36a <PWM_Init_timer4_H4>

}
     87c:	08 95       	ret

0000087e <char2hex>:

char char2hex(char c){
     87e:	98 2f       	mov	r25, r24
	
	if((c > 47) && (c <58)){
     880:	80 53       	subi	r24, 0x30	; 48
     882:	8a 30       	cpi	r24, 0x0A	; 10
     884:	38 f0       	brcs	.+14     	; 0x894 <char2hex+0x16>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     886:	81 51       	subi	r24, 0x11	; 17
     888:	86 30       	cpi	r24, 0x06	; 6
     88a:	10 f0       	brcs	.+4      	; 0x890 <char2hex+0x12>
     88c:	89 2f       	mov	r24, r25
     88e:	08 95       	ret
		c -= 55;
     890:	89 2f       	mov	r24, r25
     892:	87 53       	subi	r24, 0x37	; 55
	}
	return c;
}
     894:	08 95       	ret

00000896 <retConv_s16>:

s16 retConv_s16(char* ch_head){
     896:	fc 01       	movw	r30, r24

	s16 int_val = 0x0000;
	char iv1 = *(ch_head);
     898:	90 81       	ld	r25, Z
	char iv2 = *(ch_head + 1);
     89a:	21 81       	ldd	r18, Z+1	; 0x01
	char iv3 = *(ch_head + 2);
     89c:	42 81       	ldd	r20, Z+2	; 0x02
	char iv4 = *(ch_head + 3);
     89e:	53 81       	ldd	r21, Z+3	; 0x03

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     8a0:	89 2f       	mov	r24, r25
     8a2:	80 53       	subi	r24, 0x30	; 48
     8a4:	8a 30       	cpi	r24, 0x0A	; 10
     8a6:	10 f4       	brcc	.+4      	; 0x8ac <retConv_s16+0x16>
     8a8:	98 2f       	mov	r25, r24
     8aa:	05 c0       	rjmp	.+10     	; 0x8b6 <retConv_s16+0x20>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     8ac:	89 2f       	mov	r24, r25
     8ae:	81 54       	subi	r24, 0x41	; 65
     8b0:	86 30       	cpi	r24, 0x06	; 6
     8b2:	08 f4       	brcc	.+2      	; 0x8b6 <retConv_s16+0x20>
		c -= 55;
     8b4:	97 53       	subi	r25, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     8b6:	82 2f       	mov	r24, r18
     8b8:	80 53       	subi	r24, 0x30	; 48
     8ba:	8a 30       	cpi	r24, 0x0A	; 10
     8bc:	10 f4       	brcc	.+4      	; 0x8c2 <retConv_s16+0x2c>
     8be:	28 2f       	mov	r18, r24
     8c0:	05 c0       	rjmp	.+10     	; 0x8cc <retConv_s16+0x36>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     8c2:	82 2f       	mov	r24, r18
     8c4:	81 54       	subi	r24, 0x41	; 65
     8c6:	86 30       	cpi	r24, 0x06	; 6
     8c8:	08 f4       	brcc	.+2      	; 0x8cc <retConv_s16+0x36>
		c -= 55;
     8ca:	27 53       	subi	r18, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     8cc:	84 2f       	mov	r24, r20
     8ce:	80 53       	subi	r24, 0x30	; 48
     8d0:	8a 30       	cpi	r24, 0x0A	; 10
     8d2:	10 f4       	brcc	.+4      	; 0x8d8 <retConv_s16+0x42>
     8d4:	48 2f       	mov	r20, r24
     8d6:	05 c0       	rjmp	.+10     	; 0x8e2 <retConv_s16+0x4c>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     8d8:	84 2f       	mov	r24, r20
     8da:	81 54       	subi	r24, 0x41	; 65
     8dc:	86 30       	cpi	r24, 0x06	; 6
     8de:	08 f4       	brcc	.+2      	; 0x8e2 <retConv_s16+0x4c>
		c -= 55;
     8e0:	47 53       	subi	r20, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     8e2:	85 2f       	mov	r24, r21
     8e4:	80 53       	subi	r24, 0x30	; 48
     8e6:	8a 30       	cpi	r24, 0x0A	; 10
     8e8:	10 f4       	brcc	.+4      	; 0x8ee <retConv_s16+0x58>
     8ea:	58 2f       	mov	r21, r24
     8ec:	05 c0       	rjmp	.+10     	; 0x8f8 <retConv_s16+0x62>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     8ee:	85 2f       	mov	r24, r21
     8f0:	81 54       	subi	r24, 0x41	; 65
     8f2:	86 30       	cpi	r24, 0x06	; 6
     8f4:	08 f4       	brcc	.+2      	; 0x8f8 <retConv_s16+0x62>
		c -= 55;
     8f6:	57 53       	subi	r21, 0x37	; 55
	iv2 = char2hex(iv2);
	iv3 = char2hex(iv3);
	iv4 = char2hex(iv4);

	int_val = (int_val | iv1);
	int_val = ((int_val<<4) | iv2);
     8f8:	30 e0       	ldi	r19, 0x00	; 0
     8fa:	89 2f       	mov	r24, r25
     8fc:	90 e0       	ldi	r25, 0x00	; 0
     8fe:	a4 e0       	ldi	r26, 0x04	; 4
     900:	88 0f       	add	r24, r24
     902:	99 1f       	adc	r25, r25
     904:	aa 95       	dec	r26
     906:	e1 f7       	brne	.-8      	; 0x900 <retConv_s16+0x6a>
     908:	28 2b       	or	r18, r24
     90a:	39 2b       	or	r19, r25
	int_val = ((int_val<<4) | iv3);
     90c:	f4 e0       	ldi	r31, 0x04	; 4
     90e:	22 0f       	add	r18, r18
     910:	33 1f       	adc	r19, r19
     912:	fa 95       	dec	r31
     914:	e1 f7       	brne	.-8      	; 0x90e <retConv_s16+0x78>
     916:	84 2f       	mov	r24, r20
     918:	90 e0       	ldi	r25, 0x00	; 0
     91a:	82 2b       	or	r24, r18
     91c:	93 2b       	or	r25, r19
	int_val = ((int_val<<4) | iv4);
     91e:	e4 e0       	ldi	r30, 0x04	; 4
     920:	88 0f       	add	r24, r24
     922:	99 1f       	adc	r25, r25
     924:	ea 95       	dec	r30
     926:	e1 f7       	brne	.-8      	; 0x920 <retConv_s16+0x8a>
     928:	25 2f       	mov	r18, r21
     92a:	30 e0       	ldi	r19, 0x00	; 0
     92c:	28 2b       	or	r18, r24
     92e:	39 2b       	or	r19, r25
	return int_val;
}
     930:	c9 01       	movw	r24, r18
     932:	08 95       	ret

00000934 <retConv_s32>:

s32 retConv_s32(char* ch_head){
     934:	ff 92       	push	r15
     936:	0f 93       	push	r16
     938:	1f 93       	push	r17
     93a:	fc 01       	movw	r30, r24

	s32 int_val = 0x00000000;
	char iv1 = *(ch_head);
     93c:	90 81       	ld	r25, Z
	char iv2 = *(ch_head + 1);
     93e:	21 81       	ldd	r18, Z+1	; 0x01
	char iv3 = *(ch_head + 2);
     940:	62 81       	ldd	r22, Z+2	; 0x02
	char iv4 = *(ch_head + 3);
     942:	73 81       	ldd	r23, Z+3	; 0x03
	char iv5 = *(ch_head + 4);
     944:	14 81       	ldd	r17, Z+4	; 0x04
	char iv6 = *(ch_head + 5);
     946:	05 81       	ldd	r16, Z+5	; 0x05
	char iv7 = *(ch_head + 6);
     948:	f6 80       	ldd	r15, Z+6	; 0x06
	char iv8 = *(ch_head + 7);
     94a:	e7 81       	ldd	r30, Z+7	; 0x07

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     94c:	89 2f       	mov	r24, r25
     94e:	80 53       	subi	r24, 0x30	; 48
     950:	8a 30       	cpi	r24, 0x0A	; 10
     952:	10 f4       	brcc	.+4      	; 0x958 <retConv_s32+0x24>
     954:	98 2f       	mov	r25, r24
     956:	05 c0       	rjmp	.+10     	; 0x962 <retConv_s32+0x2e>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     958:	89 2f       	mov	r24, r25
     95a:	81 54       	subi	r24, 0x41	; 65
     95c:	86 30       	cpi	r24, 0x06	; 6
     95e:	08 f4       	brcc	.+2      	; 0x962 <retConv_s32+0x2e>
		c -= 55;
     960:	97 53       	subi	r25, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     962:	82 2f       	mov	r24, r18
     964:	80 53       	subi	r24, 0x30	; 48
     966:	8a 30       	cpi	r24, 0x0A	; 10
     968:	10 f4       	brcc	.+4      	; 0x96e <retConv_s32+0x3a>
     96a:	28 2f       	mov	r18, r24
     96c:	05 c0       	rjmp	.+10     	; 0x978 <retConv_s32+0x44>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     96e:	82 2f       	mov	r24, r18
     970:	81 54       	subi	r24, 0x41	; 65
     972:	86 30       	cpi	r24, 0x06	; 6
     974:	08 f4       	brcc	.+2      	; 0x978 <retConv_s32+0x44>
		c -= 55;
     976:	27 53       	subi	r18, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     978:	86 2f       	mov	r24, r22
     97a:	80 53       	subi	r24, 0x30	; 48
     97c:	8a 30       	cpi	r24, 0x0A	; 10
     97e:	10 f4       	brcc	.+4      	; 0x984 <retConv_s32+0x50>
     980:	68 2f       	mov	r22, r24
     982:	05 c0       	rjmp	.+10     	; 0x98e <retConv_s32+0x5a>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     984:	86 2f       	mov	r24, r22
     986:	81 54       	subi	r24, 0x41	; 65
     988:	86 30       	cpi	r24, 0x06	; 6
     98a:	08 f4       	brcc	.+2      	; 0x98e <retConv_s32+0x5a>
		c -= 55;
     98c:	67 53       	subi	r22, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     98e:	87 2f       	mov	r24, r23
     990:	80 53       	subi	r24, 0x30	; 48
     992:	8a 30       	cpi	r24, 0x0A	; 10
     994:	10 f4       	brcc	.+4      	; 0x99a <retConv_s32+0x66>
     996:	78 2f       	mov	r23, r24
     998:	05 c0       	rjmp	.+10     	; 0x9a4 <retConv_s32+0x70>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     99a:	87 2f       	mov	r24, r23
     99c:	81 54       	subi	r24, 0x41	; 65
     99e:	86 30       	cpi	r24, 0x06	; 6
     9a0:	08 f4       	brcc	.+2      	; 0x9a4 <retConv_s32+0x70>
		c -= 55;
     9a2:	77 53       	subi	r23, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     9a4:	81 2f       	mov	r24, r17
     9a6:	80 53       	subi	r24, 0x30	; 48
     9a8:	8a 30       	cpi	r24, 0x0A	; 10
     9aa:	10 f4       	brcc	.+4      	; 0x9b0 <retConv_s32+0x7c>
     9ac:	18 2f       	mov	r17, r24
     9ae:	05 c0       	rjmp	.+10     	; 0x9ba <retConv_s32+0x86>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     9b0:	81 2f       	mov	r24, r17
     9b2:	81 54       	subi	r24, 0x41	; 65
     9b4:	86 30       	cpi	r24, 0x06	; 6
     9b6:	08 f4       	brcc	.+2      	; 0x9ba <retConv_s32+0x86>
		c -= 55;
     9b8:	17 53       	subi	r17, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     9ba:	80 2f       	mov	r24, r16
     9bc:	80 53       	subi	r24, 0x30	; 48
     9be:	8a 30       	cpi	r24, 0x0A	; 10
     9c0:	10 f4       	brcc	.+4      	; 0x9c6 <retConv_s32+0x92>
     9c2:	08 2f       	mov	r16, r24
     9c4:	05 c0       	rjmp	.+10     	; 0x9d0 <retConv_s32+0x9c>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     9c6:	80 2f       	mov	r24, r16
     9c8:	81 54       	subi	r24, 0x41	; 65
     9ca:	86 30       	cpi	r24, 0x06	; 6
     9cc:	08 f4       	brcc	.+2      	; 0x9d0 <retConv_s32+0x9c>
		c -= 55;
     9ce:	07 53       	subi	r16, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     9d0:	8f 2d       	mov	r24, r15
     9d2:	80 53       	subi	r24, 0x30	; 48
     9d4:	8a 30       	cpi	r24, 0x0A	; 10
     9d6:	10 f4       	brcc	.+4      	; 0x9dc <retConv_s32+0xa8>
     9d8:	f8 2e       	mov	r15, r24
     9da:	06 c0       	rjmp	.+12     	; 0x9e8 <retConv_s32+0xb4>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     9dc:	8f 2d       	mov	r24, r15
     9de:	81 54       	subi	r24, 0x41	; 65
     9e0:	86 30       	cpi	r24, 0x06	; 6
     9e2:	10 f4       	brcc	.+4      	; 0x9e8 <retConv_s32+0xb4>
		c -= 55;
     9e4:	89 ec       	ldi	r24, 0xC9	; 201
     9e6:	f8 0e       	add	r15, r24

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     9e8:	8e 2f       	mov	r24, r30
     9ea:	80 53       	subi	r24, 0x30	; 48
     9ec:	8a 30       	cpi	r24, 0x0A	; 10
     9ee:	10 f4       	brcc	.+4      	; 0x9f4 <retConv_s32+0xc0>
     9f0:	e8 2f       	mov	r30, r24
     9f2:	05 c0       	rjmp	.+10     	; 0x9fe <retConv_s32+0xca>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     9f4:	8e 2f       	mov	r24, r30
     9f6:	81 54       	subi	r24, 0x41	; 65
     9f8:	86 30       	cpi	r24, 0x06	; 6
     9fa:	08 f4       	brcc	.+2      	; 0x9fe <retConv_s32+0xca>
		c -= 55;
     9fc:	e7 53       	subi	r30, 0x37	; 55
	iv6 = char2hex(iv6);
	iv7 = char2hex(iv7);
	iv8 = char2hex(iv8);

	int_val = (int_val | iv1);
	int_val = ((int_val<<4) | iv2);
     9fe:	30 e0       	ldi	r19, 0x00	; 0
     a00:	40 e0       	ldi	r20, 0x00	; 0
     a02:	50 e0       	ldi	r21, 0x00	; 0
     a04:	89 2f       	mov	r24, r25
     a06:	90 e0       	ldi	r25, 0x00	; 0
     a08:	a0 e0       	ldi	r26, 0x00	; 0
     a0a:	b0 e0       	ldi	r27, 0x00	; 0
     a0c:	f4 e0       	ldi	r31, 0x04	; 4
     a0e:	88 0f       	add	r24, r24
     a10:	99 1f       	adc	r25, r25
     a12:	aa 1f       	adc	r26, r26
     a14:	bb 1f       	adc	r27, r27
     a16:	fa 95       	dec	r31
     a18:	d1 f7       	brne	.-12     	; 0xa0e <retConv_s32+0xda>
     a1a:	28 2b       	or	r18, r24
     a1c:	39 2b       	or	r19, r25
     a1e:	4a 2b       	or	r20, r26
     a20:	5b 2b       	or	r21, r27
	int_val = ((int_val<<4) | iv3);
     a22:	a4 e0       	ldi	r26, 0x04	; 4
     a24:	22 0f       	add	r18, r18
     a26:	33 1f       	adc	r19, r19
     a28:	44 1f       	adc	r20, r20
     a2a:	55 1f       	adc	r21, r21
     a2c:	aa 95       	dec	r26
     a2e:	d1 f7       	brne	.-12     	; 0xa24 <retConv_s32+0xf0>
     a30:	86 2f       	mov	r24, r22
     a32:	90 e0       	ldi	r25, 0x00	; 0
     a34:	a0 e0       	ldi	r26, 0x00	; 0
     a36:	b0 e0       	ldi	r27, 0x00	; 0
     a38:	82 2b       	or	r24, r18
     a3a:	93 2b       	or	r25, r19
     a3c:	a4 2b       	or	r26, r20
     a3e:	b5 2b       	or	r27, r21
	int_val = ((int_val<<4) | iv4);
     a40:	f4 e0       	ldi	r31, 0x04	; 4
     a42:	88 0f       	add	r24, r24
     a44:	99 1f       	adc	r25, r25
     a46:	aa 1f       	adc	r26, r26
     a48:	bb 1f       	adc	r27, r27
     a4a:	fa 95       	dec	r31
     a4c:	d1 f7       	brne	.-12     	; 0xa42 <retConv_s32+0x10e>
     a4e:	27 2f       	mov	r18, r23
     a50:	30 e0       	ldi	r19, 0x00	; 0
     a52:	40 e0       	ldi	r20, 0x00	; 0
     a54:	50 e0       	ldi	r21, 0x00	; 0
     a56:	28 2b       	or	r18, r24
     a58:	39 2b       	or	r19, r25
     a5a:	4a 2b       	or	r20, r26
     a5c:	5b 2b       	or	r21, r27
	int_val = ((int_val<<4) | iv5);
     a5e:	64 e0       	ldi	r22, 0x04	; 4
     a60:	22 0f       	add	r18, r18
     a62:	33 1f       	adc	r19, r19
     a64:	44 1f       	adc	r20, r20
     a66:	55 1f       	adc	r21, r21
     a68:	6a 95       	dec	r22
     a6a:	d1 f7       	brne	.-12     	; 0xa60 <retConv_s32+0x12c>
     a6c:	81 2f       	mov	r24, r17
     a6e:	90 e0       	ldi	r25, 0x00	; 0
     a70:	a0 e0       	ldi	r26, 0x00	; 0
     a72:	b0 e0       	ldi	r27, 0x00	; 0
     a74:	82 2b       	or	r24, r18
     a76:	93 2b       	or	r25, r19
     a78:	a4 2b       	or	r26, r20
     a7a:	b5 2b       	or	r27, r21
	int_val = ((int_val<<4) | iv6);
     a7c:	24 e0       	ldi	r18, 0x04	; 4
     a7e:	88 0f       	add	r24, r24
     a80:	99 1f       	adc	r25, r25
     a82:	aa 1f       	adc	r26, r26
     a84:	bb 1f       	adc	r27, r27
     a86:	2a 95       	dec	r18
     a88:	d1 f7       	brne	.-12     	; 0xa7e <retConv_s32+0x14a>
     a8a:	20 2f       	mov	r18, r16
     a8c:	30 e0       	ldi	r19, 0x00	; 0
     a8e:	40 e0       	ldi	r20, 0x00	; 0
     a90:	50 e0       	ldi	r21, 0x00	; 0
     a92:	28 2b       	or	r18, r24
     a94:	39 2b       	or	r19, r25
     a96:	4a 2b       	or	r20, r26
     a98:	5b 2b       	or	r21, r27
	int_val = ((int_val<<4) | iv7);
     a9a:	04 e0       	ldi	r16, 0x04	; 4
     a9c:	22 0f       	add	r18, r18
     a9e:	33 1f       	adc	r19, r19
     aa0:	44 1f       	adc	r20, r20
     aa2:	55 1f       	adc	r21, r21
     aa4:	0a 95       	dec	r16
     aa6:	d1 f7       	brne	.-12     	; 0xa9c <retConv_s32+0x168>
     aa8:	8f 2d       	mov	r24, r15
     aaa:	90 e0       	ldi	r25, 0x00	; 0
     aac:	a0 e0       	ldi	r26, 0x00	; 0
     aae:	b0 e0       	ldi	r27, 0x00	; 0
     ab0:	82 2b       	or	r24, r18
     ab2:	93 2b       	or	r25, r19
     ab4:	a4 2b       	or	r26, r20
     ab6:	b5 2b       	or	r27, r21
	int_val = ((int_val<<4) | iv8);
     ab8:	14 e0       	ldi	r17, 0x04	; 4
     aba:	88 0f       	add	r24, r24
     abc:	99 1f       	adc	r25, r25
     abe:	aa 1f       	adc	r26, r26
     ac0:	bb 1f       	adc	r27, r27
     ac2:	1a 95       	dec	r17
     ac4:	d1 f7       	brne	.-12     	; 0xaba <retConv_s32+0x186>
     ac6:	2e 2f       	mov	r18, r30
     ac8:	30 e0       	ldi	r19, 0x00	; 0
     aca:	40 e0       	ldi	r20, 0x00	; 0
     acc:	50 e0       	ldi	r21, 0x00	; 0
     ace:	28 2b       	or	r18, r24
     ad0:	39 2b       	or	r19, r25
     ad2:	4a 2b       	or	r20, r26
     ad4:	5b 2b       	or	r21, r27
	return int_val;
}
     ad6:	b9 01       	movw	r22, r18
     ad8:	ca 01       	movw	r24, r20
     ada:	1f 91       	pop	r17
     adc:	0f 91       	pop	r16
     ade:	ff 90       	pop	r15
     ae0:	08 95       	ret

00000ae2 <LDSRcv>:
		else{rprintf("WR\n");}
		
}

void LDSRcv(unsigned char c){
	lds_buffer[lds_buffer_write_ndx] = c;
     ae2:	20 91 f0 02 	lds	r18, 0x02F0
     ae6:	30 91 f1 02 	lds	r19, 0x02F1
     aea:	f9 01       	movw	r30, r18
     aec:	e0 5b       	subi	r30, 0xB0	; 176
     aee:	fd 4e       	sbci	r31, 0xED	; 237
     af0:	80 83       	st	Z, r24
	lds_buffer_write_ndx++;
     af2:	2f 5f       	subi	r18, 0xFF	; 255
     af4:	3f 4f       	sbci	r19, 0xFF	; 255
     af6:	30 93 f1 02 	sts	0x02F1, r19
     afa:	20 93 f0 02 	sts	0x02F0, r18
	if(lds_buffer_write_ndx == buffer_size) lds_buffer_write_ndx = 0;
     afe:	20 50       	subi	r18, 0x00	; 0
     b00:	34 40       	sbci	r19, 0x04	; 4
     b02:	21 f4       	brne	.+8      	; 0xb0c <LDSRcv+0x2a>
     b04:	10 92 f1 02 	sts	0x02F1, r1
     b08:	10 92 f0 02 	sts	0x02F0, r1
     b0c:	08 95       	ret

00000b0e <read_LDS>:
}

uint8_t read_LDS(){
	lds_buffer_read_ndx++;
     b0e:	80 91 f2 02 	lds	r24, 0x02F2
     b12:	90 91 f3 02 	lds	r25, 0x02F3
     b16:	01 96       	adiw	r24, 0x01	; 1
     b18:	90 93 f3 02 	sts	0x02F3, r25
     b1c:	80 93 f2 02 	sts	0x02F2, r24
	if(lds_buffer_read_ndx == buffer_size) lds_buffer_read_ndx = 0;
     b20:	80 50       	subi	r24, 0x00	; 0
     b22:	94 40       	sbci	r25, 0x04	; 4
     b24:	21 f4       	brne	.+8      	; 0xb2e <read_LDS+0x20>
     b26:	10 92 f3 02 	sts	0x02F3, r1
     b2a:	10 92 f2 02 	sts	0x02F2, r1
     b2e:	e0 91 f2 02 	lds	r30, 0x02F2
     b32:	f0 91 f3 02 	lds	r31, 0x02F3
     b36:	e1 5b       	subi	r30, 0xB1	; 177
     b38:	fd 4e       	sbci	r31, 0xED	; 237
	return lds_buffer[lds_buffer_read_ndx - 1];
}
     b3a:	80 81       	ld	r24, Z
     b3c:	08 95       	ret

00000b3e <wheel_L>:
}

/*************************************************/


void wheel_L(float cmd_vel){
     b3e:	ef 92       	push	r14
     b40:	ff 92       	push	r15
     b42:	0f 93       	push	r16
     b44:	1f 93       	push	r17
     b46:	7b 01       	movw	r14, r22
     b48:	8c 01       	movw	r16, r24
		if(cmd_vel > 36){cmd_vel = 36;}
     b4a:	20 e0       	ldi	r18, 0x00	; 0
     b4c:	30 e0       	ldi	r19, 0x00	; 0
     b4e:	40 e1       	ldi	r20, 0x10	; 16
     b50:	52 e4       	ldi	r21, 0x42	; 66
     b52:	0e 94 5c 2d 	call	0x5ab8	; 0x5ab8 <__gesf2>
     b56:	18 16       	cp	r1, r24
     b58:	5c f4       	brge	.+22     	; 0xb70 <wheel_L+0x32>
     b5a:	0f 2e       	mov	r0, r31
     b5c:	f0 e0       	ldi	r31, 0x00	; 0
     b5e:	ef 2e       	mov	r14, r31
     b60:	f0 e0       	ldi	r31, 0x00	; 0
     b62:	ff 2e       	mov	r15, r31
     b64:	f0 e1       	ldi	r31, 0x10	; 16
     b66:	0f 2f       	mov	r16, r31
     b68:	f2 e4       	ldi	r31, 0x42	; 66
     b6a:	1f 2f       	mov	r17, r31
     b6c:	f0 2d       	mov	r31, r0
     b6e:	14 c0       	rjmp	.+40     	; 0xb98 <wheel_L+0x5a>
		if(cmd_vel < -36){cmd_vel = -36;}
     b70:	c8 01       	movw	r24, r16
     b72:	b7 01       	movw	r22, r14
     b74:	20 e0       	ldi	r18, 0x00	; 0
     b76:	30 e0       	ldi	r19, 0x00	; 0
     b78:	40 e1       	ldi	r20, 0x10	; 16
     b7a:	52 ec       	ldi	r21, 0xC2	; 194
     b7c:	0e 94 93 2b 	call	0x5726	; 0x5726 <__cmpsf2>
     b80:	88 23       	and	r24, r24
     b82:	54 f4       	brge	.+20     	; 0xb98 <wheel_L+0x5a>
     b84:	0f 2e       	mov	r0, r31
     b86:	f0 e0       	ldi	r31, 0x00	; 0
     b88:	ef 2e       	mov	r14, r31
     b8a:	f0 e0       	ldi	r31, 0x00	; 0
     b8c:	ff 2e       	mov	r15, r31
     b8e:	f0 e1       	ldi	r31, 0x10	; 16
     b90:	0f 2f       	mov	r16, r31
     b92:	f2 ec       	ldi	r31, 0xC2	; 194
     b94:	1f 2f       	mov	r17, r31
     b96:	f0 2d       	mov	r31, r0
		
		float s_out = -0.4928 * (cmd_vel) + 185.27;
		
		taskENTER_CRITICAL();
     b98:	0f b6       	in	r0, 0x3f	; 63
     b9a:	f8 94       	cli
     b9c:	0f 92       	push	r0
		PWM_timer3_Set_E4((int)s_out);
     b9e:	c8 01       	movw	r24, r16
     ba0:	b7 01       	movw	r22, r14
     ba2:	28 e4       	ldi	r18, 0x48	; 72
     ba4:	30 e5       	ldi	r19, 0x50	; 80
     ba6:	4c ef       	ldi	r20, 0xFC	; 252
     ba8:	5e eb       	ldi	r21, 0xBE	; 190
     baa:	0e 94 67 2d 	call	0x5ace	; 0x5ace <__mulsf3>
     bae:	2f e1       	ldi	r18, 0x1F	; 31
     bb0:	35 e4       	ldi	r19, 0x45	; 69
     bb2:	49 e3       	ldi	r20, 0x39	; 57
     bb4:	53 e4       	ldi	r21, 0x43	; 67
     bb6:	0e 94 cd 2a 	call	0x559a	; 0x559a <__addsf3>
     bba:	0e 94 ff 2b 	call	0x57fe	; 0x57fe <__fixsfsi>
void PWM_timer2_Set_H6(u16 pwmDuty)
	{OCR2B = pwmDuty;}
void PWM_timer3_Set_E3(u16 pwmDuty)
	{OCR3A = pwmDuty;}
void PWM_timer3_Set_E4(u16 pwmDuty)
	{OCR3B = pwmDuty;}
     bbe:	70 93 9b 00 	sts	0x009B, r23
     bc2:	60 93 9a 00 	sts	0x009A, r22
		taskEXIT_CRITICAL();
     bc6:	0f 90       	pop	r0
     bc8:	0f be       	out	0x3f, r0	; 63


}
     bca:	1f 91       	pop	r17
     bcc:	0f 91       	pop	r16
     bce:	ff 90       	pop	r15
     bd0:	ef 90       	pop	r14
     bd2:	08 95       	ret

00000bd4 <wheel_R>:

void wheel_R(float cmd_vel){
     bd4:	ef 92       	push	r14
     bd6:	ff 92       	push	r15
     bd8:	0f 93       	push	r16
     bda:	1f 93       	push	r17
     bdc:	7b 01       	movw	r14, r22
     bde:	8c 01       	movw	r16, r24
		if(cmd_vel > 36){cmd_vel = 36;}
     be0:	20 e0       	ldi	r18, 0x00	; 0
     be2:	30 e0       	ldi	r19, 0x00	; 0
     be4:	40 e1       	ldi	r20, 0x10	; 16
     be6:	52 e4       	ldi	r21, 0x42	; 66
     be8:	0e 94 5c 2d 	call	0x5ab8	; 0x5ab8 <__gesf2>
     bec:	18 16       	cp	r1, r24
     bee:	5c f4       	brge	.+22     	; 0xc06 <wheel_R+0x32>
     bf0:	0f 2e       	mov	r0, r31
     bf2:	f0 e0       	ldi	r31, 0x00	; 0
     bf4:	ef 2e       	mov	r14, r31
     bf6:	f0 e0       	ldi	r31, 0x00	; 0
     bf8:	ff 2e       	mov	r15, r31
     bfa:	f0 e1       	ldi	r31, 0x10	; 16
     bfc:	0f 2f       	mov	r16, r31
     bfe:	f2 e4       	ldi	r31, 0x42	; 66
     c00:	1f 2f       	mov	r17, r31
     c02:	f0 2d       	mov	r31, r0
     c04:	14 c0       	rjmp	.+40     	; 0xc2e <wheel_R+0x5a>
		if(cmd_vel < -36){cmd_vel = -36;}
     c06:	c8 01       	movw	r24, r16
     c08:	b7 01       	movw	r22, r14
     c0a:	20 e0       	ldi	r18, 0x00	; 0
     c0c:	30 e0       	ldi	r19, 0x00	; 0
     c0e:	40 e1       	ldi	r20, 0x10	; 16
     c10:	52 ec       	ldi	r21, 0xC2	; 194
     c12:	0e 94 93 2b 	call	0x5726	; 0x5726 <__cmpsf2>
     c16:	88 23       	and	r24, r24
     c18:	54 f4       	brge	.+20     	; 0xc2e <wheel_R+0x5a>
     c1a:	0f 2e       	mov	r0, r31
     c1c:	f0 e0       	ldi	r31, 0x00	; 0
     c1e:	ef 2e       	mov	r14, r31
     c20:	f0 e0       	ldi	r31, 0x00	; 0
     c22:	ff 2e       	mov	r15, r31
     c24:	f0 e1       	ldi	r31, 0x10	; 16
     c26:	0f 2f       	mov	r16, r31
     c28:	f2 ec       	ldi	r31, 0xC2	; 194
     c2a:	1f 2f       	mov	r17, r31
     c2c:	f0 2d       	mov	r31, r0
				
		float s_out = -0.5421 * (cmd_vel) + 188.41;

		taskENTER_CRITICAL();
     c2e:	0f b6       	in	r0, 0x3f	; 63
     c30:	f8 94       	cli
     c32:	0f 92       	push	r0
		PWM_timer3_Set_E3((int)s_out);
     c34:	c8 01       	movw	r24, r16
     c36:	b7 01       	movw	r22, r14
     c38:	21 e1       	ldi	r18, 0x11	; 17
     c3a:	37 ec       	ldi	r19, 0xC7	; 199
     c3c:	4a e0       	ldi	r20, 0x0A	; 10
     c3e:	5f eb       	ldi	r21, 0xBF	; 191
     c40:	0e 94 67 2d 	call	0x5ace	; 0x5ace <__mulsf3>
     c44:	26 ef       	ldi	r18, 0xF6	; 246
     c46:	38 e6       	ldi	r19, 0x68	; 104
     c48:	4c e3       	ldi	r20, 0x3C	; 60
     c4a:	53 e4       	ldi	r21, 0x43	; 67
     c4c:	0e 94 cd 2a 	call	0x559a	; 0x559a <__addsf3>
     c50:	0e 94 ff 2b 	call	0x57fe	; 0x57fe <__fixsfsi>
void PWM_timer1_Set_LED(u16 pwmDuty)
	{OCR1B = pwmDuty;}
void PWM_timer2_Set_H6(u16 pwmDuty)
	{OCR2B = pwmDuty;}
void PWM_timer3_Set_E3(u16 pwmDuty)
	{OCR3A = pwmDuty;}
     c54:	70 93 99 00 	sts	0x0099, r23
     c58:	60 93 98 00 	sts	0x0098, r22
		taskEXIT_CRITICAL();
     c5c:	0f 90       	pop	r0
     c5e:	0f be       	out	0x3f, r0	; 63


}
     c60:	1f 91       	pop	r17
     c62:	0f 91       	pop	r16
     c64:	ff 90       	pop	r15
     c66:	ef 90       	pop	r14
     c68:	08 95       	ret

00000c6a <num2char>:
	}
}



char num2char(char c){
     c6a:	98 2f       	mov	r25, r24
	
	if(c <10){
     c6c:	8a 30       	cpi	r24, 0x0A	; 10
     c6e:	10 f4       	brcc	.+4      	; 0xc74 <num2char+0xa>
		c += 48;
     c70:	90 5d       	subi	r25, 0xD0	; 208
     c72:	04 c0       	rjmp	.+8      	; 0xc7c <num2char+0x12>
	}
	else if((c >= 10) && (c <= 16)){
     c74:	8a 50       	subi	r24, 0x0A	; 10
     c76:	87 30       	cpi	r24, 0x07	; 7
     c78:	08 f4       	brcc	.+2      	; 0xc7c <num2char+0x12>
		c += 55;
     c7a:	99 5c       	subi	r25, 0xC9	; 201
	}
	return c;
}
     c7c:	89 2f       	mov	r24, r25
     c7e:	08 95       	ret

00000c80 <vUpdatePose>:
		
	vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
	}
}

void vUpdatePose(){
     c80:	af 92       	push	r10
     c82:	bf 92       	push	r11
     c84:	cf 92       	push	r12
     c86:	df 92       	push	r13
     c88:	ef 92       	push	r14
     c8a:	ff 92       	push	r15
     c8c:	0f 93       	push	r16
     c8e:	1f 93       	push	r17
	float CMD_K = 0.5;
	float COR_K = 1;
	uint8_t lds_char;

	for(;;){
		robot.heading = (180 * enc_heading) / M_PI; 
     c90:	60 91 d8 02 	lds	r22, 0x02D8
     c94:	70 91 d9 02 	lds	r23, 0x02D9
     c98:	80 91 da 02 	lds	r24, 0x02DA
     c9c:	90 91 db 02 	lds	r25, 0x02DB
     ca0:	20 e0       	ldi	r18, 0x00	; 0
     ca2:	30 e0       	ldi	r19, 0x00	; 0
     ca4:	44 e3       	ldi	r20, 0x34	; 52
     ca6:	53 e4       	ldi	r21, 0x43	; 67
     ca8:	0e 94 67 2d 	call	0x5ace	; 0x5ace <__mulsf3>
     cac:	2b ed       	ldi	r18, 0xDB	; 219
     cae:	3f e0       	ldi	r19, 0x0F	; 15
     cb0:	49 e4       	ldi	r20, 0x49	; 73
     cb2:	50 e4       	ldi	r21, 0x40	; 64
     cb4:	0e 94 97 2b 	call	0x572e	; 0x572e <__divsf3>
     cb8:	5b 01       	movw	r10, r22
     cba:	6c 01       	movw	r12, r24
		robot.vel = (LEFTVel_current + (-RIGHTVel_current)) / 2;
     cbc:	80 91 be 02 	lds	r24, 0x02BE
     cc0:	90 91 bf 02 	lds	r25, 0x02BF
     cc4:	20 91 cb 02 	lds	r18, 0x02CB
     cc8:	30 91 cc 02 	lds	r19, 0x02CC
     ccc:	82 1b       	sub	r24, r18
     cce:	93 0b       	sbc	r25, r19
     cd0:	62 e0       	ldi	r22, 0x02	; 2
     cd2:	70 e0       	ldi	r23, 0x00	; 0
     cd4:	0e 94 00 2e 	call	0x5c00	; 0x5c00 <__divmodhi4>
     cd8:	88 27       	eor	r24, r24
     cda:	77 fd       	sbrc	r23, 7
     cdc:	80 95       	com	r24
     cde:	98 2f       	mov	r25, r24
     ce0:	0e 94 32 2c 	call	0x5864	; 0x5864 <__floatsisf>
     ce4:	7b 01       	movw	r14, r22
     ce6:	8c 01       	movw	r16, r24
	float CMD_K = 0.5;
	float COR_K = 1;
	uint8_t lds_char;

	for(;;){
		robot.heading = (180 * enc_heading) / M_PI; 
     ce8:	c5 01       	movw	r24, r10
     cea:	d6 01       	movw	r26, r12
     cec:	80 93 41 12 	sts	0x1241, r24
     cf0:	90 93 42 12 	sts	0x1242, r25
     cf4:	a0 93 43 12 	sts	0x1243, r26
     cf8:	b0 93 44 12 	sts	0x1244, r27
		robot.vel = (LEFTVel_current + (-RIGHTVel_current)) / 2;
     cfc:	e0 92 45 12 	sts	0x1245, r14
     d00:	f0 92 46 12 	sts	0x1246, r15
     d04:	00 93 47 12 	sts	0x1247, r16
     d08:	10 93 48 12 	sts	0x1248, r17
     d0c:	ed cf       	rjmp	.-38     	; 0xce8 <vUpdatePose+0x68>

00000d0e <vServoTm>:
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
		LED_off();
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));	}
}

void vServoTm(){
     d0e:	1f 93       	push	r17
     d10:	cf 93       	push	r28
     d12:	df 93       	push	r29
	char adj;
	for(;;){
		adj = uart1GetByte();
		if(adj == 'p'){ spray_time++;}
		else if(adj == 'l'){ spray_time--;}
		rprintf("%d\n", spray_time);
     d14:	11 e0       	ldi	r17, 0x01	; 1
     d16:	c5 e3       	ldi	r28, 0x35	; 53
     d18:	d1 e0       	ldi	r29, 0x01	; 1
}

void vServoTm(){
	char adj;
	for(;;){
		adj = uart1GetByte();
     d1a:	0e 94 40 23 	call	0x4680	; 0x4680 <uart1GetByte>
		if(adj == 'p'){ spray_time++;}
     d1e:	80 37       	cpi	r24, 0x70	; 112
     d20:	31 f4       	brne	.+12     	; 0xd2e <vServoTm+0x20>
     d22:	80 91 b7 02 	lds	r24, 0x02B7
     d26:	90 91 b8 02 	lds	r25, 0x02B8
     d2a:	01 96       	adiw	r24, 0x01	; 1
     d2c:	07 c0       	rjmp	.+14     	; 0xd3c <vServoTm+0x2e>
		else if(adj == 'l'){ spray_time--;}
     d2e:	8c 36       	cpi	r24, 0x6C	; 108
     d30:	49 f4       	brne	.+18     	; 0xd44 <vServoTm+0x36>
     d32:	80 91 b7 02 	lds	r24, 0x02B7
     d36:	90 91 b8 02 	lds	r25, 0x02B8
     d3a:	01 97       	sbiw	r24, 0x01	; 1
     d3c:	90 93 b8 02 	sts	0x02B8, r25
     d40:	80 93 b7 02 	sts	0x02B7, r24
		rprintf("%d\n", spray_time);
     d44:	00 d0       	rcall	.+0      	; 0xd46 <vServoTm+0x38>
     d46:	00 d0       	rcall	.+0      	; 0xd48 <vServoTm+0x3a>
     d48:	0f 92       	push	r0
     d4a:	ed b7       	in	r30, 0x3d	; 61
     d4c:	fe b7       	in	r31, 0x3e	; 62
     d4e:	31 96       	adiw	r30, 0x01	; 1
     d50:	ad b7       	in	r26, 0x3d	; 61
     d52:	be b7       	in	r27, 0x3e	; 62
     d54:	11 96       	adiw	r26, 0x01	; 1
     d56:	1c 93       	st	X, r17
     d58:	d2 83       	std	Z+2, r29	; 0x02
     d5a:	c1 83       	std	Z+1, r28	; 0x01
     d5c:	80 91 b7 02 	lds	r24, 0x02B7
     d60:	90 91 b8 02 	lds	r25, 0x02B8
     d64:	94 83       	std	Z+4, r25	; 0x04
     d66:	83 83       	std	Z+3, r24	; 0x03
     d68:	0e 94 93 27 	call	0x4f26	; 0x4f26 <rprintf1RamRom>
     d6c:	0f 90       	pop	r0
     d6e:	0f 90       	pop	r0
     d70:	0f 90       	pop	r0
     d72:	0f 90       	pop	r0
     d74:	0f 90       	pop	r0
     d76:	d1 cf       	rjmp	.-94     	; 0xd1a <vServoTm+0xc>

00000d78 <fwdSer_L>:
		
			//taskYIELD();
	//	}
		
}
void fwdSer_L(unsigned char c){
     d78:	98 2f       	mov	r25, r24
	static char d_flag;
	static char vel_rough[4];  //store ascii chars
	static char dis_rough[8];  //store ascii chars

		//rprintf("%c",c);
		if(c != 0xff){
     d7a:	8f 3f       	cpi	r24, 0xFF	; 255
     d7c:	09 f4       	brne	.+2      	; 0xd80 <fwdSer_L+0x8>
     d7e:	7c c0       	rjmp	.+248    	; 0xe78 <fwdSer_L+0x100>
		//if the data isn't whitespace (0xff), post it
		//	rprintf("%c",c);

			if(c == 0x0A){lf_flag = SET;} //line feed detected, the character will be a 'D' or a 'V'
     d80:	8a 30       	cpi	r24, 0x0A	; 10
     d82:	21 f4       	brne	.+8      	; 0xd8c <fwdSer_L+0x14>
     d84:	81 e0       	ldi	r24, 0x01	; 1
     d86:	80 93 15 03 	sts	0x0315, r24
     d8a:	33 c0       	rjmp	.+102    	; 0xdf2 <fwdSer_L+0x7a>
	
			else if((lf_flag) && (c == 'V')){ //set velocity flag
     d8c:	80 91 15 03 	lds	r24, 0x0315
     d90:	88 23       	and	r24, r24
     d92:	91 f0       	breq	.+36     	; 0xdb8 <fwdSer_L+0x40>
     d94:	96 35       	cpi	r25, 0x56	; 86
     d96:	31 f4       	brne	.+12     	; 0xda4 <fwdSer_L+0x2c>
				v_flag = SET;
     d98:	81 e0       	ldi	r24, 0x01	; 1
     d9a:	80 93 12 03 	sts	0x0312, r24
				v_iter = 0;
     d9e:	10 92 14 03 	sts	0x0314, r1
     da2:	07 c0       	rjmp	.+14     	; 0xdb2 <fwdSer_L+0x3a>
				lf_flag = UNSET;
				return;
			} 
			else if((lf_flag) && (c == 'D')){ //set distance flag
     da4:	94 34       	cpi	r25, 0x44	; 68
     da6:	41 f4       	brne	.+16     	; 0xdb8 <fwdSer_L+0x40>
				d_flag = SET;
     da8:	81 e0       	ldi	r24, 0x01	; 1
     daa:	80 93 11 03 	sts	0x0311, r24
				d_iter = 0;
     dae:	10 92 13 03 	sts	0x0313, r1
				lf_flag = UNSET;
     db2:	10 92 15 03 	sts	0x0315, r1
     db6:	08 95       	ret
			//	rprintf("%c",c);
				return;
			}
			else if(v_flag){
     db8:	80 91 12 03 	lds	r24, 0x0312
     dbc:	88 23       	and	r24, r24
     dbe:	59 f0       	breq	.+22     	; 0xdd6 <fwdSer_L+0x5e>
				vel_rough[v_iter++] = c;	//store then increment	
     dc0:	80 91 14 03 	lds	r24, 0x0314
     dc4:	e8 2f       	mov	r30, r24
     dc6:	f0 e0       	ldi	r31, 0x00	; 0
     dc8:	e3 5f       	subi	r30, 0xF3	; 243
     dca:	fc 4f       	sbci	r31, 0xFC	; 252
     dcc:	90 83       	st	Z, r25
     dce:	8f 5f       	subi	r24, 0xFF	; 255
     dd0:	80 93 14 03 	sts	0x0314, r24
     dd4:	0e c0       	rjmp	.+28     	; 0xdf2 <fwdSer_L+0x7a>
				//rprintf("%c",c);
			}	
			else if(d_flag){
     dd6:	80 91 11 03 	lds	r24, 0x0311
     dda:	88 23       	and	r24, r24
     ddc:	51 f0       	breq	.+20     	; 0xdf2 <fwdSer_L+0x7a>
				dis_rough[d_iter++] = c;	//store then increment	
     dde:	80 91 13 03 	lds	r24, 0x0313
     de2:	e8 2f       	mov	r30, r24
     de4:	f0 e0       	ldi	r31, 0x00	; 0
     de6:	eb 5f       	subi	r30, 0xFB	; 251
     de8:	fc 4f       	sbci	r31, 0xFC	; 252
     dea:	90 83       	st	Z, r25
     dec:	8f 5f       	subi	r24, 0xFF	; 255
     dee:	80 93 13 03 	sts	0x0313, r24
			//	rprintf("%c",c);
			}

			if(v_iter == 4){
     df2:	80 91 14 03 	lds	r24, 0x0314
     df6:	84 30       	cpi	r24, 0x04	; 4
     df8:	01 f5       	brne	.+64     	; 0xe3a <fwdSer_L+0xc2>
				LEFTVel_current = CM_TICK * retConv_s16(&vel_rough);
     dfa:	8d e0       	ldi	r24, 0x0D	; 13
     dfc:	93 e0       	ldi	r25, 0x03	; 3
     dfe:	0e 94 4b 04 	call	0x896	; 0x896 <retConv_s16>
     e02:	aa 27       	eor	r26, r26
     e04:	97 fd       	sbrc	r25, 7
     e06:	a0 95       	com	r26
     e08:	ba 2f       	mov	r27, r26
     e0a:	bc 01       	movw	r22, r24
     e0c:	cd 01       	movw	r24, r26
     e0e:	0e 94 32 2c 	call	0x5864	; 0x5864 <__floatsisf>
     e12:	20 e0       	ldi	r18, 0x00	; 0
     e14:	30 e0       	ldi	r19, 0x00	; 0
     e16:	40 e8       	ldi	r20, 0x80	; 128
     e18:	5e e3       	ldi	r21, 0x3E	; 62
     e1a:	0e 94 67 2d 	call	0x5ace	; 0x5ace <__mulsf3>
     e1e:	0e 94 ff 2b 	call	0x57fe	; 0x57fe <__fixsfsi>
     e22:	70 93 bf 02 	sts	0x02BF, r23
     e26:	60 93 be 02 	sts	0x02BE, r22
				v_flag = UNSET;
     e2a:	10 92 12 03 	sts	0x0312, r1
				v_iter = 0;
     e2e:	10 92 14 03 	sts	0x0314, r1
				LEFTVel_ready = SET;
     e32:	81 e0       	ldi	r24, 0x01	; 1
     e34:	80 93 c0 02 	sts	0x02C0, r24
     e38:	08 95       	ret
			//	rprintf("LEFTVel_ready: %d\n", LEFTVel_ready);
			//	rprintf("LLL VVV: ");
			//	rprintfu16(RIGHTVel_current);
			//	rprintf("\n");
			}
			else if(d_iter == 8){
     e3a:	80 91 13 03 	lds	r24, 0x0313
     e3e:	88 30       	cpi	r24, 0x08	; 8
     e40:	51 f5       	brne	.+84     	; 0xe96 <fwdSer_L+0x11e>
				LEFTDis_current = CM_TICK * retConv_s32(&dis_rough);
     e42:	85 e0       	ldi	r24, 0x05	; 5
     e44:	93 e0       	ldi	r25, 0x03	; 3
     e46:	0e 94 9a 04 	call	0x934	; 0x934 <retConv_s32>
     e4a:	0e 94 32 2c 	call	0x5864	; 0x5864 <__floatsisf>
     e4e:	20 e0       	ldi	r18, 0x00	; 0
     e50:	30 e0       	ldi	r19, 0x00	; 0
     e52:	40 e8       	ldi	r20, 0x80	; 128
     e54:	5e e3       	ldi	r21, 0x3E	; 62
     e56:	0e 94 67 2d 	call	0x5ace	; 0x5ace <__mulsf3>
     e5a:	0e 94 ff 2b 	call	0x57fe	; 0x57fe <__fixsfsi>
     e5e:	60 93 c1 02 	sts	0x02C1, r22
     e62:	70 93 c2 02 	sts	0x02C2, r23
     e66:	80 93 c3 02 	sts	0x02C3, r24
     e6a:	90 93 c4 02 	sts	0x02C4, r25
			//	rprintf("dL: %d\n",dLEFTDis);
				d_flag = UNSET;
     e6e:	10 92 11 03 	sts	0x0311, r1
				d_iter = 0;
     e72:	10 92 13 03 	sts	0x0313, r1
     e76:	08 95       	ret
			//	rprintf("\n");
			}
		
		}

		else{rprintf("WR\n");}
     e78:	00 d0       	rcall	.+0      	; 0xe7a <fwdSer_L+0x102>
     e7a:	0f 92       	push	r0
     e7c:	81 e0       	ldi	r24, 0x01	; 1
     e7e:	ed b7       	in	r30, 0x3d	; 61
     e80:	fe b7       	in	r31, 0x3e	; 62
     e82:	81 83       	std	Z+1, r24	; 0x01
     e84:	89 e6       	ldi	r24, 0x69	; 105
     e86:	91 e0       	ldi	r25, 0x01	; 1
     e88:	93 83       	std	Z+3, r25	; 0x03
     e8a:	82 83       	std	Z+2, r24	; 0x02
     e8c:	0e 94 93 27 	call	0x4f26	; 0x4f26 <rprintf1RamRom>
     e90:	0f 90       	pop	r0
     e92:	0f 90       	pop	r0
     e94:	0f 90       	pop	r0
     e96:	08 95       	ret

00000e98 <fwdSer_R>:
    
    return error_checker(chk_data, checksum);
}  
*/

void fwdSer_R(unsigned char c){
     e98:	98 2f       	mov	r25, r24
	static char d_flag;
	static char vel_rough[4];  //store ascii chars
	static char dis_rough[8];  //store ascii chars

		//rprintf("%c",c);
		if(c != 0xff){
     e9a:	8f 3f       	cpi	r24, 0xFF	; 255
     e9c:	09 f4       	brne	.+2      	; 0xea0 <fwdSer_R+0x8>
     e9e:	7c c0       	rjmp	.+248    	; 0xf98 <fwdSer_R+0x100>
		//if the data isn't whitespace (0xff), post it
		//	rprintf("%c",c);

			if(c == 0x0A){lf_flag = SET;} //line feed detected, the character will be a 'D' or a 'V'
     ea0:	8a 30       	cpi	r24, 0x0A	; 10
     ea2:	21 f4       	brne	.+8      	; 0xeac <fwdSer_R+0x14>
     ea4:	81 e0       	ldi	r24, 0x01	; 1
     ea6:	80 93 26 03 	sts	0x0326, r24
     eaa:	33 c0       	rjmp	.+102    	; 0xf12 <fwdSer_R+0x7a>
	
			else if((lf_flag) && (c == 'V')){ //set velocity flag
     eac:	80 91 26 03 	lds	r24, 0x0326
     eb0:	88 23       	and	r24, r24
     eb2:	91 f0       	breq	.+36     	; 0xed8 <fwdSer_R+0x40>
     eb4:	96 35       	cpi	r25, 0x56	; 86
     eb6:	31 f4       	brne	.+12     	; 0xec4 <fwdSer_R+0x2c>
				v_flag = SET;
     eb8:	81 e0       	ldi	r24, 0x01	; 1
     eba:	80 93 23 03 	sts	0x0323, r24
				v_iter = 0;
     ebe:	10 92 25 03 	sts	0x0325, r1
     ec2:	07 c0       	rjmp	.+14     	; 0xed2 <fwdSer_R+0x3a>
				lf_flag = UNSET;
				return;
			} 
			else if((lf_flag) && (c == 'D')){ //set distance flag
     ec4:	94 34       	cpi	r25, 0x44	; 68
     ec6:	41 f4       	brne	.+16     	; 0xed8 <fwdSer_R+0x40>
				d_flag = SET;
     ec8:	81 e0       	ldi	r24, 0x01	; 1
     eca:	80 93 22 03 	sts	0x0322, r24
				d_iter = 0;
     ece:	10 92 24 03 	sts	0x0324, r1
				lf_flag = UNSET;
     ed2:	10 92 26 03 	sts	0x0326, r1
     ed6:	08 95       	ret
			//	rprintf("%c",c);
				return;
			}
			else if(v_flag){
     ed8:	80 91 23 03 	lds	r24, 0x0323
     edc:	88 23       	and	r24, r24
     ede:	59 f0       	breq	.+22     	; 0xef6 <fwdSer_R+0x5e>
				vel_rough[v_iter++] = c;	//store then increment	
     ee0:	80 91 25 03 	lds	r24, 0x0325
     ee4:	e8 2f       	mov	r30, r24
     ee6:	f0 e0       	ldi	r31, 0x00	; 0
     ee8:	e2 5e       	subi	r30, 0xE2	; 226
     eea:	fc 4f       	sbci	r31, 0xFC	; 252
     eec:	90 83       	st	Z, r25
     eee:	8f 5f       	subi	r24, 0xFF	; 255
     ef0:	80 93 25 03 	sts	0x0325, r24
     ef4:	0e c0       	rjmp	.+28     	; 0xf12 <fwdSer_R+0x7a>
				//rprintf("%c",c);
			}	
			else if(d_flag){
     ef6:	80 91 22 03 	lds	r24, 0x0322
     efa:	88 23       	and	r24, r24
     efc:	51 f0       	breq	.+20     	; 0xf12 <fwdSer_R+0x7a>
				dis_rough[d_iter++] = c;	//store then increment	
     efe:	80 91 24 03 	lds	r24, 0x0324
     f02:	e8 2f       	mov	r30, r24
     f04:	f0 e0       	ldi	r31, 0x00	; 0
     f06:	ea 5e       	subi	r30, 0xEA	; 234
     f08:	fc 4f       	sbci	r31, 0xFC	; 252
     f0a:	90 83       	st	Z, r25
     f0c:	8f 5f       	subi	r24, 0xFF	; 255
     f0e:	80 93 24 03 	sts	0x0324, r24
			//	rprintf("%c",c);
			}

			if(v_iter == 4){
     f12:	80 91 25 03 	lds	r24, 0x0325
     f16:	84 30       	cpi	r24, 0x04	; 4
     f18:	01 f5       	brne	.+64     	; 0xf5a <fwdSer_R+0xc2>
				RIGHTVel_current = CM_TICK * retConv_s16(&vel_rough);
     f1a:	8e e1       	ldi	r24, 0x1E	; 30
     f1c:	93 e0       	ldi	r25, 0x03	; 3
     f1e:	0e 94 4b 04 	call	0x896	; 0x896 <retConv_s16>
     f22:	aa 27       	eor	r26, r26
     f24:	97 fd       	sbrc	r25, 7
     f26:	a0 95       	com	r26
     f28:	ba 2f       	mov	r27, r26
     f2a:	bc 01       	movw	r22, r24
     f2c:	cd 01       	movw	r24, r26
     f2e:	0e 94 32 2c 	call	0x5864	; 0x5864 <__floatsisf>
     f32:	20 e0       	ldi	r18, 0x00	; 0
     f34:	30 e0       	ldi	r19, 0x00	; 0
     f36:	40 e8       	ldi	r20, 0x80	; 128
     f38:	5e e3       	ldi	r21, 0x3E	; 62
     f3a:	0e 94 67 2d 	call	0x5ace	; 0x5ace <__mulsf3>
     f3e:	0e 94 ff 2b 	call	0x57fe	; 0x57fe <__fixsfsi>
     f42:	70 93 cc 02 	sts	0x02CC, r23
     f46:	60 93 cb 02 	sts	0x02CB, r22
				v_flag = UNSET;
     f4a:	10 92 23 03 	sts	0x0323, r1
				v_iter = 0;
     f4e:	10 92 25 03 	sts	0x0325, r1
				RIGHTVel_ready = SET;
     f52:	81 e0       	ldi	r24, 0x01	; 1
     f54:	80 93 cd 02 	sts	0x02CD, r24
     f58:	08 95       	ret

			//	rprintf("RRR VVV: ");
			//	rprintfu16(RIGHTVel_current);
			//	rprintf("\n");
			}
			else if(d_iter == 8){
     f5a:	80 91 24 03 	lds	r24, 0x0324
     f5e:	88 30       	cpi	r24, 0x08	; 8
     f60:	51 f5       	brne	.+84     	; 0xfb6 <fwdSer_R+0x11e>
				RIGHTDis_current = CM_TICK * retConv_s32(&dis_rough);
     f62:	86 e1       	ldi	r24, 0x16	; 22
     f64:	93 e0       	ldi	r25, 0x03	; 3
     f66:	0e 94 9a 04 	call	0x934	; 0x934 <retConv_s32>
     f6a:	0e 94 32 2c 	call	0x5864	; 0x5864 <__floatsisf>
     f6e:	20 e0       	ldi	r18, 0x00	; 0
     f70:	30 e0       	ldi	r19, 0x00	; 0
     f72:	40 e8       	ldi	r20, 0x80	; 128
     f74:	5e e3       	ldi	r21, 0x3E	; 62
     f76:	0e 94 67 2d 	call	0x5ace	; 0x5ace <__mulsf3>
     f7a:	0e 94 ff 2b 	call	0x57fe	; 0x57fe <__fixsfsi>
     f7e:	60 93 ce 02 	sts	0x02CE, r22
     f82:	70 93 cf 02 	sts	0x02CF, r23
     f86:	80 93 d0 02 	sts	0x02D0, r24
     f8a:	90 93 d1 02 	sts	0x02D1, r25
				//rprintf("dR: %d\n",dRIGHTDis);
				d_flag = UNSET;
     f8e:	10 92 22 03 	sts	0x0322, r1
				d_iter = 0;
     f92:	10 92 24 03 	sts	0x0324, r1
     f96:	08 95       	ret
				//rprintf("\n");
			}
		
		}

		else{rprintf("WR\n");}
     f98:	00 d0       	rcall	.+0      	; 0xf9a <fwdSer_R+0x102>
     f9a:	0f 92       	push	r0
     f9c:	81 e0       	ldi	r24, 0x01	; 1
     f9e:	ed b7       	in	r30, 0x3d	; 61
     fa0:	fe b7       	in	r31, 0x3e	; 62
     fa2:	81 83       	std	Z+1, r24	; 0x01
     fa4:	8d e6       	ldi	r24, 0x6D	; 109
     fa6:	91 e0       	ldi	r25, 0x01	; 1
     fa8:	93 83       	std	Z+3, r25	; 0x03
     faa:	82 83       	std	Z+2, r24	; 0x02
     fac:	0e 94 93 27 	call	0x4f26	; 0x4f26 <rprintf1RamRom>
     fb0:	0f 90       	pop	r0
     fb2:	0f 90       	pop	r0
     fb4:	0f 90       	pop	r0
     fb6:	08 95       	ret

00000fb8 <vScript>:
		
	}

}

void vScript(){
     fb8:	3f 92       	push	r3
     fba:	4f 92       	push	r4
     fbc:	5f 92       	push	r5
     fbe:	6f 92       	push	r6
     fc0:	7f 92       	push	r7
     fc2:	8f 92       	push	r8
     fc4:	9f 92       	push	r9
     fc6:	af 92       	push	r10
     fc8:	bf 92       	push	r11
     fca:	cf 92       	push	r12
     fcc:	df 92       	push	r13
     fce:	ef 92       	push	r14
     fd0:	ff 92       	push	r15
     fd2:	0f 93       	push	r16
     fd4:	1f 93       	push	r17
     fd6:	df 93       	push	r29
     fd8:	cf 93       	push	r28
     fda:	00 d0       	rcall	.+0      	; 0xfdc <vScript+0x24>
     fdc:	cd b7       	in	r28, 0x3d	; 61
     fde:	de b7       	in	r29, 0x3e	; 62
	const portTickType xTicksToWait = 10000 / portTICK_RATE_MS;
	portTickType xLastWakeTime;

	for(;;){
		cmd_angle = 0;
     fe0:	0f 2e       	mov	r0, r31
     fe2:	f0 e0       	ldi	r31, 0x00	; 0
     fe4:	af 2e       	mov	r10, r31
     fe6:	f0 e0       	ldi	r31, 0x00	; 0
     fe8:	bf 2e       	mov	r11, r31
     fea:	f0 e0       	ldi	r31, 0x00	; 0
     fec:	cf 2e       	mov	r12, r31
     fee:	f0 e0       	ldi	r31, 0x00	; 0
     ff0:	df 2e       	mov	r13, r31
     ff2:	f0 2d       	mov	r31, r0
		rprintf("cmd_angle: ");
     ff4:	33 24       	eor	r3, r3
     ff6:	33 94       	inc	r3
     ff8:	b4 e2       	ldi	r27, 0x24	; 36
     ffa:	4b 2e       	mov	r4, r27
     ffc:	b1 e0       	ldi	r27, 0x01	; 1
     ffe:	5b 2e       	mov	r5, r27
		rprintfFloat(5, cmd_angle);
		rprintfCRLF();
		vTaskDelayUntil(&xLastWakeTime, xTicksToWait);
    1000:	4e 01       	movw	r8, r28
    1002:	08 94       	sec
    1004:	81 1c       	adc	r8, r1
    1006:	91 1c       	adc	r9, r1
		cmd_angle = 90*(M_PI/180);
    1008:	0f 2e       	mov	r0, r31
    100a:	fb ed       	ldi	r31, 0xDB	; 219
    100c:	ef 2e       	mov	r14, r31
    100e:	ff e0       	ldi	r31, 0x0F	; 15
    1010:	ff 2e       	mov	r15, r31
    1012:	f9 ec       	ldi	r31, 0xC9	; 201
    1014:	0f 2f       	mov	r16, r31
    1016:	ff e3       	ldi	r31, 0x3F	; 63
    1018:	1f 2f       	mov	r17, r31
    101a:	f0 2d       	mov	r31, r0
		rprintf("cmd_angle: ");
    101c:	a8 e1       	ldi	r26, 0x18	; 24
    101e:	6a 2e       	mov	r6, r26
    1020:	a1 e0       	ldi	r26, 0x01	; 1
    1022:	7a 2e       	mov	r7, r26
void vScript(){
	const portTickType xTicksToWait = 10000 / portTICK_RATE_MS;
	portTickType xLastWakeTime;

	for(;;){
		cmd_angle = 0;
    1024:	a0 92 e4 02 	sts	0x02E4, r10
    1028:	b0 92 e5 02 	sts	0x02E5, r11
    102c:	c0 92 e6 02 	sts	0x02E6, r12
    1030:	d0 92 e7 02 	sts	0x02E7, r13
		rprintf("cmd_angle: ");
    1034:	00 d0       	rcall	.+0      	; 0x1036 <vScript+0x7e>
    1036:	0f 92       	push	r0
    1038:	ed b7       	in	r30, 0x3d	; 61
    103a:	fe b7       	in	r31, 0x3e	; 62
    103c:	31 82       	std	Z+1, r3	; 0x01
    103e:	53 82       	std	Z+3, r5	; 0x03
    1040:	42 82       	std	Z+2, r4	; 0x02
    1042:	0e 94 93 27 	call	0x4f26	; 0x4f26 <rprintf1RamRom>
		rprintfFloat(5, cmd_angle);
    1046:	0f 90       	pop	r0
    1048:	0f 90       	pop	r0
    104a:	0f 90       	pop	r0
    104c:	40 91 e4 02 	lds	r20, 0x02E4
    1050:	50 91 e5 02 	lds	r21, 0x02E5
    1054:	60 91 e6 02 	lds	r22, 0x02E6
    1058:	70 91 e7 02 	lds	r23, 0x02E7
    105c:	85 e0       	ldi	r24, 0x05	; 5
    105e:	0e 94 ca 26 	call	0x4d94	; 0x4d94 <rprintfFloat>
		rprintfCRLF();
    1062:	0e 94 d3 25 	call	0x4ba6	; 0x4ba6 <rprintfCRLF>
		vTaskDelayUntil(&xLastWakeTime, xTicksToWait);
    1066:	c4 01       	movw	r24, r8
    1068:	60 e1       	ldi	r22, 0x10	; 16
    106a:	77 e2       	ldi	r23, 0x27	; 39
    106c:	0e 94 89 13 	call	0x2712	; 0x2712 <vTaskDelayUntil>
		cmd_angle = 90*(M_PI/180);
    1070:	e0 92 e4 02 	sts	0x02E4, r14
    1074:	f0 92 e5 02 	sts	0x02E5, r15
    1078:	00 93 e6 02 	sts	0x02E6, r16
    107c:	10 93 e7 02 	sts	0x02E7, r17
		rprintf("cmd_angle: ");
    1080:	00 d0       	rcall	.+0      	; 0x1082 <vScript+0xca>
    1082:	0f 92       	push	r0
    1084:	ed b7       	in	r30, 0x3d	; 61
    1086:	fe b7       	in	r31, 0x3e	; 62
    1088:	31 82       	std	Z+1, r3	; 0x01
    108a:	73 82       	std	Z+3, r7	; 0x03
    108c:	62 82       	std	Z+2, r6	; 0x02
    108e:	0e 94 93 27 	call	0x4f26	; 0x4f26 <rprintf1RamRom>
		rprintfFloat(5, cmd_angle);
    1092:	0f 90       	pop	r0
    1094:	0f 90       	pop	r0
    1096:	0f 90       	pop	r0
    1098:	40 91 e4 02 	lds	r20, 0x02E4
    109c:	50 91 e5 02 	lds	r21, 0x02E5
    10a0:	60 91 e6 02 	lds	r22, 0x02E6
    10a4:	70 91 e7 02 	lds	r23, 0x02E7
    10a8:	85 e0       	ldi	r24, 0x05	; 5
    10aa:	0e 94 ca 26 	call	0x4d94	; 0x4d94 <rprintfFloat>
		rprintfCRLF();
    10ae:	0e 94 d3 25 	call	0x4ba6	; 0x4ba6 <rprintfCRLF>
		vTaskDelayUntil(&xLastWakeTime, xTicksToWait);
    10b2:	c4 01       	movw	r24, r8
    10b4:	60 e1       	ldi	r22, 0x10	; 16
    10b6:	77 e2       	ldi	r23, 0x27	; 39
    10b8:	0e 94 89 13 	call	0x2712	; 0x2712 <vTaskDelayUntil>
    10bc:	b3 cf       	rjmp	.-154    	; 0x1024 <vScript+0x6c>

000010be <vServoOsc>:
	}

}


void vServoOsc(){
    10be:	7f 92       	push	r7
    10c0:	8f 92       	push	r8
    10c2:	9f 92       	push	r9
    10c4:	af 92       	push	r10
    10c6:	bf 92       	push	r11
    10c8:	cf 92       	push	r12
    10ca:	df 92       	push	r13
    10cc:	ef 92       	push	r14
    10ce:	ff 92       	push	r15
    10d0:	0f 93       	push	r16
    10d2:	1f 93       	push	r17
    10d4:	df 93       	push	r29
    10d6:	cf 93       	push	r28
    10d8:	00 d0       	rcall	.+0      	; 0x10da <vServoOsc+0x1c>
    10da:	cd b7       	in	r28, 0x3d	; 61
    10dc:	de b7       	in	r29, 0x3e	; 62
	sbi(TCCR4A,COM4A1);
	cbi(TCCR4A,COM4A0);
}
void PWM_timer4_On_H4(void)
{
	sbi(TCCR4A,COM4B1);
    10de:	80 91 a0 00 	lds	r24, 0x00A0
    10e2:	80 62       	ori	r24, 0x20	; 32
    10e4:	80 93 a0 00 	sts	0x00A0, r24
	cbi(TCCR4A,COM4B0);
    10e8:	80 91 a0 00 	lds	r24, 0x00A0
    10ec:	8f 7e       	andi	r24, 0xEF	; 239
    10ee:	80 93 a0 00 	sts	0x00A0, r24
	sbi(TCCR3A,COM3C1);
	cbi(TCCR3A,COM3C0);
}
void PWM_timer4_On_H3(void)
{
	sbi(TCCR4A,COM4A1);
    10f2:	80 91 a0 00 	lds	r24, 0x00A0
    10f6:	80 68       	ori	r24, 0x80	; 128
    10f8:	80 93 a0 00 	sts	0x00A0, r24
	cbi(TCCR4A,COM4A0);
    10fc:	80 91 a0 00 	lds	r24, 0x00A0
    1100:	8f 7b       	andi	r24, 0xBF	; 191
    1102:	80 93 a0 00 	sts	0x00A0, r24
    1106:	0a e7       	ldi	r16, 0x7A	; 122
    1108:	10 e0       	ldi	r17, 0x00	; 0
void PWM_timer3_Set_E5(u16 pwmDuty)
	{OCR3C = pwmDuty;}
void PWM_timer4_Set_H3(u16 pwmDuty)
	{OCR4A = pwmDuty;}
void PWM_timer4_Set_H4(u16 pwmDuty)
	{OCR4B = pwmDuty;}
    110a:	2c ec       	ldi	r18, 0xCC	; 204
    110c:	82 2e       	mov	r8, r18
    110e:	91 2c       	mov	r9, r1
		taskENTER_CRITICAL();
	//	PWM_timer3_Set_E3(i);	//right
		PWM_timer4_Set_H3(h3duty);	//left sprayer //originally 204
		PWM_timer4_Set_H4(204);	//right sprayer
		taskEXIT_CRITICAL();
		vTaskDelayUntil(&xLastWakeTime, (spray_time / portTICK_RATE_MS));
    1110:	5e 01       	movw	r10, r28
    1112:	08 94       	sec
    1114:	a1 1c       	adc	r10, r1
    1116:	b1 1c       	adc	r11, r1
		PWM_timer4_Set_H4(135);	
		taskEXIT_CRITICAL();
		vTaskDelayUntil(&xLastWakeTime, (spray_time / portTICK_RATE_MS));
		*/

		rprintf("%d", h3duty);
    1118:	77 24       	eor	r7, r7
    111a:	73 94       	inc	r7
    111c:	92 e3       	ldi	r25, 0x32	; 50
    111e:	c9 2e       	mov	r12, r25
    1120:	91 e0       	ldi	r25, 0x01	; 1
    1122:	d9 2e       	mov	r13, r25
		//rprintf(",");
		//rprintfNum(10, 5, 1, ' ', LEFTVel_current);
		rprintf("\n");
    1124:	80 e3       	ldi	r24, 0x30	; 48
    1126:	e8 2e       	mov	r14, r24
    1128:	81 e0       	ldi	r24, 0x01	; 1
    112a:	f8 2e       	mov	r15, r24
	spray_R_on();
	spray_L_on();
	uint16_t h3duty = 122;

	for(;;){
		if(h3duty > 1023){ h3duty = 0;}
    112c:	84 e0       	ldi	r24, 0x04	; 4
    112e:	00 30       	cpi	r16, 0x00	; 0
    1130:	18 07       	cpc	r17, r24
    1132:	10 f0       	brcs	.+4      	; 0x1138 <vServoOsc+0x7a>
    1134:	00 e0       	ldi	r16, 0x00	; 0
    1136:	10 e0       	ldi	r17, 0x00	; 0
		taskENTER_CRITICAL();
    1138:	0f b6       	in	r0, 0x3f	; 63
    113a:	f8 94       	cli
    113c:	0f 92       	push	r0
void PWM_timer3_Set_E4(u16 pwmDuty)
	{OCR3B = pwmDuty;}
void PWM_timer3_Set_E5(u16 pwmDuty)
	{OCR3C = pwmDuty;}
void PWM_timer4_Set_H3(u16 pwmDuty)
	{OCR4A = pwmDuty;}
    113e:	10 93 a9 00 	sts	0x00A9, r17
    1142:	00 93 a8 00 	sts	0x00A8, r16
void PWM_timer4_Set_H4(u16 pwmDuty)
	{OCR4B = pwmDuty;}
    1146:	90 92 ab 00 	sts	0x00AB, r9
    114a:	80 92 aa 00 	sts	0x00AA, r8
	//	PWM_timer3_Set_E3(i);	//right
		PWM_timer4_Set_H3(h3duty);	//left sprayer //originally 204
		PWM_timer4_Set_H4(204);	//right sprayer
		taskEXIT_CRITICAL();
    114e:	0f 90       	pop	r0
    1150:	0f be       	out	0x3f, r0	; 63
		vTaskDelayUntil(&xLastWakeTime, (spray_time / portTICK_RATE_MS));
    1152:	60 91 b7 02 	lds	r22, 0x02B7
    1156:	70 91 b8 02 	lds	r23, 0x02B8
    115a:	c5 01       	movw	r24, r10
    115c:	0e 94 89 13 	call	0x2712	; 0x2712 <vTaskDelayUntil>
		adj = uart1GetByte();
    1160:	0e 94 40 23 	call	0x4680	; 0x4680 <uart1GetByte>
		if(adj == 'p'){ h3duty++;;}
    1164:	80 37       	cpi	r24, 0x70	; 112
    1166:	19 f4       	brne	.+6      	; 0x116e <vServoOsc+0xb0>
    1168:	0f 5f       	subi	r16, 0xFF	; 255
    116a:	1f 4f       	sbci	r17, 0xFF	; 255
    116c:	04 c0       	rjmp	.+8      	; 0x1176 <vServoOsc+0xb8>
		else if(adj == 'l'){ h3duty--;}
    116e:	8c 36       	cpi	r24, 0x6C	; 108
    1170:	11 f4       	brne	.+4      	; 0x1176 <vServoOsc+0xb8>
    1172:	01 50       	subi	r16, 0x01	; 1
    1174:	10 40       	sbci	r17, 0x00	; 0
		PWM_timer4_Set_H4(135);	
		taskEXIT_CRITICAL();
		vTaskDelayUntil(&xLastWakeTime, (spray_time / portTICK_RATE_MS));
		*/

		rprintf("%d", h3duty);
    1176:	00 d0       	rcall	.+0      	; 0x1178 <vServoOsc+0xba>
    1178:	00 d0       	rcall	.+0      	; 0x117a <vServoOsc+0xbc>
    117a:	0f 92       	push	r0
    117c:	ed b7       	in	r30, 0x3d	; 61
    117e:	fe b7       	in	r31, 0x3e	; 62
    1180:	31 96       	adiw	r30, 0x01	; 1
    1182:	ad b7       	in	r26, 0x3d	; 61
    1184:	be b7       	in	r27, 0x3e	; 62
    1186:	11 96       	adiw	r26, 0x01	; 1
    1188:	7c 92       	st	X, r7
    118a:	d2 82       	std	Z+2, r13	; 0x02
    118c:	c1 82       	std	Z+1, r12	; 0x01
    118e:	14 83       	std	Z+4, r17	; 0x04
    1190:	03 83       	std	Z+3, r16	; 0x03
    1192:	0e 94 93 27 	call	0x4f26	; 0x4f26 <rprintf1RamRom>
		//rprintf(",");
		//rprintfNum(10, 5, 1, ' ', LEFTVel_current);
		rprintf("\n");
    1196:	0f 90       	pop	r0
    1198:	0f 90       	pop	r0
    119a:	ed b7       	in	r30, 0x3d	; 61
    119c:	fe b7       	in	r31, 0x3e	; 62
    119e:	71 82       	std	Z+1, r7	; 0x01
    11a0:	f3 82       	std	Z+3, r15	; 0x03
    11a2:	e2 82       	std	Z+2, r14	; 0x02
    11a4:	0e 94 93 27 	call	0x4f26	; 0x4f26 <rprintf1RamRom>
	
		h3duty++;
    11a8:	0f 5f       	subi	r16, 0xFF	; 255
    11aa:	1f 4f       	sbci	r17, 0xFF	; 255
    11ac:	0f 90       	pop	r0
    11ae:	0f 90       	pop	r0
    11b0:	0f 90       	pop	r0
    11b2:	bc cf       	rjmp	.-136    	; 0x112c <vServoOsc+0x6e>

000011b4 <vLight1On>:
		PORT_OFF(PORTA, 0);
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
		
	}
}
void vLight1On(void *pvParameters){
    11b4:	0f 93       	push	r16
    11b6:	1f 93       	push	r17
    11b8:	df 93       	push	r29
    11ba:	cf 93       	push	r28
    11bc:	00 d0       	rcall	.+0      	; 0x11be <vLight1On+0xa>
    11be:	cd b7       	in	r28, 0x3d	; 61
    11c0:	de b7       	in	r29, 0x3e	; 62
	portTickType xLastWakeTime;
	for(;;){
		LED_on();
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
    11c2:	8e 01       	movw	r16, r28
    11c4:	0f 5f       	subi	r16, 0xFF	; 255
    11c6:	1f 4f       	sbci	r17, 0xFF	; 255
//***************STATUS LED**************
//tank test
void LED_off(void)
	{PORT_ON(PORTB,6);}
void LED_on(void)
	{PORT_OFF(PORTB,6);}
    11c8:	2e 98       	cbi	0x05, 6	; 5
    11ca:	c8 01       	movw	r24, r16
    11cc:	62 e3       	ldi	r22, 0x32	; 50
    11ce:	70 e0       	ldi	r23, 0x00	; 0
    11d0:	0e 94 89 13 	call	0x2712	; 0x2712 <vTaskDelayUntil>


//***************STATUS LED**************
//tank test
void LED_off(void)
	{PORT_ON(PORTB,6);}
    11d4:	2e 9a       	sbi	0x05, 6	; 5
		LED_off();
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));	}
    11d6:	c8 01       	movw	r24, r16
    11d8:	62 e3       	ldi	r22, 0x32	; 50
    11da:	70 e0       	ldi	r23, 0x00	; 0
    11dc:	0e 94 89 13 	call	0x2712	; 0x2712 <vTaskDelayUntil>
    11e0:	f3 cf       	rjmp	.-26     	; 0x11c8 <vLight1On+0x14>

000011e2 <vLight0On>:
		vTaskDelayUntil(&xLastWakeTime, (100 / portTICK_RATE_MS));
	}

}

void vLight0On(void *pvParameters){
    11e2:	0f 93       	push	r16
    11e4:	1f 93       	push	r17
    11e6:	df 93       	push	r29
    11e8:	cf 93       	push	r28
    11ea:	00 d0       	rcall	.+0      	; 0x11ec <vLight0On+0xa>
    11ec:	cd b7       	in	r28, 0x3d	; 61
    11ee:	de b7       	in	r29, 0x3e	; 62
	portTickType xLastWakeTime;
	for(;;){
		PORT_ON(PORTA, 0);
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
    11f0:	8e 01       	movw	r16, r28
    11f2:	0f 5f       	subi	r16, 0xFF	; 255
    11f4:	1f 4f       	sbci	r17, 0xFF	; 255
}

void vLight0On(void *pvParameters){
	portTickType xLastWakeTime;
	for(;;){
		PORT_ON(PORTA, 0);
    11f6:	10 9a       	sbi	0x02, 0	; 2
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
    11f8:	c8 01       	movw	r24, r16
    11fa:	62 e3       	ldi	r22, 0x32	; 50
    11fc:	70 e0       	ldi	r23, 0x00	; 0
    11fe:	0e 94 89 13 	call	0x2712	; 0x2712 <vTaskDelayUntil>
		//taskYIELD();	
		PORT_OFF(PORTA, 0);
    1202:	10 98       	cbi	0x02, 0	; 2
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
    1204:	c8 01       	movw	r24, r16
    1206:	62 e3       	ldi	r22, 0x32	; 50
    1208:	70 e0       	ldi	r23, 0x00	; 0
    120a:	0e 94 89 13 	call	0x2712	; 0x2712 <vTaskDelayUntil>
    120e:	f3 cf       	rjmp	.-26     	; 0x11f6 <vLight0On+0x14>

00001210 <vEnc_UpdatePose>:
	uart3SendByte('\n'); //line feed
}



void vEnc_UpdatePose(){
    1210:	af 92       	push	r10
    1212:	bf 92       	push	r11
    1214:	df 92       	push	r13
    1216:	ef 92       	push	r14
    1218:	ff 92       	push	r15
    121a:	0f 93       	push	r16
    121c:	1f 93       	push	r17
    121e:	df 93       	push	r29
    1220:	cf 93       	push	r28
    1222:	00 d0       	rcall	.+0      	; 0x1224 <vEnc_UpdatePose+0x14>
    1224:	cd b7       	in	r28, 0x3d	; 61
    1226:	de b7       	in	r29, 0x3e	; 62
	portTickType xLastWakeTime;
	float elapsed_time;
	reset_timer0();
    1228:	0e 94 c7 19 	call	0x338e	; 0x338e <reset_timer0>
		taskEXIT_CRITICAL();
		*/

		}
		
	vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
    122c:	5e 01       	movw	r10, r28
    122e:	08 94       	sec
    1230:	a1 1c       	adc	r10, r1
    1232:	b1 1c       	adc	r11, r1
	portTickType xLastWakeTime;
	float elapsed_time;
	reset_timer0();

	for(;;){
		if(LEFTVel_ready || RIGHTVel_ready){
    1234:	80 91 c0 02 	lds	r24, 0x02C0
    1238:	88 23       	and	r24, r24
    123a:	29 f4       	brne	.+10     	; 0x1246 <vEnc_UpdatePose+0x36>
    123c:	80 91 cd 02 	lds	r24, 0x02CD
    1240:	88 23       	and	r24, r24
    1242:	09 f4       	brne	.+2      	; 0x1246 <vEnc_UpdatePose+0x36>
    1244:	a4 c0       	rjmp	.+328    	; 0x138e <vEnc_UpdatePose+0x17e>
		//The below formula yields the encoder calculated angular velocity of the robot
		//as it rotates about some ICC(Instantaneous Center of Curvature)
		
		enc_ang_vel = ((-RIGHTVel_current) - LEFTVel_current) / ROBOT_DIAMETER;
    1246:	60 91 cb 02 	lds	r22, 0x02CB
    124a:	70 91 cc 02 	lds	r23, 0x02CC
    124e:	70 95       	com	r23
    1250:	61 95       	neg	r22
    1252:	7f 4f       	sbci	r23, 0xFF	; 255
    1254:	20 91 be 02 	lds	r18, 0x02BE
    1258:	30 91 bf 02 	lds	r19, 0x02BF
    125c:	62 1b       	sub	r22, r18
    125e:	73 0b       	sbc	r23, r19
    1260:	88 27       	eor	r24, r24
    1262:	77 fd       	sbrc	r23, 7
    1264:	80 95       	com	r24
    1266:	98 2f       	mov	r25, r24
    1268:	0e 94 32 2c 	call	0x5864	; 0x5864 <__floatsisf>
    126c:	26 e6       	ldi	r18, 0x66	; 102
    126e:	36 e6       	ldi	r19, 0x66	; 102
    1270:	46 e8       	ldi	r20, 0x86	; 134
    1272:	51 e4       	ldi	r21, 0x41	; 65
    1274:	0e 94 97 2b 	call	0x572e	; 0x572e <__divsf3>
    1278:	60 93 dc 02 	sts	0x02DC, r22
    127c:	70 93 dd 02 	sts	0x02DD, r23
    1280:	80 93 de 02 	sts	0x02DE, r24
    1284:	90 93 df 02 	sts	0x02DF, r25
		
		//elapsed_time = ((get_timer0_overflow()*255 + TCNT0) * 0.256) / 1000;
		elapsed_time = ((get_timer0_overflow()*255 + TCNT0) * 0.0633) / 1000;
    1288:	0e 94 68 19 	call	0x32d0	; 0x32d0 <get_timer0_overflow>
    128c:	7b 01       	movw	r14, r22
    128e:	8c 01       	movw	r16, r24
    1290:	d6 b4       	in	r13, 0x26	; 38
		reset_timer0();
    1292:	0e 94 c7 19 	call	0x338e	; 0x338e <reset_timer0>
		//dRL = dRIGHTDis - dLEFTDis;
		//dis_enc_heading += sin((dRL)/ ROBOT_DIAMETER);
		//dRIGHTDis = dLEFTDis = 0;
		enc_heading += enc_ang_vel * elapsed_time;
    1296:	c8 01       	movw	r24, r16
    1298:	b7 01       	movw	r22, r14
    129a:	2f ef       	ldi	r18, 0xFF	; 255
    129c:	30 e0       	ldi	r19, 0x00	; 0
    129e:	40 e0       	ldi	r20, 0x00	; 0
    12a0:	50 e0       	ldi	r21, 0x00	; 0
    12a2:	0e 94 cd 2d 	call	0x5b9a	; 0x5b9a <__mulsi3>
    12a6:	6d 0d       	add	r22, r13
    12a8:	71 1d       	adc	r23, r1
    12aa:	81 1d       	adc	r24, r1
    12ac:	91 1d       	adc	r25, r1
    12ae:	0e 94 30 2c 	call	0x5860	; 0x5860 <__floatunsisf>
    12b2:	2e e6       	ldi	r18, 0x6E	; 110
    12b4:	33 ea       	ldi	r19, 0xA3	; 163
    12b6:	41 e8       	ldi	r20, 0x81	; 129
    12b8:	5d e3       	ldi	r21, 0x3D	; 61
    12ba:	0e 94 67 2d 	call	0x5ace	; 0x5ace <__mulsf3>
    12be:	20 e0       	ldi	r18, 0x00	; 0
    12c0:	30 e0       	ldi	r19, 0x00	; 0
    12c2:	4a e7       	ldi	r20, 0x7A	; 122
    12c4:	54 e4       	ldi	r21, 0x44	; 68
    12c6:	0e 94 97 2b 	call	0x572e	; 0x572e <__divsf3>
    12ca:	20 91 dc 02 	lds	r18, 0x02DC
    12ce:	30 91 dd 02 	lds	r19, 0x02DD
    12d2:	40 91 de 02 	lds	r20, 0x02DE
    12d6:	50 91 df 02 	lds	r21, 0x02DF
    12da:	0e 94 67 2d 	call	0x5ace	; 0x5ace <__mulsf3>
    12de:	20 91 d8 02 	lds	r18, 0x02D8
    12e2:	30 91 d9 02 	lds	r19, 0x02D9
    12e6:	40 91 da 02 	lds	r20, 0x02DA
    12ea:	50 91 db 02 	lds	r21, 0x02DB
    12ee:	0e 94 cd 2a 	call	0x559a	; 0x559a <__addsf3>
    12f2:	7b 01       	movw	r14, r22
    12f4:	8c 01       	movw	r16, r24
		// Limit the heading to 2pi
		enc_heading -= 2*M_PI*(1 + floor((enc_heading-M_PI)/(2*M_PI)));
    12f6:	2b ed       	ldi	r18, 0xDB	; 219
    12f8:	3f e0       	ldi	r19, 0x0F	; 15
    12fa:	49 e4       	ldi	r20, 0x49	; 73
    12fc:	50 e4       	ldi	r21, 0x40	; 64
    12fe:	0e 94 cc 2a 	call	0x5598	; 0x5598 <__subsf3>
    1302:	2b ed       	ldi	r18, 0xDB	; 219
    1304:	3f e0       	ldi	r19, 0x0F	; 15
    1306:	49 ec       	ldi	r20, 0xC9	; 201
    1308:	50 e4       	ldi	r21, 0x40	; 64
    130a:	0e 94 97 2b 	call	0x572e	; 0x572e <__divsf3>
    130e:	0e 94 6d 2c 	call	0x58da	; 0x58da <floor>
    1312:	20 e0       	ldi	r18, 0x00	; 0
    1314:	30 e0       	ldi	r19, 0x00	; 0
    1316:	40 e8       	ldi	r20, 0x80	; 128
    1318:	5f e3       	ldi	r21, 0x3F	; 63
    131a:	0e 94 cd 2a 	call	0x559a	; 0x559a <__addsf3>
    131e:	2b ed       	ldi	r18, 0xDB	; 219
    1320:	3f e0       	ldi	r19, 0x0F	; 15
    1322:	49 ec       	ldi	r20, 0xC9	; 201
    1324:	50 ec       	ldi	r21, 0xC0	; 192
    1326:	0e 94 67 2d 	call	0x5ace	; 0x5ace <__mulsf3>
    132a:	9b 01       	movw	r18, r22
    132c:	ac 01       	movw	r20, r24
    132e:	c8 01       	movw	r24, r16
    1330:	b7 01       	movw	r22, r14
    1332:	0e 94 cd 2a 	call	0x559a	; 0x559a <__addsf3>
    1336:	60 93 d8 02 	sts	0x02D8, r22
    133a:	70 93 d9 02 	sts	0x02D9, r23
    133e:	80 93 da 02 	sts	0x02DA, r24
    1342:	90 93 db 02 	sts	0x02DB, r25
		//cmd_ang_vel = 3*pow(cmd_angle - enc_heading,2)/(pow(cmd_angle - enc_heading,2) + pow(3,2));
		cmd_ang_vel = -0.5*atan2(1*(enc_heading - cmd_angle) +0,1);
    1346:	20 91 e4 02 	lds	r18, 0x02E4
    134a:	30 91 e5 02 	lds	r19, 0x02E5
    134e:	40 91 e6 02 	lds	r20, 0x02E6
    1352:	50 91 e7 02 	lds	r21, 0x02E7
    1356:	0e 94 cc 2a 	call	0x5598	; 0x5598 <__subsf3>
    135a:	20 e0       	ldi	r18, 0x00	; 0
    135c:	30 e0       	ldi	r19, 0x00	; 0
    135e:	40 e0       	ldi	r20, 0x00	; 0
    1360:	50 e0       	ldi	r21, 0x00	; 0
    1362:	0e 94 cd 2a 	call	0x559a	; 0x559a <__addsf3>
    1366:	20 e0       	ldi	r18, 0x00	; 0
    1368:	30 e0       	ldi	r19, 0x00	; 0
    136a:	40 e8       	ldi	r20, 0x80	; 128
    136c:	5f e3       	ldi	r21, 0x3F	; 63
    136e:	0e 94 40 2b 	call	0x5680	; 0x5680 <atan2>
    1372:	20 e0       	ldi	r18, 0x00	; 0
    1374:	30 e0       	ldi	r19, 0x00	; 0
    1376:	40 e0       	ldi	r20, 0x00	; 0
    1378:	5f eb       	ldi	r21, 0xBF	; 191
    137a:	0e 94 67 2d 	call	0x5ace	; 0x5ace <__mulsf3>
    137e:	60 93 e8 02 	sts	0x02E8, r22
    1382:	70 93 e9 02 	sts	0x02E9, r23
    1386:	80 93 ea 02 	sts	0x02EA, r24
    138a:	90 93 eb 02 	sts	0x02EB, r25
		taskEXIT_CRITICAL();
		*/

		}
		
	vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
    138e:	c5 01       	movw	r24, r10
    1390:	62 e3       	ldi	r22, 0x32	; 50
    1392:	70 e0       	ldi	r23, 0x00	; 0
    1394:	0e 94 89 13 	call	0x2712	; 0x2712 <vTaskDelayUntil>
    1398:	4d cf       	rjmp	.-358    	; 0x1234 <vEnc_UpdatePose+0x24>

0000139a <send_frame>:
	}
	return c;
}


void send_frame(char flag, int16_t data){
    139a:	ff 92       	push	r15
    139c:	0f 93       	push	r16
    139e:	1f 93       	push	r17
    13a0:	cf 93       	push	r28
    13a2:	df 93       	push	r29
    13a4:	eb 01       	movw	r28, r22
	uint8_t r1 = 0;
	uint8_t r2 = 0;
	uint8_t r3 = 0;
	uint8_t r4 = 0;

	uart3SendByte(flag);
    13a6:	0e 94 88 20 	call	0x4110	; 0x4110 <uart3SendByte>

	r1 = num2char(0x0F & (uint8_t)data);
    13aa:	6f e0       	ldi	r22, 0x0F	; 15
    13ac:	f6 2e       	mov	r15, r22
    13ae:	fc 22       	and	r15, r28



char num2char(char c){
	
	if(c <10){
    13b0:	89 e0       	ldi	r24, 0x09	; 9
    13b2:	8f 15       	cp	r24, r15
    13b4:	18 f0       	brcs	.+6      	; 0x13bc <send_frame+0x22>
		c += 48;
    13b6:	90 e3       	ldi	r25, 0x30	; 48
    13b8:	f9 0e       	add	r15, r25
    13ba:	06 c0       	rjmp	.+12     	; 0x13c8 <send_frame+0x2e>
	}
	else if((c >= 10) && (c <= 16)){
    13bc:	8f 2d       	mov	r24, r15
    13be:	8a 50       	subi	r24, 0x0A	; 10
    13c0:	87 30       	cpi	r24, 0x07	; 7
    13c2:	10 f4       	brcc	.+4      	; 0x13c8 <send_frame+0x2e>
		c += 55;
    13c4:	87 e3       	ldi	r24, 0x37	; 55
    13c6:	f8 0e       	add	r15, r24
	uint8_t r4 = 0;

	uart3SendByte(flag);

	r1 = num2char(0x0F & (uint8_t)data);
	r2 = num2char(0x0F & ((uint8_t)(data >> 4)) );
    13c8:	ce 01       	movw	r24, r28
    13ca:	54 e0       	ldi	r21, 0x04	; 4
    13cc:	95 95       	asr	r25
    13ce:	87 95       	ror	r24
    13d0:	5a 95       	dec	r21
    13d2:	e1 f7       	brne	.-8      	; 0x13cc <send_frame+0x32>
    13d4:	08 2f       	mov	r16, r24
    13d6:	0f 70       	andi	r16, 0x0F	; 15



char num2char(char c){
	
	if(c <10){
    13d8:	0a 30       	cpi	r16, 0x0A	; 10
    13da:	10 f4       	brcc	.+4      	; 0x13e0 <send_frame+0x46>
		c += 48;
    13dc:	00 5d       	subi	r16, 0xD0	; 208
    13de:	05 c0       	rjmp	.+10     	; 0x13ea <send_frame+0x50>
	}
	else if((c >= 10) && (c <= 16)){
    13e0:	80 2f       	mov	r24, r16
    13e2:	8a 50       	subi	r24, 0x0A	; 10
    13e4:	87 30       	cpi	r24, 0x07	; 7
    13e6:	08 f4       	brcc	.+2      	; 0x13ea <send_frame+0x50>
		c += 55;
    13e8:	09 5c       	subi	r16, 0xC9	; 201

	uart3SendByte(flag);

	r1 = num2char(0x0F & (uint8_t)data);
	r2 = num2char(0x0F & ((uint8_t)(data >> 4)) );
	r3 = num2char(0x0F & ((uint8_t)(data >> 8)) );
    13ea:	8d 2f       	mov	r24, r29
    13ec:	99 27       	eor	r25, r25
    13ee:	87 fd       	sbrc	r24, 7
    13f0:	9a 95       	dec	r25
    13f2:	18 2f       	mov	r17, r24
    13f4:	1f 70       	andi	r17, 0x0F	; 15



char num2char(char c){
	
	if(c <10){
    13f6:	1a 30       	cpi	r17, 0x0A	; 10
    13f8:	10 f4       	brcc	.+4      	; 0x13fe <send_frame+0x64>
		c += 48;
    13fa:	10 5d       	subi	r17, 0xD0	; 208
    13fc:	05 c0       	rjmp	.+10     	; 0x1408 <send_frame+0x6e>
	}
	else if((c >= 10) && (c <= 16)){
    13fe:	81 2f       	mov	r24, r17
    1400:	8a 50       	subi	r24, 0x0A	; 10
    1402:	87 30       	cpi	r24, 0x07	; 7
    1404:	08 f4       	brcc	.+2      	; 0x1408 <send_frame+0x6e>
		c += 55;
    1406:	19 5c       	subi	r17, 0xC9	; 201
	uart3SendByte(flag);

	r1 = num2char(0x0F & (uint8_t)data);
	r2 = num2char(0x0F & ((uint8_t)(data >> 4)) );
	r3 = num2char(0x0F & ((uint8_t)(data >> 8)) );
	r4 = num2char(0x0F & ((uint8_t)(data >> 12)) );
    1408:	c0 e1       	ldi	r28, 0x10	; 16
    140a:	dc 02       	muls	r29, r28
    140c:	c1 2d       	mov	r28, r1
    140e:	dd 0b       	sbc	r29, r29
    1410:	11 24       	eor	r1, r1
    1412:	ce 01       	movw	r24, r28
    1414:	8f 70       	andi	r24, 0x0F	; 15
    1416:	68 2f       	mov	r22, r24



char num2char(char c){
	
	if(c <10){
    1418:	8a 30       	cpi	r24, 0x0A	; 10
    141a:	10 f4       	brcc	.+4      	; 0x1420 <send_frame+0x86>
		c += 48;
    141c:	60 5d       	subi	r22, 0xD0	; 208
    141e:	04 c0       	rjmp	.+8      	; 0x1428 <send_frame+0x8e>
	}
	else if((c >= 10) && (c <= 16)){
    1420:	8a 50       	subi	r24, 0x0A	; 10
    1422:	87 30       	cpi	r24, 0x07	; 7
    1424:	08 f4       	brcc	.+2      	; 0x1428 <send_frame+0x8e>
		c += 55;
    1426:	69 5c       	subi	r22, 0xC9	; 201
	r1 = num2char(0x0F & (uint8_t)data);
	r2 = num2char(0x0F & ((uint8_t)(data >> 4)) );
	r3 = num2char(0x0F & ((uint8_t)(data >> 8)) );
	r4 = num2char(0x0F & ((uint8_t)(data >> 12)) );

	uart3SendByte(r4);
    1428:	86 2f       	mov	r24, r22
    142a:	0e 94 88 20 	call	0x4110	; 0x4110 <uart3SendByte>
	uart3SendByte(r3);
    142e:	81 2f       	mov	r24, r17
    1430:	0e 94 88 20 	call	0x4110	; 0x4110 <uart3SendByte>
	uart3SendByte(r2);
    1434:	80 2f       	mov	r24, r16
    1436:	0e 94 88 20 	call	0x4110	; 0x4110 <uart3SendByte>
	uart3SendByte(r1);
    143a:	8f 2d       	mov	r24, r15
    143c:	0e 94 88 20 	call	0x4110	; 0x4110 <uart3SendByte>
	uart3SendByte('\n'); //line feed
    1440:	8a e0       	ldi	r24, 0x0A	; 10
    1442:	0e 94 88 20 	call	0x4110	; 0x4110 <uart3SendByte>
}
    1446:	df 91       	pop	r29
    1448:	cf 91       	pop	r28
    144a:	1f 91       	pop	r17
    144c:	0f 91       	pop	r16
    144e:	ff 90       	pop	r15
    1450:	08 95       	ret

00001452 <vPID>:


}


void vPID(void* pvParameters){
    1452:	2f 92       	push	r2
    1454:	3f 92       	push	r3
    1456:	4f 92       	push	r4
    1458:	5f 92       	push	r5
    145a:	6f 92       	push	r6
    145c:	7f 92       	push	r7
    145e:	8f 92       	push	r8
    1460:	9f 92       	push	r9
    1462:	af 92       	push	r10
    1464:	bf 92       	push	r11
    1466:	cf 92       	push	r12
    1468:	df 92       	push	r13
    146a:	ef 92       	push	r14
    146c:	ff 92       	push	r15
    146e:	0f 93       	push	r16
    1470:	1f 93       	push	r17
    1472:	df 93       	push	r29
    1474:	cf 93       	push	r28
    1476:	cd b7       	in	r28, 0x3d	; 61
    1478:	de b7       	in	r29, 0x3e	; 62
    147a:	62 97       	sbiw	r28, 0x12	; 18
    147c:	0f b6       	in	r0, 0x3f	; 63
    147e:	f8 94       	cli
    1480:	de bf       	out	0x3e, r29	; 62
    1482:	0f be       	out	0x3f, r0	; 63
    1484:	cd bf       	out	0x3d, r28	; 61
	sbi(TCCR3A,COM3A1);
	cbi(TCCR3A,COM3A0);
}
void PWM_timer3_On_E4(void)
{
	sbi(TCCR3A,COM3B1);
    1486:	80 91 90 00 	lds	r24, 0x0090
    148a:	80 62       	ori	r24, 0x20	; 32
    148c:	80 93 90 00 	sts	0x0090, r24
	cbi(TCCR3A,COM3B0);
    1490:	80 91 90 00 	lds	r24, 0x0090
    1494:	8f 7e       	andi	r24, 0xEF	; 239
    1496:	80 93 90 00 	sts	0x0090, r24
	sbi(TCCR2A,COM2B1);
	cbi(TCCR2A,COM2B0);
}
void PWM_timer3_On_E3(void)
{
	sbi(TCCR3A,COM3A1);
    149a:	80 91 90 00 	lds	r24, 0x0090
    149e:	80 68       	ori	r24, 0x80	; 128
    14a0:	80 93 90 00 	sts	0x0090, r24
	cbi(TCCR3A,COM3A0);
    14a4:	80 91 90 00 	lds	r24, 0x0090
    14a8:	8f 7b       	andi	r24, 0xBF	; 191
    14aa:	80 93 90 00 	sts	0x0090, r24
	float dt = 0;
	
	wheel_L_on();
	wheel_R_on();

	reset_timer2();
    14ae:	0e 94 de 19 	call	0x33bc	; 0x33bc <reset_timer2>
    14b2:	80 e0       	ldi	r24, 0x00	; 0
    14b4:	90 e0       	ldi	r25, 0x00	; 0
    14b6:	a0 e0       	ldi	r26, 0x00	; 0
    14b8:	b0 e0       	ldi	r27, 0x00	; 0
    14ba:	8f 87       	std	Y+15, r24	; 0x0f
    14bc:	98 8b       	std	Y+16, r25	; 0x10
    14be:	a9 8b       	std	Y+17, r26	; 0x11
    14c0:	ba 8b       	std	Y+18, r27	; 0x12
    14c2:	8f 83       	std	Y+7, r24	; 0x07
    14c4:	98 87       	std	Y+8, r25	; 0x08
    14c6:	a9 87       	std	Y+9, r26	; 0x09
    14c8:	ba 87       	std	Y+10, r27	; 0x0a
			v_left = (signed int)(v_command - cmd_ang_vel*ROBOT_RADIUS);
			v_right = (signed int)(v_command + cmd_ang_vel*ROBOT_RADIUS);
		}
	*/
	
		v_left = (v_command - cmd_ang_vel*ROBOT_RADIUS);
    14ca:	a0 90 e0 02 	lds	r10, 0x02E0
    14ce:	b0 90 e1 02 	lds	r11, 0x02E1
    14d2:	c0 90 e2 02 	lds	r12, 0x02E2
    14d6:	d0 90 e3 02 	lds	r13, 0x02E3
    14da:	e0 90 e8 02 	lds	r14, 0x02E8
    14de:	f0 90 e9 02 	lds	r15, 0x02E9
    14e2:	00 91 ea 02 	lds	r16, 0x02EA
    14e6:	10 91 eb 02 	lds	r17, 0x02EB
    14ea:	c8 01       	movw	r24, r16
    14ec:	b7 01       	movw	r22, r14
    14ee:	23 e3       	ldi	r18, 0x33	; 51
    14f0:	33 e3       	ldi	r19, 0x33	; 51
    14f2:	43 e0       	ldi	r20, 0x03	; 3
    14f4:	51 ec       	ldi	r21, 0xC1	; 193
    14f6:	0e 94 67 2d 	call	0x5ace	; 0x5ace <__mulsf3>
    14fa:	9b 01       	movw	r18, r22
    14fc:	ac 01       	movw	r20, r24
    14fe:	c6 01       	movw	r24, r12
    1500:	b5 01       	movw	r22, r10
    1502:	0e 94 cd 2a 	call	0x559a	; 0x559a <__addsf3>
    1506:	1b 01       	movw	r2, r22
    1508:	2c 01       	movw	r4, r24
		v_right = (v_command + cmd_ang_vel*ROBOT_RADIUS);
    150a:	c8 01       	movw	r24, r16
    150c:	b7 01       	movw	r22, r14
    150e:	23 e3       	ldi	r18, 0x33	; 51
    1510:	33 e3       	ldi	r19, 0x33	; 51
    1512:	43 e0       	ldi	r20, 0x03	; 3
    1514:	51 e4       	ldi	r21, 0x41	; 65
    1516:	0e 94 67 2d 	call	0x5ace	; 0x5ace <__mulsf3>
    151a:	9b 01       	movw	r18, r22
    151c:	ac 01       	movw	r20, r24
    151e:	c6 01       	movw	r24, r12
    1520:	b5 01       	movw	r22, r10
    1522:	0e 94 cd 2a 	call	0x559a	; 0x559a <__addsf3>
    1526:	6b 83       	std	Y+3, r22	; 0x03
    1528:	7c 83       	std	Y+4, r23	; 0x04
    152a:	8d 83       	std	Y+5, r24	; 0x05
    152c:	9e 83       	std	Y+6, r25	; 0x06

		dt = ((get_timer2_overflow()*255 + TCNT2) * 0.0633) / 1000;
    152e:	0e 94 7e 19 	call	0x32fc	; 0x32fc <get_timer2_overflow>
    1532:	10 91 b2 00 	lds	r17, 0x00B2
    1536:	2f ef       	ldi	r18, 0xFF	; 255
    1538:	30 e0       	ldi	r19, 0x00	; 0
    153a:	40 e0       	ldi	r20, 0x00	; 0
    153c:	50 e0       	ldi	r21, 0x00	; 0
    153e:	0e 94 cd 2d 	call	0x5b9a	; 0x5b9a <__mulsi3>
    1542:	61 0f       	add	r22, r17
    1544:	71 1d       	adc	r23, r1
    1546:	81 1d       	adc	r24, r1
    1548:	91 1d       	adc	r25, r1
    154a:	0e 94 30 2c 	call	0x5860	; 0x5860 <__floatunsisf>
    154e:	2e e6       	ldi	r18, 0x6E	; 110
    1550:	33 ea       	ldi	r19, 0xA3	; 163
    1552:	41 e8       	ldi	r20, 0x81	; 129
    1554:	5d e3       	ldi	r21, 0x3D	; 61
    1556:	0e 94 67 2d 	call	0x5ace	; 0x5ace <__mulsf3>
    155a:	20 e0       	ldi	r18, 0x00	; 0
    155c:	30 e0       	ldi	r19, 0x00	; 0
    155e:	4a e7       	ldi	r20, 0x7A	; 122
    1560:	54 e4       	ldi	r21, 0x44	; 68
    1562:	0e 94 97 2b 	call	0x572e	; 0x572e <__divsf3>
    1566:	3b 01       	movw	r6, r22
    1568:	4c 01       	movw	r8, r24
		reset_timer2();
    156a:	0e 94 de 19 	call	0x33bc	; 0x33bc <reset_timer2>
	
	// PID

		LEFTVel_ready = RIGHTVel_ready = UNSET;
    156e:	10 92 cd 02 	sts	0x02CD, r1
    1572:	10 92 c0 02 	sts	0x02C0, r1

		error_L = v_left - LEFTVel_current;
    1576:	60 91 be 02 	lds	r22, 0x02BE
    157a:	70 91 bf 02 	lds	r23, 0x02BF
    157e:	88 27       	eor	r24, r24
    1580:	77 fd       	sbrc	r23, 7
    1582:	80 95       	com	r24
    1584:	98 2f       	mov	r25, r24
    1586:	0e 94 32 2c 	call	0x5864	; 0x5864 <__floatsisf>
    158a:	9b 01       	movw	r18, r22
    158c:	ac 01       	movw	r20, r24
    158e:	c2 01       	movw	r24, r4
    1590:	b1 01       	movw	r22, r2
    1592:	0e 94 cc 2a 	call	0x5598	; 0x5598 <__subsf3>
    1596:	5b 01       	movw	r10, r22
    1598:	6c 01       	movw	r12, r24
		error_R = v_right - (-RIGHTVel_current);
    159a:	60 91 cb 02 	lds	r22, 0x02CB
    159e:	70 91 cc 02 	lds	r23, 0x02CC
    15a2:	70 95       	com	r23
    15a4:	61 95       	neg	r22
    15a6:	7f 4f       	sbci	r23, 0xFF	; 255
    15a8:	88 27       	eor	r24, r24
    15aa:	77 fd       	sbrc	r23, 7
    15ac:	80 95       	com	r24
    15ae:	98 2f       	mov	r25, r24
    15b0:	0e 94 32 2c 	call	0x5864	; 0x5864 <__floatsisf>
    15b4:	9b 01       	movw	r18, r22
    15b6:	ac 01       	movw	r20, r24
    15b8:	6b 81       	ldd	r22, Y+3	; 0x03
    15ba:	7c 81       	ldd	r23, Y+4	; 0x04
    15bc:	8d 81       	ldd	r24, Y+5	; 0x05
    15be:	9e 81       	ldd	r25, Y+6	; 0x06
    15c0:	0e 94 cc 2a 	call	0x5598	; 0x5598 <__subsf3>
    15c4:	6b 87       	std	Y+11, r22	; 0x0b
    15c6:	7c 87       	std	Y+12, r23	; 0x0c
    15c8:	8d 87       	std	Y+13, r24	; 0x0d
    15ca:	9e 87       	std	Y+14, r25	; 0x0e
			
		v_out_L = KP_L*error_L + KI_L*acc_error_L + (2/25)*v_left;
    15cc:	c6 01       	movw	r24, r12
    15ce:	b5 01       	movw	r22, r10
    15d0:	22 ef       	ldi	r18, 0xF2	; 242
    15d2:	3c e5       	ldi	r19, 0x5C	; 92
    15d4:	46 e6       	ldi	r20, 0x66	; 102
    15d6:	5d e3       	ldi	r21, 0x3D	; 61
    15d8:	0e 94 67 2d 	call	0x5ace	; 0x5ace <__mulsf3>
    15dc:	7b 01       	movw	r14, r22
    15de:	8c 01       	movw	r16, r24
    15e0:	6f 85       	ldd	r22, Y+15	; 0x0f
    15e2:	78 89       	ldd	r23, Y+16	; 0x10
    15e4:	89 89       	ldd	r24, Y+17	; 0x11
    15e6:	9a 89       	ldd	r25, Y+18	; 0x12
    15e8:	28 eb       	ldi	r18, 0xB8	; 184
    15ea:	32 e4       	ldi	r19, 0x42	; 66
    15ec:	4f e0       	ldi	r20, 0x0F	; 15
    15ee:	5e e3       	ldi	r21, 0x3E	; 62
    15f0:	0e 94 67 2d 	call	0x5ace	; 0x5ace <__mulsf3>
    15f4:	9b 01       	movw	r18, r22
    15f6:	ac 01       	movw	r20, r24
    15f8:	c8 01       	movw	r24, r16
    15fa:	b7 01       	movw	r22, r14
    15fc:	0e 94 cd 2a 	call	0x559a	; 0x559a <__addsf3>
    1600:	7b 01       	movw	r14, r22
    1602:	8c 01       	movw	r16, r24
    1604:	c2 01       	movw	r24, r4
    1606:	b1 01       	movw	r22, r2
    1608:	20 e0       	ldi	r18, 0x00	; 0
    160a:	30 e0       	ldi	r19, 0x00	; 0
    160c:	40 e0       	ldi	r20, 0x00	; 0
    160e:	50 e0       	ldi	r21, 0x00	; 0
    1610:	0e 94 67 2d 	call	0x5ace	; 0x5ace <__mulsf3>
    1614:	9b 01       	movw	r18, r22
    1616:	ac 01       	movw	r20, r24
    1618:	c8 01       	movw	r24, r16
    161a:	b7 01       	movw	r22, r14
    161c:	0e 94 cd 2a 	call	0x559a	; 0x559a <__addsf3>
    1620:	7b 01       	movw	r14, r22
    1622:	8c 01       	movw	r16, r24
		v_out_R = KP_R*error_R + KI_R*acc_error_R + (2/25)*v_right;
		
		acc_error_L += error_L*dt;
    1624:	c6 01       	movw	r24, r12
    1626:	b5 01       	movw	r22, r10
    1628:	a4 01       	movw	r20, r8
    162a:	93 01       	movw	r18, r6
    162c:	0e 94 67 2d 	call	0x5ace	; 0x5ace <__mulsf3>
    1630:	9b 01       	movw	r18, r22
    1632:	ac 01       	movw	r20, r24
    1634:	6f 85       	ldd	r22, Y+15	; 0x0f
    1636:	78 89       	ldd	r23, Y+16	; 0x10
    1638:	89 89       	ldd	r24, Y+17	; 0x11
    163a:	9a 89       	ldd	r25, Y+18	; 0x12
    163c:	0e 94 cd 2a 	call	0x559a	; 0x559a <__addsf3>
    1640:	6f 87       	std	Y+15, r22	; 0x0f
    1642:	78 8b       	std	Y+16, r23	; 0x10
    1644:	89 8b       	std	Y+17, r24	; 0x11
    1646:	9a 8b       	std	Y+18, r25	; 0x12
		acc_error_R += error_R*dt;
    1648:	6b 85       	ldd	r22, Y+11	; 0x0b
    164a:	7c 85       	ldd	r23, Y+12	; 0x0c
    164c:	8d 85       	ldd	r24, Y+13	; 0x0d
    164e:	9e 85       	ldd	r25, Y+14	; 0x0e
    1650:	a4 01       	movw	r20, r8
    1652:	93 01       	movw	r18, r6
    1654:	0e 94 67 2d 	call	0x5ace	; 0x5ace <__mulsf3>
    1658:	9b 01       	movw	r18, r22
    165a:	ac 01       	movw	r20, r24
    165c:	6f 81       	ldd	r22, Y+7	; 0x07
    165e:	78 85       	ldd	r23, Y+8	; 0x08
    1660:	89 85       	ldd	r24, Y+9	; 0x09
    1662:	9a 85       	ldd	r25, Y+10	; 0x0a
    1664:	0e 94 cd 2a 	call	0x559a	; 0x559a <__addsf3>
    1668:	a6 2e       	mov	r10, r22
    166a:	67 2e       	mov	r6, r23
    166c:	28 2e       	mov	r2, r24
    166e:	d9 2e       	mov	r13, r25
			rprintfFloat(8,dt);
			rprintfCRLF();
			taskEXIT_CRITICAL();
*/
			
		taskENTER_CRITICAL();
    1670:	0f b6       	in	r0, 0x3f	; 63
    1672:	f8 94       	cli
    1674:	0f 92       	push	r0

/*************************************************/


void wheel_L(float cmd_vel){
		if(cmd_vel > 36){cmd_vel = 36;}
    1676:	c8 01       	movw	r24, r16
    1678:	b7 01       	movw	r22, r14
    167a:	20 e0       	ldi	r18, 0x00	; 0
    167c:	30 e0       	ldi	r19, 0x00	; 0
    167e:	40 e1       	ldi	r20, 0x10	; 16
    1680:	52 e4       	ldi	r21, 0x42	; 66
    1682:	0e 94 5c 2d 	call	0x5ab8	; 0x5ab8 <__gesf2>
    1686:	18 16       	cp	r1, r24
    1688:	5c f4       	brge	.+22     	; 0x16a0 <vPID+0x24e>
    168a:	0f 2e       	mov	r0, r31
    168c:	f0 e0       	ldi	r31, 0x00	; 0
    168e:	ef 2e       	mov	r14, r31
    1690:	f0 e0       	ldi	r31, 0x00	; 0
    1692:	ff 2e       	mov	r15, r31
    1694:	f0 e1       	ldi	r31, 0x10	; 16
    1696:	0f 2f       	mov	r16, r31
    1698:	f2 e4       	ldi	r31, 0x42	; 66
    169a:	1f 2f       	mov	r17, r31
    169c:	f0 2d       	mov	r31, r0
    169e:	14 c0       	rjmp	.+40     	; 0x16c8 <vPID+0x276>
		if(cmd_vel < -36){cmd_vel = -36;}
    16a0:	c8 01       	movw	r24, r16
    16a2:	b7 01       	movw	r22, r14
    16a4:	20 e0       	ldi	r18, 0x00	; 0
    16a6:	30 e0       	ldi	r19, 0x00	; 0
    16a8:	40 e1       	ldi	r20, 0x10	; 16
    16aa:	52 ec       	ldi	r21, 0xC2	; 194
    16ac:	0e 94 93 2b 	call	0x5726	; 0x5726 <__cmpsf2>
    16b0:	88 23       	and	r24, r24
    16b2:	54 f4       	brge	.+20     	; 0x16c8 <vPID+0x276>
    16b4:	0f 2e       	mov	r0, r31
    16b6:	f0 e0       	ldi	r31, 0x00	; 0
    16b8:	ef 2e       	mov	r14, r31
    16ba:	f0 e0       	ldi	r31, 0x00	; 0
    16bc:	ff 2e       	mov	r15, r31
    16be:	f0 e1       	ldi	r31, 0x10	; 16
    16c0:	0f 2f       	mov	r16, r31
    16c2:	f2 ec       	ldi	r31, 0xC2	; 194
    16c4:	1f 2f       	mov	r17, r31
    16c6:	f0 2d       	mov	r31, r0
		
		float s_out = -0.4928 * (cmd_vel) + 185.27;
		
		taskENTER_CRITICAL();
    16c8:	0f b6       	in	r0, 0x3f	; 63
    16ca:	f8 94       	cli
    16cc:	0f 92       	push	r0
		PWM_timer3_Set_E4((int)s_out);
    16ce:	c8 01       	movw	r24, r16
    16d0:	b7 01       	movw	r22, r14
    16d2:	28 e4       	ldi	r18, 0x48	; 72
    16d4:	30 e5       	ldi	r19, 0x50	; 80
    16d6:	4c ef       	ldi	r20, 0xFC	; 252
    16d8:	5e eb       	ldi	r21, 0xBE	; 190
    16da:	0e 94 67 2d 	call	0x5ace	; 0x5ace <__mulsf3>
    16de:	2f e1       	ldi	r18, 0x1F	; 31
    16e0:	35 e4       	ldi	r19, 0x45	; 69
    16e2:	49 e3       	ldi	r20, 0x39	; 57
    16e4:	53 e4       	ldi	r21, 0x43	; 67
    16e6:	0e 94 cd 2a 	call	0x559a	; 0x559a <__addsf3>
    16ea:	0e 94 ff 2b 	call	0x57fe	; 0x57fe <__fixsfsi>
void PWM_timer2_Set_H6(u16 pwmDuty)
	{OCR2B = pwmDuty;}
void PWM_timer3_Set_E3(u16 pwmDuty)
	{OCR3A = pwmDuty;}
void PWM_timer3_Set_E4(u16 pwmDuty)
	{OCR3B = pwmDuty;}
    16ee:	70 93 9b 00 	sts	0x009B, r23
    16f2:	60 93 9a 00 	sts	0x009A, r22
		taskEXIT_CRITICAL();
    16f6:	0f 90       	pop	r0
    16f8:	0f be       	out	0x3f, r0	; 63
			taskEXIT_CRITICAL();
*/
			
		taskENTER_CRITICAL();
		wheel_L(v_out_L);
		wheel_R(-v_out_R);
    16fa:	6b 85       	ldd	r22, Y+11	; 0x0b
    16fc:	7c 85       	ldd	r23, Y+12	; 0x0c
    16fe:	8d 85       	ldd	r24, Y+13	; 0x0d
    1700:	9e 85       	ldd	r25, Y+14	; 0x0e
    1702:	20 eb       	ldi	r18, 0xB0	; 176
    1704:	34 eb       	ldi	r19, 0xB4	; 180
    1706:	4a e2       	ldi	r20, 0x2A	; 42
    1708:	5d e3       	ldi	r21, 0x3D	; 61
    170a:	0e 94 67 2d 	call	0x5ace	; 0x5ace <__mulsf3>
    170e:	7b 01       	movw	r14, r22
    1710:	8c 01       	movw	r16, r24
    1712:	6f 81       	ldd	r22, Y+7	; 0x07
    1714:	78 85       	ldd	r23, Y+8	; 0x08
    1716:	89 85       	ldd	r24, Y+9	; 0x09
    1718:	9a 85       	ldd	r25, Y+10	; 0x0a
    171a:	2c e5       	ldi	r18, 0x5C	; 92
    171c:	36 e5       	ldi	r19, 0x56	; 86
    171e:	40 ea       	ldi	r20, 0xA0	; 160
    1720:	5d e3       	ldi	r21, 0x3D	; 61
    1722:	0e 94 67 2d 	call	0x5ace	; 0x5ace <__mulsf3>
    1726:	9b 01       	movw	r18, r22
    1728:	ac 01       	movw	r20, r24
    172a:	c8 01       	movw	r24, r16
    172c:	b7 01       	movw	r22, r14
    172e:	0e 94 cd 2a 	call	0x559a	; 0x559a <__addsf3>
    1732:	7b 01       	movw	r14, r22
    1734:	8c 01       	movw	r16, r24
    1736:	6b 81       	ldd	r22, Y+3	; 0x03
    1738:	7c 81       	ldd	r23, Y+4	; 0x04
    173a:	8d 81       	ldd	r24, Y+5	; 0x05
    173c:	9e 81       	ldd	r25, Y+6	; 0x06
    173e:	20 e0       	ldi	r18, 0x00	; 0
    1740:	30 e0       	ldi	r19, 0x00	; 0
    1742:	40 e0       	ldi	r20, 0x00	; 0
    1744:	50 e0       	ldi	r21, 0x00	; 0
    1746:	0e 94 67 2d 	call	0x5ace	; 0x5ace <__mulsf3>
    174a:	9b 01       	movw	r18, r22
    174c:	ac 01       	movw	r20, r24
    174e:	c8 01       	movw	r24, r16
    1750:	b7 01       	movw	r22, r14
    1752:	0e 94 cd 2a 	call	0x559a	; 0x559a <__addsf3>
    1756:	7b 01       	movw	r14, r22
    1758:	8c 01       	movw	r16, r24
    175a:	17 fb       	bst	r17, 7
    175c:	10 95       	com	r17
    175e:	17 f9       	bld	r17, 7
    1760:	10 95       	com	r17


}

void wheel_R(float cmd_vel){
		if(cmd_vel > 36){cmd_vel = 36;}
    1762:	c8 01       	movw	r24, r16
    1764:	b7 01       	movw	r22, r14
    1766:	20 e0       	ldi	r18, 0x00	; 0
    1768:	30 e0       	ldi	r19, 0x00	; 0
    176a:	40 e1       	ldi	r20, 0x10	; 16
    176c:	52 e4       	ldi	r21, 0x42	; 66
    176e:	0e 94 5c 2d 	call	0x5ab8	; 0x5ab8 <__gesf2>
    1772:	18 16       	cp	r1, r24
    1774:	5c f4       	brge	.+22     	; 0x178c <vPID+0x33a>
    1776:	0f 2e       	mov	r0, r31
    1778:	f0 e0       	ldi	r31, 0x00	; 0
    177a:	ef 2e       	mov	r14, r31
    177c:	f0 e0       	ldi	r31, 0x00	; 0
    177e:	ff 2e       	mov	r15, r31
    1780:	f0 e1       	ldi	r31, 0x10	; 16
    1782:	0f 2f       	mov	r16, r31
    1784:	f2 e4       	ldi	r31, 0x42	; 66
    1786:	1f 2f       	mov	r17, r31
    1788:	f0 2d       	mov	r31, r0
    178a:	14 c0       	rjmp	.+40     	; 0x17b4 <vPID+0x362>
		if(cmd_vel < -36){cmd_vel = -36;}
    178c:	c8 01       	movw	r24, r16
    178e:	b7 01       	movw	r22, r14
    1790:	20 e0       	ldi	r18, 0x00	; 0
    1792:	30 e0       	ldi	r19, 0x00	; 0
    1794:	40 e1       	ldi	r20, 0x10	; 16
    1796:	52 ec       	ldi	r21, 0xC2	; 194
    1798:	0e 94 93 2b 	call	0x5726	; 0x5726 <__cmpsf2>
    179c:	88 23       	and	r24, r24
    179e:	54 f4       	brge	.+20     	; 0x17b4 <vPID+0x362>
    17a0:	0f 2e       	mov	r0, r31
    17a2:	f0 e0       	ldi	r31, 0x00	; 0
    17a4:	ef 2e       	mov	r14, r31
    17a6:	f0 e0       	ldi	r31, 0x00	; 0
    17a8:	ff 2e       	mov	r15, r31
    17aa:	f0 e1       	ldi	r31, 0x10	; 16
    17ac:	0f 2f       	mov	r16, r31
    17ae:	f2 ec       	ldi	r31, 0xC2	; 194
    17b0:	1f 2f       	mov	r17, r31
    17b2:	f0 2d       	mov	r31, r0
				
		float s_out = -0.5421 * (cmd_vel) + 188.41;

		taskENTER_CRITICAL();
    17b4:	0f b6       	in	r0, 0x3f	; 63
    17b6:	f8 94       	cli
    17b8:	0f 92       	push	r0
		PWM_timer3_Set_E3((int)s_out);
    17ba:	c8 01       	movw	r24, r16
    17bc:	b7 01       	movw	r22, r14
    17be:	21 e1       	ldi	r18, 0x11	; 17
    17c0:	37 ec       	ldi	r19, 0xC7	; 199
    17c2:	4a e0       	ldi	r20, 0x0A	; 10
    17c4:	5f eb       	ldi	r21, 0xBF	; 191
    17c6:	0e 94 67 2d 	call	0x5ace	; 0x5ace <__mulsf3>
    17ca:	26 ef       	ldi	r18, 0xF6	; 246
    17cc:	38 e6       	ldi	r19, 0x68	; 104
    17ce:	4c e3       	ldi	r20, 0x3C	; 60
    17d0:	53 e4       	ldi	r21, 0x43	; 67
    17d2:	0e 94 cd 2a 	call	0x559a	; 0x559a <__addsf3>
    17d6:	0e 94 ff 2b 	call	0x57fe	; 0x57fe <__fixsfsi>
void PWM_timer1_Set_LED(u16 pwmDuty)
	{OCR1B = pwmDuty;}
void PWM_timer2_Set_H6(u16 pwmDuty)
	{OCR2B = pwmDuty;}
void PWM_timer3_Set_E3(u16 pwmDuty)
	{OCR3A = pwmDuty;}
    17da:	70 93 99 00 	sts	0x0099, r23
    17de:	60 93 98 00 	sts	0x0098, r22
		taskEXIT_CRITICAL();
    17e2:	0f 90       	pop	r0
    17e4:	0f be       	out	0x3f, r0	; 63
*/
			
		taskENTER_CRITICAL();
		wheel_L(v_out_L);
		wheel_R(-v_out_R);
		taskEXIT_CRITICAL();
    17e6:	0f 90       	pop	r0
    17e8:	0f be       	out	0x3f, r0	; 63

		vTaskDelayUntil(&xLastWakeTime, (100 / portTICK_RATE_MS));
    17ea:	ce 01       	movw	r24, r28
    17ec:	01 96       	adiw	r24, 0x01	; 1
    17ee:	64 e6       	ldi	r22, 0x64	; 100
    17f0:	70 e0       	ldi	r23, 0x00	; 0
    17f2:	0e 94 89 13 	call	0x2712	; 0x2712 <vTaskDelayUntil>
    17f6:	2a 2d       	mov	r18, r10
    17f8:	36 2d       	mov	r19, r6
    17fa:	42 2d       	mov	r20, r2
    17fc:	5d 2d       	mov	r21, r13
    17fe:	c9 01       	movw	r24, r18
    1800:	da 01       	movw	r26, r20
    1802:	5f ce       	rjmp	.-834    	; 0x14c2 <vPID+0x70>

00001804 <ubRcv>:
		
			//taskYIELD();
	//	}
}

void ubRcv(unsigned char c){
    1804:	1f 93       	push	r17
	static char dis_iter; //count iterator for commanded distance
	static char rot_flag;
	static char dis_flag;
	static s16 rot_rough = 0;  //store ascii chars
	static s16 dis_rough = 0;  //store ascii chars
		c = c & 0b01111111;		//for some reason, every byte has its first bit set to 1
    1806:	18 2f       	mov	r17, r24
    1808:	1f 77       	andi	r17, 0x7F	; 127
		uart1SendByte(c);
    180a:	81 2f       	mov	r24, r17
    180c:	0e 94 7e 20 	call	0x40fc	; 0x40fc <uart1SendByte>
		if(c != 0xff){
		//if the data isn't whitespace (0xff), post it
		

			if(c == 0x0a){lf_flag = SET;} //line feed detected, the character will be a 'R' or a 'D'
    1810:	1a 30       	cpi	r17, 0x0A	; 10
    1812:	21 f4       	brne	.+8      	; 0x181c <ubRcv+0x18>
    1814:	81 e0       	ldi	r24, 0x01	; 1
    1816:	80 93 04 03 	sts	0x0304, r24
    181a:	61 c0       	rjmp	.+194    	; 0x18de <ubRcv+0xda>
	
			else if((lf_flag) && (c == 'R')){ //set rotation flag
    181c:	80 91 04 03 	lds	r24, 0x0304
    1820:	88 23       	and	r24, r24
    1822:	91 f0       	breq	.+36     	; 0x1848 <ubRcv+0x44>
    1824:	12 35       	cpi	r17, 0x52	; 82
    1826:	31 f4       	brne	.+12     	; 0x1834 <ubRcv+0x30>
				rot_flag = SET;
    1828:	81 e0       	ldi	r24, 0x01	; 1
    182a:	80 93 01 03 	sts	0x0301, r24
				rot_iter = 0;
    182e:	10 92 03 03 	sts	0x0303, r1
    1832:	07 c0       	rjmp	.+14     	; 0x1842 <ubRcv+0x3e>
				lf_flag = UNSET;
				//rprintf("R: char: %c ",c);
				return;
			} 
			else if((lf_flag) && (c == 'M')){ //set distance flag
    1834:	1d 34       	cpi	r17, 0x4D	; 77
    1836:	41 f4       	brne	.+16     	; 0x1848 <ubRcv+0x44>
				dis_flag = SET;
    1838:	81 e0       	ldi	r24, 0x01	; 1
    183a:	80 93 00 03 	sts	0x0300, r24
				dis_iter = 0;
    183e:	10 92 02 03 	sts	0x0302, r1
				lf_flag = UNSET;
    1842:	10 92 04 03 	sts	0x0304, r1
    1846:	86 c0       	rjmp	.+268    	; 0x1954 <ubRcv+0x150>
			//	rprintf("%c",c);
				return;
			}
			else if(rot_flag){
    1848:	80 91 01 03 	lds	r24, 0x0301
    184c:	88 23       	and	r24, r24
    184e:	11 f1       	breq	.+68     	; 0x1894 <ubRcv+0x90>

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
    1850:	81 2f       	mov	r24, r17
    1852:	80 53       	subi	r24, 0x30	; 48
    1854:	8a 30       	cpi	r24, 0x0A	; 10
    1856:	10 f4       	brcc	.+4      	; 0x185c <ubRcv+0x58>
    1858:	18 2f       	mov	r17, r24
    185a:	05 c0       	rjmp	.+10     	; 0x1866 <ubRcv+0x62>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
    185c:	81 2f       	mov	r24, r17
    185e:	81 54       	subi	r24, 0x41	; 65
    1860:	86 30       	cpi	r24, 0x06	; 6
    1862:	08 f4       	brcc	.+2      	; 0x1866 <ubRcv+0x62>
		c -= 55;
    1864:	17 53       	subi	r17, 0x37	; 55
				lf_flag = UNSET;
			//	rprintf("%c",c);
				return;
			}
			else if(rot_flag){
				rot_rough = (char2hex(c) | (rot_rough << 4));	//store then increment	
    1866:	81 2f       	mov	r24, r17
    1868:	90 e0       	ldi	r25, 0x00	; 0
    186a:	20 91 fe 02 	lds	r18, 0x02FE
    186e:	30 91 ff 02 	lds	r19, 0x02FF
    1872:	e4 e0       	ldi	r30, 0x04	; 4
    1874:	22 0f       	add	r18, r18
    1876:	33 1f       	adc	r19, r19
    1878:	ea 95       	dec	r30
    187a:	e1 f7       	brne	.-8      	; 0x1874 <ubRcv+0x70>
    187c:	82 2b       	or	r24, r18
    187e:	93 2b       	or	r25, r19
    1880:	90 93 ff 02 	sts	0x02FF, r25
    1884:	80 93 fe 02 	sts	0x02FE, r24
				rot_iter++;
    1888:	80 91 03 03 	lds	r24, 0x0303
    188c:	8f 5f       	subi	r24, 0xFF	; 255
    188e:	80 93 03 03 	sts	0x0303, r24
    1892:	25 c0       	rjmp	.+74     	; 0x18de <ubRcv+0xda>
				//rprintf(" #%c\t:%d\t",c,rot_iter);
				//rprintfu08(c); rprintf("\t");
				//rprintfu16(rot_rough);
				//rprintfCRLF();
			}	
			else if(dis_flag){
    1894:	80 91 00 03 	lds	r24, 0x0300
    1898:	88 23       	and	r24, r24
    189a:	09 f1       	breq	.+66     	; 0x18de <ubRcv+0xda>

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
    189c:	81 2f       	mov	r24, r17
    189e:	80 53       	subi	r24, 0x30	; 48
    18a0:	8a 30       	cpi	r24, 0x0A	; 10
    18a2:	10 f4       	brcc	.+4      	; 0x18a8 <ubRcv+0xa4>
    18a4:	18 2f       	mov	r17, r24
    18a6:	05 c0       	rjmp	.+10     	; 0x18b2 <ubRcv+0xae>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
    18a8:	81 2f       	mov	r24, r17
    18aa:	81 54       	subi	r24, 0x41	; 65
    18ac:	86 30       	cpi	r24, 0x06	; 6
    18ae:	08 f4       	brcc	.+2      	; 0x18b2 <ubRcv+0xae>
		c -= 55;
    18b0:	17 53       	subi	r17, 0x37	; 55
				//rprintfu08(c); rprintf("\t");
				//rprintfu16(rot_rough);
				//rprintfCRLF();
			}	
			else if(dis_flag){
				dis_rough = (char2hex(c) | (dis_rough << 4));	//store then increment	
    18b2:	81 2f       	mov	r24, r17
    18b4:	90 e0       	ldi	r25, 0x00	; 0
    18b6:	20 91 fc 02 	lds	r18, 0x02FC
    18ba:	30 91 fd 02 	lds	r19, 0x02FD
    18be:	74 e0       	ldi	r23, 0x04	; 4
    18c0:	22 0f       	add	r18, r18
    18c2:	33 1f       	adc	r19, r19
    18c4:	7a 95       	dec	r23
    18c6:	e1 f7       	brne	.-8      	; 0x18c0 <ubRcv+0xbc>
    18c8:	82 2b       	or	r24, r18
    18ca:	93 2b       	or	r25, r19
    18cc:	90 93 fd 02 	sts	0x02FD, r25
    18d0:	80 93 fc 02 	sts	0x02FC, r24
				dis_iter++;
    18d4:	80 91 02 03 	lds	r24, 0x0302
    18d8:	8f 5f       	subi	r24, 0xFF	; 255
    18da:	80 93 02 03 	sts	0x0302, r24
			//	rprintf("%c",c);
			}

			if(rot_iter == 4){
    18de:	80 91 03 03 	lds	r24, 0x0303
    18e2:	84 30       	cpi	r24, 0x04	; 4
    18e4:	d9 f4       	brne	.+54     	; 0x191c <ubRcv+0x118>
				//cmd_angle = retConv_s16(&rot_rough);
				cmd_angle = rot_rough;
    18e6:	60 91 fe 02 	lds	r22, 0x02FE
    18ea:	70 91 ff 02 	lds	r23, 0x02FF
    18ee:	88 27       	eor	r24, r24
    18f0:	77 fd       	sbrc	r23, 7
    18f2:	80 95       	com	r24
    18f4:	98 2f       	mov	r25, r24
    18f6:	0e 94 32 2c 	call	0x5864	; 0x5864 <__floatsisf>
    18fa:	60 93 e4 02 	sts	0x02E4, r22
    18fe:	70 93 e5 02 	sts	0x02E5, r23
    1902:	80 93 e6 02 	sts	0x02E6, r24
    1906:	90 93 e7 02 	sts	0x02E7, r25
				rot_flag = UNSET;
    190a:	10 92 01 03 	sts	0x0301, r1
				rot_iter = 0;
    190e:	10 92 03 03 	sts	0x0303, r1
				//rprintfu16(rot_rough);
				//rprintf("\n\n");
				rot_rough = 0;
    1912:	10 92 ff 02 	sts	0x02FF, r1
    1916:	10 92 fe 02 	sts	0x02FE, r1
    191a:	1c c0       	rjmp	.+56     	; 0x1954 <ubRcv+0x150>
			}
			else if(dis_iter == 4){
    191c:	80 91 02 03 	lds	r24, 0x0302
    1920:	84 30       	cpi	r24, 0x04	; 4
    1922:	c1 f4       	brne	.+48     	; 0x1954 <ubRcv+0x150>
				cmd_dist = dis_rough;
    1924:	80 91 fc 02 	lds	r24, 0x02FC
    1928:	90 91 fd 02 	lds	r25, 0x02FD
    192c:	aa 27       	eor	r26, r26
    192e:	97 fd       	sbrc	r25, 7
    1930:	a0 95       	com	r26
    1932:	ba 2f       	mov	r27, r26
    1934:	80 93 ec 02 	sts	0x02EC, r24
    1938:	90 93 ed 02 	sts	0x02ED, r25
    193c:	a0 93 ee 02 	sts	0x02EE, r26
    1940:	b0 93 ef 02 	sts	0x02EF, r27
				dis_flag = UNSET;
    1944:	10 92 00 03 	sts	0x0300, r1
				dis_iter = 0;
    1948:	10 92 02 03 	sts	0x0302, r1
				dis_rough = 0;
    194c:	10 92 fd 02 	sts	0x02FD, r1
    1950:	10 92 fc 02 	sts	0x02FC, r1
		
		}

		else{rprintf("WR\n");}
		
}
    1954:	1f 91       	pop	r17
    1956:	08 95       	ret

00001958 <prvSetupHardware>:
	lds_buffer_read_ndx++;
	if(lds_buffer_read_ndx == buffer_size) lds_buffer_read_ndx = 0;
	return lds_buffer[lds_buffer_read_ndx - 1];
}

void prvSetupHardware(){
    1958:	0f 93       	push	r16
    195a:	1f 93       	push	r17
    195c:	cf 93       	push	r28
    195e:	df 93       	push	r29
	delay_cycles(65535);
	delay_cycles(65535);
	
	

	uartInit();  // initialize the UART (serial port)
    1960:	0e 94 2b 24 	call	0x4856	; 0x4856 <uartInit>
    uartSetBaudRate(0, 38400); // set UARTE speed, for Bluetooth
    1964:	80 e0       	ldi	r24, 0x00	; 0
    1966:	40 e0       	ldi	r20, 0x00	; 0
    1968:	56 e9       	ldi	r21, 0x96	; 150
    196a:	60 e0       	ldi	r22, 0x00	; 0
    196c:	70 e0       	ldi	r23, 0x00	; 0
    196e:	0e 94 05 20 	call	0x400a	; 0x400a <uartSetBaudRate>
    uartSetBaudRate(1, 115200); // set UARTD speed, for USB connection, up to 500k, try 115200 if it doesn't work
    1972:	81 e0       	ldi	r24, 0x01	; 1
    1974:	40 e0       	ldi	r20, 0x00	; 0
    1976:	52 ec       	ldi	r21, 0xC2	; 194
    1978:	61 e0       	ldi	r22, 0x01	; 1
    197a:	70 e0       	ldi	r23, 0x00	; 0
    197c:	0e 94 05 20 	call	0x400a	; 0x400a <uartSetBaudRate>
    uartSetBaudRate(2, 38400); // set UARTH speed
    1980:	82 e0       	ldi	r24, 0x02	; 2
    1982:	40 e0       	ldi	r20, 0x00	; 0
    1984:	56 e9       	ldi	r21, 0x96	; 150
    1986:	60 e0       	ldi	r22, 0x00	; 0
    1988:	70 e0       	ldi	r23, 0x00	; 0
    198a:	0e 94 05 20 	call	0x400a	; 0x400a <uartSetBaudRate>
    uartSetBaudRate(3, 115200); // set UARTJ speed, for Blackfin
    198e:	83 e0       	ldi	r24, 0x03	; 3
    1990:	40 e0       	ldi	r20, 0x00	; 0
    1992:	52 ec       	ldi	r21, 0xC2	; 194
    1994:	61 e0       	ldi	r22, 0x01	; 1
    1996:	70 e0       	ldi	r23, 0x00	; 0
    1998:	0e 94 05 20 	call	0x400a	; 0x400a <uartSetBaudRate>
	//G=Ground, T=Tx (connect to external Rx), R=Rx (connect to external Tx)

	rprintfInit(uart1SendByte);// initialize rprintf system and configure uart1 (USB) for rprintf
    199c:	8e e7       	ldi	r24, 0x7E	; 126
    199e:	90 e2       	ldi	r25, 0x20	; 32
    19a0:	0e 94 6f 25 	call	0x4ade	; 0x4ade <rprintfInit>

	configure_ports(); // configure which ports are analog, digital, etc.
    19a4:	0e 94 62 03 	call	0x6c4	; 0x6c4 <configure_ports>
	*/

	
	//UART ISR *** UART ISR ***
	
	uartSetRxHandler(2, &fwdSer_L);
    19a8:	82 e0       	ldi	r24, 0x02	; 2
    19aa:	6c eb       	ldi	r22, 0xBC	; 188
    19ac:	76 e0       	ldi	r23, 0x06	; 6
    19ae:	0e 94 fa 1f 	call	0x3ff4	; 0x3ff4 <uartSetRxHandler>
	uartSetRxHandler(0, &fwdSer_R);
    19b2:	80 e0       	ldi	r24, 0x00	; 0
    19b4:	6c e4       	ldi	r22, 0x4C	; 76
    19b6:	77 e0       	ldi	r23, 0x07	; 7
    19b8:	0e 94 fa 1f 	call	0x3ff4	; 0x3ff4 <uartSetRxHandler>
	uartSetRxHandler(3, &LDSRcv);
    19bc:	83 e0       	ldi	r24, 0x03	; 3
    19be:	61 e7       	ldi	r22, 0x71	; 113
    19c0:	75 e0       	ldi	r23, 0x05	; 5
    19c2:	0e 94 fa 1f 	call	0x3ff4	; 0x3ff4 <uartSetRxHandler>
void LED_on(void)
	{PORT_OFF(PORTB,6);}
    19c6:	2e 98       	cbi	0x05, 6	; 5

	//UART ISR *** UART ISR ***

	LED_on();

	rprintf("\r\nSystem Warmed Up");
    19c8:	00 d0       	rcall	.+0      	; 0x19ca <prvSetupHardware+0x72>
    19ca:	0f 92       	push	r0
    19cc:	81 e0       	ldi	r24, 0x01	; 1
    19ce:	ed b7       	in	r30, 0x3d	; 61
    19d0:	fe b7       	in	r31, 0x3e	; 62
    19d2:	81 83       	std	Z+1, r24	; 0x01
    19d4:	86 e5       	ldi	r24, 0x56	; 86
    19d6:	91 e0       	ldi	r25, 0x01	; 1
    19d8:	93 83       	std	Z+3, r25	; 0x03
    19da:	82 83       	std	Z+2, r24	; 0x02
    19dc:	0e 94 93 27 	call	0x4f26	; 0x4f26 <rprintf1RamRom>

	// initialize the timer system
 	init_timer0(TIMER_CLK_1024);
    19e0:	0f 90       	pop	r0
    19e2:	0f 90       	pop	r0
    19e4:	0f 90       	pop	r0
    19e6:	85 e0       	ldi	r24, 0x05	; 5
    19e8:	0e 94 11 1a 	call	0x3422	; 0x3422 <init_timer0>
// 	init_timer1(TIMER_CLK_64); // Timer 1 is initialized by FreeRTOS
 	//init_timer2(TIMER2_CLK_64);
	init_timer2(TIMER2_CLK_1024);
    19ec:	87 e0       	ldi	r24, 0x07	; 7
    19ee:	0e 94 31 1a 	call	0x3462	; 0x3462 <init_timer2>
 	init_timer3(TIMER_CLK_64);
    19f2:	83 e0       	ldi	r24, 0x03	; 3
    19f4:	0e 94 41 1a 	call	0x3482	; 0x3482 <init_timer3>
 	init_timer4(TIMER_CLK_64);
    19f8:	83 e0       	ldi	r24, 0x03	; 3
    19fa:	0e 94 53 1a 	call	0x34a6	; 0x34a6 <init_timer4>
 	init_timer5(TIMER_CLK_64);
    19fe:	83 e0       	ldi	r24, 0x03	; 3
    1a00:	0e 94 65 1a 	call	0x34ca	; 0x34ca <init_timer5>

	a2dInit(); // initialize analog to digital converter (ADC)
    1a04:	0e 94 e4 24 	call	0x49c8	; 0x49c8 <a2dInit>
	a2dSetPrescaler(ADC_PRESCALE_DIV32); // configure ADC scaling
    1a08:	85 e0       	ldi	r24, 0x05	; 5
    1a0a:	0e 94 09 25 	call	0x4a12	; 0x4a12 <a2dSetPrescaler>
	a2dSetReference(ADC_REFERENCE_AVCC); // configure ADC reference voltage
    1a0e:	81 e0       	ldi	r24, 0x01	; 1
    1a10:	0e 94 10 25 	call	0x4a20	; 0x4a20 <a2dSetReference>
    1a14:	10 e0       	ldi	r17, 0x00	; 0
	//let system stabelize for X time
	for(i=0;i<16;i++)
		{
		j=a2dConvert8bit(i);//read each ADC once to get it working accurately
		delay_cycles(5000); //keep LED on long enough to see Axon reseting
		rprintf(".");
    1a16:	01 e0       	ldi	r16, 0x01	; 1
    1a18:	c4 e5       	ldi	r28, 0x54	; 84
    1a1a:	d1 e0       	ldi	r29, 0x01	; 1
	a2dSetReference(ADC_REFERENCE_AVCC); // configure ADC reference voltage

	//let system stabelize for X time
	for(i=0;i<16;i++)
		{
		j=a2dConvert8bit(i);//read each ADC once to get it working accurately
    1a1c:	81 2f       	mov	r24, r17
    1a1e:	0e 94 59 25 	call	0x4ab2	; 0x4ab2 <a2dConvert8bit>
		delay_cycles(5000); //keep LED on long enough to see Axon reseting
		rprintf(".");
    1a22:	00 d0       	rcall	.+0      	; 0x1a24 <prvSetupHardware+0xcc>
    1a24:	0f 92       	push	r0
    1a26:	ed b7       	in	r30, 0x3d	; 61
    1a28:	fe b7       	in	r31, 0x3e	; 62
    1a2a:	01 83       	std	Z+1, r16	; 0x01
    1a2c:	d3 83       	std	Z+3, r29	; 0x03
    1a2e:	c2 83       	std	Z+2, r28	; 0x02
    1a30:	0e 94 93 27 	call	0x4f26	; 0x4f26 <rprintf1RamRom>
    1a34:	1f 5f       	subi	r17, 0xFF	; 255
	a2dInit(); // initialize analog to digital converter (ADC)
	a2dSetPrescaler(ADC_PRESCALE_DIV32); // configure ADC scaling
	a2dSetReference(ADC_REFERENCE_AVCC); // configure ADC reference voltage

	//let system stabelize for X time
	for(i=0;i<16;i++)
    1a36:	0f 90       	pop	r0
    1a38:	0f 90       	pop	r0
    1a3a:	0f 90       	pop	r0
    1a3c:	10 31       	cpi	r17, 0x10	; 16
    1a3e:	71 f7       	brne	.-36     	; 0x1a1c <prvSetupHardware+0xc4>


//***************STATUS LED**************
//tank test
void LED_off(void)
	{PORT_ON(PORTB,6);}
    1a40:	2e 9a       	sbi	0x05, 6	; 5
		rprintf(".");
		}

	LED_off();

	rprintf("Initialization Complete \r\n");
    1a42:	00 d0       	rcall	.+0      	; 0x1a44 <prvSetupHardware+0xec>
    1a44:	0f 92       	push	r0
    1a46:	ed b7       	in	r30, 0x3d	; 61
    1a48:	fe b7       	in	r31, 0x3e	; 62
    1a4a:	01 83       	std	Z+1, r16	; 0x01
    1a4c:	89 e3       	ldi	r24, 0x39	; 57
    1a4e:	91 e0       	ldi	r25, 0x01	; 1
    1a50:	93 83       	std	Z+3, r25	; 0x03
    1a52:	82 83       	std	Z+2, r24	; 0x02
    1a54:	0e 94 93 27 	call	0x4f26	; 0x4f26 <rprintf1RamRom>

	//reset all timers to zero
	reset_timer0();
    1a58:	0f 90       	pop	r0
    1a5a:	0f 90       	pop	r0
    1a5c:	0f 90       	pop	r0
    1a5e:	0e 94 c7 19 	call	0x338e	; 0x338e <reset_timer0>
	reset_timer1();
    1a62:	0e 94 d1 19 	call	0x33a2	; 0x33a2 <reset_timer1>
	reset_timer2();
    1a66:	0e 94 de 19 	call	0x33bc	; 0x33bc <reset_timer2>
	reset_timer3();
    1a6a:	0e 94 e9 19 	call	0x33d2	; 0x33d2 <reset_timer3>
	reset_timer4();
    1a6e:	0e 94 f6 19 	call	0x33ec	; 0x33ec <reset_timer4>
	reset_timer5();
    1a72:	0e 94 03 1a 	call	0x3406	; 0x3406 <reset_timer5>



	/********PWM Setup***********/
	prvPWMSetup();
    1a76:	0e 94 32 04 	call	0x864	; 0x864 <prvPWMSetup>

}
    1a7a:	df 91       	pop	r29
    1a7c:	cf 91       	pop	r28
    1a7e:	1f 91       	pop	r17
    1a80:	0f 91       	pop	r16
    1a82:	08 95       	ret

00001a84 <main>:
float elapsed_time;
float current_time = 0;
float previous_time = 0;

int main(void)
{
    1a84:	af 92       	push	r10
    1a86:	bf 92       	push	r11
    1a88:	cf 92       	push	r12
    1a8a:	df 92       	push	r13
    1a8c:	ef 92       	push	r14
    1a8e:	ff 92       	push	r15
    1a90:	0f 93       	push	r16
    1a92:	cf 93       	push	r28
    1a94:	df 93       	push	r29
	prvSetupHardware();
    1a96:	0e 94 ac 0c 	call	0x1958	; 0x1958 <prvSetupHardware>

	key = uart1GetByte();
    1a9a:	0e 94 40 23 	call	0x4680	; 0x4680 <uart1GetByte>
    1a9e:	80 93 4d 12 	sts	0x124D, r24
	delay_ms(500);
    1aa2:	84 ef       	ldi	r24, 0xF4	; 244
    1aa4:	91 e0       	ldi	r25, 0x01	; 1
    1aa6:	0e 94 8c 1a 	call	0x3518	; 0x3518 <sleep>

*/	

//	for(;;);

	v_command = 25;
    1aaa:	80 e0       	ldi	r24, 0x00	; 0
    1aac:	90 e0       	ldi	r25, 0x00	; 0
    1aae:	a8 ec       	ldi	r26, 0xC8	; 200
    1ab0:	b1 e4       	ldi	r27, 0x41	; 65
    1ab2:	80 93 e0 02 	sts	0x02E0, r24
    1ab6:	90 93 e1 02 	sts	0x02E1, r25
    1aba:	a0 93 e2 02 	sts	0x02E2, r26
    1abe:	b0 93 e3 02 	sts	0x02E3, r27
	cmd_ang_vel = 0;
    1ac2:	80 e0       	ldi	r24, 0x00	; 0
    1ac4:	90 e0       	ldi	r25, 0x00	; 0
    1ac6:	a0 e0       	ldi	r26, 0x00	; 0
    1ac8:	b0 e0       	ldi	r27, 0x00	; 0
    1aca:	80 93 e8 02 	sts	0x02E8, r24
    1ace:	90 93 e9 02 	sts	0x02E9, r25
    1ad2:	a0 93 ea 02 	sts	0x02EA, r26
    1ad6:	b0 93 eb 02 	sts	0x02EB, r27


	xTaskCreate(vLight0On, "Light0", 100, NULL, 1, NULL);
    1ada:	81 ef       	ldi	r24, 0xF1	; 241
    1adc:	98 e0       	ldi	r25, 0x08	; 8
    1ade:	60 e0       	ldi	r22, 0x00	; 0
    1ae0:	72 e0       	ldi	r23, 0x02	; 2
    1ae2:	44 e6       	ldi	r20, 0x64	; 100
    1ae4:	50 e0       	ldi	r21, 0x00	; 0
    1ae6:	20 e0       	ldi	r18, 0x00	; 0
    1ae8:	30 e0       	ldi	r19, 0x00	; 0
    1aea:	01 e0       	ldi	r16, 0x01	; 1
    1aec:	ee 24       	eor	r14, r14
    1aee:	ff 24       	eor	r15, r15
    1af0:	cc 24       	eor	r12, r12
    1af2:	dd 24       	eor	r13, r13
    1af4:	aa 24       	eor	r10, r10
    1af6:	bb 24       	eor	r11, r11
    1af8:	0e 94 73 14 	call	0x28e6	; 0x28e6 <xTaskGenericCreate>
	xTaskCreate(vLight1On, "Light1", 100, NULL, 1, NULL);
    1afc:	8a ed       	ldi	r24, 0xDA	; 218
    1afe:	98 e0       	ldi	r25, 0x08	; 8
    1b00:	67 e0       	ldi	r22, 0x07	; 7
    1b02:	72 e0       	ldi	r23, 0x02	; 2
    1b04:	44 e6       	ldi	r20, 0x64	; 100
    1b06:	50 e0       	ldi	r21, 0x00	; 0
    1b08:	20 e0       	ldi	r18, 0x00	; 0
    1b0a:	30 e0       	ldi	r19, 0x00	; 0
    1b0c:	0e 94 73 14 	call	0x28e6	; 0x28e6 <xTaskGenericCreate>
	xTaskCreate(vUpdatePose, "UpdatePs", 500, NULL, 1, NULL);
    1b10:	80 e4       	ldi	r24, 0x40	; 64
    1b12:	96 e0       	ldi	r25, 0x06	; 6
    1b14:	6e e0       	ldi	r22, 0x0E	; 14
    1b16:	72 e0       	ldi	r23, 0x02	; 2
    1b18:	44 ef       	ldi	r20, 0xF4	; 244
    1b1a:	51 e0       	ldi	r21, 0x01	; 1
    1b1c:	20 e0       	ldi	r18, 0x00	; 0
    1b1e:	30 e0       	ldi	r19, 0x00	; 0
    1b20:	0e 94 73 14 	call	0x28e6	; 0x28e6 <xTaskGenericCreate>
	xTaskCreate(vEnc_UpdatePose, "enUpdtPs", 500, NULL, 1, NULL);
    1b24:	88 e0       	ldi	r24, 0x08	; 8
    1b26:	99 e0       	ldi	r25, 0x09	; 9
    1b28:	67 e1       	ldi	r22, 0x17	; 23
    1b2a:	72 e0       	ldi	r23, 0x02	; 2
    1b2c:	44 ef       	ldi	r20, 0xF4	; 244
    1b2e:	51 e0       	ldi	r21, 0x01	; 1
    1b30:	20 e0       	ldi	r18, 0x00	; 0
    1b32:	30 e0       	ldi	r19, 0x00	; 0
    1b34:	0e 94 73 14 	call	0x28e6	; 0x28e6 <xTaskGenericCreate>
//	xTaskCreate(vServoOsc, "ServoGo", 200, NULL, 1, NULL);
//	xTaskCreate(vServoTm, "ServoTm", 200, NULL, 1, NULL);
//	xTaskCreate(vPID_L, "vPID_L", 500, NULL, 2, NULL);
//	xTaskCreate(vPID_R, "vPID_R", 500, NULL, 2, NULL);
	xTaskCreate(vPID, "vPID", 500, NULL, 1, NULL);
    1b38:	89 e2       	ldi	r24, 0x29	; 41
    1b3a:	9a e0       	ldi	r25, 0x0A	; 10
    1b3c:	60 e2       	ldi	r22, 0x20	; 32
    1b3e:	72 e0       	ldi	r23, 0x02	; 2
    1b40:	44 ef       	ldi	r20, 0xF4	; 244
    1b42:	51 e0       	ldi	r21, 0x01	; 1
    1b44:	20 e0       	ldi	r18, 0x00	; 0
    1b46:	30 e0       	ldi	r19, 0x00	; 0
    1b48:	0e 94 73 14 	call	0x28e6	; 0x28e6 <xTaskGenericCreate>
//	xTaskCreate(vScript, "vScript", 100, NULL, 2, NULL);


	vTaskStartScheduler();
    1b4c:	0e 94 97 15 	call	0x2b2e	; 0x2b2e <vTaskStartScheduler>
	for(;;){rprintf("DEATH\n");}
    1b50:	c1 e1       	ldi	r28, 0x11	; 17
    1b52:	d1 e0       	ldi	r29, 0x01	; 1
    1b54:	00 d0       	rcall	.+0      	; 0x1b56 <main+0xd2>
    1b56:	0f 92       	push	r0
    1b58:	ed b7       	in	r30, 0x3d	; 61
    1b5a:	fe b7       	in	r31, 0x3e	; 62
    1b5c:	01 83       	std	Z+1, r16	; 0x01
    1b5e:	d3 83       	std	Z+3, r29	; 0x03
    1b60:	c2 83       	std	Z+2, r28	; 0x02
    1b62:	0e 94 93 27 	call	0x4f26	; 0x4f26 <rprintf1RamRom>
    1b66:	0f 90       	pop	r0
    1b68:	0f 90       	pop	r0
    1b6a:	0f 90       	pop	r0
    1b6c:	f3 cf       	rjmp	.-26     	; 0x1b54 <main+0xd0>

00001b6e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1b6e:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    1b70:	9c 01       	movw	r18, r24
    1b72:	2d 5f       	subi	r18, 0xFD	; 253
    1b74:	3f 4f       	sbci	r19, 0xFF	; 255
    1b76:	32 83       	std	Z+2, r19	; 0x02
    1b78:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1b7a:	8f ef       	ldi	r24, 0xFF	; 255
    1b7c:	9f ef       	ldi	r25, 0xFF	; 255
    1b7e:	94 83       	std	Z+4, r25	; 0x04
    1b80:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1b82:	36 83       	std	Z+6, r19	; 0x06
    1b84:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1b86:	30 87       	std	Z+8, r19	; 0x08
    1b88:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = 0;
    1b8a:	10 82       	st	Z, r1
}
    1b8c:	08 95       	ret

00001b8e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1b8e:	fc 01       	movw	r30, r24
    1b90:	11 86       	std	Z+9, r1	; 0x09
    1b92:	10 86       	std	Z+8, r1	; 0x08
}
    1b94:	08 95       	ret

00001b96 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1b96:	cf 93       	push	r28
    1b98:	df 93       	push	r29
    1b9a:	ac 01       	movw	r20, r24
    1b9c:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1b9e:	ec 01       	movw	r28, r24
    1ba0:	29 81       	ldd	r18, Y+1	; 0x01
    1ba2:	3a 81       	ldd	r19, Y+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    1ba4:	f9 01       	movw	r30, r18
    1ba6:	82 81       	ldd	r24, Z+2	; 0x02
    1ba8:	93 81       	ldd	r25, Z+3	; 0x03
    1baa:	13 96       	adiw	r26, 0x03	; 3
    1bac:	9c 93       	st	X, r25
    1bae:	8e 93       	st	-X, r24
    1bb0:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1bb2:	89 81       	ldd	r24, Y+1	; 0x01
    1bb4:	9a 81       	ldd	r25, Y+2	; 0x02
    1bb6:	15 96       	adiw	r26, 0x05	; 5
    1bb8:	9c 93       	st	X, r25
    1bba:	8e 93       	st	-X, r24
    1bbc:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1bbe:	02 80       	ldd	r0, Z+2	; 0x02
    1bc0:	f3 81       	ldd	r31, Z+3	; 0x03
    1bc2:	e0 2d       	mov	r30, r0
    1bc4:	75 83       	std	Z+5, r23	; 0x05
    1bc6:	64 83       	std	Z+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1bc8:	e9 01       	movw	r28, r18
    1bca:	7b 83       	std	Y+3, r23	; 0x03
    1bcc:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    1bce:	fa 01       	movw	r30, r20
    1bd0:	72 83       	std	Z+2, r23	; 0x02
    1bd2:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1bd4:	19 96       	adiw	r26, 0x09	; 9
    1bd6:	5c 93       	st	X, r21
    1bd8:	4e 93       	st	-X, r20
    1bda:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
    1bdc:	80 81       	ld	r24, Z
    1bde:	8f 5f       	subi	r24, 0xFF	; 255
    1be0:	80 83       	st	Z, r24
}
    1be2:	df 91       	pop	r29
    1be4:	cf 91       	pop	r28
    1be6:	08 95       	ret

00001be8 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    1be8:	cf 93       	push	r28
    1bea:	df 93       	push	r29
    1bec:	9c 01       	movw	r18, r24
    1bee:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    1bf0:	48 81       	ld	r20, Y
    1bf2:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as 
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the 
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1bf4:	8f ef       	ldi	r24, 0xFF	; 255
    1bf6:	4f 3f       	cpi	r20, 0xFF	; 255
    1bf8:	58 07       	cpc	r21, r24
    1bfa:	21 f4       	brne	.+8      	; 0x1c04 <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1bfc:	f9 01       	movw	r30, r18
    1bfe:	a7 81       	ldd	r26, Z+7	; 0x07
    1c00:	b0 85       	ldd	r27, Z+8	; 0x08
    1c02:	10 c0       	rjmp	.+32     	; 0x1c24 <vListInsert+0x3c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips. 
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    1c04:	d9 01       	movw	r26, r18
    1c06:	13 96       	adiw	r26, 0x03	; 3
    1c08:	04 c0       	rjmp	.+8      	; 0x1c12 <vListInsert+0x2a>
    1c0a:	12 96       	adiw	r26, 0x02	; 2
    1c0c:	0d 90       	ld	r0, X+
    1c0e:	bc 91       	ld	r27, X
    1c10:	a0 2d       	mov	r26, r0
    1c12:	12 96       	adiw	r26, 0x02	; 2
    1c14:	ed 91       	ld	r30, X+
    1c16:	fc 91       	ld	r31, X
    1c18:	13 97       	sbiw	r26, 0x03	; 3
    1c1a:	80 81       	ld	r24, Z
    1c1c:	91 81       	ldd	r25, Z+1	; 0x01
    1c1e:	48 17       	cp	r20, r24
    1c20:	59 07       	cpc	r21, r25
    1c22:	98 f7       	brcc	.-26     	; 0x1c0a <vListInsert+0x22>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1c24:	12 96       	adiw	r26, 0x02	; 2
    1c26:	ed 91       	ld	r30, X+
    1c28:	fc 91       	ld	r31, X
    1c2a:	13 97       	sbiw	r26, 0x03	; 3
    1c2c:	fb 83       	std	Y+3, r31	; 0x03
    1c2e:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1c30:	d5 83       	std	Z+5, r29	; 0x05
    1c32:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1c34:	bd 83       	std	Y+5, r27	; 0x05
    1c36:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1c38:	13 96       	adiw	r26, 0x03	; 3
    1c3a:	dc 93       	st	X, r29
    1c3c:	ce 93       	st	-X, r28
    1c3e:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1c40:	39 87       	std	Y+9, r19	; 0x09
    1c42:	28 87       	std	Y+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    1c44:	f9 01       	movw	r30, r18
    1c46:	80 81       	ld	r24, Z
    1c48:	8f 5f       	subi	r24, 0xFF	; 255
    1c4a:	80 83       	st	Z, r24
}
    1c4c:	df 91       	pop	r29
    1c4e:	cf 91       	pop	r28
    1c50:	08 95       	ret

00001c52 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    1c52:	cf 93       	push	r28
    1c54:	df 93       	push	r29
    1c56:	dc 01       	movw	r26, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1c58:	12 96       	adiw	r26, 0x02	; 2
    1c5a:	ed 91       	ld	r30, X+
    1c5c:	fc 91       	ld	r31, X
    1c5e:	13 97       	sbiw	r26, 0x03	; 3
    1c60:	14 96       	adiw	r26, 0x04	; 4
    1c62:	8d 91       	ld	r24, X+
    1c64:	9c 91       	ld	r25, X
    1c66:	15 97       	sbiw	r26, 0x05	; 5
    1c68:	95 83       	std	Z+5, r25	; 0x05
    1c6a:	84 83       	std	Z+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1c6c:	14 96       	adiw	r26, 0x04	; 4
    1c6e:	cd 91       	ld	r28, X+
    1c70:	dc 91       	ld	r29, X
    1c72:	15 97       	sbiw	r26, 0x05	; 5
    1c74:	fb 83       	std	Y+3, r31	; 0x03
    1c76:	ea 83       	std	Y+2, r30	; 0x02
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1c78:	18 96       	adiw	r26, 0x08	; 8
    1c7a:	ed 91       	ld	r30, X+
    1c7c:	fc 91       	ld	r31, X
    1c7e:	19 97       	sbiw	r26, 0x09	; 9

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1c80:	81 81       	ldd	r24, Z+1	; 0x01
    1c82:	92 81       	ldd	r25, Z+2	; 0x02
    1c84:	8a 17       	cp	r24, r26
    1c86:	9b 07       	cpc	r25, r27
    1c88:	11 f4       	brne	.+4      	; 0x1c8e <vListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1c8a:	d2 83       	std	Z+2, r29	; 0x02
    1c8c:	c1 83       	std	Z+1, r28	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    1c8e:	19 96       	adiw	r26, 0x09	; 9
    1c90:	1c 92       	st	X, r1
    1c92:	1e 92       	st	-X, r1
    1c94:	18 97       	sbiw	r26, 0x08	; 8
	( pxList->uxNumberOfItems )--;
    1c96:	80 81       	ld	r24, Z
    1c98:	81 50       	subi	r24, 0x01	; 1
    1c9a:	80 83       	st	Z, r24
}
    1c9c:	df 91       	pop	r29
    1c9e:	cf 91       	pop	r28
    1ca0:	08 95       	ret

00001ca2 <uxQueueMessagesWaiting>:
	return xReturn;
}
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    1ca2:	fc 01       	movw	r30, r24
unsigned portBASE_TYPE uxReturn;

	taskENTER_CRITICAL();
    1ca4:	0f b6       	in	r0, 0x3f	; 63
    1ca6:	f8 94       	cli
    1ca8:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1caa:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    1cac:	0f 90       	pop	r0
    1cae:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    1cb0:	08 95       	ret

00001cb2 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    1cb2:	fc 01       	movw	r30, r24
unsigned portBASE_TYPE uxReturn;

	uxReturn = pxQueue->uxMessagesWaiting;
    1cb4:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
    1cb6:	08 95       	ret

00001cb8 <xQueueIsQueueEmptyFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    1cb8:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1cba:	82 8d       	ldd	r24, Z+26	; 0x1a
    1cbc:	90 e0       	ldi	r25, 0x00	; 0
    1cbe:	88 23       	and	r24, r24
    1cc0:	09 f4       	brne	.+2      	; 0x1cc4 <xQueueIsQueueEmptyFromISR+0xc>
    1cc2:	91 e0       	ldi	r25, 0x01	; 1

	return xReturn;
}
    1cc4:	89 2f       	mov	r24, r25
    1cc6:	08 95       	ret

00001cc8 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    1cc8:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    1cca:	92 8d       	ldd	r25, Z+26	; 0x1a
    1ccc:	20 e0       	ldi	r18, 0x00	; 0
    1cce:	83 8d       	ldd	r24, Z+27	; 0x1b
    1cd0:	98 17       	cp	r25, r24
    1cd2:	09 f4       	brne	.+2      	; 0x1cd6 <xQueueIsQueueFullFromISR+0xe>
    1cd4:	21 e0       	ldi	r18, 0x01	; 1

	return xReturn;
}
    1cd6:	82 2f       	mov	r24, r18
    1cd8:	08 95       	ret

00001cda <vQueueDelete>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    1cda:	0f 93       	push	r16
    1cdc:	1f 93       	push	r17
    1cde:	8c 01       	movw	r16, r24
	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    1ce0:	fc 01       	movw	r30, r24
    1ce2:	80 81       	ld	r24, Z
    1ce4:	91 81       	ldd	r25, Z+1	; 0x01
    1ce6:	0e 94 c6 18 	call	0x318c	; 0x318c <vPortFree>
	vPortFree( pxQueue );
    1cea:	c8 01       	movw	r24, r16
    1cec:	0e 94 c6 18 	call	0x318c	; 0x318c <vPortFree>
}
    1cf0:	1f 91       	pop	r17
    1cf2:	0f 91       	pop	r16
    1cf4:	08 95       	ret

00001cf6 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    1cf6:	0f 93       	push	r16
    1cf8:	1f 93       	push	r17
    1cfa:	cf 93       	push	r28
    1cfc:	df 93       	push	r29
    1cfe:	ec 01       	movw	r28, r24
    1d00:	fb 01       	movw	r30, r22
    1d02:	8a 01       	movw	r16, r20
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1d04:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1d06:	88 23       	and	r24, r24
    1d08:	81 f1       	breq	.+96     	; 0x1d6a <xQueueReceiveFromISR+0x74>
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    1d0a:	48 81       	ld	r20, Y
    1d0c:	59 81       	ldd	r21, Y+1	; 0x01
    1d0e:	41 15       	cp	r20, r1
    1d10:	51 05       	cpc	r21, r1
    1d12:	a9 f0       	breq	.+42     	; 0x1d3e <xQueueReceiveFromISR+0x48>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    1d14:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1d16:	2e 81       	ldd	r18, Y+6	; 0x06
    1d18:	3f 81       	ldd	r19, Y+7	; 0x07
    1d1a:	28 0f       	add	r18, r24
    1d1c:	31 1d       	adc	r19, r1
    1d1e:	3f 83       	std	Y+7, r19	; 0x07
    1d20:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    1d22:	8a 81       	ldd	r24, Y+2	; 0x02
    1d24:	9b 81       	ldd	r25, Y+3	; 0x03
    1d26:	28 17       	cp	r18, r24
    1d28:	39 07       	cpc	r19, r25
    1d2a:	10 f0       	brcs	.+4      	; 0x1d30 <xQueueReceiveFromISR+0x3a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    1d2c:	5f 83       	std	Y+7, r21	; 0x07
    1d2e:	4e 83       	std	Y+6, r20	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1d30:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1d32:	6e 81       	ldd	r22, Y+6	; 0x06
    1d34:	7f 81       	ldd	r23, Y+7	; 0x07
    1d36:	cf 01       	movw	r24, r30
    1d38:	50 e0       	ldi	r21, 0x00	; 0
    1d3a:	0e 94 ad 2a 	call	0x555a	; 0x555a <memcpy>
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
			--( pxQueue->uxMessagesWaiting );
    1d3e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1d40:	81 50       	subi	r24, 0x01	; 1
    1d42:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1d44:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1d46:	8f 3f       	cpi	r24, 0xFF	; 255
    1d48:	69 f4       	brne	.+26     	; 0x1d64 <xQueueReceiveFromISR+0x6e>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
    1d4a:	88 85       	ldd	r24, Y+8	; 0x08
    1d4c:	88 23       	and	r24, r24
    1d4e:	61 f0       	breq	.+24     	; 0x1d68 <xQueueReceiveFromISR+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1d50:	ce 01       	movw	r24, r28
    1d52:	08 96       	adiw	r24, 0x08	; 8
    1d54:	0e 94 db 11 	call	0x23b6	; 0x23b6 <xTaskRemoveFromEventList>
    1d58:	88 23       	and	r24, r24
    1d5a:	31 f0       	breq	.+12     	; 0x1d68 <xQueueReceiveFromISR+0x72>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    1d5c:	81 e0       	ldi	r24, 0x01	; 1
    1d5e:	f8 01       	movw	r30, r16
    1d60:	80 83       	st	Z, r24
    1d62:	03 c0       	rjmp	.+6      	; 0x1d6a <xQueueReceiveFromISR+0x74>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1d64:	8f 5f       	subi	r24, 0xFF	; 255
    1d66:	8d 8f       	std	Y+29, r24	; 0x1d
    1d68:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1d6a:	df 91       	pop	r29
    1d6c:	cf 91       	pop	r28
    1d6e:	1f 91       	pop	r17
    1d70:	0f 91       	pop	r16
    1d72:	08 95       	ret

00001d74 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    1d74:	cf 93       	push	r28
    1d76:	df 93       	push	r29
    1d78:	ec 01       	movw	r28, r24
    1d7a:	84 2f       	mov	r24, r20
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    1d7c:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1d7e:	44 23       	and	r20, r20
    1d80:	a1 f1       	breq	.+104    	; 0x1dea <prvCopyDataToQueue+0x76>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    1d82:	88 23       	and	r24, r24
    1d84:	b1 f4       	brne	.+44     	; 0x1db2 <prvCopyDataToQueue+0x3e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1d86:	8c 81       	ldd	r24, Y+4	; 0x04
    1d88:	9d 81       	ldd	r25, Y+5	; 0x05
    1d8a:	50 e0       	ldi	r21, 0x00	; 0
    1d8c:	0e 94 ad 2a 	call	0x555a	; 0x555a <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    1d90:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1d92:	2c 81       	ldd	r18, Y+4	; 0x04
    1d94:	3d 81       	ldd	r19, Y+5	; 0x05
    1d96:	28 0f       	add	r18, r24
    1d98:	31 1d       	adc	r19, r1
    1d9a:	3d 83       	std	Y+5, r19	; 0x05
    1d9c:	2c 83       	std	Y+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    1d9e:	8a 81       	ldd	r24, Y+2	; 0x02
    1da0:	9b 81       	ldd	r25, Y+3	; 0x03
    1da2:	28 17       	cp	r18, r24
    1da4:	39 07       	cpc	r19, r25
    1da6:	08 f1       	brcs	.+66     	; 0x1dea <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1da8:	88 81       	ld	r24, Y
    1daa:	99 81       	ldd	r25, Y+1	; 0x01
    1dac:	9d 83       	std	Y+5, r25	; 0x05
    1dae:	8c 83       	std	Y+4, r24	; 0x04
    1db0:	1c c0       	rjmp	.+56     	; 0x1dea <prvCopyDataToQueue+0x76>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1db2:	8e 81       	ldd	r24, Y+6	; 0x06
    1db4:	9f 81       	ldd	r25, Y+7	; 0x07
    1db6:	50 e0       	ldi	r21, 0x00	; 0
    1db8:	0e 94 ad 2a 	call	0x555a	; 0x555a <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    1dbc:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1dbe:	90 e0       	ldi	r25, 0x00	; 0
    1dc0:	44 27       	eor	r20, r20
    1dc2:	55 27       	eor	r21, r21
    1dc4:	48 1b       	sub	r20, r24
    1dc6:	59 0b       	sbc	r21, r25
    1dc8:	8e 81       	ldd	r24, Y+6	; 0x06
    1dca:	9f 81       	ldd	r25, Y+7	; 0x07
    1dcc:	84 0f       	add	r24, r20
    1dce:	95 1f       	adc	r25, r21
    1dd0:	9f 83       	std	Y+7, r25	; 0x07
    1dd2:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    1dd4:	28 81       	ld	r18, Y
    1dd6:	39 81       	ldd	r19, Y+1	; 0x01
    1dd8:	82 17       	cp	r24, r18
    1dda:	93 07       	cpc	r25, r19
    1ddc:	30 f4       	brcc	.+12     	; 0x1dea <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    1dde:	8a 81       	ldd	r24, Y+2	; 0x02
    1de0:	9b 81       	ldd	r25, Y+3	; 0x03
    1de2:	84 0f       	add	r24, r20
    1de4:	95 1f       	adc	r25, r21
    1de6:	9f 83       	std	Y+7, r25	; 0x07
    1de8:	8e 83       	std	Y+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    1dea:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1dec:	8f 5f       	subi	r24, 0xFF	; 255
    1dee:	8a 8f       	std	Y+26, r24	; 0x1a
}
    1df0:	df 91       	pop	r29
    1df2:	cf 91       	pop	r28
    1df4:	08 95       	ret

00001df6 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    1df6:	0f 93       	push	r16
    1df8:	1f 93       	push	r17
    1dfa:	cf 93       	push	r28
    1dfc:	df 93       	push	r29
    1dfe:	ec 01       	movw	r28, r24
    1e00:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1e02:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1e04:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1e06:	98 17       	cp	r25, r24
    1e08:	10 f0       	brcs	.+4      	; 0x1e0e <xQueueGenericSendFromISR+0x18>
    1e0a:	80 e0       	ldi	r24, 0x00	; 0
    1e0c:	17 c0       	rjmp	.+46     	; 0x1e3c <xQueueGenericSendFromISR+0x46>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1e0e:	ce 01       	movw	r24, r28
    1e10:	42 2f       	mov	r20, r18
    1e12:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1e16:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1e18:	8f 3f       	cpi	r24, 0xFF	; 255
    1e1a:	69 f4       	brne	.+26     	; 0x1e36 <xQueueGenericSendFromISR+0x40>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    1e1c:	89 89       	ldd	r24, Y+17	; 0x11
    1e1e:	88 23       	and	r24, r24
    1e20:	61 f0       	breq	.+24     	; 0x1e3a <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1e22:	ce 01       	movw	r24, r28
    1e24:	41 96       	adiw	r24, 0x11	; 17
    1e26:	0e 94 db 11 	call	0x23b6	; 0x23b6 <xTaskRemoveFromEventList>
    1e2a:	88 23       	and	r24, r24
    1e2c:	31 f0       	breq	.+12     	; 0x1e3a <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    1e2e:	81 e0       	ldi	r24, 0x01	; 1
    1e30:	f8 01       	movw	r30, r16
    1e32:	80 83       	st	Z, r24
    1e34:	03 c0       	rjmp	.+6      	; 0x1e3c <xQueueGenericSendFromISR+0x46>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1e36:	8f 5f       	subi	r24, 0xFF	; 255
    1e38:	8e 8f       	std	Y+30, r24	; 0x1e
    1e3a:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1e3c:	df 91       	pop	r29
    1e3e:	cf 91       	pop	r28
    1e40:	1f 91       	pop	r17
    1e42:	0f 91       	pop	r16
    1e44:	08 95       	ret

00001e46 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    1e46:	0f 93       	push	r16
    1e48:	1f 93       	push	r17
    1e4a:	cf 93       	push	r28
    1e4c:	df 93       	push	r29
    1e4e:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1e50:	0f b6       	in	r0, 0x3f	; 63
    1e52:	f8 94       	cli
    1e54:	0f 92       	push	r0
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1e56:	8c 01       	movw	r16, r24
    1e58:	0f 5e       	subi	r16, 0xEF	; 239
    1e5a:	1f 4f       	sbci	r17, 0xFF	; 255
    1e5c:	0d c0       	rjmp	.+26     	; 0x1e78 <prvUnlockQueue+0x32>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    1e5e:	89 89       	ldd	r24, Y+17	; 0x11
    1e60:	88 23       	and	r24, r24
    1e62:	69 f0       	breq	.+26     	; 0x1e7e <prvUnlockQueue+0x38>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1e64:	c8 01       	movw	r24, r16
    1e66:	0e 94 db 11 	call	0x23b6	; 0x23b6 <xTaskRemoveFromEventList>
    1e6a:	88 23       	and	r24, r24
    1e6c:	11 f0       	breq	.+4      	; 0x1e72 <prvUnlockQueue+0x2c>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    1e6e:	0e 94 d7 11 	call	0x23ae	; 0x23ae <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    1e72:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1e74:	81 50       	subi	r24, 0x01	; 1
    1e76:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1e78:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1e7a:	18 16       	cp	r1, r24
    1e7c:	84 f3       	brlt	.-32     	; 0x1e5e <prvUnlockQueue+0x18>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    1e7e:	8f ef       	ldi	r24, 0xFF	; 255
    1e80:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1e82:	0f 90       	pop	r0
    1e84:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1e86:	0f b6       	in	r0, 0x3f	; 63
    1e88:	f8 94       	cli
    1e8a:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1e8c:	8e 01       	movw	r16, r28
    1e8e:	08 5f       	subi	r16, 0xF8	; 248
    1e90:	1f 4f       	sbci	r17, 0xFF	; 255
    1e92:	0d c0       	rjmp	.+26     	; 0x1eae <prvUnlockQueue+0x68>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
    1e94:	88 85       	ldd	r24, Y+8	; 0x08
    1e96:	88 23       	and	r24, r24
    1e98:	69 f0       	breq	.+26     	; 0x1eb4 <prvUnlockQueue+0x6e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1e9a:	c8 01       	movw	r24, r16
    1e9c:	0e 94 db 11 	call	0x23b6	; 0x23b6 <xTaskRemoveFromEventList>
    1ea0:	88 23       	and	r24, r24
    1ea2:	11 f0       	breq	.+4      	; 0x1ea8 <prvUnlockQueue+0x62>
				{
					vTaskMissedYield();
    1ea4:	0e 94 d7 11 	call	0x23ae	; 0x23ae <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    1ea8:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1eaa:	81 50       	subi	r24, 0x01	; 1
    1eac:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1eae:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1eb0:	18 16       	cp	r1, r24
    1eb2:	84 f3       	brlt	.-32     	; 0x1e94 <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    1eb4:	8f ef       	ldi	r24, 0xFF	; 255
    1eb6:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1eb8:	0f 90       	pop	r0
    1eba:	0f be       	out	0x3f, r0	; 63
}
    1ebc:	df 91       	pop	r29
    1ebe:	cf 91       	pop	r28
    1ec0:	1f 91       	pop	r17
    1ec2:	0f 91       	pop	r16
    1ec4:	08 95       	ret

00001ec6 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    1ec6:	7f 92       	push	r7
    1ec8:	8f 92       	push	r8
    1eca:	9f 92       	push	r9
    1ecc:	af 92       	push	r10
    1ece:	bf 92       	push	r11
    1ed0:	cf 92       	push	r12
    1ed2:	df 92       	push	r13
    1ed4:	ef 92       	push	r14
    1ed6:	ff 92       	push	r15
    1ed8:	0f 93       	push	r16
    1eda:	1f 93       	push	r17
    1edc:	df 93       	push	r29
    1ede:	cf 93       	push	r28
    1ee0:	00 d0       	rcall	.+0      	; 0x1ee2 <xQueueGenericReceive+0x1c>
    1ee2:	00 d0       	rcall	.+0      	; 0x1ee4 <xQueueGenericReceive+0x1e>
    1ee4:	0f 92       	push	r0
    1ee6:	cd b7       	in	r28, 0x3d	; 61
    1ee8:	de b7       	in	r29, 0x3e	; 62
    1eea:	8c 01       	movw	r16, r24
    1eec:	96 2e       	mov	r9, r22
    1eee:	87 2e       	mov	r8, r23
    1ef0:	5d 83       	std	Y+5, r21	; 0x05
    1ef2:	4c 83       	std	Y+4, r20	; 0x04
    1ef4:	72 2e       	mov	r7, r18
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1ef6:	91 e1       	ldi	r25, 0x11	; 17
    1ef8:	c9 2e       	mov	r12, r25
    1efa:	d1 2c       	mov	r13, r1
    1efc:	c0 0e       	add	r12, r16
    1efe:	d1 1e       	adc	r13, r17
    1f00:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1f02:	7e 01       	movw	r14, r28
    1f04:	08 94       	sec
    1f06:	e1 1c       	adc	r14, r1
    1f08:	f1 1c       	adc	r15, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1f0a:	84 e0       	ldi	r24, 0x04	; 4
    1f0c:	a8 2e       	mov	r10, r24
    1f0e:	b1 2c       	mov	r11, r1
    1f10:	ac 0e       	add	r10, r28
    1f12:	bd 1e       	adc	r11, r29
    1f14:	01 c0       	rjmp	.+2      	; 0x1f18 <xQueueGenericReceive+0x52>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1f16:	21 e0       	ldi	r18, 0x01	; 1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1f18:	0f b6       	in	r0, 0x3f	; 63
    1f1a:	f8 94       	cli
    1f1c:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1f1e:	f8 01       	movw	r30, r16
    1f20:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f22:	88 23       	and	r24, r24
    1f24:	09 f4       	brne	.+2      	; 0x1f28 <xQueueGenericReceive+0x62>
    1f26:	3e c0       	rjmp	.+124    	; 0x1fa4 <xQueueGenericReceive+0xde>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1f28:	e6 80       	ldd	r14, Z+6	; 0x06
    1f2a:	f7 80       	ldd	r15, Z+7	; 0x07
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    1f2c:	40 81       	ld	r20, Z
    1f2e:	51 81       	ldd	r21, Z+1	; 0x01
    1f30:	41 15       	cp	r20, r1
    1f32:	51 05       	cpc	r21, r1
    1f34:	b1 f0       	breq	.+44     	; 0x1f62 <xQueueGenericReceive+0x9c>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    1f36:	84 8d       	ldd	r24, Z+28	; 0x1c
    1f38:	97 01       	movw	r18, r14
    1f3a:	28 0f       	add	r18, r24
    1f3c:	31 1d       	adc	r19, r1
    1f3e:	37 83       	std	Z+7, r19	; 0x07
    1f40:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    1f42:	82 81       	ldd	r24, Z+2	; 0x02
    1f44:	93 81       	ldd	r25, Z+3	; 0x03
    1f46:	28 17       	cp	r18, r24
    1f48:	39 07       	cpc	r19, r25
    1f4a:	10 f0       	brcs	.+4      	; 0x1f50 <xQueueGenericReceive+0x8a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    1f4c:	57 83       	std	Z+7, r21	; 0x07
    1f4e:	46 83       	std	Z+6, r20	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1f50:	f8 01       	movw	r30, r16
    1f52:	44 8d       	ldd	r20, Z+28	; 0x1c
    1f54:	66 81       	ldd	r22, Z+6	; 0x06
    1f56:	77 81       	ldd	r23, Z+7	; 0x07
    1f58:	89 2d       	mov	r24, r9
    1f5a:	98 2d       	mov	r25, r8
    1f5c:	50 e0       	ldi	r21, 0x00	; 0
    1f5e:	0e 94 ad 2a 	call	0x555a	; 0x555a <memcpy>
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
    1f62:	77 20       	and	r7, r7
    1f64:	71 f4       	brne	.+28     	; 0x1f82 <xQueueGenericReceive+0xbc>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1f66:	f8 01       	movw	r30, r16
    1f68:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f6a:	81 50       	subi	r24, 0x01	; 1
    1f6c:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1f6e:	80 85       	ldd	r24, Z+8	; 0x08
    1f70:	88 23       	and	r24, r24
    1f72:	a1 f0       	breq	.+40     	; 0x1f9c <xQueueGenericReceive+0xd6>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1f74:	c8 01       	movw	r24, r16
    1f76:	08 96       	adiw	r24, 0x08	; 8
    1f78:	0e 94 db 11 	call	0x23b6	; 0x23b6 <xTaskRemoveFromEventList>
    1f7c:	81 30       	cpi	r24, 0x01	; 1
    1f7e:	71 f4       	brne	.+28     	; 0x1f9c <xQueueGenericReceive+0xd6>
    1f80:	0b c0       	rjmp	.+22     	; 0x1f98 <xQueueGenericReceive+0xd2>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    1f82:	f8 01       	movw	r30, r16
    1f84:	f7 82       	std	Z+7, r15	; 0x07
    1f86:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    1f88:	81 89       	ldd	r24, Z+17	; 0x11
    1f8a:	88 23       	and	r24, r24
    1f8c:	39 f0       	breq	.+14     	; 0x1f9c <xQueueGenericReceive+0xd6>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1f8e:	c6 01       	movw	r24, r12
    1f90:	0e 94 db 11 	call	0x23b6	; 0x23b6 <xTaskRemoveFromEventList>
    1f94:	88 23       	and	r24, r24
    1f96:	11 f0       	breq	.+4      	; 0x1f9c <xQueueGenericReceive+0xd6>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    1f98:	0e 94 a3 16 	call	0x2d46	; 0x2d46 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    1f9c:	0f 90       	pop	r0
    1f9e:	0f be       	out	0x3f, r0	; 63
    1fa0:	81 e0       	ldi	r24, 0x01	; 1
    1fa2:	4a c0       	rjmp	.+148    	; 0x2038 <xQueueGenericReceive+0x172>
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1fa4:	8c 81       	ldd	r24, Y+4	; 0x04
    1fa6:	9d 81       	ldd	r25, Y+5	; 0x05
    1fa8:	89 2b       	or	r24, r25
    1faa:	19 f4       	brne	.+6      	; 0x1fb2 <xQueueGenericReceive+0xec>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1fac:	0f 90       	pop	r0
    1fae:	0f be       	out	0x3f, r0	; 63
    1fb0:	42 c0       	rjmp	.+132    	; 0x2036 <xQueueGenericReceive+0x170>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1fb2:	22 23       	and	r18, r18
    1fb4:	19 f4       	brne	.+6      	; 0x1fbc <xQueueGenericReceive+0xf6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1fb6:	c7 01       	movw	r24, r14
    1fb8:	0e 94 92 11 	call	0x2324	; 0x2324 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    1fbc:	0f 90       	pop	r0
    1fbe:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1fc0:	0e 94 36 11 	call	0x226c	; 0x226c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1fc4:	0f b6       	in	r0, 0x3f	; 63
    1fc6:	f8 94       	cli
    1fc8:	0f 92       	push	r0
    1fca:	f8 01       	movw	r30, r16
    1fcc:	85 8d       	ldd	r24, Z+29	; 0x1d
    1fce:	8f 3f       	cpi	r24, 0xFF	; 255
    1fd0:	09 f4       	brne	.+2      	; 0x1fd4 <xQueueGenericReceive+0x10e>
    1fd2:	15 8e       	std	Z+29, r1	; 0x1d
    1fd4:	f8 01       	movw	r30, r16
    1fd6:	86 8d       	ldd	r24, Z+30	; 0x1e
    1fd8:	8f 3f       	cpi	r24, 0xFF	; 255
    1fda:	09 f4       	brne	.+2      	; 0x1fde <xQueueGenericReceive+0x118>
    1fdc:	16 8e       	std	Z+30, r1	; 0x1e
    1fde:	0f 90       	pop	r0
    1fe0:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1fe2:	c7 01       	movw	r24, r14
    1fe4:	b5 01       	movw	r22, r10
    1fe6:	0e 94 9d 11 	call	0x233a	; 0x233a <xTaskCheckForTimeOut>
    1fea:	88 23       	and	r24, r24
    1fec:	f9 f4       	brne	.+62     	; 0x202c <xQueueGenericReceive+0x166>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1fee:	0f b6       	in	r0, 0x3f	; 63
    1ff0:	f8 94       	cli
    1ff2:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1ff4:	f8 01       	movw	r30, r16
    1ff6:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    1ff8:	0f 90       	pop	r0
    1ffa:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
    1ffc:	88 23       	and	r24, r24
    1ffe:	81 f4       	brne	.+32     	; 0x2020 <xQueueGenericReceive+0x15a>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2000:	6c 81       	ldd	r22, Y+4	; 0x04
    2002:	7d 81       	ldd	r23, Y+5	; 0x05
    2004:	c6 01       	movw	r24, r12
    2006:	0e 94 94 12 	call	0x2528	; 0x2528 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    200a:	c8 01       	movw	r24, r16
    200c:	0e 94 23 0f 	call	0x1e46	; 0x1e46 <prvUnlockQueue>
				if( !xTaskResumeAll() )
    2010:	0e 94 cd 12 	call	0x259a	; 0x259a <xTaskResumeAll>
    2014:	88 23       	and	r24, r24
    2016:	09 f0       	breq	.+2      	; 0x201a <xQueueGenericReceive+0x154>
    2018:	7e cf       	rjmp	.-260    	; 0x1f16 <xQueueGenericReceive+0x50>
				{
					portYIELD_WITHIN_API();
    201a:	0e 94 a3 16 	call	0x2d46	; 0x2d46 <vPortYield>
    201e:	7b cf       	rjmp	.-266    	; 0x1f16 <xQueueGenericReceive+0x50>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2020:	c8 01       	movw	r24, r16
    2022:	0e 94 23 0f 	call	0x1e46	; 0x1e46 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2026:	0e 94 cd 12 	call	0x259a	; 0x259a <xTaskResumeAll>
    202a:	75 cf       	rjmp	.-278    	; 0x1f16 <xQueueGenericReceive+0x50>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    202c:	c8 01       	movw	r24, r16
    202e:	0e 94 23 0f 	call	0x1e46	; 0x1e46 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2032:	0e 94 cd 12 	call	0x259a	; 0x259a <xTaskResumeAll>
    2036:	80 e0       	ldi	r24, 0x00	; 0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
    2038:	0f 90       	pop	r0
    203a:	0f 90       	pop	r0
    203c:	0f 90       	pop	r0
    203e:	0f 90       	pop	r0
    2040:	0f 90       	pop	r0
    2042:	cf 91       	pop	r28
    2044:	df 91       	pop	r29
    2046:	1f 91       	pop	r17
    2048:	0f 91       	pop	r16
    204a:	ff 90       	pop	r15
    204c:	ef 90       	pop	r14
    204e:	df 90       	pop	r13
    2050:	cf 90       	pop	r12
    2052:	bf 90       	pop	r11
    2054:	af 90       	pop	r10
    2056:	9f 90       	pop	r9
    2058:	8f 90       	pop	r8
    205a:	7f 90       	pop	r7
    205c:	08 95       	ret

0000205e <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    205e:	7f 92       	push	r7
    2060:	8f 92       	push	r8
    2062:	9f 92       	push	r9
    2064:	af 92       	push	r10
    2066:	bf 92       	push	r11
    2068:	cf 92       	push	r12
    206a:	df 92       	push	r13
    206c:	ef 92       	push	r14
    206e:	ff 92       	push	r15
    2070:	0f 93       	push	r16
    2072:	1f 93       	push	r17
    2074:	df 93       	push	r29
    2076:	cf 93       	push	r28
    2078:	00 d0       	rcall	.+0      	; 0x207a <xQueueGenericSend+0x1c>
    207a:	00 d0       	rcall	.+0      	; 0x207c <xQueueGenericSend+0x1e>
    207c:	0f 92       	push	r0
    207e:	cd b7       	in	r28, 0x3d	; 61
    2080:	de b7       	in	r29, 0x3e	; 62
    2082:	8c 01       	movw	r16, r24
    2084:	6b 01       	movw	r12, r22
    2086:	5d 83       	std	Y+5, r21	; 0x05
    2088:	4c 83       	std	Y+4, r20	; 0x04
    208a:	72 2e       	mov	r7, r18
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    208c:	48 e0       	ldi	r20, 0x08	; 8
    208e:	e4 2e       	mov	r14, r20
    2090:	f1 2c       	mov	r15, r1
    2092:	e8 0e       	add	r14, r24
    2094:	f9 1e       	adc	r15, r25
    2096:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2098:	5e 01       	movw	r10, r28
    209a:	08 94       	sec
    209c:	a1 1c       	adc	r10, r1
    209e:	b1 1c       	adc	r11, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    20a0:	34 e0       	ldi	r19, 0x04	; 4
    20a2:	83 2e       	mov	r8, r19
    20a4:	91 2c       	mov	r9, r1
    20a6:	8c 0e       	add	r8, r28
    20a8:	9d 1e       	adc	r9, r29
    20aa:	01 c0       	rjmp	.+2      	; 0x20ae <xQueueGenericSend+0x50>
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    20ac:	21 e0       	ldi	r18, 0x01	; 1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    20ae:	0f b6       	in	r0, 0x3f	; 63
    20b0:	f8 94       	cli
    20b2:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    20b4:	f8 01       	movw	r30, r16
    20b6:	92 8d       	ldd	r25, Z+26	; 0x1a
    20b8:	83 8d       	ldd	r24, Z+27	; 0x1b
    20ba:	98 17       	cp	r25, r24
    20bc:	a8 f4       	brcc	.+42     	; 0x20e8 <xQueueGenericSend+0x8a>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    20be:	c8 01       	movw	r24, r16
    20c0:	b6 01       	movw	r22, r12
    20c2:	47 2d       	mov	r20, r7
    20c4:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    20c8:	f8 01       	movw	r30, r16
    20ca:	81 89       	ldd	r24, Z+17	; 0x11
    20cc:	88 23       	and	r24, r24
    20ce:	41 f0       	breq	.+16     	; 0x20e0 <xQueueGenericSend+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    20d0:	c8 01       	movw	r24, r16
    20d2:	41 96       	adiw	r24, 0x11	; 17
    20d4:	0e 94 db 11 	call	0x23b6	; 0x23b6 <xTaskRemoveFromEventList>
    20d8:	81 30       	cpi	r24, 0x01	; 1
    20da:	11 f4       	brne	.+4      	; 0x20e0 <xQueueGenericSend+0x82>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    20dc:	0e 94 a3 16 	call	0x2d46	; 0x2d46 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    20e0:	0f 90       	pop	r0
    20e2:	0f be       	out	0x3f, r0	; 63
    20e4:	81 e0       	ldi	r24, 0x01	; 1
    20e6:	4c c0       	rjmp	.+152    	; 0x2180 <xQueueGenericSend+0x122>
				function. */
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    20e8:	8c 81       	ldd	r24, Y+4	; 0x04
    20ea:	9d 81       	ldd	r25, Y+5	; 0x05
    20ec:	89 2b       	or	r24, r25
    20ee:	19 f4       	brne	.+6      	; 0x20f6 <xQueueGenericSend+0x98>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    20f0:	0f 90       	pop	r0
    20f2:	0f be       	out	0x3f, r0	; 63
    20f4:	44 c0       	rjmp	.+136    	; 0x217e <xQueueGenericSend+0x120>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    20f6:	22 23       	and	r18, r18
    20f8:	19 f4       	brne	.+6      	; 0x2100 <xQueueGenericSend+0xa2>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    20fa:	c5 01       	movw	r24, r10
    20fc:	0e 94 92 11 	call	0x2324	; 0x2324 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    2100:	0f 90       	pop	r0
    2102:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2104:	0e 94 36 11 	call	0x226c	; 0x226c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2108:	0f b6       	in	r0, 0x3f	; 63
    210a:	f8 94       	cli
    210c:	0f 92       	push	r0
    210e:	f8 01       	movw	r30, r16
    2110:	85 8d       	ldd	r24, Z+29	; 0x1d
    2112:	8f 3f       	cpi	r24, 0xFF	; 255
    2114:	09 f4       	brne	.+2      	; 0x2118 <xQueueGenericSend+0xba>
    2116:	15 8e       	std	Z+29, r1	; 0x1d
    2118:	f8 01       	movw	r30, r16
    211a:	86 8d       	ldd	r24, Z+30	; 0x1e
    211c:	8f 3f       	cpi	r24, 0xFF	; 255
    211e:	09 f4       	brne	.+2      	; 0x2122 <xQueueGenericSend+0xc4>
    2120:	16 8e       	std	Z+30, r1	; 0x1e
    2122:	0f 90       	pop	r0
    2124:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2126:	c5 01       	movw	r24, r10
    2128:	b4 01       	movw	r22, r8
    212a:	0e 94 9d 11 	call	0x233a	; 0x233a <xTaskCheckForTimeOut>
    212e:	88 23       	and	r24, r24
    2130:	09 f5       	brne	.+66     	; 0x2174 <xQueueGenericSend+0x116>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    2132:	0f b6       	in	r0, 0x3f	; 63
    2134:	f8 94       	cli
    2136:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    2138:	f8 01       	movw	r30, r16
    213a:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    213c:	0f 90       	pop	r0
    213e:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
    2140:	f8 01       	movw	r30, r16
    2142:	83 8d       	ldd	r24, Z+27	; 0x1b
    2144:	98 17       	cp	r25, r24
    2146:	81 f4       	brne	.+32     	; 0x2168 <xQueueGenericSend+0x10a>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2148:	6c 81       	ldd	r22, Y+4	; 0x04
    214a:	7d 81       	ldd	r23, Y+5	; 0x05
    214c:	c7 01       	movw	r24, r14
    214e:	0e 94 94 12 	call	0x2528	; 0x2528 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    2152:	c8 01       	movw	r24, r16
    2154:	0e 94 23 0f 	call	0x1e46	; 0x1e46 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
    2158:	0e 94 cd 12 	call	0x259a	; 0x259a <xTaskResumeAll>
    215c:	88 23       	and	r24, r24
    215e:	09 f0       	breq	.+2      	; 0x2162 <xQueueGenericSend+0x104>
    2160:	a5 cf       	rjmp	.-182    	; 0x20ac <xQueueGenericSend+0x4e>
				{
					portYIELD_WITHIN_API();
    2162:	0e 94 a3 16 	call	0x2d46	; 0x2d46 <vPortYield>
    2166:	a2 cf       	rjmp	.-188    	; 0x20ac <xQueueGenericSend+0x4e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2168:	c8 01       	movw	r24, r16
    216a:	0e 94 23 0f 	call	0x1e46	; 0x1e46 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    216e:	0e 94 cd 12 	call	0x259a	; 0x259a <xTaskResumeAll>
    2172:	9c cf       	rjmp	.-200    	; 0x20ac <xQueueGenericSend+0x4e>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    2174:	c8 01       	movw	r24, r16
    2176:	0e 94 23 0f 	call	0x1e46	; 0x1e46 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    217a:	0e 94 cd 12 	call	0x259a	; 0x259a <xTaskResumeAll>
    217e:	80 e0       	ldi	r24, 0x00	; 0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
    2180:	0f 90       	pop	r0
    2182:	0f 90       	pop	r0
    2184:	0f 90       	pop	r0
    2186:	0f 90       	pop	r0
    2188:	0f 90       	pop	r0
    218a:	cf 91       	pop	r28
    218c:	df 91       	pop	r29
    218e:	1f 91       	pop	r17
    2190:	0f 91       	pop	r16
    2192:	ff 90       	pop	r15
    2194:	ef 90       	pop	r14
    2196:	df 90       	pop	r13
    2198:	cf 90       	pop	r12
    219a:	bf 90       	pop	r11
    219c:	af 90       	pop	r10
    219e:	9f 90       	pop	r9
    21a0:	8f 90       	pop	r8
    21a2:	7f 90       	pop	r7
    21a4:	08 95       	ret

000021a6 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    21a6:	8f 92       	push	r8
    21a8:	9f 92       	push	r9
    21aa:	af 92       	push	r10
    21ac:	bf 92       	push	r11
    21ae:	cf 92       	push	r12
    21b0:	df 92       	push	r13
    21b2:	ef 92       	push	r14
    21b4:	ff 92       	push	r15
    21b6:	0f 93       	push	r16
    21b8:	1f 93       	push	r17
    21ba:	cf 93       	push	r28
    21bc:	df 93       	push	r29
    21be:	98 2e       	mov	r9, r24
    21c0:	86 2e       	mov	r8, r22
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    21c2:	88 23       	and	r24, r24
    21c4:	09 f4       	brne	.+2      	; 0x21c8 <xQueueCreate+0x22>
    21c6:	42 c0       	rjmp	.+132    	; 0x224c <__stack+0x4d>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    21c8:	8f e1       	ldi	r24, 0x1F	; 31
    21ca:	90 e0       	ldi	r25, 0x00	; 0
    21cc:	0e 94 d6 18 	call	0x31ac	; 0x31ac <pvPortMalloc>
    21d0:	8c 01       	movw	r16, r24
    21d2:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    21d4:	00 97       	sbiw	r24, 0x00	; 0
    21d6:	e1 f1       	breq	.+120    	; 0x2250 <__stack+0x51>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    21d8:	c9 2c       	mov	r12, r9
    21da:	dd 24       	eor	r13, r13
    21dc:	a8 2c       	mov	r10, r8
    21de:	bb 24       	eor	r11, r11
    21e0:	ac 9c       	mul	r10, r12
    21e2:	70 01       	movw	r14, r0
    21e4:	ad 9c       	mul	r10, r13
    21e6:	f0 0c       	add	r15, r0
    21e8:	bc 9c       	mul	r11, r12
    21ea:	f0 0c       	add	r15, r0
    21ec:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    21ee:	c7 01       	movw	r24, r14
    21f0:	01 96       	adiw	r24, 0x01	; 1
    21f2:	0e 94 d6 18 	call	0x31ac	; 0x31ac <pvPortMalloc>
    21f6:	9c 01       	movw	r18, r24
    21f8:	99 83       	std	Y+1, r25	; 0x01
    21fa:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    21fc:	00 97       	sbiw	r24, 0x00	; 0
    21fe:	19 f1       	breq	.+70     	; 0x2246 <__stack+0x47>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    2200:	e8 0e       	add	r14, r24
    2202:	f9 1e       	adc	r15, r25
    2204:	fb 82       	std	Y+3, r15	; 0x03
    2206:	ea 82       	std	Y+2, r14	; 0x02
				pxNewQueue->uxMessagesWaiting = 0;
    2208:	1a 8e       	std	Y+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    220a:	9d 83       	std	Y+5, r25	; 0x05
    220c:	8c 83       	std	Y+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
    220e:	08 94       	sec
    2210:	c1 08       	sbc	r12, r1
    2212:	d1 08       	sbc	r13, r1
    2214:	ca 9c       	mul	r12, r10
    2216:	c0 01       	movw	r24, r0
    2218:	cb 9c       	mul	r12, r11
    221a:	90 0d       	add	r25, r0
    221c:	da 9c       	mul	r13, r10
    221e:	90 0d       	add	r25, r0
    2220:	11 24       	eor	r1, r1
    2222:	28 0f       	add	r18, r24
    2224:	39 1f       	adc	r19, r25
    2226:	3f 83       	std	Y+7, r19	; 0x07
    2228:	2e 83       	std	Y+6, r18	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    222a:	9b 8e       	std	Y+27, r9	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    222c:	8c 8e       	std	Y+28, r8	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    222e:	8f ef       	ldi	r24, 0xFF	; 255
    2230:	8d 8f       	std	Y+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    2232:	8e 8f       	std	Y+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    2234:	c8 01       	movw	r24, r16
    2236:	08 96       	adiw	r24, 0x08	; 8
    2238:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    223c:	c8 01       	movw	r24, r16
    223e:	41 96       	adiw	r24, 0x11	; 17
    2240:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vListInitialise>
    2244:	05 c0       	rjmp	.+10     	; 0x2250 <__stack+0x51>
				return  pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    2246:	c8 01       	movw	r24, r16
    2248:	0e 94 c6 18 	call	0x318c	; 0x318c <vPortFree>
    224c:	c0 e0       	ldi	r28, 0x00	; 0
    224e:	d0 e0       	ldi	r29, 0x00	; 0
	}

	/* Will only reach here if we could not allocate enough memory or no memory
	was required. */
	return NULL;
}
    2250:	ce 01       	movw	r24, r28
    2252:	df 91       	pop	r29
    2254:	cf 91       	pop	r28
    2256:	1f 91       	pop	r17
    2258:	0f 91       	pop	r16
    225a:	ff 90       	pop	r15
    225c:	ef 90       	pop	r14
    225e:	df 90       	pop	r13
    2260:	cf 90       	pop	r12
    2262:	bf 90       	pop	r11
    2264:	af 90       	pop	r10
    2266:	9f 90       	pop	r9
    2268:	8f 90       	pop	r8
    226a:	08 95       	ret

0000226c <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    226c:	80 91 2d 03 	lds	r24, 0x032D
    2270:	8f 5f       	subi	r24, 0xFF	; 255
    2272:	80 93 2d 03 	sts	0x032D, r24
}
    2276:	08 95       	ret

00002278 <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portENTER_CRITICAL();
    2278:	0f b6       	in	r0, 0x3f	; 63
    227a:	f8 94       	cli
    227c:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    227e:	20 91 2b 03 	lds	r18, 0x032B
    2282:	30 91 2c 03 	lds	r19, 0x032C
	}
	portEXIT_CRITICAL();
    2286:	0f 90       	pop	r0
    2288:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    228a:	c9 01       	movw	r24, r18
    228c:	08 95       	ret

0000228e <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
	return xTickCount;
    228e:	20 91 2b 03 	lds	r18, 0x032B
    2292:	30 91 2c 03 	lds	r19, 0x032C
}
    2296:	c9 01       	movw	r24, r18
    2298:	08 95       	ret

0000229a <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    229a:	80 91 30 03 	lds	r24, 0x0330
}
    229e:	08 95       	ret

000022a0 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    22a0:	80 91 2d 03 	lds	r24, 0x032D
    22a4:	88 23       	and	r24, r24
    22a6:	51 f0       	breq	.+20     	; 0x22bc <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    22a8:	81 e0       	ldi	r24, 0x01	; 1
    22aa:	80 93 29 03 	sts	0x0329, r24
    22ae:	08 95       	ret
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
	{
		--uxTopReadyPriority;
    22b0:	80 91 2e 03 	lds	r24, 0x032E
    22b4:	81 50       	subi	r24, 0x01	; 1
    22b6:	80 93 2e 03 	sts	0x032E, r24
    22ba:	01 c0       	rjmp	.+2      	; 0x22be <vTaskSwitchContext+0x1e>

	taskFIRST_CHECK_FOR_STACK_OVERFLOW();
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    22bc:	99 e0       	ldi	r25, 0x09	; 9
    22be:	e0 91 2e 03 	lds	r30, 0x032E
    22c2:	e9 9f       	mul	r30, r25
    22c4:	f0 01       	movw	r30, r0
    22c6:	11 24       	eor	r1, r1
    22c8:	eb 5c       	subi	r30, 0xCB	; 203
    22ca:	fc 4f       	sbci	r31, 0xFC	; 252
    22cc:	80 81       	ld	r24, Z
    22ce:	88 23       	and	r24, r24
    22d0:	79 f3       	breq	.-34     	; 0x22b0 <vTaskSwitchContext+0x10>
		--uxTopReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    22d2:	90 91 2e 03 	lds	r25, 0x032E
    22d6:	89 e0       	ldi	r24, 0x09	; 9
    22d8:	98 9f       	mul	r25, r24
    22da:	d0 01       	movw	r26, r0
    22dc:	11 24       	eor	r1, r1
    22de:	ab 5c       	subi	r26, 0xCB	; 203
    22e0:	bc 4f       	sbci	r27, 0xFC	; 252
    22e2:	11 96       	adiw	r26, 0x01	; 1
    22e4:	ed 91       	ld	r30, X+
    22e6:	fc 91       	ld	r31, X
    22e8:	12 97       	sbiw	r26, 0x02	; 2
    22ea:	02 80       	ldd	r0, Z+2	; 0x02
    22ec:	f3 81       	ldd	r31, Z+3	; 0x03
    22ee:	e0 2d       	mov	r30, r0
    22f0:	12 96       	adiw	r26, 0x02	; 2
    22f2:	fc 93       	st	X, r31
    22f4:	ee 93       	st	-X, r30
    22f6:	11 97       	sbiw	r26, 0x01	; 1
    22f8:	cd 01       	movw	r24, r26
    22fa:	03 96       	adiw	r24, 0x03	; 3
    22fc:	e8 17       	cp	r30, r24
    22fe:	f9 07       	cpc	r31, r25
    2300:	31 f4       	brne	.+12     	; 0x230e <vTaskSwitchContext+0x6e>
    2302:	82 81       	ldd	r24, Z+2	; 0x02
    2304:	93 81       	ldd	r25, Z+3	; 0x03
    2306:	12 96       	adiw	r26, 0x02	; 2
    2308:	9c 93       	st	X, r25
    230a:	8e 93       	st	-X, r24
    230c:	11 97       	sbiw	r26, 0x01	; 1
    230e:	11 96       	adiw	r26, 0x01	; 1
    2310:	ed 91       	ld	r30, X+
    2312:	fc 91       	ld	r31, X
    2314:	12 97       	sbiw	r26, 0x02	; 2
    2316:	86 81       	ldd	r24, Z+6	; 0x06
    2318:	97 81       	ldd	r25, Z+7	; 0x07
    231a:	90 93 28 03 	sts	0x0328, r25
    231e:	80 93 27 03 	sts	0x0327, r24
    2322:	08 95       	ret

00002324 <vTaskSetTimeOutState>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    2324:	fc 01       	movw	r30, r24
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2326:	80 91 2a 03 	lds	r24, 0x032A
    232a:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    232c:	80 91 2b 03 	lds	r24, 0x032B
    2330:	90 91 2c 03 	lds	r25, 0x032C
    2334:	92 83       	std	Z+2, r25	; 0x02
    2336:	81 83       	std	Z+1, r24	; 0x01
}
    2338:	08 95       	ret

0000233a <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    233a:	fc 01       	movw	r30, r24
    233c:	db 01       	movw	r26, r22
portBASE_TYPE xReturn;

	portENTER_CRITICAL();
    233e:	0f b6       	in	r0, 0x3f	; 63
    2340:	f8 94       	cli
    2342:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    2344:	90 91 2a 03 	lds	r25, 0x032A
    2348:	80 81       	ld	r24, Z
    234a:	98 17       	cp	r25, r24
    234c:	49 f0       	breq	.+18     	; 0x2360 <xTaskCheckForTimeOut+0x26>
    234e:	20 91 2b 03 	lds	r18, 0x032B
    2352:	30 91 2c 03 	lds	r19, 0x032C
    2356:	81 81       	ldd	r24, Z+1	; 0x01
    2358:	92 81       	ldd	r25, Z+2	; 0x02
    235a:	28 17       	cp	r18, r24
    235c:	39 07       	cpc	r19, r25
    235e:	18 f5       	brcc	.+70     	; 0x23a6 <xTaskCheckForTimeOut+0x6c>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    2360:	80 91 2b 03 	lds	r24, 0x032B
    2364:	90 91 2c 03 	lds	r25, 0x032C
    2368:	21 81       	ldd	r18, Z+1	; 0x01
    236a:	32 81       	ldd	r19, Z+2	; 0x02
    236c:	4d 91       	ld	r20, X+
    236e:	5c 91       	ld	r21, X
    2370:	11 97       	sbiw	r26, 0x01	; 1
    2372:	82 1b       	sub	r24, r18
    2374:	93 0b       	sbc	r25, r19
    2376:	84 17       	cp	r24, r20
    2378:	95 07       	cpc	r25, r21
    237a:	a8 f4       	brcc	.+42     	; 0x23a6 <xTaskCheckForTimeOut+0x6c>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    237c:	80 91 2b 03 	lds	r24, 0x032B
    2380:	90 91 2c 03 	lds	r25, 0x032C
    2384:	28 1b       	sub	r18, r24
    2386:	39 0b       	sbc	r19, r25
    2388:	24 0f       	add	r18, r20
    238a:	35 1f       	adc	r19, r21
    238c:	2d 93       	st	X+, r18
    238e:	3c 93       	st	X, r19
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2390:	80 91 2a 03 	lds	r24, 0x032A
    2394:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    2396:	80 91 2b 03 	lds	r24, 0x032B
    239a:	90 91 2c 03 	lds	r25, 0x032C
    239e:	92 83       	std	Z+2, r25	; 0x02
    23a0:	81 83       	std	Z+1, r24	; 0x01
    23a2:	80 e0       	ldi	r24, 0x00	; 0
    23a4:	01 c0       	rjmp	.+2      	; 0x23a8 <xTaskCheckForTimeOut+0x6e>
    23a6:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			xReturn = pdTRUE;
		}
	}
	portEXIT_CRITICAL();
    23a8:	0f 90       	pop	r0
    23aa:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    23ac:	08 95       	ret

000023ae <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    23ae:	81 e0       	ldi	r24, 0x01	; 1
    23b0:	80 93 29 03 	sts	0x0329, r24
}
    23b4:	08 95       	ret

000023b6 <xTaskRemoveFromEventList>:
	#endif
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    23b6:	0f 93       	push	r16
    23b8:	1f 93       	push	r17
    23ba:	cf 93       	push	r28
    23bc:	df 93       	push	r29
    23be:	fc 01       	movw	r30, r24
	it to the ready list.

	If an event is for a queue that is locked then this function will never
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    23c0:	80 81       	ld	r24, Z
    23c2:	88 23       	and	r24, r24
    23c4:	19 f4       	brne	.+6      	; 0x23cc <xTaskRemoveFromEventList+0x16>
    23c6:	c0 e0       	ldi	r28, 0x00	; 0
    23c8:	d0 e0       	ldi	r29, 0x00	; 0
    23ca:	05 c0       	rjmp	.+10     	; 0x23d6 <xTaskRemoveFromEventList+0x20>
    23cc:	05 80       	ldd	r0, Z+5	; 0x05
    23ce:	f6 81       	ldd	r31, Z+6	; 0x06
    23d0:	e0 2d       	mov	r30, r0
    23d2:	c6 81       	ldd	r28, Z+6	; 0x06
    23d4:	d7 81       	ldd	r29, Z+7	; 0x07
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    23d6:	8e 01       	movw	r16, r28
    23d8:	04 5f       	subi	r16, 0xF4	; 244
    23da:	1f 4f       	sbci	r17, 0xFF	; 255
    23dc:	c8 01       	movw	r24, r16
    23de:	0e 94 29 0e 	call	0x1c52	; 0x1c52 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    23e2:	80 91 2d 03 	lds	r24, 0x032D
    23e6:	88 23       	and	r24, r24
    23e8:	a1 f4       	brne	.+40     	; 0x2412 <xTaskRemoveFromEventList+0x5c>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    23ea:	8e 01       	movw	r16, r28
    23ec:	0e 5f       	subi	r16, 0xFE	; 254
    23ee:	1f 4f       	sbci	r17, 0xFF	; 255
    23f0:	c8 01       	movw	r24, r16
    23f2:	0e 94 29 0e 	call	0x1c52	; 0x1c52 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    23f6:	9e 89       	ldd	r25, Y+22	; 0x16
    23f8:	80 91 2e 03 	lds	r24, 0x032E
    23fc:	89 17       	cp	r24, r25
    23fe:	10 f4       	brcc	.+4      	; 0x2404 <xTaskRemoveFromEventList+0x4e>
    2400:	90 93 2e 03 	sts	0x032E, r25
    2404:	89 e0       	ldi	r24, 0x09	; 9
    2406:	98 9f       	mul	r25, r24
    2408:	c0 01       	movw	r24, r0
    240a:	11 24       	eor	r1, r1
    240c:	8b 5c       	subi	r24, 0xCB	; 203
    240e:	9c 4f       	sbci	r25, 0xFC	; 252
    2410:	02 c0       	rjmp	.+4      	; 0x2416 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2412:	8f e6       	ldi	r24, 0x6F	; 111
    2414:	93 e0       	ldi	r25, 0x03	; 3
    2416:	b8 01       	movw	r22, r16
    2418:	0e 94 cb 0d 	call	0x1b96	; 0x1b96 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    241c:	e0 91 27 03 	lds	r30, 0x0327
    2420:	f0 91 28 03 	lds	r31, 0x0328
    2424:	20 e0       	ldi	r18, 0x00	; 0
    2426:	9e 89       	ldd	r25, Y+22	; 0x16
    2428:	86 89       	ldd	r24, Z+22	; 0x16
    242a:	98 17       	cp	r25, r24
    242c:	08 f0       	brcs	.+2      	; 0x2430 <xTaskRemoveFromEventList+0x7a>
    242e:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    2430:	82 2f       	mov	r24, r18
    2432:	df 91       	pop	r29
    2434:	cf 91       	pop	r28
    2436:	1f 91       	pop	r17
    2438:	0f 91       	pop	r16
    243a:	08 95       	ret

0000243c <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
    243c:	ff 92       	push	r15
    243e:	0f 93       	push	r16
    2440:	1f 93       	push	r17
    2442:	cf 93       	push	r28
    2444:	df 93       	push	r29
	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2446:	80 91 2d 03 	lds	r24, 0x032D
    244a:	88 23       	and	r24, r24
    244c:	09 f0       	breq	.+2      	; 0x2450 <vTaskIncrementTick+0x14>
    244e:	61 c0       	rjmp	.+194    	; 0x2512 <vTaskIncrementTick+0xd6>
	{
		++xTickCount;
    2450:	80 91 2b 03 	lds	r24, 0x032B
    2454:	90 91 2c 03 	lds	r25, 0x032C
    2458:	01 96       	adiw	r24, 0x01	; 1
    245a:	90 93 2c 03 	sts	0x032C, r25
    245e:	80 93 2b 03 	sts	0x032B, r24
		if( xTickCount == ( portTickType ) 0 )
    2462:	80 91 2b 03 	lds	r24, 0x032B
    2466:	90 91 2c 03 	lds	r25, 0x032C
    246a:	89 2b       	or	r24, r25
    246c:	e9 f5       	brne	.+122    	; 0x24e8 <vTaskIncrementTick+0xac>
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			pxTemp = pxDelayedTaskList;
    246e:	80 91 6b 03 	lds	r24, 0x036B
    2472:	90 91 6c 03 	lds	r25, 0x036C
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    2476:	20 91 6d 03 	lds	r18, 0x036D
    247a:	30 91 6e 03 	lds	r19, 0x036E
    247e:	30 93 6c 03 	sts	0x036C, r19
    2482:	20 93 6b 03 	sts	0x036B, r18
			pxOverflowDelayedTaskList = pxTemp;
    2486:	90 93 6e 03 	sts	0x036E, r25
    248a:	80 93 6d 03 	sts	0x036D, r24
			xNumOfOverflows++;
    248e:	80 91 2a 03 	lds	r24, 0x032A
    2492:	8f 5f       	subi	r24, 0xFF	; 255
    2494:	80 93 2a 03 	sts	0x032A, r24
    2498:	27 c0       	rjmp	.+78     	; 0x24e8 <vTaskIncrementTick+0xac>
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    249a:	20 91 2b 03 	lds	r18, 0x032B
    249e:	30 91 2c 03 	lds	r19, 0x032C
    24a2:	8a 81       	ldd	r24, Y+2	; 0x02
    24a4:	9b 81       	ldd	r25, Y+3	; 0x03
    24a6:	28 17       	cp	r18, r24
    24a8:	39 07       	cpc	r19, r25
    24aa:	c0 f1       	brcs	.+112    	; 0x251c <vTaskIncrementTick+0xe0>
    24ac:	8e 01       	movw	r16, r28
    24ae:	0e 5f       	subi	r16, 0xFE	; 254
    24b0:	1f 4f       	sbci	r17, 0xFF	; 255
    24b2:	c8 01       	movw	r24, r16
    24b4:	0e 94 29 0e 	call	0x1c52	; 0x1c52 <vListRemove>
    24b8:	8c 89       	ldd	r24, Y+20	; 0x14
    24ba:	9d 89       	ldd	r25, Y+21	; 0x15
    24bc:	89 2b       	or	r24, r25
    24be:	21 f0       	breq	.+8      	; 0x24c8 <vTaskIncrementTick+0x8c>
    24c0:	ce 01       	movw	r24, r28
    24c2:	0c 96       	adiw	r24, 0x0c	; 12
    24c4:	0e 94 29 0e 	call	0x1c52	; 0x1c52 <vListRemove>
    24c8:	9e 89       	ldd	r25, Y+22	; 0x16
    24ca:	80 91 2e 03 	lds	r24, 0x032E
    24ce:	89 17       	cp	r24, r25
    24d0:	10 f4       	brcc	.+4      	; 0x24d6 <vTaskIncrementTick+0x9a>
    24d2:	90 93 2e 03 	sts	0x032E, r25
    24d6:	9f 9d       	mul	r25, r15
    24d8:	c0 01       	movw	r24, r0
    24da:	11 24       	eor	r1, r1
    24dc:	8b 5c       	subi	r24, 0xCB	; 203
    24de:	9c 4f       	sbci	r25, 0xFC	; 252
    24e0:	b8 01       	movw	r22, r16
    24e2:	0e 94 cb 0d 	call	0x1b96	; 0x1b96 <vListInsertEnd>
    24e6:	02 c0       	rjmp	.+4      	; 0x24ec <vTaskIncrementTick+0xb0>
    24e8:	89 e0       	ldi	r24, 0x09	; 9
    24ea:	f8 2e       	mov	r15, r24
    24ec:	e0 91 6b 03 	lds	r30, 0x036B
    24f0:	f0 91 6c 03 	lds	r31, 0x036C
    24f4:	80 81       	ld	r24, Z
    24f6:	88 23       	and	r24, r24
    24f8:	89 f0       	breq	.+34     	; 0x251c <vTaskIncrementTick+0xe0>
    24fa:	e0 91 6b 03 	lds	r30, 0x036B
    24fe:	f0 91 6c 03 	lds	r31, 0x036C
    2502:	05 80       	ldd	r0, Z+5	; 0x05
    2504:	f6 81       	ldd	r31, Z+6	; 0x06
    2506:	e0 2d       	mov	r30, r0
    2508:	c6 81       	ldd	r28, Z+6	; 0x06
    250a:	d7 81       	ldd	r29, Z+7	; 0x07
    250c:	20 97       	sbiw	r28, 0x00	; 0
    250e:	29 f6       	brne	.-118    	; 0x249a <vTaskIncrementTick+0x5e>
    2510:	05 c0       	rjmp	.+10     	; 0x251c <vTaskIncrementTick+0xe0>
	}
	else
	{
		++uxMissedTicks;
    2512:	80 91 2f 03 	lds	r24, 0x032F
    2516:	8f 5f       	subi	r24, 0xFF	; 255
    2518:	80 93 2f 03 	sts	0x032F, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    251c:	df 91       	pop	r29
    251e:	cf 91       	pop	r28
    2520:	1f 91       	pop	r17
    2522:	0f 91       	pop	r16
    2524:	ff 90       	pop	r15
    2526:	08 95       	ret

00002528 <vTaskPlaceOnEventList>:
	vWriteTraceToBuffer();
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2528:	0f 93       	push	r16
    252a:	1f 93       	push	r17
    252c:	8b 01       	movw	r16, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    252e:	60 91 27 03 	lds	r22, 0x0327
    2532:	70 91 28 03 	lds	r23, 0x0328
    2536:	64 5f       	subi	r22, 0xF4	; 244
    2538:	7f 4f       	sbci	r23, 0xFF	; 255
    253a:	0e 94 f4 0d 	call	0x1be8	; 0x1be8 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    253e:	80 91 27 03 	lds	r24, 0x0327
    2542:	90 91 28 03 	lds	r25, 0x0328
    2546:	02 96       	adiw	r24, 0x02	; 2
    2548:	0e 94 29 0e 	call	0x1c52	; 0x1c52 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    254c:	80 91 2b 03 	lds	r24, 0x032B
    2550:	90 91 2c 03 	lds	r25, 0x032C
    2554:	80 0f       	add	r24, r16
    2556:	91 1f       	adc	r25, r17

			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    2558:	e0 91 27 03 	lds	r30, 0x0327
    255c:	f0 91 28 03 	lds	r31, 0x0328
    2560:	93 83       	std	Z+3, r25	; 0x03
    2562:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xTickCount )
    2564:	20 91 2b 03 	lds	r18, 0x032B
    2568:	30 91 2c 03 	lds	r19, 0x032C
    256c:	82 17       	cp	r24, r18
    256e:	93 07       	cpc	r25, r19
    2570:	28 f4       	brcc	.+10     	; 0x257c <vTaskPlaceOnEventList+0x54>
			{
				/* Wake time has overflowed.  Place this item in the overflow list. */
				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2572:	80 91 6d 03 	lds	r24, 0x036D
    2576:	90 91 6e 03 	lds	r25, 0x036E
    257a:	04 c0       	rjmp	.+8      	; 0x2584 <vTaskPlaceOnEventList+0x5c>
			}
			else
			{
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    257c:	80 91 6b 03 	lds	r24, 0x036B
    2580:	90 91 6c 03 	lds	r25, 0x036C
    2584:	60 91 27 03 	lds	r22, 0x0327
    2588:	70 91 28 03 	lds	r23, 0x0328
    258c:	6e 5f       	subi	r22, 0xFE	; 254
    258e:	7f 4f       	sbci	r23, 0xFF	; 255
    2590:	0e 94 f4 0d 	call	0x1be8	; 0x1be8 <vListInsert>
			}
	}
	#endif
}
    2594:	1f 91       	pop	r17
    2596:	0f 91       	pop	r16
    2598:	08 95       	ret

0000259a <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    259a:	cf 92       	push	r12
    259c:	df 92       	push	r13
    259e:	ff 92       	push	r15
    25a0:	0f 93       	push	r16
    25a2:	1f 93       	push	r17
    25a4:	df 93       	push	r29
    25a6:	cf 93       	push	r28
    25a8:	0f 92       	push	r0
    25aa:	cd b7       	in	r28, 0x3d	; 61
    25ac:	de b7       	in	r29, 0x3e	; 62
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	portENTER_CRITICAL();
    25ae:	0f b6       	in	r0, 0x3f	; 63
    25b0:	f8 94       	cli
    25b2:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    25b4:	80 91 2d 03 	lds	r24, 0x032D
    25b8:	81 50       	subi	r24, 0x01	; 1
    25ba:	80 93 2d 03 	sts	0x032D, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    25be:	80 91 2d 03 	lds	r24, 0x032D
    25c2:	88 23       	and	r24, r24
    25c4:	09 f0       	breq	.+2      	; 0x25c8 <xTaskResumeAll+0x2e>
    25c6:	5b c0       	rjmp	.+182    	; 0x267e <xTaskResumeAll+0xe4>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
    25c8:	80 91 30 03 	lds	r24, 0x0330
    25cc:	88 23       	and	r24, r24
    25ce:	09 f4       	brne	.+2      	; 0x25d2 <xTaskResumeAll+0x38>
    25d0:	56 c0       	rjmp	.+172    	; 0x267e <xTaskResumeAll+0xe4>
    25d2:	19 82       	std	Y+1, r1	; 0x01
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    25d4:	99 e0       	ldi	r25, 0x09	; 9
    25d6:	f9 2e       	mov	r15, r25
    25d8:	27 c0       	rjmp	.+78     	; 0x2628 <xTaskResumeAll+0x8e>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
    25da:	c6 01       	movw	r24, r12
    25dc:	0c 96       	adiw	r24, 0x0c	; 12
    25de:	0e 94 29 0e 	call	0x1c52	; 0x1c52 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    25e2:	86 01       	movw	r16, r12
    25e4:	0e 5f       	subi	r16, 0xFE	; 254
    25e6:	1f 4f       	sbci	r17, 0xFF	; 255
    25e8:	c8 01       	movw	r24, r16
    25ea:	0e 94 29 0e 	call	0x1c52	; 0x1c52 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    25ee:	d6 01       	movw	r26, r12
    25f0:	56 96       	adiw	r26, 0x16	; 22
    25f2:	9c 91       	ld	r25, X
    25f4:	80 91 2e 03 	lds	r24, 0x032E
    25f8:	89 17       	cp	r24, r25
    25fa:	10 f4       	brcc	.+4      	; 0x2600 <xTaskResumeAll+0x66>
    25fc:	90 93 2e 03 	sts	0x032E, r25
    2600:	9f 9d       	mul	r25, r15
    2602:	c0 01       	movw	r24, r0
    2604:	11 24       	eor	r1, r1
    2606:	8b 5c       	subi	r24, 0xCB	; 203
    2608:	9c 4f       	sbci	r25, 0xFC	; 252
    260a:	b8 01       	movw	r22, r16
    260c:	0e 94 cb 0d 	call	0x1b96	; 0x1b96 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2610:	e0 91 27 03 	lds	r30, 0x0327
    2614:	f0 91 28 03 	lds	r31, 0x0328
    2618:	d6 01       	movw	r26, r12
    261a:	56 96       	adiw	r26, 0x16	; 22
    261c:	9c 91       	ld	r25, X
    261e:	86 89       	ldd	r24, Z+22	; 0x16
    2620:	98 17       	cp	r25, r24
    2622:	10 f0       	brcs	.+4      	; 0x2628 <xTaskResumeAll+0x8e>
    2624:	b1 e0       	ldi	r27, 0x01	; 1
    2626:	b9 83       	std	Y+1, r27	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
    2628:	80 91 6f 03 	lds	r24, 0x036F
    262c:	88 23       	and	r24, r24
    262e:	49 f0       	breq	.+18     	; 0x2642 <xTaskResumeAll+0xa8>
    2630:	e0 91 74 03 	lds	r30, 0x0374
    2634:	f0 91 75 03 	lds	r31, 0x0375
    2638:	c6 80       	ldd	r12, Z+6	; 0x06
    263a:	d7 80       	ldd	r13, Z+7	; 0x07
    263c:	c1 14       	cp	r12, r1
    263e:	d1 04       	cpc	r13, r1
    2640:	61 f6       	brne	.-104    	; 0x25da <xTaskResumeAll+0x40>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    2642:	80 91 2f 03 	lds	r24, 0x032F
    2646:	88 23       	and	r24, r24
    2648:	41 f4       	brne	.+16     	; 0x265a <xTaskResumeAll+0xc0>
    264a:	0c c0       	rjmp	.+24     	; 0x2664 <xTaskResumeAll+0xca>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
    264c:	0e 94 1e 12 	call	0x243c	; 0x243c <vTaskIncrementTick>
						--uxMissedTicks;
    2650:	80 91 2f 03 	lds	r24, 0x032F
    2654:	81 50       	subi	r24, 0x01	; 1
    2656:	80 93 2f 03 	sts	0x032F, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    265a:	80 91 2f 03 	lds	r24, 0x032F
    265e:	88 23       	and	r24, r24
    2660:	a9 f7       	brne	.-22     	; 0x264c <xTaskResumeAll+0xb2>
    2662:	07 c0       	rjmp	.+14     	; 0x2672 <xTaskResumeAll+0xd8>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    2664:	e9 81       	ldd	r30, Y+1	; 0x01
    2666:	e1 30       	cpi	r30, 0x01	; 1
    2668:	21 f0       	breq	.+8      	; 0x2672 <xTaskResumeAll+0xd8>
    266a:	80 91 29 03 	lds	r24, 0x0329
    266e:	81 30       	cpi	r24, 0x01	; 1
    2670:	31 f4       	brne	.+12     	; 0x267e <xTaskResumeAll+0xe4>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    2672:	10 92 29 03 	sts	0x0329, r1
					portYIELD_WITHIN_API();
    2676:	0e 94 a3 16 	call	0x2d46	; 0x2d46 <vPortYield>
    267a:	81 e0       	ldi	r24, 0x01	; 1
    267c:	01 c0       	rjmp	.+2      	; 0x2680 <xTaskResumeAll+0xe6>
    267e:	80 e0       	ldi	r24, 0x00	; 0
				}
			}
		}
	}
	portEXIT_CRITICAL();
    2680:	0f 90       	pop	r0
    2682:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    2684:	0f 90       	pop	r0
    2686:	cf 91       	pop	r28
    2688:	df 91       	pop	r29
    268a:	1f 91       	pop	r17
    268c:	0f 91       	pop	r16
    268e:	ff 90       	pop	r15
    2690:	df 90       	pop	r13
    2692:	cf 90       	pop	r12
    2694:	08 95       	ret

00002696 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    2696:	0f 93       	push	r16
    2698:	1f 93       	push	r17
    269a:	9c 01       	movw	r18, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
    269c:	00 97       	sbiw	r24, 0x00	; 0
    269e:	a1 f1       	breq	.+104    	; 0x2708 <vTaskDelay+0x72>

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    26a0:	80 91 2d 03 	lds	r24, 0x032D
    26a4:	8f 5f       	subi	r24, 0xFF	; 255
    26a6:	80 93 2d 03 	sts	0x032D, r24
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    26aa:	00 91 2b 03 	lds	r16, 0x032B
    26ae:	10 91 2c 03 	lds	r17, 0x032C
    26b2:	02 0f       	add	r16, r18
    26b4:	13 1f       	adc	r17, r19

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    26b6:	80 91 27 03 	lds	r24, 0x0327
    26ba:	90 91 28 03 	lds	r25, 0x0328
    26be:	02 96       	adiw	r24, 0x02	; 2
    26c0:	0e 94 29 0e 	call	0x1c52	; 0x1c52 <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    26c4:	e0 91 27 03 	lds	r30, 0x0327
    26c8:	f0 91 28 03 	lds	r31, 0x0328
    26cc:	13 83       	std	Z+3, r17	; 0x03
    26ce:	02 83       	std	Z+2, r16	; 0x02

				if( xTimeToWake < xTickCount )
    26d0:	80 91 2b 03 	lds	r24, 0x032B
    26d4:	90 91 2c 03 	lds	r25, 0x032C
    26d8:	08 17       	cp	r16, r24
    26da:	19 07       	cpc	r17, r25
    26dc:	28 f4       	brcc	.+10     	; 0x26e8 <vTaskDelay+0x52>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    26de:	80 91 6d 03 	lds	r24, 0x036D
    26e2:	90 91 6e 03 	lds	r25, 0x036E
    26e6:	04 c0       	rjmp	.+8      	; 0x26f0 <vTaskDelay+0x5a>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    26e8:	80 91 6b 03 	lds	r24, 0x036B
    26ec:	90 91 6c 03 	lds	r25, 0x036C
    26f0:	60 91 27 03 	lds	r22, 0x0327
    26f4:	70 91 28 03 	lds	r23, 0x0328
    26f8:	6e 5f       	subi	r22, 0xFE	; 254
    26fa:	7f 4f       	sbci	r23, 0xFF	; 255
    26fc:	0e 94 f4 0d 	call	0x1be8	; 0x1be8 <vListInsert>
				}
			}
			xAlreadyYielded = xTaskResumeAll();
    2700:	0e 94 cd 12 	call	0x259a	; 0x259a <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
    2704:	88 23       	and	r24, r24
    2706:	11 f4       	brne	.+4      	; 0x270c <vTaskDelay+0x76>
		{
			portYIELD_WITHIN_API();
    2708:	0e 94 a3 16 	call	0x2d46	; 0x2d46 <vPortYield>
		}
	}
    270c:	1f 91       	pop	r17
    270e:	0f 91       	pop	r16
    2710:	08 95       	ret

00002712 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    2712:	cf 93       	push	r28
    2714:	df 93       	push	r29
    2716:	fc 01       	movw	r30, r24
    2718:	eb 01       	movw	r28, r22

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    271a:	80 91 2d 03 	lds	r24, 0x032D
    271e:	8f 5f       	subi	r24, 0xFF	; 255
    2720:	80 93 2d 03 	sts	0x032D, r24
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		vTaskSuspendAll();
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2724:	20 81       	ld	r18, Z
    2726:	31 81       	ldd	r19, Z+1	; 0x01
    2728:	c2 0f       	add	r28, r18
    272a:	d3 1f       	adc	r29, r19

			if( xTickCount < *pxPreviousWakeTime )
    272c:	80 91 2b 03 	lds	r24, 0x032B
    2730:	90 91 2c 03 	lds	r25, 0x032C
    2734:	82 17       	cp	r24, r18
    2736:	93 07       	cpc	r25, r19
    2738:	28 f4       	brcc	.+10     	; 0x2744 <vTaskDelayUntil+0x32>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    273a:	c2 17       	cp	r28, r18
    273c:	d3 07       	cpc	r29, r19
    273e:	28 f0       	brcs	.+10     	; 0x274a <vTaskDelayUntil+0x38>
    2740:	20 e0       	ldi	r18, 0x00	; 0
    2742:	0c c0       	rjmp	.+24     	; 0x275c <vTaskDelayUntil+0x4a>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    2744:	c2 17       	cp	r28, r18
    2746:	d3 07       	cpc	r29, r19
    2748:	40 f0       	brcs	.+16     	; 0x275a <vTaskDelayUntil+0x48>
    274a:	80 91 2b 03 	lds	r24, 0x032B
    274e:	90 91 2c 03 	lds	r25, 0x032C
    2752:	20 e0       	ldi	r18, 0x00	; 0
    2754:	8c 17       	cp	r24, r28
    2756:	9d 07       	cpc	r25, r29
    2758:	08 f4       	brcc	.+2      	; 0x275c <vTaskDelayUntil+0x4a>
    275a:	21 e0       	ldi	r18, 0x01	; 1
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    275c:	d1 83       	std	Z+1, r29	; 0x01
    275e:	c0 83       	st	Z, r28

			if( xShouldDelay )
    2760:	22 23       	and	r18, r18
    2762:	29 f1       	breq	.+74     	; 0x27ae <vTaskDelayUntil+0x9c>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2764:	80 91 27 03 	lds	r24, 0x0327
    2768:	90 91 28 03 	lds	r25, 0x0328
    276c:	02 96       	adiw	r24, 0x02	; 2
    276e:	0e 94 29 0e 	call	0x1c52	; 0x1c52 <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    2772:	e0 91 27 03 	lds	r30, 0x0327
    2776:	f0 91 28 03 	lds	r31, 0x0328
    277a:	d3 83       	std	Z+3, r29	; 0x03
    277c:	c2 83       	std	Z+2, r28	; 0x02

				if( xTimeToWake < xTickCount )
    277e:	80 91 2b 03 	lds	r24, 0x032B
    2782:	90 91 2c 03 	lds	r25, 0x032C
    2786:	c8 17       	cp	r28, r24
    2788:	d9 07       	cpc	r29, r25
    278a:	28 f4       	brcc	.+10     	; 0x2796 <vTaskDelayUntil+0x84>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    278c:	80 91 6d 03 	lds	r24, 0x036D
    2790:	90 91 6e 03 	lds	r25, 0x036E
    2794:	04 c0       	rjmp	.+8      	; 0x279e <vTaskDelayUntil+0x8c>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2796:	80 91 6b 03 	lds	r24, 0x036B
    279a:	90 91 6c 03 	lds	r25, 0x036C
    279e:	60 91 27 03 	lds	r22, 0x0327
    27a2:	70 91 28 03 	lds	r23, 0x0328
    27a6:	6e 5f       	subi	r22, 0xFE	; 254
    27a8:	7f 4f       	sbci	r23, 0xFF	; 255
    27aa:	0e 94 f4 0d 	call	0x1be8	; 0x1be8 <vListInsert>
				}
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    27ae:	0e 94 cd 12 	call	0x259a	; 0x259a <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
    27b2:	88 23       	and	r24, r24
    27b4:	11 f4       	brne	.+4      	; 0x27ba <vTaskDelayUntil+0xa8>
		{
			portYIELD_WITHIN_API();
    27b6:	0e 94 a3 16 	call	0x2d46	; 0x2d46 <vPortYield>
		}
	}
    27ba:	df 91       	pop	r29
    27bc:	cf 91       	pop	r28
    27be:	08 95       	ret

000027c0 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    27c0:	ef 92       	push	r14
    27c2:	ff 92       	push	r15
    27c4:	0f 93       	push	r16
    27c6:	1f 93       	push	r17
    27c8:	cf 93       	push	r28
    27ca:	df 93       	push	r29
    27cc:	8c 01       	movw	r16, r24
	tskTCB *pxTCB;

		portENTER_CRITICAL();
    27ce:	0f b6       	in	r0, 0x3f	; 63
    27d0:	f8 94       	cli
    27d2:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    27d4:	80 91 27 03 	lds	r24, 0x0327
    27d8:	90 91 28 03 	lds	r25, 0x0328
    27dc:	08 17       	cp	r16, r24
    27de:	19 07       	cpc	r17, r25
    27e0:	19 f4       	brne	.+6      	; 0x27e8 <vTaskDelete+0x28>
    27e2:	00 e0       	ldi	r16, 0x00	; 0
    27e4:	10 e0       	ldi	r17, 0x00	; 0
    27e6:	03 c0       	rjmp	.+6      	; 0x27ee <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    27e8:	01 15       	cp	r16, r1
    27ea:	11 05       	cpc	r17, r1
    27ec:	29 f4       	brne	.+10     	; 0x27f8 <vTaskDelete+0x38>
    27ee:	c0 91 27 03 	lds	r28, 0x0327
    27f2:	d0 91 28 03 	lds	r29, 0x0328
    27f6:	01 c0       	rjmp	.+2      	; 0x27fa <vTaskDelete+0x3a>
    27f8:	e8 01       	movw	r28, r16

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    27fa:	22 e0       	ldi	r18, 0x02	; 2
    27fc:	e2 2e       	mov	r14, r18
    27fe:	f1 2c       	mov	r15, r1
    2800:	ec 0e       	add	r14, r28
    2802:	fd 1e       	adc	r15, r29
    2804:	c7 01       	movw	r24, r14
    2806:	0e 94 29 0e 	call	0x1c52	; 0x1c52 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer )
    280a:	8c 89       	ldd	r24, Y+20	; 0x14
    280c:	9d 89       	ldd	r25, Y+21	; 0x15
    280e:	89 2b       	or	r24, r25
    2810:	21 f0       	breq	.+8      	; 0x281a <vTaskDelete+0x5a>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    2812:	ce 01       	movw	r24, r28
    2814:	0c 96       	adiw	r24, 0x0c	; 12
    2816:	0e 94 29 0e 	call	0x1c52	; 0x1c52 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    281a:	88 e7       	ldi	r24, 0x78	; 120
    281c:	93 e0       	ldi	r25, 0x03	; 3
    281e:	b7 01       	movw	r22, r14
    2820:	0e 94 cb 0d 	call	0x1b96	; 0x1b96 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    2824:	80 91 32 03 	lds	r24, 0x0332
    2828:	8f 5f       	subi	r24, 0xFF	; 255
    282a:	80 93 32 03 	sts	0x0332, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    282e:	80 91 33 03 	lds	r24, 0x0333
    2832:	8f 5f       	subi	r24, 0xFF	; 255
    2834:	80 93 33 03 	sts	0x0333, r24

			traceTASK_DELETE( pxTCB );
		}
		portEXIT_CRITICAL();
    2838:	0f 90       	pop	r0
    283a:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    283c:	80 91 31 03 	lds	r24, 0x0331
    2840:	88 23       	and	r24, r24
    2842:	21 f0       	breq	.+8      	; 0x284c <vTaskDelete+0x8c>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    2844:	01 2b       	or	r16, r17
    2846:	11 f4       	brne	.+4      	; 0x284c <vTaskDelete+0x8c>
			{
				portYIELD_WITHIN_API();
    2848:	0e 94 a3 16 	call	0x2d46	; 0x2d46 <vPortYield>
			}
		}
	}
    284c:	df 91       	pop	r29
    284e:	cf 91       	pop	r28
    2850:	1f 91       	pop	r17
    2852:	0f 91       	pop	r16
    2854:	ff 90       	pop	r15
    2856:	ef 90       	pop	r14
    2858:	08 95       	ret

0000285a <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    285a:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    285c:	10 92 31 03 	sts	0x0331, r1
	vPortEndScheduler();
    2860:	0e 94 44 16 	call	0x2c88	; 0x2c88 <vPortEndScheduler>
}
    2864:	08 95       	ret

00002866 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    2866:	1f 93       	push	r17
    2868:	cf 93       	push	r28
    286a:	df 93       	push	r29
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
    286c:	80 91 32 03 	lds	r24, 0x0332
    2870:	88 23       	and	r24, r24
    2872:	91 f1       	breq	.+100    	; 0x28d8 <prvIdleTask+0x72>

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    2874:	80 91 2d 03 	lds	r24, 0x032D
    2878:	8f 5f       	subi	r24, 0xFF	; 255
    287a:	80 93 2d 03 	sts	0x032D, r24
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    287e:	10 91 78 03 	lds	r17, 0x0378
			xTaskResumeAll();
    2882:	0e 94 cd 12 	call	0x259a	; 0x259a <xTaskResumeAll>

			if( !xListIsEmpty )
    2886:	11 23       	and	r17, r17
    2888:	39 f1       	breq	.+78     	; 0x28d8 <prvIdleTask+0x72>
			{
				tskTCB *pxTCB;

				portENTER_CRITICAL();
    288a:	0f b6       	in	r0, 0x3f	; 63
    288c:	f8 94       	cli
    288e:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    2890:	80 91 78 03 	lds	r24, 0x0378
    2894:	88 23       	and	r24, r24
    2896:	19 f4       	brne	.+6      	; 0x289e <prvIdleTask+0x38>
    2898:	c0 e0       	ldi	r28, 0x00	; 0
    289a:	d0 e0       	ldi	r29, 0x00	; 0
    289c:	06 c0       	rjmp	.+12     	; 0x28aa <prvIdleTask+0x44>
    289e:	e0 91 7d 03 	lds	r30, 0x037D
    28a2:	f0 91 7e 03 	lds	r31, 0x037E
    28a6:	c6 81       	ldd	r28, Z+6	; 0x06
    28a8:	d7 81       	ldd	r29, Z+7	; 0x07
					vListRemove( &( pxTCB->xGenericListItem ) );
    28aa:	ce 01       	movw	r24, r28
    28ac:	02 96       	adiw	r24, 0x02	; 2
    28ae:	0e 94 29 0e 	call	0x1c52	; 0x1c52 <vListRemove>
					--uxCurrentNumberOfTasks;
    28b2:	80 91 30 03 	lds	r24, 0x0330
    28b6:	81 50       	subi	r24, 0x01	; 1
    28b8:	80 93 30 03 	sts	0x0330, r24
					--uxTasksDeleted;
    28bc:	80 91 32 03 	lds	r24, 0x0332
    28c0:	81 50       	subi	r24, 0x01	; 1
    28c2:	80 93 32 03 	sts	0x0332, r24
				}
				portEXIT_CRITICAL();
    28c6:	0f 90       	pop	r0
    28c8:	0f be       	out	0x3f, r0	; 63

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    28ca:	8f 89       	ldd	r24, Y+23	; 0x17
    28cc:	98 8d       	ldd	r25, Y+24	; 0x18
    28ce:	0e 94 c6 18 	call	0x318c	; 0x318c <vPortFree>
		vPortFree( pxTCB );
    28d2:	ce 01       	movw	r24, r28
    28d4:	0e 94 c6 18 	call	0x318c	; 0x318c <vPortFree>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    28d8:	80 91 35 03 	lds	r24, 0x0335
    28dc:	82 30       	cpi	r24, 0x02	; 2
    28de:	30 f2       	brcs	.-116    	; 0x286c <prvIdleTask+0x6>
			{
				taskYIELD();
    28e0:	0e 94 a3 16 	call	0x2d46	; 0x2d46 <vPortYield>
    28e4:	c3 cf       	rjmp	.-122    	; 0x286c <prvIdleTask+0x6>

000028e6 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    28e6:	2f 92       	push	r2
    28e8:	3f 92       	push	r3
    28ea:	5f 92       	push	r5
    28ec:	6f 92       	push	r6
    28ee:	7f 92       	push	r7
    28f0:	8f 92       	push	r8
    28f2:	9f 92       	push	r9
    28f4:	af 92       	push	r10
    28f6:	bf 92       	push	r11
    28f8:	cf 92       	push	r12
    28fa:	df 92       	push	r13
    28fc:	ef 92       	push	r14
    28fe:	ff 92       	push	r15
    2900:	0f 93       	push	r16
    2902:	1f 93       	push	r17
    2904:	df 93       	push	r29
    2906:	cf 93       	push	r28
    2908:	00 d0       	rcall	.+0      	; 0x290a <xTaskGenericCreate+0x24>
    290a:	00 d0       	rcall	.+0      	; 0x290c <xTaskGenericCreate+0x26>
    290c:	cd b7       	in	r28, 0x3d	; 61
    290e:	de b7       	in	r29, 0x3e	; 62
    2910:	9a 83       	std	Y+2, r25	; 0x02
    2912:	89 83       	std	Y+1, r24	; 0x01
    2914:	4b 01       	movw	r8, r22
    2916:	5a 01       	movw	r10, r20
    2918:	19 01       	movw	r2, r18
    291a:	50 2e       	mov	r5, r16
    291c:	37 01       	movw	r6, r14
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    291e:	81 e2       	ldi	r24, 0x21	; 33
    2920:	90 e0       	ldi	r25, 0x00	; 0
    2922:	0e 94 d6 18 	call	0x31ac	; 0x31ac <pvPortMalloc>
    2926:	8b 83       	std	Y+3, r24	; 0x03
    2928:	9c 83       	std	Y+4, r25	; 0x04

	if( pxNewTCB != NULL )
    292a:	8b 81       	ldd	r24, Y+3	; 0x03
    292c:	9c 81       	ldd	r25, Y+4	; 0x04
    292e:	89 2b       	or	r24, r25
    2930:	89 f0       	breq	.+34     	; 0x2954 <xTaskGenericCreate+0x6e>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    2932:	c1 14       	cp	r12, r1
    2934:	d1 04       	cpc	r13, r1
    2936:	21 f4       	brne	.+8      	; 0x2940 <xTaskGenericCreate+0x5a>
    2938:	c5 01       	movw	r24, r10
    293a:	0e 94 d6 18 	call	0x31ac	; 0x31ac <pvPortMalloc>
    293e:	6c 01       	movw	r12, r24
    2940:	eb 81       	ldd	r30, Y+3	; 0x03
    2942:	fc 81       	ldd	r31, Y+4	; 0x04
    2944:	d0 8e       	std	Z+24, r13	; 0x18
    2946:	c7 8a       	std	Z+23, r12	; 0x17

		if( pxNewTCB->pxStack == NULL )
    2948:	c1 14       	cp	r12, r1
    294a:	d1 04       	cpc	r13, r1
    294c:	29 f4       	brne	.+10     	; 0x2958 <xTaskGenericCreate+0x72>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    294e:	cf 01       	movw	r24, r30
    2950:	0e 94 c6 18 	call	0x318c	; 0x318c <vPortFree>
    2954:	8f ef       	ldi	r24, 0xFF	; 255
    2956:	d5 c0       	rjmp	.+426    	; 0x2b02 <xTaskGenericCreate+0x21c>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
    2958:	c6 01       	movw	r24, r12
    295a:	65 ea       	ldi	r22, 0xA5	; 165
    295c:	70 e0       	ldi	r23, 0x00	; 0
    295e:	a5 01       	movw	r20, r10
    2960:	0e 94 b6 2a 	call	0x556c	; 0x556c <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
    2964:	08 94       	sec
    2966:	a1 08       	sbc	r10, r1
    2968:	b1 08       	sbc	r11, r1
    296a:	eb 81       	ldd	r30, Y+3	; 0x03
    296c:	fc 81       	ldd	r31, Y+4	; 0x04
    296e:	e7 88       	ldd	r14, Z+23	; 0x17
    2970:	f0 8c       	ldd	r15, Z+24	; 0x18
    2972:	ea 0c       	add	r14, r10
    2974:	fb 1c       	adc	r15, r11
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    2976:	cf 01       	movw	r24, r30
    2978:	49 96       	adiw	r24, 0x19	; 25
    297a:	b4 01       	movw	r22, r8
    297c:	48 e0       	ldi	r20, 0x08	; 8
    297e:	50 e0       	ldi	r21, 0x00	; 0
    2980:	0e 94 bd 2a 	call	0x557a	; 0x557a <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
    2984:	eb 81       	ldd	r30, Y+3	; 0x03
    2986:	fc 81       	ldd	r31, Y+4	; 0x04
    2988:	10 a2       	std	Z+32, r1	; 0x20
    298a:	05 2d       	mov	r16, r5
    298c:	f3 e0       	ldi	r31, 0x03	; 3
    298e:	f5 15       	cp	r31, r5
    2990:	08 f4       	brcc	.+2      	; 0x2994 <xTaskGenericCreate+0xae>
    2992:	03 e0       	ldi	r16, 0x03	; 3
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - 1;
	}

	pxTCB->uxPriority = uxPriority;
    2994:	eb 81       	ldd	r30, Y+3	; 0x03
    2996:	fc 81       	ldd	r31, Y+4	; 0x04
    2998:	06 8b       	std	Z+22, r16	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    299a:	42 e0       	ldi	r20, 0x02	; 2
    299c:	c4 2e       	mov	r12, r20
    299e:	d1 2c       	mov	r13, r1
    29a0:	ce 0e       	add	r12, r30
    29a2:	df 1e       	adc	r13, r31
    29a4:	c6 01       	movw	r24, r12
    29a6:	0e 94 c7 0d 	call	0x1b8e	; 0x1b8e <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    29aa:	8b 81       	ldd	r24, Y+3	; 0x03
    29ac:	9c 81       	ldd	r25, Y+4	; 0x04
    29ae:	0c 96       	adiw	r24, 0x0c	; 12
    29b0:	0e 94 c7 0d 	call	0x1b8e	; 0x1b8e <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    29b4:	8b 81       	ldd	r24, Y+3	; 0x03
    29b6:	9c 81       	ldd	r25, Y+4	; 0x04
    29b8:	fc 01       	movw	r30, r24
    29ba:	91 87       	std	Z+9, r25	; 0x09
    29bc:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    29be:	84 e0       	ldi	r24, 0x04	; 4
    29c0:	90 e0       	ldi	r25, 0x00	; 0
    29c2:	80 1b       	sub	r24, r16
    29c4:	91 09       	sbc	r25, r1
    29c6:	95 87       	std	Z+13, r25	; 0x0d
    29c8:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    29ca:	f3 8b       	std	Z+19, r31	; 0x13
    29cc:	e2 8b       	std	Z+18, r30	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    29ce:	c7 01       	movw	r24, r14
    29d0:	69 81       	ldd	r22, Y+1	; 0x01
    29d2:	7a 81       	ldd	r23, Y+2	; 0x02
    29d4:	a1 01       	movw	r20, r2
    29d6:	0e 94 c2 15 	call	0x2b84	; 0x2b84 <pxPortInitialiseStack>
    29da:	eb 81       	ldd	r30, Y+3	; 0x03
    29dc:	fc 81       	ldd	r31, Y+4	; 0x04
    29de:	91 83       	std	Z+1, r25	; 0x01
    29e0:	80 83       	st	Z, r24
		}
		#endif

		if( ( void * ) pxCreatedTask != NULL )
    29e2:	61 14       	cp	r6, r1
    29e4:	71 04       	cpc	r7, r1
    29e6:	21 f0       	breq	.+8      	; 0x29f0 <xTaskGenericCreate+0x10a>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    29e8:	cf 01       	movw	r24, r30
    29ea:	f3 01       	movw	r30, r6
    29ec:	91 83       	std	Z+1, r25	; 0x01
    29ee:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		portENTER_CRITICAL();
    29f0:	0f b6       	in	r0, 0x3f	; 63
    29f2:	f8 94       	cli
    29f4:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    29f6:	80 91 30 03 	lds	r24, 0x0330
    29fa:	8f 5f       	subi	r24, 0xFF	; 255
    29fc:	80 93 30 03 	sts	0x0330, r24
			if( pxCurrentTCB == NULL )
    2a00:	80 91 27 03 	lds	r24, 0x0327
    2a04:	90 91 28 03 	lds	r25, 0x0328
    2a08:	89 2b       	or	r24, r25
    2a0a:	b9 f5       	brne	.+110    	; 0x2a7a <xTaskGenericCreate+0x194>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    2a0c:	eb 81       	ldd	r30, Y+3	; 0x03
    2a0e:	fc 81       	ldd	r31, Y+4	; 0x04
    2a10:	f0 93 28 03 	sts	0x0328, r31
    2a14:	e0 93 27 03 	sts	0x0327, r30

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    2a18:	80 91 30 03 	lds	r24, 0x0330
    2a1c:	81 30       	cpi	r24, 0x01	; 1
    2a1e:	f1 f5       	brne	.+124    	; 0x2a9c <xTaskGenericCreate+0x1b6>
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    2a20:	85 e3       	ldi	r24, 0x35	; 53
    2a22:	93 e0       	ldi	r25, 0x03	; 3
    2a24:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vListInitialise>
    2a28:	8e e3       	ldi	r24, 0x3E	; 62
    2a2a:	93 e0       	ldi	r25, 0x03	; 3
    2a2c:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vListInitialise>
    2a30:	87 e4       	ldi	r24, 0x47	; 71
    2a32:	93 e0       	ldi	r25, 0x03	; 3
    2a34:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vListInitialise>
    2a38:	80 e5       	ldi	r24, 0x50	; 80
    2a3a:	93 e0       	ldi	r25, 0x03	; 3
    2a3c:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    2a40:	39 e5       	ldi	r19, 0x59	; 89
    2a42:	e3 2e       	mov	r14, r19
    2a44:	33 e0       	ldi	r19, 0x03	; 3
    2a46:	f3 2e       	mov	r15, r19
    2a48:	c7 01       	movw	r24, r14
    2a4a:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    2a4e:	02 e6       	ldi	r16, 0x62	; 98
    2a50:	13 e0       	ldi	r17, 0x03	; 3
    2a52:	c8 01       	movw	r24, r16
    2a54:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    2a58:	8f e6       	ldi	r24, 0x6F	; 111
    2a5a:	93 e0       	ldi	r25, 0x03	; 3
    2a5c:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    2a60:	88 e7       	ldi	r24, 0x78	; 120
    2a62:	93 e0       	ldi	r25, 0x03	; 3
    2a64:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    2a68:	f0 92 6c 03 	sts	0x036C, r15
    2a6c:	e0 92 6b 03 	sts	0x036B, r14
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    2a70:	10 93 6e 03 	sts	0x036E, r17
    2a74:	00 93 6d 03 	sts	0x036D, r16
    2a78:	11 c0       	rjmp	.+34     	; 0x2a9c <xTaskGenericCreate+0x1b6>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    2a7a:	80 91 31 03 	lds	r24, 0x0331
    2a7e:	88 23       	and	r24, r24
    2a80:	69 f4       	brne	.+26     	; 0x2a9c <xTaskGenericCreate+0x1b6>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    2a82:	e0 91 27 03 	lds	r30, 0x0327
    2a86:	f0 91 28 03 	lds	r31, 0x0328
    2a8a:	86 89       	ldd	r24, Z+22	; 0x16
    2a8c:	58 16       	cp	r5, r24
    2a8e:	30 f0       	brcs	.+12     	; 0x2a9c <xTaskGenericCreate+0x1b6>
					{
						pxCurrentTCB = pxNewTCB;
    2a90:	8b 81       	ldd	r24, Y+3	; 0x03
    2a92:	9c 81       	ldd	r25, Y+4	; 0x04
    2a94:	90 93 28 03 	sts	0x0328, r25
    2a98:	80 93 27 03 	sts	0x0327, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    2a9c:	eb 81       	ldd	r30, Y+3	; 0x03
    2a9e:	fc 81       	ldd	r31, Y+4	; 0x04
    2aa0:	96 89       	ldd	r25, Z+22	; 0x16
    2aa2:	80 91 34 03 	lds	r24, 0x0334
    2aa6:	89 17       	cp	r24, r25
    2aa8:	10 f4       	brcc	.+4      	; 0x2aae <xTaskGenericCreate+0x1c8>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    2aaa:	90 93 34 03 	sts	0x0334, r25
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    2aae:	80 91 33 03 	lds	r24, 0x0333
    2ab2:	8f 5f       	subi	r24, 0xFF	; 255
    2ab4:	80 93 33 03 	sts	0x0333, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    2ab8:	eb 81       	ldd	r30, Y+3	; 0x03
    2aba:	fc 81       	ldd	r31, Y+4	; 0x04
    2abc:	96 89       	ldd	r25, Z+22	; 0x16
    2abe:	80 91 2e 03 	lds	r24, 0x032E
    2ac2:	89 17       	cp	r24, r25
    2ac4:	10 f4       	brcc	.+4      	; 0x2aca <xTaskGenericCreate+0x1e4>
    2ac6:	90 93 2e 03 	sts	0x032E, r25
    2aca:	eb 81       	ldd	r30, Y+3	; 0x03
    2acc:	fc 81       	ldd	r31, Y+4	; 0x04
    2ace:	86 89       	ldd	r24, Z+22	; 0x16
    2ad0:	29 e0       	ldi	r18, 0x09	; 9
    2ad2:	82 9f       	mul	r24, r18
    2ad4:	c0 01       	movw	r24, r0
    2ad6:	11 24       	eor	r1, r1
    2ad8:	8b 5c       	subi	r24, 0xCB	; 203
    2ada:	9c 4f       	sbci	r25, 0xFC	; 252
    2adc:	b6 01       	movw	r22, r12
    2ade:	0e 94 cb 0d 	call	0x1b96	; 0x1b96 <vListInsertEnd>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		portEXIT_CRITICAL();
    2ae2:	0f 90       	pop	r0
    2ae4:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED( pxNewTCB );
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    2ae6:	80 91 31 03 	lds	r24, 0x0331
    2aea:	88 23       	and	r24, r24
    2aec:	49 f0       	breq	.+18     	; 0x2b00 <xTaskGenericCreate+0x21a>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    2aee:	e0 91 27 03 	lds	r30, 0x0327
    2af2:	f0 91 28 03 	lds	r31, 0x0328
    2af6:	86 89       	ldd	r24, Z+22	; 0x16
    2af8:	85 15       	cp	r24, r5
    2afa:	10 f4       	brcc	.+4      	; 0x2b00 <xTaskGenericCreate+0x21a>
			{
				portYIELD_WITHIN_API();
    2afc:	0e 94 a3 16 	call	0x2d46	; 0x2d46 <vPortYield>
    2b00:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    2b02:	0f 90       	pop	r0
    2b04:	0f 90       	pop	r0
    2b06:	0f 90       	pop	r0
    2b08:	0f 90       	pop	r0
    2b0a:	cf 91       	pop	r28
    2b0c:	df 91       	pop	r29
    2b0e:	1f 91       	pop	r17
    2b10:	0f 91       	pop	r16
    2b12:	ff 90       	pop	r15
    2b14:	ef 90       	pop	r14
    2b16:	df 90       	pop	r13
    2b18:	cf 90       	pop	r12
    2b1a:	bf 90       	pop	r11
    2b1c:	af 90       	pop	r10
    2b1e:	9f 90       	pop	r9
    2b20:	8f 90       	pop	r8
    2b22:	7f 90       	pop	r7
    2b24:	6f 90       	pop	r6
    2b26:	5f 90       	pop	r5
    2b28:	3f 90       	pop	r3
    2b2a:	2f 90       	pop	r2
    2b2c:	08 95       	ret

00002b2e <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    2b2e:	af 92       	push	r10
    2b30:	bf 92       	push	r11
    2b32:	cf 92       	push	r12
    2b34:	df 92       	push	r13
    2b36:	ef 92       	push	r14
    2b38:	ff 92       	push	r15
    2b3a:	0f 93       	push	r16
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
    2b3c:	83 e3       	ldi	r24, 0x33	; 51
    2b3e:	94 e1       	ldi	r25, 0x14	; 20
    2b40:	69 eb       	ldi	r22, 0xB9	; 185
    2b42:	72 e0       	ldi	r23, 0x02	; 2
    2b44:	45 e5       	ldi	r20, 0x55	; 85
    2b46:	50 e0       	ldi	r21, 0x00	; 0
    2b48:	20 e0       	ldi	r18, 0x00	; 0
    2b4a:	30 e0       	ldi	r19, 0x00	; 0
    2b4c:	00 e0       	ldi	r16, 0x00	; 0
    2b4e:	ee 24       	eor	r14, r14
    2b50:	ff 24       	eor	r15, r15
    2b52:	cc 24       	eor	r12, r12
    2b54:	dd 24       	eor	r13, r13
    2b56:	aa 24       	eor	r10, r10
    2b58:	bb 24       	eor	r11, r11
    2b5a:	0e 94 73 14 	call	0x28e6	; 0x28e6 <xTaskGenericCreate>

	if( xReturn == pdPASS )
    2b5e:	81 30       	cpi	r24, 0x01	; 1
    2b60:	49 f4       	brne	.+18     	; 0x2b74 <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    2b62:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    2b64:	80 93 31 03 	sts	0x0331, r24
		xTickCount = ( portTickType ) 0;
    2b68:	10 92 2c 03 	sts	0x032C, r1
    2b6c:	10 92 2b 03 	sts	0x032B, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
    2b70:	0e 94 0a 16 	call	0x2c14	; 0x2c14 <xPortStartScheduler>
		else
		{
			/* Should only reach here if a task calls xTaskEndScheduler(). */
		}
	}
}
    2b74:	0f 91       	pop	r16
    2b76:	ff 90       	pop	r15
    2b78:	ef 90       	pop	r14
    2b7a:	df 90       	pop	r13
    2b7c:	cf 90       	pop	r12
    2b7e:	bf 90       	pop	r11
    2b80:	af 90       	pop	r10
    2b82:	08 95       	ret

00002b84 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    2b84:	fc 01       	movw	r30, r24
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    2b86:	91 e1       	ldi	r25, 0x11	; 17
    2b88:	90 83       	st	Z, r25
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    2b8a:	22 e2       	ldi	r18, 0x22	; 34
    2b8c:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    2b8e:	83 e3       	ldi	r24, 0x33	; 51
    2b90:	82 93       	st	-Z, r24
	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	

	usAddress = ( unsigned short ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2b92:	62 93       	st	-Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2b94:	72 93       	st	-Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    2b96:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    2b98:	80 e8       	ldi	r24, 0x80	; 128
    2b9a:	82 93       	st	-Z, r24
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    2b9c:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    2b9e:	82 e0       	ldi	r24, 0x02	; 2
    2ba0:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    2ba2:	83 e0       	ldi	r24, 0x03	; 3
    2ba4:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    2ba6:	84 e0       	ldi	r24, 0x04	; 4
    2ba8:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    2baa:	85 e0       	ldi	r24, 0x05	; 5
    2bac:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    2bae:	86 e0       	ldi	r24, 0x06	; 6
    2bb0:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    2bb2:	87 e0       	ldi	r24, 0x07	; 7
    2bb4:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    2bb6:	88 e0       	ldi	r24, 0x08	; 8
    2bb8:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    2bba:	89 e0       	ldi	r24, 0x09	; 9
    2bbc:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    2bbe:	80 e1       	ldi	r24, 0x10	; 16
    2bc0:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    2bc2:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    2bc4:	82 e1       	ldi	r24, 0x12	; 18
    2bc6:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    2bc8:	83 e1       	ldi	r24, 0x13	; 19
    2bca:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    2bcc:	84 e1       	ldi	r24, 0x14	; 20
    2bce:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    2bd0:	85 e1       	ldi	r24, 0x15	; 21
    2bd2:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    2bd4:	86 e1       	ldi	r24, 0x16	; 22
    2bd6:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    2bd8:	87 e1       	ldi	r24, 0x17	; 23
    2bda:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    2bdc:	88 e1       	ldi	r24, 0x18	; 24
    2bde:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    2be0:	89 e1       	ldi	r24, 0x19	; 25
    2be2:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    2be4:	80 e2       	ldi	r24, 0x20	; 32
    2be6:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    2be8:	81 e2       	ldi	r24, 0x21	; 33
    2bea:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    2bec:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    2bee:	83 e2       	ldi	r24, 0x23	; 35
    2bf0:	82 93       	st	-Z, r24
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */

	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2bf2:	42 93       	st	-Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2bf4:	52 93       	st	-Z, r21
	pxTopOfStack--;


	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    2bf6:	86 e2       	ldi	r24, 0x26	; 38
    2bf8:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    2bfa:	87 e2       	ldi	r24, 0x27	; 39
    2bfc:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    2bfe:	88 e2       	ldi	r24, 0x28	; 40
    2c00:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    2c02:	89 e2       	ldi	r24, 0x29	; 41
    2c04:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    2c06:	80 e3       	ldi	r24, 0x30	; 48
    2c08:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    2c0a:	81 e3       	ldi	r24, 0x31	; 49
    2c0c:	82 93       	st	-Z, r24
    2c0e:	31 97       	sbiw	r30, 0x01	; 1
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    2c10:	cf 01       	movw	r24, r30
    2c12:	08 95       	ret

00002c14 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	OCR1AH = ucHighByte;
    2c14:	10 92 89 00 	sts	0x0089, r1
	OCR1AL = ucLowByte;
    2c18:	89 ef       	ldi	r24, 0xF9	; 249
    2c1a:	80 93 88 00 	sts	0x0088, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    2c1e:	8b e0       	ldi	r24, 0x0B	; 11
    2c20:	80 93 81 00 	sts	0x0081, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
    2c24:	ef e6       	ldi	r30, 0x6F	; 111
    2c26:	f0 e0       	ldi	r31, 0x00	; 0
    2c28:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    2c2a:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
    2c2c:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    2c2e:	a0 91 27 03 	lds	r26, 0x0327
    2c32:	b0 91 28 03 	lds	r27, 0x0328
    2c36:	cd 91       	ld	r28, X+
    2c38:	cd bf       	out	0x3d, r28	; 61
    2c3a:	dd 91       	ld	r29, X+
    2c3c:	de bf       	out	0x3e, r29	; 62
    2c3e:	ff 91       	pop	r31
    2c40:	ef 91       	pop	r30
    2c42:	df 91       	pop	r29
    2c44:	cf 91       	pop	r28
    2c46:	bf 91       	pop	r27
    2c48:	af 91       	pop	r26
    2c4a:	9f 91       	pop	r25
    2c4c:	8f 91       	pop	r24
    2c4e:	7f 91       	pop	r23
    2c50:	6f 91       	pop	r22
    2c52:	5f 91       	pop	r21
    2c54:	4f 91       	pop	r20
    2c56:	3f 91       	pop	r19
    2c58:	2f 91       	pop	r18
    2c5a:	1f 91       	pop	r17
    2c5c:	0f 91       	pop	r16
    2c5e:	ff 90       	pop	r15
    2c60:	ef 90       	pop	r14
    2c62:	df 90       	pop	r13
    2c64:	cf 90       	pop	r12
    2c66:	bf 90       	pop	r11
    2c68:	af 90       	pop	r10
    2c6a:	9f 90       	pop	r9
    2c6c:	8f 90       	pop	r8
    2c6e:	7f 90       	pop	r7
    2c70:	6f 90       	pop	r6
    2c72:	5f 90       	pop	r5
    2c74:	4f 90       	pop	r4
    2c76:	3f 90       	pop	r3
    2c78:	2f 90       	pop	r2
    2c7a:	1f 90       	pop	r1
    2c7c:	0f 90       	pop	r0
    2c7e:	0f be       	out	0x3f, r0	; 63
    2c80:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    2c82:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    2c84:	81 e0       	ldi	r24, 0x01	; 1
    2c86:	08 95       	ret

00002c88 <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    2c88:	08 95       	ret

00002c8a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2c8a:	0f 92       	push	r0
    2c8c:	0f b6       	in	r0, 0x3f	; 63
    2c8e:	f8 94       	cli
    2c90:	0f 92       	push	r0
    2c92:	1f 92       	push	r1
    2c94:	11 24       	eor	r1, r1
    2c96:	2f 92       	push	r2
    2c98:	3f 92       	push	r3
    2c9a:	4f 92       	push	r4
    2c9c:	5f 92       	push	r5
    2c9e:	6f 92       	push	r6
    2ca0:	7f 92       	push	r7
    2ca2:	8f 92       	push	r8
    2ca4:	9f 92       	push	r9
    2ca6:	af 92       	push	r10
    2ca8:	bf 92       	push	r11
    2caa:	cf 92       	push	r12
    2cac:	df 92       	push	r13
    2cae:	ef 92       	push	r14
    2cb0:	ff 92       	push	r15
    2cb2:	0f 93       	push	r16
    2cb4:	1f 93       	push	r17
    2cb6:	2f 93       	push	r18
    2cb8:	3f 93       	push	r19
    2cba:	4f 93       	push	r20
    2cbc:	5f 93       	push	r21
    2cbe:	6f 93       	push	r22
    2cc0:	7f 93       	push	r23
    2cc2:	8f 93       	push	r24
    2cc4:	9f 93       	push	r25
    2cc6:	af 93       	push	r26
    2cc8:	bf 93       	push	r27
    2cca:	cf 93       	push	r28
    2ccc:	df 93       	push	r29
    2cce:	ef 93       	push	r30
    2cd0:	ff 93       	push	r31
    2cd2:	a0 91 27 03 	lds	r26, 0x0327
    2cd6:	b0 91 28 03 	lds	r27, 0x0328
    2cda:	0d b6       	in	r0, 0x3d	; 61
    2cdc:	0d 92       	st	X+, r0
    2cde:	0e b6       	in	r0, 0x3e	; 62
    2ce0:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    2ce2:	0e 94 1e 12 	call	0x243c	; 0x243c <vTaskIncrementTick>
	vTaskSwitchContext();
    2ce6:	0e 94 50 11 	call	0x22a0	; 0x22a0 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2cea:	a0 91 27 03 	lds	r26, 0x0327
    2cee:	b0 91 28 03 	lds	r27, 0x0328
    2cf2:	cd 91       	ld	r28, X+
    2cf4:	cd bf       	out	0x3d, r28	; 61
    2cf6:	dd 91       	ld	r29, X+
    2cf8:	de bf       	out	0x3e, r29	; 62
    2cfa:	ff 91       	pop	r31
    2cfc:	ef 91       	pop	r30
    2cfe:	df 91       	pop	r29
    2d00:	cf 91       	pop	r28
    2d02:	bf 91       	pop	r27
    2d04:	af 91       	pop	r26
    2d06:	9f 91       	pop	r25
    2d08:	8f 91       	pop	r24
    2d0a:	7f 91       	pop	r23
    2d0c:	6f 91       	pop	r22
    2d0e:	5f 91       	pop	r21
    2d10:	4f 91       	pop	r20
    2d12:	3f 91       	pop	r19
    2d14:	2f 91       	pop	r18
    2d16:	1f 91       	pop	r17
    2d18:	0f 91       	pop	r16
    2d1a:	ff 90       	pop	r15
    2d1c:	ef 90       	pop	r14
    2d1e:	df 90       	pop	r13
    2d20:	cf 90       	pop	r12
    2d22:	bf 90       	pop	r11
    2d24:	af 90       	pop	r10
    2d26:	9f 90       	pop	r9
    2d28:	8f 90       	pop	r8
    2d2a:	7f 90       	pop	r7
    2d2c:	6f 90       	pop	r6
    2d2e:	5f 90       	pop	r5
    2d30:	4f 90       	pop	r4
    2d32:	3f 90       	pop	r3
    2d34:	2f 90       	pop	r2
    2d36:	1f 90       	pop	r1
    2d38:	0f 90       	pop	r0
    2d3a:	0f be       	out	0x3f, r0	; 63
    2d3c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2d3e:	08 95       	ret

00002d40 <__vector_17>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    2d40:	0e 94 45 16 	call	0x2c8a	; 0x2c8a <vPortYieldFromTick>
		asm volatile ( "reti" );
    2d44:	18 95       	reti

00002d46 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2d46:	0f 92       	push	r0
    2d48:	0f b6       	in	r0, 0x3f	; 63
    2d4a:	f8 94       	cli
    2d4c:	0f 92       	push	r0
    2d4e:	1f 92       	push	r1
    2d50:	11 24       	eor	r1, r1
    2d52:	2f 92       	push	r2
    2d54:	3f 92       	push	r3
    2d56:	4f 92       	push	r4
    2d58:	5f 92       	push	r5
    2d5a:	6f 92       	push	r6
    2d5c:	7f 92       	push	r7
    2d5e:	8f 92       	push	r8
    2d60:	9f 92       	push	r9
    2d62:	af 92       	push	r10
    2d64:	bf 92       	push	r11
    2d66:	cf 92       	push	r12
    2d68:	df 92       	push	r13
    2d6a:	ef 92       	push	r14
    2d6c:	ff 92       	push	r15
    2d6e:	0f 93       	push	r16
    2d70:	1f 93       	push	r17
    2d72:	2f 93       	push	r18
    2d74:	3f 93       	push	r19
    2d76:	4f 93       	push	r20
    2d78:	5f 93       	push	r21
    2d7a:	6f 93       	push	r22
    2d7c:	7f 93       	push	r23
    2d7e:	8f 93       	push	r24
    2d80:	9f 93       	push	r25
    2d82:	af 93       	push	r26
    2d84:	bf 93       	push	r27
    2d86:	cf 93       	push	r28
    2d88:	df 93       	push	r29
    2d8a:	ef 93       	push	r30
    2d8c:	ff 93       	push	r31
    2d8e:	a0 91 27 03 	lds	r26, 0x0327
    2d92:	b0 91 28 03 	lds	r27, 0x0328
    2d96:	0d b6       	in	r0, 0x3d	; 61
    2d98:	0d 92       	st	X+, r0
    2d9a:	0e b6       	in	r0, 0x3e	; 62
    2d9c:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2d9e:	0e 94 50 11 	call	0x22a0	; 0x22a0 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2da2:	a0 91 27 03 	lds	r26, 0x0327
    2da6:	b0 91 28 03 	lds	r27, 0x0328
    2daa:	cd 91       	ld	r28, X+
    2dac:	cd bf       	out	0x3d, r28	; 61
    2dae:	dd 91       	ld	r29, X+
    2db0:	de bf       	out	0x3e, r29	; 62
    2db2:	ff 91       	pop	r31
    2db4:	ef 91       	pop	r30
    2db6:	df 91       	pop	r29
    2db8:	cf 91       	pop	r28
    2dba:	bf 91       	pop	r27
    2dbc:	af 91       	pop	r26
    2dbe:	9f 91       	pop	r25
    2dc0:	8f 91       	pop	r24
    2dc2:	7f 91       	pop	r23
    2dc4:	6f 91       	pop	r22
    2dc6:	5f 91       	pop	r21
    2dc8:	4f 91       	pop	r20
    2dca:	3f 91       	pop	r19
    2dcc:	2f 91       	pop	r18
    2dce:	1f 91       	pop	r17
    2dd0:	0f 91       	pop	r16
    2dd2:	ff 90       	pop	r15
    2dd4:	ef 90       	pop	r14
    2dd6:	df 90       	pop	r13
    2dd8:	cf 90       	pop	r12
    2dda:	bf 90       	pop	r11
    2ddc:	af 90       	pop	r10
    2dde:	9f 90       	pop	r9
    2de0:	8f 90       	pop	r8
    2de2:	7f 90       	pop	r7
    2de4:	6f 90       	pop	r6
    2de6:	5f 90       	pop	r5
    2de8:	4f 90       	pop	r4
    2dea:	3f 90       	pop	r3
    2dec:	2f 90       	pop	r2
    2dee:	1f 90       	pop	r1
    2df0:	0f 90       	pop	r0
    2df2:	0f be       	out	0x3f, r0	; 63
    2df4:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2df6:	08 95       	ret

00002df8 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    2df8:	0f 93       	push	r16
    2dfa:	1f 93       	push	r17
    2dfc:	cf 93       	push	r28
    2dfe:	df 93       	push	r29
    2e00:	fc 01       	movw	r30, r24
corCRCB *pxUnblockedCRCB;
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2e02:	80 81       	ld	r24, Z
    2e04:	88 23       	and	r24, r24
    2e06:	19 f4       	brne	.+6      	; 0x2e0e <xCoRoutineRemoveFromEventList+0x16>
    2e08:	c0 e0       	ldi	r28, 0x00	; 0
    2e0a:	d0 e0       	ldi	r29, 0x00	; 0
    2e0c:	05 c0       	rjmp	.+10     	; 0x2e18 <xCoRoutineRemoveFromEventList+0x20>
    2e0e:	05 80       	ldd	r0, Z+5	; 0x05
    2e10:	f6 81       	ldd	r31, Z+6	; 0x06
    2e12:	e0 2d       	mov	r30, r0
    2e14:	c6 81       	ldd	r28, Z+6	; 0x06
    2e16:	d7 81       	ldd	r29, Z+7	; 0x07
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2e18:	8e 01       	movw	r16, r28
    2e1a:	04 5f       	subi	r16, 0xF4	; 244
    2e1c:	1f 4f       	sbci	r17, 0xFF	; 255
    2e1e:	c8 01       	movw	r24, r16
    2e20:	0e 94 29 0e 	call	0x1c52	; 0x1c52 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    2e24:	82 eb       	ldi	r24, 0xB2	; 178
    2e26:	93 e0       	ldi	r25, 0x03	; 3
    2e28:	b8 01       	movw	r22, r16
    2e2a:	0e 94 cb 0d 	call	0x1b96	; 0x1b96 <vListInsertEnd>
    2e2e:	20 e0       	ldi	r18, 0x00	; 0
    2e30:	e0 91 81 03 	lds	r30, 0x0381
    2e34:	f0 91 82 03 	lds	r31, 0x0382
    2e38:	9e 89       	ldd	r25, Y+22	; 0x16
    2e3a:	86 89       	ldd	r24, Z+22	; 0x16
    2e3c:	98 17       	cp	r25, r24
    2e3e:	08 f0       	brcs	.+2      	; 0x2e42 <xCoRoutineRemoveFromEventList+0x4a>
    2e40:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    2e42:	82 2f       	mov	r24, r18
    2e44:	df 91       	pop	r29
    2e46:	cf 91       	pop	r28
    2e48:	1f 91       	pop	r17
    2e4a:	0f 91       	pop	r16
    2e4c:	08 95       	ret

00002e4e <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    2e4e:	ff 92       	push	r15
    2e50:	0f 93       	push	r16
    2e52:	1f 93       	push	r17
    2e54:	cf 93       	push	r28
    2e56:	df 93       	push	r29
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    2e58:	99 e0       	ldi	r25, 0x09	; 9
    2e5a:	f9 2e       	mov	r15, r25
    2e5c:	28 c0       	rjmp	.+80     	; 0x2eae <vCoRoutineSchedule+0x60>
	while( !listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    2e5e:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    2e60:	80 91 b2 03 	lds	r24, 0x03B2
    2e64:	88 23       	and	r24, r24
    2e66:	19 f4       	brne	.+6      	; 0x2e6e <vCoRoutineSchedule+0x20>
    2e68:	c0 e0       	ldi	r28, 0x00	; 0
    2e6a:	d0 e0       	ldi	r29, 0x00	; 0
    2e6c:	06 c0       	rjmp	.+12     	; 0x2e7a <vCoRoutineSchedule+0x2c>
    2e6e:	e0 91 b7 03 	lds	r30, 0x03B7
    2e72:	f0 91 b8 03 	lds	r31, 0x03B8
    2e76:	c6 81       	ldd	r28, Z+6	; 0x06
    2e78:	d7 81       	ldd	r29, Z+7	; 0x07
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2e7a:	ce 01       	movw	r24, r28
    2e7c:	0c 96       	adiw	r24, 0x0c	; 12
    2e7e:	0e 94 29 0e 	call	0x1c52	; 0x1c52 <vListRemove>
		}
		portENABLE_INTERRUPTS();
    2e82:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    2e84:	8e 01       	movw	r16, r28
    2e86:	0e 5f       	subi	r16, 0xFE	; 254
    2e88:	1f 4f       	sbci	r17, 0xFF	; 255
    2e8a:	c8 01       	movw	r24, r16
    2e8c:	0e 94 29 0e 	call	0x1c52	; 0x1c52 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    2e90:	9e 89       	ldd	r25, Y+22	; 0x16
    2e92:	80 91 83 03 	lds	r24, 0x0383
    2e96:	89 17       	cp	r24, r25
    2e98:	10 f4       	brcc	.+4      	; 0x2e9e <vCoRoutineSchedule+0x50>
    2e9a:	90 93 83 03 	sts	0x0383, r25
    2e9e:	9f 9d       	mul	r25, r15
    2ea0:	c0 01       	movw	r24, r0
    2ea2:	11 24       	eor	r1, r1
    2ea4:	86 57       	subi	r24, 0x76	; 118
    2ea6:	9c 4f       	sbci	r25, 0xFC	; 252
    2ea8:	b8 01       	movw	r22, r16
    2eaa:	0e 94 cb 0d 	call	0x1b96	; 0x1b96 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( !listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) )
    2eae:	80 91 b2 03 	lds	r24, 0x03B2
    2eb2:	88 23       	and	r24, r24
    2eb4:	a1 f6       	brne	.-88     	; 0x2e5e <vCoRoutineSchedule+0x10>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    2eb6:	0e 94 3c 11 	call	0x2278	; 0x2278 <xTaskGetTickCount>
    2eba:	20 91 84 03 	lds	r18, 0x0384
    2ebe:	30 91 85 03 	lds	r19, 0x0385
    2ec2:	82 1b       	sub	r24, r18
    2ec4:	93 0b       	sbc	r25, r19
    2ec6:	90 93 87 03 	sts	0x0387, r25
    2eca:	80 93 86 03 	sts	0x0386, r24
					vListRemove( &( pxCRCB->xEventListItem ) );											
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    2ece:	89 e0       	ldi	r24, 0x09	; 9
    2ed0:	f8 2e       	mov	r15, r24
    2ed2:	54 c0       	rjmp	.+168    	; 0x2f7c <vCoRoutineSchedule+0x12e>
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    2ed4:	01 96       	adiw	r24, 0x01	; 1
    2ed6:	90 93 89 03 	sts	0x0389, r25
    2eda:	80 93 88 03 	sts	0x0388, r24
		xPassedTicks--;
    2ede:	21 50       	subi	r18, 0x01	; 1
    2ee0:	30 40       	sbci	r19, 0x00	; 0
    2ee2:	30 93 87 03 	sts	0x0387, r19
    2ee6:	20 93 86 03 	sts	0x0386, r18

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    2eea:	89 2b       	or	r24, r25
    2eec:	c9 f5       	brne	.+114    	; 0x2f60 <vCoRoutineSchedule+0x112>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    2eee:	20 91 ae 03 	lds	r18, 0x03AE
    2ef2:	30 91 af 03 	lds	r19, 0x03AF
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    2ef6:	80 91 b0 03 	lds	r24, 0x03B0
    2efa:	90 91 b1 03 	lds	r25, 0x03B1
    2efe:	90 93 af 03 	sts	0x03AF, r25
    2f02:	80 93 ae 03 	sts	0x03AE, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    2f06:	30 93 b1 03 	sts	0x03B1, r19
    2f0a:	20 93 b0 03 	sts	0x03B0, r18
    2f0e:	28 c0       	rjmp	.+80     	; 0x2f60 <vCoRoutineSchedule+0x112>
		}

		/* See if this tick has made a timeout expire. */
		while( ( pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList ) ) != NULL )
		{	
			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    2f10:	20 91 88 03 	lds	r18, 0x0388
    2f14:	30 91 89 03 	lds	r19, 0x0389
    2f18:	8a 81       	ldd	r24, Y+2	; 0x02
    2f1a:	9b 81       	ldd	r25, Y+3	; 0x03
    2f1c:	28 17       	cp	r18, r24
    2f1e:	39 07       	cpc	r19, r25
    2f20:	68 f1       	brcs	.+90     	; 0x2f7c <vCoRoutineSchedule+0x12e>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    2f22:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    2f24:	8e 01       	movw	r16, r28
    2f26:	0e 5f       	subi	r16, 0xFE	; 254
    2f28:	1f 4f       	sbci	r17, 0xFF	; 255
    2f2a:	c8 01       	movw	r24, r16
    2f2c:	0e 94 29 0e 	call	0x1c52	; 0x1c52 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    2f30:	8c 89       	ldd	r24, Y+20	; 0x14
    2f32:	9d 89       	ldd	r25, Y+21	; 0x15
    2f34:	89 2b       	or	r24, r25
    2f36:	21 f0       	breq	.+8      	; 0x2f40 <vCoRoutineSchedule+0xf2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    2f38:	ce 01       	movw	r24, r28
    2f3a:	0c 96       	adiw	r24, 0x0c	; 12
    2f3c:	0e 94 29 0e 	call	0x1c52	; 0x1c52 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    2f40:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    2f42:	9e 89       	ldd	r25, Y+22	; 0x16
    2f44:	80 91 83 03 	lds	r24, 0x0383
    2f48:	89 17       	cp	r24, r25
    2f4a:	10 f4       	brcc	.+4      	; 0x2f50 <vCoRoutineSchedule+0x102>
    2f4c:	90 93 83 03 	sts	0x0383, r25
    2f50:	9f 9d       	mul	r25, r15
    2f52:	c0 01       	movw	r24, r0
    2f54:	11 24       	eor	r1, r1
    2f56:	86 57       	subi	r24, 0x76	; 118
    2f58:	9c 4f       	sbci	r25, 0xFC	; 252
    2f5a:	b8 01       	movw	r22, r16
    2f5c:	0e 94 cb 0d 	call	0x1b96	; 0x1b96 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( ( pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList ) ) != NULL )
    2f60:	e0 91 ae 03 	lds	r30, 0x03AE
    2f64:	f0 91 af 03 	lds	r31, 0x03AF
    2f68:	80 81       	ld	r24, Z
    2f6a:	88 23       	and	r24, r24
    2f6c:	39 f0       	breq	.+14     	; 0x2f7c <vCoRoutineSchedule+0x12e>
    2f6e:	05 80       	ldd	r0, Z+5	; 0x05
    2f70:	f6 81       	ldd	r31, Z+6	; 0x06
    2f72:	e0 2d       	mov	r30, r0
    2f74:	c6 81       	ldd	r28, Z+6	; 0x06
    2f76:	d7 81       	ldd	r29, Z+7	; 0x07
    2f78:	20 97       	sbiw	r28, 0x00	; 0
    2f7a:	51 f6       	brne	.-108    	; 0x2f10 <vCoRoutineSchedule+0xc2>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    2f7c:	20 91 86 03 	lds	r18, 0x0386
    2f80:	30 91 87 03 	lds	r19, 0x0387
    2f84:	80 91 88 03 	lds	r24, 0x0388
    2f88:	90 91 89 03 	lds	r25, 0x0389
    2f8c:	21 15       	cp	r18, r1
    2f8e:	31 05       	cpc	r19, r1
    2f90:	09 f0       	breq	.+2      	; 0x2f94 <vCoRoutineSchedule+0x146>
    2f92:	a0 cf       	rjmp	.-192    	; 0x2ed4 <vCoRoutineSchedule+0x86>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    2f94:	90 93 85 03 	sts	0x0385, r25
    2f98:	80 93 84 03 	sts	0x0384, r24
    2f9c:	90 91 83 03 	lds	r25, 0x0383

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    2fa0:	29 e0       	ldi	r18, 0x09	; 9
    2fa2:	06 c0       	rjmp	.+12     	; 0x2fb0 <vCoRoutineSchedule+0x162>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    2fa4:	99 23       	and	r25, r25
    2fa6:	19 f4       	brne	.+6      	; 0x2fae <vCoRoutineSchedule+0x160>
    2fa8:	10 92 83 03 	sts	0x0383, r1
    2fac:	32 c0       	rjmp	.+100    	; 0x3012 <vCoRoutineSchedule+0x1c4>
    2fae:	91 50       	subi	r25, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    2fb0:	92 9f       	mul	r25, r18
    2fb2:	d0 01       	movw	r26, r0
    2fb4:	11 24       	eor	r1, r1
    2fb6:	a6 57       	subi	r26, 0x76	; 118
    2fb8:	bc 4f       	sbci	r27, 0xFC	; 252
    2fba:	8c 91       	ld	r24, X
    2fbc:	88 23       	and	r24, r24
    2fbe:	91 f3       	breq	.-28     	; 0x2fa4 <vCoRoutineSchedule+0x156>
    2fc0:	90 93 83 03 	sts	0x0383, r25
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    2fc4:	11 96       	adiw	r26, 0x01	; 1
    2fc6:	ed 91       	ld	r30, X+
    2fc8:	fc 91       	ld	r31, X
    2fca:	12 97       	sbiw	r26, 0x02	; 2
    2fcc:	02 80       	ldd	r0, Z+2	; 0x02
    2fce:	f3 81       	ldd	r31, Z+3	; 0x03
    2fd0:	e0 2d       	mov	r30, r0
    2fd2:	12 96       	adiw	r26, 0x02	; 2
    2fd4:	fc 93       	st	X, r31
    2fd6:	ee 93       	st	-X, r30
    2fd8:	11 97       	sbiw	r26, 0x01	; 1
    2fda:	cd 01       	movw	r24, r26
    2fdc:	03 96       	adiw	r24, 0x03	; 3
    2fde:	e8 17       	cp	r30, r24
    2fe0:	f9 07       	cpc	r31, r25
    2fe2:	31 f4       	brne	.+12     	; 0x2ff0 <vCoRoutineSchedule+0x1a2>
    2fe4:	82 81       	ldd	r24, Z+2	; 0x02
    2fe6:	93 81       	ldd	r25, Z+3	; 0x03
    2fe8:	12 96       	adiw	r26, 0x02	; 2
    2fea:	9c 93       	st	X, r25
    2fec:	8e 93       	st	-X, r24
    2fee:	11 97       	sbiw	r26, 0x01	; 1
    2ff0:	11 96       	adiw	r26, 0x01	; 1
    2ff2:	ed 91       	ld	r30, X+
    2ff4:	fc 91       	ld	r31, X
    2ff6:	12 97       	sbiw	r26, 0x02	; 2
    2ff8:	06 80       	ldd	r0, Z+6	; 0x06
    2ffa:	f7 81       	ldd	r31, Z+7	; 0x07
    2ffc:	e0 2d       	mov	r30, r0
    2ffe:	f0 93 82 03 	sts	0x0382, r31
    3002:	e0 93 81 03 	sts	0x0381, r30

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    3006:	20 81       	ld	r18, Z
    3008:	31 81       	ldd	r19, Z+1	; 0x01
    300a:	cf 01       	movw	r24, r30
    300c:	67 89       	ldd	r22, Z+23	; 0x17
    300e:	f9 01       	movw	r30, r18
    3010:	09 95       	icall

	return;
}
    3012:	df 91       	pop	r29
    3014:	cf 91       	pop	r28
    3016:	1f 91       	pop	r17
    3018:	0f 91       	pop	r16
    301a:	ff 90       	pop	r15
    301c:	08 95       	ret

0000301e <vCoRoutineAddToDelayedList>:
	return xReturn;	
}
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    301e:	0f 93       	push	r16
    3020:	1f 93       	push	r17
    3022:	cf 93       	push	r28
    3024:	df 93       	push	r29
    3026:	eb 01       	movw	r28, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    3028:	00 91 88 03 	lds	r16, 0x0388
    302c:	10 91 89 03 	lds	r17, 0x0389
    3030:	08 0f       	add	r16, r24
    3032:	19 1f       	adc	r17, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    3034:	80 91 81 03 	lds	r24, 0x0381
    3038:	90 91 82 03 	lds	r25, 0x0382
    303c:	02 96       	adiw	r24, 0x02	; 2
    303e:	0e 94 29 0e 	call	0x1c52	; 0x1c52 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    3042:	e0 91 81 03 	lds	r30, 0x0381
    3046:	f0 91 82 03 	lds	r31, 0x0382
    304a:	13 83       	std	Z+3, r17	; 0x03
    304c:	02 83       	std	Z+2, r16	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    304e:	80 91 88 03 	lds	r24, 0x0388
    3052:	90 91 89 03 	lds	r25, 0x0389
    3056:	bf 01       	movw	r22, r30
    3058:	6e 5f       	subi	r22, 0xFE	; 254
    305a:	7f 4f       	sbci	r23, 0xFF	; 255
    305c:	08 17       	cp	r16, r24
    305e:	19 07       	cpc	r17, r25
    3060:	28 f4       	brcc	.+10     	; 0x306c <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    3062:	80 91 b0 03 	lds	r24, 0x03B0
    3066:	90 91 b1 03 	lds	r25, 0x03B1
    306a:	04 c0       	rjmp	.+8      	; 0x3074 <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    306c:	80 91 ae 03 	lds	r24, 0x03AE
    3070:	90 91 af 03 	lds	r25, 0x03AF
    3074:	0e 94 f4 0d 	call	0x1be8	; 0x1be8 <vListInsert>
	}

	if( pxEventList )
    3078:	20 97       	sbiw	r28, 0x00	; 0
    307a:	49 f0       	breq	.+18     	; 0x308e <vCoRoutineAddToDelayedList+0x70>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    307c:	60 91 81 03 	lds	r22, 0x0381
    3080:	70 91 82 03 	lds	r23, 0x0382
    3084:	64 5f       	subi	r22, 0xF4	; 244
    3086:	7f 4f       	sbci	r23, 0xFF	; 255
    3088:	ce 01       	movw	r24, r28
    308a:	0e 94 f4 0d 	call	0x1be8	; 0x1be8 <vListInsert>
	}
}
    308e:	df 91       	pop	r29
    3090:	cf 91       	pop	r28
    3092:	1f 91       	pop	r17
    3094:	0f 91       	pop	r16
    3096:	08 95       	ret

00003098 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    3098:	af 92       	push	r10
    309a:	bf 92       	push	r11
    309c:	cf 92       	push	r12
    309e:	df 92       	push	r13
    30a0:	ef 92       	push	r14
    30a2:	ff 92       	push	r15
    30a4:	0f 93       	push	r16
    30a6:	1f 93       	push	r17
    30a8:	cf 93       	push	r28
    30aa:	df 93       	push	r29
    30ac:	6c 01       	movw	r12, r24
    30ae:	b6 2e       	mov	r11, r22
    30b0:	a4 2e       	mov	r10, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    30b2:	8a e1       	ldi	r24, 0x1A	; 26
    30b4:	90 e0       	ldi	r25, 0x00	; 0
    30b6:	0e 94 d6 18 	call	0x31ac	; 0x31ac <pvPortMalloc>
    30ba:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
    30bc:	00 97       	sbiw	r24, 0x00	; 0
    30be:	11 f4       	brne	.+4      	; 0x30c4 <xCoRoutineCreate+0x2c>
    30c0:	8f ef       	ldi	r24, 0xFF	; 255
    30c2:	59 c0       	rjmp	.+178    	; 0x3176 <xCoRoutineCreate+0xde>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    30c4:	80 91 81 03 	lds	r24, 0x0381
    30c8:	90 91 82 03 	lds	r25, 0x0382
    30cc:	89 2b       	or	r24, r25
    30ce:	21 f5       	brne	.+72     	; 0x3118 <xCoRoutineCreate+0x80>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    30d0:	d0 93 82 03 	sts	0x0382, r29
    30d4:	c0 93 81 03 	sts	0x0381, r28
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    30d8:	8a e8       	ldi	r24, 0x8A	; 138
    30da:	93 e0       	ldi	r25, 0x03	; 3
    30dc:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vListInitialise>
    30e0:	83 e9       	ldi	r24, 0x93	; 147
    30e2:	93 e0       	ldi	r25, 0x03	; 3
    30e4:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    30e8:	2c e9       	ldi	r18, 0x9C	; 156
    30ea:	e2 2e       	mov	r14, r18
    30ec:	23 e0       	ldi	r18, 0x03	; 3
    30ee:	f2 2e       	mov	r15, r18
    30f0:	c7 01       	movw	r24, r14
    30f2:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    30f6:	05 ea       	ldi	r16, 0xA5	; 165
    30f8:	13 e0       	ldi	r17, 0x03	; 3
    30fa:	c8 01       	movw	r24, r16
    30fc:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    3100:	82 eb       	ldi	r24, 0xB2	; 178
    3102:	93 e0       	ldi	r25, 0x03	; 3
    3104:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    3108:	f0 92 af 03 	sts	0x03AF, r15
    310c:	e0 92 ae 03 	sts	0x03AE, r14
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    3110:	10 93 b1 03 	sts	0x03B1, r17
    3114:	00 93 b0 03 	sts	0x03B0, r16
    3118:	eb 2c       	mov	r14, r11
    311a:	bb 20       	and	r11, r11
    311c:	11 f0       	breq	.+4      	; 0x3122 <xCoRoutineCreate+0x8a>
    311e:	ee 24       	eor	r14, r14
    3120:	e3 94       	inc	r14
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    3122:	19 8e       	std	Y+25, r1	; 0x19
    3124:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    3126:	ee 8a       	std	Y+22, r14	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    3128:	af 8a       	std	Y+23, r10	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    312a:	fe 01       	movw	r30, r28
    312c:	c1 92       	st	Z+, r12
    312e:	d1 92       	st	Z+, r13
    3130:	8f 01       	movw	r16, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    3132:	cf 01       	movw	r24, r30
    3134:	0e 94 c7 0d 	call	0x1b8e	; 0x1b8e <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    3138:	ce 01       	movw	r24, r28
    313a:	0c 96       	adiw	r24, 0x0c	; 12
    313c:	0e 94 c7 0d 	call	0x1b8e	; 0x1b8e <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    3140:	d9 87       	std	Y+9, r29	; 0x09
    3142:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    3144:	db 8b       	std	Y+19, r29	; 0x13
    3146:	ca 8b       	std	Y+18, r28	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    3148:	84 e0       	ldi	r24, 0x04	; 4
    314a:	90 e0       	ldi	r25, 0x00	; 0
    314c:	8e 19       	sub	r24, r14
    314e:	91 09       	sbc	r25, r1
    3150:	9d 87       	std	Y+13, r25	; 0x0d
    3152:	8c 87       	std	Y+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    3154:	9e 89       	ldd	r25, Y+22	; 0x16
    3156:	80 91 83 03 	lds	r24, 0x0383
    315a:	89 17       	cp	r24, r25
    315c:	10 f4       	brcc	.+4      	; 0x3162 <xCoRoutineCreate+0xca>
    315e:	90 93 83 03 	sts	0x0383, r25
    3162:	89 e0       	ldi	r24, 0x09	; 9
    3164:	98 9f       	mul	r25, r24
    3166:	c0 01       	movw	r24, r0
    3168:	11 24       	eor	r1, r1
    316a:	86 57       	subi	r24, 0x76	; 118
    316c:	9c 4f       	sbci	r25, 0xFC	; 252
    316e:	b8 01       	movw	r22, r16
    3170:	0e 94 cb 0d 	call	0x1b96	; 0x1b96 <vListInsertEnd>
    3174:	81 e0       	ldi	r24, 0x01	; 1
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
	}
	
	return xReturn;	
}
    3176:	df 91       	pop	r29
    3178:	cf 91       	pop	r28
    317a:	1f 91       	pop	r17
    317c:	0f 91       	pop	r16
    317e:	ff 90       	pop	r15
    3180:	ef 90       	pop	r14
    3182:	df 90       	pop	r13
    3184:	cf 90       	pop	r12
    3186:	bf 90       	pop	r11
    3188:	af 90       	pop	r10
    318a:	08 95       	ret

0000318c <vPortFree>:
{
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    318c:	08 95       	ret

0000318e <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    318e:	10 92 bc 03 	sts	0x03BC, r1
    3192:	10 92 bb 03 	sts	0x03BB, r1
}
    3196:	08 95       	ret

00003198 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    3198:	28 eb       	ldi	r18, 0xB8	; 184
    319a:	3b e0       	ldi	r19, 0x0B	; 11
    319c:	80 91 bb 03 	lds	r24, 0x03BB
    31a0:	90 91 bc 03 	lds	r25, 0x03BC
    31a4:	28 1b       	sub	r18, r24
    31a6:	39 0b       	sbc	r19, r25
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
}
    31a8:	c9 01       	movw	r24, r18
    31aa:	08 95       	ret

000031ac <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    31ac:	0f 93       	push	r16
    31ae:	1f 93       	push	r17
    31b0:	cf 93       	push	r28
    31b2:	df 93       	push	r29
    31b4:	8c 01       	movw	r16, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    31b6:	0e 94 36 11 	call	0x226c	; 0x226c <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    31ba:	80 91 bb 03 	lds	r24, 0x03BB
    31be:	90 91 bc 03 	lds	r25, 0x03BC
    31c2:	98 01       	movw	r18, r16
    31c4:	28 0f       	add	r18, r24
    31c6:	39 1f       	adc	r19, r25
    31c8:	4b e0       	ldi	r20, 0x0B	; 11
    31ca:	28 3b       	cpi	r18, 0xB8	; 184
    31cc:	34 07       	cpc	r19, r20
    31ce:	58 f4       	brcc	.+22     	; 0x31e6 <pvPortMalloc+0x3a>
    31d0:	82 17       	cp	r24, r18
    31d2:	93 07       	cpc	r25, r19
    31d4:	40 f4       	brcc	.+16     	; 0x31e6 <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    31d6:	ec 01       	movw	r28, r24
    31d8:	c3 54       	subi	r28, 0x43	; 67
    31da:	dc 4f       	sbci	r29, 0xFC	; 252
			xNextFreeByte += xWantedSize;			
    31dc:	30 93 bc 03 	sts	0x03BC, r19
    31e0:	20 93 bb 03 	sts	0x03BB, r18
    31e4:	02 c0       	rjmp	.+4      	; 0x31ea <pvPortMalloc+0x3e>
    31e6:	c0 e0       	ldi	r28, 0x00	; 0
    31e8:	d0 e0       	ldi	r29, 0x00	; 0
		}	
	}
	xTaskResumeAll();
    31ea:	0e 94 cd 12 	call	0x259a	; 0x259a <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
    31ee:	ce 01       	movw	r24, r28
    31f0:	df 91       	pop	r29
    31f2:	cf 91       	pop	r28
    31f4:	1f 91       	pop	r17
    31f6:	0f 91       	pop	r16
    31f8:	08 95       	ret

000031fa <prescaler_hex_to_value>:
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    31fa:	e8 2f       	mov	r30, r24
    31fc:	f0 e0       	ldi	r31, 0x00	; 0
    31fe:	e7 70       	andi	r30, 0x07	; 7
    3200:	f0 70       	andi	r31, 0x00	; 0
    3202:	ee 0f       	add	r30, r30
    3204:	ff 1f       	adc	r31, r31
    3206:	ef 58       	subi	r30, 0x8F	; 143
    3208:	fe 4f       	sbci	r31, 0xFE	; 254
    320a:	25 91       	lpm	r18, Z+
    320c:	34 91       	lpm	r19, Z+
}
    320e:	c9 01       	movw	r24, r18
    3210:	08 95       	ret

00003212 <prescaler_hex_to_value_for_timer2>:
uint16_t prescaler_hex_to_value_for_timer2(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to Timer2PrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(Timer2PrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    3212:	e8 2f       	mov	r30, r24
    3214:	f0 e0       	ldi	r31, 0x00	; 0
    3216:	e7 70       	andi	r30, 0x07	; 7
    3218:	f0 70       	andi	r31, 0x00	; 0
    321a:	ee 0f       	add	r30, r30
    321c:	ff 1f       	adc	r31, r31
    321e:	e3 58       	subi	r30, 0x83	; 131
    3220:	fe 4f       	sbci	r31, 0xFE	; 254
    3222:	25 91       	lpm	r18, Z+
    3224:	34 91       	lpm	r19, Z+
}
    3226:	c9 01       	movw	r24, r18
    3228:	08 95       	ret

0000322a <get_timer0_prescaler>:

uint16_t get_timer0_prescaler(void)
{
  return prescaler_hex_to_value(TCCR0B);
    322a:	85 b5       	in	r24, 0x25	; 37
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    322c:	e8 2f       	mov	r30, r24
    322e:	f0 e0       	ldi	r31, 0x00	; 0
    3230:	e7 70       	andi	r30, 0x07	; 7
    3232:	f0 70       	andi	r31, 0x00	; 0
    3234:	ee 0f       	add	r30, r30
    3236:	ff 1f       	adc	r31, r31
    3238:	ef 58       	subi	r30, 0x8F	; 143
    323a:	fe 4f       	sbci	r31, 0xFE	; 254
    323c:	25 91       	lpm	r18, Z+
    323e:	34 91       	lpm	r19, Z+
}

uint16_t get_timer0_prescaler(void)
{
  return prescaler_hex_to_value(TCCR0B);
}
    3240:	c9 01       	movw	r24, r18
    3242:	08 95       	ret

00003244 <get_timer1_prescaler>:
uint16_t get_timer1_prescaler(void)
{
  return prescaler_hex_to_value(TCCR1B);
    3244:	80 91 81 00 	lds	r24, 0x0081
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    3248:	e8 2f       	mov	r30, r24
    324a:	f0 e0       	ldi	r31, 0x00	; 0
    324c:	e7 70       	andi	r30, 0x07	; 7
    324e:	f0 70       	andi	r31, 0x00	; 0
    3250:	ee 0f       	add	r30, r30
    3252:	ff 1f       	adc	r31, r31
    3254:	ef 58       	subi	r30, 0x8F	; 143
    3256:	fe 4f       	sbci	r31, 0xFE	; 254
    3258:	25 91       	lpm	r18, Z+
    325a:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR0B);
}
uint16_t get_timer1_prescaler(void)
{
  return prescaler_hex_to_value(TCCR1B);
}
    325c:	c9 01       	movw	r24, r18
    325e:	08 95       	ret

00003260 <get_timer2_prescaler>:
uint16_t get_timer2_prescaler(void)
{
  return prescaler_hex_to_value_for_timer2(TCCR2B);
    3260:	80 91 b1 00 	lds	r24, 0x00B1
uint16_t prescaler_hex_to_value_for_timer2(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to Timer2PrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(Timer2PrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    3264:	e8 2f       	mov	r30, r24
    3266:	f0 e0       	ldi	r31, 0x00	; 0
    3268:	e7 70       	andi	r30, 0x07	; 7
    326a:	f0 70       	andi	r31, 0x00	; 0
    326c:	ee 0f       	add	r30, r30
    326e:	ff 1f       	adc	r31, r31
    3270:	e3 58       	subi	r30, 0x83	; 131
    3272:	fe 4f       	sbci	r31, 0xFE	; 254
    3274:	25 91       	lpm	r18, Z+
    3276:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR1B);
}
uint16_t get_timer2_prescaler(void)
{
  return prescaler_hex_to_value_for_timer2(TCCR2B);
}
    3278:	c9 01       	movw	r24, r18
    327a:	08 95       	ret

0000327c <get_timer3_prescaler>:
uint16_t get_timer3_prescaler(void)
{
  return prescaler_hex_to_value(TCCR3B);
    327c:	80 91 91 00 	lds	r24, 0x0091
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    3280:	e8 2f       	mov	r30, r24
    3282:	f0 e0       	ldi	r31, 0x00	; 0
    3284:	e7 70       	andi	r30, 0x07	; 7
    3286:	f0 70       	andi	r31, 0x00	; 0
    3288:	ee 0f       	add	r30, r30
    328a:	ff 1f       	adc	r31, r31
    328c:	ef 58       	subi	r30, 0x8F	; 143
    328e:	fe 4f       	sbci	r31, 0xFE	; 254
    3290:	25 91       	lpm	r18, Z+
    3292:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value_for_timer2(TCCR2B);
}
uint16_t get_timer3_prescaler(void)
{
  return prescaler_hex_to_value(TCCR3B);
}
    3294:	c9 01       	movw	r24, r18
    3296:	08 95       	ret

00003298 <get_timer4_prescaler>:
uint16_t get_timer4_prescaler(void)
{
  return prescaler_hex_to_value(TCCR4B);
    3298:	80 91 a1 00 	lds	r24, 0x00A1
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    329c:	e8 2f       	mov	r30, r24
    329e:	f0 e0       	ldi	r31, 0x00	; 0
    32a0:	e7 70       	andi	r30, 0x07	; 7
    32a2:	f0 70       	andi	r31, 0x00	; 0
    32a4:	ee 0f       	add	r30, r30
    32a6:	ff 1f       	adc	r31, r31
    32a8:	ef 58       	subi	r30, 0x8F	; 143
    32aa:	fe 4f       	sbci	r31, 0xFE	; 254
    32ac:	25 91       	lpm	r18, Z+
    32ae:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR3B);
}
uint16_t get_timer4_prescaler(void)
{
  return prescaler_hex_to_value(TCCR4B);
}
    32b0:	c9 01       	movw	r24, r18
    32b2:	08 95       	ret

000032b4 <get_timer5_prescaler>:
uint16_t get_timer5_prescaler(void)
{
  return prescaler_hex_to_value(TCCR5B);
    32b4:	80 91 21 01 	lds	r24, 0x0121
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    32b8:	e8 2f       	mov	r30, r24
    32ba:	f0 e0       	ldi	r31, 0x00	; 0
    32bc:	e7 70       	andi	r30, 0x07	; 7
    32be:	f0 70       	andi	r31, 0x00	; 0
    32c0:	ee 0f       	add	r30, r30
    32c2:	ff 1f       	adc	r31, r31
    32c4:	ef 58       	subi	r30, 0x8F	; 143
    32c6:	fe 4f       	sbci	r31, 0xFE	; 254
    32c8:	25 91       	lpm	r18, Z+
    32ca:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR4B);
}
uint16_t get_timer5_prescaler(void)
{
  return prescaler_hex_to_value(TCCR5B);
}
    32cc:	c9 01       	movw	r24, r18
    32ce:	08 95       	ret

000032d0 <get_timer0_overflow>:

const uint32_t get_timer0_overflow(void)
{
    return timer0_ovrflow_cnt;
    32d0:	20 91 5c 16 	lds	r18, 0x165C
    32d4:	30 91 5d 16 	lds	r19, 0x165D
    32d8:	40 91 5e 16 	lds	r20, 0x165E
    32dc:	50 91 5f 16 	lds	r21, 0x165F
}
    32e0:	b9 01       	movw	r22, r18
    32e2:	ca 01       	movw	r24, r20
    32e4:	08 95       	ret

000032e6 <get_timer1_overflow>:
const uint32_t get_timer1_overflow(void)
{
    return timer1_ovrflow_cnt;
    32e6:	20 91 58 16 	lds	r18, 0x1658
    32ea:	30 91 59 16 	lds	r19, 0x1659
    32ee:	40 91 5a 16 	lds	r20, 0x165A
    32f2:	50 91 5b 16 	lds	r21, 0x165B
}
    32f6:	b9 01       	movw	r22, r18
    32f8:	ca 01       	movw	r24, r20
    32fa:	08 95       	ret

000032fc <get_timer2_overflow>:
const uint32_t get_timer2_overflow(void)
{
    return timer2_ovrflow_cnt;
    32fc:	20 91 60 16 	lds	r18, 0x1660
    3300:	30 91 61 16 	lds	r19, 0x1661
    3304:	40 91 62 16 	lds	r20, 0x1662
    3308:	50 91 63 16 	lds	r21, 0x1663
}
    330c:	b9 01       	movw	r22, r18
    330e:	ca 01       	movw	r24, r20
    3310:	08 95       	ret

00003312 <get_timer3_overflow>:
const uint32_t get_timer3_overflow(void)
{
    return timer3_ovrflow_cnt;
    3312:	20 91 68 16 	lds	r18, 0x1668
    3316:	30 91 69 16 	lds	r19, 0x1669
    331a:	40 91 6a 16 	lds	r20, 0x166A
    331e:	50 91 6b 16 	lds	r21, 0x166B
}
    3322:	b9 01       	movw	r22, r18
    3324:	ca 01       	movw	r24, r20
    3326:	08 95       	ret

00003328 <get_timer4_overflow>:
const uint32_t get_timer4_overflow(void)
{
    return timer4_ovrflow_cnt;
    3328:	20 91 54 16 	lds	r18, 0x1654
    332c:	30 91 55 16 	lds	r19, 0x1655
    3330:	40 91 56 16 	lds	r20, 0x1656
    3334:	50 91 57 16 	lds	r21, 0x1657
}
    3338:	b9 01       	movw	r22, r18
    333a:	ca 01       	movw	r24, r20
    333c:	08 95       	ret

0000333e <get_timer5_overflow>:
const uint32_t get_timer5_overflow(void)
{
    return timer5_ovrflow_cnt;
    333e:	20 91 6c 16 	lds	r18, 0x166C
    3342:	30 91 6d 16 	lds	r19, 0x166D
    3346:	40 91 6e 16 	lds	r20, 0x166E
    334a:	50 91 6f 16 	lds	r21, 0x166F
}
    334e:	b9 01       	movw	r22, r18
    3350:	ca 01       	movw	r24, r20
    3352:	08 95       	ret

00003354 <get_timer0_counter>:

const uint8_t get_timer0_counter(void)
{
    return TCNT0;
    3354:	86 b5       	in	r24, 0x26	; 38
}
    3356:	08 95       	ret

00003358 <get_timer1_counter>:
const uint16_t get_timer1_counter(void)
{
    return TCNT1;
    3358:	20 91 84 00 	lds	r18, 0x0084
    335c:	30 91 85 00 	lds	r19, 0x0085
}
    3360:	c9 01       	movw	r24, r18
    3362:	08 95       	ret

00003364 <get_timer2_counter>:
const uint8_t get_timer2_counter(void)
{
    return TCNT2;
    3364:	80 91 b2 00 	lds	r24, 0x00B2
}
    3368:	08 95       	ret

0000336a <get_timer3_counter>:
const uint16_t get_timer3_counter(void)
{
    return TCNT3;
    336a:	20 91 94 00 	lds	r18, 0x0094
    336e:	30 91 95 00 	lds	r19, 0x0095
}
    3372:	c9 01       	movw	r24, r18
    3374:	08 95       	ret

00003376 <get_timer4_counter>:
const uint16_t get_timer4_counter(void)
{
    return TCNT4;
    3376:	20 91 a4 00 	lds	r18, 0x00A4
    337a:	30 91 a5 00 	lds	r19, 0x00A5
}
    337e:	c9 01       	movw	r24, r18
    3380:	08 95       	ret

00003382 <get_timer5_counter>:
const uint16_t get_timer5_counter(void)
{
    return TCNT5;
    3382:	20 91 24 01 	lds	r18, 0x0124
    3386:	30 91 25 01 	lds	r19, 0x0125
}
    338a:	c9 01       	movw	r24, r18
    338c:	08 95       	ret

0000338e <reset_timer0>:

void reset_timer0(void)
{
    TCNT0 = timer0_ovrflow_cnt = 0;
    338e:	10 92 5c 16 	sts	0x165C, r1
    3392:	10 92 5d 16 	sts	0x165D, r1
    3396:	10 92 5e 16 	sts	0x165E, r1
    339a:	10 92 5f 16 	sts	0x165F, r1
    339e:	16 bc       	out	0x26, r1	; 38
}
    33a0:	08 95       	ret

000033a2 <reset_timer1>:
void reset_timer1(void)
{
    TCNT1 = timer1_ovrflow_cnt = 0;
    33a2:	10 92 58 16 	sts	0x1658, r1
    33a6:	10 92 59 16 	sts	0x1659, r1
    33aa:	10 92 5a 16 	sts	0x165A, r1
    33ae:	10 92 5b 16 	sts	0x165B, r1
    33b2:	10 92 85 00 	sts	0x0085, r1
    33b6:	10 92 84 00 	sts	0x0084, r1
}
    33ba:	08 95       	ret

000033bc <reset_timer2>:
void reset_timer2(void)
{
    TCNT2 = timer2_ovrflow_cnt = 0;
    33bc:	10 92 60 16 	sts	0x1660, r1
    33c0:	10 92 61 16 	sts	0x1661, r1
    33c4:	10 92 62 16 	sts	0x1662, r1
    33c8:	10 92 63 16 	sts	0x1663, r1
    33cc:	10 92 b2 00 	sts	0x00B2, r1
}
    33d0:	08 95       	ret

000033d2 <reset_timer3>:
void reset_timer3(void)
{
    TCNT3 = timer3_ovrflow_cnt = 0;
    33d2:	10 92 68 16 	sts	0x1668, r1
    33d6:	10 92 69 16 	sts	0x1669, r1
    33da:	10 92 6a 16 	sts	0x166A, r1
    33de:	10 92 6b 16 	sts	0x166B, r1
    33e2:	10 92 95 00 	sts	0x0095, r1
    33e6:	10 92 94 00 	sts	0x0094, r1
}
    33ea:	08 95       	ret

000033ec <reset_timer4>:
void reset_timer4(void)
{
    TCNT4 = timer4_ovrflow_cnt = 0;
    33ec:	10 92 54 16 	sts	0x1654, r1
    33f0:	10 92 55 16 	sts	0x1655, r1
    33f4:	10 92 56 16 	sts	0x1656, r1
    33f8:	10 92 57 16 	sts	0x1657, r1
    33fc:	10 92 a5 00 	sts	0x00A5, r1
    3400:	10 92 a4 00 	sts	0x00A4, r1
}
    3404:	08 95       	ret

00003406 <reset_timer5>:
void reset_timer5(void)
{
    TCNT5 = timer5_ovrflow_cnt = 0;
    3406:	10 92 6c 16 	sts	0x166C, r1
    340a:	10 92 6d 16 	sts	0x166D, r1
    340e:	10 92 6e 16 	sts	0x166E, r1
    3412:	10 92 6f 16 	sts	0x166F, r1
    3416:	10 92 25 01 	sts	0x0125, r1
    341a:	10 92 24 01 	sts	0x0124, r1
}
    341e:	08 95       	ret

00003420 <delay_us>:

	delay_loops = ((time_us * CYCLES_PER_US)+3) / 5; // +3 for rounding up (dirty) 

	// one loop takes 5 cpu cycles 
	for (i=0; i < delay_loops; i++) {};
}
    3420:	08 95       	ret

00003422 <init_timer0>:

void init_timer0(const uint8_t prescaler)
{
  TCCR0B = prescaler;
    3422:	85 bd       	out	0x25, r24	; 37
  TIMSK0 = _BV(TOIE0); // enable interrupts
    3424:	81 e0       	ldi	r24, 0x01	; 1
    3426:	80 93 6e 00 	sts	0x006E, r24
    return TCNT5;
}

void reset_timer0(void)
{
    TCNT0 = timer0_ovrflow_cnt = 0;
    342a:	10 92 5c 16 	sts	0x165C, r1
    342e:	10 92 5d 16 	sts	0x165D, r1
    3432:	10 92 5e 16 	sts	0x165E, r1
    3436:	10 92 5f 16 	sts	0x165F, r1
    343a:	16 bc       	out	0x26, r1	; 38
void init_timer0(const uint8_t prescaler)
{
  TCCR0B = prescaler;
  TIMSK0 = _BV(TOIE0); // enable interrupts
  reset_timer0(); // reset counter
}
    343c:	08 95       	ret

0000343e <init_timer1>:
void init_timer1(const uint8_t prescaler)
{
  TCCR1B = prescaler;
    343e:	80 93 81 00 	sts	0x0081, r24
  TIMSK1 = _BV(TOIE1); // enable interrupts
    3442:	81 e0       	ldi	r24, 0x01	; 1
    3444:	80 93 6f 00 	sts	0x006F, r24
{
    TCNT0 = timer0_ovrflow_cnt = 0;
}
void reset_timer1(void)
{
    TCNT1 = timer1_ovrflow_cnt = 0;
    3448:	10 92 58 16 	sts	0x1658, r1
    344c:	10 92 59 16 	sts	0x1659, r1
    3450:	10 92 5a 16 	sts	0x165A, r1
    3454:	10 92 5b 16 	sts	0x165B, r1
    3458:	10 92 85 00 	sts	0x0085, r1
    345c:	10 92 84 00 	sts	0x0084, r1
void init_timer1(const uint8_t prescaler)
{
  TCCR1B = prescaler;
  TIMSK1 = _BV(TOIE1); // enable interrupts
  reset_timer1(); // reset counter
}
    3460:	08 95       	ret

00003462 <init_timer2>:
void init_timer2(const uint8_t prescaler)
{
  TCCR2B = prescaler;
    3462:	80 93 b1 00 	sts	0x00B1, r24
  TIMSK2 = _BV(TOIE2); // enable interrupts
    3466:	81 e0       	ldi	r24, 0x01	; 1
    3468:	80 93 70 00 	sts	0x0070, r24
{
    TCNT1 = timer1_ovrflow_cnt = 0;
}
void reset_timer2(void)
{
    TCNT2 = timer2_ovrflow_cnt = 0;
    346c:	10 92 60 16 	sts	0x1660, r1
    3470:	10 92 61 16 	sts	0x1661, r1
    3474:	10 92 62 16 	sts	0x1662, r1
    3478:	10 92 63 16 	sts	0x1663, r1
    347c:	10 92 b2 00 	sts	0x00B2, r1
void init_timer2(const uint8_t prescaler)
{
  TCCR2B = prescaler;
  TIMSK2 = _BV(TOIE2); // enable interrupts
  reset_timer2(); // reset counter
}
    3480:	08 95       	ret

00003482 <init_timer3>:
void init_timer3(const uint8_t prescaler)
{
  TCCR3B = prescaler;
    3482:	80 93 91 00 	sts	0x0091, r24
  TIMSK3 = _BV(TOIE3); // enable interrupts
    3486:	81 e0       	ldi	r24, 0x01	; 1
    3488:	80 93 71 00 	sts	0x0071, r24
{
    TCNT2 = timer2_ovrflow_cnt = 0;
}
void reset_timer3(void)
{
    TCNT3 = timer3_ovrflow_cnt = 0;
    348c:	10 92 68 16 	sts	0x1668, r1
    3490:	10 92 69 16 	sts	0x1669, r1
    3494:	10 92 6a 16 	sts	0x166A, r1
    3498:	10 92 6b 16 	sts	0x166B, r1
    349c:	10 92 95 00 	sts	0x0095, r1
    34a0:	10 92 94 00 	sts	0x0094, r1
void init_timer3(const uint8_t prescaler)
{
  TCCR3B = prescaler;
  TIMSK3 = _BV(TOIE3); // enable interrupts
  reset_timer3(); // reset counter
}
    34a4:	08 95       	ret

000034a6 <init_timer4>:
void init_timer4(const uint8_t prescaler)
{
  TCCR4B = prescaler;
    34a6:	80 93 a1 00 	sts	0x00A1, r24
  TIMSK4 = _BV(TOIE4); // enable interrupts
    34aa:	81 e0       	ldi	r24, 0x01	; 1
    34ac:	80 93 72 00 	sts	0x0072, r24
{
    TCNT3 = timer3_ovrflow_cnt = 0;
}
void reset_timer4(void)
{
    TCNT4 = timer4_ovrflow_cnt = 0;
    34b0:	10 92 54 16 	sts	0x1654, r1
    34b4:	10 92 55 16 	sts	0x1655, r1
    34b8:	10 92 56 16 	sts	0x1656, r1
    34bc:	10 92 57 16 	sts	0x1657, r1
    34c0:	10 92 a5 00 	sts	0x00A5, r1
    34c4:	10 92 a4 00 	sts	0x00A4, r1
void init_timer4(const uint8_t prescaler)
{
  TCCR4B = prescaler;
  TIMSK4 = _BV(TOIE4); // enable interrupts
  reset_timer4(); // reset counter
}
    34c8:	08 95       	ret

000034ca <init_timer5>:
void init_timer5(const uint8_t prescaler)
{
  TCCR5B = prescaler;
    34ca:	80 93 21 01 	sts	0x0121, r24
  TIMSK5 = _BV(TOIE5); // enable interrupts
    34ce:	81 e0       	ldi	r24, 0x01	; 1
    34d0:	80 93 73 00 	sts	0x0073, r24
{
    TCNT4 = timer4_ovrflow_cnt = 0;
}
void reset_timer5(void)
{
    TCNT5 = timer5_ovrflow_cnt = 0;
    34d4:	10 92 6c 16 	sts	0x166C, r1
    34d8:	10 92 6d 16 	sts	0x166D, r1
    34dc:	10 92 6e 16 	sts	0x166E, r1
    34e0:	10 92 6f 16 	sts	0x166F, r1
    34e4:	10 92 25 01 	sts	0x0125, r1
    34e8:	10 92 24 01 	sts	0x0124, r1
void init_timer5(const uint8_t prescaler)
{
  TCCR5B = prescaler;
  TIMSK5 = _BV(TOIE5); // enable interrupts
  reset_timer5(); // reset counter
}
    34ec:	08 95       	ret

000034ee <timer_attach>:

void timer_attach(TimerInterrupt_t interrupt, void (*user_func)(void) )
{
  // set the interrupt function to run
  // the supplied user's function
  TimerIntFunc[interrupt] = user_func;
    34ee:	e8 2f       	mov	r30, r24
    34f0:	f0 e0       	ldi	r31, 0x00	; 0
    34f2:	ee 0f       	add	r30, r30
    34f4:	ff 1f       	adc	r31, r31
    34f6:	eb 58       	subi	r30, 0x8B	; 139
    34f8:	f0 4f       	sbci	r31, 0xF0	; 240
    34fa:	71 83       	std	Z+1, r23	; 0x01
    34fc:	60 83       	st	Z, r22
}
    34fe:	08 95       	ret

00003500 <timer_detach>:

void timer_detach(TimerInterrupt_t interrupt)
{
  // clear the user defined interrupt function
  TimerIntFunc[interrupt] = NULL;
    3500:	e8 2f       	mov	r30, r24
    3502:	f0 e0       	ldi	r31, 0x00	; 0
    3504:	ee 0f       	add	r30, r30
    3506:	ff 1f       	adc	r31, r31
    3508:	eb 58       	subi	r30, 0x8B	; 139
    350a:	f0 4f       	sbci	r31, 0xF0	; 240
    350c:	11 82       	std	Z+1, r1	; 0x01
    350e:	10 82       	st	Z, r1
}
    3510:	08 95       	ret

00003512 <_delay_loop_2>:

void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3512:	01 97       	sbiw	r24, 0x01	; 1
    3514:	f1 f7       	brne	.-4      	; 0x3512 <_delay_loop_2>
		"1: sbiw %0,1" "\n\t"
		"brne 1b"
		: "=w" (__count)
		: "0" (__count)
	);
}
    3516:	08 95       	ret

00003518 <sleep>:

void sleep(uint16_t time_ms)
{
    3518:	af 92       	push	r10
    351a:	bf 92       	push	r11
    351c:	cf 92       	push	r12
    351e:	df 92       	push	r13
    3520:	ef 92       	push	r14
    3522:	ff 92       	push	r15
    3524:	0f 93       	push	r16
    3526:	1f 93       	push	r17
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * time_ms;
    3528:	a0 e0       	ldi	r26, 0x00	; 0
    352a:	b0 e0       	ldi	r27, 0x00	; 0
    352c:	bc 01       	movw	r22, r24
    352e:	cd 01       	movw	r24, r26
    3530:	0e 94 30 2c 	call	0x5860	; 0x5860 <__floatunsisf>
    3534:	5b 01       	movw	r10, r22
    3536:	6c 01       	movw	r12, r24
    3538:	20 e0       	ldi	r18, 0x00	; 0
    353a:	30 e0       	ldi	r19, 0x00	; 0
    353c:	4a e7       	ldi	r20, 0x7A	; 122
    353e:	55 e4       	ldi	r21, 0x45	; 69
    3540:	0e 94 67 2d 	call	0x5ace	; 0x5ace <__mulsf3>
    3544:	7b 01       	movw	r14, r22
    3546:	8c 01       	movw	r16, r24
	if (__tmp < 1.0)
    3548:	20 e0       	ldi	r18, 0x00	; 0
    354a:	30 e0       	ldi	r19, 0x00	; 0
    354c:	40 e8       	ldi	r20, 0x80	; 128
    354e:	5f e3       	ldi	r21, 0x3F	; 63
    3550:	0e 94 93 2b 	call	0x5726	; 0x5726 <__cmpsf2>
    3554:	88 23       	and	r24, r24
    3556:	1c f4       	brge	.+6      	; 0x355e <sleep+0x46>
    3558:	61 e0       	ldi	r22, 0x01	; 1
    355a:	70 e0       	ldi	r23, 0x00	; 0
    355c:	24 c0       	rjmp	.+72     	; 0x35a6 <sleep+0x8e>
		__ticks = 1;
	else if (__tmp > 65535)
    355e:	c8 01       	movw	r24, r16
    3560:	b7 01       	movw	r22, r14
    3562:	20 e0       	ldi	r18, 0x00	; 0
    3564:	3f ef       	ldi	r19, 0xFF	; 255
    3566:	4f e7       	ldi	r20, 0x7F	; 127
    3568:	57 e4       	ldi	r21, 0x47	; 71
    356a:	0e 94 5c 2d 	call	0x5ab8	; 0x5ab8 <__gesf2>
    356e:	18 16       	cp	r1, r24
    3570:	b4 f4       	brge	.+44     	; 0x359e <sleep+0x86>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (time_ms * 10.0);
    3572:	c6 01       	movw	r24, r12
    3574:	b5 01       	movw	r22, r10
    3576:	20 e0       	ldi	r18, 0x00	; 0
    3578:	30 e0       	ldi	r19, 0x00	; 0
    357a:	40 e2       	ldi	r20, 0x20	; 32
    357c:	51 e4       	ldi	r21, 0x41	; 65
    357e:	0e 94 67 2d 	call	0x5ace	; 0x5ace <__mulsf3>
    3582:	0e 94 04 2c 	call	0x5808	; 0x5808 <__fixunssfsi>
}

void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3586:	80 e9       	ldi	r24, 0x90	; 144
    3588:	91 e0       	ldi	r25, 0x01	; 1
    358a:	05 c0       	rjmp	.+10     	; 0x3596 <sleep+0x7e>
    358c:	fc 01       	movw	r30, r24
    358e:	31 97       	sbiw	r30, 0x01	; 1
    3590:	f1 f7       	brne	.-4      	; 0x358e <sleep+0x76>
		__ticks = (uint16_t) (time_ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3592:	61 50       	subi	r22, 0x01	; 1
    3594:	70 40       	sbci	r23, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (time_ms * 10.0);
		while(__ticks)
    3596:	61 15       	cp	r22, r1
    3598:	71 05       	cpc	r23, r1
    359a:	c1 f7       	brne	.-16     	; 0x358c <sleep+0x74>
    359c:	07 c0       	rjmp	.+14     	; 0x35ac <sleep+0x94>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    359e:	c8 01       	movw	r24, r16
    35a0:	b7 01       	movw	r22, r14
    35a2:	0e 94 04 2c 	call	0x5808	; 0x5808 <__fixunssfsi>
}

void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    35a6:	cb 01       	movw	r24, r22
    35a8:	01 97       	sbiw	r24, 0x01	; 1
    35aa:	f1 f7       	brne	.-4      	; 0x35a8 <sleep+0x90>
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
	_delay_loop_2(__ticks);
}
    35ac:	1f 91       	pop	r17
    35ae:	0f 91       	pop	r16
    35b0:	ff 90       	pop	r15
    35b2:	ef 90       	pop	r14
    35b4:	df 90       	pop	r13
    35b6:	cf 90       	pop	r12
    35b8:	bf 90       	pop	r11
    35ba:	af 90       	pop	r10
    35bc:	08 95       	ret

000035be <__vector_23>:
    }
  }
}*/

ISR(TIMER0_OVF_vect) 
{
    35be:	1f 92       	push	r1
    35c0:	0f 92       	push	r0
    35c2:	0f b6       	in	r0, 0x3f	; 63
    35c4:	0f 92       	push	r0
    35c6:	11 24       	eor	r1, r1
    35c8:	2f 93       	push	r18
    35ca:	3f 93       	push	r19
    35cc:	4f 93       	push	r20
    35ce:	5f 93       	push	r21
    35d0:	6f 93       	push	r22
    35d2:	7f 93       	push	r23
    35d4:	8f 93       	push	r24
    35d6:	9f 93       	push	r25
    35d8:	af 93       	push	r26
    35da:	bf 93       	push	r27
    35dc:	ef 93       	push	r30
    35de:	ff 93       	push	r31
  timer0_ovrflow_cnt++;
    35e0:	80 91 5c 16 	lds	r24, 0x165C
    35e4:	90 91 5d 16 	lds	r25, 0x165D
    35e8:	a0 91 5e 16 	lds	r26, 0x165E
    35ec:	b0 91 5f 16 	lds	r27, 0x165F
    35f0:	01 96       	adiw	r24, 0x01	; 1
    35f2:	a1 1d       	adc	r26, r1
    35f4:	b1 1d       	adc	r27, r1
    35f6:	80 93 5c 16 	sts	0x165C, r24
    35fa:	90 93 5d 16 	sts	0x165D, r25
    35fe:	a0 93 5e 16 	sts	0x165E, r26
    3602:	b0 93 5f 16 	sts	0x165F, r27
  timer_sleep_cnt++;
    3606:	80 91 64 16 	lds	r24, 0x1664
    360a:	90 91 65 16 	lds	r25, 0x1665
    360e:	a0 91 66 16 	lds	r26, 0x1666
    3612:	b0 91 67 16 	lds	r27, 0x1667
    3616:	01 96       	adiw	r24, 0x01	; 1
    3618:	a1 1d       	adc	r26, r1
    361a:	b1 1d       	adc	r27, r1
    361c:	80 93 64 16 	sts	0x1664, r24
    3620:	90 93 65 16 	sts	0x1665, r25
    3624:	a0 93 66 16 	sts	0x1666, r26
    3628:	b0 93 67 16 	sts	0x1667, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER0_OVF_interrupt);
    362c:	80 91 79 0f 	lds	r24, 0x0F79
    3630:	90 91 7a 0f 	lds	r25, 0x0F7A
    3634:	89 2b       	or	r24, r25
    3636:	29 f0       	breq	.+10     	; 0x3642 <__vector_23+0x84>
    3638:	e0 91 79 0f 	lds	r30, 0x0F79
    363c:	f0 91 7a 0f 	lds	r31, 0x0F7A
    3640:	09 95       	icall
}
    3642:	ff 91       	pop	r31
    3644:	ef 91       	pop	r30
    3646:	bf 91       	pop	r27
    3648:	af 91       	pop	r26
    364a:	9f 91       	pop	r25
    364c:	8f 91       	pop	r24
    364e:	7f 91       	pop	r23
    3650:	6f 91       	pop	r22
    3652:	5f 91       	pop	r21
    3654:	4f 91       	pop	r20
    3656:	3f 91       	pop	r19
    3658:	2f 91       	pop	r18
    365a:	0f 90       	pop	r0
    365c:	0f be       	out	0x3f, r0	; 63
    365e:	0f 90       	pop	r0
    3660:	1f 90       	pop	r1
    3662:	18 95       	reti

00003664 <__vector_20>:
ISR(TIMER1_OVF_vect) 
{
    3664:	1f 92       	push	r1
    3666:	0f 92       	push	r0
    3668:	0f b6       	in	r0, 0x3f	; 63
    366a:	0f 92       	push	r0
    366c:	11 24       	eor	r1, r1
    366e:	2f 93       	push	r18
    3670:	3f 93       	push	r19
    3672:	4f 93       	push	r20
    3674:	5f 93       	push	r21
    3676:	6f 93       	push	r22
    3678:	7f 93       	push	r23
    367a:	8f 93       	push	r24
    367c:	9f 93       	push	r25
    367e:	af 93       	push	r26
    3680:	bf 93       	push	r27
    3682:	ef 93       	push	r30
    3684:	ff 93       	push	r31
  timer1_ovrflow_cnt++;
    3686:	80 91 58 16 	lds	r24, 0x1658
    368a:	90 91 59 16 	lds	r25, 0x1659
    368e:	a0 91 5a 16 	lds	r26, 0x165A
    3692:	b0 91 5b 16 	lds	r27, 0x165B
    3696:	01 96       	adiw	r24, 0x01	; 1
    3698:	a1 1d       	adc	r26, r1
    369a:	b1 1d       	adc	r27, r1
    369c:	80 93 58 16 	sts	0x1658, r24
    36a0:	90 93 59 16 	sts	0x1659, r25
    36a4:	a0 93 5a 16 	sts	0x165A, r26
    36a8:	b0 93 5b 16 	sts	0x165B, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER1_OVF_interrupt);
    36ac:	80 91 83 0f 	lds	r24, 0x0F83
    36b0:	90 91 84 0f 	lds	r25, 0x0F84
    36b4:	89 2b       	or	r24, r25
    36b6:	29 f0       	breq	.+10     	; 0x36c2 <__vector_20+0x5e>
    36b8:	e0 91 83 0f 	lds	r30, 0x0F83
    36bc:	f0 91 84 0f 	lds	r31, 0x0F84
    36c0:	09 95       	icall
}
    36c2:	ff 91       	pop	r31
    36c4:	ef 91       	pop	r30
    36c6:	bf 91       	pop	r27
    36c8:	af 91       	pop	r26
    36ca:	9f 91       	pop	r25
    36cc:	8f 91       	pop	r24
    36ce:	7f 91       	pop	r23
    36d0:	6f 91       	pop	r22
    36d2:	5f 91       	pop	r21
    36d4:	4f 91       	pop	r20
    36d6:	3f 91       	pop	r19
    36d8:	2f 91       	pop	r18
    36da:	0f 90       	pop	r0
    36dc:	0f be       	out	0x3f, r0	; 63
    36de:	0f 90       	pop	r0
    36e0:	1f 90       	pop	r1
    36e2:	18 95       	reti

000036e4 <__vector_15>:
ISR(TIMER2_OVF_vect) 
{
    36e4:	1f 92       	push	r1
    36e6:	0f 92       	push	r0
    36e8:	0f b6       	in	r0, 0x3f	; 63
    36ea:	0f 92       	push	r0
    36ec:	11 24       	eor	r1, r1
    36ee:	2f 93       	push	r18
    36f0:	3f 93       	push	r19
    36f2:	4f 93       	push	r20
    36f4:	5f 93       	push	r21
    36f6:	6f 93       	push	r22
    36f8:	7f 93       	push	r23
    36fa:	8f 93       	push	r24
    36fc:	9f 93       	push	r25
    36fe:	af 93       	push	r26
    3700:	bf 93       	push	r27
    3702:	ef 93       	push	r30
    3704:	ff 93       	push	r31
  timer2_ovrflow_cnt++;
    3706:	80 91 60 16 	lds	r24, 0x1660
    370a:	90 91 61 16 	lds	r25, 0x1661
    370e:	a0 91 62 16 	lds	r26, 0x1662
    3712:	b0 91 63 16 	lds	r27, 0x1663
    3716:	01 96       	adiw	r24, 0x01	; 1
    3718:	a1 1d       	adc	r26, r1
    371a:	b1 1d       	adc	r27, r1
    371c:	80 93 60 16 	sts	0x1660, r24
    3720:	90 93 61 16 	sts	0x1661, r25
    3724:	a0 93 62 16 	sts	0x1662, r26
    3728:	b0 93 63 16 	sts	0x1663, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER2_OVF_interrupt);
    372c:	80 91 89 0f 	lds	r24, 0x0F89
    3730:	90 91 8a 0f 	lds	r25, 0x0F8A
    3734:	89 2b       	or	r24, r25
    3736:	29 f0       	breq	.+10     	; 0x3742 <__vector_15+0x5e>
    3738:	e0 91 89 0f 	lds	r30, 0x0F89
    373c:	f0 91 8a 0f 	lds	r31, 0x0F8A
    3740:	09 95       	icall
}
    3742:	ff 91       	pop	r31
    3744:	ef 91       	pop	r30
    3746:	bf 91       	pop	r27
    3748:	af 91       	pop	r26
    374a:	9f 91       	pop	r25
    374c:	8f 91       	pop	r24
    374e:	7f 91       	pop	r23
    3750:	6f 91       	pop	r22
    3752:	5f 91       	pop	r21
    3754:	4f 91       	pop	r20
    3756:	3f 91       	pop	r19
    3758:	2f 91       	pop	r18
    375a:	0f 90       	pop	r0
    375c:	0f be       	out	0x3f, r0	; 63
    375e:	0f 90       	pop	r0
    3760:	1f 90       	pop	r1
    3762:	18 95       	reti

00003764 <__vector_35>:
ISR(TIMER3_OVF_vect) 
{
    3764:	1f 92       	push	r1
    3766:	0f 92       	push	r0
    3768:	0f b6       	in	r0, 0x3f	; 63
    376a:	0f 92       	push	r0
    376c:	11 24       	eor	r1, r1
    376e:	2f 93       	push	r18
    3770:	3f 93       	push	r19
    3772:	4f 93       	push	r20
    3774:	5f 93       	push	r21
    3776:	6f 93       	push	r22
    3778:	7f 93       	push	r23
    377a:	8f 93       	push	r24
    377c:	9f 93       	push	r25
    377e:	af 93       	push	r26
    3780:	bf 93       	push	r27
    3782:	ef 93       	push	r30
    3784:	ff 93       	push	r31
  timer3_ovrflow_cnt++;
    3786:	80 91 68 16 	lds	r24, 0x1668
    378a:	90 91 69 16 	lds	r25, 0x1669
    378e:	a0 91 6a 16 	lds	r26, 0x166A
    3792:	b0 91 6b 16 	lds	r27, 0x166B
    3796:	01 96       	adiw	r24, 0x01	; 1
    3798:	a1 1d       	adc	r26, r1
    379a:	b1 1d       	adc	r27, r1
    379c:	80 93 68 16 	sts	0x1668, r24
    37a0:	90 93 69 16 	sts	0x1669, r25
    37a4:	a0 93 6a 16 	sts	0x166A, r26
    37a8:	b0 93 6b 16 	sts	0x166B, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER3_OVF_interrupt);
    37ac:	80 91 93 0f 	lds	r24, 0x0F93
    37b0:	90 91 94 0f 	lds	r25, 0x0F94
    37b4:	89 2b       	or	r24, r25
    37b6:	29 f0       	breq	.+10     	; 0x37c2 <__vector_35+0x5e>
    37b8:	e0 91 93 0f 	lds	r30, 0x0F93
    37bc:	f0 91 94 0f 	lds	r31, 0x0F94
    37c0:	09 95       	icall
}
    37c2:	ff 91       	pop	r31
    37c4:	ef 91       	pop	r30
    37c6:	bf 91       	pop	r27
    37c8:	af 91       	pop	r26
    37ca:	9f 91       	pop	r25
    37cc:	8f 91       	pop	r24
    37ce:	7f 91       	pop	r23
    37d0:	6f 91       	pop	r22
    37d2:	5f 91       	pop	r21
    37d4:	4f 91       	pop	r20
    37d6:	3f 91       	pop	r19
    37d8:	2f 91       	pop	r18
    37da:	0f 90       	pop	r0
    37dc:	0f be       	out	0x3f, r0	; 63
    37de:	0f 90       	pop	r0
    37e0:	1f 90       	pop	r1
    37e2:	18 95       	reti

000037e4 <__vector_45>:
ISR(TIMER4_OVF_vect) 
{
    37e4:	1f 92       	push	r1
    37e6:	0f 92       	push	r0
    37e8:	0f b6       	in	r0, 0x3f	; 63
    37ea:	0f 92       	push	r0
    37ec:	11 24       	eor	r1, r1
    37ee:	2f 93       	push	r18
    37f0:	3f 93       	push	r19
    37f2:	4f 93       	push	r20
    37f4:	5f 93       	push	r21
    37f6:	6f 93       	push	r22
    37f8:	7f 93       	push	r23
    37fa:	8f 93       	push	r24
    37fc:	9f 93       	push	r25
    37fe:	af 93       	push	r26
    3800:	bf 93       	push	r27
    3802:	ef 93       	push	r30
    3804:	ff 93       	push	r31
  timer4_ovrflow_cnt++;
    3806:	80 91 54 16 	lds	r24, 0x1654
    380a:	90 91 55 16 	lds	r25, 0x1655
    380e:	a0 91 56 16 	lds	r26, 0x1656
    3812:	b0 91 57 16 	lds	r27, 0x1657
    3816:	01 96       	adiw	r24, 0x01	; 1
    3818:	a1 1d       	adc	r26, r1
    381a:	b1 1d       	adc	r27, r1
    381c:	80 93 54 16 	sts	0x1654, r24
    3820:	90 93 55 16 	sts	0x1655, r25
    3824:	a0 93 56 16 	sts	0x1656, r26
    3828:	b0 93 57 16 	sts	0x1657, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER4_OVF_interrupt);
    382c:	80 91 9d 0f 	lds	r24, 0x0F9D
    3830:	90 91 9e 0f 	lds	r25, 0x0F9E
    3834:	89 2b       	or	r24, r25
    3836:	29 f0       	breq	.+10     	; 0x3842 <__vector_45+0x5e>
    3838:	e0 91 9d 0f 	lds	r30, 0x0F9D
    383c:	f0 91 9e 0f 	lds	r31, 0x0F9E
    3840:	09 95       	icall
}
    3842:	ff 91       	pop	r31
    3844:	ef 91       	pop	r30
    3846:	bf 91       	pop	r27
    3848:	af 91       	pop	r26
    384a:	9f 91       	pop	r25
    384c:	8f 91       	pop	r24
    384e:	7f 91       	pop	r23
    3850:	6f 91       	pop	r22
    3852:	5f 91       	pop	r21
    3854:	4f 91       	pop	r20
    3856:	3f 91       	pop	r19
    3858:	2f 91       	pop	r18
    385a:	0f 90       	pop	r0
    385c:	0f be       	out	0x3f, r0	; 63
    385e:	0f 90       	pop	r0
    3860:	1f 90       	pop	r1
    3862:	18 95       	reti

00003864 <__vector_50>:
ISR(TIMER5_OVF_vect) 
{
    3864:	1f 92       	push	r1
    3866:	0f 92       	push	r0
    3868:	0f b6       	in	r0, 0x3f	; 63
    386a:	0f 92       	push	r0
    386c:	11 24       	eor	r1, r1
    386e:	2f 93       	push	r18
    3870:	3f 93       	push	r19
    3872:	4f 93       	push	r20
    3874:	5f 93       	push	r21
    3876:	6f 93       	push	r22
    3878:	7f 93       	push	r23
    387a:	8f 93       	push	r24
    387c:	9f 93       	push	r25
    387e:	af 93       	push	r26
    3880:	bf 93       	push	r27
    3882:	ef 93       	push	r30
    3884:	ff 93       	push	r31
  timer5_ovrflow_cnt++;
    3886:	80 91 6c 16 	lds	r24, 0x166C
    388a:	90 91 6d 16 	lds	r25, 0x166D
    388e:	a0 91 6e 16 	lds	r26, 0x166E
    3892:	b0 91 6f 16 	lds	r27, 0x166F
    3896:	01 96       	adiw	r24, 0x01	; 1
    3898:	a1 1d       	adc	r26, r1
    389a:	b1 1d       	adc	r27, r1
    389c:	80 93 6c 16 	sts	0x166C, r24
    38a0:	90 93 6d 16 	sts	0x166D, r25
    38a4:	a0 93 6e 16 	sts	0x166E, r26
    38a8:	b0 93 6f 16 	sts	0x166F, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER5_OVF_interrupt);
    38ac:	80 91 a7 0f 	lds	r24, 0x0FA7
    38b0:	90 91 a8 0f 	lds	r25, 0x0FA8
    38b4:	89 2b       	or	r24, r25
    38b6:	29 f0       	breq	.+10     	; 0x38c2 <__vector_50+0x5e>
    38b8:	e0 91 a7 0f 	lds	r30, 0x0FA7
    38bc:	f0 91 a8 0f 	lds	r31, 0x0FA8
    38c0:	09 95       	icall
}
    38c2:	ff 91       	pop	r31
    38c4:	ef 91       	pop	r30
    38c6:	bf 91       	pop	r27
    38c8:	af 91       	pop	r26
    38ca:	9f 91       	pop	r25
    38cc:	8f 91       	pop	r24
    38ce:	7f 91       	pop	r23
    38d0:	6f 91       	pop	r22
    38d2:	5f 91       	pop	r21
    38d4:	4f 91       	pop	r20
    38d6:	3f 91       	pop	r19
    38d8:	2f 91       	pop	r18
    38da:	0f 90       	pop	r0
    38dc:	0f be       	out	0x3f, r0	; 63
    38de:	0f 90       	pop	r0
    38e0:	1f 90       	pop	r1
    38e2:	18 95       	reti

000038e4 <__vector_21>:
ISR(TIMER0_COMPA_vect)
{
    38e4:	1f 92       	push	r1
    38e6:	0f 92       	push	r0
    38e8:	0f b6       	in	r0, 0x3f	; 63
    38ea:	0f 92       	push	r0
    38ec:	11 24       	eor	r1, r1
    38ee:	2f 93       	push	r18
    38f0:	3f 93       	push	r19
    38f2:	4f 93       	push	r20
    38f4:	5f 93       	push	r21
    38f6:	6f 93       	push	r22
    38f8:	7f 93       	push	r23
    38fa:	8f 93       	push	r24
    38fc:	9f 93       	push	r25
    38fe:	af 93       	push	r26
    3900:	bf 93       	push	r27
    3902:	ef 93       	push	r30
    3904:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER0_COMPA_interrupt);
    3906:	80 91 75 0f 	lds	r24, 0x0F75
    390a:	90 91 76 0f 	lds	r25, 0x0F76
    390e:	89 2b       	or	r24, r25
    3910:	29 f0       	breq	.+10     	; 0x391c <__vector_21+0x38>
    3912:	e0 91 75 0f 	lds	r30, 0x0F75
    3916:	f0 91 76 0f 	lds	r31, 0x0F76
    391a:	09 95       	icall
}
    391c:	ff 91       	pop	r31
    391e:	ef 91       	pop	r30
    3920:	bf 91       	pop	r27
    3922:	af 91       	pop	r26
    3924:	9f 91       	pop	r25
    3926:	8f 91       	pop	r24
    3928:	7f 91       	pop	r23
    392a:	6f 91       	pop	r22
    392c:	5f 91       	pop	r21
    392e:	4f 91       	pop	r20
    3930:	3f 91       	pop	r19
    3932:	2f 91       	pop	r18
    3934:	0f 90       	pop	r0
    3936:	0f be       	out	0x3f, r0	; 63
    3938:	0f 90       	pop	r0
    393a:	1f 90       	pop	r1
    393c:	18 95       	reti

0000393e <__vector_22>:
ISR(TIMER0_COMPB_vect)
{
    393e:	1f 92       	push	r1
    3940:	0f 92       	push	r0
    3942:	0f b6       	in	r0, 0x3f	; 63
    3944:	0f 92       	push	r0
    3946:	11 24       	eor	r1, r1
    3948:	2f 93       	push	r18
    394a:	3f 93       	push	r19
    394c:	4f 93       	push	r20
    394e:	5f 93       	push	r21
    3950:	6f 93       	push	r22
    3952:	7f 93       	push	r23
    3954:	8f 93       	push	r24
    3956:	9f 93       	push	r25
    3958:	af 93       	push	r26
    395a:	bf 93       	push	r27
    395c:	ef 93       	push	r30
    395e:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER0_COMPB_interrupt);
    3960:	80 91 77 0f 	lds	r24, 0x0F77
    3964:	90 91 78 0f 	lds	r25, 0x0F78
    3968:	89 2b       	or	r24, r25
    396a:	29 f0       	breq	.+10     	; 0x3976 <__vector_22+0x38>
    396c:	e0 91 77 0f 	lds	r30, 0x0F77
    3970:	f0 91 78 0f 	lds	r31, 0x0F78
    3974:	09 95       	icall
}
    3976:	ff 91       	pop	r31
    3978:	ef 91       	pop	r30
    397a:	bf 91       	pop	r27
    397c:	af 91       	pop	r26
    397e:	9f 91       	pop	r25
    3980:	8f 91       	pop	r24
    3982:	7f 91       	pop	r23
    3984:	6f 91       	pop	r22
    3986:	5f 91       	pop	r21
    3988:	4f 91       	pop	r20
    398a:	3f 91       	pop	r19
    398c:	2f 91       	pop	r18
    398e:	0f 90       	pop	r0
    3990:	0f be       	out	0x3f, r0	; 63
    3992:	0f 90       	pop	r0
    3994:	1f 90       	pop	r1
    3996:	18 95       	reti

00003998 <__vector_16>:
ISR(TIMER1_CAPT_vect)
{
    3998:	1f 92       	push	r1
    399a:	0f 92       	push	r0
    399c:	0f b6       	in	r0, 0x3f	; 63
    399e:	0f 92       	push	r0
    39a0:	11 24       	eor	r1, r1
    39a2:	2f 93       	push	r18
    39a4:	3f 93       	push	r19
    39a6:	4f 93       	push	r20
    39a8:	5f 93       	push	r21
    39aa:	6f 93       	push	r22
    39ac:	7f 93       	push	r23
    39ae:	8f 93       	push	r24
    39b0:	9f 93       	push	r25
    39b2:	af 93       	push	r26
    39b4:	bf 93       	push	r27
    39b6:	ef 93       	push	r30
    39b8:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER1_CAPT_interrupt);
    39ba:	80 91 7b 0f 	lds	r24, 0x0F7B
    39be:	90 91 7c 0f 	lds	r25, 0x0F7C
    39c2:	89 2b       	or	r24, r25
    39c4:	29 f0       	breq	.+10     	; 0x39d0 <__vector_16+0x38>
    39c6:	e0 91 7b 0f 	lds	r30, 0x0F7B
    39ca:	f0 91 7c 0f 	lds	r31, 0x0F7C
    39ce:	09 95       	icall
}
    39d0:	ff 91       	pop	r31
    39d2:	ef 91       	pop	r30
    39d4:	bf 91       	pop	r27
    39d6:	af 91       	pop	r26
    39d8:	9f 91       	pop	r25
    39da:	8f 91       	pop	r24
    39dc:	7f 91       	pop	r23
    39de:	6f 91       	pop	r22
    39e0:	5f 91       	pop	r21
    39e2:	4f 91       	pop	r20
    39e4:	3f 91       	pop	r19
    39e6:	2f 91       	pop	r18
    39e8:	0f 90       	pop	r0
    39ea:	0f be       	out	0x3f, r0	; 63
    39ec:	0f 90       	pop	r0
    39ee:	1f 90       	pop	r1
    39f0:	18 95       	reti

000039f2 <__vector_18>:
{
  RUN_USER_DEFINE_INTERRUPT(TIMER1_COMPA_interrupt);
}
*/
ISR(TIMER1_COMPB_vect)
{
    39f2:	1f 92       	push	r1
    39f4:	0f 92       	push	r0
    39f6:	0f b6       	in	r0, 0x3f	; 63
    39f8:	0f 92       	push	r0
    39fa:	11 24       	eor	r1, r1
    39fc:	2f 93       	push	r18
    39fe:	3f 93       	push	r19
    3a00:	4f 93       	push	r20
    3a02:	5f 93       	push	r21
    3a04:	6f 93       	push	r22
    3a06:	7f 93       	push	r23
    3a08:	8f 93       	push	r24
    3a0a:	9f 93       	push	r25
    3a0c:	af 93       	push	r26
    3a0e:	bf 93       	push	r27
    3a10:	ef 93       	push	r30
    3a12:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER1_COMPB_interrupt);
    3a14:	80 91 7f 0f 	lds	r24, 0x0F7F
    3a18:	90 91 80 0f 	lds	r25, 0x0F80
    3a1c:	89 2b       	or	r24, r25
    3a1e:	29 f0       	breq	.+10     	; 0x3a2a <__vector_18+0x38>
    3a20:	e0 91 7f 0f 	lds	r30, 0x0F7F
    3a24:	f0 91 80 0f 	lds	r31, 0x0F80
    3a28:	09 95       	icall
}
    3a2a:	ff 91       	pop	r31
    3a2c:	ef 91       	pop	r30
    3a2e:	bf 91       	pop	r27
    3a30:	af 91       	pop	r26
    3a32:	9f 91       	pop	r25
    3a34:	8f 91       	pop	r24
    3a36:	7f 91       	pop	r23
    3a38:	6f 91       	pop	r22
    3a3a:	5f 91       	pop	r21
    3a3c:	4f 91       	pop	r20
    3a3e:	3f 91       	pop	r19
    3a40:	2f 91       	pop	r18
    3a42:	0f 90       	pop	r0
    3a44:	0f be       	out	0x3f, r0	; 63
    3a46:	0f 90       	pop	r0
    3a48:	1f 90       	pop	r1
    3a4a:	18 95       	reti

00003a4c <__vector_19>:
ISR(TIMER1_COMPC_vect)
{
    3a4c:	1f 92       	push	r1
    3a4e:	0f 92       	push	r0
    3a50:	0f b6       	in	r0, 0x3f	; 63
    3a52:	0f 92       	push	r0
    3a54:	11 24       	eor	r1, r1
    3a56:	2f 93       	push	r18
    3a58:	3f 93       	push	r19
    3a5a:	4f 93       	push	r20
    3a5c:	5f 93       	push	r21
    3a5e:	6f 93       	push	r22
    3a60:	7f 93       	push	r23
    3a62:	8f 93       	push	r24
    3a64:	9f 93       	push	r25
    3a66:	af 93       	push	r26
    3a68:	bf 93       	push	r27
    3a6a:	ef 93       	push	r30
    3a6c:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER1_COMPC_interrupt);
    3a6e:	80 91 81 0f 	lds	r24, 0x0F81
    3a72:	90 91 82 0f 	lds	r25, 0x0F82
    3a76:	89 2b       	or	r24, r25
    3a78:	29 f0       	breq	.+10     	; 0x3a84 <__vector_19+0x38>
    3a7a:	e0 91 81 0f 	lds	r30, 0x0F81
    3a7e:	f0 91 82 0f 	lds	r31, 0x0F82
    3a82:	09 95       	icall
}
    3a84:	ff 91       	pop	r31
    3a86:	ef 91       	pop	r30
    3a88:	bf 91       	pop	r27
    3a8a:	af 91       	pop	r26
    3a8c:	9f 91       	pop	r25
    3a8e:	8f 91       	pop	r24
    3a90:	7f 91       	pop	r23
    3a92:	6f 91       	pop	r22
    3a94:	5f 91       	pop	r21
    3a96:	4f 91       	pop	r20
    3a98:	3f 91       	pop	r19
    3a9a:	2f 91       	pop	r18
    3a9c:	0f 90       	pop	r0
    3a9e:	0f be       	out	0x3f, r0	; 63
    3aa0:	0f 90       	pop	r0
    3aa2:	1f 90       	pop	r1
    3aa4:	18 95       	reti

00003aa6 <__vector_13>:
ISR(TIMER2_COMPA_vect)
{
    3aa6:	1f 92       	push	r1
    3aa8:	0f 92       	push	r0
    3aaa:	0f b6       	in	r0, 0x3f	; 63
    3aac:	0f 92       	push	r0
    3aae:	11 24       	eor	r1, r1
    3ab0:	2f 93       	push	r18
    3ab2:	3f 93       	push	r19
    3ab4:	4f 93       	push	r20
    3ab6:	5f 93       	push	r21
    3ab8:	6f 93       	push	r22
    3aba:	7f 93       	push	r23
    3abc:	8f 93       	push	r24
    3abe:	9f 93       	push	r25
    3ac0:	af 93       	push	r26
    3ac2:	bf 93       	push	r27
    3ac4:	ef 93       	push	r30
    3ac6:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER2_COMPA_interrupt);
    3ac8:	80 91 85 0f 	lds	r24, 0x0F85
    3acc:	90 91 86 0f 	lds	r25, 0x0F86
    3ad0:	89 2b       	or	r24, r25
    3ad2:	29 f0       	breq	.+10     	; 0x3ade <__vector_13+0x38>
    3ad4:	e0 91 85 0f 	lds	r30, 0x0F85
    3ad8:	f0 91 86 0f 	lds	r31, 0x0F86
    3adc:	09 95       	icall
}
    3ade:	ff 91       	pop	r31
    3ae0:	ef 91       	pop	r30
    3ae2:	bf 91       	pop	r27
    3ae4:	af 91       	pop	r26
    3ae6:	9f 91       	pop	r25
    3ae8:	8f 91       	pop	r24
    3aea:	7f 91       	pop	r23
    3aec:	6f 91       	pop	r22
    3aee:	5f 91       	pop	r21
    3af0:	4f 91       	pop	r20
    3af2:	3f 91       	pop	r19
    3af4:	2f 91       	pop	r18
    3af6:	0f 90       	pop	r0
    3af8:	0f be       	out	0x3f, r0	; 63
    3afa:	0f 90       	pop	r0
    3afc:	1f 90       	pop	r1
    3afe:	18 95       	reti

00003b00 <__vector_14>:
ISR(TIMER2_COMPB_vect)
{
    3b00:	1f 92       	push	r1
    3b02:	0f 92       	push	r0
    3b04:	0f b6       	in	r0, 0x3f	; 63
    3b06:	0f 92       	push	r0
    3b08:	11 24       	eor	r1, r1
    3b0a:	2f 93       	push	r18
    3b0c:	3f 93       	push	r19
    3b0e:	4f 93       	push	r20
    3b10:	5f 93       	push	r21
    3b12:	6f 93       	push	r22
    3b14:	7f 93       	push	r23
    3b16:	8f 93       	push	r24
    3b18:	9f 93       	push	r25
    3b1a:	af 93       	push	r26
    3b1c:	bf 93       	push	r27
    3b1e:	ef 93       	push	r30
    3b20:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER2_COMPB_interrupt);
    3b22:	80 91 87 0f 	lds	r24, 0x0F87
    3b26:	90 91 88 0f 	lds	r25, 0x0F88
    3b2a:	89 2b       	or	r24, r25
    3b2c:	29 f0       	breq	.+10     	; 0x3b38 <__vector_14+0x38>
    3b2e:	e0 91 87 0f 	lds	r30, 0x0F87
    3b32:	f0 91 88 0f 	lds	r31, 0x0F88
    3b36:	09 95       	icall
}
    3b38:	ff 91       	pop	r31
    3b3a:	ef 91       	pop	r30
    3b3c:	bf 91       	pop	r27
    3b3e:	af 91       	pop	r26
    3b40:	9f 91       	pop	r25
    3b42:	8f 91       	pop	r24
    3b44:	7f 91       	pop	r23
    3b46:	6f 91       	pop	r22
    3b48:	5f 91       	pop	r21
    3b4a:	4f 91       	pop	r20
    3b4c:	3f 91       	pop	r19
    3b4e:	2f 91       	pop	r18
    3b50:	0f 90       	pop	r0
    3b52:	0f be       	out	0x3f, r0	; 63
    3b54:	0f 90       	pop	r0
    3b56:	1f 90       	pop	r1
    3b58:	18 95       	reti

00003b5a <__vector_31>:
ISR(TIMER3_CAPT_vect)
{
    3b5a:	1f 92       	push	r1
    3b5c:	0f 92       	push	r0
    3b5e:	0f b6       	in	r0, 0x3f	; 63
    3b60:	0f 92       	push	r0
    3b62:	11 24       	eor	r1, r1
    3b64:	2f 93       	push	r18
    3b66:	3f 93       	push	r19
    3b68:	4f 93       	push	r20
    3b6a:	5f 93       	push	r21
    3b6c:	6f 93       	push	r22
    3b6e:	7f 93       	push	r23
    3b70:	8f 93       	push	r24
    3b72:	9f 93       	push	r25
    3b74:	af 93       	push	r26
    3b76:	bf 93       	push	r27
    3b78:	ef 93       	push	r30
    3b7a:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_CAPT_interrupt);
    3b7c:	80 91 8b 0f 	lds	r24, 0x0F8B
    3b80:	90 91 8c 0f 	lds	r25, 0x0F8C
    3b84:	89 2b       	or	r24, r25
    3b86:	29 f0       	breq	.+10     	; 0x3b92 <__vector_31+0x38>
    3b88:	e0 91 8b 0f 	lds	r30, 0x0F8B
    3b8c:	f0 91 8c 0f 	lds	r31, 0x0F8C
    3b90:	09 95       	icall
}
    3b92:	ff 91       	pop	r31
    3b94:	ef 91       	pop	r30
    3b96:	bf 91       	pop	r27
    3b98:	af 91       	pop	r26
    3b9a:	9f 91       	pop	r25
    3b9c:	8f 91       	pop	r24
    3b9e:	7f 91       	pop	r23
    3ba0:	6f 91       	pop	r22
    3ba2:	5f 91       	pop	r21
    3ba4:	4f 91       	pop	r20
    3ba6:	3f 91       	pop	r19
    3ba8:	2f 91       	pop	r18
    3baa:	0f 90       	pop	r0
    3bac:	0f be       	out	0x3f, r0	; 63
    3bae:	0f 90       	pop	r0
    3bb0:	1f 90       	pop	r1
    3bb2:	18 95       	reti

00003bb4 <__vector_32>:
ISR(TIMER3_COMPA_vect)
{
    3bb4:	1f 92       	push	r1
    3bb6:	0f 92       	push	r0
    3bb8:	0f b6       	in	r0, 0x3f	; 63
    3bba:	0f 92       	push	r0
    3bbc:	11 24       	eor	r1, r1
    3bbe:	2f 93       	push	r18
    3bc0:	3f 93       	push	r19
    3bc2:	4f 93       	push	r20
    3bc4:	5f 93       	push	r21
    3bc6:	6f 93       	push	r22
    3bc8:	7f 93       	push	r23
    3bca:	8f 93       	push	r24
    3bcc:	9f 93       	push	r25
    3bce:	af 93       	push	r26
    3bd0:	bf 93       	push	r27
    3bd2:	ef 93       	push	r30
    3bd4:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_COMPA_interrupt);
    3bd6:	80 91 8d 0f 	lds	r24, 0x0F8D
    3bda:	90 91 8e 0f 	lds	r25, 0x0F8E
    3bde:	89 2b       	or	r24, r25
    3be0:	29 f0       	breq	.+10     	; 0x3bec <__vector_32+0x38>
    3be2:	e0 91 8d 0f 	lds	r30, 0x0F8D
    3be6:	f0 91 8e 0f 	lds	r31, 0x0F8E
    3bea:	09 95       	icall
}
    3bec:	ff 91       	pop	r31
    3bee:	ef 91       	pop	r30
    3bf0:	bf 91       	pop	r27
    3bf2:	af 91       	pop	r26
    3bf4:	9f 91       	pop	r25
    3bf6:	8f 91       	pop	r24
    3bf8:	7f 91       	pop	r23
    3bfa:	6f 91       	pop	r22
    3bfc:	5f 91       	pop	r21
    3bfe:	4f 91       	pop	r20
    3c00:	3f 91       	pop	r19
    3c02:	2f 91       	pop	r18
    3c04:	0f 90       	pop	r0
    3c06:	0f be       	out	0x3f, r0	; 63
    3c08:	0f 90       	pop	r0
    3c0a:	1f 90       	pop	r1
    3c0c:	18 95       	reti

00003c0e <__vector_33>:
ISR(TIMER3_COMPB_vect)
{
    3c0e:	1f 92       	push	r1
    3c10:	0f 92       	push	r0
    3c12:	0f b6       	in	r0, 0x3f	; 63
    3c14:	0f 92       	push	r0
    3c16:	11 24       	eor	r1, r1
    3c18:	2f 93       	push	r18
    3c1a:	3f 93       	push	r19
    3c1c:	4f 93       	push	r20
    3c1e:	5f 93       	push	r21
    3c20:	6f 93       	push	r22
    3c22:	7f 93       	push	r23
    3c24:	8f 93       	push	r24
    3c26:	9f 93       	push	r25
    3c28:	af 93       	push	r26
    3c2a:	bf 93       	push	r27
    3c2c:	ef 93       	push	r30
    3c2e:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_COMPB_interrupt);
    3c30:	80 91 8f 0f 	lds	r24, 0x0F8F
    3c34:	90 91 90 0f 	lds	r25, 0x0F90
    3c38:	89 2b       	or	r24, r25
    3c3a:	29 f0       	breq	.+10     	; 0x3c46 <__vector_33+0x38>
    3c3c:	e0 91 8f 0f 	lds	r30, 0x0F8F
    3c40:	f0 91 90 0f 	lds	r31, 0x0F90
    3c44:	09 95       	icall
}
    3c46:	ff 91       	pop	r31
    3c48:	ef 91       	pop	r30
    3c4a:	bf 91       	pop	r27
    3c4c:	af 91       	pop	r26
    3c4e:	9f 91       	pop	r25
    3c50:	8f 91       	pop	r24
    3c52:	7f 91       	pop	r23
    3c54:	6f 91       	pop	r22
    3c56:	5f 91       	pop	r21
    3c58:	4f 91       	pop	r20
    3c5a:	3f 91       	pop	r19
    3c5c:	2f 91       	pop	r18
    3c5e:	0f 90       	pop	r0
    3c60:	0f be       	out	0x3f, r0	; 63
    3c62:	0f 90       	pop	r0
    3c64:	1f 90       	pop	r1
    3c66:	18 95       	reti

00003c68 <__vector_34>:
ISR(TIMER3_COMPC_vect)
{
    3c68:	1f 92       	push	r1
    3c6a:	0f 92       	push	r0
    3c6c:	0f b6       	in	r0, 0x3f	; 63
    3c6e:	0f 92       	push	r0
    3c70:	11 24       	eor	r1, r1
    3c72:	2f 93       	push	r18
    3c74:	3f 93       	push	r19
    3c76:	4f 93       	push	r20
    3c78:	5f 93       	push	r21
    3c7a:	6f 93       	push	r22
    3c7c:	7f 93       	push	r23
    3c7e:	8f 93       	push	r24
    3c80:	9f 93       	push	r25
    3c82:	af 93       	push	r26
    3c84:	bf 93       	push	r27
    3c86:	ef 93       	push	r30
    3c88:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_COMPC_interrupt);
    3c8a:	80 91 91 0f 	lds	r24, 0x0F91
    3c8e:	90 91 92 0f 	lds	r25, 0x0F92
    3c92:	89 2b       	or	r24, r25
    3c94:	29 f0       	breq	.+10     	; 0x3ca0 <__vector_34+0x38>
    3c96:	e0 91 91 0f 	lds	r30, 0x0F91
    3c9a:	f0 91 92 0f 	lds	r31, 0x0F92
    3c9e:	09 95       	icall
}
    3ca0:	ff 91       	pop	r31
    3ca2:	ef 91       	pop	r30
    3ca4:	bf 91       	pop	r27
    3ca6:	af 91       	pop	r26
    3ca8:	9f 91       	pop	r25
    3caa:	8f 91       	pop	r24
    3cac:	7f 91       	pop	r23
    3cae:	6f 91       	pop	r22
    3cb0:	5f 91       	pop	r21
    3cb2:	4f 91       	pop	r20
    3cb4:	3f 91       	pop	r19
    3cb6:	2f 91       	pop	r18
    3cb8:	0f 90       	pop	r0
    3cba:	0f be       	out	0x3f, r0	; 63
    3cbc:	0f 90       	pop	r0
    3cbe:	1f 90       	pop	r1
    3cc0:	18 95       	reti

00003cc2 <__vector_41>:
ISR(TIMER4_CAPT_vect)
{
    3cc2:	1f 92       	push	r1
    3cc4:	0f 92       	push	r0
    3cc6:	0f b6       	in	r0, 0x3f	; 63
    3cc8:	0f 92       	push	r0
    3cca:	11 24       	eor	r1, r1
    3ccc:	2f 93       	push	r18
    3cce:	3f 93       	push	r19
    3cd0:	4f 93       	push	r20
    3cd2:	5f 93       	push	r21
    3cd4:	6f 93       	push	r22
    3cd6:	7f 93       	push	r23
    3cd8:	8f 93       	push	r24
    3cda:	9f 93       	push	r25
    3cdc:	af 93       	push	r26
    3cde:	bf 93       	push	r27
    3ce0:	ef 93       	push	r30
    3ce2:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_CAPT_interrupt);
    3ce4:	80 91 95 0f 	lds	r24, 0x0F95
    3ce8:	90 91 96 0f 	lds	r25, 0x0F96
    3cec:	89 2b       	or	r24, r25
    3cee:	29 f0       	breq	.+10     	; 0x3cfa <__vector_41+0x38>
    3cf0:	e0 91 95 0f 	lds	r30, 0x0F95
    3cf4:	f0 91 96 0f 	lds	r31, 0x0F96
    3cf8:	09 95       	icall
}
    3cfa:	ff 91       	pop	r31
    3cfc:	ef 91       	pop	r30
    3cfe:	bf 91       	pop	r27
    3d00:	af 91       	pop	r26
    3d02:	9f 91       	pop	r25
    3d04:	8f 91       	pop	r24
    3d06:	7f 91       	pop	r23
    3d08:	6f 91       	pop	r22
    3d0a:	5f 91       	pop	r21
    3d0c:	4f 91       	pop	r20
    3d0e:	3f 91       	pop	r19
    3d10:	2f 91       	pop	r18
    3d12:	0f 90       	pop	r0
    3d14:	0f be       	out	0x3f, r0	; 63
    3d16:	0f 90       	pop	r0
    3d18:	1f 90       	pop	r1
    3d1a:	18 95       	reti

00003d1c <__vector_42>:
ISR(TIMER4_COMPA_vect)
{
    3d1c:	1f 92       	push	r1
    3d1e:	0f 92       	push	r0
    3d20:	0f b6       	in	r0, 0x3f	; 63
    3d22:	0f 92       	push	r0
    3d24:	11 24       	eor	r1, r1
    3d26:	2f 93       	push	r18
    3d28:	3f 93       	push	r19
    3d2a:	4f 93       	push	r20
    3d2c:	5f 93       	push	r21
    3d2e:	6f 93       	push	r22
    3d30:	7f 93       	push	r23
    3d32:	8f 93       	push	r24
    3d34:	9f 93       	push	r25
    3d36:	af 93       	push	r26
    3d38:	bf 93       	push	r27
    3d3a:	ef 93       	push	r30
    3d3c:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_COMPA_interrupt);
    3d3e:	80 91 97 0f 	lds	r24, 0x0F97
    3d42:	90 91 98 0f 	lds	r25, 0x0F98
    3d46:	89 2b       	or	r24, r25
    3d48:	29 f0       	breq	.+10     	; 0x3d54 <__vector_42+0x38>
    3d4a:	e0 91 97 0f 	lds	r30, 0x0F97
    3d4e:	f0 91 98 0f 	lds	r31, 0x0F98
    3d52:	09 95       	icall
}
    3d54:	ff 91       	pop	r31
    3d56:	ef 91       	pop	r30
    3d58:	bf 91       	pop	r27
    3d5a:	af 91       	pop	r26
    3d5c:	9f 91       	pop	r25
    3d5e:	8f 91       	pop	r24
    3d60:	7f 91       	pop	r23
    3d62:	6f 91       	pop	r22
    3d64:	5f 91       	pop	r21
    3d66:	4f 91       	pop	r20
    3d68:	3f 91       	pop	r19
    3d6a:	2f 91       	pop	r18
    3d6c:	0f 90       	pop	r0
    3d6e:	0f be       	out	0x3f, r0	; 63
    3d70:	0f 90       	pop	r0
    3d72:	1f 90       	pop	r1
    3d74:	18 95       	reti

00003d76 <__vector_43>:
ISR(TIMER4_COMPB_vect)
{
    3d76:	1f 92       	push	r1
    3d78:	0f 92       	push	r0
    3d7a:	0f b6       	in	r0, 0x3f	; 63
    3d7c:	0f 92       	push	r0
    3d7e:	11 24       	eor	r1, r1
    3d80:	2f 93       	push	r18
    3d82:	3f 93       	push	r19
    3d84:	4f 93       	push	r20
    3d86:	5f 93       	push	r21
    3d88:	6f 93       	push	r22
    3d8a:	7f 93       	push	r23
    3d8c:	8f 93       	push	r24
    3d8e:	9f 93       	push	r25
    3d90:	af 93       	push	r26
    3d92:	bf 93       	push	r27
    3d94:	ef 93       	push	r30
    3d96:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_COMPB_interrupt);
    3d98:	80 91 99 0f 	lds	r24, 0x0F99
    3d9c:	90 91 9a 0f 	lds	r25, 0x0F9A
    3da0:	89 2b       	or	r24, r25
    3da2:	29 f0       	breq	.+10     	; 0x3dae <__vector_43+0x38>
    3da4:	e0 91 99 0f 	lds	r30, 0x0F99
    3da8:	f0 91 9a 0f 	lds	r31, 0x0F9A
    3dac:	09 95       	icall
}
    3dae:	ff 91       	pop	r31
    3db0:	ef 91       	pop	r30
    3db2:	bf 91       	pop	r27
    3db4:	af 91       	pop	r26
    3db6:	9f 91       	pop	r25
    3db8:	8f 91       	pop	r24
    3dba:	7f 91       	pop	r23
    3dbc:	6f 91       	pop	r22
    3dbe:	5f 91       	pop	r21
    3dc0:	4f 91       	pop	r20
    3dc2:	3f 91       	pop	r19
    3dc4:	2f 91       	pop	r18
    3dc6:	0f 90       	pop	r0
    3dc8:	0f be       	out	0x3f, r0	; 63
    3dca:	0f 90       	pop	r0
    3dcc:	1f 90       	pop	r1
    3dce:	18 95       	reti

00003dd0 <__vector_44>:
ISR(TIMER4_COMPC_vect)
{
    3dd0:	1f 92       	push	r1
    3dd2:	0f 92       	push	r0
    3dd4:	0f b6       	in	r0, 0x3f	; 63
    3dd6:	0f 92       	push	r0
    3dd8:	11 24       	eor	r1, r1
    3dda:	2f 93       	push	r18
    3ddc:	3f 93       	push	r19
    3dde:	4f 93       	push	r20
    3de0:	5f 93       	push	r21
    3de2:	6f 93       	push	r22
    3de4:	7f 93       	push	r23
    3de6:	8f 93       	push	r24
    3de8:	9f 93       	push	r25
    3dea:	af 93       	push	r26
    3dec:	bf 93       	push	r27
    3dee:	ef 93       	push	r30
    3df0:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_COMPC_interrupt);
    3df2:	80 91 9b 0f 	lds	r24, 0x0F9B
    3df6:	90 91 9c 0f 	lds	r25, 0x0F9C
    3dfa:	89 2b       	or	r24, r25
    3dfc:	29 f0       	breq	.+10     	; 0x3e08 <__vector_44+0x38>
    3dfe:	e0 91 9b 0f 	lds	r30, 0x0F9B
    3e02:	f0 91 9c 0f 	lds	r31, 0x0F9C
    3e06:	09 95       	icall
}
    3e08:	ff 91       	pop	r31
    3e0a:	ef 91       	pop	r30
    3e0c:	bf 91       	pop	r27
    3e0e:	af 91       	pop	r26
    3e10:	9f 91       	pop	r25
    3e12:	8f 91       	pop	r24
    3e14:	7f 91       	pop	r23
    3e16:	6f 91       	pop	r22
    3e18:	5f 91       	pop	r21
    3e1a:	4f 91       	pop	r20
    3e1c:	3f 91       	pop	r19
    3e1e:	2f 91       	pop	r18
    3e20:	0f 90       	pop	r0
    3e22:	0f be       	out	0x3f, r0	; 63
    3e24:	0f 90       	pop	r0
    3e26:	1f 90       	pop	r1
    3e28:	18 95       	reti

00003e2a <__vector_46>:
ISR(TIMER5_CAPT_vect)
{
    3e2a:	1f 92       	push	r1
    3e2c:	0f 92       	push	r0
    3e2e:	0f b6       	in	r0, 0x3f	; 63
    3e30:	0f 92       	push	r0
    3e32:	11 24       	eor	r1, r1
    3e34:	2f 93       	push	r18
    3e36:	3f 93       	push	r19
    3e38:	4f 93       	push	r20
    3e3a:	5f 93       	push	r21
    3e3c:	6f 93       	push	r22
    3e3e:	7f 93       	push	r23
    3e40:	8f 93       	push	r24
    3e42:	9f 93       	push	r25
    3e44:	af 93       	push	r26
    3e46:	bf 93       	push	r27
    3e48:	ef 93       	push	r30
    3e4a:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_CAPT_interrupt);
    3e4c:	80 91 9f 0f 	lds	r24, 0x0F9F
    3e50:	90 91 a0 0f 	lds	r25, 0x0FA0
    3e54:	89 2b       	or	r24, r25
    3e56:	29 f0       	breq	.+10     	; 0x3e62 <__vector_46+0x38>
    3e58:	e0 91 9f 0f 	lds	r30, 0x0F9F
    3e5c:	f0 91 a0 0f 	lds	r31, 0x0FA0
    3e60:	09 95       	icall
}
    3e62:	ff 91       	pop	r31
    3e64:	ef 91       	pop	r30
    3e66:	bf 91       	pop	r27
    3e68:	af 91       	pop	r26
    3e6a:	9f 91       	pop	r25
    3e6c:	8f 91       	pop	r24
    3e6e:	7f 91       	pop	r23
    3e70:	6f 91       	pop	r22
    3e72:	5f 91       	pop	r21
    3e74:	4f 91       	pop	r20
    3e76:	3f 91       	pop	r19
    3e78:	2f 91       	pop	r18
    3e7a:	0f 90       	pop	r0
    3e7c:	0f be       	out	0x3f, r0	; 63
    3e7e:	0f 90       	pop	r0
    3e80:	1f 90       	pop	r1
    3e82:	18 95       	reti

00003e84 <__vector_47>:
ISR(TIMER5_COMPA_vect)
{
    3e84:	1f 92       	push	r1
    3e86:	0f 92       	push	r0
    3e88:	0f b6       	in	r0, 0x3f	; 63
    3e8a:	0f 92       	push	r0
    3e8c:	11 24       	eor	r1, r1
    3e8e:	2f 93       	push	r18
    3e90:	3f 93       	push	r19
    3e92:	4f 93       	push	r20
    3e94:	5f 93       	push	r21
    3e96:	6f 93       	push	r22
    3e98:	7f 93       	push	r23
    3e9a:	8f 93       	push	r24
    3e9c:	9f 93       	push	r25
    3e9e:	af 93       	push	r26
    3ea0:	bf 93       	push	r27
    3ea2:	ef 93       	push	r30
    3ea4:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_COMPA_interrupt);
    3ea6:	80 91 a1 0f 	lds	r24, 0x0FA1
    3eaa:	90 91 a2 0f 	lds	r25, 0x0FA2
    3eae:	89 2b       	or	r24, r25
    3eb0:	29 f0       	breq	.+10     	; 0x3ebc <__vector_47+0x38>
    3eb2:	e0 91 a1 0f 	lds	r30, 0x0FA1
    3eb6:	f0 91 a2 0f 	lds	r31, 0x0FA2
    3eba:	09 95       	icall
}
    3ebc:	ff 91       	pop	r31
    3ebe:	ef 91       	pop	r30
    3ec0:	bf 91       	pop	r27
    3ec2:	af 91       	pop	r26
    3ec4:	9f 91       	pop	r25
    3ec6:	8f 91       	pop	r24
    3ec8:	7f 91       	pop	r23
    3eca:	6f 91       	pop	r22
    3ecc:	5f 91       	pop	r21
    3ece:	4f 91       	pop	r20
    3ed0:	3f 91       	pop	r19
    3ed2:	2f 91       	pop	r18
    3ed4:	0f 90       	pop	r0
    3ed6:	0f be       	out	0x3f, r0	; 63
    3ed8:	0f 90       	pop	r0
    3eda:	1f 90       	pop	r1
    3edc:	18 95       	reti

00003ede <__vector_48>:
ISR(TIMER5_COMPB_vect)
{
    3ede:	1f 92       	push	r1
    3ee0:	0f 92       	push	r0
    3ee2:	0f b6       	in	r0, 0x3f	; 63
    3ee4:	0f 92       	push	r0
    3ee6:	11 24       	eor	r1, r1
    3ee8:	2f 93       	push	r18
    3eea:	3f 93       	push	r19
    3eec:	4f 93       	push	r20
    3eee:	5f 93       	push	r21
    3ef0:	6f 93       	push	r22
    3ef2:	7f 93       	push	r23
    3ef4:	8f 93       	push	r24
    3ef6:	9f 93       	push	r25
    3ef8:	af 93       	push	r26
    3efa:	bf 93       	push	r27
    3efc:	ef 93       	push	r30
    3efe:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_COMPB_interrupt);
    3f00:	80 91 a3 0f 	lds	r24, 0x0FA3
    3f04:	90 91 a4 0f 	lds	r25, 0x0FA4
    3f08:	89 2b       	or	r24, r25
    3f0a:	29 f0       	breq	.+10     	; 0x3f16 <__vector_48+0x38>
    3f0c:	e0 91 a3 0f 	lds	r30, 0x0FA3
    3f10:	f0 91 a4 0f 	lds	r31, 0x0FA4
    3f14:	09 95       	icall
}
    3f16:	ff 91       	pop	r31
    3f18:	ef 91       	pop	r30
    3f1a:	bf 91       	pop	r27
    3f1c:	af 91       	pop	r26
    3f1e:	9f 91       	pop	r25
    3f20:	8f 91       	pop	r24
    3f22:	7f 91       	pop	r23
    3f24:	6f 91       	pop	r22
    3f26:	5f 91       	pop	r21
    3f28:	4f 91       	pop	r20
    3f2a:	3f 91       	pop	r19
    3f2c:	2f 91       	pop	r18
    3f2e:	0f 90       	pop	r0
    3f30:	0f be       	out	0x3f, r0	; 63
    3f32:	0f 90       	pop	r0
    3f34:	1f 90       	pop	r1
    3f36:	18 95       	reti

00003f38 <__vector_49>:
ISR(TIMER5_COMPC_vect)
{
    3f38:	1f 92       	push	r1
    3f3a:	0f 92       	push	r0
    3f3c:	0f b6       	in	r0, 0x3f	; 63
    3f3e:	0f 92       	push	r0
    3f40:	11 24       	eor	r1, r1
    3f42:	2f 93       	push	r18
    3f44:	3f 93       	push	r19
    3f46:	4f 93       	push	r20
    3f48:	5f 93       	push	r21
    3f4a:	6f 93       	push	r22
    3f4c:	7f 93       	push	r23
    3f4e:	8f 93       	push	r24
    3f50:	9f 93       	push	r25
    3f52:	af 93       	push	r26
    3f54:	bf 93       	push	r27
    3f56:	ef 93       	push	r30
    3f58:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_COMPC_interrupt);
    3f5a:	80 91 a5 0f 	lds	r24, 0x0FA5
    3f5e:	90 91 a6 0f 	lds	r25, 0x0FA6
    3f62:	89 2b       	or	r24, r25
    3f64:	29 f0       	breq	.+10     	; 0x3f70 <__vector_49+0x38>
    3f66:	e0 91 a5 0f 	lds	r30, 0x0FA5
    3f6a:	f0 91 a6 0f 	lds	r31, 0x0FA6
    3f6e:	09 95       	icall
}
    3f70:	ff 91       	pop	r31
    3f72:	ef 91       	pop	r30
    3f74:	bf 91       	pop	r27
    3f76:	af 91       	pop	r26
    3f78:	9f 91       	pop	r25
    3f7a:	8f 91       	pop	r24
    3f7c:	7f 91       	pop	r23
    3f7e:	6f 91       	pop	r22
    3f80:	5f 91       	pop	r21
    3f82:	4f 91       	pop	r20
    3f84:	3f 91       	pop	r19
    3f86:	2f 91       	pop	r18
    3f88:	0f 90       	pop	r0
    3f8a:	0f be       	out	0x3f, r0	; 63
    3f8c:	0f 90       	pop	r0
    3f8e:	1f 90       	pop	r1
    3f90:	18 95       	reti

00003f92 <__vector_default>:

ISR(BADISR_vect)
{
    3f92:	1f 92       	push	r1
    3f94:	0f 92       	push	r0
    3f96:	0f b6       	in	r0, 0x3f	; 63
    3f98:	0f 92       	push	r0
    3f9a:	11 24       	eor	r1, r1
    3f9c:	2f 93       	push	r18
    3f9e:	3f 93       	push	r19
    3fa0:	4f 93       	push	r20
    3fa2:	5f 93       	push	r21
    3fa4:	6f 93       	push	r22
    3fa6:	7f 93       	push	r23
    3fa8:	8f 93       	push	r24
    3faa:	9f 93       	push	r25
    3fac:	af 93       	push	r26
    3fae:	bf 93       	push	r27
    3fb0:	ef 93       	push	r30
    3fb2:	ff 93       	push	r31
  rprintf("BAD_vect called!");
    3fb4:	00 d0       	rcall	.+0      	; 0x3fb6 <__vector_default+0x24>
    3fb6:	0f 92       	push	r0
    3fb8:	81 e0       	ldi	r24, 0x01	; 1
    3fba:	ed b7       	in	r30, 0x3d	; 61
    3fbc:	fe b7       	in	r31, 0x3e	; 62
    3fbe:	81 83       	std	Z+1, r24	; 0x01
    3fc0:	8d e8       	ldi	r24, 0x8D	; 141
    3fc2:	91 e0       	ldi	r25, 0x01	; 1
    3fc4:	93 83       	std	Z+3, r25	; 0x03
    3fc6:	82 83       	std	Z+2, r24	; 0x02
    3fc8:	0e 94 93 27 	call	0x4f26	; 0x4f26 <rprintf1RamRom>
    3fcc:	0f 90       	pop	r0
    3fce:	0f 90       	pop	r0
    3fd0:	0f 90       	pop	r0
}
    3fd2:	ff 91       	pop	r31
    3fd4:	ef 91       	pop	r30
    3fd6:	bf 91       	pop	r27
    3fd8:	af 91       	pop	r26
    3fda:	9f 91       	pop	r25
    3fdc:	8f 91       	pop	r24
    3fde:	7f 91       	pop	r23
    3fe0:	6f 91       	pop	r22
    3fe2:	5f 91       	pop	r21
    3fe4:	4f 91       	pop	r20
    3fe6:	3f 91       	pop	r19
    3fe8:	2f 91       	pop	r18
    3fea:	0f 90       	pop	r0
    3fec:	0f be       	out	0x3f, r0	; 63
    3fee:	0f 90       	pop	r0
    3ff0:	1f 90       	pop	r1
    3ff2:	18 95       	reti

00003ff4 <uartSetRxHandler>:
}

void uartSetRxHandler(u08 nUart, void (*rx_func)(unsigned char c))
{
	// make sure the uart number is within bounds
	if(nUart < 4)
    3ff4:	84 30       	cpi	r24, 0x04	; 4
    3ff6:	40 f4       	brcc	.+16     	; 0x4008 <uartSetRxHandler+0x14>
	{
		// set the receive interrupt to run the supplied user function
		UartRxFunc[nUart] = rx_func;
    3ff8:	e8 2f       	mov	r30, r24
    3ffa:	f0 e0       	ldi	r31, 0x00	; 0
    3ffc:	ee 0f       	add	r30, r30
    3ffe:	ff 1f       	adc	r31, r31
    4000:	e7 51       	subi	r30, 0x17	; 23
    4002:	fe 4e       	sbci	r31, 0xEE	; 238
    4004:	71 83       	std	Z+1, r23	; 0x01
    4006:	60 83       	st	Z, r22
    4008:	08 95       	ret

0000400a <uartSetBaudRate>:
	}
}

void uartSetBaudRate(u08 nUart, u32 baudrate)
{
    400a:	1f 93       	push	r17
    400c:	18 2f       	mov	r17, r24
    400e:	9a 01       	movw	r18, r20
    4010:	ab 01       	movw	r20, r22
	// calculate division factor for requested baud rate, and set it
	u16 bauddiv = ((F_CPU+(baudrate*8L))/(baudrate*16L)-1);
    4012:	ca 01       	movw	r24, r20
    4014:	b9 01       	movw	r22, r18
    4016:	60 58       	subi	r22, 0x80	; 128
    4018:	7b 47       	sbci	r23, 0x7B	; 123
    401a:	81 4e       	sbci	r24, 0xE1	; 225
    401c:	9f 4f       	sbci	r25, 0xFF	; 255
    401e:	f3 e0       	ldi	r31, 0x03	; 3
    4020:	66 0f       	add	r22, r22
    4022:	77 1f       	adc	r23, r23
    4024:	88 1f       	adc	r24, r24
    4026:	99 1f       	adc	r25, r25
    4028:	fa 95       	dec	r31
    402a:	d1 f7       	brne	.-12     	; 0x4020 <uartSetBaudRate+0x16>
    402c:	e4 e0       	ldi	r30, 0x04	; 4
    402e:	22 0f       	add	r18, r18
    4030:	33 1f       	adc	r19, r19
    4032:	44 1f       	adc	r20, r20
    4034:	55 1f       	adc	r21, r21
    4036:	ea 95       	dec	r30
    4038:	d1 f7       	brne	.-12     	; 0x402e <uartSetBaudRate+0x24>
    403a:	0e 94 13 2e 	call	0x5c26	; 0x5c26 <__udivmodsi4>
    403e:	21 50       	subi	r18, 0x01	; 1
    4040:	30 40       	sbci	r19, 0x00	; 0
	if(nUart==3)
    4042:	13 30       	cpi	r17, 0x03	; 3
    4044:	29 f4       	brne	.+10     	; 0x4050 <uartSetBaudRate+0x46>
	{
		outb(UBRR3L, bauddiv);
    4046:	20 93 34 01 	sts	0x0134, r18
		#ifdef UBRR3H
		outb(UBRR3H, bauddiv>>8);
    404a:	30 93 35 01 	sts	0x0135, r19
    404e:	12 c0       	rjmp	.+36     	; 0x4074 <uartSetBaudRate+0x6a>
		#endif
	}
	else if(nUart==2)
    4050:	12 30       	cpi	r17, 0x02	; 2
    4052:	29 f4       	brne	.+10     	; 0x405e <uartSetBaudRate+0x54>
	{
		outb(UBRR2L, bauddiv);
    4054:	20 93 d4 00 	sts	0x00D4, r18
		#ifdef UBRR2H
		outb(UBRR2H, bauddiv>>8);
    4058:	30 93 d5 00 	sts	0x00D5, r19
    405c:	0b c0       	rjmp	.+22     	; 0x4074 <uartSetBaudRate+0x6a>
		#endif
	}
	else if(nUart==1)
    405e:	11 30       	cpi	r17, 0x01	; 1
    4060:	29 f4       	brne	.+10     	; 0x406c <uartSetBaudRate+0x62>
	{
		outb(UBRR1L, bauddiv);
    4062:	20 93 cc 00 	sts	0x00CC, r18
		#ifdef UBRR1H
		outb(UBRR1H, bauddiv>>8);
    4066:	30 93 cd 00 	sts	0x00CD, r19
    406a:	04 c0       	rjmp	.+8      	; 0x4074 <uartSetBaudRate+0x6a>
		#endif
	}
	else
	{
		outb(UBRR0L, bauddiv);
    406c:	20 93 c4 00 	sts	0x00C4, r18
		#ifdef UBRR0H
		outb(UBRR0H, bauddiv>>8);
    4070:	30 93 c5 00 	sts	0x00C5, r19
		#endif
	}
}
    4074:	1f 91       	pop	r17
    4076:	08 95       	ret

00004078 <uartGetRxBuffer>:

cBuffer* uartGetRxBuffer(u08 nUart)
{
    4078:	28 2f       	mov	r18, r24
    407a:	30 e0       	ldi	r19, 0x00	; 0
    407c:	a3 e0       	ldi	r26, 0x03	; 3
    407e:	22 0f       	add	r18, r18
    4080:	33 1f       	adc	r19, r19
    4082:	aa 95       	dec	r26
    4084:	e1 f7       	brne	.-8      	; 0x407e <uartGetRxBuffer+0x6>
    4086:	2c 58       	subi	r18, 0x8C	; 140
    4088:	39 4e       	sbci	r19, 0xE9	; 233
	// return rx buffer pointer
	return &uartRxBuffer[nUart];
}
    408a:	c9 01       	movw	r24, r18
    408c:	08 95       	ret

0000408e <uartGetTxBuffer>:

cBuffer* uartGetTxBuffer(u08 nUart)
{
    408e:	28 2f       	mov	r18, r24
    4090:	30 e0       	ldi	r19, 0x00	; 0
    4092:	b3 e0       	ldi	r27, 0x03	; 3
    4094:	22 0f       	add	r18, r18
    4096:	33 1f       	adc	r19, r19
    4098:	ba 95       	dec	r27
    409a:	e1 f7       	brne	.-8      	; 0x4094 <uartGetTxBuffer+0x6>
    409c:	28 56       	subi	r18, 0x68	; 104
    409e:	39 4e       	sbci	r19, 0xE9	; 233
	// return tx buffer pointer
	return &uartTxBuffer[nUart];
}
    40a0:	c9 01       	movw	r24, r18
    40a2:	08 95       	ret

000040a4 <uartSendByte>:

void uartSendByte(u08 nUart, u08 txData)
{
    40a4:	e8 2f       	mov	r30, r24
	// wait for the transmitter to be ready
//	while(!uartReadyTx[nUart]);
	// send byte
	if(nUart==3)
    40a6:	83 30       	cpi	r24, 0x03	; 3
    40a8:	39 f4       	brne	.+14     	; 0x40b8 <uartSendByte+0x14>
	{
		while(!(UCSR3A & (1<<UDRE3)));
    40aa:	80 91 30 01 	lds	r24, 0x0130
    40ae:	85 ff       	sbrs	r24, 5
    40b0:	fc cf       	rjmp	.-8      	; 0x40aa <uartSendByte+0x6>
		outb(UDR3, txData);
    40b2:	60 93 36 01 	sts	0x0136, r22
    40b6:	18 c0       	rjmp	.+48     	; 0x40e8 <uartSendByte+0x44>
	}
	else if(nUart==2)
    40b8:	82 30       	cpi	r24, 0x02	; 2
    40ba:	39 f4       	brne	.+14     	; 0x40ca <uartSendByte+0x26>
	{
		while(!(UCSR2A & (1<<UDRE2)));
    40bc:	80 91 d0 00 	lds	r24, 0x00D0
    40c0:	85 ff       	sbrs	r24, 5
    40c2:	fc cf       	rjmp	.-8      	; 0x40bc <uartSendByte+0x18>
		outb(UDR2, txData);
    40c4:	60 93 d6 00 	sts	0x00D6, r22
    40c8:	0f c0       	rjmp	.+30     	; 0x40e8 <uartSendByte+0x44>
	}
	else if(nUart==1)
    40ca:	81 30       	cpi	r24, 0x01	; 1
    40cc:	39 f4       	brne	.+14     	; 0x40dc <uartSendByte+0x38>
	{
		while(!(UCSR1A & (1<<UDRE1)));
    40ce:	80 91 c8 00 	lds	r24, 0x00C8
    40d2:	85 ff       	sbrs	r24, 5
    40d4:	fc cf       	rjmp	.-8      	; 0x40ce <uartSendByte+0x2a>
		outb(UDR1, txData);
    40d6:	60 93 ce 00 	sts	0x00CE, r22
    40da:	06 c0       	rjmp	.+12     	; 0x40e8 <uartSendByte+0x44>
	}
	else
	{
		while(!(UCSR0A & (1<<UDRE0)));
    40dc:	80 91 c0 00 	lds	r24, 0x00C0
    40e0:	85 ff       	sbrs	r24, 5
    40e2:	fc cf       	rjmp	.-8      	; 0x40dc <uartSendByte+0x38>
		outb(UDR0, txData);
    40e4:	60 93 c6 00 	sts	0x00C6, r22
	}
	// set ready state to FALSE
	uartReadyTx[nUart] = FALSE;
    40e8:	f0 e0       	ldi	r31, 0x00	; 0
    40ea:	e0 59       	subi	r30, 0x90	; 144
    40ec:	f9 4e       	sbci	r31, 0xE9	; 233
    40ee:	10 82       	st	Z, r1
}
    40f0:	08 95       	ret

000040f2 <uart0SendByte>:

void uart0SendByte(u08 data)
{
    40f2:	68 2f       	mov	r22, r24
	// send byte on UART0
	uartSendByte(0, data);
    40f4:	80 e0       	ldi	r24, 0x00	; 0
    40f6:	0e 94 52 20 	call	0x40a4	; 0x40a4 <uartSendByte>
}
    40fa:	08 95       	ret

000040fc <uart1SendByte>:

void uart1SendByte(u08 data)
{
    40fc:	68 2f       	mov	r22, r24
	// send byte on UART1
	uartSendByte(1, data);
    40fe:	81 e0       	ldi	r24, 0x01	; 1
    4100:	0e 94 52 20 	call	0x40a4	; 0x40a4 <uartSendByte>
}
    4104:	08 95       	ret

00004106 <uart2SendByte>:

void uart2SendByte(u08 data)
{
    4106:	68 2f       	mov	r22, r24
	// send byte on UART2
	uartSendByte(2, data);
    4108:	82 e0       	ldi	r24, 0x02	; 2
    410a:	0e 94 52 20 	call	0x40a4	; 0x40a4 <uartSendByte>
}
    410e:	08 95       	ret

00004110 <uart3SendByte>:

void uart3SendByte(u08 data)
{
    4110:	68 2f       	mov	r22, r24
	// send byte on UART3
	uartSendByte(3, data);
    4112:	83 e0       	ldi	r24, 0x03	; 3
    4114:	0e 94 52 20 	call	0x40a4	; 0x40a4 <uartSendByte>
}
    4118:	08 95       	ret

0000411a <uartReceiveBufferIsEmpty>:
	// flush all data from receive buffer
	bufferFlush(&uartRxBuffer[nUart]);
}

u08 uartReceiveBufferIsEmpty(u08 nUart)
{
    411a:	20 e0       	ldi	r18, 0x00	; 0
    411c:	e8 2f       	mov	r30, r24
    411e:	f0 e0       	ldi	r31, 0x00	; 0
    4120:	83 e0       	ldi	r24, 0x03	; 3
    4122:	ee 0f       	add	r30, r30
    4124:	ff 1f       	adc	r31, r31
    4126:	8a 95       	dec	r24
    4128:	e1 f7       	brne	.-8      	; 0x4122 <uartReceiveBufferIsEmpty+0x8>
    412a:	e8 58       	subi	r30, 0x88	; 136
    412c:	f9 4e       	sbci	r31, 0xE9	; 233
    412e:	80 81       	ld	r24, Z
    4130:	91 81       	ldd	r25, Z+1	; 0x01
    4132:	89 2b       	or	r24, r25
    4134:	09 f4       	brne	.+2      	; 0x4138 <uartReceiveBufferIsEmpty+0x1e>
    4136:	21 e0       	ldi	r18, 0x01	; 1
	return (uartRxBuffer[nUart].datalength == 0);
}
    4138:	82 2f       	mov	r24, r18
    413a:	08 95       	ret

0000413c <uartReceiveService>:
	}
}

// UART Receive Complete Interrupt Function
void uartReceiveService(u08 nUart)
{
    413c:	cf 93       	push	r28
    413e:	df 93       	push	r29
	u08 c;
	// get received char
	if(nUart==3)
    4140:	83 30       	cpi	r24, 0x03	; 3
    4142:	19 f4       	brne	.+6      	; 0x414a <uartReceiveService+0xe>
		c = inb(UDR3);
    4144:	60 91 36 01 	lds	r22, 0x0136
    4148:	0c c0       	rjmp	.+24     	; 0x4162 <uartReceiveService+0x26>
	else if(nUart==2)
    414a:	82 30       	cpi	r24, 0x02	; 2
    414c:	19 f4       	brne	.+6      	; 0x4154 <uartReceiveService+0x18>
		c = inb(UDR2);
    414e:	60 91 d6 00 	lds	r22, 0x00D6
    4152:	07 c0       	rjmp	.+14     	; 0x4162 <uartReceiveService+0x26>
	else if(nUart==1)
    4154:	81 30       	cpi	r24, 0x01	; 1
    4156:	19 f4       	brne	.+6      	; 0x415e <uartReceiveService+0x22>
		c = inb(UDR1);
    4158:	60 91 ce 00 	lds	r22, 0x00CE
    415c:	02 c0       	rjmp	.+4      	; 0x4162 <uartReceiveService+0x26>
	else
		c = inb(UDR0);
    415e:	60 91 c6 00 	lds	r22, 0x00C6

	// if there's a user function to handle this receive event
	if(UartRxFunc[nUart])
    4162:	28 2f       	mov	r18, r24
    4164:	30 e0       	ldi	r19, 0x00	; 0
    4166:	e9 01       	movw	r28, r18
    4168:	cc 0f       	add	r28, r28
    416a:	dd 1f       	adc	r29, r29
    416c:	fe 01       	movw	r30, r28
    416e:	e7 51       	subi	r30, 0x17	; 23
    4170:	fe 4e       	sbci	r31, 0xEE	; 238
    4172:	80 81       	ld	r24, Z
    4174:	91 81       	ldd	r25, Z+1	; 0x01
    4176:	89 2b       	or	r24, r25
    4178:	31 f0       	breq	.+12     	; 0x4186 <uartReceiveService+0x4a>
	{
		// call it and pass the received data
		UartRxFunc[nUart](c);
    417a:	01 90       	ld	r0, Z+
    417c:	f0 81       	ld	r31, Z
    417e:	e0 2d       	mov	r30, r0
    4180:	86 2f       	mov	r24, r22
    4182:	09 95       	icall
    4184:	14 c0       	rjmp	.+40     	; 0x41ae <uartReceiveService+0x72>
	else
	{
		// otherwise do default processing
		// put received char in buffer
		// check if there's space
		if( !bufferAddToEnd(&uartRxBuffer[nUart], c) )
    4186:	93 e0       	ldi	r25, 0x03	; 3
    4188:	22 0f       	add	r18, r18
    418a:	33 1f       	adc	r19, r19
    418c:	9a 95       	dec	r25
    418e:	e1 f7       	brne	.-8      	; 0x4188 <uartReceiveService+0x4c>
    4190:	c9 01       	movw	r24, r18
    4192:	8c 58       	subi	r24, 0x8C	; 140
    4194:	99 4e       	sbci	r25, 0xE9	; 233
    4196:	0e 94 aa 24 	call	0x4954	; 0x4954 <bufferAddToEnd>
    419a:	88 23       	and	r24, r24
    419c:	41 f4       	brne	.+16     	; 0x41ae <uartReceiveService+0x72>
		{
			// no space in buffer
			// count overflow
			uartRxOverflow[nUart]++;
    419e:	fe 01       	movw	r30, r28
    41a0:	e8 54       	subi	r30, 0x48	; 72
    41a2:	f9 4e       	sbci	r31, 0xE9	; 233
    41a4:	80 81       	ld	r24, Z
    41a6:	91 81       	ldd	r25, Z+1	; 0x01
    41a8:	01 96       	adiw	r24, 0x01	; 1
    41aa:	91 83       	std	Z+1, r25	; 0x01
    41ac:	80 83       	st	Z, r24
		}
	}
}
    41ae:	df 91       	pop	r29
    41b0:	cf 91       	pop	r28
    41b2:	08 95       	ret

000041b4 <__vector_54>:
{
	uartReceiveService(2);
}

UART_INTERRUPT_HANDLER(SIG_USART3_RECV)      
{
    41b4:	1f 92       	push	r1
    41b6:	0f 92       	push	r0
    41b8:	0f b6       	in	r0, 0x3f	; 63
    41ba:	0f 92       	push	r0
    41bc:	11 24       	eor	r1, r1
    41be:	2f 93       	push	r18
    41c0:	3f 93       	push	r19
    41c2:	4f 93       	push	r20
    41c4:	5f 93       	push	r21
    41c6:	6f 93       	push	r22
    41c8:	7f 93       	push	r23
    41ca:	8f 93       	push	r24
    41cc:	9f 93       	push	r25
    41ce:	af 93       	push	r26
    41d0:	bf 93       	push	r27
    41d2:	ef 93       	push	r30
    41d4:	ff 93       	push	r31
	uartReceiveService(3);
    41d6:	83 e0       	ldi	r24, 0x03	; 3
    41d8:	0e 94 9e 20 	call	0x413c	; 0x413c <uartReceiveService>
}
    41dc:	ff 91       	pop	r31
    41de:	ef 91       	pop	r30
    41e0:	bf 91       	pop	r27
    41e2:	af 91       	pop	r26
    41e4:	9f 91       	pop	r25
    41e6:	8f 91       	pop	r24
    41e8:	7f 91       	pop	r23
    41ea:	6f 91       	pop	r22
    41ec:	5f 91       	pop	r21
    41ee:	4f 91       	pop	r20
    41f0:	3f 91       	pop	r19
    41f2:	2f 91       	pop	r18
    41f4:	0f 90       	pop	r0
    41f6:	0f be       	out	0x3f, r0	; 63
    41f8:	0f 90       	pop	r0
    41fa:	1f 90       	pop	r1
    41fc:	18 95       	reti

000041fe <__vector_51>:
{
	uartReceiveService(1);
}

UART_INTERRUPT_HANDLER(SIG_USART2_RECV)      
{
    41fe:	1f 92       	push	r1
    4200:	0f 92       	push	r0
    4202:	0f b6       	in	r0, 0x3f	; 63
    4204:	0f 92       	push	r0
    4206:	11 24       	eor	r1, r1
    4208:	2f 93       	push	r18
    420a:	3f 93       	push	r19
    420c:	4f 93       	push	r20
    420e:	5f 93       	push	r21
    4210:	6f 93       	push	r22
    4212:	7f 93       	push	r23
    4214:	8f 93       	push	r24
    4216:	9f 93       	push	r25
    4218:	af 93       	push	r26
    421a:	bf 93       	push	r27
    421c:	ef 93       	push	r30
    421e:	ff 93       	push	r31
	uartReceiveService(2);
    4220:	82 e0       	ldi	r24, 0x02	; 2
    4222:	0e 94 9e 20 	call	0x413c	; 0x413c <uartReceiveService>
}
    4226:	ff 91       	pop	r31
    4228:	ef 91       	pop	r30
    422a:	bf 91       	pop	r27
    422c:	af 91       	pop	r26
    422e:	9f 91       	pop	r25
    4230:	8f 91       	pop	r24
    4232:	7f 91       	pop	r23
    4234:	6f 91       	pop	r22
    4236:	5f 91       	pop	r21
    4238:	4f 91       	pop	r20
    423a:	3f 91       	pop	r19
    423c:	2f 91       	pop	r18
    423e:	0f 90       	pop	r0
    4240:	0f be       	out	0x3f, r0	; 63
    4242:	0f 90       	pop	r0
    4244:	1f 90       	pop	r1
    4246:	18 95       	reti

00004248 <__vector_36>:
{
	uartReceiveService(0);
}

UART_INTERRUPT_HANDLER(SIG_USART1_RECV)      
{
    4248:	1f 92       	push	r1
    424a:	0f 92       	push	r0
    424c:	0f b6       	in	r0, 0x3f	; 63
    424e:	0f 92       	push	r0
    4250:	11 24       	eor	r1, r1
    4252:	2f 93       	push	r18
    4254:	3f 93       	push	r19
    4256:	4f 93       	push	r20
    4258:	5f 93       	push	r21
    425a:	6f 93       	push	r22
    425c:	7f 93       	push	r23
    425e:	8f 93       	push	r24
    4260:	9f 93       	push	r25
    4262:	af 93       	push	r26
    4264:	bf 93       	push	r27
    4266:	ef 93       	push	r30
    4268:	ff 93       	push	r31
	uartReceiveService(1);
    426a:	81 e0       	ldi	r24, 0x01	; 1
    426c:	0e 94 9e 20 	call	0x413c	; 0x413c <uartReceiveService>
}
    4270:	ff 91       	pop	r31
    4272:	ef 91       	pop	r30
    4274:	bf 91       	pop	r27
    4276:	af 91       	pop	r26
    4278:	9f 91       	pop	r25
    427a:	8f 91       	pop	r24
    427c:	7f 91       	pop	r23
    427e:	6f 91       	pop	r22
    4280:	5f 91       	pop	r21
    4282:	4f 91       	pop	r20
    4284:	3f 91       	pop	r19
    4286:	2f 91       	pop	r18
    4288:	0f 90       	pop	r0
    428a:	0f be       	out	0x3f, r0	; 63
    428c:	0f 90       	pop	r0
    428e:	1f 90       	pop	r1
    4290:	18 95       	reti

00004292 <__vector_25>:
	uartTransmitService(3);
}

	// service UART receive interrupt
UART_INTERRUPT_HANDLER(SIG_USART0_RECV)      
{
    4292:	1f 92       	push	r1
    4294:	0f 92       	push	r0
    4296:	0f b6       	in	r0, 0x3f	; 63
    4298:	0f 92       	push	r0
    429a:	11 24       	eor	r1, r1
    429c:	2f 93       	push	r18
    429e:	3f 93       	push	r19
    42a0:	4f 93       	push	r20
    42a2:	5f 93       	push	r21
    42a4:	6f 93       	push	r22
    42a6:	7f 93       	push	r23
    42a8:	8f 93       	push	r24
    42aa:	9f 93       	push	r25
    42ac:	af 93       	push	r26
    42ae:	bf 93       	push	r27
    42b0:	ef 93       	push	r30
    42b2:	ff 93       	push	r31
	uartReceiveService(0);
    42b4:	80 e0       	ldi	r24, 0x00	; 0
    42b6:	0e 94 9e 20 	call	0x413c	; 0x413c <uartReceiveService>
}
    42ba:	ff 91       	pop	r31
    42bc:	ef 91       	pop	r30
    42be:	bf 91       	pop	r27
    42c0:	af 91       	pop	r26
    42c2:	9f 91       	pop	r25
    42c4:	8f 91       	pop	r24
    42c6:	7f 91       	pop	r23
    42c8:	6f 91       	pop	r22
    42ca:	5f 91       	pop	r21
    42cc:	4f 91       	pop	r20
    42ce:	3f 91       	pop	r19
    42d0:	2f 91       	pop	r18
    42d2:	0f 90       	pop	r0
    42d4:	0f be       	out	0x3f, r0	; 63
    42d6:	0f 90       	pop	r0
    42d8:	1f 90       	pop	r1
    42da:	18 95       	reti

000042dc <uartSendBuffer>:
	// send the first byte to get things going by interrupts
	uartSendByte(nUart, bufferGetFromFront(&uartTxBuffer[nUart]));
}

u08 uartSendBuffer(u08 nUart, char *buffer, u16 nBytes)
{
    42dc:	8f 92       	push	r8
    42de:	9f 92       	push	r9
    42e0:	af 92       	push	r10
    42e2:	bf 92       	push	r11
    42e4:	cf 92       	push	r12
    42e6:	df 92       	push	r13
    42e8:	ef 92       	push	r14
    42ea:	ff 92       	push	r15
    42ec:	0f 93       	push	r16
    42ee:	1f 93       	push	r17
    42f0:	cf 93       	push	r28
    42f2:	df 93       	push	r29
    42f4:	88 2e       	mov	r8, r24
    42f6:	db 01       	movw	r26, r22
	register u08 first;
	register u16 i;

	// check if there's space (and that we have any bytes to send at all)
	if((uartTxBuffer[nUart].datalength + nBytes < uartTxBuffer[nUart].size) && nBytes)
    42f8:	c8 2e       	mov	r12, r24
    42fa:	dd 24       	eor	r13, r13
    42fc:	f6 01       	movw	r30, r12
    42fe:	13 e0       	ldi	r17, 0x03	; 3
    4300:	ee 0f       	add	r30, r30
    4302:	ff 1f       	adc	r31, r31
    4304:	1a 95       	dec	r17
    4306:	e1 f7       	brne	.-8      	; 0x4300 <uartSendBuffer+0x24>
    4308:	e4 56       	subi	r30, 0x64	; 100
    430a:	f9 4e       	sbci	r31, 0xE9	; 233
    430c:	20 81       	ld	r18, Z
    430e:	31 81       	ldd	r19, Z+1	; 0x01
    4310:	24 0f       	add	r18, r20
    4312:	35 1f       	adc	r19, r21
    4314:	f6 01       	movw	r30, r12
    4316:	73 e0       	ldi	r23, 0x03	; 3
    4318:	ee 0f       	add	r30, r30
    431a:	ff 1f       	adc	r31, r31
    431c:	7a 95       	dec	r23
    431e:	e1 f7       	brne	.-8      	; 0x4318 <uartSendBuffer+0x3c>
    4320:	e6 56       	subi	r30, 0x66	; 102
    4322:	f9 4e       	sbci	r31, 0xE9	; 233
    4324:	80 81       	ld	r24, Z
    4326:	91 81       	ldd	r25, Z+1	; 0x01
    4328:	28 17       	cp	r18, r24
    432a:	39 07       	cpc	r19, r25
    432c:	70 f5       	brcc	.+92     	; 0x438a <uartSendBuffer+0xae>
    432e:	41 15       	cp	r20, r1
    4330:	51 05       	cpc	r21, r1
    4332:	59 f1       	breq	.+86     	; 0x438a <uartSendBuffer+0xae>
	{
		// grab first character
		first = *buffer++;
    4334:	9c 90       	ld	r9, X
		// copy user buffer to uart transmit buffer
		for(i = 0; i < nBytes-1; i++)
		{
			// put data bytes at end of buffer
			bufferAddToEnd(&uartTxBuffer[nUart], *buffer++);
    4336:	76 01       	movw	r14, r12
    4338:	63 e0       	ldi	r22, 0x03	; 3
    433a:	ee 0c       	add	r14, r14
    433c:	ff 1c       	adc	r15, r15
    433e:	6a 95       	dec	r22
    4340:	e1 f7       	brne	.-8      	; 0x433a <uartSendBuffer+0x5e>
    4342:	88 e9       	ldi	r24, 0x98	; 152
    4344:	96 e1       	ldi	r25, 0x16	; 22
    4346:	e8 0e       	add	r14, r24
    4348:	f9 1e       	adc	r15, r25
    434a:	8d 01       	movw	r16, r26
    434c:	c0 e0       	ldi	r28, 0x00	; 0
    434e:	d0 e0       	ldi	r29, 0x00	; 0
	if((uartTxBuffer[nUart].datalength + nBytes < uartTxBuffer[nUart].size) && nBytes)
	{
		// grab first character
		first = *buffer++;
		// copy user buffer to uart transmit buffer
		for(i = 0; i < nBytes-1; i++)
    4350:	5a 01       	movw	r10, r20
    4352:	08 94       	sec
    4354:	a1 08       	sbc	r10, r1
    4356:	b1 08       	sbc	r11, r1
    4358:	06 c0       	rjmp	.+12     	; 0x4366 <uartSendBuffer+0x8a>
    435a:	c7 01       	movw	r24, r14
    435c:	f8 01       	movw	r30, r16
    435e:	60 81       	ld	r22, Z
    4360:	0e 94 aa 24 	call	0x4954	; 0x4954 <bufferAddToEnd>
    4364:	21 96       	adiw	r28, 0x01	; 1
    4366:	0f 5f       	subi	r16, 0xFF	; 255
    4368:	1f 4f       	sbci	r17, 0xFF	; 255
    436a:	ca 15       	cp	r28, r10
    436c:	db 05       	cpc	r29, r11
    436e:	a8 f3       	brcs	.-22     	; 0x435a <uartSendBuffer+0x7e>
			// put data bytes at end of buffer
			bufferAddToEnd(&uartTxBuffer[nUart], *buffer++);
		}

		// send the first byte to get things going by interrupts
		uartBufferedTx[nUart] = TRUE;
    4370:	84 e9       	ldi	r24, 0x94	; 148
    4372:	96 e1       	ldi	r25, 0x16	; 22
    4374:	c8 0e       	add	r12, r24
    4376:	d9 1e       	adc	r13, r25
    4378:	8f ef       	ldi	r24, 0xFF	; 255
    437a:	f6 01       	movw	r30, r12
    437c:	80 83       	st	Z, r24
		uartSendByte(nUart, first);
    437e:	88 2d       	mov	r24, r8
    4380:	69 2d       	mov	r22, r9
    4382:	0e 94 52 20 	call	0x40a4	; 0x40a4 <uartSendByte>
    4386:	8f ef       	ldi	r24, 0xFF	; 255
    4388:	01 c0       	rjmp	.+2      	; 0x438c <uartSendBuffer+0xb0>
		// return success
		return TRUE;
    438a:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		// return failure
		return FALSE;
	}
}
    438c:	df 91       	pop	r29
    438e:	cf 91       	pop	r28
    4390:	1f 91       	pop	r17
    4392:	0f 91       	pop	r16
    4394:	ff 90       	pop	r15
    4396:	ef 90       	pop	r14
    4398:	df 90       	pop	r13
    439a:	cf 90       	pop	r12
    439c:	bf 90       	pop	r11
    439e:	af 90       	pop	r10
    43a0:	9f 90       	pop	r9
    43a2:	8f 90       	pop	r8
    43a4:	08 95       	ret

000043a6 <uartAddToTxBuffer>:
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    43a6:	90 e0       	ldi	r25, 0x00	; 0
    43a8:	23 e0       	ldi	r18, 0x03	; 3
    43aa:	88 0f       	add	r24, r24
    43ac:	99 1f       	adc	r25, r25
    43ae:	2a 95       	dec	r18
    43b0:	e1 f7       	brne	.-8      	; 0x43aa <uartAddToTxBuffer+0x4>
    43b2:	88 56       	subi	r24, 0x68	; 104
    43b4:	99 4e       	sbci	r25, 0xE9	; 233
    43b6:	0e 94 aa 24 	call	0x4954	; 0x4954 <bufferAddToEnd>
}
    43ba:	08 95       	ret

000043bc <uart3AddToTxBuffer>:
{
	uartAddToTxBuffer(2,data);
}

void uart3AddToTxBuffer(u08 data)
{
    43bc:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    43be:	80 eb       	ldi	r24, 0xB0	; 176
    43c0:	96 e1       	ldi	r25, 0x16	; 22
    43c2:	0e 94 aa 24 	call	0x4954	; 0x4954 <bufferAddToEnd>
}

void uart3AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(3,data);
}
    43c6:	08 95       	ret

000043c8 <uart2AddToTxBuffer>:
{
	uartAddToTxBuffer(1,data);
}

void uart2AddToTxBuffer(u08 data)
{
    43c8:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    43ca:	88 ea       	ldi	r24, 0xA8	; 168
    43cc:	96 e1       	ldi	r25, 0x16	; 22
    43ce:	0e 94 aa 24 	call	0x4954	; 0x4954 <bufferAddToEnd>
}

void uart2AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(2,data);
}
    43d2:	08 95       	ret

000043d4 <uart1AddToTxBuffer>:
{
	uartAddToTxBuffer(0,data);
}

void uart1AddToTxBuffer(u08 data)
{
    43d4:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    43d6:	80 ea       	ldi	r24, 0xA0	; 160
    43d8:	96 e1       	ldi	r25, 0x16	; 22
    43da:	0e 94 aa 24 	call	0x4954	; 0x4954 <bufferAddToEnd>
}

void uart1AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(1,data);
}
    43de:	08 95       	ret

000043e0 <uart0AddToTxBuffer>:
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
}

void uart0AddToTxBuffer(u08 data)
{
    43e0:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    43e2:	88 e9       	ldi	r24, 0x98	; 152
    43e4:	96 e1       	ldi	r25, 0x16	; 22
    43e6:	0e 94 aa 24 	call	0x4954	; 0x4954 <bufferAddToEnd>
}

void uart0AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(0,data);
}
    43ea:	08 95       	ret

000043ec <uartTransmitService>:
	}
}

// UART Transmit Complete Interrupt Function
void uartTransmitService(u08 nUart)
{
    43ec:	cf 93       	push	r28
    43ee:	df 93       	push	r29
    43f0:	28 2f       	mov	r18, r24
	// check if buffered tx is enabled
	if(uartBufferedTx[nUart])
    43f2:	a8 2f       	mov	r26, r24
    43f4:	b0 e0       	ldi	r27, 0x00	; 0
    43f6:	ed 01       	movw	r28, r26
    43f8:	cc 56       	subi	r28, 0x6C	; 108
    43fa:	d9 4e       	sbci	r29, 0xE9	; 233
    43fc:	88 81       	ld	r24, Y
    43fe:	88 23       	and	r24, r24
    4400:	79 f1       	breq	.+94     	; 0x4460 <uartTransmitService+0x74>
	{
		// check if there's data left in the buffer
		if(uartTxBuffer[nUart].datalength)
    4402:	fd 01       	movw	r30, r26
    4404:	33 e0       	ldi	r19, 0x03	; 3
    4406:	ee 0f       	add	r30, r30
    4408:	ff 1f       	adc	r31, r31
    440a:	3a 95       	dec	r19
    440c:	e1 f7       	brne	.-8      	; 0x4406 <uartTransmitService+0x1a>
    440e:	e4 56       	subi	r30, 0x64	; 100
    4410:	f9 4e       	sbci	r31, 0xE9	; 233
    4412:	80 81       	ld	r24, Z
    4414:	91 81       	ldd	r25, Z+1	; 0x01
    4416:	89 2b       	or	r24, r25
    4418:	11 f1       	breq	.+68     	; 0x445e <uartTransmitService+0x72>
		{
			// send byte from top of buffer
			if(nUart==3)
    441a:	23 30       	cpi	r18, 0x03	; 3
    441c:	39 f4       	brne	.+14     	; 0x442c <uartTransmitService+0x40>
				outb(UDR3,  bufferGetFromFront(&uartTxBuffer[3]) );
    441e:	80 eb       	ldi	r24, 0xB0	; 176
    4420:	96 e1       	ldi	r25, 0x16	; 22
    4422:	0e 94 41 24 	call	0x4882	; 0x4882 <bufferGetFromFront>
    4426:	80 93 36 01 	sts	0x0136, r24
    442a:	1e c0       	rjmp	.+60     	; 0x4468 <uartTransmitService+0x7c>
			else if(nUart==2)
    442c:	22 30       	cpi	r18, 0x02	; 2
    442e:	39 f4       	brne	.+14     	; 0x443e <uartTransmitService+0x52>
				outb(UDR2,  bufferGetFromFront(&uartTxBuffer[2]) );
    4430:	88 ea       	ldi	r24, 0xA8	; 168
    4432:	96 e1       	ldi	r25, 0x16	; 22
    4434:	0e 94 41 24 	call	0x4882	; 0x4882 <bufferGetFromFront>
    4438:	80 93 d6 00 	sts	0x00D6, r24
    443c:	15 c0       	rjmp	.+42     	; 0x4468 <uartTransmitService+0x7c>
			else if(nUart==1)
    443e:	21 30       	cpi	r18, 0x01	; 1
    4440:	39 f4       	brne	.+14     	; 0x4450 <uartTransmitService+0x64>
				outb(UDR1,  bufferGetFromFront(&uartTxBuffer[1]) );
    4442:	80 ea       	ldi	r24, 0xA0	; 160
    4444:	96 e1       	ldi	r25, 0x16	; 22
    4446:	0e 94 41 24 	call	0x4882	; 0x4882 <bufferGetFromFront>
    444a:	80 93 ce 00 	sts	0x00CE, r24
    444e:	0c c0       	rjmp	.+24     	; 0x4468 <uartTransmitService+0x7c>
			else
				outb(UDR0,  bufferGetFromFront(&uartTxBuffer[0]) );
    4450:	88 e9       	ldi	r24, 0x98	; 152
    4452:	96 e1       	ldi	r25, 0x16	; 22
    4454:	0e 94 41 24 	call	0x4882	; 0x4882 <bufferGetFromFront>
    4458:	80 93 c6 00 	sts	0x00C6, r24
    445c:	05 c0       	rjmp	.+10     	; 0x4468 <uartTransmitService+0x7c>
		}
		else
		{
			// no data left
			uartBufferedTx[nUart] = FALSE;
    445e:	18 82       	st	Y, r1
	}
	else
	{
		// we're using single-byte tx mode
		// indicate transmit complete, back to ready
		uartReadyTx[nUart] = TRUE;
    4460:	a0 59       	subi	r26, 0x90	; 144
    4462:	b9 4e       	sbci	r27, 0xE9	; 233
    4464:	8f ef       	ldi	r24, 0xFF	; 255
    4466:	8c 93       	st	X, r24
	}
}
    4468:	df 91       	pop	r29
    446a:	cf 91       	pop	r28
    446c:	08 95       	ret

0000446e <__vector_56>:
{
	uartTransmitService(2);
}

UART_INTERRUPT_HANDLER(SIG_USART3_TRANS)      
{
    446e:	1f 92       	push	r1
    4470:	0f 92       	push	r0
    4472:	0f b6       	in	r0, 0x3f	; 63
    4474:	0f 92       	push	r0
    4476:	11 24       	eor	r1, r1
    4478:	2f 93       	push	r18
    447a:	3f 93       	push	r19
    447c:	4f 93       	push	r20
    447e:	5f 93       	push	r21
    4480:	6f 93       	push	r22
    4482:	7f 93       	push	r23
    4484:	8f 93       	push	r24
    4486:	9f 93       	push	r25
    4488:	af 93       	push	r26
    448a:	bf 93       	push	r27
    448c:	ef 93       	push	r30
    448e:	ff 93       	push	r31
	uartTransmitService(3);
    4490:	83 e0       	ldi	r24, 0x03	; 3
    4492:	0e 94 f6 21 	call	0x43ec	; 0x43ec <uartTransmitService>
}
    4496:	ff 91       	pop	r31
    4498:	ef 91       	pop	r30
    449a:	bf 91       	pop	r27
    449c:	af 91       	pop	r26
    449e:	9f 91       	pop	r25
    44a0:	8f 91       	pop	r24
    44a2:	7f 91       	pop	r23
    44a4:	6f 91       	pop	r22
    44a6:	5f 91       	pop	r21
    44a8:	4f 91       	pop	r20
    44aa:	3f 91       	pop	r19
    44ac:	2f 91       	pop	r18
    44ae:	0f 90       	pop	r0
    44b0:	0f be       	out	0x3f, r0	; 63
    44b2:	0f 90       	pop	r0
    44b4:	1f 90       	pop	r1
    44b6:	18 95       	reti

000044b8 <__vector_53>:
{
	uartTransmitService(1);
}

UART_INTERRUPT_HANDLER(SIG_USART2_TRANS)      
{
    44b8:	1f 92       	push	r1
    44ba:	0f 92       	push	r0
    44bc:	0f b6       	in	r0, 0x3f	; 63
    44be:	0f 92       	push	r0
    44c0:	11 24       	eor	r1, r1
    44c2:	2f 93       	push	r18
    44c4:	3f 93       	push	r19
    44c6:	4f 93       	push	r20
    44c8:	5f 93       	push	r21
    44ca:	6f 93       	push	r22
    44cc:	7f 93       	push	r23
    44ce:	8f 93       	push	r24
    44d0:	9f 93       	push	r25
    44d2:	af 93       	push	r26
    44d4:	bf 93       	push	r27
    44d6:	ef 93       	push	r30
    44d8:	ff 93       	push	r31
	uartTransmitService(2);
    44da:	82 e0       	ldi	r24, 0x02	; 2
    44dc:	0e 94 f6 21 	call	0x43ec	; 0x43ec <uartTransmitService>
}
    44e0:	ff 91       	pop	r31
    44e2:	ef 91       	pop	r30
    44e4:	bf 91       	pop	r27
    44e6:	af 91       	pop	r26
    44e8:	9f 91       	pop	r25
    44ea:	8f 91       	pop	r24
    44ec:	7f 91       	pop	r23
    44ee:	6f 91       	pop	r22
    44f0:	5f 91       	pop	r21
    44f2:	4f 91       	pop	r20
    44f4:	3f 91       	pop	r19
    44f6:	2f 91       	pop	r18
    44f8:	0f 90       	pop	r0
    44fa:	0f be       	out	0x3f, r0	; 63
    44fc:	0f 90       	pop	r0
    44fe:	1f 90       	pop	r1
    4500:	18 95       	reti

00004502 <__vector_38>:
{
	uartTransmitService(0);
}

UART_INTERRUPT_HANDLER(SIG_USART1_TRANS)      
{
    4502:	1f 92       	push	r1
    4504:	0f 92       	push	r0
    4506:	0f b6       	in	r0, 0x3f	; 63
    4508:	0f 92       	push	r0
    450a:	11 24       	eor	r1, r1
    450c:	2f 93       	push	r18
    450e:	3f 93       	push	r19
    4510:	4f 93       	push	r20
    4512:	5f 93       	push	r21
    4514:	6f 93       	push	r22
    4516:	7f 93       	push	r23
    4518:	8f 93       	push	r24
    451a:	9f 93       	push	r25
    451c:	af 93       	push	r26
    451e:	bf 93       	push	r27
    4520:	ef 93       	push	r30
    4522:	ff 93       	push	r31
	uartTransmitService(1);
    4524:	81 e0       	ldi	r24, 0x01	; 1
    4526:	0e 94 f6 21 	call	0x43ec	; 0x43ec <uartTransmitService>
}
    452a:	ff 91       	pop	r31
    452c:	ef 91       	pop	r30
    452e:	bf 91       	pop	r27
    4530:	af 91       	pop	r26
    4532:	9f 91       	pop	r25
    4534:	8f 91       	pop	r24
    4536:	7f 91       	pop	r23
    4538:	6f 91       	pop	r22
    453a:	5f 91       	pop	r21
    453c:	4f 91       	pop	r20
    453e:	3f 91       	pop	r19
    4540:	2f 91       	pop	r18
    4542:	0f 90       	pop	r0
    4544:	0f be       	out	0x3f, r0	; 63
    4546:	0f 90       	pop	r0
    4548:	1f 90       	pop	r1
    454a:	18 95       	reti

0000454c <__vector_27>:
	}
}

	// service UART transmit interrupt
UART_INTERRUPT_HANDLER(SIG_USART0_TRANS)      
{
    454c:	1f 92       	push	r1
    454e:	0f 92       	push	r0
    4550:	0f b6       	in	r0, 0x3f	; 63
    4552:	0f 92       	push	r0
    4554:	11 24       	eor	r1, r1
    4556:	2f 93       	push	r18
    4558:	3f 93       	push	r19
    455a:	4f 93       	push	r20
    455c:	5f 93       	push	r21
    455e:	6f 93       	push	r22
    4560:	7f 93       	push	r23
    4562:	8f 93       	push	r24
    4564:	9f 93       	push	r25
    4566:	af 93       	push	r26
    4568:	bf 93       	push	r27
    456a:	ef 93       	push	r30
    456c:	ff 93       	push	r31
	uartTransmitService(0);
    456e:	80 e0       	ldi	r24, 0x00	; 0
    4570:	0e 94 f6 21 	call	0x43ec	; 0x43ec <uartTransmitService>
}
    4574:	ff 91       	pop	r31
    4576:	ef 91       	pop	r30
    4578:	bf 91       	pop	r27
    457a:	af 91       	pop	r26
    457c:	9f 91       	pop	r25
    457e:	8f 91       	pop	r24
    4580:	7f 91       	pop	r23
    4582:	6f 91       	pop	r22
    4584:	5f 91       	pop	r21
    4586:	4f 91       	pop	r20
    4588:	3f 91       	pop	r19
    458a:	2f 91       	pop	r18
    458c:	0f 90       	pop	r0
    458e:	0f be       	out	0x3f, r0	; 63
    4590:	0f 90       	pop	r0
    4592:	1f 90       	pop	r1
    4594:	18 95       	reti

00004596 <uartSendTxBuffer>:
{
	uartAddToTxBuffer(3,data);
}

void uartSendTxBuffer(u08 nUart)
{
    4596:	1f 93       	push	r17
    4598:	18 2f       	mov	r17, r24
	// turn on buffered transmit
	uartBufferedTx[nUart] = TRUE;
    459a:	90 e0       	ldi	r25, 0x00	; 0
    459c:	fc 01       	movw	r30, r24
    459e:	ec 56       	subi	r30, 0x6C	; 108
    45a0:	f9 4e       	sbci	r31, 0xE9	; 233
    45a2:	2f ef       	ldi	r18, 0xFF	; 255
    45a4:	20 83       	st	Z, r18
	// send the first byte to get things going by interrupts
	uartSendByte(nUart, bufferGetFromFront(&uartTxBuffer[nUart]));
    45a6:	43 e0       	ldi	r20, 0x03	; 3
    45a8:	88 0f       	add	r24, r24
    45aa:	99 1f       	adc	r25, r25
    45ac:	4a 95       	dec	r20
    45ae:	e1 f7       	brne	.-8      	; 0x45a8 <uartSendTxBuffer+0x12>
    45b0:	88 56       	subi	r24, 0x68	; 104
    45b2:	99 4e       	sbci	r25, 0xE9	; 233
    45b4:	0e 94 41 24 	call	0x4882	; 0x4882 <bufferGetFromFront>
    45b8:	68 2f       	mov	r22, r24
    45ba:	81 2f       	mov	r24, r17
    45bc:	0e 94 52 20 	call	0x40a4	; 0x40a4 <uartSendByte>
}
    45c0:	1f 91       	pop	r17
    45c2:	08 95       	ret

000045c4 <uartReceiveByte>:
		return -1;
}


u08 uartReceiveByte(u08 nUart, u08* rxData)
{
    45c4:	cf 93       	push	r28
    45c6:	df 93       	push	r29
    45c8:	eb 01       	movw	r28, r22
	// make sure we have a receive buffer
	if(uartRxBuffer[nUart].size)
    45ca:	28 2f       	mov	r18, r24
    45cc:	30 e0       	ldi	r19, 0x00	; 0
    45ce:	f9 01       	movw	r30, r18
    45d0:	73 e0       	ldi	r23, 0x03	; 3
    45d2:	ee 0f       	add	r30, r30
    45d4:	ff 1f       	adc	r31, r31
    45d6:	7a 95       	dec	r23
    45d8:	e1 f7       	brne	.-8      	; 0x45d2 <uartReceiveByte+0xe>
    45da:	ea 58       	subi	r30, 0x8A	; 138
    45dc:	f9 4e       	sbci	r31, 0xE9	; 233
    45de:	80 81       	ld	r24, Z
    45e0:	91 81       	ldd	r25, Z+1	; 0x01
    45e2:	89 2b       	or	r24, r25
    45e4:	c9 f0       	breq	.+50     	; 0x4618 <uartReceiveByte+0x54>
	{
		// make sure we have data
		if(uartRxBuffer[nUart].datalength)
    45e6:	f9 01       	movw	r30, r18
    45e8:	63 e0       	ldi	r22, 0x03	; 3
    45ea:	ee 0f       	add	r30, r30
    45ec:	ff 1f       	adc	r31, r31
    45ee:	6a 95       	dec	r22
    45f0:	e1 f7       	brne	.-8      	; 0x45ea <uartReceiveByte+0x26>
    45f2:	e8 58       	subi	r30, 0x88	; 136
    45f4:	f9 4e       	sbci	r31, 0xE9	; 233
    45f6:	80 81       	ld	r24, Z
    45f8:	91 81       	ldd	r25, Z+1	; 0x01
    45fa:	89 2b       	or	r24, r25
    45fc:	69 f0       	breq	.+26     	; 0x4618 <uartReceiveByte+0x54>
		{
			// get byte from beginning of buffer
			*rxData = bufferGetFromFront(&uartRxBuffer[nUart]);
    45fe:	53 e0       	ldi	r21, 0x03	; 3
    4600:	22 0f       	add	r18, r18
    4602:	33 1f       	adc	r19, r19
    4604:	5a 95       	dec	r21
    4606:	e1 f7       	brne	.-8      	; 0x4600 <uartReceiveByte+0x3c>
    4608:	c9 01       	movw	r24, r18
    460a:	8c 58       	subi	r24, 0x8C	; 140
    460c:	99 4e       	sbci	r25, 0xE9	; 233
    460e:	0e 94 41 24 	call	0x4882	; 0x4882 <bufferGetFromFront>
    4612:	88 83       	st	Y, r24
    4614:	8f ef       	ldi	r24, 0xFF	; 255
    4616:	01 c0       	rjmp	.+2      	; 0x461a <uartReceiveByte+0x56>
			return TRUE;
    4618:	80 e0       	ldi	r24, 0x00	; 0
		else
			return FALSE;			// no data
	}
	else
		return FALSE;				// no buffer
}
    461a:	df 91       	pop	r29
    461c:	cf 91       	pop	r28
    461e:	08 95       	ret

00004620 <uart3GetByte>:
	else
		return -1;
}

int uart3GetByte(void)
{
    4620:	df 93       	push	r29
    4622:	cf 93       	push	r28
    4624:	0f 92       	push	r0
    4626:	cd b7       	in	r28, 0x3d	; 61
    4628:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(3,&c))
    462a:	83 e0       	ldi	r24, 0x03	; 3
    462c:	be 01       	movw	r22, r28
    462e:	6f 5f       	subi	r22, 0xFF	; 255
    4630:	7f 4f       	sbci	r23, 0xFF	; 255
    4632:	0e 94 e2 22 	call	0x45c4	; 0x45c4 <uartReceiveByte>
    4636:	88 23       	and	r24, r24
    4638:	19 f4       	brne	.+6      	; 0x4640 <uart3GetByte+0x20>
    463a:	2f ef       	ldi	r18, 0xFF	; 255
    463c:	3f ef       	ldi	r19, 0xFF	; 255
    463e:	03 c0       	rjmp	.+6      	; 0x4646 <uart3GetByte+0x26>
		return c;
    4640:	89 81       	ldd	r24, Y+1	; 0x01
    4642:	28 2f       	mov	r18, r24
    4644:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    4646:	c9 01       	movw	r24, r18
    4648:	0f 90       	pop	r0
    464a:	cf 91       	pop	r28
    464c:	df 91       	pop	r29
    464e:	08 95       	ret

00004650 <uart2GetByte>:
	else
		return -1;
}

int uart2GetByte(void)
{
    4650:	df 93       	push	r29
    4652:	cf 93       	push	r28
    4654:	0f 92       	push	r0
    4656:	cd b7       	in	r28, 0x3d	; 61
    4658:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(2,&c))
    465a:	82 e0       	ldi	r24, 0x02	; 2
    465c:	be 01       	movw	r22, r28
    465e:	6f 5f       	subi	r22, 0xFF	; 255
    4660:	7f 4f       	sbci	r23, 0xFF	; 255
    4662:	0e 94 e2 22 	call	0x45c4	; 0x45c4 <uartReceiveByte>
    4666:	88 23       	and	r24, r24
    4668:	19 f4       	brne	.+6      	; 0x4670 <uart2GetByte+0x20>
    466a:	2f ef       	ldi	r18, 0xFF	; 255
    466c:	3f ef       	ldi	r19, 0xFF	; 255
    466e:	03 c0       	rjmp	.+6      	; 0x4676 <uart2GetByte+0x26>
		return c;
    4670:	89 81       	ldd	r24, Y+1	; 0x01
    4672:	28 2f       	mov	r18, r24
    4674:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    4676:	c9 01       	movw	r24, r18
    4678:	0f 90       	pop	r0
    467a:	cf 91       	pop	r28
    467c:	df 91       	pop	r29
    467e:	08 95       	ret

00004680 <uart1GetByte>:
	else
		return -1;
}

int uart1GetByte(void)
{
    4680:	df 93       	push	r29
    4682:	cf 93       	push	r28
    4684:	0f 92       	push	r0
    4686:	cd b7       	in	r28, 0x3d	; 61
    4688:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(1,&c))
    468a:	81 e0       	ldi	r24, 0x01	; 1
    468c:	be 01       	movw	r22, r28
    468e:	6f 5f       	subi	r22, 0xFF	; 255
    4690:	7f 4f       	sbci	r23, 0xFF	; 255
    4692:	0e 94 e2 22 	call	0x45c4	; 0x45c4 <uartReceiveByte>
    4696:	88 23       	and	r24, r24
    4698:	19 f4       	brne	.+6      	; 0x46a0 <uart1GetByte+0x20>
    469a:	2f ef       	ldi	r18, 0xFF	; 255
    469c:	3f ef       	ldi	r19, 0xFF	; 255
    469e:	03 c0       	rjmp	.+6      	; 0x46a6 <uart1GetByte+0x26>
		return c;
    46a0:	89 81       	ldd	r24, Y+1	; 0x01
    46a2:	28 2f       	mov	r18, r24
    46a4:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    46a6:	c9 01       	movw	r24, r18
    46a8:	0f 90       	pop	r0
    46aa:	cf 91       	pop	r28
    46ac:	df 91       	pop	r29
    46ae:	08 95       	ret

000046b0 <uart0GetByte>:
	// send byte on UART3
	uartSendByte(3, data);
}

int uart0GetByte(void)
{
    46b0:	df 93       	push	r29
    46b2:	cf 93       	push	r28
    46b4:	0f 92       	push	r0
    46b6:	cd b7       	in	r28, 0x3d	; 61
    46b8:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(0,&c))
    46ba:	80 e0       	ldi	r24, 0x00	; 0
    46bc:	be 01       	movw	r22, r28
    46be:	6f 5f       	subi	r22, 0xFF	; 255
    46c0:	7f 4f       	sbci	r23, 0xFF	; 255
    46c2:	0e 94 e2 22 	call	0x45c4	; 0x45c4 <uartReceiveByte>
    46c6:	88 23       	and	r24, r24
    46c8:	19 f4       	brne	.+6      	; 0x46d0 <uart0GetByte+0x20>
    46ca:	2f ef       	ldi	r18, 0xFF	; 255
    46cc:	3f ef       	ldi	r19, 0xFF	; 255
    46ce:	03 c0       	rjmp	.+6      	; 0x46d6 <uart0GetByte+0x26>
		return c;
    46d0:	89 81       	ldd	r24, Y+1	; 0x01
    46d2:	28 2f       	mov	r18, r24
    46d4:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    46d6:	c9 01       	movw	r24, r18
    46d8:	0f 90       	pop	r0
    46da:	cf 91       	pop	r28
    46dc:	df 91       	pop	r29
    46de:	08 95       	ret

000046e0 <uartFlushReceiveBuffer>:
}

void uartFlushReceiveBuffer(u08 nUart)
{
	// flush all data from receive buffer
	bufferFlush(&uartRxBuffer[nUart]);
    46e0:	90 e0       	ldi	r25, 0x00	; 0
    46e2:	e3 e0       	ldi	r30, 0x03	; 3
    46e4:	88 0f       	add	r24, r24
    46e6:	99 1f       	adc	r25, r25
    46e8:	ea 95       	dec	r30
    46ea:	e1 f7       	brne	.-8      	; 0x46e4 <uartFlushReceiveBuffer+0x4>
    46ec:	8c 58       	subi	r24, 0x8C	; 140
    46ee:	99 4e       	sbci	r25, 0xE9	; 233
    46f0:	0e 94 dd 24 	call	0x49ba	; 0x49ba <bufferFlush>
}
    46f4:	08 95       	ret

000046f6 <uart3InitBuffers>:

void uart3InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART3 buffers
		bufferInit(&uartRxBuffer[3], (u08*) uart3RxData, UART3_RX_BUFFER_SIZE);
    46f6:	8c e8       	ldi	r24, 0x8C	; 140
    46f8:	96 e1       	ldi	r25, 0x16	; 22
    46fa:	69 e5       	ldi	r22, 0x59	; 89
    46fc:	71 e1       	ldi	r23, 0x11	; 17
    46fe:	40 e8       	ldi	r20, 0x80	; 128
    4700:	50 e0       	ldi	r21, 0x00	; 0
    4702:	0e 94 34 24 	call	0x4868	; 0x4868 <bufferInit>
		bufferInit(&uartTxBuffer[3], (u08*) uart3TxData, UART3_TX_BUFFER_SIZE);
    4706:	80 eb       	ldi	r24, 0xB0	; 176
    4708:	96 e1       	ldi	r25, 0x16	; 22
    470a:	69 ed       	ldi	r22, 0xD9	; 217
    470c:	71 e1       	ldi	r23, 0x11	; 17
    470e:	40 e1       	ldi	r20, 0x10	; 16
    4710:	50 e0       	ldi	r21, 0x00	; 0
    4712:	0e 94 34 24 	call	0x4868	; 0x4868 <bufferInit>
	#else
		// initialize the UART3 buffers
		bufferInit(&uartRxBuffer[3], (u08*) UART3_RX_BUFFER_ADDR, UART3_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[3], (u08*) UART3_TX_BUFFER_ADDR, UART3_TX_BUFFER_SIZE);
	#endif
}
    4716:	08 95       	ret

00004718 <uart3Init>:
}

void uart3Init(void)
{
	// initialize the buffers
	uart3InitBuffers();
    4718:	0e 94 7b 23 	call	0x46f6	; 0x46f6 <uart3InitBuffers>
	// initialize user receive handlers
	UartRxFunc[3] = 0;
    471c:	10 92 f0 11 	sts	0x11F0, r1
    4720:	10 92 ef 11 	sts	0x11EF, r1
	// enable RxD/TxD and interrupts
	outb(UCSR3B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    4724:	88 ed       	ldi	r24, 0xD8	; 216
    4726:	80 93 31 01 	sts	0x0131, r24
	// set default baud rate
	uartSetBaudRate(3, UART3_DEFAULT_BAUD_RATE);
    472a:	83 e0       	ldi	r24, 0x03	; 3
    472c:	40 e8       	ldi	r20, 0x80	; 128
    472e:	55 e2       	ldi	r21, 0x25	; 37
    4730:	60 e0       	ldi	r22, 0x00	; 0
    4732:	70 e0       	ldi	r23, 0x00	; 0
    4734:	0e 94 05 20 	call	0x400a	; 0x400a <uartSetBaudRate>
	// initialize states
	uartReadyTx[3] = TRUE;
    4738:	8f ef       	ldi	r24, 0xFF	; 255
    473a:	80 93 73 16 	sts	0x1673, r24
	uartBufferedTx[3] = FALSE;
    473e:	10 92 97 16 	sts	0x1697, r1
	// clear overflow count
	uartRxOverflow[3] = 0;
    4742:	10 92 bf 16 	sts	0x16BF, r1
    4746:	10 92 be 16 	sts	0x16BE, r1
	// enable interrupts
	sei();
    474a:	78 94       	sei
}
    474c:	08 95       	ret

0000474e <uart2InitBuffers>:

void uart2InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART2 buffers
		bufferInit(&uartRxBuffer[2], (u08*) uart2RxData, UART2_RX_BUFFER_SIZE);
    474e:	84 e8       	ldi	r24, 0x84	; 132
    4750:	96 e1       	ldi	r25, 0x16	; 22
    4752:	69 ec       	ldi	r22, 0xC9	; 201
    4754:	70 e1       	ldi	r23, 0x10	; 16
    4756:	40 e8       	ldi	r20, 0x80	; 128
    4758:	50 e0       	ldi	r21, 0x00	; 0
    475a:	0e 94 34 24 	call	0x4868	; 0x4868 <bufferInit>
		bufferInit(&uartTxBuffer[2], (u08*) uart2TxData, UART2_TX_BUFFER_SIZE);
    475e:	88 ea       	ldi	r24, 0xA8	; 168
    4760:	96 e1       	ldi	r25, 0x16	; 22
    4762:	69 e4       	ldi	r22, 0x49	; 73
    4764:	71 e1       	ldi	r23, 0x11	; 17
    4766:	40 e1       	ldi	r20, 0x10	; 16
    4768:	50 e0       	ldi	r21, 0x00	; 0
    476a:	0e 94 34 24 	call	0x4868	; 0x4868 <bufferInit>
	#else
		// initialize the UART2 buffers
		bufferInit(&uartRxBuffer[2], (u08*) UART2_RX_BUFFER_ADDR, UART2_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[2], (u08*) UART2_TX_BUFFER_ADDR, UART2_TX_BUFFER_SIZE);
	#endif
}
    476e:	08 95       	ret

00004770 <uart2Init>:
}

void uart2Init(void)
{
	// initialize the buffers
	uart2InitBuffers();
    4770:	0e 94 a7 23 	call	0x474e	; 0x474e <uart2InitBuffers>
	// initialize user receive handlers
	UartRxFunc[2] = 0;
    4774:	10 92 ee 11 	sts	0x11EE, r1
    4778:	10 92 ed 11 	sts	0x11ED, r1
	// enable RxD/TxD and interrupts
	outb(UCSR2B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    477c:	88 ed       	ldi	r24, 0xD8	; 216
    477e:	80 93 d1 00 	sts	0x00D1, r24
	// set default baud rate
	uartSetBaudRate(2, UART2_DEFAULT_BAUD_RATE);
    4782:	82 e0       	ldi	r24, 0x02	; 2
    4784:	40 e8       	ldi	r20, 0x80	; 128
    4786:	55 e2       	ldi	r21, 0x25	; 37
    4788:	60 e0       	ldi	r22, 0x00	; 0
    478a:	70 e0       	ldi	r23, 0x00	; 0
    478c:	0e 94 05 20 	call	0x400a	; 0x400a <uartSetBaudRate>
	// initialize states
	uartReadyTx[2] = TRUE;
    4790:	8f ef       	ldi	r24, 0xFF	; 255
    4792:	80 93 72 16 	sts	0x1672, r24
	uartBufferedTx[2] = FALSE;
    4796:	10 92 96 16 	sts	0x1696, r1
	// clear overflow count
	uartRxOverflow[2] = 0;
    479a:	10 92 bd 16 	sts	0x16BD, r1
    479e:	10 92 bc 16 	sts	0x16BC, r1
	// enable interrupts
	sei();
    47a2:	78 94       	sei
}
    47a4:	08 95       	ret

000047a6 <uart1InitBuffers>:

void uart1InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART1 buffers
		bufferInit(&uartRxBuffer[1], (u08*) uart1RxData, UART1_RX_BUFFER_SIZE);
    47a6:	8c e7       	ldi	r24, 0x7C	; 124
    47a8:	96 e1       	ldi	r25, 0x16	; 22
    47aa:	69 e3       	ldi	r22, 0x39	; 57
    47ac:	70 e1       	ldi	r23, 0x10	; 16
    47ae:	40 e8       	ldi	r20, 0x80	; 128
    47b0:	50 e0       	ldi	r21, 0x00	; 0
    47b2:	0e 94 34 24 	call	0x4868	; 0x4868 <bufferInit>
		bufferInit(&uartTxBuffer[1], (u08*) uart1TxData, UART1_TX_BUFFER_SIZE);
    47b6:	80 ea       	ldi	r24, 0xA0	; 160
    47b8:	96 e1       	ldi	r25, 0x16	; 22
    47ba:	69 eb       	ldi	r22, 0xB9	; 185
    47bc:	70 e1       	ldi	r23, 0x10	; 16
    47be:	40 e1       	ldi	r20, 0x10	; 16
    47c0:	50 e0       	ldi	r21, 0x00	; 0
    47c2:	0e 94 34 24 	call	0x4868	; 0x4868 <bufferInit>
	#else
		// initialize the UART1 buffers
		bufferInit(&uartRxBuffer[1], (u08*) UART1_RX_BUFFER_ADDR, UART1_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[1], (u08*) UART1_TX_BUFFER_ADDR, UART1_TX_BUFFER_SIZE);
	#endif
}
    47c6:	08 95       	ret

000047c8 <uart1Init>:
}

void uart1Init(void)
{
	// initialize the buffers
	uart1InitBuffers();
    47c8:	0e 94 d3 23 	call	0x47a6	; 0x47a6 <uart1InitBuffers>
	// initialize user receive handlers
	UartRxFunc[1] = 0;
    47cc:	10 92 ec 11 	sts	0x11EC, r1
    47d0:	10 92 eb 11 	sts	0x11EB, r1
	// enable RxD/TxD and interrupts
	outb(UCSR1B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    47d4:	88 ed       	ldi	r24, 0xD8	; 216
    47d6:	80 93 c9 00 	sts	0x00C9, r24
	// set default baud rate
	uartSetBaudRate(1, UART1_DEFAULT_BAUD_RATE);
    47da:	81 e0       	ldi	r24, 0x01	; 1
    47dc:	40 e8       	ldi	r20, 0x80	; 128
    47de:	55 e2       	ldi	r21, 0x25	; 37
    47e0:	60 e0       	ldi	r22, 0x00	; 0
    47e2:	70 e0       	ldi	r23, 0x00	; 0
    47e4:	0e 94 05 20 	call	0x400a	; 0x400a <uartSetBaudRate>
	// initialize states
	uartReadyTx[1] = TRUE;
    47e8:	8f ef       	ldi	r24, 0xFF	; 255
    47ea:	80 93 71 16 	sts	0x1671, r24
	uartBufferedTx[1] = FALSE;
    47ee:	10 92 95 16 	sts	0x1695, r1
	// clear overflow count
	uartRxOverflow[1] = 0;
    47f2:	10 92 bb 16 	sts	0x16BB, r1
    47f6:	10 92 ba 16 	sts	0x16BA, r1
	// enable interrupts
	sei();
    47fa:	78 94       	sei
}
    47fc:	08 95       	ret

000047fe <uart0InitBuffers>:

void uart0InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART0 buffers
		bufferInit(&uartRxBuffer[0], (u08*) uart0RxData, UART0_RX_BUFFER_SIZE);
    47fe:	84 e7       	ldi	r24, 0x74	; 116
    4800:	96 e1       	ldi	r25, 0x16	; 22
    4802:	69 ea       	ldi	r22, 0xA9	; 169
    4804:	7f e0       	ldi	r23, 0x0F	; 15
    4806:	40 e8       	ldi	r20, 0x80	; 128
    4808:	50 e0       	ldi	r21, 0x00	; 0
    480a:	0e 94 34 24 	call	0x4868	; 0x4868 <bufferInit>
		bufferInit(&uartTxBuffer[0], (u08*) uart0TxData, UART0_TX_BUFFER_SIZE);
    480e:	88 e9       	ldi	r24, 0x98	; 152
    4810:	96 e1       	ldi	r25, 0x16	; 22
    4812:	69 e2       	ldi	r22, 0x29	; 41
    4814:	70 e1       	ldi	r23, 0x10	; 16
    4816:	40 e1       	ldi	r20, 0x10	; 16
    4818:	50 e0       	ldi	r21, 0x00	; 0
    481a:	0e 94 34 24 	call	0x4868	; 0x4868 <bufferInit>
	#else
		// initialize the UART0 buffers
		bufferInit(&uartRxBuffer[0], (u08*) UART0_RX_BUFFER_ADDR, UART0_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[0], (u08*) UART0_TX_BUFFER_ADDR, UART0_TX_BUFFER_SIZE);
	#endif
}
    481e:	08 95       	ret

00004820 <uart0Init>:
}

void uart0Init(void)
{
	// initialize the buffers
	uart0InitBuffers();
    4820:	0e 94 ff 23 	call	0x47fe	; 0x47fe <uart0InitBuffers>
	// initialize user receive handlers
	UartRxFunc[0] = 0;
    4824:	10 92 ea 11 	sts	0x11EA, r1
    4828:	10 92 e9 11 	sts	0x11E9, r1
	// enable RxD/TxD and interrupts
	outb(UCSR0B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    482c:	88 ed       	ldi	r24, 0xD8	; 216
    482e:	80 93 c1 00 	sts	0x00C1, r24
	// set default baud rate
	uartSetBaudRate(0, UART0_DEFAULT_BAUD_RATE); 
    4832:	80 e0       	ldi	r24, 0x00	; 0
    4834:	40 e8       	ldi	r20, 0x80	; 128
    4836:	55 e2       	ldi	r21, 0x25	; 37
    4838:	60 e0       	ldi	r22, 0x00	; 0
    483a:	70 e0       	ldi	r23, 0x00	; 0
    483c:	0e 94 05 20 	call	0x400a	; 0x400a <uartSetBaudRate>
	// initialize states
	uartReadyTx[0] = TRUE;
    4840:	8f ef       	ldi	r24, 0xFF	; 255
    4842:	80 93 70 16 	sts	0x1670, r24
	uartBufferedTx[0] = FALSE;
    4846:	10 92 94 16 	sts	0x1694, r1
	// clear overflow count
	uartRxOverflow[0] = 0;
    484a:	10 92 b9 16 	sts	0x16B9, r1
    484e:	10 92 b8 16 	sts	0x16B8, r1
	// enable interrupts
	sei();
    4852:	78 94       	sei
}
    4854:	08 95       	ret

00004856 <uartInit>:
volatile static voidFuncPtru08 UartRxFunc[4];

void uartInit(void)
{
	// initialize all uarts
	uart0Init();
    4856:	0e 94 10 24 	call	0x4820	; 0x4820 <uart0Init>
	uart1Init();
    485a:	0e 94 e4 23 	call	0x47c8	; 0x47c8 <uart1Init>
	uart2Init();
    485e:	0e 94 b8 23 	call	0x4770	; 0x4770 <uart2Init>
	uart3Init();
    4862:	0e 94 8c 23 	call	0x4718	; 0x4718 <uart3Init>
}
    4866:	08 95       	ret

00004868 <bufferInit>:
// global variables

// initialization

void bufferInit(cBuffer* buffer, unsigned char *start, unsigned short size)
{
    4868:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    486a:	8f b7       	in	r24, 0x3f	; 63
    486c:	f8 94       	cli
	// set start pointer of the buffer
	buffer->dataptr = start;
    486e:	71 83       	std	Z+1, r23	; 0x01
    4870:	60 83       	st	Z, r22
	buffer->size = size;
    4872:	53 83       	std	Z+3, r21	; 0x03
    4874:	42 83       	std	Z+2, r20	; 0x02
	// initialize index and length
	buffer->dataindex = 0;
    4876:	17 82       	std	Z+7, r1	; 0x07
    4878:	16 82       	std	Z+6, r1	; 0x06
	buffer->datalength = 0;
    487a:	15 82       	std	Z+5, r1	; 0x05
    487c:	14 82       	std	Z+4, r1	; 0x04
	// end critical section
	CRITICAL_SECTION_END;
    487e:	8f bf       	out	0x3f, r24	; 63
}
    4880:	08 95       	ret

00004882 <bufferGetFromFront>:

// access routines
unsigned char  bufferGetFromFront(cBuffer* buffer)
{
    4882:	dc 01       	movw	r26, r24
	unsigned char data = 0;
	// begin critical section
	CRITICAL_SECTION_START;
    4884:	4f b7       	in	r20, 0x3f	; 63
    4886:	f8 94       	cli
	// check to see if there's data in the buffer
	if(buffer->datalength)
    4888:	14 96       	adiw	r26, 0x04	; 4
    488a:	8d 91       	ld	r24, X+
    488c:	9c 91       	ld	r25, X
    488e:	15 97       	sbiw	r26, 0x05	; 5
    4890:	89 2b       	or	r24, r25
    4892:	11 f4       	brne	.+4      	; 0x4898 <bufferGetFromFront+0x16>
    4894:	e0 e0       	ldi	r30, 0x00	; 0
    4896:	25 c0       	rjmp	.+74     	; 0x48e2 <bufferGetFromFront+0x60>
	{
		// get the first character from buffer
		data = buffer->dataptr[buffer->dataindex];
    4898:	16 96       	adiw	r26, 0x06	; 6
    489a:	8d 91       	ld	r24, X+
    489c:	9c 91       	ld	r25, X
    489e:	17 97       	sbiw	r26, 0x07	; 7
    48a0:	ed 91       	ld	r30, X+
    48a2:	fc 91       	ld	r31, X
    48a4:	11 97       	sbiw	r26, 0x01	; 1
    48a6:	e8 0f       	add	r30, r24
    48a8:	f9 1f       	adc	r31, r25
    48aa:	e0 81       	ld	r30, Z
		// move index down and decrement length
		buffer->dataindex++;
    48ac:	01 96       	adiw	r24, 0x01	; 1
    48ae:	17 96       	adiw	r26, 0x07	; 7
    48b0:	9c 93       	st	X, r25
    48b2:	8e 93       	st	-X, r24
    48b4:	16 97       	sbiw	r26, 0x06	; 6
		if(buffer->dataindex >= buffer->size)
    48b6:	12 96       	adiw	r26, 0x02	; 2
    48b8:	2d 91       	ld	r18, X+
    48ba:	3c 91       	ld	r19, X
    48bc:	13 97       	sbiw	r26, 0x03	; 3
    48be:	82 17       	cp	r24, r18
    48c0:	93 07       	cpc	r25, r19
    48c2:	30 f0       	brcs	.+12     	; 0x48d0 <bufferGetFromFront+0x4e>
		{
			buffer->dataindex -= buffer->size;
    48c4:	82 1b       	sub	r24, r18
    48c6:	93 0b       	sbc	r25, r19
    48c8:	17 96       	adiw	r26, 0x07	; 7
    48ca:	9c 93       	st	X, r25
    48cc:	8e 93       	st	-X, r24
    48ce:	16 97       	sbiw	r26, 0x06	; 6
		}
		buffer->datalength--;
    48d0:	14 96       	adiw	r26, 0x04	; 4
    48d2:	8d 91       	ld	r24, X+
    48d4:	9c 91       	ld	r25, X
    48d6:	15 97       	sbiw	r26, 0x05	; 5
    48d8:	01 97       	sbiw	r24, 0x01	; 1
    48da:	15 96       	adiw	r26, 0x05	; 5
    48dc:	9c 93       	st	X, r25
    48de:	8e 93       	st	-X, r24
    48e0:	14 97       	sbiw	r26, 0x04	; 4
	}
	// end critical section
	CRITICAL_SECTION_END;
    48e2:	4f bf       	out	0x3f, r20	; 63
	// return
	return data;
}
    48e4:	8e 2f       	mov	r24, r30
    48e6:	08 95       	ret

000048e8 <bufferDumpFromFront>:

void bufferDumpFromFront(cBuffer* buffer, unsigned short numbytes)
{
    48e8:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    48ea:	4f b7       	in	r20, 0x3f	; 63
    48ec:	f8 94       	cli
	// dump numbytes from the front of the buffer
	// are we dumping less than the entire buffer?
	if(numbytes < buffer->datalength)
    48ee:	84 81       	ldd	r24, Z+4	; 0x04
    48f0:	95 81       	ldd	r25, Z+5	; 0x05
    48f2:	68 17       	cp	r22, r24
    48f4:	79 07       	cpc	r23, r25
    48f6:	b0 f4       	brcc	.+44     	; 0x4924 <bufferDumpFromFront+0x3c>
	{
		// move index down by numbytes and decrement length by numbytes
		buffer->dataindex += numbytes;
    48f8:	86 81       	ldd	r24, Z+6	; 0x06
    48fa:	97 81       	ldd	r25, Z+7	; 0x07
    48fc:	86 0f       	add	r24, r22
    48fe:	97 1f       	adc	r25, r23
    4900:	97 83       	std	Z+7, r25	; 0x07
    4902:	86 83       	std	Z+6, r24	; 0x06
		if(buffer->dataindex >= buffer->size)
    4904:	22 81       	ldd	r18, Z+2	; 0x02
    4906:	33 81       	ldd	r19, Z+3	; 0x03
    4908:	82 17       	cp	r24, r18
    490a:	93 07       	cpc	r25, r19
    490c:	20 f0       	brcs	.+8      	; 0x4916 <bufferDumpFromFront+0x2e>
		{
			buffer->dataindex -= buffer->size;
    490e:	82 1b       	sub	r24, r18
    4910:	93 0b       	sbc	r25, r19
    4912:	97 83       	std	Z+7, r25	; 0x07
    4914:	86 83       	std	Z+6, r24	; 0x06
		}
		buffer->datalength -= numbytes;
    4916:	84 81       	ldd	r24, Z+4	; 0x04
    4918:	95 81       	ldd	r25, Z+5	; 0x05
    491a:	86 1b       	sub	r24, r22
    491c:	97 0b       	sbc	r25, r23
    491e:	95 83       	std	Z+5, r25	; 0x05
    4920:	84 83       	std	Z+4, r24	; 0x04
    4922:	02 c0       	rjmp	.+4      	; 0x4928 <bufferDumpFromFront+0x40>
	}
	else
	{
		// flush the whole buffer
		buffer->datalength = 0;
    4924:	15 82       	std	Z+5, r1	; 0x05
    4926:	14 82       	std	Z+4, r1	; 0x04
	}
	// end critical section
	CRITICAL_SECTION_END;
    4928:	4f bf       	out	0x3f, r20	; 63
}
    492a:	08 95       	ret

0000492c <bufferGetAtIndex>:

unsigned char bufferGetAtIndex(cBuffer* buffer, unsigned short index)
{
    492c:	fc 01       	movw	r30, r24
    492e:	cb 01       	movw	r24, r22
	// begin critical section
	CRITICAL_SECTION_START;
    4930:	2f b7       	in	r18, 0x3f	; 63
    4932:	f8 94       	cli
	// return character at index in buffer
	unsigned char data = buffer->dataptr[(buffer->dataindex+index)%(buffer->size)];
	// end critical section
	CRITICAL_SECTION_END;
    4934:	2f bf       	out	0x3f, r18	; 63
    4936:	26 81       	ldd	r18, Z+6	; 0x06
    4938:	37 81       	ldd	r19, Z+7	; 0x07
    493a:	62 81       	ldd	r22, Z+2	; 0x02
    493c:	73 81       	ldd	r23, Z+3	; 0x03
    493e:	82 0f       	add	r24, r18
    4940:	93 1f       	adc	r25, r19
    4942:	0e 94 ec 2d 	call	0x5bd8	; 0x5bd8 <__udivmodhi4>
    4946:	01 90       	ld	r0, Z+
    4948:	f0 81       	ld	r31, Z
    494a:	e0 2d       	mov	r30, r0
    494c:	e8 0f       	add	r30, r24
    494e:	f9 1f       	adc	r31, r25
	return data;
}
    4950:	80 81       	ld	r24, Z
    4952:	08 95       	ret

00004954 <bufferAddToEnd>:

unsigned char bufferAddToEnd(cBuffer* buffer, unsigned char data)
{
    4954:	1f 93       	push	r17
    4956:	cf 93       	push	r28
    4958:	df 93       	push	r29
    495a:	ec 01       	movw	r28, r24
    495c:	16 2f       	mov	r17, r22
	// begin critical section
	CRITICAL_SECTION_START;
    495e:	4f b7       	in	r20, 0x3f	; 63
    4960:	f8 94       	cli
	// make sure the buffer has room
	if(buffer->datalength < buffer->size)
    4962:	2c 81       	ldd	r18, Y+4	; 0x04
    4964:	3d 81       	ldd	r19, Y+5	; 0x05
    4966:	6a 81       	ldd	r22, Y+2	; 0x02
    4968:	7b 81       	ldd	r23, Y+3	; 0x03
    496a:	26 17       	cp	r18, r22
    496c:	37 07       	cpc	r19, r23
    496e:	98 f4       	brcc	.+38     	; 0x4996 <bufferAddToEnd+0x42>
	{
		// save data byte at end of buffer
		buffer->dataptr[(buffer->dataindex + buffer->datalength) % buffer->size] = data;
    4970:	8e 81       	ldd	r24, Y+6	; 0x06
    4972:	9f 81       	ldd	r25, Y+7	; 0x07
    4974:	82 0f       	add	r24, r18
    4976:	93 1f       	adc	r25, r19
    4978:	0e 94 ec 2d 	call	0x5bd8	; 0x5bd8 <__udivmodhi4>
    497c:	e8 81       	ld	r30, Y
    497e:	f9 81       	ldd	r31, Y+1	; 0x01
    4980:	e8 0f       	add	r30, r24
    4982:	f9 1f       	adc	r31, r25
    4984:	10 83       	st	Z, r17
		// increment the length
		buffer->datalength++;
    4986:	8c 81       	ldd	r24, Y+4	; 0x04
    4988:	9d 81       	ldd	r25, Y+5	; 0x05
    498a:	01 96       	adiw	r24, 0x01	; 1
    498c:	9d 83       	std	Y+5, r25	; 0x05
    498e:	8c 83       	std	Y+4, r24	; 0x04
		// end critical section
		CRITICAL_SECTION_END;
    4990:	4f bf       	out	0x3f, r20	; 63
    4992:	8f ef       	ldi	r24, 0xFF	; 255
    4994:	02 c0       	rjmp	.+4      	; 0x499a <bufferAddToEnd+0x46>
		// return success
		return -1;
	}
	// end critical section
	CRITICAL_SECTION_END;
    4996:	4f bf       	out	0x3f, r20	; 63
    4998:	80 e0       	ldi	r24, 0x00	; 0
	// return failure
	return 0;
}
    499a:	df 91       	pop	r29
    499c:	cf 91       	pop	r28
    499e:	1f 91       	pop	r17
    49a0:	08 95       	ret

000049a2 <bufferIsNotFull>:

unsigned short bufferIsNotFull(cBuffer* buffer)
{
    49a2:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    49a4:	8f b7       	in	r24, 0x3f	; 63
    49a6:	f8 94       	cli
	// check to see if the buffer has room
	// return true if there is room
	unsigned short bytesleft = (buffer->size - buffer->datalength);
	// end critical section
	CRITICAL_SECTION_END;
    49a8:	8f bf       	out	0x3f, r24	; 63
    49aa:	22 81       	ldd	r18, Z+2	; 0x02
    49ac:	33 81       	ldd	r19, Z+3	; 0x03
    49ae:	84 81       	ldd	r24, Z+4	; 0x04
    49b0:	95 81       	ldd	r25, Z+5	; 0x05
    49b2:	28 1b       	sub	r18, r24
    49b4:	39 0b       	sbc	r19, r25
	return bytesleft;
}
    49b6:	c9 01       	movw	r24, r18
    49b8:	08 95       	ret

000049ba <bufferFlush>:

void bufferFlush(cBuffer* buffer)
{
    49ba:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    49bc:	8f b7       	in	r24, 0x3f	; 63
    49be:	f8 94       	cli
	// flush contents of the buffer
	buffer->datalength = 0;
    49c0:	15 82       	std	Z+5, r1	; 0x05
    49c2:	14 82       	std	Z+4, r1	; 0x04
	// end critical section
	CRITICAL_SECTION_END;
    49c4:	8f bf       	out	0x3f, r24	; 63
}
    49c6:	08 95       	ret

000049c8 <a2dInit>:
// functions

// initialize a2d converter
void a2dInit(void)
{
	sbi(ADCSR, ADEN);				// enable ADC (turn on ADC power)
    49c8:	aa e7       	ldi	r26, 0x7A	; 122
    49ca:	b0 e0       	ldi	r27, 0x00	; 0
    49cc:	8c 91       	ld	r24, X
    49ce:	80 68       	ori	r24, 0x80	; 128
    49d0:	8c 93       	st	X, r24
	cbi(ADCSR, ADFR);				// default to single sample convert mode
    49d2:	8c 91       	ld	r24, X
    49d4:	8f 7d       	andi	r24, 0xDF	; 223
    49d6:	8c 93       	st	X, r24
}

// configure A2D converter clock division (prescaling)
void a2dSetPrescaler(unsigned char prescale)
{
	outb(ADCSR, ((inb(ADCSR) & ~ADC_PRESCALE_MASK) | prescale));
    49d8:	8c 91       	ld	r24, X
    49da:	88 7f       	andi	r24, 0xF8	; 248
    49dc:	86 60       	ori	r24, 0x06	; 6
    49de:	8c 93       	st	X, r24
}

// configure A2D converter voltage reference
void a2dSetReference(unsigned char ref)
{
	outb(ADMUX, ((inb(ADMUX) & ~ADC_REFERENCE_MASK) | (ref<<6)));
    49e0:	ec e7       	ldi	r30, 0x7C	; 124
    49e2:	f0 e0       	ldi	r31, 0x00	; 0
    49e4:	80 81       	ld	r24, Z
    49e6:	8f 73       	andi	r24, 0x3F	; 63
    49e8:	80 64       	ori	r24, 0x40	; 64
    49ea:	80 83       	st	Z, r24
{
	sbi(ADCSR, ADEN);				// enable ADC (turn on ADC power)
	cbi(ADCSR, ADFR);				// default to single sample convert mode
	a2dSetPrescaler(ADC_PRESCALE);	// set default prescaler
	a2dSetReference(ADC_REFERENCE);	// set default reference
	cbi(ADMUX, ADLAR);				// set to right-adjusted result
    49ec:	80 81       	ld	r24, Z
    49ee:	8f 7d       	andi	r24, 0xDF	; 223
    49f0:	80 83       	st	Z, r24

	sbi(ADCSR, ADIE);				// enable ADC interrupts
    49f2:	8c 91       	ld	r24, X
    49f4:	88 60       	ori	r24, 0x08	; 8
    49f6:	8c 93       	st	X, r24

	a2dCompleteFlag = FALSE;		// clear conversion complete flag
    49f8:	10 92 c0 16 	sts	0x16C0, r1
	sei();							// turn on interrupts (if not already on)
    49fc:	78 94       	sei
}
    49fe:	08 95       	ret

00004a00 <a2dOff>:

// turn off a2d converter
void a2dOff(void)
{
	cbi(ADCSR, ADIE);				// disable ADC interrupts
    4a00:	ea e7       	ldi	r30, 0x7A	; 122
    4a02:	f0 e0       	ldi	r31, 0x00	; 0
    4a04:	80 81       	ld	r24, Z
    4a06:	87 7f       	andi	r24, 0xF7	; 247
    4a08:	80 83       	st	Z, r24
	cbi(ADCSR, ADEN);				// disable ADC (turn off ADC power)
    4a0a:	80 81       	ld	r24, Z
    4a0c:	8f 77       	andi	r24, 0x7F	; 127
    4a0e:	80 83       	st	Z, r24
}
    4a10:	08 95       	ret

00004a12 <a2dSetPrescaler>:

// configure A2D converter clock division (prescaling)
void a2dSetPrescaler(unsigned char prescale)
{
	outb(ADCSR, ((inb(ADCSR) & ~ADC_PRESCALE_MASK) | prescale));
    4a12:	ea e7       	ldi	r30, 0x7A	; 122
    4a14:	f0 e0       	ldi	r31, 0x00	; 0
    4a16:	90 81       	ld	r25, Z
    4a18:	98 7f       	andi	r25, 0xF8	; 248
    4a1a:	98 2b       	or	r25, r24
    4a1c:	90 83       	st	Z, r25
}
    4a1e:	08 95       	ret

00004a20 <a2dSetReference>:

// configure A2D converter voltage reference
void a2dSetReference(unsigned char ref)
{
	outb(ADMUX, ((inb(ADMUX) & ~ADC_REFERENCE_MASK) | (ref<<6)));
    4a20:	ec e7       	ldi	r30, 0x7C	; 124
    4a22:	f0 e0       	ldi	r31, 0x00	; 0
    4a24:	90 81       	ld	r25, Z
    4a26:	82 95       	swap	r24
    4a28:	88 0f       	add	r24, r24
    4a2a:	88 0f       	add	r24, r24
    4a2c:	80 7c       	andi	r24, 0xC0	; 192
    4a2e:	9f 73       	andi	r25, 0x3F	; 63
    4a30:	98 2b       	or	r25, r24
    4a32:	90 83       	st	Z, r25
}
    4a34:	08 95       	ret

00004a36 <a2dSetChannel>:

// sets the a2d input channel
void a2dSetChannel(unsigned char ch)
{
	outb(ADMUX, (inb(ADMUX) & ~ADC_MUX_MASK) | (ch & ADC_MUX_MASK));	// set channel
    4a36:	ec e7       	ldi	r30, 0x7C	; 124
    4a38:	f0 e0       	ldi	r31, 0x00	; 0
    4a3a:	90 81       	ld	r25, Z
    4a3c:	8f 71       	andi	r24, 0x1F	; 31
    4a3e:	90 7e       	andi	r25, 0xE0	; 224
    4a40:	89 2b       	or	r24, r25
    4a42:	80 83       	st	Z, r24
}
    4a44:	08 95       	ret

00004a46 <a2dStartConvert>:

// start a conversion on the current a2d input channel
void a2dStartConvert(void)
{
	sbi(ADCSR, ADIF);	// clear hardware "conversion complete" flag 
    4a46:	ea e7       	ldi	r30, 0x7A	; 122
    4a48:	f0 e0       	ldi	r31, 0x00	; 0
    4a4a:	80 81       	ld	r24, Z
    4a4c:	80 61       	ori	r24, 0x10	; 16
    4a4e:	80 83       	st	Z, r24
	sbi(ADCSR, ADSC);	// start conversion
    4a50:	80 81       	ld	r24, Z
    4a52:	80 64       	ori	r24, 0x40	; 64
    4a54:	80 83       	st	Z, r24
}
    4a56:	08 95       	ret

00004a58 <a2dIsComplete>:

// return TRUE if conversion is complete
u08 a2dIsComplete(void)
{
	return bit_is_set(ADCSR, ADSC);
    4a58:	80 91 7a 00 	lds	r24, 0x007A
}
    4a5c:	80 74       	andi	r24, 0x40	; 64
    4a5e:	08 95       	ret

00004a60 <a2dConvert10bit>:

// Perform a 10-bit conversion
// starts conversion, waits until conversion is done, and returns result
unsigned short a2dConvert10bit(unsigned char ch)
{
    4a60:	98 2f       	mov	r25, r24
	a2dCompleteFlag = FALSE;				// clear conversion complete flag
    4a62:	10 92 c0 16 	sts	0x16C0, r1

if (ch >= 8)
    4a66:	88 30       	cpi	r24, 0x08	; 8
    4a68:	20 f0       	brcs	.+8      	; 0x4a72 <a2dConvert10bit+0x12>
    ADCSRB |= _BV(MUX5);
    4a6a:	80 91 7b 00 	lds	r24, 0x007B
    4a6e:	88 60       	ori	r24, 0x08	; 8
    4a70:	03 c0       	rjmp	.+6      	; 0x4a78 <a2dConvert10bit+0x18>
else
    ADCSRB &= ~_BV(MUX5);
    4a72:	80 91 7b 00 	lds	r24, 0x007B
    4a76:	87 7f       	andi	r24, 0xF7	; 247
    4a78:	80 93 7b 00 	sts	0x007B, r24

   outb(ADMUX, (inb(ADMUX) & ~7) | (ch & 7));   // set channel
    4a7c:	80 91 7c 00 	lds	r24, 0x007C
    4a80:	97 70       	andi	r25, 0x07	; 7
    4a82:	88 7f       	andi	r24, 0xF8	; 248
    4a84:	89 2b       	or	r24, r25
    4a86:	80 93 7c 00 	sts	0x007C, r24

	//outb(ADMUX, (inb(ADMUX) & ~ADC_MUX_MASK) | (ch & ADC_MUX_MASK));	// set channel
	sbi(ADCSR, ADIF);						// clear hardware "conversion complete" flag 
    4a8a:	80 91 7a 00 	lds	r24, 0x007A
    4a8e:	80 61       	ori	r24, 0x10	; 16
    4a90:	80 93 7a 00 	sts	0x007A, r24
	sbi(ADCSR, ADSC);						// start conversion
    4a94:	80 91 7a 00 	lds	r24, 0x007A
    4a98:	80 64       	ori	r24, 0x40	; 64
    4a9a:	80 93 7a 00 	sts	0x007A, r24
	//while(!a2dCompleteFlag);				// wait until conversion complete
	//while( bit_is_clear(ADCSR, ADIF) );		// wait until conversion complete
	while( bit_is_set(ADCSR, ADSC) );		// wait until conversion complete
    4a9e:	80 91 7a 00 	lds	r24, 0x007A
    4aa2:	86 fd       	sbrc	r24, 6
    4aa4:	fc cf       	rjmp	.-8      	; 0x4a9e <a2dConvert10bit+0x3e>

	// CAUTION: MUST READ ADCL BEFORE ADCH!!!
	//return (inb(ADCL) | (inb(ADCH)<<8));	// read ADC (full 10 bits) //old version
	return ADC;//new version code
    4aa6:	20 91 78 00 	lds	r18, 0x0078
    4aaa:	30 91 79 00 	lds	r19, 0x0079
}
    4aae:	c9 01       	movw	r24, r18
    4ab0:	08 95       	ret

00004ab2 <a2dConvert8bit>:
// Perform a 8-bit conversion.
// starts conversion, waits until conversion is done, and returns result
unsigned char a2dConvert8bit(unsigned char ch)
{
	// do 10-bit conversion and return highest 8 bits
	return a2dConvert10bit(ch)>>2;			// return ADC MSB byte
    4ab2:	0e 94 30 25 	call	0x4a60	; 0x4a60 <a2dConvert10bit>
    4ab6:	96 95       	lsr	r25
    4ab8:	87 95       	ror	r24
    4aba:	96 95       	lsr	r25
    4abc:	87 95       	ror	r24
}
    4abe:	08 95       	ret

00004ac0 <__vector_29>:

//! Interrupt handler for ADC complete interrupt.
SIGNAL(SIG_ADC)
{
    4ac0:	1f 92       	push	r1
    4ac2:	0f 92       	push	r0
    4ac4:	0f b6       	in	r0, 0x3f	; 63
    4ac6:	0f 92       	push	r0
    4ac8:	11 24       	eor	r1, r1
    4aca:	8f 93       	push	r24
	// set the a2d conversion flag to indicate "complete"
	a2dCompleteFlag = TRUE;
    4acc:	8f ef       	ldi	r24, 0xFF	; 255
    4ace:	80 93 c0 16 	sts	0x16C0, r24
}
    4ad2:	8f 91       	pop	r24
    4ad4:	0f 90       	pop	r0
    4ad6:	0f be       	out	0x3f, r0	; 63
    4ad8:	0f 90       	pop	r0
    4ada:	1f 90       	pop	r1
    4adc:	18 95       	reti

00004ade <rprintfInit>:
// *** rprintf initialization ***
// you must call this function once and supply the character output
// routine before using other functions in this library
void rprintfInit(void (*putchar_func)(unsigned char c))
{
	rputchar = putchar_func;
    4ade:	90 93 f2 11 	sts	0x11F2, r25
    4ae2:	80 93 f1 11 	sts	0x11F1, r24
}
    4ae6:	08 95       	ret

00004ae8 <rprintfChar>:

// *** rprintfChar ***
// send a character/byte to the current output device
void rprintfChar(unsigned char c)
{
    4ae8:	1f 93       	push	r17
    4aea:	18 2f       	mov	r17, r24
	// do LF -> CR/LF translation
	if(c == '\n')
    4aec:	8a 30       	cpi	r24, 0x0A	; 10
    4aee:	31 f4       	brne	.+12     	; 0x4afc <rprintfChar+0x14>
		rputchar('\r');
    4af0:	e0 91 f1 11 	lds	r30, 0x11F1
    4af4:	f0 91 f2 11 	lds	r31, 0x11F2
    4af8:	8d e0       	ldi	r24, 0x0D	; 13
    4afa:	09 95       	icall
	// send character
	rputchar(c);
    4afc:	e0 91 f1 11 	lds	r30, 0x11F1
    4b00:	f0 91 f2 11 	lds	r31, 0x11F2
    4b04:	81 2f       	mov	r24, r17
    4b06:	09 95       	icall
}
    4b08:	1f 91       	pop	r17
    4b0a:	08 95       	ret

00004b0c <rprintfStr>:

// *** rprintfStr ***
// prints a null-terminated string stored in RAM
void rprintfStr(char str[])
{
    4b0c:	cf 93       	push	r28
    4b0e:	df 93       	push	r29
    4b10:	ec 01       	movw	r28, r24
	// send a string stored in RAM
	// check to make sure we have a good pointer
	if (!str) return;
    4b12:	00 97       	sbiw	r24, 0x00	; 0
    4b14:	21 f4       	brne	.+8      	; 0x4b1e <rprintfStr+0x12>
    4b16:	06 c0       	rjmp	.+12     	; 0x4b24 <rprintfStr+0x18>

	// print the string until a null-terminator
	while (*str)
		rprintfChar(*str++);
    4b18:	21 96       	adiw	r28, 0x01	; 1
    4b1a:	0e 94 74 25 	call	0x4ae8	; 0x4ae8 <rprintfChar>
	// send a string stored in RAM
	// check to make sure we have a good pointer
	if (!str) return;

	// print the string until a null-terminator
	while (*str)
    4b1e:	88 81       	ld	r24, Y
    4b20:	88 23       	and	r24, r24
    4b22:	d1 f7       	brne	.-12     	; 0x4b18 <rprintfStr+0xc>
		rprintfChar(*str++);
}
    4b24:	df 91       	pop	r29
    4b26:	cf 91       	pop	r28
    4b28:	08 95       	ret

00004b2a <rprintfStrLen>:
// *** rprintfStrLen ***
// prints a section of a string stored in RAM
// begins printing at position indicated by <start>
// prints number of characters indicated by <len>
void rprintfStrLen(char str[], unsigned int start, unsigned int len)
{
    4b2a:	ef 92       	push	r14
    4b2c:	ff 92       	push	r15
    4b2e:	0f 93       	push	r16
    4b30:	1f 93       	push	r17
    4b32:	cf 93       	push	r28
    4b34:	df 93       	push	r29
    4b36:	8c 01       	movw	r16, r24
    4b38:	7a 01       	movw	r14, r20
	register int i=0;

	// check to make sure we have a good pointer
	if (!str) return;
    4b3a:	00 97       	sbiw	r24, 0x00	; 0
    4b3c:	e9 f0       	breq	.+58     	; 0x4b78 <rprintfStrLen+0x4e>
    4b3e:	20 e0       	ldi	r18, 0x00	; 0
    4b40:	30 e0       	ldi	r19, 0x00	; 0
	// spin through characters up to requested start
	// keep going as long as there's no null
	while((i++<start) && (*str++));
    4b42:	26 17       	cp	r18, r22
    4b44:	37 07       	cpc	r19, r23
    4b46:	38 f4       	brcc	.+14     	; 0x4b56 <rprintfStrLen+0x2c>
    4b48:	f8 01       	movw	r30, r16
    4b4a:	81 91       	ld	r24, Z+
    4b4c:	8f 01       	movw	r16, r30
    4b4e:	2f 5f       	subi	r18, 0xFF	; 255
    4b50:	3f 4f       	sbci	r19, 0xFF	; 255
    4b52:	88 23       	and	r24, r24
    4b54:	b1 f7       	brne	.-20     	; 0x4b42 <rprintfStrLen+0x18>
    4b56:	c0 e0       	ldi	r28, 0x00	; 0
    4b58:	d0 e0       	ldi	r29, 0x00	; 0
    4b5a:	0b c0       	rjmp	.+22     	; 0x4b72 <rprintfStrLen+0x48>
	// then print exactly len characters
	for(i=0; i<len; i++)
	{
		// print data out of the string as long as we haven't reached a null yet
		// at the null, start printing spaces
		if(*str)
    4b5c:	f8 01       	movw	r30, r16
    4b5e:	80 81       	ld	r24, Z
    4b60:	88 23       	and	r24, r24
    4b62:	19 f0       	breq	.+6      	; 0x4b6a <rprintfStrLen+0x40>
			rprintfChar(*str++);
    4b64:	0f 5f       	subi	r16, 0xFF	; 255
    4b66:	1f 4f       	sbci	r17, 0xFF	; 255
    4b68:	01 c0       	rjmp	.+2      	; 0x4b6c <rprintfStrLen+0x42>
		else
			rprintfChar(' ');
    4b6a:	80 e2       	ldi	r24, 0x20	; 32
    4b6c:	0e 94 74 25 	call	0x4ae8	; 0x4ae8 <rprintfChar>
//		// keep steping through string as long as there's no null
//		if(*str) str++;
//	}

	// then print exactly len characters
	for(i=0; i<len; i++)
    4b70:	21 96       	adiw	r28, 0x01	; 1
    4b72:	ce 15       	cp	r28, r14
    4b74:	df 05       	cpc	r29, r15
    4b76:	90 f3       	brcs	.-28     	; 0x4b5c <rprintfStrLen+0x32>
			rprintfChar(*str++);
		else
			rprintfChar(' ');
	}

}
    4b78:	df 91       	pop	r29
    4b7a:	cf 91       	pop	r28
    4b7c:	1f 91       	pop	r17
    4b7e:	0f 91       	pop	r16
    4b80:	ff 90       	pop	r15
    4b82:	ef 90       	pop	r14
    4b84:	08 95       	ret

00004b86 <rprintfProgStr>:

// *** rprintfProgStr ***
// prints a null-terminated string stored in program ROM
void rprintfProgStr(const prog_char str[])
{
    4b86:	cf 93       	push	r28
    4b88:	df 93       	push	r29
    4b8a:	ec 01       	movw	r28, r24
	// print a string stored in program memory
	register char c;

	// check to make sure we have a good pointer
	if (!str) return;
    4b8c:	00 97       	sbiw	r24, 0x00	; 0
    4b8e:	19 f4       	brne	.+6      	; 0x4b96 <rprintfProgStr+0x10>
    4b90:	07 c0       	rjmp	.+14     	; 0x4ba0 <rprintfProgStr+0x1a>
	
	// print the string until the null-terminator
	while((c = pgm_read_byte(str++)))
		rprintfChar(c);
    4b92:	0e 94 74 25 	call	0x4ae8	; 0x4ae8 <rprintfChar>
    4b96:	fe 01       	movw	r30, r28

	// check to make sure we have a good pointer
	if (!str) return;
	
	// print the string until the null-terminator
	while((c = pgm_read_byte(str++)))
    4b98:	21 96       	adiw	r28, 0x01	; 1
    4b9a:	84 91       	lpm	r24, Z+
    4b9c:	88 23       	and	r24, r24
    4b9e:	c9 f7       	brne	.-14     	; 0x4b92 <rprintfProgStr+0xc>
		rprintfChar(c);
}
    4ba0:	df 91       	pop	r29
    4ba2:	cf 91       	pop	r28
    4ba4:	08 95       	ret

00004ba6 <rprintfCRLF>:
void rprintfCRLF(void)
{
	// print CR/LF
	//rprintfChar('\r');
	// LF -> CR/LF translation built-in to rprintfChar()
	rprintfChar('\n');
    4ba6:	8a e0       	ldi	r24, 0x0A	; 10
    4ba8:	0e 94 74 25 	call	0x4ae8	; 0x4ae8 <rprintfChar>
}
    4bac:	08 95       	ret

00004bae <rprintfu04>:
//	char Character = data&0x0f;
//	if (Character>9)
//		Character+='A'-10;
//	else
//		Character+='0';
	rprintfChar(hexchar(data));
    4bae:	e8 2f       	mov	r30, r24
    4bb0:	f0 e0       	ldi	r31, 0x00	; 0
    4bb2:	ef 70       	andi	r30, 0x0F	; 15
    4bb4:	f0 70       	andi	r31, 0x00	; 0
    4bb6:	e2 56       	subi	r30, 0x62	; 98
    4bb8:	fe 4f       	sbci	r31, 0xFE	; 254
    4bba:	e4 91       	lpm	r30, Z+
    4bbc:	8e 2f       	mov	r24, r30
    4bbe:	0e 94 74 25 	call	0x4ae8	; 0x4ae8 <rprintfChar>
}
    4bc2:	08 95       	ret

00004bc4 <rprintfu08>:

// *** rprintfu08 ***
// prints an unsigned 8-bit number in hex (2 digits)
void rprintfu08(unsigned char data)
{
    4bc4:	1f 93       	push	r17
    4bc6:	18 2f       	mov	r17, r24
	// print 8-bit hex value
	rprintfu04(data>>4);
    4bc8:	82 95       	swap	r24
    4bca:	8f 70       	andi	r24, 0x0F	; 15
    4bcc:	0e 94 d7 25 	call	0x4bae	; 0x4bae <rprintfu04>
	rprintfu04(data);
    4bd0:	81 2f       	mov	r24, r17
    4bd2:	0e 94 d7 25 	call	0x4bae	; 0x4bae <rprintfu04>
}
    4bd6:	1f 91       	pop	r17
    4bd8:	08 95       	ret

00004bda <rprintfu16>:

// *** rprintfu16 ***
// prints an unsigned 16-bit number in hex (4 digits)
void rprintfu16(unsigned short data)
{
    4bda:	1f 93       	push	r17
    4bdc:	18 2f       	mov	r17, r24
	// print 16-bit hex value
	rprintfu08(data>>8);
    4bde:	89 2f       	mov	r24, r25
    4be0:	0e 94 e2 25 	call	0x4bc4	; 0x4bc4 <rprintfu08>
	rprintfu08(data);
    4be4:	81 2f       	mov	r24, r17
    4be6:	0e 94 e2 25 	call	0x4bc4	; 0x4bc4 <rprintfu08>
}
    4bea:	1f 91       	pop	r17
    4bec:	08 95       	ret

00004bee <rprintfu32>:

// *** rprintfu32 ***
// prints an unsigned 32-bit number in hex (8 digits)
void rprintfu32(unsigned long data)
{
    4bee:	ef 92       	push	r14
    4bf0:	ff 92       	push	r15
    4bf2:	0f 93       	push	r16
    4bf4:	1f 93       	push	r17
    4bf6:	7b 01       	movw	r14, r22
    4bf8:	8c 01       	movw	r16, r24
	// print 32-bit hex value
	rprintfu16(data>>16);
    4bfa:	c8 01       	movw	r24, r16
    4bfc:	aa 27       	eor	r26, r26
    4bfe:	bb 27       	eor	r27, r27
    4c00:	0e 94 ed 25 	call	0x4bda	; 0x4bda <rprintfu16>
	rprintfu16(data);
    4c04:	c7 01       	movw	r24, r14
    4c06:	0e 94 ed 25 	call	0x4bda	; 0x4bda <rprintfu16>
}
    4c0a:	1f 91       	pop	r17
    4c0c:	0f 91       	pop	r16
    4c0e:	ff 90       	pop	r15
    4c10:	ef 90       	pop	r14
    4c12:	08 95       	ret

00004c14 <rprintfNum>:
//	Examples:
//	uartPrintfNum(10, 6,  TRUE, ' ',   1234);  -->  " +1234"
//	uartPrintfNum(10, 6, FALSE, '0',   1234);  -->  "001234"
//	uartPrintfNum(16, 6, FALSE, '.', 0x5AA5);  -->  "..5AA5"
void rprintfNum(char base, char numDigits, char isSigned, char padchar, long n)
{
    4c14:	2f 92       	push	r2
    4c16:	3f 92       	push	r3
    4c18:	4f 92       	push	r4
    4c1a:	5f 92       	push	r5
    4c1c:	6f 92       	push	r6
    4c1e:	7f 92       	push	r7
    4c20:	8f 92       	push	r8
    4c22:	9f 92       	push	r9
    4c24:	af 92       	push	r10
    4c26:	bf 92       	push	r11
    4c28:	cf 92       	push	r12
    4c2a:	df 92       	push	r13
    4c2c:	ef 92       	push	r14
    4c2e:	ff 92       	push	r15
    4c30:	0f 93       	push	r16
    4c32:	1f 93       	push	r17
    4c34:	df 93       	push	r29
    4c36:	cf 93       	push	r28
    4c38:	cd b7       	in	r28, 0x3d	; 61
    4c3a:	de b7       	in	r29, 0x3e	; 62
    4c3c:	a3 97       	sbiw	r28, 0x23	; 35
    4c3e:	0f b6       	in	r0, 0x3f	; 63
    4c40:	f8 94       	cli
    4c42:	de bf       	out	0x3e, r29	; 62
    4c44:	0f be       	out	0x3f, r0	; 63
    4c46:	cd bf       	out	0x3d, r28	; 61
    4c48:	6a a3       	std	Y+34, r22	; 0x22
    4c4a:	24 2e       	mov	r2, r20
    4c4c:	2b a3       	std	Y+35, r18	; 0x23
    4c4e:	37 01       	movw	r6, r14
    4c50:	48 01       	movw	r8, r16
	char *p, buf[32];
	unsigned long x;
	unsigned char count;

	// prepare negative number
	if( isSigned && (n < 0) )
    4c52:	44 23       	and	r20, r20
    4c54:	51 f0       	breq	.+20     	; 0x4c6a <rprintfNum+0x56>
    4c56:	17 ff       	sbrs	r17, 7
    4c58:	08 c0       	rjmp	.+16     	; 0x4c6a <rprintfNum+0x56>
	{
		x = -n;
    4c5a:	ee 24       	eor	r14, r14
    4c5c:	ff 24       	eor	r15, r15
    4c5e:	87 01       	movw	r16, r14
    4c60:	e6 18       	sub	r14, r6
    4c62:	f7 08       	sbc	r15, r7
    4c64:	08 09       	sbc	r16, r8
    4c66:	19 09       	sbc	r17, r9
    4c68:	02 c0       	rjmp	.+4      	; 0x4c6e <rprintfNum+0x5a>
	}
	else
	{
	 	x = n;
    4c6a:	84 01       	movw	r16, r8
    4c6c:	73 01       	movw	r14, r6
	}

	// setup little string buffer
	count = (numDigits-1)-(isSigned?1:0);
    4c6e:	2a a1       	ldd	r18, Y+34	; 0x22
    4c70:	21 50       	subi	r18, 0x01	; 1
    4c72:	90 e0       	ldi	r25, 0x00	; 0
    4c74:	21 10       	cpse	r2, r1
    4c76:	91 e0       	ldi	r25, 0x01	; 1
    4c78:	29 1b       	sub	r18, r25
    4c7a:	29 a3       	std	Y+33, r18	; 0x21
  	p = buf + sizeof (buf);
  	*--p = '\0';
    4c7c:	18 a2       	std	Y+32, r1	; 0x20
	
	// force calculation of first digit
	// (to prevent zero from not printing at all!!!)
	*--p = hexchar(x%base); x /= base;
    4c7e:	a8 2e       	mov	r10, r24
    4c80:	bb 24       	eor	r11, r11
    4c82:	cc 24       	eor	r12, r12
    4c84:	dd 24       	eor	r13, r13
    4c86:	c8 01       	movw	r24, r16
    4c88:	b7 01       	movw	r22, r14
    4c8a:	a6 01       	movw	r20, r12
    4c8c:	95 01       	movw	r18, r10
    4c8e:	0e 94 13 2e 	call	0x5c26	; 0x5c26 <__udivmodsi4>
    4c92:	fb 01       	movw	r30, r22
    4c94:	ef 70       	andi	r30, 0x0F	; 15
    4c96:	f0 70       	andi	r31, 0x00	; 0
    4c98:	e2 56       	subi	r30, 0x62	; 98
    4c9a:	fe 4f       	sbci	r31, 0xFE	; 254
    4c9c:	64 91       	lpm	r22, Z+
    4c9e:	6f 8f       	std	Y+31, r22	; 0x1f
    4ca0:	c8 01       	movw	r24, r16
    4ca2:	b7 01       	movw	r22, r14
    4ca4:	a6 01       	movw	r20, r12
    4ca6:	95 01       	movw	r18, r10
    4ca8:	0e 94 13 2e 	call	0x5c26	; 0x5c26 <__udivmodsi4>
    4cac:	c9 01       	movw	r24, r18
    4cae:	da 01       	movw	r26, r20
    4cb0:	7c 01       	movw	r14, r24
    4cb2:	8d 01       	movw	r16, r26
    4cb4:	9e e1       	ldi	r25, 0x1E	; 30
    4cb6:	49 2e       	mov	r4, r25
    4cb8:	51 2c       	mov	r5, r1
    4cba:	4c 0e       	add	r4, r28
    4cbc:	5d 1e       	adc	r5, r29
    4cbe:	39 a0       	ldd	r3, Y+33	; 0x21
    4cc0:	25 c0       	rjmp	.+74     	; 0x4d0c <rprintfNum+0xf8>
	// calculate remaining digits
	while(count--)
	{
		if(x != 0)
    4cc2:	e1 14       	cp	r14, r1
    4cc4:	f1 04       	cpc	r15, r1
    4cc6:	01 05       	cpc	r16, r1
    4cc8:	11 05       	cpc	r17, r1
    4cca:	c9 f0       	breq	.+50     	; 0x4cfe <rprintfNum+0xea>
		{
			// calculate next digit
			*--p = hexchar(x%base); x /= base;
    4ccc:	c8 01       	movw	r24, r16
    4cce:	b7 01       	movw	r22, r14
    4cd0:	a6 01       	movw	r20, r12
    4cd2:	95 01       	movw	r18, r10
    4cd4:	0e 94 13 2e 	call	0x5c26	; 0x5c26 <__udivmodsi4>
    4cd8:	fb 01       	movw	r30, r22
    4cda:	ef 70       	andi	r30, 0x0F	; 15
    4cdc:	f0 70       	andi	r31, 0x00	; 0
    4cde:	e2 56       	subi	r30, 0x62	; 98
    4ce0:	fe 4f       	sbci	r31, 0xFE	; 254
    4ce2:	64 91       	lpm	r22, Z+
    4ce4:	f2 01       	movw	r30, r4
    4ce6:	60 83       	st	Z, r22
    4ce8:	c8 01       	movw	r24, r16
    4cea:	b7 01       	movw	r22, r14
    4cec:	a6 01       	movw	r20, r12
    4cee:	95 01       	movw	r18, r10
    4cf0:	0e 94 13 2e 	call	0x5c26	; 0x5c26 <__udivmodsi4>
    4cf4:	c9 01       	movw	r24, r18
    4cf6:	da 01       	movw	r26, r20
    4cf8:	7c 01       	movw	r14, r24
    4cfa:	8d 01       	movw	r16, r26
    4cfc:	03 c0       	rjmp	.+6      	; 0x4d04 <rprintfNum+0xf0>
		}
		else
		{
			// no more digits left, pad out to desired length
			*--p = padchar;
    4cfe:	2b a1       	ldd	r18, Y+35	; 0x23
    4d00:	f2 01       	movw	r30, r4
    4d02:	20 83       	st	Z, r18
    4d04:	3a 94       	dec	r3
    4d06:	08 94       	sec
    4d08:	41 08       	sbc	r4, r1
    4d0a:	51 08       	sbc	r5, r1
	
	// force calculation of first digit
	// (to prevent zero from not printing at all!!!)
	*--p = hexchar(x%base); x /= base;
	// calculate remaining digits
	while(count--)
    4d0c:	33 20       	and	r3, r3
    4d0e:	c9 f6       	brne	.-78     	; 0x4cc2 <rprintfNum+0xae>
    4d10:	ce 01       	movw	r24, r28
    4d12:	4f 96       	adiw	r24, 0x1f	; 31
    4d14:	8c 01       	movw	r16, r24
    4d16:	e9 a1       	ldd	r30, Y+33	; 0x21
    4d18:	0e 1b       	sub	r16, r30
    4d1a:	11 09       	sbc	r17, r1
			*--p = padchar;
		}
	}

	// apply signed notation if requested
	if( isSigned )
    4d1c:	22 20       	and	r2, r2
    4d1e:	f1 f0       	breq	.+60     	; 0x4d5c <rprintfNum+0x148>
	{
		if(n < 0)
    4d20:	97 fe       	sbrs	r9, 7
    4d22:	05 c0       	rjmp	.+10     	; 0x4d2e <rprintfNum+0x11a>
		{
   			*--p = '-';
    4d24:	8d e2       	ldi	r24, 0x2D	; 45
    4d26:	f8 01       	movw	r30, r16
    4d28:	82 93       	st	-Z, r24
    4d2a:	8f 01       	movw	r16, r30
    4d2c:	17 c0       	rjmp	.+46     	; 0x4d5c <rprintfNum+0x148>
    4d2e:	c8 01       	movw	r24, r16
    4d30:	01 97       	sbiw	r24, 0x01	; 1
		}
		else if(n > 0)
    4d32:	61 14       	cp	r6, r1
    4d34:	71 04       	cpc	r7, r1
    4d36:	81 04       	cpc	r8, r1
    4d38:	91 04       	cpc	r9, r1
    4d3a:	19 f0       	breq	.+6      	; 0x4d42 <rprintfNum+0x12e>
		{
	   		*--p = '+';
    4d3c:	8c 01       	movw	r16, r24
    4d3e:	8b e2       	ldi	r24, 0x2B	; 43
    4d40:	02 c0       	rjmp	.+4      	; 0x4d46 <rprintfNum+0x132>
		}
		else
		{
	   		*--p = ' ';
    4d42:	8c 01       	movw	r16, r24
    4d44:	80 e2       	ldi	r24, 0x20	; 32
    4d46:	f8 01       	movw	r30, r16
    4d48:	80 83       	st	Z, r24
    4d4a:	08 c0       	rjmp	.+16     	; 0x4d5c <rprintfNum+0x148>

	// print the string right-justified
	count = numDigits;
	while(count--)
	{
		rprintfChar(*p++);
    4d4c:	f8 01       	movw	r30, r16
    4d4e:	81 91       	ld	r24, Z+
    4d50:	8f 01       	movw	r16, r30
    4d52:	0e 94 74 25 	call	0x4ae8	; 0x4ae8 <rprintfChar>
    4d56:	fa a1       	ldd	r31, Y+34	; 0x22
    4d58:	f1 50       	subi	r31, 0x01	; 1
    4d5a:	fa a3       	std	Y+34, r31	; 0x22
		}
	}

	// print the string right-justified
	count = numDigits;
	while(count--)
    4d5c:	2a a1       	ldd	r18, Y+34	; 0x22
    4d5e:	22 23       	and	r18, r18
    4d60:	a9 f7       	brne	.-22     	; 0x4d4c <rprintfNum+0x138>
	{
		rprintfChar(*p++);
	}
}
    4d62:	a3 96       	adiw	r28, 0x23	; 35
    4d64:	0f b6       	in	r0, 0x3f	; 63
    4d66:	f8 94       	cli
    4d68:	de bf       	out	0x3e, r29	; 62
    4d6a:	0f be       	out	0x3f, r0	; 63
    4d6c:	cd bf       	out	0x3d, r28	; 61
    4d6e:	cf 91       	pop	r28
    4d70:	df 91       	pop	r29
    4d72:	1f 91       	pop	r17
    4d74:	0f 91       	pop	r16
    4d76:	ff 90       	pop	r15
    4d78:	ef 90       	pop	r14
    4d7a:	df 90       	pop	r13
    4d7c:	cf 90       	pop	r12
    4d7e:	bf 90       	pop	r11
    4d80:	af 90       	pop	r10
    4d82:	9f 90       	pop	r9
    4d84:	8f 90       	pop	r8
    4d86:	7f 90       	pop	r7
    4d88:	6f 90       	pop	r6
    4d8a:	5f 90       	pop	r5
    4d8c:	4f 90       	pop	r4
    4d8e:	3f 90       	pop	r3
    4d90:	2f 90       	pop	r2
    4d92:	08 95       	ret

00004d94 <rprintfFloat>:

#ifdef RPRINTF_FLOAT
// *** rprintfFloat ***
// floating-point print
void rprintfFloat(char numDigits, double x)
{
    4d94:	4f 92       	push	r4
    4d96:	5f 92       	push	r5
    4d98:	6f 92       	push	r6
    4d9a:	7f 92       	push	r7
    4d9c:	8f 92       	push	r8
    4d9e:	9f 92       	push	r9
    4da0:	af 92       	push	r10
    4da2:	bf 92       	push	r11
    4da4:	cf 92       	push	r12
    4da6:	df 92       	push	r13
    4da8:	ef 92       	push	r14
    4daa:	ff 92       	push	r15
    4dac:	0f 93       	push	r16
    4dae:	1f 93       	push	r17
    4db0:	cf 93       	push	r28
    4db2:	df 93       	push	r29
    4db4:	48 2e       	mov	r4, r24
    4db6:	5a 01       	movw	r10, r20
    4db8:	6b 01       	movw	r12, r22
	double place = 1.0;
	
	// save sign
	negative = (x<0);
	// convert to absolute value
	x = (x>0)?(x):(-x);
    4dba:	cb 01       	movw	r24, r22
    4dbc:	ba 01       	movw	r22, r20
    4dbe:	20 e0       	ldi	r18, 0x00	; 0
    4dc0:	30 e0       	ldi	r19, 0x00	; 0
    4dc2:	40 e0       	ldi	r20, 0x00	; 0
    4dc4:	50 e0       	ldi	r21, 0x00	; 0
    4dc6:	0e 94 5c 2d 	call	0x5ab8	; 0x5ab8 <__gesf2>
    4dca:	18 16       	cp	r1, r24
    4dcc:	1c f4       	brge	.+6      	; 0x4dd4 <rprintfFloat+0x40>
    4dce:	35 01       	movw	r6, r10
    4dd0:	46 01       	movw	r8, r12
    4dd2:	06 c0       	rjmp	.+12     	; 0x4de0 <rprintfFloat+0x4c>
    4dd4:	35 01       	movw	r6, r10
    4dd6:	46 01       	movw	r8, r12
    4dd8:	97 fa       	bst	r9, 7
    4dda:	90 94       	com	r9
    4ddc:	97 f8       	bld	r9, 7
    4dde:	90 94       	com	r9
    4de0:	0f 2e       	mov	r0, r31
    4de2:	f0 e0       	ldi	r31, 0x00	; 0
    4de4:	ef 2e       	mov	r14, r31
    4de6:	f0 e0       	ldi	r31, 0x00	; 0
    4de8:	ff 2e       	mov	r15, r31
    4dea:	f0 e8       	ldi	r31, 0x80	; 128
    4dec:	0f 2f       	mov	r16, r31
    4dee:	ff e3       	ldi	r31, 0x3F	; 63
    4df0:	1f 2f       	mov	r17, r31
    4df2:	f0 2d       	mov	r31, r0
    4df4:	55 24       	eor	r5, r5
	
	// find starting digit place
	for(i=0; i<15; i++)
	{
		if((x/place) < 10.0)
    4df6:	c4 01       	movw	r24, r8
    4df8:	b3 01       	movw	r22, r6
    4dfa:	a8 01       	movw	r20, r16
    4dfc:	97 01       	movw	r18, r14
    4dfe:	0e 94 97 2b 	call	0x572e	; 0x572e <__divsf3>
    4e02:	20 e0       	ldi	r18, 0x00	; 0
    4e04:	30 e0       	ldi	r19, 0x00	; 0
    4e06:	40 e2       	ldi	r20, 0x20	; 32
    4e08:	51 e4       	ldi	r21, 0x41	; 65
    4e0a:	0e 94 93 2b 	call	0x5726	; 0x5726 <__cmpsf2>
    4e0e:	87 fd       	sbrc	r24, 7
    4e10:	0e c0       	rjmp	.+28     	; 0x4e2e <rprintfFloat+0x9a>
			break;
		else
			place *= 10.0;
    4e12:	c8 01       	movw	r24, r16
    4e14:	b7 01       	movw	r22, r14
    4e16:	20 e0       	ldi	r18, 0x00	; 0
    4e18:	30 e0       	ldi	r19, 0x00	; 0
    4e1a:	40 e2       	ldi	r20, 0x20	; 32
    4e1c:	51 e4       	ldi	r21, 0x41	; 65
    4e1e:	0e 94 67 2d 	call	0x5ace	; 0x5ace <__mulsf3>
    4e22:	7b 01       	movw	r14, r22
    4e24:	8c 01       	movw	r16, r24
	negative = (x<0);
	// convert to absolute value
	x = (x>0)?(x):(-x);
	
	// find starting digit place
	for(i=0; i<15; i++)
    4e26:	53 94       	inc	r5
    4e28:	8f e0       	ldi	r24, 0x0F	; 15
    4e2a:	58 16       	cp	r5, r24
    4e2c:	21 f7       	brne	.-56     	; 0x4df6 <rprintfFloat+0x62>
			break;
		else
			place *= 10.0;
	}
	// print polarity character
	if(negative)
    4e2e:	c6 01       	movw	r24, r12
    4e30:	b5 01       	movw	r22, r10
    4e32:	20 e0       	ldi	r18, 0x00	; 0
    4e34:	30 e0       	ldi	r19, 0x00	; 0
    4e36:	40 e0       	ldi	r20, 0x00	; 0
    4e38:	50 e0       	ldi	r21, 0x00	; 0
    4e3a:	0e 94 93 2b 	call	0x5726	; 0x5726 <__cmpsf2>
    4e3e:	88 23       	and	r24, r24
    4e40:	14 f4       	brge	.+4      	; 0x4e46 <rprintfFloat+0xb2>
		rprintfChar('-');
    4e42:	8d e2       	ldi	r24, 0x2D	; 45
    4e44:	01 c0       	rjmp	.+2      	; 0x4e48 <rprintfFloat+0xb4>
	else
		rprintfChar('+');
    4e46:	8b e2       	ldi	r24, 0x2B	; 43
    4e48:	0e 94 74 25 	call	0x4ae8	; 0x4ae8 <rprintfChar>
    4e4c:	dd 24       	eor	r13, r13
    4e4e:	aa 24       	eor	r10, r10
    4e50:	56 c0       	rjmp	.+172    	; 0x4efe <rprintfFloat+0x16a>

	// print digits
	for(i=0; i<numDigits; i++)
	{
		digit = (x/place);
    4e52:	c4 01       	movw	r24, r8
    4e54:	b3 01       	movw	r22, r6
    4e56:	a8 01       	movw	r20, r16
    4e58:	97 01       	movw	r18, r14
    4e5a:	0e 94 97 2b 	call	0x572e	; 0x572e <__divsf3>
    4e5e:	0e 94 04 2c 	call	0x5808	; 0x5808 <__fixunssfsi>
    4e62:	b6 2e       	mov	r11, r22

		if(digit | firstplace | (place == 1.0))
    4e64:	d6 2a       	or	r13, r22
    4e66:	cd 2d       	mov	r28, r13
    4e68:	d0 e0       	ldi	r29, 0x00	; 0
    4e6a:	cc 24       	eor	r12, r12
    4e6c:	dd 24       	eor	r13, r13
    4e6e:	c8 01       	movw	r24, r16
    4e70:	b7 01       	movw	r22, r14
    4e72:	20 e0       	ldi	r18, 0x00	; 0
    4e74:	30 e0       	ldi	r19, 0x00	; 0
    4e76:	40 e8       	ldi	r20, 0x80	; 128
    4e78:	5f e3       	ldi	r21, 0x3F	; 63
    4e7a:	0e 94 93 2b 	call	0x5726	; 0x5726 <__cmpsf2>
    4e7e:	88 23       	and	r24, r24
    4e80:	19 f4       	brne	.+6      	; 0x4e88 <rprintfFloat+0xf4>
    4e82:	21 e0       	ldi	r18, 0x01	; 1
    4e84:	c2 2e       	mov	r12, r18
    4e86:	d1 2c       	mov	r13, r1
    4e88:	cc 29       	or	r28, r12
    4e8a:	dd 29       	or	r29, r13
    4e8c:	cd 2b       	or	r28, r29
    4e8e:	39 f0       	breq	.+14     	; 0x4e9e <rprintfFloat+0x10a>
		{
			firstplace = TRUE;
			rprintfChar(digit+0x30);
    4e90:	8b 2d       	mov	r24, r11
    4e92:	80 5d       	subi	r24, 0xD0	; 208
    4e94:	0e 94 74 25 	call	0x4ae8	; 0x4ae8 <rprintfChar>
    4e98:	dd 24       	eor	r13, r13
    4e9a:	da 94       	dec	r13
    4e9c:	04 c0       	rjmp	.+8      	; 0x4ea6 <rprintfFloat+0x112>
		}
		else
			rprintfChar(' ');
    4e9e:	80 e2       	ldi	r24, 0x20	; 32
    4ea0:	0e 94 74 25 	call	0x4ae8	; 0x4ae8 <rprintfChar>
    4ea4:	dd 24       	eor	r13, r13
		
		if(place == 1.0)
    4ea6:	c8 01       	movw	r24, r16
    4ea8:	b7 01       	movw	r22, r14
    4eaa:	20 e0       	ldi	r18, 0x00	; 0
    4eac:	30 e0       	ldi	r19, 0x00	; 0
    4eae:	40 e8       	ldi	r20, 0x80	; 128
    4eb0:	5f e3       	ldi	r21, 0x3F	; 63
    4eb2:	0e 94 93 2b 	call	0x5726	; 0x5726 <__cmpsf2>
    4eb6:	88 23       	and	r24, r24
    4eb8:	19 f4       	brne	.+6      	; 0x4ec0 <rprintfFloat+0x12c>
		{
			rprintfChar('.');
    4eba:	8e e2       	ldi	r24, 0x2E	; 46
    4ebc:	0e 94 74 25 	call	0x4ae8	; 0x4ae8 <rprintfChar>
		}
		
		x -= (digit*place);
    4ec0:	6b 2d       	mov	r22, r11
    4ec2:	70 e0       	ldi	r23, 0x00	; 0
    4ec4:	88 27       	eor	r24, r24
    4ec6:	77 fd       	sbrc	r23, 7
    4ec8:	80 95       	com	r24
    4eca:	98 2f       	mov	r25, r24
    4ecc:	0e 94 32 2c 	call	0x5864	; 0x5864 <__floatsisf>
    4ed0:	a8 01       	movw	r20, r16
    4ed2:	97 01       	movw	r18, r14
    4ed4:	0e 94 67 2d 	call	0x5ace	; 0x5ace <__mulsf3>
    4ed8:	9b 01       	movw	r18, r22
    4eda:	ac 01       	movw	r20, r24
    4edc:	c4 01       	movw	r24, r8
    4ede:	b3 01       	movw	r22, r6
    4ee0:	0e 94 cc 2a 	call	0x5598	; 0x5598 <__subsf3>
    4ee4:	3b 01       	movw	r6, r22
    4ee6:	4c 01       	movw	r8, r24
		place /= 10.0;
    4ee8:	c8 01       	movw	r24, r16
    4eea:	b7 01       	movw	r22, r14
    4eec:	20 e0       	ldi	r18, 0x00	; 0
    4eee:	30 e0       	ldi	r19, 0x00	; 0
    4ef0:	40 e2       	ldi	r20, 0x20	; 32
    4ef2:	51 e4       	ldi	r21, 0x41	; 65
    4ef4:	0e 94 97 2b 	call	0x572e	; 0x572e <__divsf3>
    4ef8:	7b 01       	movw	r14, r22
    4efa:	8c 01       	movw	r16, r24
		rprintfChar('-');
	else
		rprintfChar('+');

	// print digits
	for(i=0; i<numDigits; i++)
    4efc:	a3 94       	inc	r10
    4efe:	a4 14       	cp	r10, r4
    4f00:	08 f4       	brcc	.+2      	; 0x4f04 <rprintfFloat+0x170>
    4f02:	a7 cf       	rjmp	.-178    	; 0x4e52 <rprintfFloat+0xbe>
		}
		
		x -= (digit*place);
		place /= 10.0;
	}
}
    4f04:	df 91       	pop	r29
    4f06:	cf 91       	pop	r28
    4f08:	1f 91       	pop	r17
    4f0a:	0f 91       	pop	r16
    4f0c:	ff 90       	pop	r15
    4f0e:	ef 90       	pop	r14
    4f10:	df 90       	pop	r13
    4f12:	cf 90       	pop	r12
    4f14:	bf 90       	pop	r11
    4f16:	af 90       	pop	r10
    4f18:	9f 90       	pop	r9
    4f1a:	8f 90       	pop	r8
    4f1c:	7f 90       	pop	r7
    4f1e:	6f 90       	pop	r6
    4f20:	5f 90       	pop	r5
    4f22:	4f 90       	pop	r4
    4f24:	08 95       	ret

00004f26 <rprintf1RamRom>:
// Supports:
// %d - decimal
// %x - hex
// %c - character
int rprintf1RamRom(unsigned char stringInRom, const char *format, ...)
{
    4f26:	7f 92       	push	r7
    4f28:	8f 92       	push	r8
    4f2a:	9f 92       	push	r9
    4f2c:	af 92       	push	r10
    4f2e:	bf 92       	push	r11
    4f30:	cf 92       	push	r12
    4f32:	df 92       	push	r13
    4f34:	ef 92       	push	r14
    4f36:	ff 92       	push	r15
    4f38:	0f 93       	push	r16
    4f3a:	1f 93       	push	r17
    4f3c:	df 93       	push	r29
    4f3e:	cf 93       	push	r28
    4f40:	cd b7       	in	r28, 0x3d	; 61
    4f42:	de b7       	in	r29, 0x3e	; 62
    4f44:	78 88       	ldd	r7, Y+16	; 0x10
    4f46:	c9 88       	ldd	r12, Y+17	; 0x11
    4f48:	da 88       	ldd	r13, Y+18	; 0x12
    4f4a:	63 e1       	ldi	r22, 0x13	; 19
    4f4c:	e6 2e       	mov	r14, r22
    4f4e:	f1 2c       	mov	r15, r1
    4f50:	ec 0e       	add	r14, r28
    4f52:	fd 1e       	adc	r15, r29
    4f54:	14 c0       	rjmp	.+40     	; 0x4f7e <rprintf1RamRom+0x58>
	va_start(ap, format);
	for (;;)
	{
		while ((format_flag = READMEMBYTE(stringInRom,format++) ) != '%')
		{	// Until '%' or '\0'
			if (!format_flag)
    4f56:	88 23       	and	r24, r24
    4f58:	81 f4       	brne	.+32     	; 0x4f7a <rprintf1RamRom+0x54>
				div_val /= base;
			} while (div_val);
		}
	}
	va_end(ap);
}
    4f5a:	80 e0       	ldi	r24, 0x00	; 0
    4f5c:	90 e0       	ldi	r25, 0x00	; 0
    4f5e:	cf 91       	pop	r28
    4f60:	df 91       	pop	r29
    4f62:	1f 91       	pop	r17
    4f64:	0f 91       	pop	r16
    4f66:	ff 90       	pop	r15
    4f68:	ef 90       	pop	r14
    4f6a:	df 90       	pop	r13
    4f6c:	cf 90       	pop	r12
    4f6e:	bf 90       	pop	r11
    4f70:	af 90       	pop	r10
    4f72:	9f 90       	pop	r9
    4f74:	8f 90       	pop	r8
    4f76:	7f 90       	pop	r7
    4f78:	08 95       	ret
			if (!format_flag)
			{
				va_end(ap);
				return(0);
			}
			rprintfChar(format_flag);
    4f7a:	0e 94 74 25 	call	0x4ae8	; 0x4ae8 <rprintfChar>
    4f7e:	96 01       	movw	r18, r12
    4f80:	2f 5f       	subi	r18, 0xFF	; 255
    4f82:	3f 4f       	sbci	r19, 0xFF	; 255
	va_list ap;

	va_start(ap, format);
	for (;;)
	{
		while ((format_flag = READMEMBYTE(stringInRom,format++) ) != '%')
    4f84:	77 20       	and	r7, r7
    4f86:	21 f0       	breq	.+8      	; 0x4f90 <rprintf1RamRom+0x6a>
    4f88:	f6 01       	movw	r30, r12
    4f8a:	69 01       	movw	r12, r18
    4f8c:	84 91       	lpm	r24, Z+
    4f8e:	03 c0       	rjmp	.+6      	; 0x4f96 <rprintf1RamRom+0x70>
    4f90:	f6 01       	movw	r30, r12
    4f92:	80 81       	ld	r24, Z
    4f94:	69 01       	movw	r12, r18
    4f96:	85 32       	cpi	r24, 0x25	; 37
    4f98:	f1 f6       	brne	.-68     	; 0x4f56 <rprintf1RamRom+0x30>
    4f9a:	2f 5f       	subi	r18, 0xFF	; 255
    4f9c:	3f 4f       	sbci	r19, 0xFF	; 255
				return(0);
			}
			rprintfChar(format_flag);
		}

		switch (format_flag = READMEMBYTE(stringInRom,format++) )
    4f9e:	77 20       	and	r7, r7
    4fa0:	21 f0       	breq	.+8      	; 0x4faa <rprintf1RamRom+0x84>
    4fa2:	f6 01       	movw	r30, r12
    4fa4:	69 01       	movw	r12, r18
    4fa6:	84 91       	lpm	r24, Z+
    4fa8:	03 c0       	rjmp	.+6      	; 0x4fb0 <rprintf1RamRom+0x8a>
    4faa:	f6 01       	movw	r30, r12
    4fac:	80 81       	ld	r24, Z
    4fae:	69 01       	movw	r12, r18
    4fb0:	84 36       	cpi	r24, 0x64	; 100
    4fb2:	29 f0       	breq	.+10     	; 0x4fbe <rprintf1RamRom+0x98>
    4fb4:	88 37       	cpi	r24, 0x78	; 120
    4fb6:	81 f0       	breq	.+32     	; 0x4fd8 <rprintf1RamRom+0xb2>
    4fb8:	83 36       	cpi	r24, 0x63	; 99
    4fba:	f9 f6       	brne	.-66     	; 0x4f7a <rprintf1RamRom+0x54>
    4fbc:	06 c0       	rjmp	.+12     	; 0x4fca <rprintf1RamRom+0xa4>
    4fbe:	00 e1       	ldi	r16, 0x10	; 16
    4fc0:	17 e2       	ldi	r17, 0x27	; 39
    4fc2:	5a e0       	ldi	r21, 0x0A	; 10
    4fc4:	a5 2e       	mov	r10, r21
    4fc6:	b1 2c       	mov	r11, r1
    4fc8:	0c c0       	rjmp	.+24     	; 0x4fe2 <rprintf1RamRom+0xbc>
		{
			case 'c': format_flag = va_arg(ap,int);
    4fca:	f7 01       	movw	r30, r14
    4fcc:	80 81       	ld	r24, Z
    4fce:	22 e0       	ldi	r18, 0x02	; 2
    4fd0:	30 e0       	ldi	r19, 0x00	; 0
    4fd2:	e2 0e       	add	r14, r18
    4fd4:	f3 1e       	adc	r15, r19
    4fd6:	d1 cf       	rjmp	.-94     	; 0x4f7a <rprintf1RamRom+0x54>
			default:  rprintfChar(format_flag); continue;
    4fd8:	00 e0       	ldi	r16, 0x00	; 0
    4fda:	10 e1       	ldi	r17, 0x10	; 16
    4fdc:	40 e1       	ldi	r20, 0x10	; 16
    4fde:	a4 2e       	mov	r10, r20
    4fe0:	b1 2c       	mov	r11, r1
			case 'd': base = 10; div_val = 10000; goto CONVERSION_LOOP;
//			case 'x': base = 16; div_val = 0x10;
			case 'x': base = 16; div_val = 0x1000;

			CONVERSION_LOOP:
			u_val = va_arg(ap,int);
    4fe2:	32 e0       	ldi	r19, 0x02	; 2
    4fe4:	83 2e       	mov	r8, r19
    4fe6:	91 2c       	mov	r9, r1
    4fe8:	8e 0c       	add	r8, r14
    4fea:	9f 1c       	adc	r9, r15
    4fec:	f7 01       	movw	r30, r14
    4fee:	e0 80       	ld	r14, Z
    4ff0:	f1 80       	ldd	r15, Z+1	; 0x01
			if (format_flag == 'd')
    4ff2:	84 36       	cpi	r24, 0x64	; 100
    4ff4:	b1 f4       	brne	.+44     	; 0x5022 <rprintf1RamRom+0xfc>
			{
				if (((int)u_val) < 0)
    4ff6:	f7 fe       	sbrs	r15, 7
    4ff8:	11 c0       	rjmp	.+34     	; 0x501c <rprintf1RamRom+0xf6>
				{
					u_val = - u_val;
    4ffa:	f0 94       	com	r15
    4ffc:	e1 94       	neg	r14
    4ffe:	f1 08       	sbc	r15, r1
    5000:	f3 94       	inc	r15
					rprintfChar('-');
    5002:	8d e2       	ldi	r24, 0x2D	; 45
    5004:	0e 94 74 25 	call	0x4ae8	; 0x4ae8 <rprintfChar>
    5008:	09 c0       	rjmp	.+18     	; 0x501c <rprintf1RamRom+0xf6>
				}
				while (div_val > 1 && div_val > u_val) div_val /= 10;
    500a:	c8 01       	movw	r24, r16
    500c:	6a e0       	ldi	r22, 0x0A	; 10
    500e:	70 e0       	ldi	r23, 0x00	; 0
    5010:	0e 94 ec 2d 	call	0x5bd8	; 0x5bd8 <__udivmodhi4>
    5014:	8b 01       	movw	r16, r22
    5016:	62 30       	cpi	r22, 0x02	; 2
    5018:	71 05       	cpc	r23, r1
    501a:	18 f0       	brcs	.+6      	; 0x5022 <rprintf1RamRom+0xfc>
    501c:	e0 16       	cp	r14, r16
    501e:	f1 06       	cpc	r15, r17
    5020:	a0 f3       	brcs	.-24     	; 0x500a <rprintf1RamRom+0xe4>
			}
			do
			{
				//rprintfChar(pgm_read_byte(HexChars+(u_val/div_val)));
				rprintfu04(u_val/div_val);
    5022:	c7 01       	movw	r24, r14
    5024:	b8 01       	movw	r22, r16
    5026:	0e 94 ec 2d 	call	0x5bd8	; 0x5bd8 <__udivmodhi4>
    502a:	86 2f       	mov	r24, r22
    502c:	0e 94 d7 25 	call	0x4bae	; 0x4bae <rprintfu04>
				u_val %= div_val;
    5030:	c7 01       	movw	r24, r14
    5032:	b8 01       	movw	r22, r16
    5034:	0e 94 ec 2d 	call	0x5bd8	; 0x5bd8 <__udivmodhi4>
    5038:	7c 01       	movw	r14, r24
				div_val /= base;
    503a:	c8 01       	movw	r24, r16
    503c:	b5 01       	movw	r22, r10
    503e:	0e 94 ec 2d 	call	0x5bd8	; 0x5bd8 <__udivmodhi4>
    5042:	8b 01       	movw	r16, r22
			} while (div_val);
    5044:	61 15       	cp	r22, r1
    5046:	71 05       	cpc	r23, r1
    5048:	61 f7       	brne	.-40     	; 0x5022 <rprintf1RamRom+0xfc>
    504a:	74 01       	movw	r14, r8
    504c:	98 cf       	rjmp	.-208    	; 0x4f7e <rprintf1RamRom+0x58>

0000504e <i2cSetBitrate>:
	// SCL freq = F_CPU/(16+2*TWBR))
	#ifdef TWPS0
		// for processors with additional bitrate division (mega128)
		// SCL freq = F_CPU/(16+2*TWBR*4^TWPS)
		// set TWPS to zero
		cbi(TWSR, TWPS0);
    504e:	20 91 b9 00 	lds	r18, 0x00B9
    5052:	2e 7f       	andi	r18, 0xFE	; 254
    5054:	20 93 b9 00 	sts	0x00B9, r18
		cbi(TWSR, TWPS1);
    5058:	20 91 b9 00 	lds	r18, 0x00B9
    505c:	2d 7f       	andi	r18, 0xFD	; 253
    505e:	20 93 b9 00 	sts	0x00B9, r18
	#endif
	// calculate bitrate division	
	bitrate_div = ((F_CPU/1000l)/bitrateKHz);
    5062:	9c 01       	movw	r18, r24
    5064:	40 e0       	ldi	r20, 0x00	; 0
    5066:	50 e0       	ldi	r21, 0x00	; 0
    5068:	60 e8       	ldi	r22, 0x80	; 128
    506a:	7e e3       	ldi	r23, 0x3E	; 62
    506c:	80 e0       	ldi	r24, 0x00	; 0
    506e:	90 e0       	ldi	r25, 0x00	; 0
    5070:	0e 94 35 2e 	call	0x5c6a	; 0x5c6a <__divmodsi4>
	if(bitrate_div >= 16)
    5074:	20 31       	cpi	r18, 0x10	; 16
    5076:	30 f0       	brcs	.+12     	; 0x5084 <i2cSetBitrate+0x36>
		bitrate_div = (bitrate_div-16)/2;
    5078:	82 2f       	mov	r24, r18
    507a:	90 e0       	ldi	r25, 0x00	; 0
    507c:	40 97       	sbiw	r24, 0x10	; 16
    507e:	95 95       	asr	r25
    5080:	87 95       	ror	r24
    5082:	28 2f       	mov	r18, r24
	outb(TWBR, bitrate_div);
    5084:	20 93 b8 00 	sts	0x00B8, r18
}
    5088:	08 95       	ret

0000508a <i2cInit>:

// functions
void i2cInit(void)
{
	// set pull-up resistors on I2C bus pins
	sbi(PORTD, 0);	// i2c SCL on 640
    508a:	58 9a       	sbi	0x0b, 0	; 11
	sbi(PORTD, 1);	// i2c SDA on 640
    508c:	59 9a       	sbi	0x0b, 1	; 11

	// clear SlaveReceive and SlaveTransmit handler to null
	i2cSlaveReceive = 0;
    508e:	10 92 3a 12 	sts	0x123A, r1
    5092:	10 92 39 12 	sts	0x1239, r1
	i2cSlaveTransmit = 0;
    5096:	10 92 3c 12 	sts	0x123C, r1
    509a:	10 92 3b 12 	sts	0x123B, r1
	// set i2c bit rate to 100KHz
	i2cSetBitrate(100);
    509e:	84 e6       	ldi	r24, 0x64	; 100
    50a0:	90 e0       	ldi	r25, 0x00	; 0
    50a2:	0e 94 27 28 	call	0x504e	; 0x504e <i2cSetBitrate>
	// enable TWI (two-wire interface)
	sbi(TWCR, TWEN);
    50a6:	ec eb       	ldi	r30, 0xBC	; 188
    50a8:	f0 e0       	ldi	r31, 0x00	; 0
    50aa:	80 81       	ld	r24, Z
    50ac:	84 60       	ori	r24, 0x04	; 4
    50ae:	80 83       	st	Z, r24
	// set state
	I2cState = I2C_IDLE;
    50b0:	10 92 f3 11 	sts	0x11F3, r1
	// enable TWI interrupt and slave address ACK
	sbi(TWCR, TWIE);
    50b4:	80 81       	ld	r24, Z
    50b6:	81 60       	ori	r24, 0x01	; 1
    50b8:	80 83       	st	Z, r24
	sbi(TWCR, TWEA);
    50ba:	80 81       	ld	r24, Z
    50bc:	80 64       	ori	r24, 0x40	; 64
    50be:	80 83       	st	Z, r24
	//outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
	// enable interrupts
	sei();
    50c0:	78 94       	sei
}
    50c2:	08 95       	ret

000050c4 <i2cSetLocalDeviceAddr>:
}

void i2cSetLocalDeviceAddr(u08 deviceAddr, u08 genCallEn)
{
	// set local device address (used in slave mode only)
	outb(TWAR, ((deviceAddr&0xFE) | (genCallEn?1:0)) );
    50c4:	90 e0       	ldi	r25, 0x00	; 0
    50c6:	61 11       	cpse	r22, r1
    50c8:	91 e0       	ldi	r25, 0x01	; 1
    50ca:	8e 7f       	andi	r24, 0xFE	; 254
    50cc:	98 2b       	or	r25, r24
    50ce:	90 93 ba 00 	sts	0x00BA, r25
}
    50d2:	08 95       	ret

000050d4 <i2cSetSlaveReceiveHandler>:

void i2cSetSlaveReceiveHandler(void (*i2cSlaveRx_func)(u08 receiveDataLength, u08* recieveData))
{
	i2cSlaveReceive = i2cSlaveRx_func;
    50d4:	90 93 3a 12 	sts	0x123A, r25
    50d8:	80 93 39 12 	sts	0x1239, r24
}
    50dc:	08 95       	ret

000050de <i2cSetSlaveTransmitHandler>:

void i2cSetSlaveTransmitHandler(u08 (*i2cSlaveTx_func)(u08 transmitDataLengthMax, u08* transmitData))
{
	i2cSlaveTransmit = i2cSlaveTx_func;
    50de:	90 93 3c 12 	sts	0x123C, r25
    50e2:	80 93 3b 12 	sts	0x123B, r24
}
    50e6:	08 95       	ret

000050e8 <i2cSendStart>:

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    50e8:	ec eb       	ldi	r30, 0xBC	; 188
    50ea:	f0 e0       	ldi	r31, 0x00	; 0
    50ec:	80 81       	ld	r24, Z
    50ee:	8f 70       	andi	r24, 0x0F	; 15
    50f0:	80 6a       	ori	r24, 0xA0	; 160
    50f2:	80 83       	st	Z, r24
}
    50f4:	08 95       	ret

000050f6 <i2cSendStop>:

inline void i2cSendStop(void)
{
	// transmit stop condition
	// leave with TWEA on for slave receiving
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA)|BV(TWSTO));
    50f6:	ec eb       	ldi	r30, 0xBC	; 188
    50f8:	f0 e0       	ldi	r31, 0x00	; 0
    50fa:	80 81       	ld	r24, Z
    50fc:	8f 70       	andi	r24, 0x0F	; 15
    50fe:	80 6d       	ori	r24, 0xD0	; 208
    5100:	80 83       	st	Z, r24
}
    5102:	08 95       	ret

00005104 <i2cWaitForComplete>:

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    5104:	80 91 bc 00 	lds	r24, 0x00BC
    5108:	87 ff       	sbrs	r24, 7
    510a:	fc cf       	rjmp	.-8      	; 0x5104 <i2cWaitForComplete>
}
    510c:	08 95       	ret

0000510e <i2cSendByte>:

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    510e:	80 93 bb 00 	sts	0x00BB, r24
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    5112:	ec eb       	ldi	r30, 0xBC	; 188
    5114:	f0 e0       	ldi	r31, 0x00	; 0
    5116:	80 81       	ld	r24, Z
    5118:	8f 70       	andi	r24, 0x0F	; 15
    511a:	80 68       	ori	r24, 0x80	; 128
    511c:	80 83       	st	Z, r24
}
    511e:	08 95       	ret

00005120 <i2cReceiveByte>:

inline void i2cReceiveByte(u08 ackFlag)
{
	// begin receive over i2c
	if( ackFlag )
    5120:	88 23       	and	r24, r24
    5122:	29 f0       	breq	.+10     	; 0x512e <i2cReceiveByte+0xe>
	{
		// ackFlag = TRUE: ACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    5124:	80 91 bc 00 	lds	r24, 0x00BC
    5128:	8f 70       	andi	r24, 0x0F	; 15
    512a:	80 6c       	ori	r24, 0xC0	; 192
    512c:	04 c0       	rjmp	.+8      	; 0x5136 <i2cReceiveByte+0x16>
	}
	else
	{
		// ackFlag = FALSE: NACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    512e:	80 91 bc 00 	lds	r24, 0x00BC
    5132:	8f 70       	andi	r24, 0x0F	; 15
    5134:	80 68       	ori	r24, 0x80	; 128
    5136:	80 93 bc 00 	sts	0x00BC, r24
    513a:	08 95       	ret

0000513c <i2cGetReceivedByte>:
}

inline u08 i2cGetReceivedByte(void)
{
	// retieve received data byte from i2c TWDR
	return( inb(TWDR) );
    513c:	80 91 bb 00 	lds	r24, 0x00BB
}
    5140:	08 95       	ret

00005142 <i2cGetStatus>:

inline u08 i2cGetStatus(void)
{
	// retieve current i2c status from i2c TWSR
	return( inb(TWSR) );
    5142:	80 91 b9 00 	lds	r24, 0x00B9
}
    5146:	08 95       	ret

00005148 <i2cMasterSend>:

void i2cMasterSend(u08 deviceAddr, u08 length, u08* data)
{
    5148:	98 2f       	mov	r25, r24
	u08 i;
	// wait for interface to be ready
	while(I2cState);
    514a:	80 91 f3 11 	lds	r24, 0x11F3
    514e:	88 23       	and	r24, r24
    5150:	e1 f7       	brne	.-8      	; 0x514a <i2cMasterSend+0x2>
	// set state
	I2cState = I2C_MASTER_TX;
    5152:	82 e0       	ldi	r24, 0x02	; 2
    5154:	80 93 f3 11 	sts	0x11F3, r24
	// save data
	I2cDeviceAddrRW = (deviceAddr & 0xFE);	// RW cleared: write operation
    5158:	9e 7f       	andi	r25, 0xFE	; 254
    515a:	90 93 f4 11 	sts	0x11F4, r25
    515e:	a5 ef       	ldi	r26, 0xF5	; 245
    5160:	b1 e1       	ldi	r27, 0x11	; 17
    5162:	fa 01       	movw	r30, r20
    5164:	02 c0       	rjmp	.+4      	; 0x516a <i2cMasterSend+0x22>
	for(i=0; i<length; i++)
		I2cSendData[i] = *data++;
    5166:	81 91       	ld	r24, Z+
    5168:	8d 93       	st	X+, r24
	while(I2cState);
	// set state
	I2cState = I2C_MASTER_TX;
	// save data
	I2cDeviceAddrRW = (deviceAddr & 0xFE);	// RW cleared: write operation
	for(i=0; i<length; i++)
    516a:	8e 2f       	mov	r24, r30
    516c:	84 1b       	sub	r24, r20
    516e:	86 17       	cp	r24, r22
    5170:	d0 f3       	brcs	.-12     	; 0x5166 <i2cMasterSend+0x1e>
		I2cSendData[i] = *data++;
	I2cSendDataIndex = 0;
    5172:	10 92 15 12 	sts	0x1215, r1
	I2cSendDataLength = length;
    5176:	60 93 16 12 	sts	0x1216, r22
}

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    517a:	80 91 bc 00 	lds	r24, 0x00BC
    517e:	8f 70       	andi	r24, 0x0F	; 15
    5180:	80 6a       	ori	r24, 0xA0	; 160
    5182:	80 93 bc 00 	sts	0x00BC, r24
		I2cSendData[i] = *data++;
	I2cSendDataIndex = 0;
	I2cSendDataLength = length;
	// send start condition
	i2cSendStart();
}
    5186:	08 95       	ret

00005188 <i2cMasterReceive>:

void i2cMasterReceive(u08 deviceAddr, u08 length, u08* data)
{
    5188:	98 2f       	mov	r25, r24
	u08 i;
	// wait for interface to be ready
	while(I2cState);
    518a:	80 91 f3 11 	lds	r24, 0x11F3
    518e:	88 23       	and	r24, r24
    5190:	e1 f7       	brne	.-8      	; 0x518a <i2cMasterReceive+0x2>
	// set state
	I2cState = I2C_MASTER_RX;
    5192:	83 e0       	ldi	r24, 0x03	; 3
    5194:	80 93 f3 11 	sts	0x11F3, r24
	// save data
	I2cDeviceAddrRW = (deviceAddr|0x01);	// RW set: read operation
    5198:	91 60       	ori	r25, 0x01	; 1
    519a:	90 93 f4 11 	sts	0x11F4, r25
	I2cReceiveDataIndex = 0;
    519e:	10 92 37 12 	sts	0x1237, r1
	I2cReceiveDataLength = length;
    51a2:	60 93 38 12 	sts	0x1238, r22
}

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    51a6:	80 91 bc 00 	lds	r24, 0x00BC
    51aa:	8f 70       	andi	r24, 0x0F	; 15
    51ac:	80 6a       	ori	r24, 0xA0	; 160
    51ae:	80 93 bc 00 	sts	0x00BC, r24
	I2cReceiveDataIndex = 0;
	I2cReceiveDataLength = length;
	// send start condition
	i2cSendStart();
	// wait for data
	while(I2cState);
    51b2:	80 91 f3 11 	lds	r24, 0x11F3
    51b6:	88 23       	and	r24, r24
    51b8:	e1 f7       	brne	.-8      	; 0x51b2 <i2cMasterReceive+0x2a>
    51ba:	a7 e1       	ldi	r26, 0x17	; 23
    51bc:	b2 e1       	ldi	r27, 0x12	; 18
    51be:	fa 01       	movw	r30, r20
    51c0:	02 c0       	rjmp	.+4      	; 0x51c6 <i2cMasterReceive+0x3e>
	// return data
	for(i=0; i<length; i++)
		*data++ = I2cReceiveData[i];
    51c2:	8d 91       	ld	r24, X+
    51c4:	81 93       	st	Z+, r24
	// send start condition
	i2cSendStart();
	// wait for data
	while(I2cState);
	// return data
	for(i=0; i<length; i++)
    51c6:	8e 2f       	mov	r24, r30
    51c8:	84 1b       	sub	r24, r20
    51ca:	86 17       	cp	r24, r22
    51cc:	d0 f3       	brcs	.-12     	; 0x51c2 <i2cMasterReceive+0x3a>
		*data++ = I2cReceiveData[i];
}
    51ce:	08 95       	ret

000051d0 <i2cMasterSendNI>:

u08 i2cMasterSendNI(u08 deviceAddr, u08 length, u08* data)
{
    51d0:	98 2f       	mov	r25, r24
    51d2:	fa 01       	movw	r30, r20
	u08 retval = I2C_OK;

	// disable TWI interrupt
	cbi(TWCR, TWIE);
    51d4:	80 91 bc 00 	lds	r24, 0x00BC
    51d8:	8e 7f       	andi	r24, 0xFE	; 254
    51da:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    51de:	80 91 bc 00 	lds	r24, 0x00BC
    51e2:	8f 70       	andi	r24, 0x0F	; 15
    51e4:	80 6a       	ori	r24, 0xA0	; 160
    51e6:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    51ea:	80 91 bc 00 	lds	r24, 0x00BC
    51ee:	87 ff       	sbrs	r24, 7
    51f0:	fc cf       	rjmp	.-8      	; 0x51ea <i2cMasterSendNI+0x1a>
	// send start condition
	i2cSendStart();
	i2cWaitForComplete();

	// send device address with write
	i2cSendByte( deviceAddr & 0xFE );
    51f2:	9e 7f       	andi	r25, 0xFE	; 254
}

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    51f4:	90 93 bb 00 	sts	0x00BB, r25
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    51f8:	80 91 bc 00 	lds	r24, 0x00BC
    51fc:	8f 70       	andi	r24, 0x0F	; 15
    51fe:	80 68       	ori	r24, 0x80	; 128
    5200:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    5204:	80 91 bc 00 	lds	r24, 0x00BC
    5208:	87 ff       	sbrs	r24, 7
    520a:	fc cf       	rjmp	.-8      	; 0x5204 <i2cMasterSendNI+0x34>
	// send device address with write
	i2cSendByte( deviceAddr & 0xFE );
	i2cWaitForComplete();

	// check if device is present and live
	if( inb(TWSR) == TW_MT_SLA_ACK)
    520c:	80 91 b9 00 	lds	r24, 0x00B9
    5210:	88 31       	cpi	r24, 0x18	; 24
    5212:	89 f0       	breq	.+34     	; 0x5236 <i2cMasterSendNI+0x66>
    5214:	91 e0       	ldi	r25, 0x01	; 1
    5216:	12 c0       	rjmp	.+36     	; 0x523c <i2cMasterSendNI+0x6c>
	{
		// send data
		while(length)
		{
			i2cSendByte( *data++ );
    5218:	80 81       	ld	r24, Z
}

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    521a:	80 93 bb 00 	sts	0x00BB, r24
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    521e:	80 91 bc 00 	lds	r24, 0x00BC
    5222:	8f 70       	andi	r24, 0x0F	; 15
    5224:	80 68       	ori	r24, 0x80	; 128
    5226:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    522a:	80 91 bc 00 	lds	r24, 0x00BC
    522e:	87 ff       	sbrs	r24, 7
    5230:	fc cf       	rjmp	.-8      	; 0x522a <i2cMasterSendNI+0x5a>
	if( inb(TWSR) == TW_MT_SLA_ACK)
	{
		// send data
		while(length)
		{
			i2cSendByte( *data++ );
    5232:	31 96       	adiw	r30, 0x01	; 1
			i2cWaitForComplete();
			length--;
    5234:	61 50       	subi	r22, 0x01	; 1

	// check if device is present and live
	if( inb(TWSR) == TW_MT_SLA_ACK)
	{
		// send data
		while(length)
    5236:	66 23       	and	r22, r22
    5238:	79 f7       	brne	.-34     	; 0x5218 <i2cMasterSendNI+0x48>
    523a:	90 e0       	ldi	r25, 0x00	; 0

inline void i2cSendStop(void)
{
	// transmit stop condition
	// leave with TWEA on for slave receiving
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA)|BV(TWSTO));
    523c:	80 91 bc 00 	lds	r24, 0x00BC
    5240:	8f 70       	andi	r24, 0x0F	; 15
    5242:	80 6d       	ori	r24, 0xD0	; 208
    5244:	80 93 bc 00 	sts	0x00BC, r24
	}

	// transmit stop condition
	// leave with TWEA on for slave receiving
	i2cSendStop();
	while( !(inb(TWCR) & BV(TWSTO)) );
    5248:	80 91 bc 00 	lds	r24, 0x00BC
    524c:	84 ff       	sbrs	r24, 4
    524e:	fc cf       	rjmp	.-8      	; 0x5248 <i2cMasterSendNI+0x78>

	// enable TWI interrupt
	sbi(TWCR, TWIE);
    5250:	80 91 bc 00 	lds	r24, 0x00BC
    5254:	81 60       	ori	r24, 0x01	; 1
    5256:	80 93 bc 00 	sts	0x00BC, r24

	return retval;
}
    525a:	89 2f       	mov	r24, r25
    525c:	08 95       	ret

0000525e <i2cMasterReceiveNI>:

u08 i2cMasterReceiveNI(u08 deviceAddr, u08 length, u08 *data)
{
    525e:	98 2f       	mov	r25, r24
    5260:	fa 01       	movw	r30, r20
	u08 retval = I2C_OK;

	// disable TWI interrupt
	cbi(TWCR, TWIE);
    5262:	80 91 bc 00 	lds	r24, 0x00BC
    5266:	8e 7f       	andi	r24, 0xFE	; 254
    5268:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    526c:	80 91 bc 00 	lds	r24, 0x00BC
    5270:	8f 70       	andi	r24, 0x0F	; 15
    5272:	80 6a       	ori	r24, 0xA0	; 160
    5274:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    5278:	80 91 bc 00 	lds	r24, 0x00BC
    527c:	87 ff       	sbrs	r24, 7
    527e:	fc cf       	rjmp	.-8      	; 0x5278 <i2cMasterReceiveNI+0x1a>
	// send start condition
	i2cSendStart();
	i2cWaitForComplete();

	// send device address with read
	i2cSendByte( deviceAddr | 0x01 );
    5280:	91 60       	ori	r25, 0x01	; 1
}

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    5282:	90 93 bb 00 	sts	0x00BB, r25
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    5286:	80 91 bc 00 	lds	r24, 0x00BC
    528a:	8f 70       	andi	r24, 0x0F	; 15
    528c:	80 68       	ori	r24, 0x80	; 128
    528e:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    5292:	80 91 bc 00 	lds	r24, 0x00BC
    5296:	87 ff       	sbrs	r24, 7
    5298:	fc cf       	rjmp	.-8      	; 0x5292 <i2cMasterReceiveNI+0x34>
	// send device address with read
	i2cSendByte( deviceAddr | 0x01 );
	i2cWaitForComplete();

	// check if device is present and live
	if( inb(TWSR) == TW_MR_SLA_ACK)
    529a:	80 91 b9 00 	lds	r24, 0x00B9
    529e:	80 34       	cpi	r24, 0x40	; 64
    52a0:	81 f0       	breq	.+32     	; 0x52c2 <i2cMasterReceiveNI+0x64>
    52a2:	91 e0       	ldi	r25, 0x01	; 1
    52a4:	1e c0       	rjmp	.+60     	; 0x52e2 <i2cMasterReceiveNI+0x84>
{
	// begin receive over i2c
	if( ackFlag )
	{
		// ackFlag = TRUE: ACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    52a6:	80 91 bc 00 	lds	r24, 0x00BC
    52aa:	8f 70       	andi	r24, 0x0F	; 15
    52ac:	80 6c       	ori	r24, 0xC0	; 192
    52ae:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    52b2:	80 91 bc 00 	lds	r24, 0x00BC
    52b6:	87 ff       	sbrs	r24, 7
    52b8:	fc cf       	rjmp	.-8      	; 0x52b2 <i2cMasterReceiveNI+0x54>
}

inline u08 i2cGetReceivedByte(void)
{
	// retieve received data byte from i2c TWDR
	return( inb(TWDR) );
    52ba:	80 91 bb 00 	lds	r24, 0x00BB
		// accept receive data and ack it
		while(length > 1)
		{
			i2cReceiveByte(TRUE);
			i2cWaitForComplete();
			*data++ = i2cGetReceivedByte();
    52be:	81 93       	st	Z+, r24
			// decrement length
			length--;
    52c0:	61 50       	subi	r22, 0x01	; 1

	// check if device is present and live
	if( inb(TWSR) == TW_MR_SLA_ACK)
	{
		// accept receive data and ack it
		while(length > 1)
    52c2:	62 30       	cpi	r22, 0x02	; 2
    52c4:	80 f7       	brcc	.-32     	; 0x52a6 <i2cMasterReceiveNI+0x48>
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
	}
	else
	{
		// ackFlag = FALSE: NACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    52c6:	80 91 bc 00 	lds	r24, 0x00BC
    52ca:	8f 70       	andi	r24, 0x0F	; 15
    52cc:	80 68       	ori	r24, 0x80	; 128
    52ce:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    52d2:	80 91 bc 00 	lds	r24, 0x00BC
    52d6:	87 ff       	sbrs	r24, 7
    52d8:	fc cf       	rjmp	.-8      	; 0x52d2 <i2cMasterReceiveNI+0x74>
}

inline u08 i2cGetReceivedByte(void)
{
	// retieve received data byte from i2c TWDR
	return( inb(TWDR) );
    52da:	80 91 bb 00 	lds	r24, 0x00BB
		}

		// accept receive data and nack it (last-byte signal)
		i2cReceiveByte(FALSE);
		i2cWaitForComplete();
		*data++ = i2cGetReceivedByte();
    52de:	80 83       	st	Z, r24
    52e0:	90 e0       	ldi	r25, 0x00	; 0

inline void i2cSendStop(void)
{
	// transmit stop condition
	// leave with TWEA on for slave receiving
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA)|BV(TWSTO));
    52e2:	80 91 bc 00 	lds	r24, 0x00BC
    52e6:	8f 70       	andi	r24, 0x0F	; 15
    52e8:	80 6d       	ori	r24, 0xD0	; 208
    52ea:	80 93 bc 00 	sts	0x00BC, r24
	// transmit stop condition
	// leave with TWEA on for slave receiving
	i2cSendStop();

	// enable TWI interrupt
	sbi(TWCR, TWIE);
    52ee:	80 91 bc 00 	lds	r24, 0x00BC
    52f2:	81 60       	ori	r24, 0x01	; 1
    52f4:	80 93 bc 00 	sts	0x00BC, r24

	return retval;
}
    52f8:	89 2f       	mov	r24, r25
    52fa:	08 95       	ret

000052fc <__vector_39>:
}
*/

//! I2C (TWI) interrupt service routine
SIGNAL(SIG_2WIRE_SERIAL)
{
    52fc:	1f 92       	push	r1
    52fe:	0f 92       	push	r0
    5300:	0f b6       	in	r0, 0x3f	; 63
    5302:	0f 92       	push	r0
    5304:	11 24       	eor	r1, r1
    5306:	2f 93       	push	r18
    5308:	3f 93       	push	r19
    530a:	4f 93       	push	r20
    530c:	5f 93       	push	r21
    530e:	6f 93       	push	r22
    5310:	7f 93       	push	r23
    5312:	8f 93       	push	r24
    5314:	9f 93       	push	r25
    5316:	af 93       	push	r26
    5318:	bf 93       	push	r27
    531a:	ef 93       	push	r30
    531c:	ff 93       	push	r31
	// read status bits
	u08 status = inb(TWSR) & TWSR_STATUS_MASK;
    531e:	80 91 b9 00 	lds	r24, 0x00B9

	switch(status)
    5322:	88 7f       	andi	r24, 0xF8	; 248
    5324:	80 36       	cpi	r24, 0x60	; 96
    5326:	09 f4       	brne	.+2      	; 0x532a <__vector_39+0x2e>
    5328:	a0 c0       	rjmp	.+320    	; 0x546a <__vector_39+0x16e>
    532a:	81 36       	cpi	r24, 0x61	; 97
    532c:	70 f5       	brcc	.+92     	; 0x538a <__vector_39+0x8e>
    532e:	88 32       	cpi	r24, 0x28	; 40
    5330:	09 f4       	brne	.+2      	; 0x5334 <__vector_39+0x38>
    5332:	5f c0       	rjmp	.+190    	; 0x53f2 <__vector_39+0xf6>
    5334:	89 32       	cpi	r24, 0x29	; 41
    5336:	98 f4       	brcc	.+38     	; 0x535e <__vector_39+0x62>
    5338:	80 31       	cpi	r24, 0x10	; 16
    533a:	09 f4       	brne	.+2      	; 0x533e <__vector_39+0x42>
    533c:	57 c0       	rjmp	.+174    	; 0x53ec <__vector_39+0xf0>
    533e:	81 31       	cpi	r24, 0x11	; 17
    5340:	38 f4       	brcc	.+14     	; 0x5350 <__vector_39+0x54>
    5342:	88 23       	and	r24, r24
    5344:	09 f4       	brne	.+2      	; 0x5348 <__vector_39+0x4c>
    5346:	ea c0       	rjmp	.+468    	; 0x551c <__vector_39+0x220>
    5348:	88 30       	cpi	r24, 0x08	; 8
    534a:	09 f0       	breq	.+2      	; 0x534e <__vector_39+0x52>
    534c:	ef c0       	rjmp	.+478    	; 0x552c <__vector_39+0x230>
    534e:	4e c0       	rjmp	.+156    	; 0x53ec <__vector_39+0xf0>
    5350:	88 31       	cpi	r24, 0x18	; 24
    5352:	09 f4       	brne	.+2      	; 0x5356 <__vector_39+0x5a>
    5354:	4e c0       	rjmp	.+156    	; 0x53f2 <__vector_39+0xf6>
    5356:	80 32       	cpi	r24, 0x20	; 32
    5358:	09 f0       	breq	.+2      	; 0x535c <__vector_39+0x60>
    535a:	e8 c0       	rjmp	.+464    	; 0x552c <__vector_39+0x230>
    535c:	df c0       	rjmp	.+446    	; 0x551c <__vector_39+0x220>
    535e:	80 34       	cpi	r24, 0x40	; 64
    5360:	09 f4       	brne	.+2      	; 0x5364 <__vector_39+0x68>
    5362:	77 c0       	rjmp	.+238    	; 0x5452 <__vector_39+0x156>
    5364:	81 34       	cpi	r24, 0x41	; 65
    5366:	38 f4       	brcc	.+14     	; 0x5376 <__vector_39+0x7a>
    5368:	80 33       	cpi	r24, 0x30	; 48
    536a:	09 f4       	brne	.+2      	; 0x536e <__vector_39+0x72>
    536c:	d7 c0       	rjmp	.+430    	; 0x551c <__vector_39+0x220>
    536e:	88 33       	cpi	r24, 0x38	; 56
    5370:	09 f0       	breq	.+2      	; 0x5374 <__vector_39+0x78>
    5372:	dc c0       	rjmp	.+440    	; 0x552c <__vector_39+0x230>
    5374:	5d c0       	rjmp	.+186    	; 0x5430 <__vector_39+0x134>
    5376:	80 35       	cpi	r24, 0x50	; 80
    5378:	09 f4       	brne	.+2      	; 0x537c <__vector_39+0x80>
    537a:	5f c0       	rjmp	.+190    	; 0x543a <__vector_39+0x13e>
    537c:	88 35       	cpi	r24, 0x58	; 88
    537e:	09 f4       	brne	.+2      	; 0x5382 <__vector_39+0x86>
    5380:	4a c0       	rjmp	.+148    	; 0x5416 <__vector_39+0x11a>
    5382:	88 34       	cpi	r24, 0x48	; 72
    5384:	09 f0       	breq	.+2      	; 0x5388 <__vector_39+0x8c>
    5386:	d2 c0       	rjmp	.+420    	; 0x552c <__vector_39+0x230>
    5388:	c9 c0       	rjmp	.+402    	; 0x551c <__vector_39+0x220>
    538a:	88 39       	cpi	r24, 0x98	; 152
    538c:	09 f4       	brne	.+2      	; 0x5390 <__vector_39+0x94>
    538e:	ba c0       	rjmp	.+372    	; 0x5504 <__vector_39+0x208>
    5390:	89 39       	cpi	r24, 0x99	; 153
    5392:	b0 f4       	brcc	.+44     	; 0x53c0 <__vector_39+0xc4>
    5394:	88 37       	cpi	r24, 0x78	; 120
    5396:	09 f4       	brne	.+2      	; 0x539a <__vector_39+0x9e>
    5398:	68 c0       	rjmp	.+208    	; 0x546a <__vector_39+0x16e>
    539a:	89 37       	cpi	r24, 0x79	; 121
    539c:	38 f4       	brcc	.+14     	; 0x53ac <__vector_39+0xb0>
    539e:	88 36       	cpi	r24, 0x68	; 104
    53a0:	09 f4       	brne	.+2      	; 0x53a4 <__vector_39+0xa8>
    53a2:	63 c0       	rjmp	.+198    	; 0x546a <__vector_39+0x16e>
    53a4:	80 37       	cpi	r24, 0x70	; 112
    53a6:	09 f0       	breq	.+2      	; 0x53aa <__vector_39+0xae>
    53a8:	c1 c0       	rjmp	.+386    	; 0x552c <__vector_39+0x230>
    53aa:	5f c0       	rjmp	.+190    	; 0x546a <__vector_39+0x16e>
    53ac:	88 38       	cpi	r24, 0x88	; 136
    53ae:	09 f4       	brne	.+2      	; 0x53b2 <__vector_39+0xb6>
    53b0:	a9 c0       	rjmp	.+338    	; 0x5504 <__vector_39+0x208>
    53b2:	80 39       	cpi	r24, 0x90	; 144
    53b4:	09 f4       	brne	.+2      	; 0x53b8 <__vector_39+0xbc>
    53b6:	5f c0       	rjmp	.+190    	; 0x5476 <__vector_39+0x17a>
    53b8:	80 38       	cpi	r24, 0x80	; 128
    53ba:	09 f0       	breq	.+2      	; 0x53be <__vector_39+0xc2>
    53bc:	b7 c0       	rjmp	.+366    	; 0x552c <__vector_39+0x230>
    53be:	5b c0       	rjmp	.+182    	; 0x5476 <__vector_39+0x17a>
    53c0:	80 3b       	cpi	r24, 0xB0	; 176
    53c2:	09 f4       	brne	.+2      	; 0x53c6 <__vector_39+0xca>
    53c4:	79 c0       	rjmp	.+242    	; 0x54b8 <__vector_39+0x1bc>
    53c6:	81 3b       	cpi	r24, 0xB1	; 177
    53c8:	38 f4       	brcc	.+14     	; 0x53d8 <__vector_39+0xdc>
    53ca:	80 3a       	cpi	r24, 0xA0	; 160
    53cc:	09 f4       	brne	.+2      	; 0x53d0 <__vector_39+0xd4>
    53ce:	62 c0       	rjmp	.+196    	; 0x5494 <__vector_39+0x198>
    53d0:	88 3a       	cpi	r24, 0xA8	; 168
    53d2:	09 f0       	breq	.+2      	; 0x53d6 <__vector_39+0xda>
    53d4:	ab c0       	rjmp	.+342    	; 0x552c <__vector_39+0x230>
    53d6:	70 c0       	rjmp	.+224    	; 0x54b8 <__vector_39+0x1bc>
    53d8:	80 3c       	cpi	r24, 0xC0	; 192
    53da:	09 f4       	brne	.+2      	; 0x53de <__vector_39+0xe2>
    53dc:	9a c0       	rjmp	.+308    	; 0x5512 <__vector_39+0x216>
    53de:	88 3c       	cpi	r24, 0xC8	; 200
    53e0:	09 f4       	brne	.+2      	; 0x53e4 <__vector_39+0xe8>
    53e2:	97 c0       	rjmp	.+302    	; 0x5512 <__vector_39+0x216>
    53e4:	88 3b       	cpi	r24, 0xB8	; 184
    53e6:	09 f0       	breq	.+2      	; 0x53ea <__vector_39+0xee>
    53e8:	a1 c0       	rjmp	.+322    	; 0x552c <__vector_39+0x230>
    53ea:	77 c0       	rjmp	.+238    	; 0x54da <__vector_39+0x1de>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: M->START\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// send device address
		i2cSendByte(I2cDeviceAddrRW);
    53ec:	80 91 f4 11 	lds	r24, 0x11F4
    53f0:	0f c0       	rjmp	.+30     	; 0x5410 <__vector_39+0x114>
		#ifdef I2C_DEBUG
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MT->SLA_ACK or DATA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		if(I2cSendDataIndex < I2cSendDataLength)
    53f2:	90 91 15 12 	lds	r25, 0x1215
    53f6:	80 91 16 12 	lds	r24, 0x1216
    53fa:	98 17       	cp	r25, r24
    53fc:	08 f0       	brcs	.+2      	; 0x5400 <__vector_39+0x104>
    53fe:	8e c0       	rjmp	.+284    	; 0x551c <__vector_39+0x220>
		{
			// send data
			i2cSendByte( I2cSendData[I2cSendDataIndex++] );
    5400:	e9 2f       	mov	r30, r25
    5402:	f0 e0       	ldi	r31, 0x00	; 0
    5404:	eb 50       	subi	r30, 0x0B	; 11
    5406:	fe 4e       	sbci	r31, 0xEE	; 238
    5408:	80 81       	ld	r24, Z
    540a:	9f 5f       	subi	r25, 0xFF	; 255
    540c:	90 93 15 12 	sts	0x1215, r25
}

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    5410:	80 93 bb 00 	sts	0x00BB, r24
    5414:	77 c0       	rjmp	.+238    	; 0x5504 <__vector_39+0x208>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MR->DATA_NACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// store final received data byte
		I2cReceiveData[I2cReceiveDataIndex++] = inb(TWDR);
    5416:	80 91 37 12 	lds	r24, 0x1237
    541a:	90 91 bb 00 	lds	r25, 0x00BB
    541e:	e8 2f       	mov	r30, r24
    5420:	f0 e0       	ldi	r31, 0x00	; 0
    5422:	e9 5e       	subi	r30, 0xE9	; 233
    5424:	fd 4e       	sbci	r31, 0xED	; 237
    5426:	90 83       	st	Z, r25
    5428:	8f 5f       	subi	r24, 0xFF	; 255
    542a:	80 93 37 12 	sts	0x1237, r24
    542e:	76 c0       	rjmp	.+236    	; 0x551c <__vector_39+0x220>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MT->ARB_LOST\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// release bus
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    5430:	80 91 bc 00 	lds	r24, 0x00BC
    5434:	8f 70       	andi	r24, 0x0F	; 15
    5436:	80 68       	ori	r24, 0x80	; 128
    5438:	75 c0       	rjmp	.+234    	; 0x5524 <__vector_39+0x228>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MR->DATA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// store received data byte
		I2cReceiveData[I2cReceiveDataIndex++] = inb(TWDR);
    543a:	80 91 37 12 	lds	r24, 0x1237
    543e:	90 91 bb 00 	lds	r25, 0x00BB
    5442:	e8 2f       	mov	r30, r24
    5444:	f0 e0       	ldi	r31, 0x00	; 0
    5446:	e9 5e       	subi	r30, 0xE9	; 233
    5448:	fd 4e       	sbci	r31, 0xED	; 237
    544a:	90 83       	st	Z, r25
    544c:	8f 5f       	subi	r24, 0xFF	; 255
    544e:	80 93 37 12 	sts	0x1237, r24
		#ifdef I2C_DEBUG
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MR->SLA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		if(I2cReceiveDataIndex < (I2cReceiveDataLength-1))
    5452:	20 91 37 12 	lds	r18, 0x1237
    5456:	30 e0       	ldi	r19, 0x00	; 0
    5458:	80 91 38 12 	lds	r24, 0x1238
    545c:	90 e0       	ldi	r25, 0x00	; 0
    545e:	01 97       	sbiw	r24, 0x01	; 1
    5460:	28 17       	cp	r18, r24
    5462:	39 07       	cpc	r19, r25
    5464:	0c f0       	brlt	.+2      	; 0x5468 <__vector_39+0x16c>
    5466:	4e c0       	rjmp	.+156    	; 0x5504 <__vector_39+0x208>
    5468:	48 c0       	rjmp	.+144    	; 0x54fa <__vector_39+0x1fe>
		rprintf("I2C: SR->SLA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// we are being addressed as slave for writing (data will be received from master)
		// set state
		I2cState = I2C_SLAVE_RX;
    546a:	85 e0       	ldi	r24, 0x05	; 5
    546c:	80 93 f3 11 	sts	0x11F3, r24
		// prepare buffer
		I2cReceiveDataIndex = 0;
    5470:	10 92 37 12 	sts	0x1237, r1
    5474:	42 c0       	rjmp	.+132    	; 0x54fa <__vector_39+0x1fe>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: SR->DATA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// get previously received data byte
		I2cReceiveData[I2cReceiveDataIndex++] = inb(TWDR);
    5476:	80 91 37 12 	lds	r24, 0x1237
    547a:	90 91 bb 00 	lds	r25, 0x00BB
    547e:	e8 2f       	mov	r30, r24
    5480:	f0 e0       	ldi	r31, 0x00	; 0
    5482:	e9 5e       	subi	r30, 0xE9	; 233
    5484:	fd 4e       	sbci	r31, 0xED	; 237
    5486:	90 83       	st	Z, r25
    5488:	8f 5f       	subi	r24, 0xFF	; 255
    548a:	80 93 37 12 	sts	0x1237, r24
		// check receive buffer status
		if(I2cReceiveDataIndex < I2C_RECEIVE_DATA_BUFFER_SIZE)
    548e:	80 32       	cpi	r24, 0x20	; 32
    5490:	c8 f5       	brcc	.+114    	; 0x5504 <__vector_39+0x208>
    5492:	33 c0       	rjmp	.+102    	; 0x54fa <__vector_39+0x1fe>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: SR->SR_STOP\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// switch to SR mode with SLA ACK
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    5494:	80 91 bc 00 	lds	r24, 0x00BC
    5498:	8f 70       	andi	r24, 0x0F	; 15
    549a:	80 6c       	ori	r24, 0xC0	; 192
    549c:	80 93 bc 00 	sts	0x00BC, r24
		// i2c receive is complete, call i2cSlaveReceive
		if(i2cSlaveReceive) i2cSlaveReceive(I2cReceiveDataIndex, I2cReceiveData);
    54a0:	e0 91 39 12 	lds	r30, 0x1239
    54a4:	f0 91 3a 12 	lds	r31, 0x123A
    54a8:	30 97       	sbiw	r30, 0x00	; 0
    54aa:	f1 f1       	breq	.+124    	; 0x5528 <__vector_39+0x22c>
    54ac:	80 91 37 12 	lds	r24, 0x1237
    54b0:	67 e1       	ldi	r22, 0x17	; 23
    54b2:	72 e1       	ldi	r23, 0x12	; 18
    54b4:	09 95       	icall
    54b6:	38 c0       	rjmp	.+112    	; 0x5528 <__vector_39+0x22c>
		rprintf("I2C: ST->SLA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// we are being addressed as slave for reading (data must be transmitted back to master)
		// set state
		I2cState = I2C_SLAVE_TX;
    54b8:	84 e0       	ldi	r24, 0x04	; 4
    54ba:	80 93 f3 11 	sts	0x11F3, r24
		// request data from application
		if(i2cSlaveTransmit) I2cSendDataLength = i2cSlaveTransmit(I2C_SEND_DATA_BUFFER_SIZE, I2cSendData);
    54be:	e0 91 3b 12 	lds	r30, 0x123B
    54c2:	f0 91 3c 12 	lds	r31, 0x123C
    54c6:	30 97       	sbiw	r30, 0x00	; 0
    54c8:	31 f0       	breq	.+12     	; 0x54d6 <__vector_39+0x1da>
    54ca:	80 e2       	ldi	r24, 0x20	; 32
    54cc:	65 ef       	ldi	r22, 0xF5	; 245
    54ce:	71 e1       	ldi	r23, 0x11	; 17
    54d0:	09 95       	icall
    54d2:	80 93 16 12 	sts	0x1216, r24
		// reset data index
		I2cSendDataIndex = 0;
    54d6:	10 92 15 12 	sts	0x1215, r1
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: ST->DATA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// transmit data byte
		outb(TWDR, I2cSendData[I2cSendDataIndex++]);
    54da:	90 91 15 12 	lds	r25, 0x1215
    54de:	e9 2f       	mov	r30, r25
    54e0:	f0 e0       	ldi	r31, 0x00	; 0
    54e2:	eb 50       	subi	r30, 0x0B	; 11
    54e4:	fe 4e       	sbci	r31, 0xEE	; 238
    54e6:	80 81       	ld	r24, Z
    54e8:	80 93 bb 00 	sts	0x00BB, r24
    54ec:	9f 5f       	subi	r25, 0xFF	; 255
    54ee:	90 93 15 12 	sts	0x1215, r25
		if(I2cSendDataIndex < I2cSendDataLength)
    54f2:	80 91 16 12 	lds	r24, 0x1216
    54f6:	98 17       	cp	r25, r24
    54f8:	28 f4       	brcc	.+10     	; 0x5504 <__vector_39+0x208>
			// expect ACK to data byte
			outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    54fa:	80 91 bc 00 	lds	r24, 0x00BC
    54fe:	8f 70       	andi	r24, 0x0F	; 15
    5500:	80 6c       	ori	r24, 0xC0	; 192
    5502:	04 c0       	rjmp	.+8      	; 0x550c <__vector_39+0x210>
		else
			// expect NACK to data byte
			outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    5504:	80 91 bc 00 	lds	r24, 0x00BC
    5508:	8f 70       	andi	r24, 0x0F	; 15
    550a:	80 68       	ori	r24, 0x80	; 128
    550c:	80 93 bc 00 	sts	0x00BC, r24
    5510:	0d c0       	rjmp	.+26     	; 0x552c <__vector_39+0x230>
		rprintf("I2C: ST->DATA_NACK or LAST_DATA\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// all done
		// switch to open slave
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    5512:	80 91 bc 00 	lds	r24, 0x00BC
    5516:	8f 70       	andi	r24, 0x0F	; 15
    5518:	80 6c       	ori	r24, 0xC0	; 192
    551a:	04 c0       	rjmp	.+8      	; 0x5524 <__vector_39+0x228>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: BUS_ERROR\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// reset internal hardware and release bus
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTO)|BV(TWEA));
    551c:	80 91 bc 00 	lds	r24, 0x00BC
    5520:	8f 70       	andi	r24, 0x0F	; 15
    5522:	80 6d       	ori	r24, 0xD0	; 208
    5524:	80 93 bc 00 	sts	0x00BC, r24
		// set state
		I2cState = I2C_IDLE;
    5528:	10 92 f3 11 	sts	0x11F3, r1
		break;
	}
}
    552c:	ff 91       	pop	r31
    552e:	ef 91       	pop	r30
    5530:	bf 91       	pop	r27
    5532:	af 91       	pop	r26
    5534:	9f 91       	pop	r25
    5536:	8f 91       	pop	r24
    5538:	7f 91       	pop	r23
    553a:	6f 91       	pop	r22
    553c:	5f 91       	pop	r21
    553e:	4f 91       	pop	r20
    5540:	3f 91       	pop	r19
    5542:	2f 91       	pop	r18
    5544:	0f 90       	pop	r0
    5546:	0f be       	out	0x3f, r0	; 63
    5548:	0f 90       	pop	r0
    554a:	1f 90       	pop	r1
    554c:	18 95       	reti

0000554e <i2cGetState>:

eI2cStateType i2cGetState(void)
{
	return I2cState;
    554e:	80 91 f3 11 	lds	r24, 0x11F3
}
    5552:	08 95       	ret

00005554 <exit>:
    5554:	f8 94       	cli
    5556:	0c 94 50 2e 	jmp	0x5ca0	; 0x5ca0 <_exit>

0000555a <memcpy>:
    555a:	fb 01       	movw	r30, r22
    555c:	dc 01       	movw	r26, r24
    555e:	02 c0       	rjmp	.+4      	; 0x5564 <memcpy+0xa>
    5560:	01 90       	ld	r0, Z+
    5562:	0d 92       	st	X+, r0
    5564:	41 50       	subi	r20, 0x01	; 1
    5566:	50 40       	sbci	r21, 0x00	; 0
    5568:	d8 f7       	brcc	.-10     	; 0x5560 <memcpy+0x6>
    556a:	08 95       	ret

0000556c <memset>:
    556c:	dc 01       	movw	r26, r24
    556e:	01 c0       	rjmp	.+2      	; 0x5572 <memset+0x6>
    5570:	6d 93       	st	X+, r22
    5572:	41 50       	subi	r20, 0x01	; 1
    5574:	50 40       	sbci	r21, 0x00	; 0
    5576:	e0 f7       	brcc	.-8      	; 0x5570 <memset+0x4>
    5578:	08 95       	ret

0000557a <strncpy>:
    557a:	fb 01       	movw	r30, r22
    557c:	dc 01       	movw	r26, r24
    557e:	41 50       	subi	r20, 0x01	; 1
    5580:	50 40       	sbci	r21, 0x00	; 0
    5582:	48 f0       	brcs	.+18     	; 0x5596 <strncpy+0x1c>
    5584:	01 90       	ld	r0, Z+
    5586:	0d 92       	st	X+, r0
    5588:	00 20       	and	r0, r0
    558a:	c9 f7       	brne	.-14     	; 0x557e <strncpy+0x4>
    558c:	01 c0       	rjmp	.+2      	; 0x5590 <strncpy+0x16>
    558e:	1d 92       	st	X+, r1
    5590:	41 50       	subi	r20, 0x01	; 1
    5592:	50 40       	sbci	r21, 0x00	; 0
    5594:	e0 f7       	brcc	.-8      	; 0x558e <strncpy+0x14>
    5596:	08 95       	ret

00005598 <__subsf3>:
    5598:	50 58       	subi	r21, 0x80	; 128

0000559a <__addsf3>:
    559a:	bb 27       	eor	r27, r27
    559c:	aa 27       	eor	r26, r26
    559e:	0e d0       	rcall	.+28     	; 0x55bc <__addsf3x>
    55a0:	3a c2       	rjmp	.+1140   	; 0x5a16 <__fp_round>
    55a2:	2b d2       	rcall	.+1110   	; 0x59fa <__fp_pscA>
    55a4:	30 f0       	brcs	.+12     	; 0x55b2 <__addsf3+0x18>
    55a6:	30 d2       	rcall	.+1120   	; 0x5a08 <__fp_pscB>
    55a8:	20 f0       	brcs	.+8      	; 0x55b2 <__addsf3+0x18>
    55aa:	31 f4       	brne	.+12     	; 0x55b8 <__addsf3+0x1e>
    55ac:	9f 3f       	cpi	r25, 0xFF	; 255
    55ae:	11 f4       	brne	.+4      	; 0x55b4 <__addsf3+0x1a>
    55b0:	1e f4       	brtc	.+6      	; 0x55b8 <__addsf3+0x1e>
    55b2:	fb c1       	rjmp	.+1014   	; 0x59aa <__fp_nan>
    55b4:	0e f4       	brtc	.+2      	; 0x55b8 <__addsf3+0x1e>
    55b6:	e0 95       	com	r30
    55b8:	e7 fb       	bst	r30, 7
    55ba:	c6 c1       	rjmp	.+908    	; 0x5948 <__fp_inf>

000055bc <__addsf3x>:
    55bc:	e9 2f       	mov	r30, r25
    55be:	3c d2       	rcall	.+1144   	; 0x5a38 <__fp_split3>
    55c0:	80 f3       	brcs	.-32     	; 0x55a2 <__addsf3+0x8>
    55c2:	ba 17       	cp	r27, r26
    55c4:	62 07       	cpc	r22, r18
    55c6:	73 07       	cpc	r23, r19
    55c8:	84 07       	cpc	r24, r20
    55ca:	95 07       	cpc	r25, r21
    55cc:	18 f0       	brcs	.+6      	; 0x55d4 <__addsf3x+0x18>
    55ce:	71 f4       	brne	.+28     	; 0x55ec <__addsf3x+0x30>
    55d0:	9e f5       	brtc	.+102    	; 0x5638 <__addsf3x+0x7c>
    55d2:	6b c2       	rjmp	.+1238   	; 0x5aaa <__fp_zero>
    55d4:	0e f4       	brtc	.+2      	; 0x55d8 <__addsf3x+0x1c>
    55d6:	e0 95       	com	r30
    55d8:	0b 2e       	mov	r0, r27
    55da:	ba 2f       	mov	r27, r26
    55dc:	a0 2d       	mov	r26, r0
    55de:	0b 01       	movw	r0, r22
    55e0:	b9 01       	movw	r22, r18
    55e2:	90 01       	movw	r18, r0
    55e4:	0c 01       	movw	r0, r24
    55e6:	ca 01       	movw	r24, r20
    55e8:	a0 01       	movw	r20, r0
    55ea:	11 24       	eor	r1, r1
    55ec:	ff 27       	eor	r31, r31
    55ee:	59 1b       	sub	r21, r25
    55f0:	99 f0       	breq	.+38     	; 0x5618 <__addsf3x+0x5c>
    55f2:	59 3f       	cpi	r21, 0xF9	; 249
    55f4:	50 f4       	brcc	.+20     	; 0x560a <__addsf3x+0x4e>
    55f6:	50 3e       	cpi	r21, 0xE0	; 224
    55f8:	68 f1       	brcs	.+90     	; 0x5654 <__addsf3x+0x98>
    55fa:	1a 16       	cp	r1, r26
    55fc:	f0 40       	sbci	r31, 0x00	; 0
    55fe:	a2 2f       	mov	r26, r18
    5600:	23 2f       	mov	r18, r19
    5602:	34 2f       	mov	r19, r20
    5604:	44 27       	eor	r20, r20
    5606:	58 5f       	subi	r21, 0xF8	; 248
    5608:	f3 cf       	rjmp	.-26     	; 0x55f0 <__addsf3x+0x34>
    560a:	46 95       	lsr	r20
    560c:	37 95       	ror	r19
    560e:	27 95       	ror	r18
    5610:	a7 95       	ror	r26
    5612:	f0 40       	sbci	r31, 0x00	; 0
    5614:	53 95       	inc	r21
    5616:	c9 f7       	brne	.-14     	; 0x560a <__addsf3x+0x4e>
    5618:	7e f4       	brtc	.+30     	; 0x5638 <__addsf3x+0x7c>
    561a:	1f 16       	cp	r1, r31
    561c:	ba 0b       	sbc	r27, r26
    561e:	62 0b       	sbc	r22, r18
    5620:	73 0b       	sbc	r23, r19
    5622:	84 0b       	sbc	r24, r20
    5624:	ba f0       	brmi	.+46     	; 0x5654 <__addsf3x+0x98>
    5626:	91 50       	subi	r25, 0x01	; 1
    5628:	a1 f0       	breq	.+40     	; 0x5652 <__addsf3x+0x96>
    562a:	ff 0f       	add	r31, r31
    562c:	bb 1f       	adc	r27, r27
    562e:	66 1f       	adc	r22, r22
    5630:	77 1f       	adc	r23, r23
    5632:	88 1f       	adc	r24, r24
    5634:	c2 f7       	brpl	.-16     	; 0x5626 <__addsf3x+0x6a>
    5636:	0e c0       	rjmp	.+28     	; 0x5654 <__addsf3x+0x98>
    5638:	ba 0f       	add	r27, r26
    563a:	62 1f       	adc	r22, r18
    563c:	73 1f       	adc	r23, r19
    563e:	84 1f       	adc	r24, r20
    5640:	48 f4       	brcc	.+18     	; 0x5654 <__addsf3x+0x98>
    5642:	87 95       	ror	r24
    5644:	77 95       	ror	r23
    5646:	67 95       	ror	r22
    5648:	b7 95       	ror	r27
    564a:	f7 95       	ror	r31
    564c:	9e 3f       	cpi	r25, 0xFE	; 254
    564e:	08 f0       	brcs	.+2      	; 0x5652 <__addsf3x+0x96>
    5650:	b3 cf       	rjmp	.-154    	; 0x55b8 <__addsf3+0x1e>
    5652:	93 95       	inc	r25
    5654:	88 0f       	add	r24, r24
    5656:	08 f0       	brcs	.+2      	; 0x565a <__addsf3x+0x9e>
    5658:	99 27       	eor	r25, r25
    565a:	ee 0f       	add	r30, r30
    565c:	97 95       	ror	r25
    565e:	87 95       	ror	r24
    5660:	08 95       	ret
    5662:	cb d1       	rcall	.+918    	; 0x59fa <__fp_pscA>
    5664:	58 f0       	brcs	.+22     	; 0x567c <__addsf3x+0xc0>
    5666:	80 e8       	ldi	r24, 0x80	; 128
    5668:	91 e0       	ldi	r25, 0x01	; 1
    566a:	09 f4       	brne	.+2      	; 0x566e <__addsf3x+0xb2>
    566c:	9e ef       	ldi	r25, 0xFE	; 254
    566e:	cc d1       	rcall	.+920    	; 0x5a08 <__fp_pscB>
    5670:	28 f0       	brcs	.+10     	; 0x567c <__addsf3x+0xc0>
    5672:	40 e8       	ldi	r20, 0x80	; 128
    5674:	51 e0       	ldi	r21, 0x01	; 1
    5676:	59 f4       	brne	.+22     	; 0x568e <atan2+0xe>
    5678:	5e ef       	ldi	r21, 0xFE	; 254
    567a:	09 c0       	rjmp	.+18     	; 0x568e <atan2+0xe>
    567c:	96 c1       	rjmp	.+812    	; 0x59aa <__fp_nan>
    567e:	15 c2       	rjmp	.+1066   	; 0x5aaa <__fp_zero>

00005680 <atan2>:
    5680:	e9 2f       	mov	r30, r25
    5682:	e0 78       	andi	r30, 0x80	; 128
    5684:	d9 d1       	rcall	.+946    	; 0x5a38 <__fp_split3>
    5686:	68 f3       	brcs	.-38     	; 0x5662 <__addsf3x+0xa6>
    5688:	09 2e       	mov	r0, r25
    568a:	05 2a       	or	r0, r21
    568c:	c1 f3       	breq	.-16     	; 0x567e <__addsf3x+0xc2>
    568e:	26 17       	cp	r18, r22
    5690:	37 07       	cpc	r19, r23
    5692:	48 07       	cpc	r20, r24
    5694:	59 07       	cpc	r21, r25
    5696:	38 f0       	brcs	.+14     	; 0x56a6 <atan2+0x26>
    5698:	0e 2e       	mov	r0, r30
    569a:	07 f8       	bld	r0, 7
    569c:	e0 25       	eor	r30, r0
    569e:	69 f0       	breq	.+26     	; 0x56ba <atan2+0x3a>
    56a0:	e0 25       	eor	r30, r0
    56a2:	e0 64       	ori	r30, 0x40	; 64
    56a4:	0a c0       	rjmp	.+20     	; 0x56ba <atan2+0x3a>
    56a6:	ef 63       	ori	r30, 0x3F	; 63
    56a8:	07 f8       	bld	r0, 7
    56aa:	00 94       	com	r0
    56ac:	07 fa       	bst	r0, 7
    56ae:	db 01       	movw	r26, r22
    56b0:	b9 01       	movw	r22, r18
    56b2:	9d 01       	movw	r18, r26
    56b4:	dc 01       	movw	r26, r24
    56b6:	ca 01       	movw	r24, r20
    56b8:	ad 01       	movw	r20, r26
    56ba:	ef 93       	push	r30
    56bc:	47 d0       	rcall	.+142    	; 0x574c <__divsf3_pse>
    56be:	ab d1       	rcall	.+854    	; 0x5a16 <__fp_round>
    56c0:	0a d0       	rcall	.+20     	; 0x56d6 <atan>
    56c2:	5f 91       	pop	r21
    56c4:	55 23       	and	r21, r21
    56c6:	31 f0       	breq	.+12     	; 0x56d4 <atan2+0x54>
    56c8:	2b ed       	ldi	r18, 0xDB	; 219
    56ca:	3f e0       	ldi	r19, 0x0F	; 15
    56cc:	49 e4       	ldi	r20, 0x49	; 73
    56ce:	50 fd       	sbrc	r21, 0
    56d0:	49 ec       	ldi	r20, 0xC9	; 201
    56d2:	63 cf       	rjmp	.-314    	; 0x559a <__addsf3>
    56d4:	08 95       	ret

000056d6 <atan>:
    56d6:	df 93       	push	r29
    56d8:	dd 27       	eor	r29, r29
    56da:	b9 2f       	mov	r27, r25
    56dc:	bf 77       	andi	r27, 0x7F	; 127
    56de:	40 e8       	ldi	r20, 0x80	; 128
    56e0:	5f e3       	ldi	r21, 0x3F	; 63
    56e2:	16 16       	cp	r1, r22
    56e4:	17 06       	cpc	r1, r23
    56e6:	48 07       	cpc	r20, r24
    56e8:	5b 07       	cpc	r21, r27
    56ea:	10 f4       	brcc	.+4      	; 0x56f0 <atan+0x1a>
    56ec:	d9 2f       	mov	r29, r25
    56ee:	e8 d1       	rcall	.+976    	; 0x5ac0 <inverse>
    56f0:	9f 93       	push	r25
    56f2:	8f 93       	push	r24
    56f4:	7f 93       	push	r23
    56f6:	6f 93       	push	r22
    56f8:	4d d2       	rcall	.+1178   	; 0x5b94 <square>
    56fa:	e4 ee       	ldi	r30, 0xE4	; 228
    56fc:	f0 e0       	ldi	r31, 0x00	; 0
    56fe:	58 d1       	rcall	.+688    	; 0x59b0 <__fp_powser>
    5700:	8a d1       	rcall	.+788    	; 0x5a16 <__fp_round>
    5702:	2f 91       	pop	r18
    5704:	3f 91       	pop	r19
    5706:	4f 91       	pop	r20
    5708:	5f 91       	pop	r21
    570a:	ed d1       	rcall	.+986    	; 0x5ae6 <__mulsf3x>
    570c:	dd 23       	and	r29, r29
    570e:	49 f0       	breq	.+18     	; 0x5722 <atan+0x4c>
    5710:	90 58       	subi	r25, 0x80	; 128
    5712:	a2 ea       	ldi	r26, 0xA2	; 162
    5714:	2a ed       	ldi	r18, 0xDA	; 218
    5716:	3f e0       	ldi	r19, 0x0F	; 15
    5718:	49 ec       	ldi	r20, 0xC9	; 201
    571a:	5f e3       	ldi	r21, 0x3F	; 63
    571c:	d0 78       	andi	r29, 0x80	; 128
    571e:	5d 27       	eor	r21, r29
    5720:	4d df       	rcall	.-358    	; 0x55bc <__addsf3x>
    5722:	df 91       	pop	r29
    5724:	78 c1       	rjmp	.+752    	; 0x5a16 <__fp_round>

00005726 <__cmpsf2>:
    5726:	ec d0       	rcall	.+472    	; 0x5900 <__fp_cmp>
    5728:	08 f4       	brcc	.+2      	; 0x572c <__cmpsf2+0x6>
    572a:	81 e0       	ldi	r24, 0x01	; 1
    572c:	08 95       	ret

0000572e <__divsf3>:
    572e:	0c d0       	rcall	.+24     	; 0x5748 <__divsf3x>
    5730:	72 c1       	rjmp	.+740    	; 0x5a16 <__fp_round>
    5732:	6a d1       	rcall	.+724    	; 0x5a08 <__fp_pscB>
    5734:	40 f0       	brcs	.+16     	; 0x5746 <__divsf3+0x18>
    5736:	61 d1       	rcall	.+706    	; 0x59fa <__fp_pscA>
    5738:	30 f0       	brcs	.+12     	; 0x5746 <__divsf3+0x18>
    573a:	21 f4       	brne	.+8      	; 0x5744 <__divsf3+0x16>
    573c:	5f 3f       	cpi	r21, 0xFF	; 255
    573e:	19 f0       	breq	.+6      	; 0x5746 <__divsf3+0x18>
    5740:	03 c1       	rjmp	.+518    	; 0x5948 <__fp_inf>
    5742:	51 11       	cpse	r21, r1
    5744:	b3 c1       	rjmp	.+870    	; 0x5aac <__fp_szero>
    5746:	31 c1       	rjmp	.+610    	; 0x59aa <__fp_nan>

00005748 <__divsf3x>:
    5748:	77 d1       	rcall	.+750    	; 0x5a38 <__fp_split3>
    574a:	98 f3       	brcs	.-26     	; 0x5732 <__divsf3+0x4>

0000574c <__divsf3_pse>:
    574c:	99 23       	and	r25, r25
    574e:	c9 f3       	breq	.-14     	; 0x5742 <__divsf3+0x14>
    5750:	55 23       	and	r21, r21
    5752:	b1 f3       	breq	.-20     	; 0x5740 <__divsf3+0x12>
    5754:	95 1b       	sub	r25, r21
    5756:	55 0b       	sbc	r21, r21
    5758:	bb 27       	eor	r27, r27
    575a:	aa 27       	eor	r26, r26
    575c:	62 17       	cp	r22, r18
    575e:	73 07       	cpc	r23, r19
    5760:	84 07       	cpc	r24, r20
    5762:	38 f0       	brcs	.+14     	; 0x5772 <__divsf3_pse+0x26>
    5764:	9f 5f       	subi	r25, 0xFF	; 255
    5766:	5f 4f       	sbci	r21, 0xFF	; 255
    5768:	22 0f       	add	r18, r18
    576a:	33 1f       	adc	r19, r19
    576c:	44 1f       	adc	r20, r20
    576e:	aa 1f       	adc	r26, r26
    5770:	a9 f3       	breq	.-22     	; 0x575c <__divsf3_pse+0x10>
    5772:	33 d0       	rcall	.+102    	; 0x57da <__divsf3_pse+0x8e>
    5774:	0e 2e       	mov	r0, r30
    5776:	3a f0       	brmi	.+14     	; 0x5786 <__divsf3_pse+0x3a>
    5778:	e0 e8       	ldi	r30, 0x80	; 128
    577a:	30 d0       	rcall	.+96     	; 0x57dc <__divsf3_pse+0x90>
    577c:	91 50       	subi	r25, 0x01	; 1
    577e:	50 40       	sbci	r21, 0x00	; 0
    5780:	e6 95       	lsr	r30
    5782:	00 1c       	adc	r0, r0
    5784:	ca f7       	brpl	.-14     	; 0x5778 <__divsf3_pse+0x2c>
    5786:	29 d0       	rcall	.+82     	; 0x57da <__divsf3_pse+0x8e>
    5788:	fe 2f       	mov	r31, r30
    578a:	27 d0       	rcall	.+78     	; 0x57da <__divsf3_pse+0x8e>
    578c:	66 0f       	add	r22, r22
    578e:	77 1f       	adc	r23, r23
    5790:	88 1f       	adc	r24, r24
    5792:	bb 1f       	adc	r27, r27
    5794:	26 17       	cp	r18, r22
    5796:	37 07       	cpc	r19, r23
    5798:	48 07       	cpc	r20, r24
    579a:	ab 07       	cpc	r26, r27
    579c:	b0 e8       	ldi	r27, 0x80	; 128
    579e:	09 f0       	breq	.+2      	; 0x57a2 <__divsf3_pse+0x56>
    57a0:	bb 0b       	sbc	r27, r27
    57a2:	80 2d       	mov	r24, r0
    57a4:	bf 01       	movw	r22, r30
    57a6:	ff 27       	eor	r31, r31
    57a8:	93 58       	subi	r25, 0x83	; 131
    57aa:	5f 4f       	sbci	r21, 0xFF	; 255
    57ac:	2a f0       	brmi	.+10     	; 0x57b8 <__divsf3_pse+0x6c>
    57ae:	9e 3f       	cpi	r25, 0xFE	; 254
    57b0:	51 05       	cpc	r21, r1
    57b2:	68 f0       	brcs	.+26     	; 0x57ce <__divsf3_pse+0x82>
    57b4:	c9 c0       	rjmp	.+402    	; 0x5948 <__fp_inf>
    57b6:	7a c1       	rjmp	.+756    	; 0x5aac <__fp_szero>
    57b8:	5f 3f       	cpi	r21, 0xFF	; 255
    57ba:	ec f3       	brlt	.-6      	; 0x57b6 <__divsf3_pse+0x6a>
    57bc:	98 3e       	cpi	r25, 0xE8	; 232
    57be:	dc f3       	brlt	.-10     	; 0x57b6 <__divsf3_pse+0x6a>
    57c0:	86 95       	lsr	r24
    57c2:	77 95       	ror	r23
    57c4:	67 95       	ror	r22
    57c6:	b7 95       	ror	r27
    57c8:	f7 95       	ror	r31
    57ca:	9f 5f       	subi	r25, 0xFF	; 255
    57cc:	c9 f7       	brne	.-14     	; 0x57c0 <__divsf3_pse+0x74>
    57ce:	88 0f       	add	r24, r24
    57d0:	91 1d       	adc	r25, r1
    57d2:	96 95       	lsr	r25
    57d4:	87 95       	ror	r24
    57d6:	97 f9       	bld	r25, 7
    57d8:	08 95       	ret
    57da:	e1 e0       	ldi	r30, 0x01	; 1
    57dc:	66 0f       	add	r22, r22
    57de:	77 1f       	adc	r23, r23
    57e0:	88 1f       	adc	r24, r24
    57e2:	bb 1f       	adc	r27, r27
    57e4:	62 17       	cp	r22, r18
    57e6:	73 07       	cpc	r23, r19
    57e8:	84 07       	cpc	r24, r20
    57ea:	ba 07       	cpc	r27, r26
    57ec:	20 f0       	brcs	.+8      	; 0x57f6 <__divsf3_pse+0xaa>
    57ee:	62 1b       	sub	r22, r18
    57f0:	73 0b       	sbc	r23, r19
    57f2:	84 0b       	sbc	r24, r20
    57f4:	ba 0b       	sbc	r27, r26
    57f6:	ee 1f       	adc	r30, r30
    57f8:	88 f7       	brcc	.-30     	; 0x57dc <__divsf3_pse+0x90>
    57fa:	e0 95       	com	r30
    57fc:	08 95       	ret

000057fe <__fixsfsi>:
    57fe:	04 d0       	rcall	.+8      	; 0x5808 <__fixunssfsi>
    5800:	68 94       	set
    5802:	b1 11       	cpse	r27, r1
    5804:	53 c1       	rjmp	.+678    	; 0x5aac <__fp_szero>
    5806:	08 95       	ret

00005808 <__fixunssfsi>:
    5808:	1f d1       	rcall	.+574    	; 0x5a48 <__fp_splitA>
    580a:	88 f0       	brcs	.+34     	; 0x582e <__fixunssfsi+0x26>
    580c:	9f 57       	subi	r25, 0x7F	; 127
    580e:	90 f0       	brcs	.+36     	; 0x5834 <__fixunssfsi+0x2c>
    5810:	b9 2f       	mov	r27, r25
    5812:	99 27       	eor	r25, r25
    5814:	b7 51       	subi	r27, 0x17	; 23
    5816:	a0 f0       	brcs	.+40     	; 0x5840 <__fixunssfsi+0x38>
    5818:	d1 f0       	breq	.+52     	; 0x584e <__fixunssfsi+0x46>
    581a:	66 0f       	add	r22, r22
    581c:	77 1f       	adc	r23, r23
    581e:	88 1f       	adc	r24, r24
    5820:	99 1f       	adc	r25, r25
    5822:	1a f0       	brmi	.+6      	; 0x582a <__fixunssfsi+0x22>
    5824:	ba 95       	dec	r27
    5826:	c9 f7       	brne	.-14     	; 0x581a <__fixunssfsi+0x12>
    5828:	12 c0       	rjmp	.+36     	; 0x584e <__fixunssfsi+0x46>
    582a:	b1 30       	cpi	r27, 0x01	; 1
    582c:	81 f0       	breq	.+32     	; 0x584e <__fixunssfsi+0x46>
    582e:	3d d1       	rcall	.+634    	; 0x5aaa <__fp_zero>
    5830:	b1 e0       	ldi	r27, 0x01	; 1
    5832:	08 95       	ret
    5834:	3a c1       	rjmp	.+628    	; 0x5aaa <__fp_zero>
    5836:	67 2f       	mov	r22, r23
    5838:	78 2f       	mov	r23, r24
    583a:	88 27       	eor	r24, r24
    583c:	b8 5f       	subi	r27, 0xF8	; 248
    583e:	39 f0       	breq	.+14     	; 0x584e <__fixunssfsi+0x46>
    5840:	b9 3f       	cpi	r27, 0xF9	; 249
    5842:	cc f3       	brlt	.-14     	; 0x5836 <__fixunssfsi+0x2e>
    5844:	86 95       	lsr	r24
    5846:	77 95       	ror	r23
    5848:	67 95       	ror	r22
    584a:	b3 95       	inc	r27
    584c:	d9 f7       	brne	.-10     	; 0x5844 <__fixunssfsi+0x3c>
    584e:	3e f4       	brtc	.+14     	; 0x585e <__fixunssfsi+0x56>
    5850:	90 95       	com	r25
    5852:	80 95       	com	r24
    5854:	70 95       	com	r23
    5856:	61 95       	neg	r22
    5858:	7f 4f       	sbci	r23, 0xFF	; 255
    585a:	8f 4f       	sbci	r24, 0xFF	; 255
    585c:	9f 4f       	sbci	r25, 0xFF	; 255
    585e:	08 95       	ret

00005860 <__floatunsisf>:
    5860:	e8 94       	clt
    5862:	09 c0       	rjmp	.+18     	; 0x5876 <__floatsisf+0x12>

00005864 <__floatsisf>:
    5864:	97 fb       	bst	r25, 7
    5866:	3e f4       	brtc	.+14     	; 0x5876 <__floatsisf+0x12>
    5868:	90 95       	com	r25
    586a:	80 95       	com	r24
    586c:	70 95       	com	r23
    586e:	61 95       	neg	r22
    5870:	7f 4f       	sbci	r23, 0xFF	; 255
    5872:	8f 4f       	sbci	r24, 0xFF	; 255
    5874:	9f 4f       	sbci	r25, 0xFF	; 255
    5876:	99 23       	and	r25, r25
    5878:	a9 f0       	breq	.+42     	; 0x58a4 <__floatsisf+0x40>
    587a:	f9 2f       	mov	r31, r25
    587c:	96 e9       	ldi	r25, 0x96	; 150
    587e:	bb 27       	eor	r27, r27
    5880:	93 95       	inc	r25
    5882:	f6 95       	lsr	r31
    5884:	87 95       	ror	r24
    5886:	77 95       	ror	r23
    5888:	67 95       	ror	r22
    588a:	b7 95       	ror	r27
    588c:	f1 11       	cpse	r31, r1
    588e:	f8 cf       	rjmp	.-16     	; 0x5880 <__floatsisf+0x1c>
    5890:	fa f4       	brpl	.+62     	; 0x58d0 <__floatsisf+0x6c>
    5892:	bb 0f       	add	r27, r27
    5894:	11 f4       	brne	.+4      	; 0x589a <__floatsisf+0x36>
    5896:	60 ff       	sbrs	r22, 0
    5898:	1b c0       	rjmp	.+54     	; 0x58d0 <__floatsisf+0x6c>
    589a:	6f 5f       	subi	r22, 0xFF	; 255
    589c:	7f 4f       	sbci	r23, 0xFF	; 255
    589e:	8f 4f       	sbci	r24, 0xFF	; 255
    58a0:	9f 4f       	sbci	r25, 0xFF	; 255
    58a2:	16 c0       	rjmp	.+44     	; 0x58d0 <__floatsisf+0x6c>
    58a4:	88 23       	and	r24, r24
    58a6:	11 f0       	breq	.+4      	; 0x58ac <__floatsisf+0x48>
    58a8:	96 e9       	ldi	r25, 0x96	; 150
    58aa:	11 c0       	rjmp	.+34     	; 0x58ce <__floatsisf+0x6a>
    58ac:	77 23       	and	r23, r23
    58ae:	21 f0       	breq	.+8      	; 0x58b8 <__floatsisf+0x54>
    58b0:	9e e8       	ldi	r25, 0x8E	; 142
    58b2:	87 2f       	mov	r24, r23
    58b4:	76 2f       	mov	r23, r22
    58b6:	05 c0       	rjmp	.+10     	; 0x58c2 <__floatsisf+0x5e>
    58b8:	66 23       	and	r22, r22
    58ba:	71 f0       	breq	.+28     	; 0x58d8 <__floatsisf+0x74>
    58bc:	96 e8       	ldi	r25, 0x86	; 134
    58be:	86 2f       	mov	r24, r22
    58c0:	70 e0       	ldi	r23, 0x00	; 0
    58c2:	60 e0       	ldi	r22, 0x00	; 0
    58c4:	2a f0       	brmi	.+10     	; 0x58d0 <__floatsisf+0x6c>
    58c6:	9a 95       	dec	r25
    58c8:	66 0f       	add	r22, r22
    58ca:	77 1f       	adc	r23, r23
    58cc:	88 1f       	adc	r24, r24
    58ce:	da f7       	brpl	.-10     	; 0x58c6 <__floatsisf+0x62>
    58d0:	88 0f       	add	r24, r24
    58d2:	96 95       	lsr	r25
    58d4:	87 95       	ror	r24
    58d6:	97 f9       	bld	r25, 7
    58d8:	08 95       	ret

000058da <floor>:
    58da:	d0 d0       	rcall	.+416    	; 0x5a7c <__fp_trunc>
    58dc:	80 f0       	brcs	.+32     	; 0x58fe <floor+0x24>
    58de:	9f 37       	cpi	r25, 0x7F	; 127
    58e0:	40 f4       	brcc	.+16     	; 0x58f2 <floor+0x18>
    58e2:	91 11       	cpse	r25, r1
    58e4:	0e f0       	brts	.+2      	; 0x58e8 <floor+0xe>
    58e6:	e2 c0       	rjmp	.+452    	; 0x5aac <__fp_szero>
    58e8:	60 e0       	ldi	r22, 0x00	; 0
    58ea:	70 e0       	ldi	r23, 0x00	; 0
    58ec:	80 e8       	ldi	r24, 0x80	; 128
    58ee:	9f eb       	ldi	r25, 0xBF	; 191
    58f0:	08 95       	ret
    58f2:	26 f4       	brtc	.+8      	; 0x58fc <floor+0x22>
    58f4:	1b 16       	cp	r1, r27
    58f6:	61 1d       	adc	r22, r1
    58f8:	71 1d       	adc	r23, r1
    58fa:	81 1d       	adc	r24, r1
    58fc:	2b c0       	rjmp	.+86     	; 0x5954 <__fp_mintl>
    58fe:	45 c0       	rjmp	.+138    	; 0x598a <__fp_mpack>

00005900 <__fp_cmp>:
    5900:	99 0f       	add	r25, r25
    5902:	00 08       	sbc	r0, r0
    5904:	55 0f       	add	r21, r21
    5906:	aa 0b       	sbc	r26, r26
    5908:	e0 e8       	ldi	r30, 0x80	; 128
    590a:	fe ef       	ldi	r31, 0xFE	; 254
    590c:	16 16       	cp	r1, r22
    590e:	17 06       	cpc	r1, r23
    5910:	e8 07       	cpc	r30, r24
    5912:	f9 07       	cpc	r31, r25
    5914:	c0 f0       	brcs	.+48     	; 0x5946 <__fp_cmp+0x46>
    5916:	12 16       	cp	r1, r18
    5918:	13 06       	cpc	r1, r19
    591a:	e4 07       	cpc	r30, r20
    591c:	f5 07       	cpc	r31, r21
    591e:	98 f0       	brcs	.+38     	; 0x5946 <__fp_cmp+0x46>
    5920:	62 1b       	sub	r22, r18
    5922:	73 0b       	sbc	r23, r19
    5924:	84 0b       	sbc	r24, r20
    5926:	95 0b       	sbc	r25, r21
    5928:	39 f4       	brne	.+14     	; 0x5938 <__fp_cmp+0x38>
    592a:	0a 26       	eor	r0, r26
    592c:	61 f0       	breq	.+24     	; 0x5946 <__fp_cmp+0x46>
    592e:	23 2b       	or	r18, r19
    5930:	24 2b       	or	r18, r20
    5932:	25 2b       	or	r18, r21
    5934:	21 f4       	brne	.+8      	; 0x593e <__fp_cmp+0x3e>
    5936:	08 95       	ret
    5938:	0a 26       	eor	r0, r26
    593a:	09 f4       	brne	.+2      	; 0x593e <__fp_cmp+0x3e>
    593c:	a1 40       	sbci	r26, 0x01	; 1
    593e:	a6 95       	lsr	r26
    5940:	8f ef       	ldi	r24, 0xFF	; 255
    5942:	81 1d       	adc	r24, r1
    5944:	81 1d       	adc	r24, r1
    5946:	08 95       	ret

00005948 <__fp_inf>:
    5948:	97 f9       	bld	r25, 7
    594a:	9f 67       	ori	r25, 0x7F	; 127
    594c:	80 e8       	ldi	r24, 0x80	; 128
    594e:	70 e0       	ldi	r23, 0x00	; 0
    5950:	60 e0       	ldi	r22, 0x00	; 0
    5952:	08 95       	ret

00005954 <__fp_mintl>:
    5954:	88 23       	and	r24, r24
    5956:	71 f4       	brne	.+28     	; 0x5974 <__fp_mintl+0x20>
    5958:	77 23       	and	r23, r23
    595a:	21 f0       	breq	.+8      	; 0x5964 <__fp_mintl+0x10>
    595c:	98 50       	subi	r25, 0x08	; 8
    595e:	87 2b       	or	r24, r23
    5960:	76 2f       	mov	r23, r22
    5962:	07 c0       	rjmp	.+14     	; 0x5972 <__fp_mintl+0x1e>
    5964:	66 23       	and	r22, r22
    5966:	11 f4       	brne	.+4      	; 0x596c <__fp_mintl+0x18>
    5968:	99 27       	eor	r25, r25
    596a:	0d c0       	rjmp	.+26     	; 0x5986 <__fp_mintl+0x32>
    596c:	90 51       	subi	r25, 0x10	; 16
    596e:	86 2b       	or	r24, r22
    5970:	70 e0       	ldi	r23, 0x00	; 0
    5972:	60 e0       	ldi	r22, 0x00	; 0
    5974:	2a f0       	brmi	.+10     	; 0x5980 <__fp_mintl+0x2c>
    5976:	9a 95       	dec	r25
    5978:	66 0f       	add	r22, r22
    597a:	77 1f       	adc	r23, r23
    597c:	88 1f       	adc	r24, r24
    597e:	da f7       	brpl	.-10     	; 0x5976 <__fp_mintl+0x22>
    5980:	88 0f       	add	r24, r24
    5982:	96 95       	lsr	r25
    5984:	87 95       	ror	r24
    5986:	97 f9       	bld	r25, 7
    5988:	08 95       	ret

0000598a <__fp_mpack>:
    598a:	9f 3f       	cpi	r25, 0xFF	; 255
    598c:	49 f0       	breq	.+18     	; 0x59a0 <__fp_mpack+0x16>
    598e:	91 50       	subi	r25, 0x01	; 1
    5990:	28 f4       	brcc	.+10     	; 0x599c <__fp_mpack+0x12>
    5992:	86 95       	lsr	r24
    5994:	77 95       	ror	r23
    5996:	67 95       	ror	r22
    5998:	b7 95       	ror	r27
    599a:	9f 5f       	subi	r25, 0xFF	; 255
    599c:	80 38       	cpi	r24, 0x80	; 128
    599e:	9f 4f       	sbci	r25, 0xFF	; 255
    59a0:	88 0f       	add	r24, r24
    59a2:	96 95       	lsr	r25
    59a4:	87 95       	ror	r24
    59a6:	97 f9       	bld	r25, 7
    59a8:	08 95       	ret

000059aa <__fp_nan>:
    59aa:	9f ef       	ldi	r25, 0xFF	; 255
    59ac:	80 ec       	ldi	r24, 0xC0	; 192
    59ae:	08 95       	ret

000059b0 <__fp_powser>:
    59b0:	df 93       	push	r29
    59b2:	cf 93       	push	r28
    59b4:	1f 93       	push	r17
    59b6:	0f 93       	push	r16
    59b8:	ff 92       	push	r15
    59ba:	ef 92       	push	r14
    59bc:	df 92       	push	r13
    59be:	7b 01       	movw	r14, r22
    59c0:	8c 01       	movw	r16, r24
    59c2:	68 94       	set
    59c4:	05 c0       	rjmp	.+10     	; 0x59d0 <__fp_powser+0x20>
    59c6:	da 2e       	mov	r13, r26
    59c8:	ef 01       	movw	r28, r30
    59ca:	8d d0       	rcall	.+282    	; 0x5ae6 <__mulsf3x>
    59cc:	fe 01       	movw	r30, r28
    59ce:	e8 94       	clt
    59d0:	a5 91       	lpm	r26, Z+
    59d2:	25 91       	lpm	r18, Z+
    59d4:	35 91       	lpm	r19, Z+
    59d6:	45 91       	lpm	r20, Z+
    59d8:	55 91       	lpm	r21, Z+
    59da:	ae f3       	brts	.-22     	; 0x59c6 <__fp_powser+0x16>
    59dc:	ef 01       	movw	r28, r30
    59de:	ee dd       	rcall	.-1060   	; 0x55bc <__addsf3x>
    59e0:	fe 01       	movw	r30, r28
    59e2:	97 01       	movw	r18, r14
    59e4:	a8 01       	movw	r20, r16
    59e6:	da 94       	dec	r13
    59e8:	79 f7       	brne	.-34     	; 0x59c8 <__fp_powser+0x18>
    59ea:	df 90       	pop	r13
    59ec:	ef 90       	pop	r14
    59ee:	ff 90       	pop	r15
    59f0:	0f 91       	pop	r16
    59f2:	1f 91       	pop	r17
    59f4:	cf 91       	pop	r28
    59f6:	df 91       	pop	r29
    59f8:	08 95       	ret

000059fa <__fp_pscA>:
    59fa:	00 24       	eor	r0, r0
    59fc:	0a 94       	dec	r0
    59fe:	16 16       	cp	r1, r22
    5a00:	17 06       	cpc	r1, r23
    5a02:	18 06       	cpc	r1, r24
    5a04:	09 06       	cpc	r0, r25
    5a06:	08 95       	ret

00005a08 <__fp_pscB>:
    5a08:	00 24       	eor	r0, r0
    5a0a:	0a 94       	dec	r0
    5a0c:	12 16       	cp	r1, r18
    5a0e:	13 06       	cpc	r1, r19
    5a10:	14 06       	cpc	r1, r20
    5a12:	05 06       	cpc	r0, r21
    5a14:	08 95       	ret

00005a16 <__fp_round>:
    5a16:	09 2e       	mov	r0, r25
    5a18:	03 94       	inc	r0
    5a1a:	00 0c       	add	r0, r0
    5a1c:	11 f4       	brne	.+4      	; 0x5a22 <__fp_round+0xc>
    5a1e:	88 23       	and	r24, r24
    5a20:	52 f0       	brmi	.+20     	; 0x5a36 <__fp_round+0x20>
    5a22:	bb 0f       	add	r27, r27
    5a24:	40 f4       	brcc	.+16     	; 0x5a36 <__fp_round+0x20>
    5a26:	bf 2b       	or	r27, r31
    5a28:	11 f4       	brne	.+4      	; 0x5a2e <__fp_round+0x18>
    5a2a:	60 ff       	sbrs	r22, 0
    5a2c:	04 c0       	rjmp	.+8      	; 0x5a36 <__fp_round+0x20>
    5a2e:	6f 5f       	subi	r22, 0xFF	; 255
    5a30:	7f 4f       	sbci	r23, 0xFF	; 255
    5a32:	8f 4f       	sbci	r24, 0xFF	; 255
    5a34:	9f 4f       	sbci	r25, 0xFF	; 255
    5a36:	08 95       	ret

00005a38 <__fp_split3>:
    5a38:	57 fd       	sbrc	r21, 7
    5a3a:	90 58       	subi	r25, 0x80	; 128
    5a3c:	44 0f       	add	r20, r20
    5a3e:	55 1f       	adc	r21, r21
    5a40:	59 f0       	breq	.+22     	; 0x5a58 <__fp_splitA+0x10>
    5a42:	5f 3f       	cpi	r21, 0xFF	; 255
    5a44:	71 f0       	breq	.+28     	; 0x5a62 <__fp_splitA+0x1a>
    5a46:	47 95       	ror	r20

00005a48 <__fp_splitA>:
    5a48:	88 0f       	add	r24, r24
    5a4a:	97 fb       	bst	r25, 7
    5a4c:	99 1f       	adc	r25, r25
    5a4e:	61 f0       	breq	.+24     	; 0x5a68 <__fp_splitA+0x20>
    5a50:	9f 3f       	cpi	r25, 0xFF	; 255
    5a52:	79 f0       	breq	.+30     	; 0x5a72 <__fp_splitA+0x2a>
    5a54:	87 95       	ror	r24
    5a56:	08 95       	ret
    5a58:	12 16       	cp	r1, r18
    5a5a:	13 06       	cpc	r1, r19
    5a5c:	14 06       	cpc	r1, r20
    5a5e:	55 1f       	adc	r21, r21
    5a60:	f2 cf       	rjmp	.-28     	; 0x5a46 <__fp_split3+0xe>
    5a62:	46 95       	lsr	r20
    5a64:	f1 df       	rcall	.-30     	; 0x5a48 <__fp_splitA>
    5a66:	08 c0       	rjmp	.+16     	; 0x5a78 <__fp_splitA+0x30>
    5a68:	16 16       	cp	r1, r22
    5a6a:	17 06       	cpc	r1, r23
    5a6c:	18 06       	cpc	r1, r24
    5a6e:	99 1f       	adc	r25, r25
    5a70:	f1 cf       	rjmp	.-30     	; 0x5a54 <__fp_splitA+0xc>
    5a72:	86 95       	lsr	r24
    5a74:	71 05       	cpc	r23, r1
    5a76:	61 05       	cpc	r22, r1
    5a78:	08 94       	sec
    5a7a:	08 95       	ret

00005a7c <__fp_trunc>:
    5a7c:	e5 df       	rcall	.-54     	; 0x5a48 <__fp_splitA>
    5a7e:	a0 f0       	brcs	.+40     	; 0x5aa8 <__fp_trunc+0x2c>
    5a80:	be e7       	ldi	r27, 0x7E	; 126
    5a82:	b9 17       	cp	r27, r25
    5a84:	88 f4       	brcc	.+34     	; 0x5aa8 <__fp_trunc+0x2c>
    5a86:	bb 27       	eor	r27, r27
    5a88:	9f 38       	cpi	r25, 0x8F	; 143
    5a8a:	60 f4       	brcc	.+24     	; 0x5aa4 <__fp_trunc+0x28>
    5a8c:	16 16       	cp	r1, r22
    5a8e:	b1 1d       	adc	r27, r1
    5a90:	67 2f       	mov	r22, r23
    5a92:	78 2f       	mov	r23, r24
    5a94:	88 27       	eor	r24, r24
    5a96:	98 5f       	subi	r25, 0xF8	; 248
    5a98:	f7 cf       	rjmp	.-18     	; 0x5a88 <__fp_trunc+0xc>
    5a9a:	86 95       	lsr	r24
    5a9c:	77 95       	ror	r23
    5a9e:	67 95       	ror	r22
    5aa0:	b1 1d       	adc	r27, r1
    5aa2:	93 95       	inc	r25
    5aa4:	96 39       	cpi	r25, 0x96	; 150
    5aa6:	c8 f3       	brcs	.-14     	; 0x5a9a <__fp_trunc+0x1e>
    5aa8:	08 95       	ret

00005aaa <__fp_zero>:
    5aaa:	e8 94       	clt

00005aac <__fp_szero>:
    5aac:	bb 27       	eor	r27, r27
    5aae:	66 27       	eor	r22, r22
    5ab0:	77 27       	eor	r23, r23
    5ab2:	cb 01       	movw	r24, r22
    5ab4:	97 f9       	bld	r25, 7
    5ab6:	08 95       	ret

00005ab8 <__gesf2>:
    5ab8:	23 df       	rcall	.-442    	; 0x5900 <__fp_cmp>
    5aba:	08 f4       	brcc	.+2      	; 0x5abe <__gesf2+0x6>
    5abc:	8f ef       	ldi	r24, 0xFF	; 255
    5abe:	08 95       	ret

00005ac0 <inverse>:
    5ac0:	9b 01       	movw	r18, r22
    5ac2:	ac 01       	movw	r20, r24
    5ac4:	60 e0       	ldi	r22, 0x00	; 0
    5ac6:	70 e0       	ldi	r23, 0x00	; 0
    5ac8:	80 e8       	ldi	r24, 0x80	; 128
    5aca:	9f e3       	ldi	r25, 0x3F	; 63
    5acc:	30 ce       	rjmp	.-928    	; 0x572e <__divsf3>

00005ace <__mulsf3>:
    5ace:	0b d0       	rcall	.+22     	; 0x5ae6 <__mulsf3x>
    5ad0:	a2 cf       	rjmp	.-188    	; 0x5a16 <__fp_round>
    5ad2:	93 df       	rcall	.-218    	; 0x59fa <__fp_pscA>
    5ad4:	28 f0       	brcs	.+10     	; 0x5ae0 <__mulsf3+0x12>
    5ad6:	98 df       	rcall	.-208    	; 0x5a08 <__fp_pscB>
    5ad8:	18 f0       	brcs	.+6      	; 0x5ae0 <__mulsf3+0x12>
    5ada:	95 23       	and	r25, r21
    5adc:	09 f0       	breq	.+2      	; 0x5ae0 <__mulsf3+0x12>
    5ade:	34 cf       	rjmp	.-408    	; 0x5948 <__fp_inf>
    5ae0:	64 cf       	rjmp	.-312    	; 0x59aa <__fp_nan>
    5ae2:	11 24       	eor	r1, r1
    5ae4:	e3 cf       	rjmp	.-58     	; 0x5aac <__fp_szero>

00005ae6 <__mulsf3x>:
    5ae6:	a8 df       	rcall	.-176    	; 0x5a38 <__fp_split3>
    5ae8:	a0 f3       	brcs	.-24     	; 0x5ad2 <__mulsf3+0x4>

00005aea <__mulsf3_pse>:
    5aea:	95 9f       	mul	r25, r21
    5aec:	d1 f3       	breq	.-12     	; 0x5ae2 <__mulsf3+0x14>
    5aee:	95 0f       	add	r25, r21
    5af0:	50 e0       	ldi	r21, 0x00	; 0
    5af2:	55 1f       	adc	r21, r21
    5af4:	62 9f       	mul	r22, r18
    5af6:	f0 01       	movw	r30, r0
    5af8:	72 9f       	mul	r23, r18
    5afa:	bb 27       	eor	r27, r27
    5afc:	f0 0d       	add	r31, r0
    5afe:	b1 1d       	adc	r27, r1
    5b00:	63 9f       	mul	r22, r19
    5b02:	aa 27       	eor	r26, r26
    5b04:	f0 0d       	add	r31, r0
    5b06:	b1 1d       	adc	r27, r1
    5b08:	aa 1f       	adc	r26, r26
    5b0a:	64 9f       	mul	r22, r20
    5b0c:	66 27       	eor	r22, r22
    5b0e:	b0 0d       	add	r27, r0
    5b10:	a1 1d       	adc	r26, r1
    5b12:	66 1f       	adc	r22, r22
    5b14:	82 9f       	mul	r24, r18
    5b16:	22 27       	eor	r18, r18
    5b18:	b0 0d       	add	r27, r0
    5b1a:	a1 1d       	adc	r26, r1
    5b1c:	62 1f       	adc	r22, r18
    5b1e:	73 9f       	mul	r23, r19
    5b20:	b0 0d       	add	r27, r0
    5b22:	a1 1d       	adc	r26, r1
    5b24:	62 1f       	adc	r22, r18
    5b26:	83 9f       	mul	r24, r19
    5b28:	a0 0d       	add	r26, r0
    5b2a:	61 1d       	adc	r22, r1
    5b2c:	22 1f       	adc	r18, r18
    5b2e:	74 9f       	mul	r23, r20
    5b30:	33 27       	eor	r19, r19
    5b32:	a0 0d       	add	r26, r0
    5b34:	61 1d       	adc	r22, r1
    5b36:	23 1f       	adc	r18, r19
    5b38:	84 9f       	mul	r24, r20
    5b3a:	60 0d       	add	r22, r0
    5b3c:	21 1d       	adc	r18, r1
    5b3e:	82 2f       	mov	r24, r18
    5b40:	76 2f       	mov	r23, r22
    5b42:	6a 2f       	mov	r22, r26
    5b44:	11 24       	eor	r1, r1
    5b46:	9f 57       	subi	r25, 0x7F	; 127
    5b48:	50 40       	sbci	r21, 0x00	; 0
    5b4a:	8a f0       	brmi	.+34     	; 0x5b6e <__mulsf3_pse+0x84>
    5b4c:	e1 f0       	breq	.+56     	; 0x5b86 <__mulsf3_pse+0x9c>
    5b4e:	88 23       	and	r24, r24
    5b50:	4a f0       	brmi	.+18     	; 0x5b64 <__mulsf3_pse+0x7a>
    5b52:	ee 0f       	add	r30, r30
    5b54:	ff 1f       	adc	r31, r31
    5b56:	bb 1f       	adc	r27, r27
    5b58:	66 1f       	adc	r22, r22
    5b5a:	77 1f       	adc	r23, r23
    5b5c:	88 1f       	adc	r24, r24
    5b5e:	91 50       	subi	r25, 0x01	; 1
    5b60:	50 40       	sbci	r21, 0x00	; 0
    5b62:	a9 f7       	brne	.-22     	; 0x5b4e <__mulsf3_pse+0x64>
    5b64:	9e 3f       	cpi	r25, 0xFE	; 254
    5b66:	51 05       	cpc	r21, r1
    5b68:	70 f0       	brcs	.+28     	; 0x5b86 <__mulsf3_pse+0x9c>
    5b6a:	ee ce       	rjmp	.-548    	; 0x5948 <__fp_inf>
    5b6c:	9f cf       	rjmp	.-194    	; 0x5aac <__fp_szero>
    5b6e:	5f 3f       	cpi	r21, 0xFF	; 255
    5b70:	ec f3       	brlt	.-6      	; 0x5b6c <__mulsf3_pse+0x82>
    5b72:	98 3e       	cpi	r25, 0xE8	; 232
    5b74:	dc f3       	brlt	.-10     	; 0x5b6c <__mulsf3_pse+0x82>
    5b76:	86 95       	lsr	r24
    5b78:	77 95       	ror	r23
    5b7a:	67 95       	ror	r22
    5b7c:	b7 95       	ror	r27
    5b7e:	f7 95       	ror	r31
    5b80:	e7 95       	ror	r30
    5b82:	9f 5f       	subi	r25, 0xFF	; 255
    5b84:	c1 f7       	brne	.-16     	; 0x5b76 <__mulsf3_pse+0x8c>
    5b86:	fe 2b       	or	r31, r30
    5b88:	88 0f       	add	r24, r24
    5b8a:	91 1d       	adc	r25, r1
    5b8c:	96 95       	lsr	r25
    5b8e:	87 95       	ror	r24
    5b90:	97 f9       	bld	r25, 7
    5b92:	08 95       	ret

00005b94 <square>:
    5b94:	9b 01       	movw	r18, r22
    5b96:	ac 01       	movw	r20, r24
    5b98:	9a cf       	rjmp	.-204    	; 0x5ace <__mulsf3>

00005b9a <__mulsi3>:
    5b9a:	62 9f       	mul	r22, r18
    5b9c:	d0 01       	movw	r26, r0
    5b9e:	73 9f       	mul	r23, r19
    5ba0:	f0 01       	movw	r30, r0
    5ba2:	82 9f       	mul	r24, r18
    5ba4:	e0 0d       	add	r30, r0
    5ba6:	f1 1d       	adc	r31, r1
    5ba8:	64 9f       	mul	r22, r20
    5baa:	e0 0d       	add	r30, r0
    5bac:	f1 1d       	adc	r31, r1
    5bae:	92 9f       	mul	r25, r18
    5bb0:	f0 0d       	add	r31, r0
    5bb2:	83 9f       	mul	r24, r19
    5bb4:	f0 0d       	add	r31, r0
    5bb6:	74 9f       	mul	r23, r20
    5bb8:	f0 0d       	add	r31, r0
    5bba:	65 9f       	mul	r22, r21
    5bbc:	f0 0d       	add	r31, r0
    5bbe:	99 27       	eor	r25, r25
    5bc0:	72 9f       	mul	r23, r18
    5bc2:	b0 0d       	add	r27, r0
    5bc4:	e1 1d       	adc	r30, r1
    5bc6:	f9 1f       	adc	r31, r25
    5bc8:	63 9f       	mul	r22, r19
    5bca:	b0 0d       	add	r27, r0
    5bcc:	e1 1d       	adc	r30, r1
    5bce:	f9 1f       	adc	r31, r25
    5bd0:	bd 01       	movw	r22, r26
    5bd2:	cf 01       	movw	r24, r30
    5bd4:	11 24       	eor	r1, r1
    5bd6:	08 95       	ret

00005bd8 <__udivmodhi4>:
    5bd8:	aa 1b       	sub	r26, r26
    5bda:	bb 1b       	sub	r27, r27
    5bdc:	51 e1       	ldi	r21, 0x11	; 17
    5bde:	07 c0       	rjmp	.+14     	; 0x5bee <__udivmodhi4_ep>

00005be0 <__udivmodhi4_loop>:
    5be0:	aa 1f       	adc	r26, r26
    5be2:	bb 1f       	adc	r27, r27
    5be4:	a6 17       	cp	r26, r22
    5be6:	b7 07       	cpc	r27, r23
    5be8:	10 f0       	brcs	.+4      	; 0x5bee <__udivmodhi4_ep>
    5bea:	a6 1b       	sub	r26, r22
    5bec:	b7 0b       	sbc	r27, r23

00005bee <__udivmodhi4_ep>:
    5bee:	88 1f       	adc	r24, r24
    5bf0:	99 1f       	adc	r25, r25
    5bf2:	5a 95       	dec	r21
    5bf4:	a9 f7       	brne	.-22     	; 0x5be0 <__udivmodhi4_loop>
    5bf6:	80 95       	com	r24
    5bf8:	90 95       	com	r25
    5bfa:	bc 01       	movw	r22, r24
    5bfc:	cd 01       	movw	r24, r26
    5bfe:	08 95       	ret

00005c00 <__divmodhi4>:
    5c00:	97 fb       	bst	r25, 7
    5c02:	09 2e       	mov	r0, r25
    5c04:	07 26       	eor	r0, r23
    5c06:	0a d0       	rcall	.+20     	; 0x5c1c <__divmodhi4_neg1>
    5c08:	77 fd       	sbrc	r23, 7
    5c0a:	04 d0       	rcall	.+8      	; 0x5c14 <__divmodhi4_neg2>
    5c0c:	e5 df       	rcall	.-54     	; 0x5bd8 <__udivmodhi4>
    5c0e:	06 d0       	rcall	.+12     	; 0x5c1c <__divmodhi4_neg1>
    5c10:	00 20       	and	r0, r0
    5c12:	1a f4       	brpl	.+6      	; 0x5c1a <__divmodhi4_exit>

00005c14 <__divmodhi4_neg2>:
    5c14:	70 95       	com	r23
    5c16:	61 95       	neg	r22
    5c18:	7f 4f       	sbci	r23, 0xFF	; 255

00005c1a <__divmodhi4_exit>:
    5c1a:	08 95       	ret

00005c1c <__divmodhi4_neg1>:
    5c1c:	f6 f7       	brtc	.-4      	; 0x5c1a <__divmodhi4_exit>
    5c1e:	90 95       	com	r25
    5c20:	81 95       	neg	r24
    5c22:	9f 4f       	sbci	r25, 0xFF	; 255
    5c24:	08 95       	ret

00005c26 <__udivmodsi4>:
    5c26:	a1 e2       	ldi	r26, 0x21	; 33
    5c28:	1a 2e       	mov	r1, r26
    5c2a:	aa 1b       	sub	r26, r26
    5c2c:	bb 1b       	sub	r27, r27
    5c2e:	fd 01       	movw	r30, r26
    5c30:	0d c0       	rjmp	.+26     	; 0x5c4c <__udivmodsi4_ep>

00005c32 <__udivmodsi4_loop>:
    5c32:	aa 1f       	adc	r26, r26
    5c34:	bb 1f       	adc	r27, r27
    5c36:	ee 1f       	adc	r30, r30
    5c38:	ff 1f       	adc	r31, r31
    5c3a:	a2 17       	cp	r26, r18
    5c3c:	b3 07       	cpc	r27, r19
    5c3e:	e4 07       	cpc	r30, r20
    5c40:	f5 07       	cpc	r31, r21
    5c42:	20 f0       	brcs	.+8      	; 0x5c4c <__udivmodsi4_ep>
    5c44:	a2 1b       	sub	r26, r18
    5c46:	b3 0b       	sbc	r27, r19
    5c48:	e4 0b       	sbc	r30, r20
    5c4a:	f5 0b       	sbc	r31, r21

00005c4c <__udivmodsi4_ep>:
    5c4c:	66 1f       	adc	r22, r22
    5c4e:	77 1f       	adc	r23, r23
    5c50:	88 1f       	adc	r24, r24
    5c52:	99 1f       	adc	r25, r25
    5c54:	1a 94       	dec	r1
    5c56:	69 f7       	brne	.-38     	; 0x5c32 <__udivmodsi4_loop>
    5c58:	60 95       	com	r22
    5c5a:	70 95       	com	r23
    5c5c:	80 95       	com	r24
    5c5e:	90 95       	com	r25
    5c60:	9b 01       	movw	r18, r22
    5c62:	ac 01       	movw	r20, r24
    5c64:	bd 01       	movw	r22, r26
    5c66:	cf 01       	movw	r24, r30
    5c68:	08 95       	ret

00005c6a <__divmodsi4>:
    5c6a:	97 fb       	bst	r25, 7
    5c6c:	09 2e       	mov	r0, r25
    5c6e:	05 26       	eor	r0, r21
    5c70:	0e d0       	rcall	.+28     	; 0x5c8e <__divmodsi4_neg1>
    5c72:	57 fd       	sbrc	r21, 7
    5c74:	04 d0       	rcall	.+8      	; 0x5c7e <__divmodsi4_neg2>
    5c76:	d7 df       	rcall	.-82     	; 0x5c26 <__udivmodsi4>
    5c78:	0a d0       	rcall	.+20     	; 0x5c8e <__divmodsi4_neg1>
    5c7a:	00 1c       	adc	r0, r0
    5c7c:	38 f4       	brcc	.+14     	; 0x5c8c <__divmodsi4_exit>

00005c7e <__divmodsi4_neg2>:
    5c7e:	50 95       	com	r21
    5c80:	40 95       	com	r20
    5c82:	30 95       	com	r19
    5c84:	21 95       	neg	r18
    5c86:	3f 4f       	sbci	r19, 0xFF	; 255
    5c88:	4f 4f       	sbci	r20, 0xFF	; 255
    5c8a:	5f 4f       	sbci	r21, 0xFF	; 255

00005c8c <__divmodsi4_exit>:
    5c8c:	08 95       	ret

00005c8e <__divmodsi4_neg1>:
    5c8e:	f6 f7       	brtc	.-4      	; 0x5c8c <__divmodsi4_exit>
    5c90:	90 95       	com	r25
    5c92:	80 95       	com	r24
    5c94:	70 95       	com	r23
    5c96:	61 95       	neg	r22
    5c98:	7f 4f       	sbci	r23, 0xFF	; 255
    5c9a:	8f 4f       	sbci	r24, 0xFF	; 255
    5c9c:	9f 4f       	sbci	r25, 0xFF	; 255
    5c9e:	08 95       	ret

00005ca0 <_exit>:
    5ca0:	f8 94       	cli

00005ca2 <__stop_program>:
    5ca2:	ff cf       	rjmp	.-2      	; 0x5ca2 <__stop_program>

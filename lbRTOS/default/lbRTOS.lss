
lbRTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000009a  00800200  000061b6  0000624a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000061b6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000ff0  0080029a  0080029a  000062e4  2**0
                  ALLOC
  3 .debug_aranges 000001a0  00000000  00000000  000062e4  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00001852  00000000  00000000  00006484  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00005a24  00000000  00000000  00007cd6  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000016eb  00000000  00000000  0000d6fa  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000048ee  00000000  00000000  0000ede5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00001210  00000000  00000000  000136d4  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000024b0  00000000  00000000  000148e4  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00002d6e  00000000  00000000  00016d94  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000030  00000000  00000000  00019b02  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__ctors_end>
       4:	0c 94 18 01 	jmp	0x230	; 0x230 <__bad_interrupt>
       8:	0c 94 18 01 	jmp	0x230	; 0x230 <__bad_interrupt>
       c:	0c 94 18 01 	jmp	0x230	; 0x230 <__bad_interrupt>
      10:	0c 94 18 01 	jmp	0x230	; 0x230 <__bad_interrupt>
      14:	0c 94 18 01 	jmp	0x230	; 0x230 <__bad_interrupt>
      18:	0c 94 18 01 	jmp	0x230	; 0x230 <__bad_interrupt>
      1c:	0c 94 18 01 	jmp	0x230	; 0x230 <__bad_interrupt>
      20:	0c 94 18 01 	jmp	0x230	; 0x230 <__bad_interrupt>
      24:	0c 94 18 01 	jmp	0x230	; 0x230 <__bad_interrupt>
      28:	0c 94 18 01 	jmp	0x230	; 0x230 <__bad_interrupt>
      2c:	0c 94 18 01 	jmp	0x230	; 0x230 <__bad_interrupt>
      30:	0c 94 18 01 	jmp	0x230	; 0x230 <__bad_interrupt>
      34:	0c 94 06 1f 	jmp	0x3e0c	; 0x3e0c <__vector_13>
      38:	0c 94 33 1f 	jmp	0x3e66	; 0x3e66 <__vector_14>
      3c:	0c 94 25 1d 	jmp	0x3a4a	; 0x3a4a <__vector_15>
      40:	0c 94 7f 1e 	jmp	0x3cfe	; 0x3cfe <__vector_16>
      44:	0c 94 53 18 	jmp	0x30a6	; 0x30a6 <__vector_17>
      48:	0c 94 ac 1e 	jmp	0x3d58	; 0x3d58 <__vector_18>
      4c:	0c 94 d9 1e 	jmp	0x3db2	; 0x3db2 <__vector_19>
      50:	0c 94 e5 1c 	jmp	0x39ca	; 0x39ca <__vector_20>
      54:	0c 94 25 1e 	jmp	0x3c4a	; 0x3c4a <__vector_21>
      58:	0c 94 52 1e 	jmp	0x3ca4	; 0x3ca4 <__vector_22>
      5c:	0c 94 92 1c 	jmp	0x3924	; 0x3924 <__vector_23>
      60:	0c 94 18 01 	jmp	0x230	; 0x230 <__bad_interrupt>
      64:	0c 94 fc 22 	jmp	0x45f8	; 0x45f8 <__vector_25>
      68:	0c 94 18 01 	jmp	0x230	; 0x230 <__bad_interrupt>
      6c:	0c 94 59 24 	jmp	0x48b2	; 0x48b2 <__vector_27>
      70:	0c 94 18 01 	jmp	0x230	; 0x230 <__bad_interrupt>
      74:	0c 94 13 27 	jmp	0x4e26	; 0x4e26 <__vector_29>
      78:	0c 94 18 01 	jmp	0x230	; 0x230 <__bad_interrupt>
      7c:	0c 94 60 1f 	jmp	0x3ec0	; 0x3ec0 <__vector_31>
      80:	0c 94 8d 1f 	jmp	0x3f1a	; 0x3f1a <__vector_32>
      84:	0c 94 ba 1f 	jmp	0x3f74	; 0x3f74 <__vector_33>
      88:	0c 94 e7 1f 	jmp	0x3fce	; 0x3fce <__vector_34>
      8c:	0c 94 65 1d 	jmp	0x3aca	; 0x3aca <__vector_35>
      90:	0c 94 d7 22 	jmp	0x45ae	; 0x45ae <__vector_36>
      94:	0c 94 18 01 	jmp	0x230	; 0x230 <__bad_interrupt>
      98:	0c 94 34 24 	jmp	0x4868	; 0x4868 <__vector_38>
      9c:	0c 94 31 2b 	jmp	0x5662	; 0x5662 <__vector_39>
      a0:	0c 94 18 01 	jmp	0x230	; 0x230 <__bad_interrupt>
      a4:	0c 94 14 20 	jmp	0x4028	; 0x4028 <__vector_41>
      a8:	0c 94 41 20 	jmp	0x4082	; 0x4082 <__vector_42>
      ac:	0c 94 6e 20 	jmp	0x40dc	; 0x40dc <__vector_43>
      b0:	0c 94 9b 20 	jmp	0x4136	; 0x4136 <__vector_44>
      b4:	0c 94 a5 1d 	jmp	0x3b4a	; 0x3b4a <__vector_45>
      b8:	0c 94 c8 20 	jmp	0x4190	; 0x4190 <__vector_46>
      bc:	0c 94 f5 20 	jmp	0x41ea	; 0x41ea <__vector_47>
      c0:	0c 94 22 21 	jmp	0x4244	; 0x4244 <__vector_48>
      c4:	0c 94 4f 21 	jmp	0x429e	; 0x429e <__vector_49>
      c8:	0c 94 e5 1d 	jmp	0x3bca	; 0x3bca <__vector_50>
      cc:	0c 94 b2 22 	jmp	0x4564	; 0x4564 <__vector_51>
      d0:	0c 94 18 01 	jmp	0x230	; 0x230 <__bad_interrupt>
      d4:	0c 94 0f 24 	jmp	0x481e	; 0x481e <__vector_53>
      d8:	0c 94 8d 22 	jmp	0x451a	; 0x451a <__vector_54>
      dc:	0c 94 18 01 	jmp	0x230	; 0x230 <__bad_interrupt>
      e0:	0c 94 ea 23 	jmp	0x47d4	; 0x47d4 <__vector_56>
      e4:	07 63       	ori	r16, 0x37	; 55
      e6:	42 36       	cpi	r20, 0x62	; 98
      e8:	b7 9b       	sbis	0x16, 7	; 22
      ea:	d8 a7       	std	Y+40, r29	; 0x28
      ec:	1a 39       	cpi	r17, 0x9A	; 154
      ee:	68 56       	subi	r22, 0x68	; 104
      f0:	18 ae       	std	Y+56, r1	; 0x38
      f2:	ba ab       	std	Y+50, r27	; 0x32
      f4:	55 8c       	ldd	r5, Z+29	; 0x1d
      f6:	1d 3c       	cpi	r17, 0xCD	; 205
      f8:	b7 cc       	rjmp	.-1682   	; 0xfffffa68 <__eeprom_end+0xff7efa68>
      fa:	57 63       	ori	r21, 0x37	; 55
      fc:	bd 6d       	ori	r27, 0xDD	; 221
      fe:	ed fd       	.word	0xfded	; ????
     100:	75 3e       	cpi	r23, 0xE5	; 229
     102:	f6 17       	cp	r31, r22
     104:	72 31       	cpi	r23, 0x12	; 18
     106:	bf 00       	.word	0x00bf	; ????
     108:	00 00       	nop
     10a:	80 3f       	cpi	r24, 0xF0	; 240
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 00       	nop
     110:	be 92       	st	-X, r11
     112:	24 49       	sbci	r18, 0x94	; 148
     114:	12 3e       	cpi	r17, 0xE2	; 226
     116:	ab aa       	std	Y+51, r10	; 0x33
     118:	aa 2a       	or	r10, r26
     11a:	be cd       	rjmp	.-1156   	; 0xfffffc98 <__eeprom_end+0xff7efc98>
     11c:	cc cc       	rjmp	.-1640   	; 0xfffffab6 <__eeprom_end+0xff7efab6>
     11e:	4c 3e       	cpi	r20, 0xEC	; 236
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	be ab       	std	Y+54, r27	; 0x36
     126:	aa aa       	std	Y+50, r10	; 0x32
     128:	aa 3e       	cpi	r26, 0xEA	; 234
     12a:	00 00       	nop
     12c:	00 00       	nop
     12e:	bf 00       	.word	0x00bf	; ????
     130:	00 00       	nop
     132:	80 3f       	cpi	r24, 0xF0	; 240
     134:	00 00       	nop
     136:	00 00       	nop
     138:	00 08       	sbc	r0, r0
     13a:	41 78       	andi	r20, 0x81	; 129
     13c:	d3 bb       	out	0x13, r29	; 19
     13e:	43 87       	std	Z+11, r20	; 0x0b
     140:	d1 13       	cpse	r29, r17
     142:	3d 19       	sub	r19, r13
     144:	0e 3c       	cpi	r16, 0xCE	; 206
     146:	c3 bd       	out	0x23, r28	; 35
     148:	42 82       	std	Z+2, r4	; 0x02
     14a:	ad 2b       	or	r26, r29
     14c:	3e 68       	ori	r19, 0x8E	; 142
     14e:	ec 82       	std	Y+4, r14	; 0x04
     150:	76 be       	out	0x36, r7	; 54
     152:	d9 8f       	std	Y+25, r29	; 0x19
     154:	e1 a9       	ldd	r30, Z+49	; 0x31
     156:	3e 4c       	sbci	r19, 0xCE	; 206
     158:	80 ef       	ldi	r24, 0xF0	; 240
     15a:	ff be       	out	0x3f, r15	; 63
     15c:	01 c4       	rjmp	.+2050   	; 0x960 <retConv_s16+0x84>
     15e:	ff 7f       	andi	r31, 0xFF	; 255
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
	...

00000166 <__c.3390>:
     166:	68 65 6c 6c 6f 20 62 72 69 61 6e 2e 2e 2e 0a 00     hello brian.....

00000176 <__c.3212>:
     176:	0a 00                                               ..

00000178 <__c.3210>:
     178:	25 64 00                                            %d.

0000017b <__c.3198>:
     17b:	25 64 0a 00                                         %d..

0000017f <__c.3099>:
     17f:	49 6e 69 74 69 61 6c 69 7a 61 74 69 6f 6e 20 43     Initialization C
     18f:	6f 6d 70 6c 65 74 65 20 0d 0a 00                    omplete ...

0000019a <__c.3094>:
     19a:	2e 00                                               ..

0000019c <__c.3092>:
     19c:	0d 0a 53 79 73 74 65 6d 20 57 61 72 6d 65 64 20     ..System Warmed 
     1ac:	55 70 00                                            Up.

000001af <__c.3035>:
     1af:	57 52 0a 00                                         WR..

000001b3 <__c.3004>:
     1b3:	57 52 0a 00                                         WR..

000001b7 <TimerPrescaleFactor>:
     1b7:	00 00 01 00 08 00 40 00 00 01 00 04                 ......@.....

000001c3 <Timer2PrescaleFactor>:
     1c3:	00 00 01 00 08 00 20 00 40 00 80 00 00 01 00 04     ...... .@.......

000001d3 <__c.1991>:
     1d3:	42 41 44 5f 76 65 63 74 20 63 61 6c 6c 65 64 21     BAD_vect called!
	...

000001e4 <HexChars>:
     1e4:	30 31 32 33 34 35 36 37 38 39 41 42 43 44 45 46     0123456789ABCDEF
	...

000001f6 <__ctors_end>:
     1f6:	11 24       	eor	r1, r1
     1f8:	1f be       	out	0x3f, r1	; 63
     1fa:	cf ef       	ldi	r28, 0xFF	; 255
     1fc:	d1 e2       	ldi	r29, 0x21	; 33
     1fe:	de bf       	out	0x3e, r29	; 62
     200:	cd bf       	out	0x3d, r28	; 61

00000202 <__do_copy_data>:
     202:	12 e0       	ldi	r17, 0x02	; 2
     204:	a0 e0       	ldi	r26, 0x00	; 0
     206:	b2 e0       	ldi	r27, 0x02	; 2
     208:	e6 eb       	ldi	r30, 0xB6	; 182
     20a:	f1 e6       	ldi	r31, 0x61	; 97
     20c:	02 c0       	rjmp	.+4      	; 0x212 <.do_copy_data_start>

0000020e <.do_copy_data_loop>:
     20e:	05 90       	lpm	r0, Z+
     210:	0d 92       	st	X+, r0

00000212 <.do_copy_data_start>:
     212:	aa 39       	cpi	r26, 0x9A	; 154
     214:	b1 07       	cpc	r27, r17
     216:	d9 f7       	brne	.-10     	; 0x20e <.do_copy_data_loop>

00000218 <__do_clear_bss>:
     218:	12 e1       	ldi	r17, 0x12	; 18
     21a:	aa e9       	ldi	r26, 0x9A	; 154
     21c:	b2 e0       	ldi	r27, 0x02	; 2
     21e:	01 c0       	rjmp	.+2      	; 0x222 <.do_clear_bss_start>

00000220 <.do_clear_bss_loop>:
     220:	1d 92       	st	X+, r1

00000222 <.do_clear_bss_start>:
     222:	aa 38       	cpi	r26, 0x8A	; 138
     224:	b1 07       	cpc	r27, r17
     226:	e1 f7       	brne	.-8      	; 0x220 <.do_clear_bss_loop>
     228:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <main>
     22c:	0c 94 5d 2c 	jmp	0x58ba	; 0x58ba <exit>

00000230 <__bad_interrupt>:
     230:	0c 94 7c 21 	jmp	0x42f8	; 0x42f8 <__vector_default>

00000234 <PWM_Init_timer1_LED>:

//OC1B  pin B6 (attached to green LED)
void PWM_Init_timer1_LED(u08 bitRes)
{
	// enable timer2 as 8,9,10bit PWM
	if(bitRes == 9)
     234:	89 30       	cpi	r24, 0x09	; 9
     236:	49 f4       	brne	.+18     	; 0x24a <PWM_Init_timer1_LED+0x16>
	{	// 9bit mode
		sbi(TCCR1A,PWM11);
     238:	80 91 80 00 	lds	r24, 0x0080
     23c:	82 60       	ori	r24, 0x02	; 2
     23e:	80 93 80 00 	sts	0x0080, r24
		cbi(TCCR1A,PWM10);
     242:	80 91 80 00 	lds	r24, 0x0080
     246:	8e 7f       	andi	r24, 0xFE	; 254
     248:	0e c0       	rjmp	.+28     	; 0x266 <PWM_Init_timer1_LED+0x32>
	}
	else if( bitRes == 10 )
     24a:	8a 30       	cpi	r24, 0x0A	; 10
     24c:	21 f4       	brne	.+8      	; 0x256 <PWM_Init_timer1_LED+0x22>
	{	// 10bit mode
		sbi(TCCR1A,PWM11);
     24e:	80 91 80 00 	lds	r24, 0x0080
     252:	82 60       	ori	r24, 0x02	; 2
     254:	03 c0       	rjmp	.+6      	; 0x25c <PWM_Init_timer1_LED+0x28>
		sbi(TCCR1A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR1A,PWM11);
     256:	80 91 80 00 	lds	r24, 0x0080
     25a:	8d 7f       	andi	r24, 0xFD	; 253
     25c:	80 93 80 00 	sts	0x0080, r24
		sbi(TCCR1A,PWM10);
     260:	80 91 80 00 	lds	r24, 0x0080
     264:	81 60       	ori	r24, 0x01	; 1
     266:	80 93 80 00 	sts	0x0080, r24
	}
	// clear output compare values
	OCR1B = 0;
     26a:	10 92 8b 00 	sts	0x008B, r1
     26e:	10 92 8a 00 	sts	0x008A, r1
}
     272:	08 95       	ret

00000274 <PWM_Init_timer2_H6>:
//pin H6, timer2
void PWM_Init_timer2_H6(u08 bitRes)
{
	// enable timer2 as 8,9,10bit PWM
	if(bitRes == 9)
     274:	89 30       	cpi	r24, 0x09	; 9
     276:	49 f4       	brne	.+18     	; 0x28a <PWM_Init_timer2_H6+0x16>
	{	// 9bit mode
		sbi(TCCR2A,PWM11);
     278:	80 91 b0 00 	lds	r24, 0x00B0
     27c:	82 60       	ori	r24, 0x02	; 2
     27e:	80 93 b0 00 	sts	0x00B0, r24
		cbi(TCCR2A,PWM10);
     282:	80 91 b0 00 	lds	r24, 0x00B0
     286:	8e 7f       	andi	r24, 0xFE	; 254
     288:	0e c0       	rjmp	.+28     	; 0x2a6 <PWM_Init_timer2_H6+0x32>
	}
	else if( bitRes == 10 )
     28a:	8a 30       	cpi	r24, 0x0A	; 10
     28c:	21 f4       	brne	.+8      	; 0x296 <PWM_Init_timer2_H6+0x22>
	{	// 10bit mode
		sbi(TCCR2A,PWM11);
     28e:	80 91 b0 00 	lds	r24, 0x00B0
     292:	82 60       	ori	r24, 0x02	; 2
     294:	03 c0       	rjmp	.+6      	; 0x29c <PWM_Init_timer2_H6+0x28>
		sbi(TCCR2A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR2A,PWM11);
     296:	80 91 b0 00 	lds	r24, 0x00B0
     29a:	8d 7f       	andi	r24, 0xFD	; 253
     29c:	80 93 b0 00 	sts	0x00B0, r24
		sbi(TCCR2A,PWM10);
     2a0:	80 91 b0 00 	lds	r24, 0x00B0
     2a4:	81 60       	ori	r24, 0x01	; 1
     2a6:	80 93 b0 00 	sts	0x00B0, r24
	}
	// clear output compare values
	OCR2B = 0;
     2aa:	10 92 b4 00 	sts	0x00B4, r1
}
     2ae:	08 95       	ret

000002b0 <PWM_Init_timer3_E3>:
//pin E3
void PWM_Init_timer3_E3(u08 bitRes)
{
	// enable timer3 as 8,9,10bit PWM
	if(bitRes == 9)
     2b0:	89 30       	cpi	r24, 0x09	; 9
     2b2:	49 f4       	brne	.+18     	; 0x2c6 <PWM_Init_timer3_E3+0x16>
	{	// 9bit mode
		sbi(TCCR3A,PWM11);
     2b4:	80 91 90 00 	lds	r24, 0x0090
     2b8:	82 60       	ori	r24, 0x02	; 2
     2ba:	80 93 90 00 	sts	0x0090, r24
		cbi(TCCR3A,PWM10);
     2be:	80 91 90 00 	lds	r24, 0x0090
     2c2:	8e 7f       	andi	r24, 0xFE	; 254
     2c4:	0e c0       	rjmp	.+28     	; 0x2e2 <PWM_Init_timer3_E3+0x32>
	}
	else if( bitRes == 10 )
     2c6:	8a 30       	cpi	r24, 0x0A	; 10
     2c8:	21 f4       	brne	.+8      	; 0x2d2 <PWM_Init_timer3_E3+0x22>
	{	// 10bit mode
		sbi(TCCR3A,PWM11);
     2ca:	80 91 90 00 	lds	r24, 0x0090
     2ce:	82 60       	ori	r24, 0x02	; 2
     2d0:	03 c0       	rjmp	.+6      	; 0x2d8 <PWM_Init_timer3_E3+0x28>
		sbi(TCCR3A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR3A,PWM11);
     2d2:	80 91 90 00 	lds	r24, 0x0090
     2d6:	8d 7f       	andi	r24, 0xFD	; 253
     2d8:	80 93 90 00 	sts	0x0090, r24
		sbi(TCCR3A,PWM10);
     2dc:	80 91 90 00 	lds	r24, 0x0090
     2e0:	81 60       	ori	r24, 0x01	; 1
     2e2:	80 93 90 00 	sts	0x0090, r24
	}
	// clear output compare values
	OCR3A = 0;
     2e6:	10 92 99 00 	sts	0x0099, r1
     2ea:	10 92 98 00 	sts	0x0098, r1
	//timer3PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     2ee:	08 95       	ret

000002f0 <PWM_Init_timer3_E4>:
//pin E4
void PWM_Init_timer3_E4(u08 bitRes)
{
	// enable timer3 as 8,9,10bit PWM
	if(bitRes == 9)
     2f0:	89 30       	cpi	r24, 0x09	; 9
     2f2:	49 f4       	brne	.+18     	; 0x306 <PWM_Init_timer3_E4+0x16>
	{	// 9bit mode
		sbi(TCCR3B,PWM11);
     2f4:	80 91 91 00 	lds	r24, 0x0091
     2f8:	82 60       	ori	r24, 0x02	; 2
     2fa:	80 93 91 00 	sts	0x0091, r24
		cbi(TCCR3B,PWM10);
     2fe:	80 91 91 00 	lds	r24, 0x0091
     302:	8e 7f       	andi	r24, 0xFE	; 254
     304:	0e c0       	rjmp	.+28     	; 0x322 <PWM_Init_timer3_E4+0x32>
	}
	else if( bitRes == 10 )
     306:	8a 30       	cpi	r24, 0x0A	; 10
     308:	21 f4       	brne	.+8      	; 0x312 <PWM_Init_timer3_E4+0x22>
	{	// 10bit mode
		sbi(TCCR3B,PWM11);
     30a:	80 91 91 00 	lds	r24, 0x0091
     30e:	82 60       	ori	r24, 0x02	; 2
     310:	03 c0       	rjmp	.+6      	; 0x318 <PWM_Init_timer3_E4+0x28>
		sbi(TCCR3B,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR3B,PWM11);
     312:	80 91 91 00 	lds	r24, 0x0091
     316:	8d 7f       	andi	r24, 0xFD	; 253
     318:	80 93 91 00 	sts	0x0091, r24
		sbi(TCCR3B,PWM10);
     31c:	80 91 91 00 	lds	r24, 0x0091
     320:	81 60       	ori	r24, 0x01	; 1
     322:	80 93 91 00 	sts	0x0091, r24
	}
	// clear output compare values
	OCR3B = 0;
     326:	10 92 9b 00 	sts	0x009B, r1
     32a:	10 92 9a 00 	sts	0x009A, r1
	//timer3PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     32e:	08 95       	ret

00000330 <PWM_Init_timer3_E5>:
//pin E5
void PWM_Init_timer3_E5(u08 bitRes)
{
	// enable timer3 as 8,9,10bit PWM
	if(bitRes == 9)
     330:	89 30       	cpi	r24, 0x09	; 9
     332:	49 f4       	brne	.+18     	; 0x346 <PWM_Init_timer3_E5+0x16>
	{	// 9bit mode
		sbi(TCCR3C,PWM11);
     334:	80 91 92 00 	lds	r24, 0x0092
     338:	82 60       	ori	r24, 0x02	; 2
     33a:	80 93 92 00 	sts	0x0092, r24
		cbi(TCCR3C,PWM10);
     33e:	80 91 92 00 	lds	r24, 0x0092
     342:	8e 7f       	andi	r24, 0xFE	; 254
     344:	0e c0       	rjmp	.+28     	; 0x362 <PWM_Init_timer3_E5+0x32>
	}
	else if( bitRes == 10 )
     346:	8a 30       	cpi	r24, 0x0A	; 10
     348:	21 f4       	brne	.+8      	; 0x352 <PWM_Init_timer3_E5+0x22>
	{	// 10bit mode
		sbi(TCCR3C,PWM11);
     34a:	80 91 92 00 	lds	r24, 0x0092
     34e:	82 60       	ori	r24, 0x02	; 2
     350:	03 c0       	rjmp	.+6      	; 0x358 <PWM_Init_timer3_E5+0x28>
		sbi(TCCR3C,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR3C,PWM11);
     352:	80 91 92 00 	lds	r24, 0x0092
     356:	8d 7f       	andi	r24, 0xFD	; 253
     358:	80 93 92 00 	sts	0x0092, r24
		sbi(TCCR3C,PWM10);
     35c:	80 91 92 00 	lds	r24, 0x0092
     360:	81 60       	ori	r24, 0x01	; 1
     362:	80 93 92 00 	sts	0x0092, r24
	}
	// clear output compare values
	OCR3C = 0;
     366:	10 92 9d 00 	sts	0x009D, r1
     36a:	10 92 9c 00 	sts	0x009C, r1
	//timer3PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     36e:	08 95       	ret

00000370 <PWM_Init_timer4_H3>:
//pin H3, timer4
void PWM_Init_timer4_H3(u08 bitRes)
{
	// enable timer4 as 8,9,10bit PWM
	if(bitRes == 9)
     370:	89 30       	cpi	r24, 0x09	; 9
     372:	49 f4       	brne	.+18     	; 0x386 <PWM_Init_timer4_H3+0x16>
	{	// 9bit mode
		sbi(TCCR4A,PWM11);
     374:	80 91 a0 00 	lds	r24, 0x00A0
     378:	82 60       	ori	r24, 0x02	; 2
     37a:	80 93 a0 00 	sts	0x00A0, r24
		cbi(TCCR4A,PWM10);
     37e:	80 91 a0 00 	lds	r24, 0x00A0
     382:	8e 7f       	andi	r24, 0xFE	; 254
     384:	0e c0       	rjmp	.+28     	; 0x3a2 <PWM_Init_timer4_H3+0x32>
	}
	else if( bitRes == 10 )
     386:	8a 30       	cpi	r24, 0x0A	; 10
     388:	21 f4       	brne	.+8      	; 0x392 <PWM_Init_timer4_H3+0x22>
	{	// 10bit mode
		sbi(TCCR4A,PWM11);
     38a:	80 91 a0 00 	lds	r24, 0x00A0
     38e:	82 60       	ori	r24, 0x02	; 2
     390:	03 c0       	rjmp	.+6      	; 0x398 <PWM_Init_timer4_H3+0x28>
		sbi(TCCR4A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR4A,PWM11);
     392:	80 91 a0 00 	lds	r24, 0x00A0
     396:	8d 7f       	andi	r24, 0xFD	; 253
     398:	80 93 a0 00 	sts	0x00A0, r24
		sbi(TCCR4A,PWM10);
     39c:	80 91 a0 00 	lds	r24, 0x00A0
     3a0:	81 60       	ori	r24, 0x01	; 1
     3a2:	80 93 a0 00 	sts	0x00A0, r24
	}
	// clear output compare values
	OCR4A = 0;
     3a6:	10 92 a9 00 	sts	0x00A9, r1
     3aa:	10 92 a8 00 	sts	0x00A8, r1
	//timer4PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     3ae:	08 95       	ret

000003b0 <PWM_Init_timer4_H4>:
//pin H4, timer4
void PWM_Init_timer4_H4(u08 bitRes)
{
	// enable timer4 as 8,9,10bit PWM
	if(bitRes == 9)
     3b0:	89 30       	cpi	r24, 0x09	; 9
     3b2:	49 f4       	brne	.+18     	; 0x3c6 <PWM_Init_timer4_H4+0x16>
	{	// 9bit mode
		sbi(TCCR4B,PWM11);
     3b4:	80 91 a1 00 	lds	r24, 0x00A1
     3b8:	82 60       	ori	r24, 0x02	; 2
     3ba:	80 93 a1 00 	sts	0x00A1, r24
		cbi(TCCR4B,PWM10);
     3be:	80 91 a1 00 	lds	r24, 0x00A1
     3c2:	8e 7f       	andi	r24, 0xFE	; 254
     3c4:	0e c0       	rjmp	.+28     	; 0x3e2 <PWM_Init_timer4_H4+0x32>
	}
	else if( bitRes == 10 )
     3c6:	8a 30       	cpi	r24, 0x0A	; 10
     3c8:	21 f4       	brne	.+8      	; 0x3d2 <PWM_Init_timer4_H4+0x22>
	{	// 10bit mode
		sbi(TCCR4B,PWM11);
     3ca:	80 91 a1 00 	lds	r24, 0x00A1
     3ce:	82 60       	ori	r24, 0x02	; 2
     3d0:	03 c0       	rjmp	.+6      	; 0x3d8 <PWM_Init_timer4_H4+0x28>
		sbi(TCCR4B,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR4B,PWM11);
     3d2:	80 91 a1 00 	lds	r24, 0x00A1
     3d6:	8d 7f       	andi	r24, 0xFD	; 253
     3d8:	80 93 a1 00 	sts	0x00A1, r24
		sbi(TCCR4B,PWM10);
     3dc:	80 91 a1 00 	lds	r24, 0x00A1
     3e0:	81 60       	ori	r24, 0x01	; 1
     3e2:	80 93 a1 00 	sts	0x00A1, r24
	}
	// clear output compare values
	OCR4B = 0;
     3e6:	10 92 ab 00 	sts	0x00AB, r1
     3ea:	10 92 aa 00 	sts	0x00AA, r1
	//timer4PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     3ee:	08 95       	ret

000003f0 <PWM_Init_timer4_H5>:
//pin H5, timer4
void PWM_Init_timer4_H5(u08 bitRes)
{
	// enable timer4 as 8,9,10bit PWM
	if(bitRes == 9)
     3f0:	89 30       	cpi	r24, 0x09	; 9
     3f2:	49 f4       	brne	.+18     	; 0x406 <PWM_Init_timer4_H5+0x16>
	{	// 9bit mode
		sbi(TCCR4A,PWM11);
     3f4:	80 91 a0 00 	lds	r24, 0x00A0
     3f8:	82 60       	ori	r24, 0x02	; 2
     3fa:	80 93 a0 00 	sts	0x00A0, r24
		cbi(TCCR4A,PWM10);
     3fe:	80 91 a0 00 	lds	r24, 0x00A0
     402:	8e 7f       	andi	r24, 0xFE	; 254
     404:	0e c0       	rjmp	.+28     	; 0x422 <PWM_Init_timer4_H5+0x32>
	}
	else if( bitRes == 10 )
     406:	8a 30       	cpi	r24, 0x0A	; 10
     408:	21 f4       	brne	.+8      	; 0x412 <PWM_Init_timer4_H5+0x22>
	{	// 10bit mode
		sbi(TCCR4A,PWM11);
     40a:	80 91 a0 00 	lds	r24, 0x00A0
     40e:	82 60       	ori	r24, 0x02	; 2
     410:	03 c0       	rjmp	.+6      	; 0x418 <PWM_Init_timer4_H5+0x28>
		sbi(TCCR4A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR4A,PWM11);
     412:	80 91 a0 00 	lds	r24, 0x00A0
     416:	8d 7f       	andi	r24, 0xFD	; 253
     418:	80 93 a0 00 	sts	0x00A0, r24
		sbi(TCCR4A,PWM10);
     41c:	80 91 a0 00 	lds	r24, 0x00A0
     420:	81 60       	ori	r24, 0x01	; 1
     422:	80 93 a0 00 	sts	0x00A0, r24
	}
	// clear output compare values
	OCR4C = 0;
     426:	10 92 ad 00 	sts	0x00AD, r1
     42a:	10 92 ac 00 	sts	0x00AC, r1
	//timer4PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     42e:	08 95       	ret

00000430 <timer1PWMInitICR>:
// include support for arbitrary top-count PWM
// on new AVR processors that support it
void timer1PWMInitICR(u16 topcount)
{
	// set PWM mode with ICR top-count
	cbi(TCCR1A,WGM10);
     430:	e0 e8       	ldi	r30, 0x80	; 128
     432:	f0 e0       	ldi	r31, 0x00	; 0
     434:	20 81       	ld	r18, Z
     436:	2e 7f       	andi	r18, 0xFE	; 254
     438:	20 83       	st	Z, r18
	sbi(TCCR1A,WGM11);
     43a:	20 81       	ld	r18, Z
     43c:	22 60       	ori	r18, 0x02	; 2
     43e:	20 83       	st	Z, r18
	sbi(TCCR1B,WGM12);
     440:	e1 e8       	ldi	r30, 0x81	; 129
     442:	f0 e0       	ldi	r31, 0x00	; 0
     444:	20 81       	ld	r18, Z
     446:	28 60       	ori	r18, 0x08	; 8
     448:	20 83       	st	Z, r18
	sbi(TCCR1B,WGM13);
     44a:	20 81       	ld	r18, Z
     44c:	20 61       	ori	r18, 0x10	; 16
     44e:	20 83       	st	Z, r18
	
	// set top count value
	ICR1 = topcount;
     450:	90 93 87 00 	sts	0x0087, r25
     454:	80 93 86 00 	sts	0x0086, r24
	
	// clear output compare values
	OCR1A = 0;
     458:	10 92 89 00 	sts	0x0089, r1
     45c:	10 92 88 00 	sts	0x0088, r1
	OCR1B = 0;
     460:	10 92 8b 00 	sts	0x008B, r1
     464:	10 92 8a 00 	sts	0x008A, r1
	OCR1C = 0;
     468:	10 92 8d 00 	sts	0x008D, r1
     46c:	10 92 8c 00 	sts	0x008C, r1
}
     470:	08 95       	ret

00000472 <timer3PWMInitICR>:
void timer3PWMInitICR(u16 topcount)
{
	// set PWM mode with ICR top-count
	cbi(TCCR3A,WGM10);
     472:	e0 e9       	ldi	r30, 0x90	; 144
     474:	f0 e0       	ldi	r31, 0x00	; 0
     476:	20 81       	ld	r18, Z
     478:	2e 7f       	andi	r18, 0xFE	; 254
     47a:	20 83       	st	Z, r18
	sbi(TCCR3A,WGM11);
     47c:	20 81       	ld	r18, Z
     47e:	22 60       	ori	r18, 0x02	; 2
     480:	20 83       	st	Z, r18
	sbi(TCCR3B,WGM12);
     482:	e1 e9       	ldi	r30, 0x91	; 145
     484:	f0 e0       	ldi	r31, 0x00	; 0
     486:	20 81       	ld	r18, Z
     488:	28 60       	ori	r18, 0x08	; 8
     48a:	20 83       	st	Z, r18
	sbi(TCCR3B,WGM13);
     48c:	20 81       	ld	r18, Z
     48e:	20 61       	ori	r18, 0x10	; 16
     490:	20 83       	st	Z, r18
	
	// set top count value
	ICR3 = topcount;
     492:	90 93 97 00 	sts	0x0097, r25
     496:	80 93 96 00 	sts	0x0096, r24
	
	// clear output compare values
	OCR3A = 0;
     49a:	10 92 99 00 	sts	0x0099, r1
     49e:	10 92 98 00 	sts	0x0098, r1
	OCR3B = 0;
     4a2:	10 92 9b 00 	sts	0x009B, r1
     4a6:	10 92 9a 00 	sts	0x009A, r1
	OCR3C = 0;
     4aa:	10 92 9d 00 	sts	0x009D, r1
     4ae:	10 92 9c 00 	sts	0x009C, r1
}
     4b2:	08 95       	ret

000004b4 <timer4PWMInitICR>:
void timer4PWMInitICR(u16 topcount)
{
	// set PWM mode with ICR top-count
	cbi(TCCR4A,WGM10);
     4b4:	e0 ea       	ldi	r30, 0xA0	; 160
     4b6:	f0 e0       	ldi	r31, 0x00	; 0
     4b8:	20 81       	ld	r18, Z
     4ba:	2e 7f       	andi	r18, 0xFE	; 254
     4bc:	20 83       	st	Z, r18
	sbi(TCCR4A,WGM11);
     4be:	20 81       	ld	r18, Z
     4c0:	22 60       	ori	r18, 0x02	; 2
     4c2:	20 83       	st	Z, r18
	sbi(TCCR4B,WGM12);
     4c4:	e1 ea       	ldi	r30, 0xA1	; 161
     4c6:	f0 e0       	ldi	r31, 0x00	; 0
     4c8:	20 81       	ld	r18, Z
     4ca:	28 60       	ori	r18, 0x08	; 8
     4cc:	20 83       	st	Z, r18
	sbi(TCCR4B,WGM13);
     4ce:	20 81       	ld	r18, Z
     4d0:	20 61       	ori	r18, 0x10	; 16
     4d2:	20 83       	st	Z, r18
	
	// set top count value
	ICR4 = topcount;
     4d4:	90 93 a7 00 	sts	0x00A7, r25
     4d8:	80 93 a6 00 	sts	0x00A6, r24
	
	// clear output compare values
	OCR4A = 0;
     4dc:	10 92 a9 00 	sts	0x00A9, r1
     4e0:	10 92 a8 00 	sts	0x00A8, r1
	OCR4B = 0;
     4e4:	10 92 ab 00 	sts	0x00AB, r1
     4e8:	10 92 aa 00 	sts	0x00AA, r1
	OCR4C = 0;
     4ec:	10 92 ad 00 	sts	0x00AD, r1
     4f0:	10 92 ac 00 	sts	0x00AC, r1
}
     4f4:	08 95       	ret

000004f6 <PWM_timer1_On_LED>:
#endif

//on commands
void PWM_timer1_On_LED(void)
{
	sbi(TCCR1A,COM1B1);
     4f6:	e0 e8       	ldi	r30, 0x80	; 128
     4f8:	f0 e0       	ldi	r31, 0x00	; 0
     4fa:	80 81       	ld	r24, Z
     4fc:	80 62       	ori	r24, 0x20	; 32
     4fe:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B0);
     500:	80 81       	ld	r24, Z
     502:	8f 7e       	andi	r24, 0xEF	; 239
     504:	80 83       	st	Z, r24
}
     506:	08 95       	ret

00000508 <PWM_timer2_On_H6>:
void PWM_timer2_On_H6(void)
{
	sbi(TCCR2A,COM2B1);
     508:	e0 eb       	ldi	r30, 0xB0	; 176
     50a:	f0 e0       	ldi	r31, 0x00	; 0
     50c:	80 81       	ld	r24, Z
     50e:	80 62       	ori	r24, 0x20	; 32
     510:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B0);
     512:	80 81       	ld	r24, Z
     514:	8f 7e       	andi	r24, 0xEF	; 239
     516:	80 83       	st	Z, r24
}
     518:	08 95       	ret

0000051a <PWM_timer3_On_E3>:
void PWM_timer3_On_E3(void)
{
	sbi(TCCR3A,COM3A1);
     51a:	e0 e9       	ldi	r30, 0x90	; 144
     51c:	f0 e0       	ldi	r31, 0x00	; 0
     51e:	80 81       	ld	r24, Z
     520:	80 68       	ori	r24, 0x80	; 128
     522:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3A0);
     524:	80 81       	ld	r24, Z
     526:	8f 7b       	andi	r24, 0xBF	; 191
     528:	80 83       	st	Z, r24
}
     52a:	08 95       	ret

0000052c <PWM_timer3_On_E4>:
void PWM_timer3_On_E4(void)
{
	sbi(TCCR3A,COM3B1);
     52c:	e0 e9       	ldi	r30, 0x90	; 144
     52e:	f0 e0       	ldi	r31, 0x00	; 0
     530:	80 81       	ld	r24, Z
     532:	80 62       	ori	r24, 0x20	; 32
     534:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3B0);
     536:	80 81       	ld	r24, Z
     538:	8f 7e       	andi	r24, 0xEF	; 239
     53a:	80 83       	st	Z, r24
}
     53c:	08 95       	ret

0000053e <PWM_timer3_On_E5>:
void PWM_timer3_On_E5(void)
{
	sbi(TCCR3A,COM3C1);
     53e:	e0 e9       	ldi	r30, 0x90	; 144
     540:	f0 e0       	ldi	r31, 0x00	; 0
     542:	80 81       	ld	r24, Z
     544:	88 60       	ori	r24, 0x08	; 8
     546:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C0);
     548:	80 81       	ld	r24, Z
     54a:	8b 7f       	andi	r24, 0xFB	; 251
     54c:	80 83       	st	Z, r24
}
     54e:	08 95       	ret

00000550 <PWM_timer4_On_H3>:
void PWM_timer4_On_H3(void)
{
	sbi(TCCR4A,COM4A1);
     550:	e0 ea       	ldi	r30, 0xA0	; 160
     552:	f0 e0       	ldi	r31, 0x00	; 0
     554:	80 81       	ld	r24, Z
     556:	80 68       	ori	r24, 0x80	; 128
     558:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4A0);
     55a:	80 81       	ld	r24, Z
     55c:	8f 7b       	andi	r24, 0xBF	; 191
     55e:	80 83       	st	Z, r24
}
     560:	08 95       	ret

00000562 <PWM_timer4_On_H4>:
void PWM_timer4_On_H4(void)
{
	sbi(TCCR4A,COM4B1);
     562:	e0 ea       	ldi	r30, 0xA0	; 160
     564:	f0 e0       	ldi	r31, 0x00	; 0
     566:	80 81       	ld	r24, Z
     568:	80 62       	ori	r24, 0x20	; 32
     56a:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4B0);
     56c:	80 81       	ld	r24, Z
     56e:	8f 7e       	andi	r24, 0xEF	; 239
     570:	80 83       	st	Z, r24
}
     572:	08 95       	ret

00000574 <PWM_timer4_On_H5>:
void PWM_timer4_On_H5(void)
{
	sbi(TCCR4A,COM4C1);
     574:	e0 ea       	ldi	r30, 0xA0	; 160
     576:	f0 e0       	ldi	r31, 0x00	; 0
     578:	80 81       	ld	r24, Z
     57a:	88 60       	ori	r24, 0x08	; 8
     57c:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4C0);
     57e:	80 81       	ld	r24, Z
     580:	8b 7f       	andi	r24, 0xFB	; 251
     582:	80 83       	st	Z, r24
}
     584:	08 95       	ret

00000586 <PWM_timer1_Off_LED>:

//off commands
void PWM_timer1_Off_LED(void)
{
	cbi(TCCR1A,COM1B1);
     586:	e0 e8       	ldi	r30, 0x80	; 128
     588:	f0 e0       	ldi	r31, 0x00	; 0
     58a:	80 81       	ld	r24, Z
     58c:	8f 7d       	andi	r24, 0xDF	; 223
     58e:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B0);
     590:	80 81       	ld	r24, Z
     592:	8f 7e       	andi	r24, 0xEF	; 239
     594:	80 83       	st	Z, r24
}
     596:	08 95       	ret

00000598 <PWM_timer2_Off_H6>:
void PWM_timer2_Off_H6(void)
{
	cbi(TCCR2A,COM2B1);
     598:	e0 eb       	ldi	r30, 0xB0	; 176
     59a:	f0 e0       	ldi	r31, 0x00	; 0
     59c:	80 81       	ld	r24, Z
     59e:	8f 7d       	andi	r24, 0xDF	; 223
     5a0:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B0);
     5a2:	80 81       	ld	r24, Z
     5a4:	8f 7e       	andi	r24, 0xEF	; 239
     5a6:	80 83       	st	Z, r24
}
     5a8:	08 95       	ret

000005aa <PWM_timer3_Off_E3>:
void PWM_timer3_Off_E3(void)
{
	cbi(TCCR3A,COM3A1);
     5aa:	e0 e9       	ldi	r30, 0x90	; 144
     5ac:	f0 e0       	ldi	r31, 0x00	; 0
     5ae:	80 81       	ld	r24, Z
     5b0:	8f 77       	andi	r24, 0x7F	; 127
     5b2:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3A0);
     5b4:	80 81       	ld	r24, Z
     5b6:	8f 7b       	andi	r24, 0xBF	; 191
     5b8:	80 83       	st	Z, r24
}
     5ba:	08 95       	ret

000005bc <PWM_timer3_Off_E4>:
void PWM_timer3_Off_E4(void)
{
	cbi(TCCR3A,COM3B1);
     5bc:	e0 e9       	ldi	r30, 0x90	; 144
     5be:	f0 e0       	ldi	r31, 0x00	; 0
     5c0:	80 81       	ld	r24, Z
     5c2:	8f 7d       	andi	r24, 0xDF	; 223
     5c4:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3B0);
     5c6:	80 81       	ld	r24, Z
     5c8:	8f 7e       	andi	r24, 0xEF	; 239
     5ca:	80 83       	st	Z, r24
}
     5cc:	08 95       	ret

000005ce <PWM_timer3_Off_E5>:
void PWM_timer3_Off_E5(void)
{
	cbi(TCCR3A,COM3C1);
     5ce:	e0 e9       	ldi	r30, 0x90	; 144
     5d0:	f0 e0       	ldi	r31, 0x00	; 0
     5d2:	80 81       	ld	r24, Z
     5d4:	87 7f       	andi	r24, 0xF7	; 247
     5d6:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C0);
     5d8:	80 81       	ld	r24, Z
     5da:	8b 7f       	andi	r24, 0xFB	; 251
     5dc:	80 83       	st	Z, r24
}
     5de:	08 95       	ret

000005e0 <PWM_timer4_Off_H3>:
void PWM_timer4_Off_H3(void)
{
	cbi(TCCR4A,COM4A1);
     5e0:	e0 ea       	ldi	r30, 0xA0	; 160
     5e2:	f0 e0       	ldi	r31, 0x00	; 0
     5e4:	80 81       	ld	r24, Z
     5e6:	8f 77       	andi	r24, 0x7F	; 127
     5e8:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4A0);
     5ea:	80 81       	ld	r24, Z
     5ec:	8f 7b       	andi	r24, 0xBF	; 191
     5ee:	80 83       	st	Z, r24
}
     5f0:	08 95       	ret

000005f2 <PWM_timer4_Off_H4>:
void PWM_timer4_Off_H4(void)
{
	cbi(TCCR4A,COM4B1);
     5f2:	e0 ea       	ldi	r30, 0xA0	; 160
     5f4:	f0 e0       	ldi	r31, 0x00	; 0
     5f6:	80 81       	ld	r24, Z
     5f8:	8f 7d       	andi	r24, 0xDF	; 223
     5fa:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4B0);
     5fc:	80 81       	ld	r24, Z
     5fe:	8f 7e       	andi	r24, 0xEF	; 239
     600:	80 83       	st	Z, r24
}
     602:	08 95       	ret

00000604 <PWM_timer4_Off_H5>:
void PWM_timer4_Off_H5(void)
{
	cbi(TCCR4A,COM4C1);
     604:	e0 ea       	ldi	r30, 0xA0	; 160
     606:	f0 e0       	ldi	r31, 0x00	; 0
     608:	80 81       	ld	r24, Z
     60a:	87 7f       	andi	r24, 0xF7	; 247
     60c:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4C0);
     60e:	80 81       	ld	r24, Z
     610:	8b 7f       	andi	r24, 0xFB	; 251
     612:	80 83       	st	Z, r24
}
     614:	08 95       	ret

00000616 <PWM_timer1_Off_All>:


void PWM_timer1_Off_All(void)
{
	cbi(TCCR1A,PWM11);
     616:	e0 e8       	ldi	r30, 0x80	; 128
     618:	f0 e0       	ldi	r31, 0x00	; 0
     61a:	80 81       	ld	r24, Z
     61c:	8d 7f       	andi	r24, 0xFD	; 253
     61e:	80 83       	st	Z, r24
	cbi(TCCR1A,PWM10);
     620:	80 81       	ld	r24, Z
     622:	8e 7f       	andi	r24, 0xFE	; 254
     624:	80 83       	st	Z, r24
}

//off commands
void PWM_timer1_Off_LED(void)
{
	cbi(TCCR1A,COM1B1);
     626:	80 81       	ld	r24, Z
     628:	8f 7d       	andi	r24, 0xDF	; 223
     62a:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B0);
     62c:	80 81       	ld	r24, Z
     62e:	8f 7e       	andi	r24, 0xEF	; 239
     630:	80 83       	st	Z, r24
	cbi(TCCR1A,PWM11);
	cbi(TCCR1A,PWM10);
	//timer2PWMAOff();
	PWM_timer1_Off_LED();
	//timer2PWMCOff();
}
     632:	08 95       	ret

00000634 <PWM_timer2_Off_All>:
void PWM_timer2_Off_All(void)
{
	cbi(TCCR2A,PWM11);
     634:	e0 eb       	ldi	r30, 0xB0	; 176
     636:	f0 e0       	ldi	r31, 0x00	; 0
     638:	80 81       	ld	r24, Z
     63a:	8d 7f       	andi	r24, 0xFD	; 253
     63c:	80 83       	st	Z, r24
	cbi(TCCR2A,PWM10);
     63e:	80 81       	ld	r24, Z
     640:	8e 7f       	andi	r24, 0xFE	; 254
     642:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B1);
	cbi(TCCR1A,COM1B0);
}
void PWM_timer2_Off_H6(void)
{
	cbi(TCCR2A,COM2B1);
     644:	80 81       	ld	r24, Z
     646:	8f 7d       	andi	r24, 0xDF	; 223
     648:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B0);
     64a:	80 81       	ld	r24, Z
     64c:	8f 7e       	andi	r24, 0xEF	; 239
     64e:	80 83       	st	Z, r24
	cbi(TCCR2A,PWM11);
	cbi(TCCR2A,PWM10);
	//timer2PWMAOff();
	PWM_timer2_Off_H6();
	//timer2PWMCOff();
}
     650:	08 95       	ret

00000652 <PWM_timer3_Off_All>:
void PWM_timer3_Off_All(void)
{
	cbi(TCCR3A,PWM11);
     652:	e0 e9       	ldi	r30, 0x90	; 144
     654:	f0 e0       	ldi	r31, 0x00	; 0
     656:	80 81       	ld	r24, Z
     658:	8d 7f       	andi	r24, 0xFD	; 253
     65a:	80 83       	st	Z, r24
	cbi(TCCR3A,PWM10);
     65c:	80 81       	ld	r24, Z
     65e:	8e 7f       	andi	r24, 0xFE	; 254
     660:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B1);
	cbi(TCCR2A,COM2B0);
}
void PWM_timer3_Off_E3(void)
{
	cbi(TCCR3A,COM3A1);
     662:	80 81       	ld	r24, Z
     664:	8f 77       	andi	r24, 0x7F	; 127
     666:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3A0);
     668:	80 81       	ld	r24, Z
     66a:	8f 7b       	andi	r24, 0xBF	; 191
     66c:	80 83       	st	Z, r24
}
void PWM_timer3_Off_E4(void)
{
	cbi(TCCR3A,COM3B1);
     66e:	80 81       	ld	r24, Z
     670:	8f 7d       	andi	r24, 0xDF	; 223
     672:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3B0);
     674:	80 81       	ld	r24, Z
     676:	8f 7e       	andi	r24, 0xEF	; 239
     678:	80 83       	st	Z, r24
}
void PWM_timer3_Off_E5(void)
{
	cbi(TCCR3A,COM3C1);
     67a:	80 81       	ld	r24, Z
     67c:	87 7f       	andi	r24, 0xF7	; 247
     67e:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C0);
     680:	80 81       	ld	r24, Z
     682:	8b 7f       	andi	r24, 0xFB	; 251
     684:	80 83       	st	Z, r24
	//timer2PWMAOff();
	PWM_timer3_Off_E3();
	PWM_timer3_Off_E4();
	PWM_timer3_Off_E5();
	//timer2PWMCOff();
}
     686:	08 95       	ret

00000688 <PWM_timer4_Off_All>:
void PWM_timer4_Off_All(void)
{
	cbi(TCCR4A,PWM11);
     688:	e0 ea       	ldi	r30, 0xA0	; 160
     68a:	f0 e0       	ldi	r31, 0x00	; 0
     68c:	80 81       	ld	r24, Z
     68e:	8d 7f       	andi	r24, 0xFD	; 253
     690:	80 83       	st	Z, r24
	cbi(TCCR4A,PWM10);
     692:	80 81       	ld	r24, Z
     694:	8e 7f       	andi	r24, 0xFE	; 254
     696:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C1);
	cbi(TCCR3A,COM3C0);
}
void PWM_timer4_Off_H3(void)
{
	cbi(TCCR4A,COM4A1);
     698:	80 81       	ld	r24, Z
     69a:	8f 77       	andi	r24, 0x7F	; 127
     69c:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4A0);
     69e:	80 81       	ld	r24, Z
     6a0:	8f 7b       	andi	r24, 0xBF	; 191
     6a2:	80 83       	st	Z, r24
}
void PWM_timer4_Off_H4(void)
{
	cbi(TCCR4A,COM4B1);
     6a4:	80 81       	ld	r24, Z
     6a6:	8f 7d       	andi	r24, 0xDF	; 223
     6a8:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4B0);
     6aa:	80 81       	ld	r24, Z
     6ac:	8f 7e       	andi	r24, 0xEF	; 239
     6ae:	80 83       	st	Z, r24
}
void PWM_timer4_Off_H5(void)
{
	cbi(TCCR4A,COM4C1);
     6b0:	80 81       	ld	r24, Z
     6b2:	87 7f       	andi	r24, 0xF7	; 247
     6b4:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4C0);
     6b6:	80 81       	ld	r24, Z
     6b8:	8b 7f       	andi	r24, 0xFB	; 251
     6ba:	80 83       	st	Z, r24
	//timer2PWMAOff();
	PWM_timer4_Off_H3();
	PWM_timer4_Off_H4();
	PWM_timer4_Off_H5();
	//timer2PWMCOff();
}
     6bc:	08 95       	ret

000006be <PWM_timer1_Set_LED>:
// this PWM output is generated on OC2B pin
// NOTE:	pwmDuty should be in the range 0-255 for 8bit PWM
//			pwmDuty should be in the range 0-511 for 9bit PWM
//			pwmDuty should be in the range 0-1023 for 10bit PWM
void PWM_timer1_Set_LED(u16 pwmDuty)
	{OCR1B = pwmDuty;}
     6be:	90 93 8b 00 	sts	0x008B, r25
     6c2:	80 93 8a 00 	sts	0x008A, r24
     6c6:	08 95       	ret

000006c8 <PWM_timer2_Set_H6>:
void PWM_timer2_Set_H6(u16 pwmDuty)
	{OCR2B = pwmDuty;}
     6c8:	80 93 b4 00 	sts	0x00B4, r24
     6cc:	08 95       	ret

000006ce <PWM_timer3_Set_E3>:
void PWM_timer3_Set_E3(u16 pwmDuty)
	{OCR3A = pwmDuty;}
     6ce:	90 93 99 00 	sts	0x0099, r25
     6d2:	80 93 98 00 	sts	0x0098, r24
     6d6:	08 95       	ret

000006d8 <PWM_timer3_Set_E4>:
void PWM_timer3_Set_E4(u16 pwmDuty)
	{OCR3B = pwmDuty;}
     6d8:	90 93 9b 00 	sts	0x009B, r25
     6dc:	80 93 9a 00 	sts	0x009A, r24
     6e0:	08 95       	ret

000006e2 <PWM_timer3_Set_E5>:
void PWM_timer3_Set_E5(u16 pwmDuty)
	{OCR3C = pwmDuty;}
     6e2:	90 93 9d 00 	sts	0x009D, r25
     6e6:	80 93 9c 00 	sts	0x009C, r24
     6ea:	08 95       	ret

000006ec <PWM_timer4_Set_H3>:
void PWM_timer4_Set_H3(u16 pwmDuty)
	{OCR4A = pwmDuty;}
     6ec:	90 93 a9 00 	sts	0x00A9, r25
     6f0:	80 93 a8 00 	sts	0x00A8, r24
     6f4:	08 95       	ret

000006f6 <PWM_timer4_Set_H4>:
void PWM_timer4_Set_H4(u16 pwmDuty)
	{OCR4B = pwmDuty;}
     6f6:	90 93 ab 00 	sts	0x00AB, r25
     6fa:	80 93 aa 00 	sts	0x00AA, r24
     6fe:	08 95       	ret

00000700 <PWM_timer4_Set_H5>:
void PWM_timer4_Set_H5(u16 pwmDuty)
	{OCR4C = pwmDuty;}
     700:	90 93 ad 00 	sts	0x00AD, r25
     704:	80 93 ac 00 	sts	0x00AC, r24
     708:	08 95       	ret

0000070a <configure_ports>:
	//cbi(DDRG, PG5);  //set G5 as input pin

	//ANALOG PORTS
	//useful for sensors, SharpIR, photoresistors, etc.
	//analog ports can be configured as digital ports if desired
	DDRF = 0b00000000;  //configure all F ports for input				0x00
     70a:	10 ba       	out	0x10, r1	; 16
	PORTF = 0b00000000; //make sure pull-up resistors are turned off	0x00
     70c:	11 ba       	out	0x11, r1	; 17
	DDRK = 0b00000000;  //configure all K ports for input				0x00
     70e:	10 92 07 01 	sts	0x0107, r1
	PORTK = 0b00000000; //make sure pull-up resistors are turned off	0x00
     712:	10 92 08 01 	sts	0x0108, r1

	//DIGITAL PORTS
	//useful for servos, PWM, LED's, UART, interrupts, timers
	DDRA = 0b11111111;  //configure ports for output
     716:	9f ef       	ldi	r25, 0xFF	; 255
     718:	91 b9       	out	0x01, r25	; 1
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	//PORTB reserved for programmer (use programmer pins if you know what you are doing)
	DDRB = _BV (PB6);	//PB6 is LED, hold low to turn it on
     71a:	80 e4       	ldi	r24, 0x40	; 64
     71c:	84 b9       	out	0x04, r24	; 4
	DDRC = 0b11111111;  //configure ports for output
     71e:	97 b9       	out	0x07, r25	; 7
	//       ||||\______3: 
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 	
	sbi(PORTD, PD0); // SCL pull-up
     720:	58 9a       	sbi	0x0b, 0	; 11
	sbi(PORTD, PD1); // SDA pull-up
     722:	59 9a       	sbi	0x0b, 1	; 11
	DDRD = 0b11110011;  //configure ports for output
     724:	83 ef       	ldi	r24, 0xF3	; 243
     726:	8a b9       	out	0x0a, r24	; 10
	//       ||||\______3: serial TXD1, output -> 1
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: timer0
	DDRE = 0b11111110;  //configure ports for output
     728:	8e ef       	ldi	r24, 0xFE	; 254
     72a:	8d b9       	out	0x0d, r24	; 13
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	//cbi(PORTG, PG5);  // disable pull-up resistor for Axon v1e and earlier
	sbi(PORTG, PG5);  // enable pull-up resistor for v1f and later
     72c:	a5 9a       	sbi	0x14, 5	; 20
	cbi(DDRG, PG5);	//PG5 is for the button, make a digital input
     72e:	9d 98       	cbi	0x13, 5	; 19
	//note that button actions are inverted between both versions!!!
	DDRH = 0b11111110;  //configure ports for output
     730:	80 93 01 01 	sts	0x0101, r24
	//       ||||\______3: 
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	DDRJ = 0b11111110;  //configure ports for output
     734:	80 93 04 01 	sts	0x0104, r24
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	//PORTL has no headers
	};
     738:	08 95       	ret

0000073a <delay_cycles>:
void delay_cycles(unsigned long int cycles)
	{
	cycles=cycles;//doubled frequency but too lazy to change times
	while(cycles > 0)
		cycles--;
	}
     73a:	08 95       	ret

0000073c <LED_off>:


//***************STATUS LED**************
//tank test
void LED_off(void)
	{PORT_ON(PORTB,6);}
     73c:	2e 9a       	sbi	0x05, 6	; 5
     73e:	08 95       	ret

00000740 <LED_on>:
void LED_on(void)
	{PORT_OFF(PORTB,6);}
     740:	2e 98       	cbi	0x05, 6	; 5
     742:	08 95       	ret

00000744 <button_pressed>:


//*****************BUTTON****************
int button_pressed(void)
	{
	return (bit_is_clear(PING, 5));
     744:	22 b3       	in	r18, 0x12	; 18
     746:	30 e0       	ldi	r19, 0x00	; 0
     748:	85 e0       	ldi	r24, 0x05	; 5
     74a:	36 95       	lsr	r19
     74c:	27 95       	ror	r18
     74e:	8a 95       	dec	r24
     750:	e1 f7       	brne	.-8      	; 0x74a <button_pressed+0x6>
     752:	20 95       	com	r18
     754:	30 95       	com	r19
     756:	21 70       	andi	r18, 0x01	; 1
     758:	30 70       	andi	r19, 0x00	; 0
	//return ((PING) & (1<<PG5));//old version, went high when button pushed
	}
     75a:	c9 01       	movw	r24, r18
     75c:	08 95       	ret

0000075e <cos_SoR>:
signed int angtable[73]={100,100,98,97,94,91,87,82,77,71,64,57,50,42,34,26,17,9,0,-9,-17,-26,-34,-42,-50,-57,-64,-71,-77,-82,-87,-91,-94,-97,-98,-100,
						 -100,-100,-98,-97,-94,-91,-87,-82,-77,-71,-64,-57,-50,-42,-34,-26,-17,-9,0,9,17,26,34,42,50,57,64,71,77,82,87,91,94,97,98,100,100};

signed int cos_SoR(long signed int degrees)//returns cos*100
	{
	if (degrees >= 0)//positive angles
     75e:	97 fd       	sbrc	r25, 7
     760:	10 c0       	rjmp	.+32     	; 0x782 <cos_SoR+0x24>
		return angtable[degrees/5];
     762:	25 e0       	ldi	r18, 0x05	; 5
     764:	30 e0       	ldi	r19, 0x00	; 0
     766:	40 e0       	ldi	r20, 0x00	; 0
     768:	50 e0       	ldi	r21, 0x00	; 0
     76a:	0e 94 be 30 	call	0x617c	; 0x617c <__divmodsi4>
     76e:	da 01       	movw	r26, r20
     770:	c9 01       	movw	r24, r18
     772:	88 0f       	add	r24, r24
     774:	99 1f       	adc	r25, r25
     776:	80 50       	subi	r24, 0x00	; 0
     778:	9e 4f       	sbci	r25, 0xFE	; 254
     77a:	fc 01       	movw	r30, r24
     77c:	20 81       	ld	r18, Z
     77e:	31 81       	ldd	r19, Z+1	; 0x01
     780:	17 c0       	rjmp	.+46     	; 0x7b0 <cos_SoR+0x52>
	else
		return -angtable[72-(-degrees)/5];
     782:	25 e0       	ldi	r18, 0x05	; 5
     784:	30 e0       	ldi	r19, 0x00	; 0
     786:	40 e0       	ldi	r20, 0x00	; 0
     788:	50 e0       	ldi	r21, 0x00	; 0
     78a:	0e 94 be 30 	call	0x617c	; 0x617c <__divmodsi4>
     78e:	da 01       	movw	r26, r20
     790:	c9 01       	movw	r24, r18
     792:	88 5b       	subi	r24, 0xB8	; 184
     794:	9f 4f       	sbci	r25, 0xFF	; 255
     796:	af 4f       	sbci	r26, 0xFF	; 255
     798:	bf 4f       	sbci	r27, 0xFF	; 255
     79a:	88 0f       	add	r24, r24
     79c:	99 1f       	adc	r25, r25
     79e:	80 50       	subi	r24, 0x00	; 0
     7a0:	9e 4f       	sbci	r25, 0xFE	; 254
     7a2:	fc 01       	movw	r30, r24
     7a4:	80 81       	ld	r24, Z
     7a6:	91 81       	ldd	r25, Z+1	; 0x01
     7a8:	22 27       	eor	r18, r18
     7aa:	33 27       	eor	r19, r19
     7ac:	28 1b       	sub	r18, r24
     7ae:	39 0b       	sbc	r19, r25
	}
     7b0:	c9 01       	movw	r24, r18
     7b2:	08 95       	ret

000007b4 <sin_SoR>:

signed int sin_SoR(long signed int degrees)//returns sin*100
	{
	degrees=degrees - 90;//phase shift 90 degrees
     7b4:	6a 55       	subi	r22, 0x5A	; 90
     7b6:	70 40       	sbci	r23, 0x00	; 0
     7b8:	80 40       	sbci	r24, 0x00	; 0
     7ba:	90 40       	sbci	r25, 0x00	; 0

	if (degrees >= 0)//positive angles
     7bc:	97 fd       	sbrc	r25, 7
     7be:	10 c0       	rjmp	.+32     	; 0x7e0 <sin_SoR+0x2c>
		return angtable[degrees/5];
     7c0:	25 e0       	ldi	r18, 0x05	; 5
     7c2:	30 e0       	ldi	r19, 0x00	; 0
     7c4:	40 e0       	ldi	r20, 0x00	; 0
     7c6:	50 e0       	ldi	r21, 0x00	; 0
     7c8:	0e 94 be 30 	call	0x617c	; 0x617c <__divmodsi4>
     7cc:	da 01       	movw	r26, r20
     7ce:	c9 01       	movw	r24, r18
     7d0:	88 0f       	add	r24, r24
     7d2:	99 1f       	adc	r25, r25
     7d4:	80 50       	subi	r24, 0x00	; 0
     7d6:	9e 4f       	sbci	r25, 0xFE	; 254
     7d8:	fc 01       	movw	r30, r24
     7da:	20 81       	ld	r18, Z
     7dc:	31 81       	ldd	r19, Z+1	; 0x01
     7de:	17 c0       	rjmp	.+46     	; 0x80e <sin_SoR+0x5a>
	else
		return -angtable[72-(-degrees)/5];
     7e0:	25 e0       	ldi	r18, 0x05	; 5
     7e2:	30 e0       	ldi	r19, 0x00	; 0
     7e4:	40 e0       	ldi	r20, 0x00	; 0
     7e6:	50 e0       	ldi	r21, 0x00	; 0
     7e8:	0e 94 be 30 	call	0x617c	; 0x617c <__divmodsi4>
     7ec:	da 01       	movw	r26, r20
     7ee:	c9 01       	movw	r24, r18
     7f0:	88 5b       	subi	r24, 0xB8	; 184
     7f2:	9f 4f       	sbci	r25, 0xFF	; 255
     7f4:	af 4f       	sbci	r26, 0xFF	; 255
     7f6:	bf 4f       	sbci	r27, 0xFF	; 255
     7f8:	88 0f       	add	r24, r24
     7fa:	99 1f       	adc	r25, r25
     7fc:	80 50       	subi	r24, 0x00	; 0
     7fe:	9e 4f       	sbci	r25, 0xFE	; 254
     800:	fc 01       	movw	r30, r24
     802:	80 81       	ld	r24, Z
     804:	91 81       	ldd	r25, Z+1	; 0x01
     806:	22 27       	eor	r18, r18
     808:	33 27       	eor	r19, r19
     80a:	28 1b       	sub	r18, r24
     80c:	39 0b       	sbc	r19, r25
	}
     80e:	c9 01       	movw	r24, r18
     810:	08 95       	ret

00000812 <tan_SoR>:

signed int tan_SoR(long signed int degrees)//returns tan * 10
	{
     812:	cf 92       	push	r12
     814:	df 92       	push	r13
     816:	ef 92       	push	r14
     818:	ff 92       	push	r15
     81a:	0f 93       	push	r16
     81c:	1f 93       	push	r17
     81e:	6b 01       	movw	r12, r22
     820:	7c 01       	movw	r14, r24
	//tan(x) = sin(x)/cos(x)
	if (degrees == 90 || degrees == -90 || degrees == 270 || degrees == -270)//blows up
     822:	8a e5       	ldi	r24, 0x5A	; 90
     824:	c8 16       	cp	r12, r24
     826:	d1 04       	cpc	r13, r1
     828:	e1 04       	cpc	r14, r1
     82a:	f1 04       	cpc	r15, r1
     82c:	a1 f1       	breq	.+104    	; 0x896 <tan_SoR+0x84>
     82e:	86 ea       	ldi	r24, 0xA6	; 166
     830:	c8 16       	cp	r12, r24
     832:	8f ef       	ldi	r24, 0xFF	; 255
     834:	d8 06       	cpc	r13, r24
     836:	8f ef       	ldi	r24, 0xFF	; 255
     838:	e8 06       	cpc	r14, r24
     83a:	8f ef       	ldi	r24, 0xFF	; 255
     83c:	f8 06       	cpc	r15, r24
     83e:	59 f1       	breq	.+86     	; 0x896 <tan_SoR+0x84>
     840:	8e e0       	ldi	r24, 0x0E	; 14
     842:	c8 16       	cp	r12, r24
     844:	81 e0       	ldi	r24, 0x01	; 1
     846:	d8 06       	cpc	r13, r24
     848:	80 e0       	ldi	r24, 0x00	; 0
     84a:	e8 06       	cpc	r14, r24
     84c:	80 e0       	ldi	r24, 0x00	; 0
     84e:	f8 06       	cpc	r15, r24
     850:	11 f1       	breq	.+68     	; 0x896 <tan_SoR+0x84>
     852:	82 ef       	ldi	r24, 0xF2	; 242
     854:	c8 16       	cp	r12, r24
     856:	8e ef       	ldi	r24, 0xFE	; 254
     858:	d8 06       	cpc	r13, r24
     85a:	8f ef       	ldi	r24, 0xFF	; 255
     85c:	e8 06       	cpc	r14, r24
     85e:	8f ef       	ldi	r24, 0xFF	; 255
     860:	f8 06       	cpc	r15, r24
     862:	c9 f0       	breq	.+50     	; 0x896 <tan_SoR+0x84>
		return 0;//what else should I return?!?!?
	return sin_SoR(degrees)/cos_SoR(degrees)*10;
     864:	c7 01       	movw	r24, r14
     866:	b6 01       	movw	r22, r12
     868:	0e 94 da 03 	call	0x7b4	; 0x7b4 <sin_SoR>
     86c:	8c 01       	movw	r16, r24
     86e:	c7 01       	movw	r24, r14
     870:	b6 01       	movw	r22, r12
     872:	0e 94 af 03 	call	0x75e	; 0x75e <cos_SoR>
     876:	bc 01       	movw	r22, r24
     878:	c8 01       	movw	r24, r16
     87a:	0e 94 89 30 	call	0x6112	; 0x6112 <__divmodhi4>
     87e:	cb 01       	movw	r24, r22
     880:	9b 01       	movw	r18, r22
     882:	73 e0       	ldi	r23, 0x03	; 3
     884:	22 0f       	add	r18, r18
     886:	33 1f       	adc	r19, r19
     888:	7a 95       	dec	r23
     88a:	e1 f7       	brne	.-8      	; 0x884 <tan_SoR+0x72>
     88c:	88 0f       	add	r24, r24
     88e:	99 1f       	adc	r25, r25
     890:	28 0f       	add	r18, r24
     892:	39 1f       	adc	r19, r25
     894:	02 c0       	rjmp	.+4      	; 0x89a <tan_SoR+0x88>
     896:	20 e0       	ldi	r18, 0x00	; 0
     898:	30 e0       	ldi	r19, 0x00	; 0
	}
     89a:	c9 01       	movw	r24, r18
     89c:	1f 91       	pop	r17
     89e:	0f 91       	pop	r16
     8a0:	ff 90       	pop	r15
     8a2:	ef 90       	pop	r14
     8a4:	df 90       	pop	r13
     8a6:	cf 90       	pop	r12
     8a8:	08 95       	ret

000008aa <prvPWMSetup>:
//-----------------------------**&&**


void prvPWMSetup(){

	PWM_Init_timer3_E4(10); // Left wheel
     8aa:	8a e0       	ldi	r24, 0x0A	; 10
     8ac:	0e 94 78 01 	call	0x2f0	; 0x2f0 <PWM_Init_timer3_E4>
	PWM_Init_timer3_E3(10); // Right wheel
     8b0:	8a e0       	ldi	r24, 0x0A	; 10
     8b2:	0e 94 58 01 	call	0x2b0	; 0x2b0 <PWM_Init_timer3_E3>
	PWM_Init_timer4_H3(10);	// Left sprayer
     8b6:	8a e0       	ldi	r24, 0x0A	; 10
     8b8:	0e 94 b8 01 	call	0x370	; 0x370 <PWM_Init_timer4_H3>
	PWM_Init_timer4_H4(10);	// Right sprayer
     8bc:	8a e0       	ldi	r24, 0x0A	; 10
     8be:	0e 94 d8 01 	call	0x3b0	; 0x3b0 <PWM_Init_timer4_H4>

}
     8c2:	08 95       	ret

000008c4 <char2hex>:

char char2hex(char c){
     8c4:	98 2f       	mov	r25, r24
	
	if((c > 47) && (c <58)){
     8c6:	80 53       	subi	r24, 0x30	; 48
     8c8:	8a 30       	cpi	r24, 0x0A	; 10
     8ca:	38 f0       	brcs	.+14     	; 0x8da <char2hex+0x16>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     8cc:	81 51       	subi	r24, 0x11	; 17
     8ce:	86 30       	cpi	r24, 0x06	; 6
     8d0:	10 f0       	brcs	.+4      	; 0x8d6 <char2hex+0x12>
     8d2:	89 2f       	mov	r24, r25
     8d4:	08 95       	ret
		c -= 55;
     8d6:	89 2f       	mov	r24, r25
     8d8:	87 53       	subi	r24, 0x37	; 55
	}
	return c;
}
     8da:	08 95       	ret

000008dc <retConv_s16>:

s16 retConv_s16(char* ch_head){
     8dc:	fc 01       	movw	r30, r24

	s16 int_val = 0x0000;
	char iv1 = *(ch_head);
     8de:	90 81       	ld	r25, Z
	char iv2 = *(ch_head + 1);
     8e0:	21 81       	ldd	r18, Z+1	; 0x01
	char iv3 = *(ch_head + 2);
     8e2:	42 81       	ldd	r20, Z+2	; 0x02
	char iv4 = *(ch_head + 3);
     8e4:	53 81       	ldd	r21, Z+3	; 0x03

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     8e6:	89 2f       	mov	r24, r25
     8e8:	80 53       	subi	r24, 0x30	; 48
     8ea:	8a 30       	cpi	r24, 0x0A	; 10
     8ec:	10 f4       	brcc	.+4      	; 0x8f2 <retConv_s16+0x16>
     8ee:	98 2f       	mov	r25, r24
     8f0:	05 c0       	rjmp	.+10     	; 0x8fc <retConv_s16+0x20>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     8f2:	89 2f       	mov	r24, r25
     8f4:	81 54       	subi	r24, 0x41	; 65
     8f6:	86 30       	cpi	r24, 0x06	; 6
     8f8:	08 f4       	brcc	.+2      	; 0x8fc <retConv_s16+0x20>
		c -= 55;
     8fa:	97 53       	subi	r25, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     8fc:	82 2f       	mov	r24, r18
     8fe:	80 53       	subi	r24, 0x30	; 48
     900:	8a 30       	cpi	r24, 0x0A	; 10
     902:	10 f4       	brcc	.+4      	; 0x908 <retConv_s16+0x2c>
     904:	28 2f       	mov	r18, r24
     906:	05 c0       	rjmp	.+10     	; 0x912 <retConv_s16+0x36>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     908:	82 2f       	mov	r24, r18
     90a:	81 54       	subi	r24, 0x41	; 65
     90c:	86 30       	cpi	r24, 0x06	; 6
     90e:	08 f4       	brcc	.+2      	; 0x912 <retConv_s16+0x36>
		c -= 55;
     910:	27 53       	subi	r18, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     912:	84 2f       	mov	r24, r20
     914:	80 53       	subi	r24, 0x30	; 48
     916:	8a 30       	cpi	r24, 0x0A	; 10
     918:	10 f4       	brcc	.+4      	; 0x91e <retConv_s16+0x42>
     91a:	48 2f       	mov	r20, r24
     91c:	05 c0       	rjmp	.+10     	; 0x928 <retConv_s16+0x4c>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     91e:	84 2f       	mov	r24, r20
     920:	81 54       	subi	r24, 0x41	; 65
     922:	86 30       	cpi	r24, 0x06	; 6
     924:	08 f4       	brcc	.+2      	; 0x928 <retConv_s16+0x4c>
		c -= 55;
     926:	47 53       	subi	r20, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     928:	85 2f       	mov	r24, r21
     92a:	80 53       	subi	r24, 0x30	; 48
     92c:	8a 30       	cpi	r24, 0x0A	; 10
     92e:	10 f4       	brcc	.+4      	; 0x934 <retConv_s16+0x58>
     930:	58 2f       	mov	r21, r24
     932:	05 c0       	rjmp	.+10     	; 0x93e <retConv_s16+0x62>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     934:	85 2f       	mov	r24, r21
     936:	81 54       	subi	r24, 0x41	; 65
     938:	86 30       	cpi	r24, 0x06	; 6
     93a:	08 f4       	brcc	.+2      	; 0x93e <retConv_s16+0x62>
		c -= 55;
     93c:	57 53       	subi	r21, 0x37	; 55
	iv2 = char2hex(iv2);
	iv3 = char2hex(iv3);
	iv4 = char2hex(iv4);

	int_val = (int_val | iv1);
	int_val = ((int_val<<4) | iv2);
     93e:	30 e0       	ldi	r19, 0x00	; 0
     940:	89 2f       	mov	r24, r25
     942:	90 e0       	ldi	r25, 0x00	; 0
     944:	a4 e0       	ldi	r26, 0x04	; 4
     946:	88 0f       	add	r24, r24
     948:	99 1f       	adc	r25, r25
     94a:	aa 95       	dec	r26
     94c:	e1 f7       	brne	.-8      	; 0x946 <retConv_s16+0x6a>
     94e:	28 2b       	or	r18, r24
     950:	39 2b       	or	r19, r25
	int_val = ((int_val<<4) | iv3);
     952:	f4 e0       	ldi	r31, 0x04	; 4
     954:	22 0f       	add	r18, r18
     956:	33 1f       	adc	r19, r19
     958:	fa 95       	dec	r31
     95a:	e1 f7       	brne	.-8      	; 0x954 <retConv_s16+0x78>
     95c:	84 2f       	mov	r24, r20
     95e:	90 e0       	ldi	r25, 0x00	; 0
     960:	82 2b       	or	r24, r18
     962:	93 2b       	or	r25, r19
	int_val = ((int_val<<4) | iv4);
     964:	e4 e0       	ldi	r30, 0x04	; 4
     966:	88 0f       	add	r24, r24
     968:	99 1f       	adc	r25, r25
     96a:	ea 95       	dec	r30
     96c:	e1 f7       	brne	.-8      	; 0x966 <retConv_s16+0x8a>
     96e:	25 2f       	mov	r18, r21
     970:	30 e0       	ldi	r19, 0x00	; 0
     972:	28 2b       	or	r18, r24
     974:	39 2b       	or	r19, r25
	return int_val;
}
     976:	c9 01       	movw	r24, r18
     978:	08 95       	ret

0000097a <retConv_s32>:

s32 retConv_s32(char* ch_head){
     97a:	ff 92       	push	r15
     97c:	0f 93       	push	r16
     97e:	1f 93       	push	r17
     980:	fc 01       	movw	r30, r24

	s32 int_val = 0x00000000;
	char iv1 = *(ch_head);
     982:	90 81       	ld	r25, Z
	char iv2 = *(ch_head + 1);
     984:	21 81       	ldd	r18, Z+1	; 0x01
	char iv3 = *(ch_head + 2);
     986:	62 81       	ldd	r22, Z+2	; 0x02
	char iv4 = *(ch_head + 3);
     988:	73 81       	ldd	r23, Z+3	; 0x03
	char iv5 = *(ch_head + 4);
     98a:	14 81       	ldd	r17, Z+4	; 0x04
	char iv6 = *(ch_head + 5);
     98c:	05 81       	ldd	r16, Z+5	; 0x05
	char iv7 = *(ch_head + 6);
     98e:	f6 80       	ldd	r15, Z+6	; 0x06
	char iv8 = *(ch_head + 7);
     990:	e7 81       	ldd	r30, Z+7	; 0x07

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     992:	89 2f       	mov	r24, r25
     994:	80 53       	subi	r24, 0x30	; 48
     996:	8a 30       	cpi	r24, 0x0A	; 10
     998:	10 f4       	brcc	.+4      	; 0x99e <retConv_s32+0x24>
     99a:	98 2f       	mov	r25, r24
     99c:	05 c0       	rjmp	.+10     	; 0x9a8 <retConv_s32+0x2e>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     99e:	89 2f       	mov	r24, r25
     9a0:	81 54       	subi	r24, 0x41	; 65
     9a2:	86 30       	cpi	r24, 0x06	; 6
     9a4:	08 f4       	brcc	.+2      	; 0x9a8 <retConv_s32+0x2e>
		c -= 55;
     9a6:	97 53       	subi	r25, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     9a8:	82 2f       	mov	r24, r18
     9aa:	80 53       	subi	r24, 0x30	; 48
     9ac:	8a 30       	cpi	r24, 0x0A	; 10
     9ae:	10 f4       	brcc	.+4      	; 0x9b4 <retConv_s32+0x3a>
     9b0:	28 2f       	mov	r18, r24
     9b2:	05 c0       	rjmp	.+10     	; 0x9be <retConv_s32+0x44>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     9b4:	82 2f       	mov	r24, r18
     9b6:	81 54       	subi	r24, 0x41	; 65
     9b8:	86 30       	cpi	r24, 0x06	; 6
     9ba:	08 f4       	brcc	.+2      	; 0x9be <retConv_s32+0x44>
		c -= 55;
     9bc:	27 53       	subi	r18, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     9be:	86 2f       	mov	r24, r22
     9c0:	80 53       	subi	r24, 0x30	; 48
     9c2:	8a 30       	cpi	r24, 0x0A	; 10
     9c4:	10 f4       	brcc	.+4      	; 0x9ca <retConv_s32+0x50>
     9c6:	68 2f       	mov	r22, r24
     9c8:	05 c0       	rjmp	.+10     	; 0x9d4 <retConv_s32+0x5a>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     9ca:	86 2f       	mov	r24, r22
     9cc:	81 54       	subi	r24, 0x41	; 65
     9ce:	86 30       	cpi	r24, 0x06	; 6
     9d0:	08 f4       	brcc	.+2      	; 0x9d4 <retConv_s32+0x5a>
		c -= 55;
     9d2:	67 53       	subi	r22, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     9d4:	87 2f       	mov	r24, r23
     9d6:	80 53       	subi	r24, 0x30	; 48
     9d8:	8a 30       	cpi	r24, 0x0A	; 10
     9da:	10 f4       	brcc	.+4      	; 0x9e0 <retConv_s32+0x66>
     9dc:	78 2f       	mov	r23, r24
     9de:	05 c0       	rjmp	.+10     	; 0x9ea <retConv_s32+0x70>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     9e0:	87 2f       	mov	r24, r23
     9e2:	81 54       	subi	r24, 0x41	; 65
     9e4:	86 30       	cpi	r24, 0x06	; 6
     9e6:	08 f4       	brcc	.+2      	; 0x9ea <retConv_s32+0x70>
		c -= 55;
     9e8:	77 53       	subi	r23, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     9ea:	81 2f       	mov	r24, r17
     9ec:	80 53       	subi	r24, 0x30	; 48
     9ee:	8a 30       	cpi	r24, 0x0A	; 10
     9f0:	10 f4       	brcc	.+4      	; 0x9f6 <retConv_s32+0x7c>
     9f2:	18 2f       	mov	r17, r24
     9f4:	05 c0       	rjmp	.+10     	; 0xa00 <retConv_s32+0x86>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     9f6:	81 2f       	mov	r24, r17
     9f8:	81 54       	subi	r24, 0x41	; 65
     9fa:	86 30       	cpi	r24, 0x06	; 6
     9fc:	08 f4       	brcc	.+2      	; 0xa00 <retConv_s32+0x86>
		c -= 55;
     9fe:	17 53       	subi	r17, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     a00:	80 2f       	mov	r24, r16
     a02:	80 53       	subi	r24, 0x30	; 48
     a04:	8a 30       	cpi	r24, 0x0A	; 10
     a06:	10 f4       	brcc	.+4      	; 0xa0c <retConv_s32+0x92>
     a08:	08 2f       	mov	r16, r24
     a0a:	05 c0       	rjmp	.+10     	; 0xa16 <retConv_s32+0x9c>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     a0c:	80 2f       	mov	r24, r16
     a0e:	81 54       	subi	r24, 0x41	; 65
     a10:	86 30       	cpi	r24, 0x06	; 6
     a12:	08 f4       	brcc	.+2      	; 0xa16 <retConv_s32+0x9c>
		c -= 55;
     a14:	07 53       	subi	r16, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     a16:	8f 2d       	mov	r24, r15
     a18:	80 53       	subi	r24, 0x30	; 48
     a1a:	8a 30       	cpi	r24, 0x0A	; 10
     a1c:	10 f4       	brcc	.+4      	; 0xa22 <retConv_s32+0xa8>
     a1e:	f8 2e       	mov	r15, r24
     a20:	06 c0       	rjmp	.+12     	; 0xa2e <retConv_s32+0xb4>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     a22:	8f 2d       	mov	r24, r15
     a24:	81 54       	subi	r24, 0x41	; 65
     a26:	86 30       	cpi	r24, 0x06	; 6
     a28:	10 f4       	brcc	.+4      	; 0xa2e <retConv_s32+0xb4>
		c -= 55;
     a2a:	89 ec       	ldi	r24, 0xC9	; 201
     a2c:	f8 0e       	add	r15, r24

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     a2e:	8e 2f       	mov	r24, r30
     a30:	80 53       	subi	r24, 0x30	; 48
     a32:	8a 30       	cpi	r24, 0x0A	; 10
     a34:	10 f4       	brcc	.+4      	; 0xa3a <retConv_s32+0xc0>
     a36:	e8 2f       	mov	r30, r24
     a38:	05 c0       	rjmp	.+10     	; 0xa44 <retConv_s32+0xca>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     a3a:	8e 2f       	mov	r24, r30
     a3c:	81 54       	subi	r24, 0x41	; 65
     a3e:	86 30       	cpi	r24, 0x06	; 6
     a40:	08 f4       	brcc	.+2      	; 0xa44 <retConv_s32+0xca>
		c -= 55;
     a42:	e7 53       	subi	r30, 0x37	; 55
	iv6 = char2hex(iv6);
	iv7 = char2hex(iv7);
	iv8 = char2hex(iv8);

	int_val = (int_val | iv1);
	int_val = ((int_val<<4) | iv2);
     a44:	30 e0       	ldi	r19, 0x00	; 0
     a46:	40 e0       	ldi	r20, 0x00	; 0
     a48:	50 e0       	ldi	r21, 0x00	; 0
     a4a:	89 2f       	mov	r24, r25
     a4c:	90 e0       	ldi	r25, 0x00	; 0
     a4e:	a0 e0       	ldi	r26, 0x00	; 0
     a50:	b0 e0       	ldi	r27, 0x00	; 0
     a52:	f4 e0       	ldi	r31, 0x04	; 4
     a54:	88 0f       	add	r24, r24
     a56:	99 1f       	adc	r25, r25
     a58:	aa 1f       	adc	r26, r26
     a5a:	bb 1f       	adc	r27, r27
     a5c:	fa 95       	dec	r31
     a5e:	d1 f7       	brne	.-12     	; 0xa54 <retConv_s32+0xda>
     a60:	28 2b       	or	r18, r24
     a62:	39 2b       	or	r19, r25
     a64:	4a 2b       	or	r20, r26
     a66:	5b 2b       	or	r21, r27
	int_val = ((int_val<<4) | iv3);
     a68:	a4 e0       	ldi	r26, 0x04	; 4
     a6a:	22 0f       	add	r18, r18
     a6c:	33 1f       	adc	r19, r19
     a6e:	44 1f       	adc	r20, r20
     a70:	55 1f       	adc	r21, r21
     a72:	aa 95       	dec	r26
     a74:	d1 f7       	brne	.-12     	; 0xa6a <retConv_s32+0xf0>
     a76:	86 2f       	mov	r24, r22
     a78:	90 e0       	ldi	r25, 0x00	; 0
     a7a:	a0 e0       	ldi	r26, 0x00	; 0
     a7c:	b0 e0       	ldi	r27, 0x00	; 0
     a7e:	82 2b       	or	r24, r18
     a80:	93 2b       	or	r25, r19
     a82:	a4 2b       	or	r26, r20
     a84:	b5 2b       	or	r27, r21
	int_val = ((int_val<<4) | iv4);
     a86:	f4 e0       	ldi	r31, 0x04	; 4
     a88:	88 0f       	add	r24, r24
     a8a:	99 1f       	adc	r25, r25
     a8c:	aa 1f       	adc	r26, r26
     a8e:	bb 1f       	adc	r27, r27
     a90:	fa 95       	dec	r31
     a92:	d1 f7       	brne	.-12     	; 0xa88 <retConv_s32+0x10e>
     a94:	27 2f       	mov	r18, r23
     a96:	30 e0       	ldi	r19, 0x00	; 0
     a98:	40 e0       	ldi	r20, 0x00	; 0
     a9a:	50 e0       	ldi	r21, 0x00	; 0
     a9c:	28 2b       	or	r18, r24
     a9e:	39 2b       	or	r19, r25
     aa0:	4a 2b       	or	r20, r26
     aa2:	5b 2b       	or	r21, r27
	int_val = ((int_val<<4) | iv5);
     aa4:	64 e0       	ldi	r22, 0x04	; 4
     aa6:	22 0f       	add	r18, r18
     aa8:	33 1f       	adc	r19, r19
     aaa:	44 1f       	adc	r20, r20
     aac:	55 1f       	adc	r21, r21
     aae:	6a 95       	dec	r22
     ab0:	d1 f7       	brne	.-12     	; 0xaa6 <retConv_s32+0x12c>
     ab2:	81 2f       	mov	r24, r17
     ab4:	90 e0       	ldi	r25, 0x00	; 0
     ab6:	a0 e0       	ldi	r26, 0x00	; 0
     ab8:	b0 e0       	ldi	r27, 0x00	; 0
     aba:	82 2b       	or	r24, r18
     abc:	93 2b       	or	r25, r19
     abe:	a4 2b       	or	r26, r20
     ac0:	b5 2b       	or	r27, r21
	int_val = ((int_val<<4) | iv6);
     ac2:	24 e0       	ldi	r18, 0x04	; 4
     ac4:	88 0f       	add	r24, r24
     ac6:	99 1f       	adc	r25, r25
     ac8:	aa 1f       	adc	r26, r26
     aca:	bb 1f       	adc	r27, r27
     acc:	2a 95       	dec	r18
     ace:	d1 f7       	brne	.-12     	; 0xac4 <retConv_s32+0x14a>
     ad0:	20 2f       	mov	r18, r16
     ad2:	30 e0       	ldi	r19, 0x00	; 0
     ad4:	40 e0       	ldi	r20, 0x00	; 0
     ad6:	50 e0       	ldi	r21, 0x00	; 0
     ad8:	28 2b       	or	r18, r24
     ada:	39 2b       	or	r19, r25
     adc:	4a 2b       	or	r20, r26
     ade:	5b 2b       	or	r21, r27
	int_val = ((int_val<<4) | iv7);
     ae0:	04 e0       	ldi	r16, 0x04	; 4
     ae2:	22 0f       	add	r18, r18
     ae4:	33 1f       	adc	r19, r19
     ae6:	44 1f       	adc	r20, r20
     ae8:	55 1f       	adc	r21, r21
     aea:	0a 95       	dec	r16
     aec:	d1 f7       	brne	.-12     	; 0xae2 <retConv_s32+0x168>
     aee:	8f 2d       	mov	r24, r15
     af0:	90 e0       	ldi	r25, 0x00	; 0
     af2:	a0 e0       	ldi	r26, 0x00	; 0
     af4:	b0 e0       	ldi	r27, 0x00	; 0
     af6:	82 2b       	or	r24, r18
     af8:	93 2b       	or	r25, r19
     afa:	a4 2b       	or	r26, r20
     afc:	b5 2b       	or	r27, r21
	int_val = ((int_val<<4) | iv8);
     afe:	14 e0       	ldi	r17, 0x04	; 4
     b00:	88 0f       	add	r24, r24
     b02:	99 1f       	adc	r25, r25
     b04:	aa 1f       	adc	r26, r26
     b06:	bb 1f       	adc	r27, r27
     b08:	1a 95       	dec	r17
     b0a:	d1 f7       	brne	.-12     	; 0xb00 <retConv_s32+0x186>
     b0c:	2e 2f       	mov	r18, r30
     b0e:	30 e0       	ldi	r19, 0x00	; 0
     b10:	40 e0       	ldi	r20, 0x00	; 0
     b12:	50 e0       	ldi	r21, 0x00	; 0
     b14:	28 2b       	or	r18, r24
     b16:	39 2b       	or	r19, r25
     b18:	4a 2b       	or	r20, r26
     b1a:	5b 2b       	or	r21, r27
	return int_val;
}
     b1c:	b9 01       	movw	r22, r18
     b1e:	ca 01       	movw	r24, r20
     b20:	1f 91       	pop	r17
     b22:	0f 91       	pop	r16
     b24:	ff 90       	pop	r15
     b26:	08 95       	ret

00000b28 <wheel_L>:
	{
	return 739.38*pow(value,-.8105);
	}
//***FROM THE SoR LIBRARIES

void wheel_L(signed int cmd_vel){
     b28:	9c 01       	movw	r18, r24
		if(cmd_vel > 36){cmd_vel = 36;}
     b2a:	85 32       	cpi	r24, 0x25	; 37
     b2c:	91 05       	cpc	r25, r1
     b2e:	1c f0       	brlt	.+6      	; 0xb36 <wheel_L+0xe>
     b30:	24 e2       	ldi	r18, 0x24	; 36
     b32:	30 e0       	ldi	r19, 0x00	; 0
     b34:	06 c0       	rjmp	.+12     	; 0xb42 <wheel_L+0x1a>
		if(cmd_vel < -36){cmd_vel = -36;}
     b36:	8f ef       	ldi	r24, 0xFF	; 255
     b38:	2c 3d       	cpi	r18, 0xDC	; 220
     b3a:	38 07       	cpc	r19, r24
     b3c:	14 f4       	brge	.+4      	; 0xb42 <wheel_L+0x1a>
     b3e:	2c ed       	ldi	r18, 0xDC	; 220
     b40:	3f ef       	ldi	r19, 0xFF	; 255
		rprintf("*** PWM: ");
		rprintfFloat(10, s_out);
		rprintf(" | %d ", (int)s_out); 
		rprintf(" ***LLL\n");
		*/
		taskENTER_CRITICAL();
     b42:	0f b6       	in	r0, 0x3f	; 63
     b44:	f8 94       	cli
     b46:	0f 92       	push	r0
		PWM_timer3_Set_E4((int)s_out);
     b48:	b9 01       	movw	r22, r18
     b4a:	88 27       	eor	r24, r24
     b4c:	77 fd       	sbrc	r23, 7
     b4e:	80 95       	com	r24
     b50:	98 2f       	mov	r25, r24
     b52:	0e 94 83 2d 	call	0x5b06	; 0x5b06 <__floatsisf>
     b56:	28 e4       	ldi	r18, 0x48	; 72
     b58:	30 e5       	ldi	r19, 0x50	; 80
     b5a:	4c ef       	ldi	r20, 0xFC	; 252
     b5c:	5e eb       	ldi	r21, 0xBE	; 190
     b5e:	0e 94 37 2e 	call	0x5c6e	; 0x5c6e <__mulsf3>
     b62:	2f e1       	ldi	r18, 0x1F	; 31
     b64:	35 e4       	ldi	r19, 0x45	; 69
     b66:	49 e3       	ldi	r20, 0x39	; 57
     b68:	53 e4       	ldi	r21, 0x43	; 67
     b6a:	0e 94 80 2c 	call	0x5900	; 0x5900 <__addsf3>
     b6e:	0e 94 50 2d 	call	0x5aa0	; 0x5aa0 <__fixsfsi>
void PWM_timer2_Set_H6(u16 pwmDuty)
	{OCR2B = pwmDuty;}
void PWM_timer3_Set_E3(u16 pwmDuty)
	{OCR3A = pwmDuty;}
void PWM_timer3_Set_E4(u16 pwmDuty)
	{OCR3B = pwmDuty;}
     b72:	70 93 9b 00 	sts	0x009B, r23
     b76:	60 93 9a 00 	sts	0x009A, r22
		taskEXIT_CRITICAL();
     b7a:	0f 90       	pop	r0
     b7c:	0f be       	out	0x3f, r0	; 63


}
     b7e:	08 95       	ret

00000b80 <wheel_R>:

void wheel_R(signed int cmd_vel){
     b80:	9c 01       	movw	r18, r24
		if(cmd_vel > 36){cmd_vel = 36;}
     b82:	85 32       	cpi	r24, 0x25	; 37
     b84:	91 05       	cpc	r25, r1
     b86:	1c f0       	brlt	.+6      	; 0xb8e <wheel_R+0xe>
     b88:	24 e2       	ldi	r18, 0x24	; 36
     b8a:	30 e0       	ldi	r19, 0x00	; 0
     b8c:	06 c0       	rjmp	.+12     	; 0xb9a <wheel_R+0x1a>
		if(cmd_vel < -36){cmd_vel = -36;}
     b8e:	8f ef       	ldi	r24, 0xFF	; 255
     b90:	2c 3d       	cpi	r18, 0xDC	; 220
     b92:	38 07       	cpc	r19, r24
     b94:	14 f4       	brge	.+4      	; 0xb9a <wheel_R+0x1a>
     b96:	2c ed       	ldi	r18, 0xDC	; 220
     b98:	3f ef       	ldi	r19, 0xFF	; 255
		rprintf("*** PWM: ");
		rprintfFloat(10, s_out);
		rprintf(" | %d ", (int)s_out); 
		rprintf(" ***RRR\n");
		*/
		taskENTER_CRITICAL();
     b9a:	0f b6       	in	r0, 0x3f	; 63
     b9c:	f8 94       	cli
     b9e:	0f 92       	push	r0
		PWM_timer3_Set_E3((int)s_out);
     ba0:	b9 01       	movw	r22, r18
     ba2:	88 27       	eor	r24, r24
     ba4:	77 fd       	sbrc	r23, 7
     ba6:	80 95       	com	r24
     ba8:	98 2f       	mov	r25, r24
     baa:	0e 94 83 2d 	call	0x5b06	; 0x5b06 <__floatsisf>
     bae:	21 e1       	ldi	r18, 0x11	; 17
     bb0:	37 ec       	ldi	r19, 0xC7	; 199
     bb2:	4a e0       	ldi	r20, 0x0A	; 10
     bb4:	5f eb       	ldi	r21, 0xBF	; 191
     bb6:	0e 94 37 2e 	call	0x5c6e	; 0x5c6e <__mulsf3>
     bba:	26 ef       	ldi	r18, 0xF6	; 246
     bbc:	38 e6       	ldi	r19, 0x68	; 104
     bbe:	4c e3       	ldi	r20, 0x3C	; 60
     bc0:	53 e4       	ldi	r21, 0x43	; 67
     bc2:	0e 94 80 2c 	call	0x5900	; 0x5900 <__addsf3>
     bc6:	0e 94 50 2d 	call	0x5aa0	; 0x5aa0 <__fixsfsi>
void PWM_timer1_Set_LED(u16 pwmDuty)
	{OCR1B = pwmDuty;}
void PWM_timer2_Set_H6(u16 pwmDuty)
	{OCR2B = pwmDuty;}
void PWM_timer3_Set_E3(u16 pwmDuty)
	{OCR3A = pwmDuty;}
     bca:	70 93 99 00 	sts	0x0099, r23
     bce:	60 93 98 00 	sts	0x0098, r22
		taskEXIT_CRITICAL();
     bd2:	0f 90       	pop	r0
     bd4:	0f be       	out	0x3f, r0	; 63


}
     bd6:	08 95       	ret

00000bd8 <num2char>:


}
*/

char num2char(char c){
     bd8:	98 2f       	mov	r25, r24
	
	if(c <10){
     bda:	8a 30       	cpi	r24, 0x0A	; 10
     bdc:	10 f4       	brcc	.+4      	; 0xbe2 <num2char+0xa>
		c += 48;
     bde:	90 5d       	subi	r25, 0xD0	; 208
     be0:	04 c0       	rjmp	.+8      	; 0xbea <num2char+0x12>
	}
	else if((c >= 10) && (c <= 16)){
     be2:	8a 50       	subi	r24, 0x0A	; 10
     be4:	87 30       	cpi	r24, 0x07	; 7
     be6:	08 f4       	brcc	.+2      	; 0xbea <num2char+0x12>
		c += 55;
     be8:	99 5c       	subi	r25, 0xC9	; 201
	}
	return c;
}
     bea:	89 2f       	mov	r24, r25
     bec:	08 95       	ret

00000bee <fwdSer_L>:
		
			//taskYIELD();
	//	}
		
}
void fwdSer_L(unsigned char c){
     bee:	98 2f       	mov	r25, r24
	static char v_flag;
	static char d_flag;
	static char vel_rough[4];  //store ascii chars
	static char dis_rough[8];  //store ascii chars
		//rprintf("%c",c);
		if(c != 0xff){
     bf0:	8f 3f       	cpi	r24, 0xFF	; 255
     bf2:	09 f4       	brne	.+2      	; 0xbf6 <fwdSer_L+0x8>
     bf4:	79 c0       	rjmp	.+242    	; 0xce8 <fwdSer_L+0xfa>
		//if the data isn't whitespace (0xff), post it
		//	rprintf("%c",c);

			if(c == 0x0A){lf_flag = SET;} //line feed detected, the character will be a 'D' or a 'V'
     bf6:	8a 30       	cpi	r24, 0x0A	; 10
     bf8:	21 f4       	brne	.+8      	; 0xc02 <fwdSer_L+0x14>
     bfa:	81 e0       	ldi	r24, 0x01	; 1
     bfc:	80 93 e3 02 	sts	0x02E3, r24
     c00:	33 c0       	rjmp	.+102    	; 0xc68 <fwdSer_L+0x7a>
	
			else if((lf_flag) && (c == 'V')){ //set velocity flag
     c02:	80 91 e3 02 	lds	r24, 0x02E3
     c06:	88 23       	and	r24, r24
     c08:	91 f0       	breq	.+36     	; 0xc2e <fwdSer_L+0x40>
     c0a:	96 35       	cpi	r25, 0x56	; 86
     c0c:	31 f4       	brne	.+12     	; 0xc1a <fwdSer_L+0x2c>
				v_flag = SET;
     c0e:	81 e0       	ldi	r24, 0x01	; 1
     c10:	80 93 e0 02 	sts	0x02E0, r24
				v_iter = 0;
     c14:	10 92 e2 02 	sts	0x02E2, r1
     c18:	07 c0       	rjmp	.+14     	; 0xc28 <fwdSer_L+0x3a>
				lf_flag = UNSET;
				return;
			} 
			else if((lf_flag) && (c == 'D')){ //set distance flag
     c1a:	94 34       	cpi	r25, 0x44	; 68
     c1c:	41 f4       	brne	.+16     	; 0xc2e <fwdSer_L+0x40>
				d_flag = SET;
     c1e:	81 e0       	ldi	r24, 0x01	; 1
     c20:	80 93 df 02 	sts	0x02DF, r24
				d_iter = 0;
     c24:	10 92 e1 02 	sts	0x02E1, r1
				lf_flag = UNSET;
     c28:	10 92 e3 02 	sts	0x02E3, r1
     c2c:	08 95       	ret
			//	rprintf("%c",c);
				return;
			}
			else if(v_flag){
     c2e:	80 91 e0 02 	lds	r24, 0x02E0
     c32:	88 23       	and	r24, r24
     c34:	59 f0       	breq	.+22     	; 0xc4c <fwdSer_L+0x5e>
				vel_rough[v_iter++] = c;	//store then increment	
     c36:	80 91 e2 02 	lds	r24, 0x02E2
     c3a:	e8 2f       	mov	r30, r24
     c3c:	f0 e0       	ldi	r31, 0x00	; 0
     c3e:	e5 52       	subi	r30, 0x25	; 37
     c40:	fd 4f       	sbci	r31, 0xFD	; 253
     c42:	90 83       	st	Z, r25
     c44:	8f 5f       	subi	r24, 0xFF	; 255
     c46:	80 93 e2 02 	sts	0x02E2, r24
     c4a:	0e c0       	rjmp	.+28     	; 0xc68 <fwdSer_L+0x7a>
				//rprintf("%c",c);
			}	
			else if(d_flag){
     c4c:	80 91 df 02 	lds	r24, 0x02DF
     c50:	88 23       	and	r24, r24
     c52:	51 f0       	breq	.+20     	; 0xc68 <fwdSer_L+0x7a>
				dis_rough[d_iter++] = c;	//store then increment	
     c54:	80 91 e1 02 	lds	r24, 0x02E1
     c58:	e8 2f       	mov	r30, r24
     c5a:	f0 e0       	ldi	r31, 0x00	; 0
     c5c:	ed 52       	subi	r30, 0x2D	; 45
     c5e:	fd 4f       	sbci	r31, 0xFD	; 253
     c60:	90 83       	st	Z, r25
     c62:	8f 5f       	subi	r24, 0xFF	; 255
     c64:	80 93 e1 02 	sts	0x02E1, r24
			//	rprintf("%c",c);
			}

			if(v_iter == 4){
     c68:	80 91 e2 02 	lds	r24, 0x02E2
     c6c:	84 30       	cpi	r24, 0x04	; 4
     c6e:	e9 f4       	brne	.+58     	; 0xcaa <fwdSer_L+0xbc>
				LEFTVel_current = CM_TICK * retConv_s16(&vel_rough);
     c70:	8b ed       	ldi	r24, 0xDB	; 219
     c72:	92 e0       	ldi	r25, 0x02	; 2
     c74:	0e 94 6e 04 	call	0x8dc	; 0x8dc <retConv_s16>
     c78:	aa 27       	eor	r26, r26
     c7a:	97 fd       	sbrc	r25, 7
     c7c:	a0 95       	com	r26
     c7e:	ba 2f       	mov	r27, r26
     c80:	bc 01       	movw	r22, r24
     c82:	cd 01       	movw	r24, r26
     c84:	0e 94 83 2d 	call	0x5b06	; 0x5b06 <__floatsisf>
     c88:	20 e0       	ldi	r18, 0x00	; 0
     c8a:	30 e0       	ldi	r19, 0x00	; 0
     c8c:	40 e8       	ldi	r20, 0x80	; 128
     c8e:	5e e3       	ldi	r21, 0x3E	; 62
     c90:	0e 94 37 2e 	call	0x5c6e	; 0x5c6e <__mulsf3>
     c94:	0e 94 50 2d 	call	0x5aa0	; 0x5aa0 <__fixsfsi>
     c98:	70 93 a5 02 	sts	0x02A5, r23
     c9c:	60 93 a4 02 	sts	0x02A4, r22
				v_flag = UNSET;
     ca0:	10 92 e0 02 	sts	0x02E0, r1
				v_iter = 0;
     ca4:	10 92 e2 02 	sts	0x02E2, r1
     ca8:	08 95       	ret
			//	rprintf("RRR VVV: ");
			//	rprintfu16(RIGHTVel_current);
			//	rprintf("\n");
			}
			else if(d_iter == 8){
     caa:	80 91 e1 02 	lds	r24, 0x02E1
     cae:	88 30       	cpi	r24, 0x08	; 8
     cb0:	51 f5       	brne	.+84     	; 0xd06 <fwdSer_L+0x118>
				LEFTDis_current = CM_TICK * retConv_s32(&dis_rough);
     cb2:	83 ed       	ldi	r24, 0xD3	; 211
     cb4:	92 e0       	ldi	r25, 0x02	; 2
     cb6:	0e 94 bd 04 	call	0x97a	; 0x97a <retConv_s32>
     cba:	0e 94 83 2d 	call	0x5b06	; 0x5b06 <__floatsisf>
     cbe:	20 e0       	ldi	r18, 0x00	; 0
     cc0:	30 e0       	ldi	r19, 0x00	; 0
     cc2:	40 e8       	ldi	r20, 0x80	; 128
     cc4:	5e e3       	ldi	r21, 0x3E	; 62
     cc6:	0e 94 37 2e 	call	0x5c6e	; 0x5c6e <__mulsf3>
     cca:	0e 94 50 2d 	call	0x5aa0	; 0x5aa0 <__fixsfsi>
     cce:	60 93 a6 02 	sts	0x02A6, r22
     cd2:	70 93 a7 02 	sts	0x02A7, r23
     cd6:	80 93 a8 02 	sts	0x02A8, r24
     cda:	90 93 a9 02 	sts	0x02A9, r25
			//	rprintf("dL: %d\n",dLEFTDis);
				d_flag = UNSET;
     cde:	10 92 df 02 	sts	0x02DF, r1
				d_iter = 0;
     ce2:	10 92 e1 02 	sts	0x02E1, r1
     ce6:	08 95       	ret
			//	rprintf("\n");
			}
		
		}

		else{rprintf("WR\n");}
     ce8:	00 d0       	rcall	.+0      	; 0xcea <fwdSer_L+0xfc>
     cea:	0f 92       	push	r0
     cec:	81 e0       	ldi	r24, 0x01	; 1
     cee:	ed b7       	in	r30, 0x3d	; 61
     cf0:	fe b7       	in	r31, 0x3e	; 62
     cf2:	81 83       	std	Z+1, r24	; 0x01
     cf4:	8f ea       	ldi	r24, 0xAF	; 175
     cf6:	91 e0       	ldi	r25, 0x01	; 1
     cf8:	93 83       	std	Z+3, r25	; 0x03
     cfa:	82 83       	std	Z+2, r24	; 0x02
     cfc:	0e 94 46 29 	call	0x528c	; 0x528c <rprintf1RamRom>
     d00:	0f 90       	pop	r0
     d02:	0f 90       	pop	r0
     d04:	0f 90       	pop	r0
     d06:	08 95       	ret

00000d08 <fwdSer_R>:
	int_val = ((int_val<<4) | iv8);
	return int_val;
}


void fwdSer_R(unsigned char c){
     d08:	98 2f       	mov	r25, r24
	static char v_flag;
	static char d_flag;
	static char vel_rough[4];  //store ascii chars
	static char dis_rough[8];  //store ascii chars
		//rprintf("%c",c);
		if(c != 0xff){
     d0a:	8f 3f       	cpi	r24, 0xFF	; 255
     d0c:	09 f4       	brne	.+2      	; 0xd10 <fwdSer_R+0x8>
     d0e:	79 c0       	rjmp	.+242    	; 0xe02 <fwdSer_R+0xfa>
		//if the data isn't whitespace (0xff), post it
		//	rprintf("%c",c);

			if(c == 0x0A){lf_flag = SET;} //line feed detected, the character will be a 'D' or a 'V'
     d10:	8a 30       	cpi	r24, 0x0A	; 10
     d12:	21 f4       	brne	.+8      	; 0xd1c <fwdSer_R+0x14>
     d14:	81 e0       	ldi	r24, 0x01	; 1
     d16:	80 93 f4 02 	sts	0x02F4, r24
     d1a:	33 c0       	rjmp	.+102    	; 0xd82 <fwdSer_R+0x7a>
	
			else if((lf_flag) && (c == 'V')){ //set velocity flag
     d1c:	80 91 f4 02 	lds	r24, 0x02F4
     d20:	88 23       	and	r24, r24
     d22:	91 f0       	breq	.+36     	; 0xd48 <fwdSer_R+0x40>
     d24:	96 35       	cpi	r25, 0x56	; 86
     d26:	31 f4       	brne	.+12     	; 0xd34 <fwdSer_R+0x2c>
				v_flag = SET;
     d28:	81 e0       	ldi	r24, 0x01	; 1
     d2a:	80 93 f1 02 	sts	0x02F1, r24
				v_iter = 0;
     d2e:	10 92 f3 02 	sts	0x02F3, r1
     d32:	07 c0       	rjmp	.+14     	; 0xd42 <fwdSer_R+0x3a>
				lf_flag = UNSET;
				return;
			} 
			else if((lf_flag) && (c == 'D')){ //set distance flag
     d34:	94 34       	cpi	r25, 0x44	; 68
     d36:	41 f4       	brne	.+16     	; 0xd48 <fwdSer_R+0x40>
				d_flag = SET;
     d38:	81 e0       	ldi	r24, 0x01	; 1
     d3a:	80 93 f0 02 	sts	0x02F0, r24
				d_iter = 0;
     d3e:	10 92 f2 02 	sts	0x02F2, r1
				lf_flag = UNSET;
     d42:	10 92 f4 02 	sts	0x02F4, r1
     d46:	08 95       	ret
			//	rprintf("%c",c);
				return;
			}
			else if(v_flag){
     d48:	80 91 f1 02 	lds	r24, 0x02F1
     d4c:	88 23       	and	r24, r24
     d4e:	59 f0       	breq	.+22     	; 0xd66 <fwdSer_R+0x5e>
				vel_rough[v_iter++] = c;	//store then increment	
     d50:	80 91 f3 02 	lds	r24, 0x02F3
     d54:	e8 2f       	mov	r30, r24
     d56:	f0 e0       	ldi	r31, 0x00	; 0
     d58:	e4 51       	subi	r30, 0x14	; 20
     d5a:	fd 4f       	sbci	r31, 0xFD	; 253
     d5c:	90 83       	st	Z, r25
     d5e:	8f 5f       	subi	r24, 0xFF	; 255
     d60:	80 93 f3 02 	sts	0x02F3, r24
     d64:	0e c0       	rjmp	.+28     	; 0xd82 <fwdSer_R+0x7a>
				//rprintf("%c",c);
			}	
			else if(d_flag){
     d66:	80 91 f0 02 	lds	r24, 0x02F0
     d6a:	88 23       	and	r24, r24
     d6c:	51 f0       	breq	.+20     	; 0xd82 <fwdSer_R+0x7a>
				dis_rough[d_iter++] = c;	//store then increment	
     d6e:	80 91 f2 02 	lds	r24, 0x02F2
     d72:	e8 2f       	mov	r30, r24
     d74:	f0 e0       	ldi	r31, 0x00	; 0
     d76:	ec 51       	subi	r30, 0x1C	; 28
     d78:	fd 4f       	sbci	r31, 0xFD	; 253
     d7a:	90 83       	st	Z, r25
     d7c:	8f 5f       	subi	r24, 0xFF	; 255
     d7e:	80 93 f2 02 	sts	0x02F2, r24
			//	rprintf("%c",c);
			}

			if(v_iter == 4){
     d82:	80 91 f3 02 	lds	r24, 0x02F3
     d86:	84 30       	cpi	r24, 0x04	; 4
     d88:	e9 f4       	brne	.+58     	; 0xdc4 <fwdSer_R+0xbc>
				RIGHTVel_current = CM_TICK * retConv_s16(&vel_rough);
     d8a:	8c ee       	ldi	r24, 0xEC	; 236
     d8c:	92 e0       	ldi	r25, 0x02	; 2
     d8e:	0e 94 6e 04 	call	0x8dc	; 0x8dc <retConv_s16>
     d92:	aa 27       	eor	r26, r26
     d94:	97 fd       	sbrc	r25, 7
     d96:	a0 95       	com	r26
     d98:	ba 2f       	mov	r27, r26
     d9a:	bc 01       	movw	r22, r24
     d9c:	cd 01       	movw	r24, r26
     d9e:	0e 94 83 2d 	call	0x5b06	; 0x5b06 <__floatsisf>
     da2:	20 e0       	ldi	r18, 0x00	; 0
     da4:	30 e0       	ldi	r19, 0x00	; 0
     da6:	40 e8       	ldi	r20, 0x80	; 128
     da8:	5e e3       	ldi	r21, 0x3E	; 62
     daa:	0e 94 37 2e 	call	0x5c6e	; 0x5c6e <__mulsf3>
     dae:	0e 94 50 2d 	call	0x5aa0	; 0x5aa0 <__fixsfsi>
     db2:	70 93 b1 02 	sts	0x02B1, r23
     db6:	60 93 b0 02 	sts	0x02B0, r22
				v_flag = UNSET;
     dba:	10 92 f1 02 	sts	0x02F1, r1
				v_iter = 0;
     dbe:	10 92 f3 02 	sts	0x02F3, r1
     dc2:	08 95       	ret
			//	rprintf("RRR VVV: ");
			//	rprintfu16(RIGHTVel_current);
			//	rprintf("\n");
			}
			else if(d_iter == 8){
     dc4:	80 91 f2 02 	lds	r24, 0x02F2
     dc8:	88 30       	cpi	r24, 0x08	; 8
     dca:	51 f5       	brne	.+84     	; 0xe20 <fwdSer_R+0x118>
				RIGHTDis_current = CM_TICK * retConv_s32(&dis_rough);
     dcc:	84 ee       	ldi	r24, 0xE4	; 228
     dce:	92 e0       	ldi	r25, 0x02	; 2
     dd0:	0e 94 bd 04 	call	0x97a	; 0x97a <retConv_s32>
     dd4:	0e 94 83 2d 	call	0x5b06	; 0x5b06 <__floatsisf>
     dd8:	20 e0       	ldi	r18, 0x00	; 0
     dda:	30 e0       	ldi	r19, 0x00	; 0
     ddc:	40 e8       	ldi	r20, 0x80	; 128
     dde:	5e e3       	ldi	r21, 0x3E	; 62
     de0:	0e 94 37 2e 	call	0x5c6e	; 0x5c6e <__mulsf3>
     de4:	0e 94 50 2d 	call	0x5aa0	; 0x5aa0 <__fixsfsi>
     de8:	60 93 b2 02 	sts	0x02B2, r22
     dec:	70 93 b3 02 	sts	0x02B3, r23
     df0:	80 93 b4 02 	sts	0x02B4, r24
     df4:	90 93 b5 02 	sts	0x02B5, r25
				//rprintf("dR: %d\n",dRIGHTDis);
				d_flag = UNSET;
     df8:	10 92 f0 02 	sts	0x02F0, r1
				d_iter = 0;
     dfc:	10 92 f2 02 	sts	0x02F2, r1
     e00:	08 95       	ret
				//rprintf("\n");
			}
		
		}

		else{rprintf("WR\n");}
     e02:	00 d0       	rcall	.+0      	; 0xe04 <fwdSer_R+0xfc>
     e04:	0f 92       	push	r0
     e06:	81 e0       	ldi	r24, 0x01	; 1
     e08:	ed b7       	in	r30, 0x3d	; 61
     e0a:	fe b7       	in	r31, 0x3e	; 62
     e0c:	81 83       	std	Z+1, r24	; 0x01
     e0e:	83 eb       	ldi	r24, 0xB3	; 179
     e10:	91 e0       	ldi	r25, 0x01	; 1
     e12:	93 83       	std	Z+3, r25	; 0x03
     e14:	82 83       	std	Z+2, r24	; 0x02
     e16:	0e 94 46 29 	call	0x528c	; 0x528c <rprintf1RamRom>
     e1a:	0f 90       	pop	r0
     e1c:	0f 90       	pop	r0
     e1e:	0f 90       	pop	r0
     e20:	08 95       	ret

00000e22 <vScript>:
		
	}

}

void vScript(){
     e22:	ef 92       	push	r14
     e24:	ff 92       	push	r15
     e26:	0f 93       	push	r16
     e28:	1f 93       	push	r17
     e2a:	df 93       	push	r29
     e2c:	cf 93       	push	r28
     e2e:	00 d0       	rcall	.+0      	; 0xe30 <vScript+0xe>
     e30:	cd b7       	in	r28, 0x3d	; 61
     e32:	de b7       	in	r29, 0x3e	; 62
	const portTickType xTicksToWait = 10000 / portTICK_RATE_MS;
	portTickType xLastWakeTime;

	for(;;){
		cmd_angle = 0;
		vTaskDelayUntil(&xLastWakeTime, xTicksToWait);
     e34:	8e 01       	movw	r16, r28
     e36:	0f 5f       	subi	r16, 0xFF	; 255
     e38:	1f 4f       	sbci	r17, 0xFF	; 255
		cmd_angle = 90;
     e3a:	aa e5       	ldi	r26, 0x5A	; 90
     e3c:	ea 2e       	mov	r14, r26
     e3e:	f1 2c       	mov	r15, r1
void vScript(){
	const portTickType xTicksToWait = 10000 / portTICK_RATE_MS;
	portTickType xLastWakeTime;

	for(;;){
		cmd_angle = 0;
     e40:	10 92 c1 02 	sts	0x02C1, r1
     e44:	10 92 c0 02 	sts	0x02C0, r1
		vTaskDelayUntil(&xLastWakeTime, xTicksToWait);
     e48:	c8 01       	movw	r24, r16
     e4a:	60 e1       	ldi	r22, 0x10	; 16
     e4c:	77 e2       	ldi	r23, 0x27	; 39
     e4e:	0e 94 3c 15 	call	0x2a78	; 0x2a78 <vTaskDelayUntil>
		cmd_angle = 90;
     e52:	f0 92 c1 02 	sts	0x02C1, r15
     e56:	e0 92 c0 02 	sts	0x02C0, r14
		vTaskDelayUntil(&xLastWakeTime, xTicksToWait);
     e5a:	c8 01       	movw	r24, r16
     e5c:	60 e1       	ldi	r22, 0x10	; 16
     e5e:	77 e2       	ldi	r23, 0x27	; 39
     e60:	0e 94 3c 15 	call	0x2a78	; 0x2a78 <vTaskDelayUntil>
     e64:	ed cf       	rjmp	.-38     	; 0xe40 <vScript+0x1e>

00000e66 <vRampVel>:
	uart3SendByte(r2);
	uart3SendByte(r1);
	uart3SendByte('\n'); //line feed
}

void vRampVel(){
     e66:	8f 92       	push	r8
     e68:	9f 92       	push	r9
     e6a:	af 92       	push	r10
     e6c:	bf 92       	push	r11
     e6e:	cf 92       	push	r12
     e70:	df 92       	push	r13
     e72:	ef 92       	push	r14
     e74:	ff 92       	push	r15
     e76:	0f 93       	push	r16
     e78:	1f 93       	push	r17
     e7a:	df 93       	push	r29
     e7c:	cf 93       	push	r28
     e7e:	00 d0       	rcall	.+0      	; 0xe80 <vRampVel+0x1a>
     e80:	cd b7       	in	r28, 0x3d	; 61
     e82:	de b7       	in	r29, 0x3e	; 62
	const portTickType xTicksToWait = 1000 / portTICK_RATE_MS;
	portTickType xLastWakeTime;
	v_command = 0;
     e84:	80 e0       	ldi	r24, 0x00	; 0
     e86:	90 e0       	ldi	r25, 0x00	; 0
     e88:	a0 e0       	ldi	r26, 0x00	; 0
     e8a:	b0 e0       	ldi	r27, 0x00	; 0
     e8c:	80 93 9a 02 	sts	0x029A, r24
     e90:	90 93 9b 02 	sts	0x029B, r25
     e94:	a0 93 9c 02 	sts	0x029C, r26
     e98:	b0 93 9d 02 	sts	0x029D, r27
	inst_cmd_vel = 25;
     e9c:	80 e0       	ldi	r24, 0x00	; 0
     e9e:	90 e0       	ldi	r25, 0x00	; 0
     ea0:	a8 ec       	ldi	r26, 0xC8	; 200
     ea2:	b1 e4       	ldi	r27, 0x41	; 65
     ea4:	80 93 9e 02 	sts	0x029E, r24
     ea8:	90 93 9f 02 	sts	0x029F, r25
     eac:	a0 93 a0 02 	sts	0x02A0, r26
     eb0:	b0 93 a1 02 	sts	0x02A1, r27
	vTaskDelayUntil(&xLastWakeTime, 10000 / portTICK_RATE_MS);	//leave velocity at zero briefly
     eb4:	8e 01       	movw	r16, r28
     eb6:	0f 5f       	subi	r16, 0xFF	; 255
     eb8:	1f 4f       	sbci	r17, 0xFF	; 255
     eba:	c8 01       	movw	r24, r16
     ebc:	60 e1       	ldi	r22, 0x10	; 16
     ebe:	77 e2       	ldi	r23, 0x27	; 39
     ec0:	0e 94 3c 15 	call	0x2a78	; 0x2a78 <vTaskDelayUntil>

	for(;;){
		
		vTaskDelayUntil(&xLastWakeTime, xTicksToWait);
     ec4:	48 01       	movw	r8, r16
     ec6:	c4 01       	movw	r24, r8
     ec8:	68 ee       	ldi	r22, 0xE8	; 232
     eca:	73 e0       	ldi	r23, 0x03	; 3
     ecc:	0e 94 3c 15 	call	0x2a78	; 0x2a78 <vTaskDelayUntil>
		//if(v_command != inst_cmd_vel){v_command++;}
		v_command += (1/(inst_cmd_vel - v_command))*(inst_cmd_vel);
     ed0:	e0 90 9e 02 	lds	r14, 0x029E
     ed4:	f0 90 9f 02 	lds	r15, 0x029F
     ed8:	00 91 a0 02 	lds	r16, 0x02A0
     edc:	10 91 a1 02 	lds	r17, 0x02A1
     ee0:	a0 90 9a 02 	lds	r10, 0x029A
     ee4:	b0 90 9b 02 	lds	r11, 0x029B
     ee8:	c0 90 9c 02 	lds	r12, 0x029C
     eec:	d0 90 9d 02 	lds	r13, 0x029D
     ef0:	c8 01       	movw	r24, r16
     ef2:	b7 01       	movw	r22, r14
     ef4:	a6 01       	movw	r20, r12
     ef6:	95 01       	movw	r18, r10
     ef8:	0e 94 7f 2c 	call	0x58fe	; 0x58fe <__subsf3>
     efc:	9b 01       	movw	r18, r22
     efe:	ac 01       	movw	r20, r24
     f00:	60 e0       	ldi	r22, 0x00	; 0
     f02:	70 e0       	ldi	r23, 0x00	; 0
     f04:	80 e8       	ldi	r24, 0x80	; 128
     f06:	9f e3       	ldi	r25, 0x3F	; 63
     f08:	0e 94 e8 2c 	call	0x59d0	; 0x59d0 <__divsf3>
     f0c:	a8 01       	movw	r20, r16
     f0e:	97 01       	movw	r18, r14
     f10:	0e 94 37 2e 	call	0x5c6e	; 0x5c6e <__mulsf3>
     f14:	9b 01       	movw	r18, r22
     f16:	ac 01       	movw	r20, r24
     f18:	c6 01       	movw	r24, r12
     f1a:	b5 01       	movw	r22, r10
     f1c:	0e 94 80 2c 	call	0x5900	; 0x5900 <__addsf3>
     f20:	60 93 9a 02 	sts	0x029A, r22
     f24:	70 93 9b 02 	sts	0x029B, r23
     f28:	80 93 9c 02 	sts	0x029C, r24
     f2c:	90 93 9d 02 	sts	0x029D, r25

		if(v_command > 25){v_command = 25;}
     f30:	20 e0       	ldi	r18, 0x00	; 0
     f32:	30 e0       	ldi	r19, 0x00	; 0
     f34:	48 ec       	ldi	r20, 0xC8	; 200
     f36:	51 e4       	ldi	r21, 0x41	; 65
     f38:	0e 94 33 2e 	call	0x5c66	; 0x5c66 <__gesf2>
     f3c:	18 16       	cp	r1, r24
     f3e:	64 f4       	brge	.+24     	; 0xf58 <vRampVel+0xf2>
     f40:	80 e0       	ldi	r24, 0x00	; 0
     f42:	90 e0       	ldi	r25, 0x00	; 0
     f44:	a8 ec       	ldi	r26, 0xC8	; 200
     f46:	b1 e4       	ldi	r27, 0x41	; 65
     f48:	80 93 9a 02 	sts	0x029A, r24
     f4c:	90 93 9b 02 	sts	0x029B, r25
     f50:	a0 93 9c 02 	sts	0x029C, r26
     f54:	b0 93 9d 02 	sts	0x029D, r27
		if(v_command <  0){v_command =  0;}
     f58:	60 91 9a 02 	lds	r22, 0x029A
     f5c:	70 91 9b 02 	lds	r23, 0x029B
     f60:	80 91 9c 02 	lds	r24, 0x029C
     f64:	90 91 9d 02 	lds	r25, 0x029D
     f68:	20 e0       	ldi	r18, 0x00	; 0
     f6a:	30 e0       	ldi	r19, 0x00	; 0
     f6c:	40 e0       	ldi	r20, 0x00	; 0
     f6e:	50 e0       	ldi	r21, 0x00	; 0
     f70:	0e 94 e4 2c 	call	0x59c8	; 0x59c8 <__cmpsf2>
     f74:	88 23       	and	r24, r24
     f76:	0c f0       	brlt	.+2      	; 0xf7a <vRampVel+0x114>
     f78:	a6 cf       	rjmp	.-180    	; 0xec6 <vRampVel+0x60>
     f7a:	80 e0       	ldi	r24, 0x00	; 0
     f7c:	90 e0       	ldi	r25, 0x00	; 0
     f7e:	a0 e0       	ldi	r26, 0x00	; 0
     f80:	b0 e0       	ldi	r27, 0x00	; 0
     f82:	80 93 9a 02 	sts	0x029A, r24
     f86:	90 93 9b 02 	sts	0x029B, r25
     f8a:	a0 93 9c 02 	sts	0x029C, r26
     f8e:	b0 93 9d 02 	sts	0x029D, r27
     f92:	99 cf       	rjmp	.-206    	; 0xec6 <vRampVel+0x60>

00000f94 <vLight1On>:
		PORT_OFF(PORTA, 0);
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
		
	}
}
void vLight1On(void *pvParameters){
     f94:	0f 93       	push	r16
     f96:	1f 93       	push	r17
     f98:	df 93       	push	r29
     f9a:	cf 93       	push	r28
     f9c:	00 d0       	rcall	.+0      	; 0xf9e <vLight1On+0xa>
     f9e:	cd b7       	in	r28, 0x3d	; 61
     fa0:	de b7       	in	r29, 0x3e	; 62
	portTickType xLastWakeTime;
	for(;;){
		LED_on();
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
     fa2:	8e 01       	movw	r16, r28
     fa4:	0f 5f       	subi	r16, 0xFF	; 255
     fa6:	1f 4f       	sbci	r17, 0xFF	; 255
//***************STATUS LED**************
//tank test
void LED_off(void)
	{PORT_ON(PORTB,6);}
void LED_on(void)
	{PORT_OFF(PORTB,6);}
     fa8:	2e 98       	cbi	0x05, 6	; 5
     faa:	c8 01       	movw	r24, r16
     fac:	62 e3       	ldi	r22, 0x32	; 50
     fae:	70 e0       	ldi	r23, 0x00	; 0
     fb0:	0e 94 3c 15 	call	0x2a78	; 0x2a78 <vTaskDelayUntil>


//***************STATUS LED**************
//tank test
void LED_off(void)
	{PORT_ON(PORTB,6);}
     fb4:	2e 9a       	sbi	0x05, 6	; 5
		LED_off();
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));	}
     fb6:	c8 01       	movw	r24, r16
     fb8:	62 e3       	ldi	r22, 0x32	; 50
     fba:	70 e0       	ldi	r23, 0x00	; 0
     fbc:	0e 94 3c 15 	call	0x2a78	; 0x2a78 <vTaskDelayUntil>
     fc0:	f3 cf       	rjmp	.-26     	; 0xfa8 <vLight1On+0x14>

00000fc2 <vLight0On>:
	}
}



void vLight0On(void *pvParameters){
     fc2:	0f 93       	push	r16
     fc4:	1f 93       	push	r17
     fc6:	df 93       	push	r29
     fc8:	cf 93       	push	r28
     fca:	00 d0       	rcall	.+0      	; 0xfcc <vLight0On+0xa>
     fcc:	cd b7       	in	r28, 0x3d	; 61
     fce:	de b7       	in	r29, 0x3e	; 62
	portTickType xLastWakeTime;
	for(;;){
		PORT_ON(PORTA, 0);
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
     fd0:	8e 01       	movw	r16, r28
     fd2:	0f 5f       	subi	r16, 0xFF	; 255
     fd4:	1f 4f       	sbci	r17, 0xFF	; 255


void vLight0On(void *pvParameters){
	portTickType xLastWakeTime;
	for(;;){
		PORT_ON(PORTA, 0);
     fd6:	10 9a       	sbi	0x02, 0	; 2
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
     fd8:	c8 01       	movw	r24, r16
     fda:	62 e3       	ldi	r22, 0x32	; 50
     fdc:	70 e0       	ldi	r23, 0x00	; 0
     fde:	0e 94 3c 15 	call	0x2a78	; 0x2a78 <vTaskDelayUntil>
		//taskYIELD();	
		PORT_OFF(PORTA, 0);
     fe2:	10 98       	cbi	0x02, 0	; 2
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
     fe4:	c8 01       	movw	r24, r16
     fe6:	62 e3       	ldi	r22, 0x32	; 50
     fe8:	70 e0       	ldi	r23, 0x00	; 0
     fea:	0e 94 3c 15 	call	0x2a78	; 0x2a78 <vTaskDelayUntil>
     fee:	f3 cf       	rjmp	.-26     	; 0xfd6 <vLight0On+0x14>

00000ff0 <vPID_R>:
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
	}

}

void vPID_R(void* pvParameters){
     ff0:	6f 92       	push	r6
     ff2:	7f 92       	push	r7
     ff4:	8f 92       	push	r8
     ff6:	9f 92       	push	r9
     ff8:	af 92       	push	r10
     ffa:	bf 92       	push	r11
     ffc:	cf 92       	push	r12
     ffe:	df 92       	push	r13
    1000:	ef 92       	push	r14
    1002:	ff 92       	push	r15
    1004:	0f 93       	push	r16
    1006:	1f 93       	push	r17
    1008:	df 93       	push	r29
    100a:	cf 93       	push	r28
    100c:	00 d0       	rcall	.+0      	; 0x100e <vPID_R+0x1e>
    100e:	cd b7       	in	r28, 0x3d	; 61
    1010:	de b7       	in	r29, 0x3e	; 62
	sbi(TCCR2A,COM2B1);
	cbi(TCCR2A,COM2B0);
}
void PWM_timer3_On_E3(void)
{
	sbi(TCCR3A,COM3A1);
    1012:	80 91 90 00 	lds	r24, 0x0090
    1016:	80 68       	ori	r24, 0x80	; 128
    1018:	80 93 90 00 	sts	0x0090, r24
	cbi(TCCR3A,COM3A0);
    101c:	80 91 90 00 	lds	r24, 0x0090
    1020:	8f 7b       	andi	r24, 0xBF	; 191
    1022:	80 93 90 00 	sts	0x0090, r24
    1026:	88 24       	eor	r8, r8
    1028:	99 24       	eor	r9, r9
	//		if(adj == 'p'){ KD+= 0.01;}
	//		else if(adj == 'l'){ KD -= 0.01;}
			


		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
    102a:	3e 01       	movw	r6, r28
    102c:	08 94       	sec
    102e:	61 1c       	adc	r6, r1
    1030:	71 1c       	adc	r7, r1
	wheel_R_on();

	char adj;
	for(;;){
			
			signed int v_out = v_command - v_offset;
    1032:	e0 90 9a 02 	lds	r14, 0x029A
    1036:	f0 90 9b 02 	lds	r15, 0x029B
    103a:	00 91 9c 02 	lds	r16, 0x029C
    103e:	10 91 9d 02 	lds	r17, 0x029D
    1042:	60 91 a2 02 	lds	r22, 0x02A2
    1046:	70 91 a3 02 	lds	r23, 0x02A3
    104a:	88 27       	eor	r24, r24
    104c:	77 fd       	sbrc	r23, 7
    104e:	80 95       	com	r24
    1050:	98 2f       	mov	r25, r24
    1052:	0e 94 83 2d 	call	0x5b06	; 0x5b06 <__floatsisf>
    1056:	9b 01       	movw	r18, r22
    1058:	ac 01       	movw	r20, r24
    105a:	c8 01       	movw	r24, r16
    105c:	b7 01       	movw	r22, r14
    105e:	0e 94 7f 2c 	call	0x58fe	; 0x58fe <__subsf3>
    1062:	0e 94 50 2d 	call	0x5aa0	; 0x5aa0 <__fixsfsi>
    1066:	5b 01       	movw	r10, r22
    1068:	6c 01       	movw	r12, r24
			error = v_command - (-RIGHTVel_current);
    106a:	60 91 b0 02 	lds	r22, 0x02B0
    106e:	70 91 b1 02 	lds	r23, 0x02B1
    1072:	70 95       	com	r23
    1074:	61 95       	neg	r22
    1076:	7f 4f       	sbci	r23, 0xFF	; 255
    1078:	88 27       	eor	r24, r24
    107a:	77 fd       	sbrc	r23, 7
    107c:	80 95       	com	r24
    107e:	98 2f       	mov	r25, r24
    1080:	0e 94 83 2d 	call	0x5b06	; 0x5b06 <__floatsisf>
    1084:	9b 01       	movw	r18, r22
    1086:	ac 01       	movw	r20, r24
    1088:	c8 01       	movw	r24, r16
    108a:	b7 01       	movw	r22, r14
    108c:	0e 94 7f 2c 	call	0x58fe	; 0x58fe <__subsf3>
    1090:	0e 94 50 2d 	call	0x5aa0	; 0x5aa0 <__fixsfsi>
    1094:	6b 01       	movw	r12, r22
	//		d_error = (error - pre_error)/dt;
	//		wD = 1 - (d_error)/(d_error + cD);
	//		d_error *= wD; 
			v_out += (signed int)((KP * error) + (KI * acc_error));
    1096:	b6 01       	movw	r22, r12
    1098:	88 27       	eor	r24, r24
    109a:	77 fd       	sbrc	r23, 7
    109c:	80 95       	com	r24
    109e:	98 2f       	mov	r25, r24
    10a0:	0e 94 83 2d 	call	0x5b06	; 0x5b06 <__floatsisf>
    10a4:	20 e0       	ldi	r18, 0x00	; 0
    10a6:	30 e0       	ldi	r19, 0x00	; 0
    10a8:	40 e8       	ldi	r20, 0x80	; 128
    10aa:	5e e3       	ldi	r21, 0x3E	; 62
    10ac:	0e 94 37 2e 	call	0x5c6e	; 0x5c6e <__mulsf3>
    10b0:	7b 01       	movw	r14, r22
    10b2:	8c 01       	movw	r16, r24
    10b4:	b4 01       	movw	r22, r8
    10b6:	88 27       	eor	r24, r24
    10b8:	77 fd       	sbrc	r23, 7
    10ba:	80 95       	com	r24
    10bc:	98 2f       	mov	r25, r24
    10be:	0e 94 83 2d 	call	0x5b06	; 0x5b06 <__floatsisf>
    10c2:	20 e0       	ldi	r18, 0x00	; 0
    10c4:	30 e0       	ldi	r19, 0x00	; 0
    10c6:	40 e0       	ldi	r20, 0x00	; 0
    10c8:	5e e3       	ldi	r21, 0x3E	; 62
    10ca:	0e 94 37 2e 	call	0x5c6e	; 0x5c6e <__mulsf3>
    10ce:	9b 01       	movw	r18, r22
    10d0:	ac 01       	movw	r20, r24
    10d2:	c8 01       	movw	r24, r16
    10d4:	b7 01       	movw	r22, r14
    10d6:	0e 94 80 2c 	call	0x5900	; 0x5900 <__addsf3>
    10da:	0e 94 50 2d 	call	0x5aa0	; 0x5aa0 <__fixsfsi>
    10de:	6a 0d       	add	r22, r10
    10e0:	7b 1d       	adc	r23, r11
	//		pre_error = error;
			if(v_out > 36){v_out = 36;}
    10e2:	65 32       	cpi	r22, 0x25	; 37
    10e4:	71 05       	cpc	r23, r1
    10e6:	1c f0       	brlt	.+6      	; 0x10ee <vPID_R+0xfe>
    10e8:	64 e2       	ldi	r22, 0x24	; 36
    10ea:	70 e0       	ldi	r23, 0x00	; 0
    10ec:	06 c0       	rjmp	.+12     	; 0x10fa <vPID_R+0x10a>
			if(v_out < -36){v_out = -36;}
    10ee:	8f ef       	ldi	r24, 0xFF	; 255
    10f0:	6c 3d       	cpi	r22, 0xDC	; 220
    10f2:	78 07       	cpc	r23, r24
    10f4:	14 f4       	brge	.+4      	; 0x10fa <vPID_R+0x10a>
    10f6:	6c ed       	ldi	r22, 0xDC	; 220
    10f8:	7f ef       	ldi	r23, 0xFF	; 255
			taskENTER_CRITICAL();
    10fa:	0f b6       	in	r0, 0x3f	; 63
    10fc:	f8 94       	cli
    10fe:	0f 92       	push	r0
			wheel_R(-v_out);
    1100:	88 27       	eor	r24, r24
    1102:	99 27       	eor	r25, r25
    1104:	86 1b       	sub	r24, r22
    1106:	97 0b       	sbc	r25, r23
    1108:	0e 94 c0 05 	call	0xb80	; 0xb80 <wheel_R>
			
		
		//rprintfNum(10, 5, 0, ' ', s_out);
//		rprintf("RRR: %d , %d\n",v_out,RIGHTVel_current);
	//	rprintf("%d\n", -RIGHTVel_current);
			taskEXIT_CRITICAL();
    110c:	0f 90       	pop	r0
    110e:	0f be       	out	0x3f, r0	; 63

			acc_error += error;
    1110:	8c 0c       	add	r8, r12
    1112:	9d 1c       	adc	r9, r13
	//		if(adj == 'p'){ KD+= 0.01;}
	//		else if(adj == 'l'){ KD -= 0.01;}
			


		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
    1114:	c3 01       	movw	r24, r6
    1116:	62 e3       	ldi	r22, 0x32	; 50
    1118:	70 e0       	ldi	r23, 0x00	; 0
    111a:	0e 94 3c 15 	call	0x2a78	; 0x2a78 <vTaskDelayUntil>
    111e:	89 cf       	rjmp	.-238    	; 0x1032 <vPID_R+0x42>

00001120 <vPID_L>:
		taskEXIT_CRITICAL();


}

void vPID_L(void* pvParameters){
    1120:	4f 92       	push	r4
    1122:	5f 92       	push	r5
    1124:	6f 92       	push	r6
    1126:	7f 92       	push	r7
    1128:	8f 92       	push	r8
    112a:	9f 92       	push	r9
    112c:	af 92       	push	r10
    112e:	bf 92       	push	r11
    1130:	cf 92       	push	r12
    1132:	df 92       	push	r13
    1134:	ef 92       	push	r14
    1136:	ff 92       	push	r15
    1138:	0f 93       	push	r16
    113a:	1f 93       	push	r17
    113c:	df 93       	push	r29
    113e:	cf 93       	push	r28
    1140:	00 d0       	rcall	.+0      	; 0x1142 <vPID_L+0x22>
    1142:	cd b7       	in	r28, 0x3d	; 61
    1144:	de b7       	in	r29, 0x3e	; 62
}
void PWM_timer3_On_E4(void)
{
	sbi(TCCR3A,COM3B1);
    1146:	80 91 90 00 	lds	r24, 0x0090
    114a:	80 62       	ori	r24, 0x20	; 32
    114c:	80 93 90 00 	sts	0x0090, r24
	cbi(TCCR3A,COM3B0);
    1150:	80 91 90 00 	lds	r24, 0x0090
    1154:	8f 7e       	andi	r24, 0xEF	; 239
    1156:	80 93 90 00 	sts	0x0090, r24
    115a:	66 24       	eor	r6, r6
    115c:	77 24       	eor	r7, r7

		
			//rprintfNum(10, 5, 0, ' ', s_out);
//			rprintf("LLL: %d , %d\n",v_out,LEFTVel_current);
			taskEXIT_CRITICAL();
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
    115e:	2e 01       	movw	r4, r28
    1160:	08 94       	sec
    1162:	41 1c       	adc	r4, r1
    1164:	51 1c       	adc	r5, r1
	

	wheel_L_on();

	for(;;){
			signed int v_out = v_command + v_offset;
    1166:	60 91 a2 02 	lds	r22, 0x02A2
    116a:	70 91 a3 02 	lds	r23, 0x02A3
    116e:	88 27       	eor	r24, r24
    1170:	77 fd       	sbrc	r23, 7
    1172:	80 95       	com	r24
    1174:	98 2f       	mov	r25, r24
    1176:	0e 94 83 2d 	call	0x5b06	; 0x5b06 <__floatsisf>
    117a:	20 91 9a 02 	lds	r18, 0x029A
    117e:	30 91 9b 02 	lds	r19, 0x029B
    1182:	40 91 9c 02 	lds	r20, 0x029C
    1186:	50 91 9d 02 	lds	r21, 0x029D
    118a:	0e 94 80 2c 	call	0x5900	; 0x5900 <__addsf3>
    118e:	0e 94 50 2d 	call	0x5aa0	; 0x5aa0 <__fixsfsi>
    1192:	7b 01       	movw	r14, r22
    1194:	8c 01       	movw	r16, r24
			error = v_out - LEFTVel_current;
    1196:	80 91 a4 02 	lds	r24, 0x02A4
    119a:	90 91 a5 02 	lds	r25, 0x02A5
    119e:	47 01       	movw	r8, r14
    11a0:	88 1a       	sub	r8, r24
    11a2:	99 0a       	sbc	r9, r25
	//		d_error = (error - pre_error);
			
			v_out += (signed int)((KP * error) + (KI * acc_error));
    11a4:	b4 01       	movw	r22, r8
    11a6:	88 27       	eor	r24, r24
    11a8:	77 fd       	sbrc	r23, 7
    11aa:	80 95       	com	r24
    11ac:	98 2f       	mov	r25, r24
    11ae:	0e 94 83 2d 	call	0x5b06	; 0x5b06 <__floatsisf>
    11b2:	20 e0       	ldi	r18, 0x00	; 0
    11b4:	30 e0       	ldi	r19, 0x00	; 0
    11b6:	40 e8       	ldi	r20, 0x80	; 128
    11b8:	5e e3       	ldi	r21, 0x3E	; 62
    11ba:	0e 94 37 2e 	call	0x5c6e	; 0x5c6e <__mulsf3>
    11be:	5b 01       	movw	r10, r22
    11c0:	6c 01       	movw	r12, r24
    11c2:	b3 01       	movw	r22, r6
    11c4:	88 27       	eor	r24, r24
    11c6:	77 fd       	sbrc	r23, 7
    11c8:	80 95       	com	r24
    11ca:	98 2f       	mov	r25, r24
    11cc:	0e 94 83 2d 	call	0x5b06	; 0x5b06 <__floatsisf>
    11d0:	20 e0       	ldi	r18, 0x00	; 0
    11d2:	30 e0       	ldi	r19, 0x00	; 0
    11d4:	40 e0       	ldi	r20, 0x00	; 0
    11d6:	5e e3       	ldi	r21, 0x3E	; 62
    11d8:	0e 94 37 2e 	call	0x5c6e	; 0x5c6e <__mulsf3>
    11dc:	9b 01       	movw	r18, r22
    11de:	ac 01       	movw	r20, r24
    11e0:	c6 01       	movw	r24, r12
    11e2:	b5 01       	movw	r22, r10
    11e4:	0e 94 80 2c 	call	0x5900	; 0x5900 <__addsf3>
    11e8:	0e 94 50 2d 	call	0x5aa0	; 0x5aa0 <__fixsfsi>
    11ec:	cb 01       	movw	r24, r22
    11ee:	8e 0d       	add	r24, r14
    11f0:	9f 1d       	adc	r25, r15
	//		pre_error = error;
			acc_error += error;
    11f2:	68 0c       	add	r6, r8
    11f4:	79 1c       	adc	r7, r9

			if(v_out > 36){v_out = 36;}
    11f6:	85 32       	cpi	r24, 0x25	; 37
    11f8:	91 05       	cpc	r25, r1
    11fa:	1c f0       	brlt	.+6      	; 0x1202 <vPID_L+0xe2>
    11fc:	84 e2       	ldi	r24, 0x24	; 36
    11fe:	90 e0       	ldi	r25, 0x00	; 0
    1200:	06 c0       	rjmp	.+12     	; 0x120e <vPID_L+0xee>
			if(v_out < -36){v_out = -36;}
    1202:	2f ef       	ldi	r18, 0xFF	; 255
    1204:	8c 3d       	cpi	r24, 0xDC	; 220
    1206:	92 07       	cpc	r25, r18
    1208:	14 f4       	brge	.+4      	; 0x120e <vPID_L+0xee>
    120a:	8c ed       	ldi	r24, 0xDC	; 220
    120c:	9f ef       	ldi	r25, 0xFF	; 255
			taskENTER_CRITICAL();
    120e:	0f b6       	in	r0, 0x3f	; 63
    1210:	f8 94       	cli
    1212:	0f 92       	push	r0
			wheel_L(v_out);
    1214:	0e 94 94 05 	call	0xb28	; 0xb28 <wheel_L>

		
			//rprintfNum(10, 5, 0, ' ', s_out);
//			rprintf("LLL: %d , %d\n",v_out,LEFTVel_current);
			taskEXIT_CRITICAL();
    1218:	0f 90       	pop	r0
    121a:	0f be       	out	0x3f, r0	; 63
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
    121c:	c2 01       	movw	r24, r4
    121e:	62 e3       	ldi	r22, 0x32	; 50
    1220:	70 e0       	ldi	r23, 0x00	; 0
    1222:	0e 94 3c 15 	call	0x2a78	; 0x2a78 <vTaskDelayUntil>
    1226:	9f cf       	rjmp	.-194    	; 0x1166 <vPID_L+0x46>

00001228 <vEnc_UpdatePose>:
		
	
	}
}

void vEnc_UpdatePose(){
    1228:	df 92       	push	r13
    122a:	ef 92       	push	r14
    122c:	ff 92       	push	r15
    122e:	0f 93       	push	r16
    1230:	1f 93       	push	r17

	for(;;){
		
		//The below formula yields the encoder calculated angular velocity of the robot
		//as it rotates about some ICC(Instantaneous Center of Curvature)
		reset_timer0();
    1232:	0e 94 7a 1b 	call	0x36f4	; 0x36f4 <reset_timer0>
		enc_ang_vel = ((-RIGHTVel_current) - LEFTVel_current) / ROBOT_DIAMETER;
    1236:	60 91 b0 02 	lds	r22, 0x02B0
    123a:	70 91 b1 02 	lds	r23, 0x02B1
    123e:	70 95       	com	r23
    1240:	61 95       	neg	r22
    1242:	7f 4f       	sbci	r23, 0xFF	; 255
    1244:	20 91 a4 02 	lds	r18, 0x02A4
    1248:	30 91 a5 02 	lds	r19, 0x02A5
    124c:	62 1b       	sub	r22, r18
    124e:	73 0b       	sbc	r23, r19
    1250:	88 27       	eor	r24, r24
    1252:	77 fd       	sbrc	r23, 7
    1254:	80 95       	com	r24
    1256:	98 2f       	mov	r25, r24
    1258:	0e 94 83 2d 	call	0x5b06	; 0x5b06 <__floatsisf>
    125c:	26 e6       	ldi	r18, 0x66	; 102
    125e:	36 e6       	ldi	r19, 0x66	; 102
    1260:	46 e8       	ldi	r20, 0x86	; 134
    1262:	51 e4       	ldi	r21, 0x41	; 65
    1264:	0e 94 e8 2c 	call	0x59d0	; 0x59d0 <__divsf3>
    1268:	7b 01       	movw	r14, r22
    126a:	8c 01       	movw	r16, r24
		elapsed_time = ((get_timer0_overflow()*255 + TCNT0) * 0.256) / 1000;
    126c:	0e 94 1b 1b 	call	0x3636	; 0x3636 <get_timer0_overflow>
    1270:	d6 b4       	in	r13, 0x26	; 38
		//dRL = dRIGHTDis - dLEFTDis;
		//dis_enc_heading += sin((dRL)/ ROBOT_DIAMETER);
		//dRIGHTDis = dLEFTDis = 0;
		enc_heading += enc_ang_vel * elapsed_time;
    1272:	2f ef       	ldi	r18, 0xFF	; 255
    1274:	30 e0       	ldi	r19, 0x00	; 0
    1276:	40 e0       	ldi	r20, 0x00	; 0
    1278:	50 e0       	ldi	r21, 0x00	; 0
    127a:	0e 94 56 30 	call	0x60ac	; 0x60ac <__mulsi3>
    127e:	6d 0d       	add	r22, r13
    1280:	71 1d       	adc	r23, r1
    1282:	81 1d       	adc	r24, r1
    1284:	91 1d       	adc	r25, r1
    1286:	0e 94 81 2d 	call	0x5b02	; 0x5b02 <__floatunsisf>
    128a:	2f e6       	ldi	r18, 0x6F	; 111
    128c:	32 e1       	ldi	r19, 0x12	; 18
    128e:	43 e8       	ldi	r20, 0x83	; 131
    1290:	5e e3       	ldi	r21, 0x3E	; 62
    1292:	0e 94 37 2e 	call	0x5c6e	; 0x5c6e <__mulsf3>
    1296:	20 e0       	ldi	r18, 0x00	; 0
    1298:	30 e0       	ldi	r19, 0x00	; 0
    129a:	4a e7       	ldi	r20, 0x7A	; 122
    129c:	54 e4       	ldi	r21, 0x44	; 68
    129e:	0e 94 e8 2c 	call	0x59d0	; 0x59d0 <__divsf3>
    12a2:	9b 01       	movw	r18, r22
    12a4:	ac 01       	movw	r20, r24
    12a6:	c8 01       	movw	r24, r16
    12a8:	b7 01       	movw	r22, r14
    12aa:	0e 94 37 2e 	call	0x5c6e	; 0x5c6e <__mulsf3>
    12ae:	9b 01       	movw	r18, r22
    12b0:	ac 01       	movw	r20, r24
    12b2:	60 91 bc 02 	lds	r22, 0x02BC
    12b6:	70 91 bd 02 	lds	r23, 0x02BD
    12ba:	80 91 be 02 	lds	r24, 0x02BE
    12be:	90 91 bf 02 	lds	r25, 0x02BF
    12c2:	0e 94 80 2c 	call	0x5900	; 0x5900 <__addsf3>
    12c6:	60 93 bc 02 	sts	0x02BC, r22
    12ca:	70 93 bd 02 	sts	0x02BD, r23
    12ce:	80 93 be 02 	sts	0x02BE, r24
    12d2:	90 93 bf 02 	sts	0x02BF, r25
    12d6:	ad cf       	rjmp	.-166    	; 0x1232 <vEnc_UpdatePose+0xa>

000012d8 <send_frame>:
	}
	return c;
}


void send_frame(char flag, int16_t data){
    12d8:	ff 92       	push	r15
    12da:	0f 93       	push	r16
    12dc:	1f 93       	push	r17
    12de:	cf 93       	push	r28
    12e0:	df 93       	push	r29
    12e2:	eb 01       	movw	r28, r22
	uint8_t r1 = 0;
	uint8_t r2 = 0;
	uint8_t r3 = 0;
	uint8_t r4 = 0;

	uart3SendByte(flag);
    12e4:	0e 94 3b 22 	call	0x4476	; 0x4476 <uart3SendByte>

	r1 = num2char(0x0F & (uint8_t)data);
    12e8:	8f e0       	ldi	r24, 0x0F	; 15
    12ea:	f8 2e       	mov	r15, r24
    12ec:	fc 22       	and	r15, r28
}
*/

char num2char(char c){
	
	if(c <10){
    12ee:	89 e0       	ldi	r24, 0x09	; 9
    12f0:	8f 15       	cp	r24, r15
    12f2:	18 f0       	brcs	.+6      	; 0x12fa <send_frame+0x22>
		c += 48;
    12f4:	90 e3       	ldi	r25, 0x30	; 48
    12f6:	f9 0e       	add	r15, r25
    12f8:	06 c0       	rjmp	.+12     	; 0x1306 <send_frame+0x2e>
	}
	else if((c >= 10) && (c <= 16)){
    12fa:	8f 2d       	mov	r24, r15
    12fc:	8a 50       	subi	r24, 0x0A	; 10
    12fe:	87 30       	cpi	r24, 0x07	; 7
    1300:	10 f4       	brcc	.+4      	; 0x1306 <send_frame+0x2e>
		c += 55;
    1302:	87 e3       	ldi	r24, 0x37	; 55
    1304:	f8 0e       	add	r15, r24
	uint8_t r4 = 0;

	uart3SendByte(flag);

	r1 = num2char(0x0F & (uint8_t)data);
	r2 = num2char(0x0F & ((uint8_t)(data >> 4)) );
    1306:	ce 01       	movw	r24, r28
    1308:	04 e0       	ldi	r16, 0x04	; 4
    130a:	95 95       	asr	r25
    130c:	87 95       	ror	r24
    130e:	0a 95       	dec	r16
    1310:	e1 f7       	brne	.-8      	; 0x130a <send_frame+0x32>
    1312:	08 2f       	mov	r16, r24
    1314:	0f 70       	andi	r16, 0x0F	; 15
}
*/

char num2char(char c){
	
	if(c <10){
    1316:	0a 30       	cpi	r16, 0x0A	; 10
    1318:	10 f4       	brcc	.+4      	; 0x131e <send_frame+0x46>
		c += 48;
    131a:	00 5d       	subi	r16, 0xD0	; 208
    131c:	05 c0       	rjmp	.+10     	; 0x1328 <send_frame+0x50>
	}
	else if((c >= 10) && (c <= 16)){
    131e:	80 2f       	mov	r24, r16
    1320:	8a 50       	subi	r24, 0x0A	; 10
    1322:	87 30       	cpi	r24, 0x07	; 7
    1324:	08 f4       	brcc	.+2      	; 0x1328 <send_frame+0x50>
		c += 55;
    1326:	09 5c       	subi	r16, 0xC9	; 201

	uart3SendByte(flag);

	r1 = num2char(0x0F & (uint8_t)data);
	r2 = num2char(0x0F & ((uint8_t)(data >> 4)) );
	r3 = num2char(0x0F & ((uint8_t)(data >> 8)) );
    1328:	8d 2f       	mov	r24, r29
    132a:	99 27       	eor	r25, r25
    132c:	87 fd       	sbrc	r24, 7
    132e:	9a 95       	dec	r25
    1330:	18 2f       	mov	r17, r24
    1332:	1f 70       	andi	r17, 0x0F	; 15
}
*/

char num2char(char c){
	
	if(c <10){
    1334:	1a 30       	cpi	r17, 0x0A	; 10
    1336:	10 f4       	brcc	.+4      	; 0x133c <send_frame+0x64>
		c += 48;
    1338:	10 5d       	subi	r17, 0xD0	; 208
    133a:	05 c0       	rjmp	.+10     	; 0x1346 <send_frame+0x6e>
	}
	else if((c >= 10) && (c <= 16)){
    133c:	81 2f       	mov	r24, r17
    133e:	8a 50       	subi	r24, 0x0A	; 10
    1340:	87 30       	cpi	r24, 0x07	; 7
    1342:	08 f4       	brcc	.+2      	; 0x1346 <send_frame+0x6e>
		c += 55;
    1344:	19 5c       	subi	r17, 0xC9	; 201
	uart3SendByte(flag);

	r1 = num2char(0x0F & (uint8_t)data);
	r2 = num2char(0x0F & ((uint8_t)(data >> 4)) );
	r3 = num2char(0x0F & ((uint8_t)(data >> 8)) );
	r4 = num2char(0x0F & ((uint8_t)(data >> 12)) );
    1346:	c0 e1       	ldi	r28, 0x10	; 16
    1348:	dc 02       	muls	r29, r28
    134a:	c1 2d       	mov	r28, r1
    134c:	dd 0b       	sbc	r29, r29
    134e:	11 24       	eor	r1, r1
    1350:	ce 01       	movw	r24, r28
    1352:	8f 70       	andi	r24, 0x0F	; 15
    1354:	68 2f       	mov	r22, r24
}
*/

char num2char(char c){
	
	if(c <10){
    1356:	8a 30       	cpi	r24, 0x0A	; 10
    1358:	10 f4       	brcc	.+4      	; 0x135e <send_frame+0x86>
		c += 48;
    135a:	60 5d       	subi	r22, 0xD0	; 208
    135c:	04 c0       	rjmp	.+8      	; 0x1366 <send_frame+0x8e>
	}
	else if((c >= 10) && (c <= 16)){
    135e:	8a 50       	subi	r24, 0x0A	; 10
    1360:	87 30       	cpi	r24, 0x07	; 7
    1362:	08 f4       	brcc	.+2      	; 0x1366 <send_frame+0x8e>
		c += 55;
    1364:	69 5c       	subi	r22, 0xC9	; 201
	r1 = num2char(0x0F & (uint8_t)data);
	r2 = num2char(0x0F & ((uint8_t)(data >> 4)) );
	r3 = num2char(0x0F & ((uint8_t)(data >> 8)) );
	r4 = num2char(0x0F & ((uint8_t)(data >> 12)) );

	uart3SendByte(r4);
    1366:	86 2f       	mov	r24, r22
    1368:	0e 94 3b 22 	call	0x4476	; 0x4476 <uart3SendByte>
	uart3SendByte(r3);
    136c:	81 2f       	mov	r24, r17
    136e:	0e 94 3b 22 	call	0x4476	; 0x4476 <uart3SendByte>
	uart3SendByte(r2);
    1372:	80 2f       	mov	r24, r16
    1374:	0e 94 3b 22 	call	0x4476	; 0x4476 <uart3SendByte>
	uart3SendByte(r1);
    1378:	8f 2d       	mov	r24, r15
    137a:	0e 94 3b 22 	call	0x4476	; 0x4476 <uart3SendByte>
	uart3SendByte('\n'); //line feed
    137e:	8a e0       	ldi	r24, 0x0A	; 10
    1380:	0e 94 3b 22 	call	0x4476	; 0x4476 <uart3SendByte>
}
    1384:	df 91       	pop	r29
    1386:	cf 91       	pop	r28
    1388:	1f 91       	pop	r17
    138a:	0f 91       	pop	r16
    138c:	ff 90       	pop	r15
    138e:	08 95       	ret

00001390 <vUpdatePose>:


	}
}

void vUpdatePose(){
    1390:	af 92       	push	r10
    1392:	bf 92       	push	r11
    1394:	cf 92       	push	r12
    1396:	df 92       	push	r13
    1398:	ef 92       	push	r14
    139a:	ff 92       	push	r15
    139c:	0f 93       	push	r16
    139e:	1f 93       	push	r17
	s16 dDis;
	float CMD_K = 0.5;
	float COR_K = 1;

	for(;;){
		robot.heading = (180 * enc_heading) / M_PI; 
    13a0:	60 91 bc 02 	lds	r22, 0x02BC
    13a4:	70 91 bd 02 	lds	r23, 0x02BD
    13a8:	80 91 be 02 	lds	r24, 0x02BE
    13ac:	90 91 bf 02 	lds	r25, 0x02BF
    13b0:	20 e0       	ldi	r18, 0x00	; 0
    13b2:	30 e0       	ldi	r19, 0x00	; 0
    13b4:	44 e3       	ldi	r20, 0x34	; 52
    13b6:	53 e4       	ldi	r21, 0x43	; 67
    13b8:	0e 94 37 2e 	call	0x5c6e	; 0x5c6e <__mulsf3>
    13bc:	2b ed       	ldi	r18, 0xDB	; 219
    13be:	3f e0       	ldi	r19, 0x0F	; 15
    13c0:	49 e4       	ldi	r20, 0x49	; 73
    13c2:	50 e4       	ldi	r21, 0x40	; 64
    13c4:	0e 94 e8 2c 	call	0x59d0	; 0x59d0 <__divsf3>
    13c8:	5b 01       	movw	r10, r22
    13ca:	6c 01       	movw	r12, r24
    13cc:	60 93 0b 12 	sts	0x120B, r22
    13d0:	70 93 0c 12 	sts	0x120C, r23
    13d4:	80 93 0d 12 	sts	0x120D, r24
    13d8:	90 93 0e 12 	sts	0x120E, r25
		v_offset = (0.5 * robot.heading) + CMD_K*cmd_angle + COR_K*correction_angle;
    13dc:	20 e0       	ldi	r18, 0x00	; 0
    13de:	30 e0       	ldi	r19, 0x00	; 0
    13e0:	40 e0       	ldi	r20, 0x00	; 0
    13e2:	5f e3       	ldi	r21, 0x3F	; 63
    13e4:	0e 94 37 2e 	call	0x5c6e	; 0x5c6e <__mulsf3>
    13e8:	7b 01       	movw	r14, r22
    13ea:	8c 01       	movw	r16, r24
    13ec:	60 91 c0 02 	lds	r22, 0x02C0
    13f0:	70 91 c1 02 	lds	r23, 0x02C1
    13f4:	88 27       	eor	r24, r24
    13f6:	77 fd       	sbrc	r23, 7
    13f8:	80 95       	com	r24
    13fa:	98 2f       	mov	r25, r24
    13fc:	0e 94 83 2d 	call	0x5b06	; 0x5b06 <__floatsisf>
    1400:	20 e0       	ldi	r18, 0x00	; 0
    1402:	30 e0       	ldi	r19, 0x00	; 0
    1404:	40 e0       	ldi	r20, 0x00	; 0
    1406:	5f e3       	ldi	r21, 0x3F	; 63
    1408:	0e 94 37 2e 	call	0x5c6e	; 0x5c6e <__mulsf3>
    140c:	9b 01       	movw	r18, r22
    140e:	ac 01       	movw	r20, r24
    1410:	c8 01       	movw	r24, r16
    1412:	b7 01       	movw	r22, r14
    1414:	0e 94 80 2c 	call	0x5900	; 0x5900 <__addsf3>
    1418:	20 91 c6 02 	lds	r18, 0x02C6
    141c:	30 91 c7 02 	lds	r19, 0x02C7
    1420:	40 91 c8 02 	lds	r20, 0x02C8
    1424:	50 91 c9 02 	lds	r21, 0x02C9
    1428:	0e 94 80 2c 	call	0x5900	; 0x5900 <__addsf3>
    142c:	0e 94 50 2d 	call	0x5aa0	; 0x5aa0 <__fixsfsi>
    1430:	70 93 a3 02 	sts	0x02A3, r23
    1434:	60 93 a2 02 	sts	0x02A2, r22
		robot.vel = (LEFTVel_current + (-RIGHTVel_current)) / 2;
    1438:	80 91 a4 02 	lds	r24, 0x02A4
    143c:	90 91 a5 02 	lds	r25, 0x02A5
    1440:	20 91 b0 02 	lds	r18, 0x02B0
    1444:	30 91 b1 02 	lds	r19, 0x02B1
    1448:	82 1b       	sub	r24, r18
    144a:	93 0b       	sbc	r25, r19
    144c:	62 e0       	ldi	r22, 0x02	; 2
    144e:	70 e0       	ldi	r23, 0x00	; 0
    1450:	0e 94 89 30 	call	0x6112	; 0x6112 <__divmodhi4>
    1454:	88 27       	eor	r24, r24
    1456:	77 fd       	sbrc	r23, 7
    1458:	80 95       	com	r24
    145a:	98 2f       	mov	r25, r24
    145c:	0e 94 83 2d 	call	0x5b06	; 0x5b06 <__floatsisf>
    1460:	60 93 0f 12 	sts	0x120F, r22
    1464:	70 93 10 12 	sts	0x1210, r23
    1468:	80 93 11 12 	sts	0x1211, r24
    146c:	90 93 12 12 	sts	0x1212, r25
		
		dRIGHTDis = (-RIGHTDis_current) - (-RIGHTDis_prev); 
    1470:	80 91 b2 02 	lds	r24, 0x02B2
    1474:	90 91 b3 02 	lds	r25, 0x02B3
    1478:	a0 91 b4 02 	lds	r26, 0x02B4
    147c:	b0 91 b5 02 	lds	r27, 0x02B5
    1480:	e0 90 b6 02 	lds	r14, 0x02B6
    1484:	f0 90 b7 02 	lds	r15, 0x02B7
    1488:	e8 1a       	sub	r14, r24
    148a:	f9 0a       	sbc	r15, r25
		RIGHTDis_prev = RIGHTDis_current;
    148c:	80 93 b6 02 	sts	0x02B6, r24
    1490:	90 93 b7 02 	sts	0x02B7, r25
    1494:	a0 93 b8 02 	sts	0x02B8, r26
    1498:	b0 93 b9 02 	sts	0x02B9, r27
		dLEFTDis = LEFTDis_current - LEFTDis_prev;
    149c:	80 91 a6 02 	lds	r24, 0x02A6
    14a0:	90 91 a7 02 	lds	r25, 0x02A7
    14a4:	a0 91 a8 02 	lds	r26, 0x02A8
    14a8:	b0 91 a9 02 	lds	r27, 0x02A9
    14ac:	20 91 aa 02 	lds	r18, 0x02AA
    14b0:	30 91 ab 02 	lds	r19, 0x02AB
    14b4:	8c 01       	movw	r16, r24
    14b6:	02 1b       	sub	r16, r18
    14b8:	13 0b       	sbc	r17, r19
		LEFTDis_prev = LEFTDis_current;
    14ba:	80 93 aa 02 	sts	0x02AA, r24
    14be:	90 93 ab 02 	sts	0x02AB, r25
    14c2:	a0 93 ac 02 	sts	0x02AC, r26
    14c6:	b0 93 ad 02 	sts	0x02AD, r27
		
		dDis = (10*(dRIGHTDis + dLEFTDis))/2;	//Send shifted value to avoid decimals
		dRIGHTDis = dLEFTDis = 0;
    14ca:	10 92 af 02 	sts	0x02AF, r1
    14ce:	10 92 ae 02 	sts	0x02AE, r1
    14d2:	10 92 bb 02 	sts	0x02BB, r1
    14d6:	10 92 ba 02 	sts	0x02BA, r1
		
		send_frame('H', robot.heading);
    14da:	c6 01       	movw	r24, r12
    14dc:	b5 01       	movw	r22, r10
    14de:	0e 94 50 2d 	call	0x5aa0	; 0x5aa0 <__fixsfsi>
    14e2:	9b 01       	movw	r18, r22
    14e4:	ac 01       	movw	r20, r24
    14e6:	88 e4       	ldi	r24, 0x48	; 72
    14e8:	b9 01       	movw	r22, r18
    14ea:	0e 94 6c 09 	call	0x12d8	; 0x12d8 <send_frame>
		send_frame('V', robot.vel);
    14ee:	60 91 0f 12 	lds	r22, 0x120F
    14f2:	70 91 10 12 	lds	r23, 0x1210
    14f6:	80 91 11 12 	lds	r24, 0x1211
    14fa:	90 91 12 12 	lds	r25, 0x1212
    14fe:	0e 94 50 2d 	call	0x5aa0	; 0x5aa0 <__fixsfsi>
    1502:	9b 01       	movw	r18, r22
    1504:	ac 01       	movw	r20, r24
    1506:	86 e5       	ldi	r24, 0x56	; 86
    1508:	b9 01       	movw	r22, r18
    150a:	0e 94 6c 09 	call	0x12d8	; 0x12d8 <send_frame>
		send_frame('S', dDis);
    150e:	0e 0d       	add	r16, r14
    1510:	1f 1d       	adc	r17, r15
    1512:	b8 01       	movw	r22, r16
    1514:	66 0f       	add	r22, r22
    1516:	77 1f       	adc	r23, r23
    1518:	66 0f       	add	r22, r22
    151a:	77 1f       	adc	r23, r23
    151c:	60 0f       	add	r22, r16
    151e:	71 1f       	adc	r23, r17
    1520:	83 e5       	ldi	r24, 0x53	; 83
    1522:	0e 94 6c 09 	call	0x12d8	; 0x12d8 <send_frame>
    1526:	3c cf       	rjmp	.-392    	; 0x13a0 <vUpdatePose+0x10>

00001528 <vServoOsc>:
	}

}


void vServoOsc(){
    1528:	7f 92       	push	r7
    152a:	8f 92       	push	r8
    152c:	9f 92       	push	r9
    152e:	af 92       	push	r10
    1530:	bf 92       	push	r11
    1532:	cf 92       	push	r12
    1534:	df 92       	push	r13
    1536:	ef 92       	push	r14
    1538:	ff 92       	push	r15
    153a:	0f 93       	push	r16
    153c:	1f 93       	push	r17
    153e:	df 93       	push	r29
    1540:	cf 93       	push	r28
    1542:	00 d0       	rcall	.+0      	; 0x1544 <vServoOsc+0x1c>
    1544:	cd b7       	in	r28, 0x3d	; 61
    1546:	de b7       	in	r29, 0x3e	; 62
	sbi(TCCR4A,COM4A1);
	cbi(TCCR4A,COM4A0);
}
void PWM_timer4_On_H4(void)
{
	sbi(TCCR4A,COM4B1);
    1548:	80 91 a0 00 	lds	r24, 0x00A0
    154c:	80 62       	ori	r24, 0x20	; 32
    154e:	80 93 a0 00 	sts	0x00A0, r24
	cbi(TCCR4A,COM4B0);
    1552:	80 91 a0 00 	lds	r24, 0x00A0
    1556:	8f 7e       	andi	r24, 0xEF	; 239
    1558:	80 93 a0 00 	sts	0x00A0, r24
	sbi(TCCR3A,COM3C1);
	cbi(TCCR3A,COM3C0);
}
void PWM_timer4_On_H3(void)
{
	sbi(TCCR4A,COM4A1);
    155c:	80 91 a0 00 	lds	r24, 0x00A0
    1560:	80 68       	ori	r24, 0x80	; 128
    1562:	80 93 a0 00 	sts	0x00A0, r24
	cbi(TCCR4A,COM4A0);
    1566:	80 91 a0 00 	lds	r24, 0x00A0
    156a:	8f 7b       	andi	r24, 0xBF	; 191
    156c:	80 93 a0 00 	sts	0x00A0, r24
    1570:	0a e7       	ldi	r16, 0x7A	; 122
    1572:	10 e0       	ldi	r17, 0x00	; 0
void PWM_timer3_Set_E5(u16 pwmDuty)
	{OCR3C = pwmDuty;}
void PWM_timer4_Set_H3(u16 pwmDuty)
	{OCR4A = pwmDuty;}
void PWM_timer4_Set_H4(u16 pwmDuty)
	{OCR4B = pwmDuty;}
    1574:	4c ec       	ldi	r20, 0xCC	; 204
    1576:	84 2e       	mov	r8, r20
    1578:	91 2c       	mov	r9, r1
		taskENTER_CRITICAL();
	//	PWM_timer3_Set_E3(i);	//right
		PWM_timer4_Set_H3(h3duty);	//left sprayer //originally 204
		PWM_timer4_Set_H4(204);	//right sprayer
		taskEXIT_CRITICAL();
		vTaskDelayUntil(&xLastWakeTime, (spray_time / portTICK_RATE_MS));
    157a:	5e 01       	movw	r10, r28
    157c:	08 94       	sec
    157e:	a1 1c       	adc	r10, r1
    1580:	b1 1c       	adc	r11, r1
		PWM_timer4_Set_H4(135);	
		taskEXIT_CRITICAL();
		vTaskDelayUntil(&xLastWakeTime, (spray_time / portTICK_RATE_MS));
		*/

		rprintf("%d", h3duty);
    1582:	77 24       	eor	r7, r7
    1584:	73 94       	inc	r7
    1586:	38 e7       	ldi	r19, 0x78	; 120
    1588:	c3 2e       	mov	r12, r19
    158a:	31 e0       	ldi	r19, 0x01	; 1
    158c:	d3 2e       	mov	r13, r19
		//rprintf(",");
		//rprintfNum(10, 5, 1, ' ', LEFTVel_current);
		rprintf("\n");
    158e:	26 e7       	ldi	r18, 0x76	; 118
    1590:	e2 2e       	mov	r14, r18
    1592:	21 e0       	ldi	r18, 0x01	; 1
    1594:	f2 2e       	mov	r15, r18
	spray_R_on();
	spray_L_on();
	uint16_t h3duty = 122;

	for(;;){
		if(h3duty > 1023){ h3duty = 0;}
    1596:	84 e0       	ldi	r24, 0x04	; 4
    1598:	00 30       	cpi	r16, 0x00	; 0
    159a:	18 07       	cpc	r17, r24
    159c:	10 f0       	brcs	.+4      	; 0x15a2 <vServoOsc+0x7a>
    159e:	00 e0       	ldi	r16, 0x00	; 0
    15a0:	10 e0       	ldi	r17, 0x00	; 0
		taskENTER_CRITICAL();
    15a2:	0f b6       	in	r0, 0x3f	; 63
    15a4:	f8 94       	cli
    15a6:	0f 92       	push	r0
void PWM_timer3_Set_E4(u16 pwmDuty)
	{OCR3B = pwmDuty;}
void PWM_timer3_Set_E5(u16 pwmDuty)
	{OCR3C = pwmDuty;}
void PWM_timer4_Set_H3(u16 pwmDuty)
	{OCR4A = pwmDuty;}
    15a8:	10 93 a9 00 	sts	0x00A9, r17
    15ac:	00 93 a8 00 	sts	0x00A8, r16
void PWM_timer4_Set_H4(u16 pwmDuty)
	{OCR4B = pwmDuty;}
    15b0:	90 92 ab 00 	sts	0x00AB, r9
    15b4:	80 92 aa 00 	sts	0x00AA, r8
	//	PWM_timer3_Set_E3(i);	//right
		PWM_timer4_Set_H3(h3duty);	//left sprayer //originally 204
		PWM_timer4_Set_H4(204);	//right sprayer
		taskEXIT_CRITICAL();
    15b8:	0f 90       	pop	r0
    15ba:	0f be       	out	0x3f, r0	; 63
		vTaskDelayUntil(&xLastWakeTime, (spray_time / portTICK_RATE_MS));
    15bc:	60 91 92 02 	lds	r22, 0x0292
    15c0:	70 91 93 02 	lds	r23, 0x0293
    15c4:	c5 01       	movw	r24, r10
    15c6:	0e 94 3c 15 	call	0x2a78	; 0x2a78 <vTaskDelayUntil>
		adj = uart1GetByte();
    15ca:	0e 94 f3 24 	call	0x49e6	; 0x49e6 <uart1GetByte>
		if(adj == 'p'){ h3duty++;;}
    15ce:	80 37       	cpi	r24, 0x70	; 112
    15d0:	19 f4       	brne	.+6      	; 0x15d8 <vServoOsc+0xb0>
    15d2:	0f 5f       	subi	r16, 0xFF	; 255
    15d4:	1f 4f       	sbci	r17, 0xFF	; 255
    15d6:	04 c0       	rjmp	.+8      	; 0x15e0 <vServoOsc+0xb8>
		else if(adj == 'l'){ h3duty--;}
    15d8:	8c 36       	cpi	r24, 0x6C	; 108
    15da:	11 f4       	brne	.+4      	; 0x15e0 <vServoOsc+0xb8>
    15dc:	01 50       	subi	r16, 0x01	; 1
    15de:	10 40       	sbci	r17, 0x00	; 0
		PWM_timer4_Set_H4(135);	
		taskEXIT_CRITICAL();
		vTaskDelayUntil(&xLastWakeTime, (spray_time / portTICK_RATE_MS));
		*/

		rprintf("%d", h3duty);
    15e0:	00 d0       	rcall	.+0      	; 0x15e2 <vServoOsc+0xba>
    15e2:	00 d0       	rcall	.+0      	; 0x15e4 <vServoOsc+0xbc>
    15e4:	0f 92       	push	r0
    15e6:	ed b7       	in	r30, 0x3d	; 61
    15e8:	fe b7       	in	r31, 0x3e	; 62
    15ea:	31 96       	adiw	r30, 0x01	; 1
    15ec:	ad b7       	in	r26, 0x3d	; 61
    15ee:	be b7       	in	r27, 0x3e	; 62
    15f0:	11 96       	adiw	r26, 0x01	; 1
    15f2:	7c 92       	st	X, r7
    15f4:	d2 82       	std	Z+2, r13	; 0x02
    15f6:	c1 82       	std	Z+1, r12	; 0x01
    15f8:	14 83       	std	Z+4, r17	; 0x04
    15fa:	03 83       	std	Z+3, r16	; 0x03
    15fc:	0e 94 46 29 	call	0x528c	; 0x528c <rprintf1RamRom>
		//rprintf(",");
		//rprintfNum(10, 5, 1, ' ', LEFTVel_current);
		rprintf("\n");
    1600:	0f 90       	pop	r0
    1602:	0f 90       	pop	r0
    1604:	ed b7       	in	r30, 0x3d	; 61
    1606:	fe b7       	in	r31, 0x3e	; 62
    1608:	71 82       	std	Z+1, r7	; 0x01
    160a:	f3 82       	std	Z+3, r15	; 0x03
    160c:	e2 82       	std	Z+2, r14	; 0x02
    160e:	0e 94 46 29 	call	0x528c	; 0x528c <rprintf1RamRom>
	
		h3duty++;
    1612:	0f 5f       	subi	r16, 0xFF	; 255
    1614:	1f 4f       	sbci	r17, 0xFF	; 255
    1616:	0f 90       	pop	r0
    1618:	0f 90       	pop	r0
    161a:	0f 90       	pop	r0
    161c:	bc cf       	rjmp	.-136    	; 0x1596 <vServoOsc+0x6e>

0000161e <vServoTm>:
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
		LED_off();
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));	}
}

void vServoTm(){
    161e:	1f 93       	push	r17
    1620:	cf 93       	push	r28
    1622:	df 93       	push	r29
	char adj;
	for(;;){
		adj = uart1GetByte();
		if(adj == 'p'){ spray_time++;}
		else if(adj == 'l'){ spray_time--;}
		rprintf("%d\n", spray_time);
    1624:	11 e0       	ldi	r17, 0x01	; 1
    1626:	cb e7       	ldi	r28, 0x7B	; 123
    1628:	d1 e0       	ldi	r29, 0x01	; 1
}

void vServoTm(){
	char adj;
	for(;;){
		adj = uart1GetByte();
    162a:	0e 94 f3 24 	call	0x49e6	; 0x49e6 <uart1GetByte>
		if(adj == 'p'){ spray_time++;}
    162e:	80 37       	cpi	r24, 0x70	; 112
    1630:	31 f4       	brne	.+12     	; 0x163e <vServoTm+0x20>
    1632:	80 91 92 02 	lds	r24, 0x0292
    1636:	90 91 93 02 	lds	r25, 0x0293
    163a:	01 96       	adiw	r24, 0x01	; 1
    163c:	07 c0       	rjmp	.+14     	; 0x164c <vServoTm+0x2e>
		else if(adj == 'l'){ spray_time--;}
    163e:	8c 36       	cpi	r24, 0x6C	; 108
    1640:	49 f4       	brne	.+18     	; 0x1654 <vServoTm+0x36>
    1642:	80 91 92 02 	lds	r24, 0x0292
    1646:	90 91 93 02 	lds	r25, 0x0293
    164a:	01 97       	sbiw	r24, 0x01	; 1
    164c:	90 93 93 02 	sts	0x0293, r25
    1650:	80 93 92 02 	sts	0x0292, r24
		rprintf("%d\n", spray_time);
    1654:	00 d0       	rcall	.+0      	; 0x1656 <vServoTm+0x38>
    1656:	00 d0       	rcall	.+0      	; 0x1658 <vServoTm+0x3a>
    1658:	0f 92       	push	r0
    165a:	ed b7       	in	r30, 0x3d	; 61
    165c:	fe b7       	in	r31, 0x3e	; 62
    165e:	31 96       	adiw	r30, 0x01	; 1
    1660:	ad b7       	in	r26, 0x3d	; 61
    1662:	be b7       	in	r27, 0x3e	; 62
    1664:	11 96       	adiw	r26, 0x01	; 1
    1666:	1c 93       	st	X, r17
    1668:	d2 83       	std	Z+2, r29	; 0x02
    166a:	c1 83       	std	Z+1, r28	; 0x01
    166c:	80 91 92 02 	lds	r24, 0x0292
    1670:	90 91 93 02 	lds	r25, 0x0293
    1674:	94 83       	std	Z+4, r25	; 0x04
    1676:	83 83       	std	Z+3, r24	; 0x03
    1678:	0e 94 46 29 	call	0x528c	; 0x528c <rprintf1RamRom>
    167c:	0f 90       	pop	r0
    167e:	0f 90       	pop	r0
    1680:	0f 90       	pop	r0
    1682:	0f 90       	pop	r0
    1684:	0f 90       	pop	r0
    1686:	d1 cf       	rjmp	.-94     	; 0x162a <vServoTm+0xc>

00001688 <sharp_IR_interpret_GP2Y0A21YK>:
	}

//Sharp GP2Y0A21YK IR Range Sensor - 4 cm to 30 cm
int sharp_IR_interpret_GP2Y0A21YK(int value)
	{
	return 739.38*pow(value,-.8105);
    1688:	aa 27       	eor	r26, r26
    168a:	97 fd       	sbrc	r25, 7
    168c:	a0 95       	com	r26
    168e:	ba 2f       	mov	r27, r26
    1690:	bc 01       	movw	r22, r24
    1692:	cd 01       	movw	r24, r26
    1694:	0e 94 83 2d 	call	0x5b06	; 0x5b06 <__floatsisf>
    1698:	2e ee       	ldi	r18, 0xEE	; 238
    169a:	3c e7       	ldi	r19, 0x7C	; 124
    169c:	4f e4       	ldi	r20, 0x4F	; 79
    169e:	5f eb       	ldi	r21, 0xBF	; 191
    16a0:	0e 94 9a 2e 	call	0x5d34	; 0x5d34 <pow>
    16a4:	9b 01       	movw	r18, r22
    16a6:	ac 01       	movw	r20, r24
    16a8:	ca 01       	movw	r24, r20
    16aa:	b9 01       	movw	r22, r18
    16ac:	22 e5       	ldi	r18, 0x52	; 82
    16ae:	38 ed       	ldi	r19, 0xD8	; 216
    16b0:	48 e3       	ldi	r20, 0x38	; 56
    16b2:	54 e4       	ldi	r21, 0x44	; 68
    16b4:	0e 94 37 2e 	call	0x5c6e	; 0x5c6e <__mulsf3>
    16b8:	0e 94 50 2d 	call	0x5aa0	; 0x5aa0 <__fixsfsi>
	}
    16bc:	cb 01       	movw	r24, r22
    16be:	08 95       	ret

000016c0 <sharp_IR_interpret_GP2D12>:

//***FROM THE SoR LIBRARIES
//Sharp GP2D12 IR Range Sensor -  claims 10cm to 80cm (I got 8cm to 150cm)
int sharp_IR_interpret_GP2D12(int value)
	{
	return 1384.4*pow(value,-.9988);
    16c0:	aa 27       	eor	r26, r26
    16c2:	97 fd       	sbrc	r25, 7
    16c4:	a0 95       	com	r26
    16c6:	ba 2f       	mov	r27, r26
    16c8:	bc 01       	movw	r22, r24
    16ca:	cd 01       	movw	r24, r26
    16cc:	0e 94 83 2d 	call	0x5b06	; 0x5b06 <__floatsisf>
    16d0:	2b e5       	ldi	r18, 0x5B	; 91
    16d2:	31 eb       	ldi	r19, 0xB1	; 177
    16d4:	4f e7       	ldi	r20, 0x7F	; 127
    16d6:	5f eb       	ldi	r21, 0xBF	; 191
    16d8:	0e 94 9a 2e 	call	0x5d34	; 0x5d34 <pow>
    16dc:	9b 01       	movw	r18, r22
    16de:	ac 01       	movw	r20, r24
    16e0:	ca 01       	movw	r24, r20
    16e2:	b9 01       	movw	r22, r18
    16e4:	2d ec       	ldi	r18, 0xCD	; 205
    16e6:	3c e0       	ldi	r19, 0x0C	; 12
    16e8:	4d ea       	ldi	r20, 0xAD	; 173
    16ea:	54 e4       	ldi	r21, 0x44	; 68
    16ec:	0e 94 37 2e 	call	0x5c6e	; 0x5c6e <__mulsf3>
    16f0:	0e 94 50 2d 	call	0x5aa0	; 0x5aa0 <__fixsfsi>
	}
    16f4:	cb 01       	movw	r24, r22
    16f6:	08 95       	ret

000016f8 <vReadIR>:
		
	
	}
}

void vReadIR(){
    16f8:	2f 92       	push	r2
    16fa:	3f 92       	push	r3
    16fc:	4f 92       	push	r4
    16fe:	5f 92       	push	r5
    1700:	6f 92       	push	r6
    1702:	7f 92       	push	r7
    1704:	8f 92       	push	r8
    1706:	9f 92       	push	r9
    1708:	af 92       	push	r10
    170a:	bf 92       	push	r11
    170c:	cf 92       	push	r12
    170e:	df 92       	push	r13
    1710:	ef 92       	push	r14
    1712:	ff 92       	push	r15
    1714:	0f 93       	push	r16
    1716:	1f 93       	push	r17
    1718:	df 93       	push	r29
    171a:	cf 93       	push	r28
    171c:	cd b7       	in	r28, 0x3d	; 61
    171e:	de b7       	in	r29, 0x3e	; 62
    1720:	2d 97       	sbiw	r28, 0x0d	; 13
    1722:	0f b6       	in	r0, 0x3f	; 63
    1724:	f8 94       	cli
    1726:	de bf       	out	0x3e, r29	; 62
    1728:	0f be       	out	0x3f, r0	; 63
    172a:	cd bf       	out	0x3d, r28	; 61
    172c:	0f 2e       	mov	r0, r31
    172e:	f0 e0       	ldi	r31, 0x00	; 0
    1730:	ef 2e       	mov	r14, r31
    1732:	f0 e0       	ldi	r31, 0x00	; 0
    1734:	ff 2e       	mov	r15, r31
    1736:	f0 e0       	ldi	r31, 0x00	; 0
    1738:	0f 2f       	mov	r16, r31
    173a:	f0 e0       	ldi	r31, 0x00	; 0
    173c:	1f 2f       	mov	r17, r31
    173e:	f0 2d       	mov	r31, r0
    1740:	57 01       	movw	r10, r14
    1742:	68 01       	movw	r12, r16
    1744:	ea 86       	std	Y+10, r14	; 0x0a
    1746:	fb 86       	std	Y+11, r15	; 0x0b
    1748:	0c 87       	std	Y+12, r16	; 0x0c
    174a:	1d 87       	std	Y+13, r17	; 0x0d
    174c:	37 01       	movw	r6, r14
    174e:	48 01       	movw	r8, r16
    1750:	17 01       	movw	r2, r14
    1752:	28 01       	movw	r4, r16
    1754:	19 82       	std	Y+1, r1	; 0x01
    1756:	93 c0       	rjmp	.+294    	; 0x187e <vReadIR+0x186>
	float cor_coeff;
	float vel_coeff;

	for(;;){
		for(uint8_t itr = 0; itr < NUM_IR_READS; itr++){
			n90_range  += ((float)sharp_IR_interpret_GP2Y0A21YK(a2dConvert8bit(2)))/NUM_IR_READS;
    1758:	82 e0       	ldi	r24, 0x02	; 2
    175a:	0e 94 0c 27 	call	0x4e18	; 0x4e18 <a2dConvert8bit>
    175e:	90 e0       	ldi	r25, 0x00	; 0
    1760:	0e 94 44 0b 	call	0x1688	; 0x1688 <sharp_IR_interpret_GP2Y0A21YK>
    1764:	aa 27       	eor	r26, r26
    1766:	97 fd       	sbrc	r25, 7
    1768:	a0 95       	com	r26
    176a:	ba 2f       	mov	r27, r26
    176c:	bc 01       	movw	r22, r24
    176e:	cd 01       	movw	r24, r26
    1770:	0e 94 83 2d 	call	0x5b06	; 0x5b06 <__floatsisf>
    1774:	20 e0       	ldi	r18, 0x00	; 0
    1776:	30 e0       	ldi	r19, 0x00	; 0
    1778:	40 e2       	ldi	r20, 0x20	; 32
    177a:	51 e4       	ldi	r21, 0x41	; 65
    177c:	0e 94 e8 2c 	call	0x59d0	; 0x59d0 <__divsf3>
    1780:	9b 01       	movw	r18, r22
    1782:	ac 01       	movw	r20, r24
    1784:	c8 01       	movw	r24, r16
    1786:	b7 01       	movw	r22, r14
    1788:	0e 94 80 2c 	call	0x5900	; 0x5900 <__addsf3>
    178c:	7b 01       	movw	r14, r22
    178e:	8c 01       	movw	r16, r24
			zero_range += ((float)sharp_IR_interpret_GP2D12(a2dConvert8bit(3)))/NUM_IR_READS;
    1790:	83 e0       	ldi	r24, 0x03	; 3
    1792:	0e 94 0c 27 	call	0x4e18	; 0x4e18 <a2dConvert8bit>
    1796:	90 e0       	ldi	r25, 0x00	; 0
    1798:	0e 94 60 0b 	call	0x16c0	; 0x16c0 <sharp_IR_interpret_GP2D12>
    179c:	aa 27       	eor	r26, r26
    179e:	97 fd       	sbrc	r25, 7
    17a0:	a0 95       	com	r26
    17a2:	ba 2f       	mov	r27, r26
    17a4:	bc 01       	movw	r22, r24
    17a6:	cd 01       	movw	r24, r26
    17a8:	0e 94 83 2d 	call	0x5b06	; 0x5b06 <__floatsisf>
    17ac:	20 e0       	ldi	r18, 0x00	; 0
    17ae:	30 e0       	ldi	r19, 0x00	; 0
    17b0:	40 e2       	ldi	r20, 0x20	; 32
    17b2:	51 e4       	ldi	r21, 0x41	; 65
    17b4:	0e 94 e8 2c 	call	0x59d0	; 0x59d0 <__divsf3>
    17b8:	9b 01       	movw	r18, r22
    17ba:	ac 01       	movw	r20, r24
    17bc:	6a 85       	ldd	r22, Y+10	; 0x0a
    17be:	7b 85       	ldd	r23, Y+11	; 0x0b
    17c0:	8c 85       	ldd	r24, Y+12	; 0x0c
    17c2:	9d 85       	ldd	r25, Y+13	; 0x0d
    17c4:	0e 94 80 2c 	call	0x5900	; 0x5900 <__addsf3>
    17c8:	6a 87       	std	Y+10, r22	; 0x0a
    17ca:	7b 87       	std	Y+11, r23	; 0x0b
    17cc:	8c 87       	std	Y+12, r24	; 0x0c
    17ce:	9d 87       	std	Y+13, r25	; 0x0d
			p90_range  += ((float)sharp_IR_interpret_GP2D12(a2dConvert8bit(4)))/NUM_IR_READS;
    17d0:	84 e0       	ldi	r24, 0x04	; 4
    17d2:	0e 94 0c 27 	call	0x4e18	; 0x4e18 <a2dConvert8bit>
    17d6:	90 e0       	ldi	r25, 0x00	; 0
    17d8:	0e 94 60 0b 	call	0x16c0	; 0x16c0 <sharp_IR_interpret_GP2D12>
    17dc:	aa 27       	eor	r26, r26
    17de:	97 fd       	sbrc	r25, 7
    17e0:	a0 95       	com	r26
    17e2:	ba 2f       	mov	r27, r26
    17e4:	bc 01       	movw	r22, r24
    17e6:	cd 01       	movw	r24, r26
    17e8:	0e 94 83 2d 	call	0x5b06	; 0x5b06 <__floatsisf>
    17ec:	20 e0       	ldi	r18, 0x00	; 0
    17ee:	30 e0       	ldi	r19, 0x00	; 0
    17f0:	40 e2       	ldi	r20, 0x20	; 32
    17f2:	51 e4       	ldi	r21, 0x41	; 65
    17f4:	0e 94 e8 2c 	call	0x59d0	; 0x59d0 <__divsf3>
    17f8:	9b 01       	movw	r18, r22
    17fa:	ac 01       	movw	r20, r24
    17fc:	c6 01       	movw	r24, r12
    17fe:	b5 01       	movw	r22, r10
    1800:	0e 94 80 2c 	call	0x5900	; 0x5900 <__addsf3>
    1804:	5b 01       	movw	r10, r22
    1806:	6c 01       	movw	r12, r24
			p45_range  += ((float)sharp_IR_interpret_GP2Y0A21YK(a2dConvert8bit(5)))/NUM_IR_READS;
    1808:	85 e0       	ldi	r24, 0x05	; 5
    180a:	0e 94 0c 27 	call	0x4e18	; 0x4e18 <a2dConvert8bit>
    180e:	90 e0       	ldi	r25, 0x00	; 0
    1810:	0e 94 44 0b 	call	0x1688	; 0x1688 <sharp_IR_interpret_GP2Y0A21YK>
    1814:	aa 27       	eor	r26, r26
    1816:	97 fd       	sbrc	r25, 7
    1818:	a0 95       	com	r26
    181a:	ba 2f       	mov	r27, r26
    181c:	bc 01       	movw	r22, r24
    181e:	cd 01       	movw	r24, r26
    1820:	0e 94 83 2d 	call	0x5b06	; 0x5b06 <__floatsisf>
    1824:	20 e0       	ldi	r18, 0x00	; 0
    1826:	30 e0       	ldi	r19, 0x00	; 0
    1828:	40 e2       	ldi	r20, 0x20	; 32
    182a:	51 e4       	ldi	r21, 0x41	; 65
    182c:	0e 94 e8 2c 	call	0x59d0	; 0x59d0 <__divsf3>
    1830:	9b 01       	movw	r18, r22
    1832:	ac 01       	movw	r20, r24
    1834:	c2 01       	movw	r24, r4
    1836:	b1 01       	movw	r22, r2
    1838:	0e 94 80 2c 	call	0x5900	; 0x5900 <__addsf3>
    183c:	1b 01       	movw	r2, r22
    183e:	2c 01       	movw	r4, r24
			n45_range  += ((float)sharp_IR_interpret_GP2Y0A21YK(a2dConvert8bit(6)))/NUM_IR_READS;
    1840:	86 e0       	ldi	r24, 0x06	; 6
    1842:	0e 94 0c 27 	call	0x4e18	; 0x4e18 <a2dConvert8bit>
    1846:	90 e0       	ldi	r25, 0x00	; 0
    1848:	0e 94 44 0b 	call	0x1688	; 0x1688 <sharp_IR_interpret_GP2Y0A21YK>
    184c:	aa 27       	eor	r26, r26
    184e:	97 fd       	sbrc	r25, 7
    1850:	a0 95       	com	r26
    1852:	ba 2f       	mov	r27, r26
    1854:	bc 01       	movw	r22, r24
    1856:	cd 01       	movw	r24, r26
    1858:	0e 94 83 2d 	call	0x5b06	; 0x5b06 <__floatsisf>
    185c:	20 e0       	ldi	r18, 0x00	; 0
    185e:	30 e0       	ldi	r19, 0x00	; 0
    1860:	40 e2       	ldi	r20, 0x20	; 32
    1862:	51 e4       	ldi	r21, 0x41	; 65
    1864:	0e 94 e8 2c 	call	0x59d0	; 0x59d0 <__divsf3>
    1868:	9b 01       	movw	r18, r22
    186a:	ac 01       	movw	r20, r24
    186c:	c4 01       	movw	r24, r8
    186e:	b3 01       	movw	r22, r6
    1870:	0e 94 80 2c 	call	0x5900	; 0x5900 <__addsf3>
    1874:	3b 01       	movw	r6, r22
    1876:	4c 01       	movw	r8, r24

	float cor_coeff;
	float vel_coeff;

	for(;;){
		for(uint8_t itr = 0; itr < NUM_IR_READS; itr++){
    1878:	89 81       	ldd	r24, Y+1	; 0x01
    187a:	8f 5f       	subi	r24, 0xFF	; 255
    187c:	89 83       	std	Y+1, r24	; 0x01
    187e:	99 81       	ldd	r25, Y+1	; 0x01
    1880:	9a 30       	cpi	r25, 0x0A	; 10
    1882:	08 f4       	brcc	.+2      	; 0x1886 <vReadIR+0x18e>
    1884:	69 cf       	rjmp	.-302    	; 0x1758 <vReadIR+0x60>
			p45_range  += ((float)sharp_IR_interpret_GP2Y0A21YK(a2dConvert8bit(5)))/NUM_IR_READS;
			n45_range  += ((float)sharp_IR_interpret_GP2Y0A21YK(a2dConvert8bit(6)))/NUM_IR_READS;
		}
//		rprintf("IR[-90]: %d\tIR[-45]: %d\tIR[0]: %d\tin_vel: %d\tvel_cmd: %d\t",(uint8_t)n90_range, (uint8_t)n45_range, (uint8_t)zero_range, (int32_t)inst_cmd_vel, (int32_t)v_command);

		denom_n90 = ((n90_range)-IR_TO_EDGE)*((n90_range)-IR_TO_EDGE);
    1886:	c8 01       	movw	r24, r16
    1888:	b7 01       	movw	r22, r14
    188a:	20 e0       	ldi	r18, 0x00	; 0
    188c:	30 e0       	ldi	r19, 0x00	; 0
    188e:	40 e2       	ldi	r20, 0x20	; 32
    1890:	51 e4       	ldi	r21, 0x41	; 65
    1892:	0e 94 7f 2c 	call	0x58fe	; 0x58fe <__subsf3>
    1896:	9b 01       	movw	r18, r22
    1898:	ac 01       	movw	r20, r24
    189a:	0e 94 37 2e 	call	0x5c6e	; 0x5c6e <__mulsf3>
    189e:	7b 01       	movw	r14, r22
    18a0:	8c 01       	movw	r16, r24
		denom_p90 = ((p90_range)-IR_TO_EDGE)*((p90_range)-IR_TO_EDGE);
    18a2:	c6 01       	movw	r24, r12
    18a4:	b5 01       	movw	r22, r10
    18a6:	20 e0       	ldi	r18, 0x00	; 0
    18a8:	30 e0       	ldi	r19, 0x00	; 0
    18aa:	40 e2       	ldi	r20, 0x20	; 32
    18ac:	51 e4       	ldi	r21, 0x41	; 65
    18ae:	0e 94 7f 2c 	call	0x58fe	; 0x58fe <__subsf3>
    18b2:	9b 01       	movw	r18, r22
    18b4:	ac 01       	movw	r20, r24
    18b6:	0e 94 37 2e 	call	0x5c6e	; 0x5c6e <__mulsf3>
    18ba:	5b 01       	movw	r10, r22
    18bc:	6c 01       	movw	r12, r24
		denom_n45 = ((n45_range)-IR_TO_EDGE)*((n45_range)-IR_TO_EDGE);
    18be:	c4 01       	movw	r24, r8
    18c0:	b3 01       	movw	r22, r6
    18c2:	20 e0       	ldi	r18, 0x00	; 0
    18c4:	30 e0       	ldi	r19, 0x00	; 0
    18c6:	40 e2       	ldi	r20, 0x20	; 32
    18c8:	51 e4       	ldi	r21, 0x41	; 65
    18ca:	0e 94 7f 2c 	call	0x58fe	; 0x58fe <__subsf3>
    18ce:	9b 01       	movw	r18, r22
    18d0:	ac 01       	movw	r20, r24
    18d2:	0e 94 37 2e 	call	0x5c6e	; 0x5c6e <__mulsf3>
    18d6:	3b 01       	movw	r6, r22
    18d8:	4c 01       	movw	r8, r24
		denom_p45 = ((p45_range)-IR_TO_EDGE)*((p45_range)-IR_TO_EDGE);
    18da:	c2 01       	movw	r24, r4
    18dc:	b1 01       	movw	r22, r2
    18de:	20 e0       	ldi	r18, 0x00	; 0
    18e0:	30 e0       	ldi	r19, 0x00	; 0
    18e2:	40 e2       	ldi	r20, 0x20	; 32
    18e4:	51 e4       	ldi	r21, 0x41	; 65
    18e6:	0e 94 7f 2c 	call	0x58fe	; 0x58fe <__subsf3>
    18ea:	9b 01       	movw	r18, r22
    18ec:	ac 01       	movw	r20, r24
    18ee:	0e 94 37 2e 	call	0x5c6e	; 0x5c6e <__mulsf3>
    18f2:	6e 83       	std	Y+6, r22	; 0x06
    18f4:	7f 83       	std	Y+7, r23	; 0x07
    18f6:	88 87       	std	Y+8, r24	; 0x08
    18f8:	99 87       	std	Y+9, r25	; 0x09
		
		if(denom_n90 != 0){
    18fa:	c8 01       	movw	r24, r16
    18fc:	b7 01       	movw	r22, r14
    18fe:	20 e0       	ldi	r18, 0x00	; 0
    1900:	30 e0       	ldi	r19, 0x00	; 0
    1902:	40 e0       	ldi	r20, 0x00	; 0
    1904:	50 e0       	ldi	r21, 0x00	; 0
    1906:	0e 94 e4 2c 	call	0x59c8	; 0x59c8 <__cmpsf2>
    190a:	88 23       	and	r24, r24
    190c:	a1 f0       	breq	.+40     	; 0x1936 <vReadIR+0x23e>
			cor_ang_n90 =  1000.0/denom_n90;
    190e:	60 e0       	ldi	r22, 0x00	; 0
    1910:	70 e0       	ldi	r23, 0x00	; 0
    1912:	8a e7       	ldi	r24, 0x7A	; 122
    1914:	94 e4       	ldi	r25, 0x44	; 68
    1916:	a8 01       	movw	r20, r16
    1918:	97 01       	movw	r18, r14
    191a:	0e 94 e8 2c 	call	0x59d0	; 0x59d0 <__divsf3>
    191e:	6a 83       	std	Y+2, r22	; 0x02
    1920:	7b 83       	std	Y+3, r23	; 0x03
    1922:	8c 83       	std	Y+4, r24	; 0x04
    1924:	9d 83       	std	Y+5, r25	; 0x05
			if(cor_ang_n90 > 90){cor_ang_n90 = 90;}
    1926:	20 e0       	ldi	r18, 0x00	; 0
    1928:	30 e0       	ldi	r19, 0x00	; 0
    192a:	44 eb       	ldi	r20, 0xB4	; 180
    192c:	52 e4       	ldi	r21, 0x42	; 66
    192e:	0e 94 33 2e 	call	0x5c66	; 0x5c66 <__gesf2>
    1932:	18 16       	cp	r1, r24
    1934:	2c f4       	brge	.+10     	; 0x1940 <vReadIR+0x248>
    1936:	80 e0       	ldi	r24, 0x00	; 0
    1938:	90 e0       	ldi	r25, 0x00	; 0
    193a:	a4 eb       	ldi	r26, 0xB4	; 180
    193c:	b2 e4       	ldi	r27, 0x42	; 66
    193e:	10 c0       	rjmp	.+32     	; 0x1960 <vReadIR+0x268>
			if(cor_ang_n90 < -90){cor_ang_n90 = -90;}
    1940:	6a 81       	ldd	r22, Y+2	; 0x02
    1942:	7b 81       	ldd	r23, Y+3	; 0x03
    1944:	8c 81       	ldd	r24, Y+4	; 0x04
    1946:	9d 81       	ldd	r25, Y+5	; 0x05
    1948:	20 e0       	ldi	r18, 0x00	; 0
    194a:	30 e0       	ldi	r19, 0x00	; 0
    194c:	44 eb       	ldi	r20, 0xB4	; 180
    194e:	52 ec       	ldi	r21, 0xC2	; 194
    1950:	0e 94 e4 2c 	call	0x59c8	; 0x59c8 <__cmpsf2>
    1954:	88 23       	and	r24, r24
    1956:	44 f4       	brge	.+16     	; 0x1968 <vReadIR+0x270>
    1958:	80 e0       	ldi	r24, 0x00	; 0
    195a:	90 e0       	ldi	r25, 0x00	; 0
    195c:	a4 eb       	ldi	r26, 0xB4	; 180
    195e:	b2 ec       	ldi	r27, 0xC2	; 194
    1960:	8a 83       	std	Y+2, r24	; 0x02
    1962:	9b 83       	std	Y+3, r25	; 0x03
    1964:	ac 83       	std	Y+4, r26	; 0x04
    1966:	bd 83       	std	Y+5, r27	; 0x05
		}
		else{cor_ang_n90 = 90;}

		if(denom_p90 != 0){
    1968:	c6 01       	movw	r24, r12
    196a:	b5 01       	movw	r22, r10
    196c:	20 e0       	ldi	r18, 0x00	; 0
    196e:	30 e0       	ldi	r19, 0x00	; 0
    1970:	40 e0       	ldi	r20, 0x00	; 0
    1972:	50 e0       	ldi	r21, 0x00	; 0
    1974:	0e 94 e4 2c 	call	0x59c8	; 0x59c8 <__cmpsf2>
    1978:	88 23       	and	r24, r24
    197a:	91 f0       	breq	.+36     	; 0x19a0 <vReadIR+0x2a8>
			cor_ang_p90 =  1000.0/denom_p90;
    197c:	60 e0       	ldi	r22, 0x00	; 0
    197e:	70 e0       	ldi	r23, 0x00	; 0
    1980:	8a e7       	ldi	r24, 0x7A	; 122
    1982:	94 e4       	ldi	r25, 0x44	; 68
    1984:	a6 01       	movw	r20, r12
    1986:	95 01       	movw	r18, r10
    1988:	0e 94 e8 2c 	call	0x59d0	; 0x59d0 <__divsf3>
    198c:	7b 01       	movw	r14, r22
    198e:	8c 01       	movw	r16, r24
			if(cor_ang_p90 > 90){cor_ang_p90 = 90;}
    1990:	20 e0       	ldi	r18, 0x00	; 0
    1992:	30 e0       	ldi	r19, 0x00	; 0
    1994:	44 eb       	ldi	r20, 0xB4	; 180
    1996:	52 e4       	ldi	r21, 0x42	; 66
    1998:	0e 94 33 2e 	call	0x5c66	; 0x5c66 <__gesf2>
    199c:	18 16       	cp	r1, r24
    199e:	5c f4       	brge	.+22     	; 0x19b6 <vReadIR+0x2be>
    19a0:	0f 2e       	mov	r0, r31
    19a2:	f0 e0       	ldi	r31, 0x00	; 0
    19a4:	ef 2e       	mov	r14, r31
    19a6:	f0 e0       	ldi	r31, 0x00	; 0
    19a8:	ff 2e       	mov	r15, r31
    19aa:	f4 eb       	ldi	r31, 0xB4	; 180
    19ac:	0f 2f       	mov	r16, r31
    19ae:	f2 e4       	ldi	r31, 0x42	; 66
    19b0:	1f 2f       	mov	r17, r31
    19b2:	f0 2d       	mov	r31, r0
    19b4:	14 c0       	rjmp	.+40     	; 0x19de <vReadIR+0x2e6>
			if(cor_ang_p90 < -90){cor_ang_p90 = -90;}
    19b6:	c8 01       	movw	r24, r16
    19b8:	b7 01       	movw	r22, r14
    19ba:	20 e0       	ldi	r18, 0x00	; 0
    19bc:	30 e0       	ldi	r19, 0x00	; 0
    19be:	44 eb       	ldi	r20, 0xB4	; 180
    19c0:	52 ec       	ldi	r21, 0xC2	; 194
    19c2:	0e 94 e4 2c 	call	0x59c8	; 0x59c8 <__cmpsf2>
    19c6:	88 23       	and	r24, r24
    19c8:	54 f4       	brge	.+20     	; 0x19de <vReadIR+0x2e6>
    19ca:	0f 2e       	mov	r0, r31
    19cc:	f0 e0       	ldi	r31, 0x00	; 0
    19ce:	ef 2e       	mov	r14, r31
    19d0:	f0 e0       	ldi	r31, 0x00	; 0
    19d2:	ff 2e       	mov	r15, r31
    19d4:	f4 eb       	ldi	r31, 0xB4	; 180
    19d6:	0f 2f       	mov	r16, r31
    19d8:	f2 ec       	ldi	r31, 0xC2	; 194
    19da:	1f 2f       	mov	r17, r31
    19dc:	f0 2d       	mov	r31, r0
		}
		else{cor_ang_p90 = 90;}

		if(denom_n45 != 0){
    19de:	c4 01       	movw	r24, r8
    19e0:	b3 01       	movw	r22, r6
    19e2:	20 e0       	ldi	r18, 0x00	; 0
    19e4:	30 e0       	ldi	r19, 0x00	; 0
    19e6:	40 e0       	ldi	r20, 0x00	; 0
    19e8:	50 e0       	ldi	r21, 0x00	; 0
    19ea:	0e 94 e4 2c 	call	0x59c8	; 0x59c8 <__cmpsf2>
    19ee:	88 23       	and	r24, r24
    19f0:	91 f0       	breq	.+36     	; 0x1a16 <vReadIR+0x31e>
			cor_ang_n45 =  1000.0/denom_n45;
    19f2:	60 e0       	ldi	r22, 0x00	; 0
    19f4:	70 e0       	ldi	r23, 0x00	; 0
    19f6:	8a e7       	ldi	r24, 0x7A	; 122
    19f8:	94 e4       	ldi	r25, 0x44	; 68
    19fa:	a4 01       	movw	r20, r8
    19fc:	93 01       	movw	r18, r6
    19fe:	0e 94 e8 2c 	call	0x59d0	; 0x59d0 <__divsf3>
    1a02:	1b 01       	movw	r2, r22
    1a04:	2c 01       	movw	r4, r24
			if(cor_ang_n45 > 90){cor_ang_n45 = 90;}
    1a06:	20 e0       	ldi	r18, 0x00	; 0
    1a08:	30 e0       	ldi	r19, 0x00	; 0
    1a0a:	44 eb       	ldi	r20, 0xB4	; 180
    1a0c:	52 e4       	ldi	r21, 0x42	; 66
    1a0e:	0e 94 33 2e 	call	0x5c66	; 0x5c66 <__gesf2>
    1a12:	18 16       	cp	r1, r24
    1a14:	5c f4       	brge	.+22     	; 0x1a2c <vReadIR+0x334>
    1a16:	0f 2e       	mov	r0, r31
    1a18:	f0 e0       	ldi	r31, 0x00	; 0
    1a1a:	2f 2e       	mov	r2, r31
    1a1c:	f0 e0       	ldi	r31, 0x00	; 0
    1a1e:	3f 2e       	mov	r3, r31
    1a20:	f4 eb       	ldi	r31, 0xB4	; 180
    1a22:	4f 2e       	mov	r4, r31
    1a24:	f2 e4       	ldi	r31, 0x42	; 66
    1a26:	5f 2e       	mov	r5, r31
    1a28:	f0 2d       	mov	r31, r0
    1a2a:	14 c0       	rjmp	.+40     	; 0x1a54 <vReadIR+0x35c>
			if(cor_ang_n45 < -90){cor_ang_n45 = -90;}
    1a2c:	c2 01       	movw	r24, r4
    1a2e:	b1 01       	movw	r22, r2
    1a30:	20 e0       	ldi	r18, 0x00	; 0
    1a32:	30 e0       	ldi	r19, 0x00	; 0
    1a34:	44 eb       	ldi	r20, 0xB4	; 180
    1a36:	52 ec       	ldi	r21, 0xC2	; 194
    1a38:	0e 94 e4 2c 	call	0x59c8	; 0x59c8 <__cmpsf2>
    1a3c:	88 23       	and	r24, r24
    1a3e:	54 f4       	brge	.+20     	; 0x1a54 <vReadIR+0x35c>
    1a40:	0f 2e       	mov	r0, r31
    1a42:	f0 e0       	ldi	r31, 0x00	; 0
    1a44:	2f 2e       	mov	r2, r31
    1a46:	f0 e0       	ldi	r31, 0x00	; 0
    1a48:	3f 2e       	mov	r3, r31
    1a4a:	f4 eb       	ldi	r31, 0xB4	; 180
    1a4c:	4f 2e       	mov	r4, r31
    1a4e:	f2 ec       	ldi	r31, 0xC2	; 194
    1a50:	5f 2e       	mov	r5, r31
    1a52:	f0 2d       	mov	r31, r0
		}
		else{cor_ang_n45 = 90;}

		if(denom_p45 != 0){
    1a54:	6e 81       	ldd	r22, Y+6	; 0x06
    1a56:	7f 81       	ldd	r23, Y+7	; 0x07
    1a58:	88 85       	ldd	r24, Y+8	; 0x08
    1a5a:	99 85       	ldd	r25, Y+9	; 0x09
    1a5c:	20 e0       	ldi	r18, 0x00	; 0
    1a5e:	30 e0       	ldi	r19, 0x00	; 0
    1a60:	40 e0       	ldi	r20, 0x00	; 0
    1a62:	50 e0       	ldi	r21, 0x00	; 0
    1a64:	0e 94 e4 2c 	call	0x59c8	; 0x59c8 <__cmpsf2>
    1a68:	88 23       	and	r24, r24
    1a6a:	a1 f0       	breq	.+40     	; 0x1a94 <vReadIR+0x39c>
			cor_ang_p45 =  1000.0/denom_p45;
    1a6c:	60 e0       	ldi	r22, 0x00	; 0
    1a6e:	70 e0       	ldi	r23, 0x00	; 0
    1a70:	8a e7       	ldi	r24, 0x7A	; 122
    1a72:	94 e4       	ldi	r25, 0x44	; 68
    1a74:	2e 81       	ldd	r18, Y+6	; 0x06
    1a76:	3f 81       	ldd	r19, Y+7	; 0x07
    1a78:	48 85       	ldd	r20, Y+8	; 0x08
    1a7a:	59 85       	ldd	r21, Y+9	; 0x09
    1a7c:	0e 94 e8 2c 	call	0x59d0	; 0x59d0 <__divsf3>
    1a80:	5b 01       	movw	r10, r22
    1a82:	6c 01       	movw	r12, r24
			if(cor_ang_p45 > 90){cor_ang_p45 = 90;}
    1a84:	20 e0       	ldi	r18, 0x00	; 0
    1a86:	30 e0       	ldi	r19, 0x00	; 0
    1a88:	44 eb       	ldi	r20, 0xB4	; 180
    1a8a:	52 e4       	ldi	r21, 0x42	; 66
    1a8c:	0e 94 33 2e 	call	0x5c66	; 0x5c66 <__gesf2>
    1a90:	18 16       	cp	r1, r24
    1a92:	5c f4       	brge	.+22     	; 0x1aaa <vReadIR+0x3b2>
    1a94:	0f 2e       	mov	r0, r31
    1a96:	f0 e0       	ldi	r31, 0x00	; 0
    1a98:	af 2e       	mov	r10, r31
    1a9a:	f0 e0       	ldi	r31, 0x00	; 0
    1a9c:	bf 2e       	mov	r11, r31
    1a9e:	f4 eb       	ldi	r31, 0xB4	; 180
    1aa0:	cf 2e       	mov	r12, r31
    1aa2:	f2 e4       	ldi	r31, 0x42	; 66
    1aa4:	df 2e       	mov	r13, r31
    1aa6:	f0 2d       	mov	r31, r0
    1aa8:	14 c0       	rjmp	.+40     	; 0x1ad2 <vReadIR+0x3da>
			if(cor_ang_p45 < -90){cor_ang_p45 = -90;}
    1aaa:	c6 01       	movw	r24, r12
    1aac:	b5 01       	movw	r22, r10
    1aae:	20 e0       	ldi	r18, 0x00	; 0
    1ab0:	30 e0       	ldi	r19, 0x00	; 0
    1ab2:	44 eb       	ldi	r20, 0xB4	; 180
    1ab4:	52 ec       	ldi	r21, 0xC2	; 194
    1ab6:	0e 94 e4 2c 	call	0x59c8	; 0x59c8 <__cmpsf2>
    1aba:	88 23       	and	r24, r24
    1abc:	54 f4       	brge	.+20     	; 0x1ad2 <vReadIR+0x3da>
    1abe:	0f 2e       	mov	r0, r31
    1ac0:	f0 e0       	ldi	r31, 0x00	; 0
    1ac2:	af 2e       	mov	r10, r31
    1ac4:	f0 e0       	ldi	r31, 0x00	; 0
    1ac6:	bf 2e       	mov	r11, r31
    1ac8:	f4 eb       	ldi	r31, 0xB4	; 180
    1aca:	cf 2e       	mov	r12, r31
    1acc:	f2 ec       	ldi	r31, 0xC2	; 194
    1ace:	df 2e       	mov	r13, r31
    1ad0:	f0 2d       	mov	r31, r0
		}
		else{cor_ang_p45 = 90;}

		cor_coeff = 40/(zero_range - IR_TO_EDGE);
    1ad2:	6a 85       	ldd	r22, Y+10	; 0x0a
    1ad4:	7b 85       	ldd	r23, Y+11	; 0x0b
    1ad6:	8c 85       	ldd	r24, Y+12	; 0x0c
    1ad8:	9d 85       	ldd	r25, Y+13	; 0x0d
    1ada:	20 e0       	ldi	r18, 0x00	; 0
    1adc:	30 e0       	ldi	r19, 0x00	; 0
    1ade:	40 e2       	ldi	r20, 0x20	; 32
    1ae0:	51 e4       	ldi	r21, 0x41	; 65
    1ae2:	0e 94 7f 2c 	call	0x58fe	; 0x58fe <__subsf3>
    1ae6:	9b 01       	movw	r18, r22
    1ae8:	ac 01       	movw	r20, r24
    1aea:	60 e0       	ldi	r22, 0x00	; 0
    1aec:	70 e0       	ldi	r23, 0x00	; 0
    1aee:	80 e2       	ldi	r24, 0x20	; 32
    1af0:	92 e4       	ldi	r25, 0x42	; 66
    1af2:	0e 94 e8 2c 	call	0x59d0	; 0x59d0 <__divsf3>
    1af6:	3b 01       	movw	r6, r22
    1af8:	4c 01       	movw	r8, r24
		vel_coeff = sqrt((zero_range)/40);
    1afa:	6a 85       	ldd	r22, Y+10	; 0x0a
    1afc:	7b 85       	ldd	r23, Y+11	; 0x0b
    1afe:	8c 85       	ldd	r24, Y+12	; 0x0c
    1b00:	9d 85       	ldd	r25, Y+13	; 0x0d
    1b02:	20 e0       	ldi	r18, 0x00	; 0
    1b04:	30 e0       	ldi	r19, 0x00	; 0
    1b06:	40 e2       	ldi	r20, 0x20	; 32
    1b08:	52 e4       	ldi	r21, 0x42	; 66
    1b0a:	0e 94 e8 2c 	call	0x59d0	; 0x59d0 <__divsf3>
    1b0e:	0e 94 ea 2e 	call	0x5dd4	; 0x5dd4 <sqrt>
//		rprintf("VEL_COEFF: %d\t",(int16_t)vel_coeff);
		inst_cmd_vel = (vel_coeff * inst_cmd_vel) + 1;
    1b12:	20 91 9e 02 	lds	r18, 0x029E
    1b16:	30 91 9f 02 	lds	r19, 0x029F
    1b1a:	40 91 a0 02 	lds	r20, 0x02A0
    1b1e:	50 91 a1 02 	lds	r21, 0x02A1
    1b22:	0e 94 37 2e 	call	0x5c6e	; 0x5c6e <__mulsf3>
    1b26:	20 e0       	ldi	r18, 0x00	; 0
    1b28:	30 e0       	ldi	r19, 0x00	; 0
    1b2a:	40 e8       	ldi	r20, 0x80	; 128
    1b2c:	5f e3       	ldi	r21, 0x3F	; 63
    1b2e:	0e 94 80 2c 	call	0x5900	; 0x5900 <__addsf3>
    1b32:	60 93 9e 02 	sts	0x029E, r22
    1b36:	70 93 9f 02 	sts	0x029F, r23
    1b3a:	80 93 a0 02 	sts	0x02A0, r24
    1b3e:	90 93 a1 02 	sts	0x02A1, r25
		if(cor_coeff < 1){cor_coeff = 1;}
    1b42:	c4 01       	movw	r24, r8
    1b44:	b3 01       	movw	r22, r6
    1b46:	20 e0       	ldi	r18, 0x00	; 0
    1b48:	30 e0       	ldi	r19, 0x00	; 0
    1b4a:	40 e8       	ldi	r20, 0x80	; 128
    1b4c:	5f e3       	ldi	r21, 0x3F	; 63
    1b4e:	0e 94 e4 2c 	call	0x59c8	; 0x59c8 <__cmpsf2>
    1b52:	88 23       	and	r24, r24
    1b54:	54 f4       	brge	.+20     	; 0x1b6a <vReadIR+0x472>
    1b56:	0f 2e       	mov	r0, r31
    1b58:	f0 e0       	ldi	r31, 0x00	; 0
    1b5a:	6f 2e       	mov	r6, r31
    1b5c:	f0 e0       	ldi	r31, 0x00	; 0
    1b5e:	7f 2e       	mov	r7, r31
    1b60:	f0 e8       	ldi	r31, 0x80	; 128
    1b62:	8f 2e       	mov	r8, r31
    1b64:	ff e3       	ldi	r31, 0x3F	; 63
    1b66:	9f 2e       	mov	r9, r31
    1b68:	f0 2d       	mov	r31, r0

		//rprintf("caIR[-90]: %d\tcaIR[-45]: %d\tcaIR[90]: %d\tcaIR[45]: %d\t",(uint8_t)cor_ang_n90, (uint8_t)cor_ang_n45, (uint8_t)cor_ang_p90, (uint8_t)cor_ang_p45);

		correction_angle = (cor_coeff)*((cor_ang_p90 - cor_ang_n90) + (cor_ang_p45 - cor_ang_n45));
    1b6a:	c8 01       	movw	r24, r16
    1b6c:	b7 01       	movw	r22, r14
    1b6e:	2a 81       	ldd	r18, Y+2	; 0x02
    1b70:	3b 81       	ldd	r19, Y+3	; 0x03
    1b72:	4c 81       	ldd	r20, Y+4	; 0x04
    1b74:	5d 81       	ldd	r21, Y+5	; 0x05
    1b76:	0e 94 7f 2c 	call	0x58fe	; 0x58fe <__subsf3>
    1b7a:	7b 01       	movw	r14, r22
    1b7c:	8c 01       	movw	r16, r24
    1b7e:	c6 01       	movw	r24, r12
    1b80:	b5 01       	movw	r22, r10
    1b82:	a2 01       	movw	r20, r4
    1b84:	91 01       	movw	r18, r2
    1b86:	0e 94 7f 2c 	call	0x58fe	; 0x58fe <__subsf3>
    1b8a:	9b 01       	movw	r18, r22
    1b8c:	ac 01       	movw	r20, r24
    1b8e:	c8 01       	movw	r24, r16
    1b90:	b7 01       	movw	r22, r14
    1b92:	0e 94 80 2c 	call	0x5900	; 0x5900 <__addsf3>
    1b96:	9b 01       	movw	r18, r22
    1b98:	ac 01       	movw	r20, r24
    1b9a:	c4 01       	movw	r24, r8
    1b9c:	b3 01       	movw	r22, r6
    1b9e:	0e 94 37 2e 	call	0x5c6e	; 0x5c6e <__mulsf3>
    1ba2:	60 93 c6 02 	sts	0x02C6, r22
    1ba6:	70 93 c7 02 	sts	0x02C7, r23
    1baa:	80 93 c8 02 	sts	0x02C8, r24
    1bae:	90 93 c9 02 	sts	0x02C9, r25
		if(correction_angle > 90){correction_angle = 90;}
    1bb2:	20 e0       	ldi	r18, 0x00	; 0
    1bb4:	30 e0       	ldi	r19, 0x00	; 0
    1bb6:	44 eb       	ldi	r20, 0xB4	; 180
    1bb8:	52 e4       	ldi	r21, 0x42	; 66
    1bba:	0e 94 33 2e 	call	0x5c66	; 0x5c66 <__gesf2>
    1bbe:	18 16       	cp	r1, r24
    1bc0:	64 f4       	brge	.+24     	; 0x1bda <vReadIR+0x4e2>
    1bc2:	80 e0       	ldi	r24, 0x00	; 0
    1bc4:	90 e0       	ldi	r25, 0x00	; 0
    1bc6:	a4 eb       	ldi	r26, 0xB4	; 180
    1bc8:	b2 e4       	ldi	r27, 0x42	; 66
    1bca:	80 93 c6 02 	sts	0x02C6, r24
    1bce:	90 93 c7 02 	sts	0x02C7, r25
    1bd2:	a0 93 c8 02 	sts	0x02C8, r26
    1bd6:	b0 93 c9 02 	sts	0x02C9, r27
		if(correction_angle < -90){correction_angle = -90;}
    1bda:	60 91 c6 02 	lds	r22, 0x02C6
    1bde:	70 91 c7 02 	lds	r23, 0x02C7
    1be2:	80 91 c8 02 	lds	r24, 0x02C8
    1be6:	90 91 c9 02 	lds	r25, 0x02C9
    1bea:	20 e0       	ldi	r18, 0x00	; 0
    1bec:	30 e0       	ldi	r19, 0x00	; 0
    1bee:	44 eb       	ldi	r20, 0xB4	; 180
    1bf0:	52 ec       	ldi	r21, 0xC2	; 194
    1bf2:	0e 94 e4 2c 	call	0x59c8	; 0x59c8 <__cmpsf2>
    1bf6:	87 ff       	sbrs	r24, 7
    1bf8:	0c c0       	rjmp	.+24     	; 0x1c12 <vReadIR+0x51a>
    1bfa:	80 e0       	ldi	r24, 0x00	; 0
    1bfc:	90 e0       	ldi	r25, 0x00	; 0
    1bfe:	a4 eb       	ldi	r26, 0xB4	; 180
    1c00:	b2 ec       	ldi	r27, 0xC2	; 194
    1c02:	80 93 c6 02 	sts	0x02C6, r24
    1c06:	90 93 c7 02 	sts	0x02C7, r25
    1c0a:	a0 93 c8 02 	sts	0x02C8, r26
    1c0e:	b0 93 c9 02 	sts	0x02C9, r27
    1c12:	0f 2e       	mov	r0, r31
    1c14:	f0 e0       	ldi	r31, 0x00	; 0
    1c16:	ef 2e       	mov	r14, r31
    1c18:	f0 e0       	ldi	r31, 0x00	; 0
    1c1a:	ff 2e       	mov	r15, r31
    1c1c:	f0 e0       	ldi	r31, 0x00	; 0
    1c1e:	0f 2f       	mov	r16, r31
    1c20:	f0 e0       	ldi	r31, 0x00	; 0
    1c22:	1f 2f       	mov	r17, r31
    1c24:	f0 2d       	mov	r31, r0
    1c26:	57 01       	movw	r10, r14
    1c28:	68 01       	movw	r12, r16
    1c2a:	ea 86       	std	Y+10, r14	; 0x0a
    1c2c:	fb 86       	std	Y+11, r15	; 0x0b
    1c2e:	0c 87       	std	Y+12, r16	; 0x0c
    1c30:	1d 87       	std	Y+13, r17	; 0x0d
    1c32:	37 01       	movw	r6, r14
    1c34:	48 01       	movw	r8, r16
    1c36:	17 01       	movw	r2, r14
    1c38:	28 01       	movw	r4, r16
    1c3a:	19 82       	std	Y+1, r1	; 0x01
    1c3c:	8d cd       	rjmp	.-1254   	; 0x1758 <vReadIR+0x60>

00001c3e <ubRcv>:
		
			//taskYIELD();
	//	}
}

void ubRcv(unsigned char c){
    1c3e:	1f 93       	push	r17
	static char dis_iter; //count iterator for commanded distance
	static char rot_flag;
	static char dis_flag;
	static s16 rot_rough = 0;  //store ascii chars
	static s16 dis_rough = 0;  //store ascii chars
		c = c & 0b01111111;		//for some reason, every byte has its first bit set to 1
    1c40:	18 2f       	mov	r17, r24
    1c42:	1f 77       	andi	r17, 0x7F	; 127
		uart1SendByte(c);
    1c44:	81 2f       	mov	r24, r17
    1c46:	0e 94 31 22 	call	0x4462	; 0x4462 <uart1SendByte>
		if(c != 0xff){
		//if the data isn't whitespace (0xff), post it
		

			if(c == 0x0a){lf_flag = SET;} //line feed detected, the character will be a 'R' or a 'D'
    1c4a:	1a 30       	cpi	r17, 0x0A	; 10
    1c4c:	21 f4       	brne	.+8      	; 0x1c56 <ubRcv+0x18>
    1c4e:	81 e0       	ldi	r24, 0x01	; 1
    1c50:	80 93 d2 02 	sts	0x02D2, r24
    1c54:	61 c0       	rjmp	.+194    	; 0x1d18 <ubRcv+0xda>
	
			else if((lf_flag) && (c == 'R')){ //set rotation flag
    1c56:	80 91 d2 02 	lds	r24, 0x02D2
    1c5a:	88 23       	and	r24, r24
    1c5c:	91 f0       	breq	.+36     	; 0x1c82 <ubRcv+0x44>
    1c5e:	12 35       	cpi	r17, 0x52	; 82
    1c60:	31 f4       	brne	.+12     	; 0x1c6e <ubRcv+0x30>
				rot_flag = SET;
    1c62:	81 e0       	ldi	r24, 0x01	; 1
    1c64:	80 93 cf 02 	sts	0x02CF, r24
				rot_iter = 0;
    1c68:	10 92 d1 02 	sts	0x02D1, r1
    1c6c:	07 c0       	rjmp	.+14     	; 0x1c7c <ubRcv+0x3e>
				lf_flag = UNSET;
				//rprintf("R: char: %c ",c);
				return;
			} 
			else if((lf_flag) && (c == 'M')){ //set distance flag
    1c6e:	1d 34       	cpi	r17, 0x4D	; 77
    1c70:	41 f4       	brne	.+16     	; 0x1c82 <ubRcv+0x44>
				dis_flag = SET;
    1c72:	81 e0       	ldi	r24, 0x01	; 1
    1c74:	80 93 ce 02 	sts	0x02CE, r24
				dis_iter = 0;
    1c78:	10 92 d0 02 	sts	0x02D0, r1
				lf_flag = UNSET;
    1c7c:	10 92 d2 02 	sts	0x02D2, r1
    1c80:	7c c0       	rjmp	.+248    	; 0x1d7a <ubRcv+0x13c>
			//	rprintf("%c",c);
				return;
			}
			else if(rot_flag){
    1c82:	80 91 cf 02 	lds	r24, 0x02CF
    1c86:	88 23       	and	r24, r24
    1c88:	11 f1       	breq	.+68     	; 0x1cce <ubRcv+0x90>

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
    1c8a:	81 2f       	mov	r24, r17
    1c8c:	80 53       	subi	r24, 0x30	; 48
    1c8e:	8a 30       	cpi	r24, 0x0A	; 10
    1c90:	10 f4       	brcc	.+4      	; 0x1c96 <ubRcv+0x58>
    1c92:	18 2f       	mov	r17, r24
    1c94:	05 c0       	rjmp	.+10     	; 0x1ca0 <ubRcv+0x62>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
    1c96:	81 2f       	mov	r24, r17
    1c98:	81 54       	subi	r24, 0x41	; 65
    1c9a:	86 30       	cpi	r24, 0x06	; 6
    1c9c:	08 f4       	brcc	.+2      	; 0x1ca0 <ubRcv+0x62>
		c -= 55;
    1c9e:	17 53       	subi	r17, 0x37	; 55
				lf_flag = UNSET;
			//	rprintf("%c",c);
				return;
			}
			else if(rot_flag){
				rot_rough = (char2hex(c) | (rot_rough << 4));	//store then increment	
    1ca0:	81 2f       	mov	r24, r17
    1ca2:	90 e0       	ldi	r25, 0x00	; 0
    1ca4:	20 91 cc 02 	lds	r18, 0x02CC
    1ca8:	30 91 cd 02 	lds	r19, 0x02CD
    1cac:	64 e0       	ldi	r22, 0x04	; 4
    1cae:	22 0f       	add	r18, r18
    1cb0:	33 1f       	adc	r19, r19
    1cb2:	6a 95       	dec	r22
    1cb4:	e1 f7       	brne	.-8      	; 0x1cae <ubRcv+0x70>
    1cb6:	82 2b       	or	r24, r18
    1cb8:	93 2b       	or	r25, r19
    1cba:	90 93 cd 02 	sts	0x02CD, r25
    1cbe:	80 93 cc 02 	sts	0x02CC, r24
				rot_iter++;
    1cc2:	80 91 d1 02 	lds	r24, 0x02D1
    1cc6:	8f 5f       	subi	r24, 0xFF	; 255
    1cc8:	80 93 d1 02 	sts	0x02D1, r24
    1ccc:	25 c0       	rjmp	.+74     	; 0x1d18 <ubRcv+0xda>
				//rprintf(" #%c\t:%d\t",c,rot_iter);
				//rprintfu08(c); rprintf("\t");
				//rprintfu16(rot_rough);
				//rprintfCRLF();
			}	
			else if(dis_flag){
    1cce:	80 91 ce 02 	lds	r24, 0x02CE
    1cd2:	88 23       	and	r24, r24
    1cd4:	09 f1       	breq	.+66     	; 0x1d18 <ubRcv+0xda>

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
    1cd6:	81 2f       	mov	r24, r17
    1cd8:	80 53       	subi	r24, 0x30	; 48
    1cda:	8a 30       	cpi	r24, 0x0A	; 10
    1cdc:	10 f4       	brcc	.+4      	; 0x1ce2 <ubRcv+0xa4>
    1cde:	18 2f       	mov	r17, r24
    1ce0:	05 c0       	rjmp	.+10     	; 0x1cec <ubRcv+0xae>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
    1ce2:	81 2f       	mov	r24, r17
    1ce4:	81 54       	subi	r24, 0x41	; 65
    1ce6:	86 30       	cpi	r24, 0x06	; 6
    1ce8:	08 f4       	brcc	.+2      	; 0x1cec <ubRcv+0xae>
		c -= 55;
    1cea:	17 53       	subi	r17, 0x37	; 55
				//rprintfu08(c); rprintf("\t");
				//rprintfu16(rot_rough);
				//rprintfCRLF();
			}	
			else if(dis_flag){
				dis_rough = (char2hex(c) | (dis_rough << 4));	//store then increment	
    1cec:	81 2f       	mov	r24, r17
    1cee:	90 e0       	ldi	r25, 0x00	; 0
    1cf0:	20 91 ca 02 	lds	r18, 0x02CA
    1cf4:	30 91 cb 02 	lds	r19, 0x02CB
    1cf8:	54 e0       	ldi	r21, 0x04	; 4
    1cfa:	22 0f       	add	r18, r18
    1cfc:	33 1f       	adc	r19, r19
    1cfe:	5a 95       	dec	r21
    1d00:	e1 f7       	brne	.-8      	; 0x1cfa <ubRcv+0xbc>
    1d02:	82 2b       	or	r24, r18
    1d04:	93 2b       	or	r25, r19
    1d06:	90 93 cb 02 	sts	0x02CB, r25
    1d0a:	80 93 ca 02 	sts	0x02CA, r24
				dis_iter++;
    1d0e:	80 91 d0 02 	lds	r24, 0x02D0
    1d12:	8f 5f       	subi	r24, 0xFF	; 255
    1d14:	80 93 d0 02 	sts	0x02D0, r24
			//	rprintf("%c",c);
			}

			if(rot_iter == 4){
    1d18:	80 91 d1 02 	lds	r24, 0x02D1
    1d1c:	84 30       	cpi	r24, 0x04	; 4
    1d1e:	89 f4       	brne	.+34     	; 0x1d42 <ubRcv+0x104>
				//cmd_angle = retConv_s16(&rot_rough);
				cmd_angle = rot_rough;
    1d20:	80 91 cc 02 	lds	r24, 0x02CC
    1d24:	90 91 cd 02 	lds	r25, 0x02CD
    1d28:	90 93 c1 02 	sts	0x02C1, r25
    1d2c:	80 93 c0 02 	sts	0x02C0, r24
				rot_flag = UNSET;
    1d30:	10 92 cf 02 	sts	0x02CF, r1
				rot_iter = 0;
    1d34:	10 92 d1 02 	sts	0x02D1, r1
				//rprintfu16(rot_rough);
				//rprintf("\n\n");
				rot_rough = 0;
    1d38:	10 92 cd 02 	sts	0x02CD, r1
    1d3c:	10 92 cc 02 	sts	0x02CC, r1
    1d40:	1c c0       	rjmp	.+56     	; 0x1d7a <ubRcv+0x13c>
			}
			else if(dis_iter == 4){
    1d42:	80 91 d0 02 	lds	r24, 0x02D0
    1d46:	84 30       	cpi	r24, 0x04	; 4
    1d48:	c1 f4       	brne	.+48     	; 0x1d7a <ubRcv+0x13c>
				cmd_dist = dis_rough;
    1d4a:	80 91 ca 02 	lds	r24, 0x02CA
    1d4e:	90 91 cb 02 	lds	r25, 0x02CB
    1d52:	aa 27       	eor	r26, r26
    1d54:	97 fd       	sbrc	r25, 7
    1d56:	a0 95       	com	r26
    1d58:	ba 2f       	mov	r27, r26
    1d5a:	80 93 c2 02 	sts	0x02C2, r24
    1d5e:	90 93 c3 02 	sts	0x02C3, r25
    1d62:	a0 93 c4 02 	sts	0x02C4, r26
    1d66:	b0 93 c5 02 	sts	0x02C5, r27
				dis_flag = UNSET;
    1d6a:	10 92 ce 02 	sts	0x02CE, r1
				dis_iter = 0;
    1d6e:	10 92 d0 02 	sts	0x02D0, r1
				dis_rough = 0;
    1d72:	10 92 cb 02 	sts	0x02CB, r1
    1d76:	10 92 ca 02 	sts	0x02CA, r1
	//	if(xHigherPriorityTaskWoken == pdTRUE){
		//if data couldn't be posted, rprintf a message
		
			//taskYIELD();
	//	}
}
    1d7a:	1f 91       	pop	r17
    1d7c:	08 95       	ret

00001d7e <prvSetupHardware>:
	i2cSendByte((u08)robot.heading);
	rprintf("%d\n",(u08)robot.heading);
}
*/

void prvSetupHardware(){
    1d7e:	0f 93       	push	r16
    1d80:	1f 93       	push	r17
    1d82:	cf 93       	push	r28
    1d84:	df 93       	push	r29
	delay_cycles(65535);
	delay_cycles(65535);
	
	

	uartInit();  // initialize the UART (serial port)
    1d86:	0e 94 de 25 	call	0x4bbc	; 0x4bbc <uartInit>
    uartSetBaudRate(0, 38400); // set UARTE speed, for Bluetooth
    1d8a:	80 e0       	ldi	r24, 0x00	; 0
    1d8c:	40 e0       	ldi	r20, 0x00	; 0
    1d8e:	56 e9       	ldi	r21, 0x96	; 150
    1d90:	60 e0       	ldi	r22, 0x00	; 0
    1d92:	70 e0       	ldi	r23, 0x00	; 0
    1d94:	0e 94 b8 21 	call	0x4370	; 0x4370 <uartSetBaudRate>
    uartSetBaudRate(1, 115200); // set UARTD speed, for USB connection, up to 500k, try 115200 if it doesn't work
    1d98:	81 e0       	ldi	r24, 0x01	; 1
    1d9a:	40 e0       	ldi	r20, 0x00	; 0
    1d9c:	52 ec       	ldi	r21, 0xC2	; 194
    1d9e:	61 e0       	ldi	r22, 0x01	; 1
    1da0:	70 e0       	ldi	r23, 0x00	; 0
    1da2:	0e 94 b8 21 	call	0x4370	; 0x4370 <uartSetBaudRate>
    uartSetBaudRate(2, 38400); // set UARTH speed
    1da6:	82 e0       	ldi	r24, 0x02	; 2
    1da8:	40 e0       	ldi	r20, 0x00	; 0
    1daa:	56 e9       	ldi	r21, 0x96	; 150
    1dac:	60 e0       	ldi	r22, 0x00	; 0
    1dae:	70 e0       	ldi	r23, 0x00	; 0
    1db0:	0e 94 b8 21 	call	0x4370	; 0x4370 <uartSetBaudRate>
    uartSetBaudRate(3, 38400); // set UARTJ speed, for Blackfin
    1db4:	83 e0       	ldi	r24, 0x03	; 3
    1db6:	40 e0       	ldi	r20, 0x00	; 0
    1db8:	56 e9       	ldi	r21, 0x96	; 150
    1dba:	60 e0       	ldi	r22, 0x00	; 0
    1dbc:	70 e0       	ldi	r23, 0x00	; 0
    1dbe:	0e 94 b8 21 	call	0x4370	; 0x4370 <uartSetBaudRate>
	//G=Ground, T=Tx (connect to external Rx), R=Rx (connect to external Tx)

	rprintfInit(uart1SendByte);// initialize rprintf system and configure uart1 (USB) for rprintf
    1dc2:	81 e3       	ldi	r24, 0x31	; 49
    1dc4:	92 e2       	ldi	r25, 0x22	; 34
    1dc6:	0e 94 22 27 	call	0x4e44	; 0x4e44 <rprintfInit>

	configure_ports(); // configure which ports are analog, digital, etc.
    1dca:	0e 94 85 03 	call	0x70a	; 0x70a <configure_ports>
	*/

	
	//UART ISR *** UART ISR ***
	
	uartSetRxHandler(2, &fwdSer_L);
    1dce:	82 e0       	ldi	r24, 0x02	; 2
    1dd0:	67 ef       	ldi	r22, 0xF7	; 247
    1dd2:	75 e0       	ldi	r23, 0x05	; 5
    1dd4:	0e 94 ad 21 	call	0x435a	; 0x435a <uartSetRxHandler>
	uartSetRxHandler(0, &fwdSer_R);
    1dd8:	80 e0       	ldi	r24, 0x00	; 0
    1dda:	64 e8       	ldi	r22, 0x84	; 132
    1ddc:	76 e0       	ldi	r23, 0x06	; 6
    1dde:	0e 94 ad 21 	call	0x435a	; 0x435a <uartSetRxHandler>
	uartSetRxHandler(3, &ubRcv);
    1de2:	83 e0       	ldi	r24, 0x03	; 3
    1de4:	6f e1       	ldi	r22, 0x1F	; 31
    1de6:	7e e0       	ldi	r23, 0x0E	; 14
    1de8:	0e 94 ad 21 	call	0x435a	; 0x435a <uartSetRxHandler>
void LED_on(void)
	{PORT_OFF(PORTB,6);}
    1dec:	2e 98       	cbi	0x05, 6	; 5

	//UART ISR *** UART ISR ***

	LED_on();

	rprintf("\r\nSystem Warmed Up");
    1dee:	00 d0       	rcall	.+0      	; 0x1df0 <prvSetupHardware+0x72>
    1df0:	0f 92       	push	r0
    1df2:	81 e0       	ldi	r24, 0x01	; 1
    1df4:	ed b7       	in	r30, 0x3d	; 61
    1df6:	fe b7       	in	r31, 0x3e	; 62
    1df8:	81 83       	std	Z+1, r24	; 0x01
    1dfa:	8c e9       	ldi	r24, 0x9C	; 156
    1dfc:	91 e0       	ldi	r25, 0x01	; 1
    1dfe:	93 83       	std	Z+3, r25	; 0x03
    1e00:	82 83       	std	Z+2, r24	; 0x02
    1e02:	0e 94 46 29 	call	0x528c	; 0x528c <rprintf1RamRom>

	// initialize the timer system
 	init_timer0(TIMER_CLK_1024);
    1e06:	0f 90       	pop	r0
    1e08:	0f 90       	pop	r0
    1e0a:	0f 90       	pop	r0
    1e0c:	85 e0       	ldi	r24, 0x05	; 5
    1e0e:	0e 94 c4 1b 	call	0x3788	; 0x3788 <init_timer0>
// 	init_timer1(TIMER_CLK_64); // Timer 1 is initialized by FreeRTOS
 	init_timer2(TIMER2_CLK_64);
    1e12:	84 e0       	ldi	r24, 0x04	; 4
    1e14:	0e 94 e4 1b 	call	0x37c8	; 0x37c8 <init_timer2>
 	init_timer3(TIMER_CLK_64);
    1e18:	83 e0       	ldi	r24, 0x03	; 3
    1e1a:	0e 94 f4 1b 	call	0x37e8	; 0x37e8 <init_timer3>
 	init_timer4(TIMER_CLK_64);
    1e1e:	83 e0       	ldi	r24, 0x03	; 3
    1e20:	0e 94 06 1c 	call	0x380c	; 0x380c <init_timer4>
 	init_timer5(TIMER_CLK_64);
    1e24:	83 e0       	ldi	r24, 0x03	; 3
    1e26:	0e 94 18 1c 	call	0x3830	; 0x3830 <init_timer5>

	a2dInit(); // initialize analog to digital converter (ADC)
    1e2a:	0e 94 97 26 	call	0x4d2e	; 0x4d2e <a2dInit>
	a2dSetPrescaler(ADC_PRESCALE_DIV32); // configure ADC scaling
    1e2e:	85 e0       	ldi	r24, 0x05	; 5
    1e30:	0e 94 bc 26 	call	0x4d78	; 0x4d78 <a2dSetPrescaler>
	a2dSetReference(ADC_REFERENCE_AVCC); // configure ADC reference voltage
    1e34:	81 e0       	ldi	r24, 0x01	; 1
    1e36:	0e 94 c3 26 	call	0x4d86	; 0x4d86 <a2dSetReference>
    1e3a:	10 e0       	ldi	r17, 0x00	; 0
	//let system stabelize for X time
	for(i=0;i<16;i++)
		{
		j=a2dConvert8bit(i);//read each ADC once to get it working accurately
		delay_cycles(5000); //keep LED on long enough to see Axon reseting
		rprintf(".");
    1e3c:	01 e0       	ldi	r16, 0x01	; 1
    1e3e:	ca e9       	ldi	r28, 0x9A	; 154
    1e40:	d1 e0       	ldi	r29, 0x01	; 1
	a2dSetReference(ADC_REFERENCE_AVCC); // configure ADC reference voltage

	//let system stabelize for X time
	for(i=0;i<16;i++)
		{
		j=a2dConvert8bit(i);//read each ADC once to get it working accurately
    1e42:	81 2f       	mov	r24, r17
    1e44:	0e 94 0c 27 	call	0x4e18	; 0x4e18 <a2dConvert8bit>
		delay_cycles(5000); //keep LED on long enough to see Axon reseting
		rprintf(".");
    1e48:	00 d0       	rcall	.+0      	; 0x1e4a <prvSetupHardware+0xcc>
    1e4a:	0f 92       	push	r0
    1e4c:	ed b7       	in	r30, 0x3d	; 61
    1e4e:	fe b7       	in	r31, 0x3e	; 62
    1e50:	01 83       	std	Z+1, r16	; 0x01
    1e52:	d3 83       	std	Z+3, r29	; 0x03
    1e54:	c2 83       	std	Z+2, r28	; 0x02
    1e56:	0e 94 46 29 	call	0x528c	; 0x528c <rprintf1RamRom>
    1e5a:	1f 5f       	subi	r17, 0xFF	; 255
	a2dInit(); // initialize analog to digital converter (ADC)
	a2dSetPrescaler(ADC_PRESCALE_DIV32); // configure ADC scaling
	a2dSetReference(ADC_REFERENCE_AVCC); // configure ADC reference voltage

	//let system stabelize for X time
	for(i=0;i<16;i++)
    1e5c:	0f 90       	pop	r0
    1e5e:	0f 90       	pop	r0
    1e60:	0f 90       	pop	r0
    1e62:	10 31       	cpi	r17, 0x10	; 16
    1e64:	71 f7       	brne	.-36     	; 0x1e42 <prvSetupHardware+0xc4>


//***************STATUS LED**************
//tank test
void LED_off(void)
	{PORT_ON(PORTB,6);}
    1e66:	2e 9a       	sbi	0x05, 6	; 5
		rprintf(".");
		}

	LED_off();

	rprintf("Initialization Complete \r\n");
    1e68:	00 d0       	rcall	.+0      	; 0x1e6a <prvSetupHardware+0xec>
    1e6a:	0f 92       	push	r0
    1e6c:	ed b7       	in	r30, 0x3d	; 61
    1e6e:	fe b7       	in	r31, 0x3e	; 62
    1e70:	01 83       	std	Z+1, r16	; 0x01
    1e72:	8f e7       	ldi	r24, 0x7F	; 127
    1e74:	91 e0       	ldi	r25, 0x01	; 1
    1e76:	93 83       	std	Z+3, r25	; 0x03
    1e78:	82 83       	std	Z+2, r24	; 0x02
    1e7a:	0e 94 46 29 	call	0x528c	; 0x528c <rprintf1RamRom>

	//reset all timers to zero
	reset_timer0();
    1e7e:	0f 90       	pop	r0
    1e80:	0f 90       	pop	r0
    1e82:	0f 90       	pop	r0
    1e84:	0e 94 7a 1b 	call	0x36f4	; 0x36f4 <reset_timer0>
	reset_timer1();
    1e88:	0e 94 84 1b 	call	0x3708	; 0x3708 <reset_timer1>
	reset_timer2();
    1e8c:	0e 94 91 1b 	call	0x3722	; 0x3722 <reset_timer2>
	reset_timer3();
    1e90:	0e 94 9c 1b 	call	0x3738	; 0x3738 <reset_timer3>
	reset_timer4();
    1e94:	0e 94 a9 1b 	call	0x3752	; 0x3752 <reset_timer4>
	reset_timer5();
    1e98:	0e 94 b6 1b 	call	0x376c	; 0x376c <reset_timer5>



	/********PWM Setup***********/
	prvPWMSetup();
    1e9c:	0e 94 55 04 	call	0x8aa	; 0x8aa <prvPWMSetup>

}
    1ea0:	df 91       	pop	r29
    1ea2:	cf 91       	pop	r28
    1ea4:	1f 91       	pop	r17
    1ea6:	0f 91       	pop	r16
    1ea8:	08 95       	ret

00001eaa <main>:
	}

}

int main(void)
{
    1eaa:	1f 93       	push	r17
    1eac:	cf 93       	push	r28
    1eae:	df 93       	push	r29
	prvSetupHardware();
    1eb0:	0e 94 bf 0e 	call	0x1d7e	; 0x1d7e <prvSetupHardware>

	for(;;){
		//uart3SendByte(0xAF);
		rprintf("hello brian...\n");
    1eb4:	11 e0       	ldi	r17, 0x01	; 1
    1eb6:	c6 e6       	ldi	r28, 0x66	; 102
    1eb8:	d1 e0       	ldi	r29, 0x01	; 1
    1eba:	00 d0       	rcall	.+0      	; 0x1ebc <main+0x12>
    1ebc:	0f 92       	push	r0
    1ebe:	ed b7       	in	r30, 0x3d	; 61
    1ec0:	fe b7       	in	r31, 0x3e	; 62
    1ec2:	11 83       	std	Z+1, r17	; 0x01
    1ec4:	d3 83       	std	Z+3, r29	; 0x03
    1ec6:	c2 83       	std	Z+2, r28	; 0x02
    1ec8:	0e 94 46 29 	call	0x528c	; 0x528c <rprintf1RamRom>
    1ecc:	0f 90       	pop	r0
    1ece:	0f 90       	pop	r0
    1ed0:	0f 90       	pop	r0
    1ed2:	f3 cf       	rjmp	.-26     	; 0x1eba <main+0x10>

00001ed4 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1ed4:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    1ed6:	9c 01       	movw	r18, r24
    1ed8:	2d 5f       	subi	r18, 0xFD	; 253
    1eda:	3f 4f       	sbci	r19, 0xFF	; 255
    1edc:	32 83       	std	Z+2, r19	; 0x02
    1ede:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1ee0:	8f ef       	ldi	r24, 0xFF	; 255
    1ee2:	9f ef       	ldi	r25, 0xFF	; 255
    1ee4:	94 83       	std	Z+4, r25	; 0x04
    1ee6:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1ee8:	36 83       	std	Z+6, r19	; 0x06
    1eea:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1eec:	30 87       	std	Z+8, r19	; 0x08
    1eee:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = 0;
    1ef0:	10 82       	st	Z, r1
}
    1ef2:	08 95       	ret

00001ef4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1ef4:	fc 01       	movw	r30, r24
    1ef6:	11 86       	std	Z+9, r1	; 0x09
    1ef8:	10 86       	std	Z+8, r1	; 0x08
}
    1efa:	08 95       	ret

00001efc <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1efc:	cf 93       	push	r28
    1efe:	df 93       	push	r29
    1f00:	ac 01       	movw	r20, r24
    1f02:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1f04:	ec 01       	movw	r28, r24
    1f06:	29 81       	ldd	r18, Y+1	; 0x01
    1f08:	3a 81       	ldd	r19, Y+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    1f0a:	f9 01       	movw	r30, r18
    1f0c:	82 81       	ldd	r24, Z+2	; 0x02
    1f0e:	93 81       	ldd	r25, Z+3	; 0x03
    1f10:	13 96       	adiw	r26, 0x03	; 3
    1f12:	9c 93       	st	X, r25
    1f14:	8e 93       	st	-X, r24
    1f16:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1f18:	89 81       	ldd	r24, Y+1	; 0x01
    1f1a:	9a 81       	ldd	r25, Y+2	; 0x02
    1f1c:	15 96       	adiw	r26, 0x05	; 5
    1f1e:	9c 93       	st	X, r25
    1f20:	8e 93       	st	-X, r24
    1f22:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1f24:	02 80       	ldd	r0, Z+2	; 0x02
    1f26:	f3 81       	ldd	r31, Z+3	; 0x03
    1f28:	e0 2d       	mov	r30, r0
    1f2a:	75 83       	std	Z+5, r23	; 0x05
    1f2c:	64 83       	std	Z+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1f2e:	e9 01       	movw	r28, r18
    1f30:	7b 83       	std	Y+3, r23	; 0x03
    1f32:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    1f34:	fa 01       	movw	r30, r20
    1f36:	72 83       	std	Z+2, r23	; 0x02
    1f38:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1f3a:	19 96       	adiw	r26, 0x09	; 9
    1f3c:	5c 93       	st	X, r21
    1f3e:	4e 93       	st	-X, r20
    1f40:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
    1f42:	80 81       	ld	r24, Z
    1f44:	8f 5f       	subi	r24, 0xFF	; 255
    1f46:	80 83       	st	Z, r24
}
    1f48:	df 91       	pop	r29
    1f4a:	cf 91       	pop	r28
    1f4c:	08 95       	ret

00001f4e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    1f4e:	cf 93       	push	r28
    1f50:	df 93       	push	r29
    1f52:	9c 01       	movw	r18, r24
    1f54:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    1f56:	48 81       	ld	r20, Y
    1f58:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as 
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the 
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1f5a:	8f ef       	ldi	r24, 0xFF	; 255
    1f5c:	4f 3f       	cpi	r20, 0xFF	; 255
    1f5e:	58 07       	cpc	r21, r24
    1f60:	21 f4       	brne	.+8      	; 0x1f6a <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1f62:	f9 01       	movw	r30, r18
    1f64:	a7 81       	ldd	r26, Z+7	; 0x07
    1f66:	b0 85       	ldd	r27, Z+8	; 0x08
    1f68:	10 c0       	rjmp	.+32     	; 0x1f8a <vListInsert+0x3c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips. 
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    1f6a:	d9 01       	movw	r26, r18
    1f6c:	13 96       	adiw	r26, 0x03	; 3
    1f6e:	04 c0       	rjmp	.+8      	; 0x1f78 <vListInsert+0x2a>
    1f70:	12 96       	adiw	r26, 0x02	; 2
    1f72:	0d 90       	ld	r0, X+
    1f74:	bc 91       	ld	r27, X
    1f76:	a0 2d       	mov	r26, r0
    1f78:	12 96       	adiw	r26, 0x02	; 2
    1f7a:	ed 91       	ld	r30, X+
    1f7c:	fc 91       	ld	r31, X
    1f7e:	13 97       	sbiw	r26, 0x03	; 3
    1f80:	80 81       	ld	r24, Z
    1f82:	91 81       	ldd	r25, Z+1	; 0x01
    1f84:	48 17       	cp	r20, r24
    1f86:	59 07       	cpc	r21, r25
    1f88:	98 f7       	brcc	.-26     	; 0x1f70 <vListInsert+0x22>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1f8a:	12 96       	adiw	r26, 0x02	; 2
    1f8c:	ed 91       	ld	r30, X+
    1f8e:	fc 91       	ld	r31, X
    1f90:	13 97       	sbiw	r26, 0x03	; 3
    1f92:	fb 83       	std	Y+3, r31	; 0x03
    1f94:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1f96:	d5 83       	std	Z+5, r29	; 0x05
    1f98:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1f9a:	bd 83       	std	Y+5, r27	; 0x05
    1f9c:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1f9e:	13 96       	adiw	r26, 0x03	; 3
    1fa0:	dc 93       	st	X, r29
    1fa2:	ce 93       	st	-X, r28
    1fa4:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1fa6:	39 87       	std	Y+9, r19	; 0x09
    1fa8:	28 87       	std	Y+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    1faa:	f9 01       	movw	r30, r18
    1fac:	80 81       	ld	r24, Z
    1fae:	8f 5f       	subi	r24, 0xFF	; 255
    1fb0:	80 83       	st	Z, r24
}
    1fb2:	df 91       	pop	r29
    1fb4:	cf 91       	pop	r28
    1fb6:	08 95       	ret

00001fb8 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    1fb8:	cf 93       	push	r28
    1fba:	df 93       	push	r29
    1fbc:	dc 01       	movw	r26, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1fbe:	12 96       	adiw	r26, 0x02	; 2
    1fc0:	ed 91       	ld	r30, X+
    1fc2:	fc 91       	ld	r31, X
    1fc4:	13 97       	sbiw	r26, 0x03	; 3
    1fc6:	14 96       	adiw	r26, 0x04	; 4
    1fc8:	8d 91       	ld	r24, X+
    1fca:	9c 91       	ld	r25, X
    1fcc:	15 97       	sbiw	r26, 0x05	; 5
    1fce:	95 83       	std	Z+5, r25	; 0x05
    1fd0:	84 83       	std	Z+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1fd2:	14 96       	adiw	r26, 0x04	; 4
    1fd4:	cd 91       	ld	r28, X+
    1fd6:	dc 91       	ld	r29, X
    1fd8:	15 97       	sbiw	r26, 0x05	; 5
    1fda:	fb 83       	std	Y+3, r31	; 0x03
    1fdc:	ea 83       	std	Y+2, r30	; 0x02
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1fde:	18 96       	adiw	r26, 0x08	; 8
    1fe0:	ed 91       	ld	r30, X+
    1fe2:	fc 91       	ld	r31, X
    1fe4:	19 97       	sbiw	r26, 0x09	; 9

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1fe6:	81 81       	ldd	r24, Z+1	; 0x01
    1fe8:	92 81       	ldd	r25, Z+2	; 0x02
    1fea:	8a 17       	cp	r24, r26
    1fec:	9b 07       	cpc	r25, r27
    1fee:	11 f4       	brne	.+4      	; 0x1ff4 <vListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1ff0:	d2 83       	std	Z+2, r29	; 0x02
    1ff2:	c1 83       	std	Z+1, r28	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    1ff4:	19 96       	adiw	r26, 0x09	; 9
    1ff6:	1c 92       	st	X, r1
    1ff8:	1e 92       	st	-X, r1
    1ffa:	18 97       	sbiw	r26, 0x08	; 8
	( pxList->uxNumberOfItems )--;
    1ffc:	80 81       	ld	r24, Z
    1ffe:	81 50       	subi	r24, 0x01	; 1
    2000:	80 83       	st	Z, r24
}
    2002:	df 91       	pop	r29
    2004:	cf 91       	pop	r28
    2006:	08 95       	ret

00002008 <uxQueueMessagesWaiting>:
	return xReturn;
}
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    2008:	fc 01       	movw	r30, r24
unsigned portBASE_TYPE uxReturn;

	taskENTER_CRITICAL();
    200a:	0f b6       	in	r0, 0x3f	; 63
    200c:	f8 94       	cli
    200e:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    2010:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    2012:	0f 90       	pop	r0
    2014:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    2016:	08 95       	ret

00002018 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    2018:	fc 01       	movw	r30, r24
unsigned portBASE_TYPE uxReturn;

	uxReturn = pxQueue->uxMessagesWaiting;
    201a:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
    201c:	08 95       	ret

0000201e <xQueueIsQueueEmptyFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    201e:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    2020:	82 8d       	ldd	r24, Z+26	; 0x1a
    2022:	90 e0       	ldi	r25, 0x00	; 0
    2024:	88 23       	and	r24, r24
    2026:	09 f4       	brne	.+2      	; 0x202a <xQueueIsQueueEmptyFromISR+0xc>
    2028:	91 e0       	ldi	r25, 0x01	; 1

	return xReturn;
}
    202a:	89 2f       	mov	r24, r25
    202c:	08 95       	ret

0000202e <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    202e:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    2030:	92 8d       	ldd	r25, Z+26	; 0x1a
    2032:	20 e0       	ldi	r18, 0x00	; 0
    2034:	83 8d       	ldd	r24, Z+27	; 0x1b
    2036:	98 17       	cp	r25, r24
    2038:	09 f4       	brne	.+2      	; 0x203c <xQueueIsQueueFullFromISR+0xe>
    203a:	21 e0       	ldi	r18, 0x01	; 1

	return xReturn;
}
    203c:	82 2f       	mov	r24, r18
    203e:	08 95       	ret

00002040 <vQueueDelete>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    2040:	0f 93       	push	r16
    2042:	1f 93       	push	r17
    2044:	8c 01       	movw	r16, r24
	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    2046:	fc 01       	movw	r30, r24
    2048:	80 81       	ld	r24, Z
    204a:	91 81       	ldd	r25, Z+1	; 0x01
    204c:	0e 94 79 1a 	call	0x34f2	; 0x34f2 <vPortFree>
	vPortFree( pxQueue );
    2050:	c8 01       	movw	r24, r16
    2052:	0e 94 79 1a 	call	0x34f2	; 0x34f2 <vPortFree>
}
    2056:	1f 91       	pop	r17
    2058:	0f 91       	pop	r16
    205a:	08 95       	ret

0000205c <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    205c:	0f 93       	push	r16
    205e:	1f 93       	push	r17
    2060:	cf 93       	push	r28
    2062:	df 93       	push	r29
    2064:	ec 01       	movw	r28, r24
    2066:	fb 01       	movw	r30, r22
    2068:	8a 01       	movw	r16, r20
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    206a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    206c:	88 23       	and	r24, r24
    206e:	81 f1       	breq	.+96     	; 0x20d0 <xQueueReceiveFromISR+0x74>
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    2070:	48 81       	ld	r20, Y
    2072:	59 81       	ldd	r21, Y+1	; 0x01
    2074:	41 15       	cp	r20, r1
    2076:	51 05       	cpc	r21, r1
    2078:	a9 f0       	breq	.+42     	; 0x20a4 <xQueueReceiveFromISR+0x48>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    207a:	8c 8d       	ldd	r24, Y+28	; 0x1c
    207c:	2e 81       	ldd	r18, Y+6	; 0x06
    207e:	3f 81       	ldd	r19, Y+7	; 0x07
    2080:	28 0f       	add	r18, r24
    2082:	31 1d       	adc	r19, r1
    2084:	3f 83       	std	Y+7, r19	; 0x07
    2086:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    2088:	8a 81       	ldd	r24, Y+2	; 0x02
    208a:	9b 81       	ldd	r25, Y+3	; 0x03
    208c:	28 17       	cp	r18, r24
    208e:	39 07       	cpc	r19, r25
    2090:	10 f0       	brcs	.+4      	; 0x2096 <xQueueReceiveFromISR+0x3a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    2092:	5f 83       	std	Y+7, r21	; 0x07
    2094:	4e 83       	std	Y+6, r20	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    2096:	4c 8d       	ldd	r20, Y+28	; 0x1c
    2098:	6e 81       	ldd	r22, Y+6	; 0x06
    209a:	7f 81       	ldd	r23, Y+7	; 0x07
    209c:	cf 01       	movw	r24, r30
    209e:	50 e0       	ldi	r21, 0x00	; 0
    20a0:	0e 94 60 2c 	call	0x58c0	; 0x58c0 <memcpy>
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
			--( pxQueue->uxMessagesWaiting );
    20a4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    20a6:	81 50       	subi	r24, 0x01	; 1
    20a8:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    20aa:	8d 8d       	ldd	r24, Y+29	; 0x1d
    20ac:	8f 3f       	cpi	r24, 0xFF	; 255
    20ae:	69 f4       	brne	.+26     	; 0x20ca <xQueueReceiveFromISR+0x6e>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
    20b0:	88 85       	ldd	r24, Y+8	; 0x08
    20b2:	88 23       	and	r24, r24
    20b4:	61 f0       	breq	.+24     	; 0x20ce <xQueueReceiveFromISR+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    20b6:	ce 01       	movw	r24, r28
    20b8:	08 96       	adiw	r24, 0x08	; 8
    20ba:	0e 94 8e 13 	call	0x271c	; 0x271c <xTaskRemoveFromEventList>
    20be:	88 23       	and	r24, r24
    20c0:	31 f0       	breq	.+12     	; 0x20ce <xQueueReceiveFromISR+0x72>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    20c2:	81 e0       	ldi	r24, 0x01	; 1
    20c4:	f8 01       	movw	r30, r16
    20c6:	80 83       	st	Z, r24
    20c8:	03 c0       	rjmp	.+6      	; 0x20d0 <xQueueReceiveFromISR+0x74>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    20ca:	8f 5f       	subi	r24, 0xFF	; 255
    20cc:	8d 8f       	std	Y+29, r24	; 0x1d
    20ce:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    20d0:	df 91       	pop	r29
    20d2:	cf 91       	pop	r28
    20d4:	1f 91       	pop	r17
    20d6:	0f 91       	pop	r16
    20d8:	08 95       	ret

000020da <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    20da:	cf 93       	push	r28
    20dc:	df 93       	push	r29
    20de:	ec 01       	movw	r28, r24
    20e0:	84 2f       	mov	r24, r20
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    20e2:	4c 8d       	ldd	r20, Y+28	; 0x1c
    20e4:	44 23       	and	r20, r20
    20e6:	a1 f1       	breq	.+104    	; 0x2150 <prvCopyDataToQueue+0x76>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    20e8:	88 23       	and	r24, r24
    20ea:	b1 f4       	brne	.+44     	; 0x2118 <prvCopyDataToQueue+0x3e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    20ec:	8c 81       	ldd	r24, Y+4	; 0x04
    20ee:	9d 81       	ldd	r25, Y+5	; 0x05
    20f0:	50 e0       	ldi	r21, 0x00	; 0
    20f2:	0e 94 60 2c 	call	0x58c0	; 0x58c0 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    20f6:	8c 8d       	ldd	r24, Y+28	; 0x1c
    20f8:	2c 81       	ldd	r18, Y+4	; 0x04
    20fa:	3d 81       	ldd	r19, Y+5	; 0x05
    20fc:	28 0f       	add	r18, r24
    20fe:	31 1d       	adc	r19, r1
    2100:	3d 83       	std	Y+5, r19	; 0x05
    2102:	2c 83       	std	Y+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    2104:	8a 81       	ldd	r24, Y+2	; 0x02
    2106:	9b 81       	ldd	r25, Y+3	; 0x03
    2108:	28 17       	cp	r18, r24
    210a:	39 07       	cpc	r19, r25
    210c:	08 f1       	brcs	.+66     	; 0x2150 <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    210e:	88 81       	ld	r24, Y
    2110:	99 81       	ldd	r25, Y+1	; 0x01
    2112:	9d 83       	std	Y+5, r25	; 0x05
    2114:	8c 83       	std	Y+4, r24	; 0x04
    2116:	1c c0       	rjmp	.+56     	; 0x2150 <prvCopyDataToQueue+0x76>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    2118:	8e 81       	ldd	r24, Y+6	; 0x06
    211a:	9f 81       	ldd	r25, Y+7	; 0x07
    211c:	50 e0       	ldi	r21, 0x00	; 0
    211e:	0e 94 60 2c 	call	0x58c0	; 0x58c0 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    2122:	8c 8d       	ldd	r24, Y+28	; 0x1c
    2124:	90 e0       	ldi	r25, 0x00	; 0
    2126:	44 27       	eor	r20, r20
    2128:	55 27       	eor	r21, r21
    212a:	48 1b       	sub	r20, r24
    212c:	59 0b       	sbc	r21, r25
    212e:	8e 81       	ldd	r24, Y+6	; 0x06
    2130:	9f 81       	ldd	r25, Y+7	; 0x07
    2132:	84 0f       	add	r24, r20
    2134:	95 1f       	adc	r25, r21
    2136:	9f 83       	std	Y+7, r25	; 0x07
    2138:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    213a:	28 81       	ld	r18, Y
    213c:	39 81       	ldd	r19, Y+1	; 0x01
    213e:	82 17       	cp	r24, r18
    2140:	93 07       	cpc	r25, r19
    2142:	30 f4       	brcc	.+12     	; 0x2150 <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    2144:	8a 81       	ldd	r24, Y+2	; 0x02
    2146:	9b 81       	ldd	r25, Y+3	; 0x03
    2148:	84 0f       	add	r24, r20
    214a:	95 1f       	adc	r25, r21
    214c:	9f 83       	std	Y+7, r25	; 0x07
    214e:	8e 83       	std	Y+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    2150:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2152:	8f 5f       	subi	r24, 0xFF	; 255
    2154:	8a 8f       	std	Y+26, r24	; 0x1a
}
    2156:	df 91       	pop	r29
    2158:	cf 91       	pop	r28
    215a:	08 95       	ret

0000215c <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    215c:	0f 93       	push	r16
    215e:	1f 93       	push	r17
    2160:	cf 93       	push	r28
    2162:	df 93       	push	r29
    2164:	ec 01       	movw	r28, r24
    2166:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    2168:	9a 8d       	ldd	r25, Y+26	; 0x1a
    216a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    216c:	98 17       	cp	r25, r24
    216e:	10 f0       	brcs	.+4      	; 0x2174 <xQueueGenericSendFromISR+0x18>
    2170:	80 e0       	ldi	r24, 0x00	; 0
    2172:	17 c0       	rjmp	.+46     	; 0x21a2 <xQueueGenericSendFromISR+0x46>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2174:	ce 01       	movw	r24, r28
    2176:	42 2f       	mov	r20, r18
    2178:	0e 94 6d 10 	call	0x20da	; 0x20da <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    217c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    217e:	8f 3f       	cpi	r24, 0xFF	; 255
    2180:	69 f4       	brne	.+26     	; 0x219c <xQueueGenericSendFromISR+0x40>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    2182:	89 89       	ldd	r24, Y+17	; 0x11
    2184:	88 23       	and	r24, r24
    2186:	61 f0       	breq	.+24     	; 0x21a0 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2188:	ce 01       	movw	r24, r28
    218a:	41 96       	adiw	r24, 0x11	; 17
    218c:	0e 94 8e 13 	call	0x271c	; 0x271c <xTaskRemoveFromEventList>
    2190:	88 23       	and	r24, r24
    2192:	31 f0       	breq	.+12     	; 0x21a0 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    2194:	81 e0       	ldi	r24, 0x01	; 1
    2196:	f8 01       	movw	r30, r16
    2198:	80 83       	st	Z, r24
    219a:	03 c0       	rjmp	.+6      	; 0x21a2 <xQueueGenericSendFromISR+0x46>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    219c:	8f 5f       	subi	r24, 0xFF	; 255
    219e:	8e 8f       	std	Y+30, r24	; 0x1e
    21a0:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    21a2:	df 91       	pop	r29
    21a4:	cf 91       	pop	r28
    21a6:	1f 91       	pop	r17
    21a8:	0f 91       	pop	r16
    21aa:	08 95       	ret

000021ac <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    21ac:	0f 93       	push	r16
    21ae:	1f 93       	push	r17
    21b0:	cf 93       	push	r28
    21b2:	df 93       	push	r29
    21b4:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    21b6:	0f b6       	in	r0, 0x3f	; 63
    21b8:	f8 94       	cli
    21ba:	0f 92       	push	r0
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    21bc:	8c 01       	movw	r16, r24
    21be:	0f 5e       	subi	r16, 0xEF	; 239
    21c0:	1f 4f       	sbci	r17, 0xFF	; 255
    21c2:	0d c0       	rjmp	.+26     	; 0x21de <prvUnlockQueue+0x32>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    21c4:	89 89       	ldd	r24, Y+17	; 0x11
    21c6:	88 23       	and	r24, r24
    21c8:	69 f0       	breq	.+26     	; 0x21e4 <prvUnlockQueue+0x38>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    21ca:	c8 01       	movw	r24, r16
    21cc:	0e 94 8e 13 	call	0x271c	; 0x271c <xTaskRemoveFromEventList>
    21d0:	88 23       	and	r24, r24
    21d2:	11 f0       	breq	.+4      	; 0x21d8 <prvUnlockQueue+0x2c>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    21d4:	0e 94 8a 13 	call	0x2714	; 0x2714 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    21d8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    21da:	81 50       	subi	r24, 0x01	; 1
    21dc:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    21de:	8e 8d       	ldd	r24, Y+30	; 0x1e
    21e0:	18 16       	cp	r1, r24
    21e2:	84 f3       	brlt	.-32     	; 0x21c4 <prvUnlockQueue+0x18>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    21e4:	8f ef       	ldi	r24, 0xFF	; 255
    21e6:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    21e8:	0f 90       	pop	r0
    21ea:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    21ec:	0f b6       	in	r0, 0x3f	; 63
    21ee:	f8 94       	cli
    21f0:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    21f2:	8e 01       	movw	r16, r28
    21f4:	08 5f       	subi	r16, 0xF8	; 248
    21f6:	1f 4f       	sbci	r17, 0xFF	; 255
    21f8:	0d c0       	rjmp	.+26     	; 0x2214 <__stack+0x15>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
    21fa:	88 85       	ldd	r24, Y+8	; 0x08
    21fc:	88 23       	and	r24, r24
    21fe:	69 f0       	breq	.+26     	; 0x221a <__stack+0x1b>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2200:	c8 01       	movw	r24, r16
    2202:	0e 94 8e 13 	call	0x271c	; 0x271c <xTaskRemoveFromEventList>
    2206:	88 23       	and	r24, r24
    2208:	11 f0       	breq	.+4      	; 0x220e <__stack+0xf>
				{
					vTaskMissedYield();
    220a:	0e 94 8a 13 	call	0x2714	; 0x2714 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    220e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2210:	81 50       	subi	r24, 0x01	; 1
    2212:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2214:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2216:	18 16       	cp	r1, r24
    2218:	84 f3       	brlt	.-32     	; 0x21fa <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    221a:	8f ef       	ldi	r24, 0xFF	; 255
    221c:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    221e:	0f 90       	pop	r0
    2220:	0f be       	out	0x3f, r0	; 63
}
    2222:	df 91       	pop	r29
    2224:	cf 91       	pop	r28
    2226:	1f 91       	pop	r17
    2228:	0f 91       	pop	r16
    222a:	08 95       	ret

0000222c <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    222c:	7f 92       	push	r7
    222e:	8f 92       	push	r8
    2230:	9f 92       	push	r9
    2232:	af 92       	push	r10
    2234:	bf 92       	push	r11
    2236:	cf 92       	push	r12
    2238:	df 92       	push	r13
    223a:	ef 92       	push	r14
    223c:	ff 92       	push	r15
    223e:	0f 93       	push	r16
    2240:	1f 93       	push	r17
    2242:	df 93       	push	r29
    2244:	cf 93       	push	r28
    2246:	00 d0       	rcall	.+0      	; 0x2248 <xQueueGenericReceive+0x1c>
    2248:	00 d0       	rcall	.+0      	; 0x224a <xQueueGenericReceive+0x1e>
    224a:	0f 92       	push	r0
    224c:	cd b7       	in	r28, 0x3d	; 61
    224e:	de b7       	in	r29, 0x3e	; 62
    2250:	8c 01       	movw	r16, r24
    2252:	96 2e       	mov	r9, r22
    2254:	87 2e       	mov	r8, r23
    2256:	5d 83       	std	Y+5, r21	; 0x05
    2258:	4c 83       	std	Y+4, r20	; 0x04
    225a:	72 2e       	mov	r7, r18
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    225c:	91 e1       	ldi	r25, 0x11	; 17
    225e:	c9 2e       	mov	r12, r25
    2260:	d1 2c       	mov	r13, r1
    2262:	c0 0e       	add	r12, r16
    2264:	d1 1e       	adc	r13, r17
    2266:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2268:	7e 01       	movw	r14, r28
    226a:	08 94       	sec
    226c:	e1 1c       	adc	r14, r1
    226e:	f1 1c       	adc	r15, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2270:	84 e0       	ldi	r24, 0x04	; 4
    2272:	a8 2e       	mov	r10, r24
    2274:	b1 2c       	mov	r11, r1
    2276:	ac 0e       	add	r10, r28
    2278:	bd 1e       	adc	r11, r29
    227a:	01 c0       	rjmp	.+2      	; 0x227e <xQueueGenericReceive+0x52>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    227c:	21 e0       	ldi	r18, 0x01	; 1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    227e:	0f b6       	in	r0, 0x3f	; 63
    2280:	f8 94       	cli
    2282:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    2284:	f8 01       	movw	r30, r16
    2286:	82 8d       	ldd	r24, Z+26	; 0x1a
    2288:	88 23       	and	r24, r24
    228a:	09 f4       	brne	.+2      	; 0x228e <xQueueGenericReceive+0x62>
    228c:	3e c0       	rjmp	.+124    	; 0x230a <xQueueGenericReceive+0xde>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    228e:	e6 80       	ldd	r14, Z+6	; 0x06
    2290:	f7 80       	ldd	r15, Z+7	; 0x07
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    2292:	40 81       	ld	r20, Z
    2294:	51 81       	ldd	r21, Z+1	; 0x01
    2296:	41 15       	cp	r20, r1
    2298:	51 05       	cpc	r21, r1
    229a:	b1 f0       	breq	.+44     	; 0x22c8 <xQueueGenericReceive+0x9c>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    229c:	84 8d       	ldd	r24, Z+28	; 0x1c
    229e:	97 01       	movw	r18, r14
    22a0:	28 0f       	add	r18, r24
    22a2:	31 1d       	adc	r19, r1
    22a4:	37 83       	std	Z+7, r19	; 0x07
    22a6:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    22a8:	82 81       	ldd	r24, Z+2	; 0x02
    22aa:	93 81       	ldd	r25, Z+3	; 0x03
    22ac:	28 17       	cp	r18, r24
    22ae:	39 07       	cpc	r19, r25
    22b0:	10 f0       	brcs	.+4      	; 0x22b6 <xQueueGenericReceive+0x8a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    22b2:	57 83       	std	Z+7, r21	; 0x07
    22b4:	46 83       	std	Z+6, r20	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    22b6:	f8 01       	movw	r30, r16
    22b8:	44 8d       	ldd	r20, Z+28	; 0x1c
    22ba:	66 81       	ldd	r22, Z+6	; 0x06
    22bc:	77 81       	ldd	r23, Z+7	; 0x07
    22be:	89 2d       	mov	r24, r9
    22c0:	98 2d       	mov	r25, r8
    22c2:	50 e0       	ldi	r21, 0x00	; 0
    22c4:	0e 94 60 2c 	call	0x58c0	; 0x58c0 <memcpy>
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
    22c8:	77 20       	and	r7, r7
    22ca:	71 f4       	brne	.+28     	; 0x22e8 <xQueueGenericReceive+0xbc>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    22cc:	f8 01       	movw	r30, r16
    22ce:	82 8d       	ldd	r24, Z+26	; 0x1a
    22d0:	81 50       	subi	r24, 0x01	; 1
    22d2:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    22d4:	80 85       	ldd	r24, Z+8	; 0x08
    22d6:	88 23       	and	r24, r24
    22d8:	a1 f0       	breq	.+40     	; 0x2302 <xQueueGenericReceive+0xd6>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    22da:	c8 01       	movw	r24, r16
    22dc:	08 96       	adiw	r24, 0x08	; 8
    22de:	0e 94 8e 13 	call	0x271c	; 0x271c <xTaskRemoveFromEventList>
    22e2:	81 30       	cpi	r24, 0x01	; 1
    22e4:	71 f4       	brne	.+28     	; 0x2302 <xQueueGenericReceive+0xd6>
    22e6:	0b c0       	rjmp	.+22     	; 0x22fe <xQueueGenericReceive+0xd2>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    22e8:	f8 01       	movw	r30, r16
    22ea:	f7 82       	std	Z+7, r15	; 0x07
    22ec:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    22ee:	81 89       	ldd	r24, Z+17	; 0x11
    22f0:	88 23       	and	r24, r24
    22f2:	39 f0       	breq	.+14     	; 0x2302 <xQueueGenericReceive+0xd6>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    22f4:	c6 01       	movw	r24, r12
    22f6:	0e 94 8e 13 	call	0x271c	; 0x271c <xTaskRemoveFromEventList>
    22fa:	88 23       	and	r24, r24
    22fc:	11 f0       	breq	.+4      	; 0x2302 <xQueueGenericReceive+0xd6>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    22fe:	0e 94 56 18 	call	0x30ac	; 0x30ac <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    2302:	0f 90       	pop	r0
    2304:	0f be       	out	0x3f, r0	; 63
    2306:	81 e0       	ldi	r24, 0x01	; 1
    2308:	4a c0       	rjmp	.+148    	; 0x239e <xQueueGenericReceive+0x172>
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    230a:	8c 81       	ldd	r24, Y+4	; 0x04
    230c:	9d 81       	ldd	r25, Y+5	; 0x05
    230e:	89 2b       	or	r24, r25
    2310:	19 f4       	brne	.+6      	; 0x2318 <xQueueGenericReceive+0xec>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2312:	0f 90       	pop	r0
    2314:	0f be       	out	0x3f, r0	; 63
    2316:	42 c0       	rjmp	.+132    	; 0x239c <xQueueGenericReceive+0x170>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    2318:	22 23       	and	r18, r18
    231a:	19 f4       	brne	.+6      	; 0x2322 <xQueueGenericReceive+0xf6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    231c:	c7 01       	movw	r24, r14
    231e:	0e 94 45 13 	call	0x268a	; 0x268a <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    2322:	0f 90       	pop	r0
    2324:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2326:	0e 94 e9 12 	call	0x25d2	; 0x25d2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    232a:	0f b6       	in	r0, 0x3f	; 63
    232c:	f8 94       	cli
    232e:	0f 92       	push	r0
    2330:	f8 01       	movw	r30, r16
    2332:	85 8d       	ldd	r24, Z+29	; 0x1d
    2334:	8f 3f       	cpi	r24, 0xFF	; 255
    2336:	09 f4       	brne	.+2      	; 0x233a <xQueueGenericReceive+0x10e>
    2338:	15 8e       	std	Z+29, r1	; 0x1d
    233a:	f8 01       	movw	r30, r16
    233c:	86 8d       	ldd	r24, Z+30	; 0x1e
    233e:	8f 3f       	cpi	r24, 0xFF	; 255
    2340:	09 f4       	brne	.+2      	; 0x2344 <xQueueGenericReceive+0x118>
    2342:	16 8e       	std	Z+30, r1	; 0x1e
    2344:	0f 90       	pop	r0
    2346:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2348:	c7 01       	movw	r24, r14
    234a:	b5 01       	movw	r22, r10
    234c:	0e 94 50 13 	call	0x26a0	; 0x26a0 <xTaskCheckForTimeOut>
    2350:	88 23       	and	r24, r24
    2352:	f9 f4       	brne	.+62     	; 0x2392 <xQueueGenericReceive+0x166>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    2354:	0f b6       	in	r0, 0x3f	; 63
    2356:	f8 94       	cli
    2358:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    235a:	f8 01       	movw	r30, r16
    235c:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    235e:	0f 90       	pop	r0
    2360:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
    2362:	88 23       	and	r24, r24
    2364:	81 f4       	brne	.+32     	; 0x2386 <xQueueGenericReceive+0x15a>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2366:	6c 81       	ldd	r22, Y+4	; 0x04
    2368:	7d 81       	ldd	r23, Y+5	; 0x05
    236a:	c6 01       	movw	r24, r12
    236c:	0e 94 47 14 	call	0x288e	; 0x288e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2370:	c8 01       	movw	r24, r16
    2372:	0e 94 d6 10 	call	0x21ac	; 0x21ac <prvUnlockQueue>
				if( !xTaskResumeAll() )
    2376:	0e 94 80 14 	call	0x2900	; 0x2900 <xTaskResumeAll>
    237a:	88 23       	and	r24, r24
    237c:	09 f0       	breq	.+2      	; 0x2380 <xQueueGenericReceive+0x154>
    237e:	7e cf       	rjmp	.-260    	; 0x227c <xQueueGenericReceive+0x50>
				{
					portYIELD_WITHIN_API();
    2380:	0e 94 56 18 	call	0x30ac	; 0x30ac <vPortYield>
    2384:	7b cf       	rjmp	.-266    	; 0x227c <xQueueGenericReceive+0x50>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2386:	c8 01       	movw	r24, r16
    2388:	0e 94 d6 10 	call	0x21ac	; 0x21ac <prvUnlockQueue>
				( void ) xTaskResumeAll();
    238c:	0e 94 80 14 	call	0x2900	; 0x2900 <xTaskResumeAll>
    2390:	75 cf       	rjmp	.-278    	; 0x227c <xQueueGenericReceive+0x50>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    2392:	c8 01       	movw	r24, r16
    2394:	0e 94 d6 10 	call	0x21ac	; 0x21ac <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2398:	0e 94 80 14 	call	0x2900	; 0x2900 <xTaskResumeAll>
    239c:	80 e0       	ldi	r24, 0x00	; 0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
    239e:	0f 90       	pop	r0
    23a0:	0f 90       	pop	r0
    23a2:	0f 90       	pop	r0
    23a4:	0f 90       	pop	r0
    23a6:	0f 90       	pop	r0
    23a8:	cf 91       	pop	r28
    23aa:	df 91       	pop	r29
    23ac:	1f 91       	pop	r17
    23ae:	0f 91       	pop	r16
    23b0:	ff 90       	pop	r15
    23b2:	ef 90       	pop	r14
    23b4:	df 90       	pop	r13
    23b6:	cf 90       	pop	r12
    23b8:	bf 90       	pop	r11
    23ba:	af 90       	pop	r10
    23bc:	9f 90       	pop	r9
    23be:	8f 90       	pop	r8
    23c0:	7f 90       	pop	r7
    23c2:	08 95       	ret

000023c4 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    23c4:	7f 92       	push	r7
    23c6:	8f 92       	push	r8
    23c8:	9f 92       	push	r9
    23ca:	af 92       	push	r10
    23cc:	bf 92       	push	r11
    23ce:	cf 92       	push	r12
    23d0:	df 92       	push	r13
    23d2:	ef 92       	push	r14
    23d4:	ff 92       	push	r15
    23d6:	0f 93       	push	r16
    23d8:	1f 93       	push	r17
    23da:	df 93       	push	r29
    23dc:	cf 93       	push	r28
    23de:	00 d0       	rcall	.+0      	; 0x23e0 <xQueueGenericSend+0x1c>
    23e0:	00 d0       	rcall	.+0      	; 0x23e2 <xQueueGenericSend+0x1e>
    23e2:	0f 92       	push	r0
    23e4:	cd b7       	in	r28, 0x3d	; 61
    23e6:	de b7       	in	r29, 0x3e	; 62
    23e8:	8c 01       	movw	r16, r24
    23ea:	6b 01       	movw	r12, r22
    23ec:	5d 83       	std	Y+5, r21	; 0x05
    23ee:	4c 83       	std	Y+4, r20	; 0x04
    23f0:	72 2e       	mov	r7, r18
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    23f2:	48 e0       	ldi	r20, 0x08	; 8
    23f4:	e4 2e       	mov	r14, r20
    23f6:	f1 2c       	mov	r15, r1
    23f8:	e8 0e       	add	r14, r24
    23fa:	f9 1e       	adc	r15, r25
    23fc:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    23fe:	5e 01       	movw	r10, r28
    2400:	08 94       	sec
    2402:	a1 1c       	adc	r10, r1
    2404:	b1 1c       	adc	r11, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2406:	34 e0       	ldi	r19, 0x04	; 4
    2408:	83 2e       	mov	r8, r19
    240a:	91 2c       	mov	r9, r1
    240c:	8c 0e       	add	r8, r28
    240e:	9d 1e       	adc	r9, r29
    2410:	01 c0       	rjmp	.+2      	; 0x2414 <xQueueGenericSend+0x50>
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2412:	21 e0       	ldi	r18, 0x01	; 1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2414:	0f b6       	in	r0, 0x3f	; 63
    2416:	f8 94       	cli
    2418:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    241a:	f8 01       	movw	r30, r16
    241c:	92 8d       	ldd	r25, Z+26	; 0x1a
    241e:	83 8d       	ldd	r24, Z+27	; 0x1b
    2420:	98 17       	cp	r25, r24
    2422:	a8 f4       	brcc	.+42     	; 0x244e <xQueueGenericSend+0x8a>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2424:	c8 01       	movw	r24, r16
    2426:	b6 01       	movw	r22, r12
    2428:	47 2d       	mov	r20, r7
    242a:	0e 94 6d 10 	call	0x20da	; 0x20da <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    242e:	f8 01       	movw	r30, r16
    2430:	81 89       	ldd	r24, Z+17	; 0x11
    2432:	88 23       	and	r24, r24
    2434:	41 f0       	breq	.+16     	; 0x2446 <xQueueGenericSend+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    2436:	c8 01       	movw	r24, r16
    2438:	41 96       	adiw	r24, 0x11	; 17
    243a:	0e 94 8e 13 	call	0x271c	; 0x271c <xTaskRemoveFromEventList>
    243e:	81 30       	cpi	r24, 0x01	; 1
    2440:	11 f4       	brne	.+4      	; 0x2446 <xQueueGenericSend+0x82>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    2442:	0e 94 56 18 	call	0x30ac	; 0x30ac <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    2446:	0f 90       	pop	r0
    2448:	0f be       	out	0x3f, r0	; 63
    244a:	81 e0       	ldi	r24, 0x01	; 1
    244c:	4c c0       	rjmp	.+152    	; 0x24e6 <xQueueGenericSend+0x122>
				function. */
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    244e:	8c 81       	ldd	r24, Y+4	; 0x04
    2450:	9d 81       	ldd	r25, Y+5	; 0x05
    2452:	89 2b       	or	r24, r25
    2454:	19 f4       	brne	.+6      	; 0x245c <xQueueGenericSend+0x98>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2456:	0f 90       	pop	r0
    2458:	0f be       	out	0x3f, r0	; 63
    245a:	44 c0       	rjmp	.+136    	; 0x24e4 <xQueueGenericSend+0x120>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    245c:	22 23       	and	r18, r18
    245e:	19 f4       	brne	.+6      	; 0x2466 <xQueueGenericSend+0xa2>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2460:	c5 01       	movw	r24, r10
    2462:	0e 94 45 13 	call	0x268a	; 0x268a <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    2466:	0f 90       	pop	r0
    2468:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    246a:	0e 94 e9 12 	call	0x25d2	; 0x25d2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    246e:	0f b6       	in	r0, 0x3f	; 63
    2470:	f8 94       	cli
    2472:	0f 92       	push	r0
    2474:	f8 01       	movw	r30, r16
    2476:	85 8d       	ldd	r24, Z+29	; 0x1d
    2478:	8f 3f       	cpi	r24, 0xFF	; 255
    247a:	09 f4       	brne	.+2      	; 0x247e <xQueueGenericSend+0xba>
    247c:	15 8e       	std	Z+29, r1	; 0x1d
    247e:	f8 01       	movw	r30, r16
    2480:	86 8d       	ldd	r24, Z+30	; 0x1e
    2482:	8f 3f       	cpi	r24, 0xFF	; 255
    2484:	09 f4       	brne	.+2      	; 0x2488 <xQueueGenericSend+0xc4>
    2486:	16 8e       	std	Z+30, r1	; 0x1e
    2488:	0f 90       	pop	r0
    248a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    248c:	c5 01       	movw	r24, r10
    248e:	b4 01       	movw	r22, r8
    2490:	0e 94 50 13 	call	0x26a0	; 0x26a0 <xTaskCheckForTimeOut>
    2494:	88 23       	and	r24, r24
    2496:	09 f5       	brne	.+66     	; 0x24da <xQueueGenericSend+0x116>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    2498:	0f b6       	in	r0, 0x3f	; 63
    249a:	f8 94       	cli
    249c:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    249e:	f8 01       	movw	r30, r16
    24a0:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    24a2:	0f 90       	pop	r0
    24a4:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
    24a6:	f8 01       	movw	r30, r16
    24a8:	83 8d       	ldd	r24, Z+27	; 0x1b
    24aa:	98 17       	cp	r25, r24
    24ac:	81 f4       	brne	.+32     	; 0x24ce <xQueueGenericSend+0x10a>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    24ae:	6c 81       	ldd	r22, Y+4	; 0x04
    24b0:	7d 81       	ldd	r23, Y+5	; 0x05
    24b2:	c7 01       	movw	r24, r14
    24b4:	0e 94 47 14 	call	0x288e	; 0x288e <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    24b8:	c8 01       	movw	r24, r16
    24ba:	0e 94 d6 10 	call	0x21ac	; 0x21ac <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
    24be:	0e 94 80 14 	call	0x2900	; 0x2900 <xTaskResumeAll>
    24c2:	88 23       	and	r24, r24
    24c4:	09 f0       	breq	.+2      	; 0x24c8 <xQueueGenericSend+0x104>
    24c6:	a5 cf       	rjmp	.-182    	; 0x2412 <xQueueGenericSend+0x4e>
				{
					portYIELD_WITHIN_API();
    24c8:	0e 94 56 18 	call	0x30ac	; 0x30ac <vPortYield>
    24cc:	a2 cf       	rjmp	.-188    	; 0x2412 <xQueueGenericSend+0x4e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    24ce:	c8 01       	movw	r24, r16
    24d0:	0e 94 d6 10 	call	0x21ac	; 0x21ac <prvUnlockQueue>
				( void ) xTaskResumeAll();
    24d4:	0e 94 80 14 	call	0x2900	; 0x2900 <xTaskResumeAll>
    24d8:	9c cf       	rjmp	.-200    	; 0x2412 <xQueueGenericSend+0x4e>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    24da:	c8 01       	movw	r24, r16
    24dc:	0e 94 d6 10 	call	0x21ac	; 0x21ac <prvUnlockQueue>
			( void ) xTaskResumeAll();
    24e0:	0e 94 80 14 	call	0x2900	; 0x2900 <xTaskResumeAll>
    24e4:	80 e0       	ldi	r24, 0x00	; 0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
    24e6:	0f 90       	pop	r0
    24e8:	0f 90       	pop	r0
    24ea:	0f 90       	pop	r0
    24ec:	0f 90       	pop	r0
    24ee:	0f 90       	pop	r0
    24f0:	cf 91       	pop	r28
    24f2:	df 91       	pop	r29
    24f4:	1f 91       	pop	r17
    24f6:	0f 91       	pop	r16
    24f8:	ff 90       	pop	r15
    24fa:	ef 90       	pop	r14
    24fc:	df 90       	pop	r13
    24fe:	cf 90       	pop	r12
    2500:	bf 90       	pop	r11
    2502:	af 90       	pop	r10
    2504:	9f 90       	pop	r9
    2506:	8f 90       	pop	r8
    2508:	7f 90       	pop	r7
    250a:	08 95       	ret

0000250c <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    250c:	8f 92       	push	r8
    250e:	9f 92       	push	r9
    2510:	af 92       	push	r10
    2512:	bf 92       	push	r11
    2514:	cf 92       	push	r12
    2516:	df 92       	push	r13
    2518:	ef 92       	push	r14
    251a:	ff 92       	push	r15
    251c:	0f 93       	push	r16
    251e:	1f 93       	push	r17
    2520:	cf 93       	push	r28
    2522:	df 93       	push	r29
    2524:	98 2e       	mov	r9, r24
    2526:	86 2e       	mov	r8, r22
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    2528:	88 23       	and	r24, r24
    252a:	09 f4       	brne	.+2      	; 0x252e <xQueueCreate+0x22>
    252c:	42 c0       	rjmp	.+132    	; 0x25b2 <xQueueCreate+0xa6>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    252e:	8f e1       	ldi	r24, 0x1F	; 31
    2530:	90 e0       	ldi	r25, 0x00	; 0
    2532:	0e 94 89 1a 	call	0x3512	; 0x3512 <pvPortMalloc>
    2536:	8c 01       	movw	r16, r24
    2538:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    253a:	00 97       	sbiw	r24, 0x00	; 0
    253c:	e1 f1       	breq	.+120    	; 0x25b6 <xQueueCreate+0xaa>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    253e:	c9 2c       	mov	r12, r9
    2540:	dd 24       	eor	r13, r13
    2542:	a8 2c       	mov	r10, r8
    2544:	bb 24       	eor	r11, r11
    2546:	ac 9c       	mul	r10, r12
    2548:	70 01       	movw	r14, r0
    254a:	ad 9c       	mul	r10, r13
    254c:	f0 0c       	add	r15, r0
    254e:	bc 9c       	mul	r11, r12
    2550:	f0 0c       	add	r15, r0
    2552:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    2554:	c7 01       	movw	r24, r14
    2556:	01 96       	adiw	r24, 0x01	; 1
    2558:	0e 94 89 1a 	call	0x3512	; 0x3512 <pvPortMalloc>
    255c:	9c 01       	movw	r18, r24
    255e:	99 83       	std	Y+1, r25	; 0x01
    2560:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    2562:	00 97       	sbiw	r24, 0x00	; 0
    2564:	19 f1       	breq	.+70     	; 0x25ac <xQueueCreate+0xa0>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    2566:	e8 0e       	add	r14, r24
    2568:	f9 1e       	adc	r15, r25
    256a:	fb 82       	std	Y+3, r15	; 0x03
    256c:	ea 82       	std	Y+2, r14	; 0x02
				pxNewQueue->uxMessagesWaiting = 0;
    256e:	1a 8e       	std	Y+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    2570:	9d 83       	std	Y+5, r25	; 0x05
    2572:	8c 83       	std	Y+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
    2574:	08 94       	sec
    2576:	c1 08       	sbc	r12, r1
    2578:	d1 08       	sbc	r13, r1
    257a:	ca 9c       	mul	r12, r10
    257c:	c0 01       	movw	r24, r0
    257e:	cb 9c       	mul	r12, r11
    2580:	90 0d       	add	r25, r0
    2582:	da 9c       	mul	r13, r10
    2584:	90 0d       	add	r25, r0
    2586:	11 24       	eor	r1, r1
    2588:	28 0f       	add	r18, r24
    258a:	39 1f       	adc	r19, r25
    258c:	3f 83       	std	Y+7, r19	; 0x07
    258e:	2e 83       	std	Y+6, r18	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    2590:	9b 8e       	std	Y+27, r9	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    2592:	8c 8e       	std	Y+28, r8	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    2594:	8f ef       	ldi	r24, 0xFF	; 255
    2596:	8d 8f       	std	Y+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    2598:	8e 8f       	std	Y+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    259a:	c8 01       	movw	r24, r16
    259c:	08 96       	adiw	r24, 0x08	; 8
    259e:	0e 94 6a 0f 	call	0x1ed4	; 0x1ed4 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    25a2:	c8 01       	movw	r24, r16
    25a4:	41 96       	adiw	r24, 0x11	; 17
    25a6:	0e 94 6a 0f 	call	0x1ed4	; 0x1ed4 <vListInitialise>
    25aa:	05 c0       	rjmp	.+10     	; 0x25b6 <xQueueCreate+0xaa>
				return  pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    25ac:	c8 01       	movw	r24, r16
    25ae:	0e 94 79 1a 	call	0x34f2	; 0x34f2 <vPortFree>
    25b2:	c0 e0       	ldi	r28, 0x00	; 0
    25b4:	d0 e0       	ldi	r29, 0x00	; 0
	}

	/* Will only reach here if we could not allocate enough memory or no memory
	was required. */
	return NULL;
}
    25b6:	ce 01       	movw	r24, r28
    25b8:	df 91       	pop	r29
    25ba:	cf 91       	pop	r28
    25bc:	1f 91       	pop	r17
    25be:	0f 91       	pop	r16
    25c0:	ff 90       	pop	r15
    25c2:	ef 90       	pop	r14
    25c4:	df 90       	pop	r13
    25c6:	cf 90       	pop	r12
    25c8:	bf 90       	pop	r11
    25ca:	af 90       	pop	r10
    25cc:	9f 90       	pop	r9
    25ce:	8f 90       	pop	r8
    25d0:	08 95       	ret

000025d2 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    25d2:	80 91 fb 02 	lds	r24, 0x02FB
    25d6:	8f 5f       	subi	r24, 0xFF	; 255
    25d8:	80 93 fb 02 	sts	0x02FB, r24
}
    25dc:	08 95       	ret

000025de <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portENTER_CRITICAL();
    25de:	0f b6       	in	r0, 0x3f	; 63
    25e0:	f8 94       	cli
    25e2:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    25e4:	20 91 f9 02 	lds	r18, 0x02F9
    25e8:	30 91 fa 02 	lds	r19, 0x02FA
	}
	portEXIT_CRITICAL();
    25ec:	0f 90       	pop	r0
    25ee:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    25f0:	c9 01       	movw	r24, r18
    25f2:	08 95       	ret

000025f4 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
	return xTickCount;
    25f4:	20 91 f9 02 	lds	r18, 0x02F9
    25f8:	30 91 fa 02 	lds	r19, 0x02FA
}
    25fc:	c9 01       	movw	r24, r18
    25fe:	08 95       	ret

00002600 <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    2600:	80 91 fe 02 	lds	r24, 0x02FE
}
    2604:	08 95       	ret

00002606 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2606:	80 91 fb 02 	lds	r24, 0x02FB
    260a:	88 23       	and	r24, r24
    260c:	51 f0       	breq	.+20     	; 0x2622 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    260e:	81 e0       	ldi	r24, 0x01	; 1
    2610:	80 93 f7 02 	sts	0x02F7, r24
    2614:	08 95       	ret
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
	{
		--uxTopReadyPriority;
    2616:	80 91 fc 02 	lds	r24, 0x02FC
    261a:	81 50       	subi	r24, 0x01	; 1
    261c:	80 93 fc 02 	sts	0x02FC, r24
    2620:	01 c0       	rjmp	.+2      	; 0x2624 <vTaskSwitchContext+0x1e>

	taskFIRST_CHECK_FOR_STACK_OVERFLOW();
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2622:	99 e0       	ldi	r25, 0x09	; 9
    2624:	e0 91 fc 02 	lds	r30, 0x02FC
    2628:	e9 9f       	mul	r30, r25
    262a:	f0 01       	movw	r30, r0
    262c:	11 24       	eor	r1, r1
    262e:	ed 5f       	subi	r30, 0xFD	; 253
    2630:	fc 4f       	sbci	r31, 0xFC	; 252
    2632:	80 81       	ld	r24, Z
    2634:	88 23       	and	r24, r24
    2636:	79 f3       	breq	.-34     	; 0x2616 <vTaskSwitchContext+0x10>
		--uxTopReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2638:	90 91 fc 02 	lds	r25, 0x02FC
    263c:	89 e0       	ldi	r24, 0x09	; 9
    263e:	98 9f       	mul	r25, r24
    2640:	d0 01       	movw	r26, r0
    2642:	11 24       	eor	r1, r1
    2644:	ad 5f       	subi	r26, 0xFD	; 253
    2646:	bc 4f       	sbci	r27, 0xFC	; 252
    2648:	11 96       	adiw	r26, 0x01	; 1
    264a:	ed 91       	ld	r30, X+
    264c:	fc 91       	ld	r31, X
    264e:	12 97       	sbiw	r26, 0x02	; 2
    2650:	02 80       	ldd	r0, Z+2	; 0x02
    2652:	f3 81       	ldd	r31, Z+3	; 0x03
    2654:	e0 2d       	mov	r30, r0
    2656:	12 96       	adiw	r26, 0x02	; 2
    2658:	fc 93       	st	X, r31
    265a:	ee 93       	st	-X, r30
    265c:	11 97       	sbiw	r26, 0x01	; 1
    265e:	cd 01       	movw	r24, r26
    2660:	03 96       	adiw	r24, 0x03	; 3
    2662:	e8 17       	cp	r30, r24
    2664:	f9 07       	cpc	r31, r25
    2666:	31 f4       	brne	.+12     	; 0x2674 <vTaskSwitchContext+0x6e>
    2668:	82 81       	ldd	r24, Z+2	; 0x02
    266a:	93 81       	ldd	r25, Z+3	; 0x03
    266c:	12 96       	adiw	r26, 0x02	; 2
    266e:	9c 93       	st	X, r25
    2670:	8e 93       	st	-X, r24
    2672:	11 97       	sbiw	r26, 0x01	; 1
    2674:	11 96       	adiw	r26, 0x01	; 1
    2676:	ed 91       	ld	r30, X+
    2678:	fc 91       	ld	r31, X
    267a:	12 97       	sbiw	r26, 0x02	; 2
    267c:	86 81       	ldd	r24, Z+6	; 0x06
    267e:	97 81       	ldd	r25, Z+7	; 0x07
    2680:	90 93 f6 02 	sts	0x02F6, r25
    2684:	80 93 f5 02 	sts	0x02F5, r24
    2688:	08 95       	ret

0000268a <vTaskSetTimeOutState>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    268a:	fc 01       	movw	r30, r24
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    268c:	80 91 f8 02 	lds	r24, 0x02F8
    2690:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    2692:	80 91 f9 02 	lds	r24, 0x02F9
    2696:	90 91 fa 02 	lds	r25, 0x02FA
    269a:	92 83       	std	Z+2, r25	; 0x02
    269c:	81 83       	std	Z+1, r24	; 0x01
}
    269e:	08 95       	ret

000026a0 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    26a0:	fc 01       	movw	r30, r24
    26a2:	db 01       	movw	r26, r22
portBASE_TYPE xReturn;

	portENTER_CRITICAL();
    26a4:	0f b6       	in	r0, 0x3f	; 63
    26a6:	f8 94       	cli
    26a8:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    26aa:	90 91 f8 02 	lds	r25, 0x02F8
    26ae:	80 81       	ld	r24, Z
    26b0:	98 17       	cp	r25, r24
    26b2:	49 f0       	breq	.+18     	; 0x26c6 <xTaskCheckForTimeOut+0x26>
    26b4:	20 91 f9 02 	lds	r18, 0x02F9
    26b8:	30 91 fa 02 	lds	r19, 0x02FA
    26bc:	81 81       	ldd	r24, Z+1	; 0x01
    26be:	92 81       	ldd	r25, Z+2	; 0x02
    26c0:	28 17       	cp	r18, r24
    26c2:	39 07       	cpc	r19, r25
    26c4:	18 f5       	brcc	.+70     	; 0x270c <xTaskCheckForTimeOut+0x6c>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    26c6:	80 91 f9 02 	lds	r24, 0x02F9
    26ca:	90 91 fa 02 	lds	r25, 0x02FA
    26ce:	21 81       	ldd	r18, Z+1	; 0x01
    26d0:	32 81       	ldd	r19, Z+2	; 0x02
    26d2:	4d 91       	ld	r20, X+
    26d4:	5c 91       	ld	r21, X
    26d6:	11 97       	sbiw	r26, 0x01	; 1
    26d8:	82 1b       	sub	r24, r18
    26da:	93 0b       	sbc	r25, r19
    26dc:	84 17       	cp	r24, r20
    26de:	95 07       	cpc	r25, r21
    26e0:	a8 f4       	brcc	.+42     	; 0x270c <xTaskCheckForTimeOut+0x6c>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    26e2:	80 91 f9 02 	lds	r24, 0x02F9
    26e6:	90 91 fa 02 	lds	r25, 0x02FA
    26ea:	28 1b       	sub	r18, r24
    26ec:	39 0b       	sbc	r19, r25
    26ee:	24 0f       	add	r18, r20
    26f0:	35 1f       	adc	r19, r21
    26f2:	2d 93       	st	X+, r18
    26f4:	3c 93       	st	X, r19
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    26f6:	80 91 f8 02 	lds	r24, 0x02F8
    26fa:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    26fc:	80 91 f9 02 	lds	r24, 0x02F9
    2700:	90 91 fa 02 	lds	r25, 0x02FA
    2704:	92 83       	std	Z+2, r25	; 0x02
    2706:	81 83       	std	Z+1, r24	; 0x01
    2708:	80 e0       	ldi	r24, 0x00	; 0
    270a:	01 c0       	rjmp	.+2      	; 0x270e <xTaskCheckForTimeOut+0x6e>
    270c:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			xReturn = pdTRUE;
		}
	}
	portEXIT_CRITICAL();
    270e:	0f 90       	pop	r0
    2710:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2712:	08 95       	ret

00002714 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    2714:	81 e0       	ldi	r24, 0x01	; 1
    2716:	80 93 f7 02 	sts	0x02F7, r24
}
    271a:	08 95       	ret

0000271c <xTaskRemoveFromEventList>:
	#endif
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    271c:	0f 93       	push	r16
    271e:	1f 93       	push	r17
    2720:	cf 93       	push	r28
    2722:	df 93       	push	r29
    2724:	fc 01       	movw	r30, r24
	it to the ready list.

	If an event is for a queue that is locked then this function will never
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2726:	80 81       	ld	r24, Z
    2728:	88 23       	and	r24, r24
    272a:	19 f4       	brne	.+6      	; 0x2732 <xTaskRemoveFromEventList+0x16>
    272c:	c0 e0       	ldi	r28, 0x00	; 0
    272e:	d0 e0       	ldi	r29, 0x00	; 0
    2730:	05 c0       	rjmp	.+10     	; 0x273c <xTaskRemoveFromEventList+0x20>
    2732:	05 80       	ldd	r0, Z+5	; 0x05
    2734:	f6 81       	ldd	r31, Z+6	; 0x06
    2736:	e0 2d       	mov	r30, r0
    2738:	c6 81       	ldd	r28, Z+6	; 0x06
    273a:	d7 81       	ldd	r29, Z+7	; 0x07
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    273c:	8e 01       	movw	r16, r28
    273e:	04 5f       	subi	r16, 0xF4	; 244
    2740:	1f 4f       	sbci	r17, 0xFF	; 255
    2742:	c8 01       	movw	r24, r16
    2744:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2748:	80 91 fb 02 	lds	r24, 0x02FB
    274c:	88 23       	and	r24, r24
    274e:	a1 f4       	brne	.+40     	; 0x2778 <xTaskRemoveFromEventList+0x5c>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2750:	8e 01       	movw	r16, r28
    2752:	0e 5f       	subi	r16, 0xFE	; 254
    2754:	1f 4f       	sbci	r17, 0xFF	; 255
    2756:	c8 01       	movw	r24, r16
    2758:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    275c:	9e 89       	ldd	r25, Y+22	; 0x16
    275e:	80 91 fc 02 	lds	r24, 0x02FC
    2762:	89 17       	cp	r24, r25
    2764:	10 f4       	brcc	.+4      	; 0x276a <xTaskRemoveFromEventList+0x4e>
    2766:	90 93 fc 02 	sts	0x02FC, r25
    276a:	89 e0       	ldi	r24, 0x09	; 9
    276c:	98 9f       	mul	r25, r24
    276e:	c0 01       	movw	r24, r0
    2770:	11 24       	eor	r1, r1
    2772:	8d 5f       	subi	r24, 0xFD	; 253
    2774:	9c 4f       	sbci	r25, 0xFC	; 252
    2776:	02 c0       	rjmp	.+4      	; 0x277c <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2778:	8d e3       	ldi	r24, 0x3D	; 61
    277a:	93 e0       	ldi	r25, 0x03	; 3
    277c:	b8 01       	movw	r22, r16
    277e:	0e 94 7e 0f 	call	0x1efc	; 0x1efc <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2782:	e0 91 f5 02 	lds	r30, 0x02F5
    2786:	f0 91 f6 02 	lds	r31, 0x02F6
    278a:	20 e0       	ldi	r18, 0x00	; 0
    278c:	9e 89       	ldd	r25, Y+22	; 0x16
    278e:	86 89       	ldd	r24, Z+22	; 0x16
    2790:	98 17       	cp	r25, r24
    2792:	08 f0       	brcs	.+2      	; 0x2796 <xTaskRemoveFromEventList+0x7a>
    2794:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    2796:	82 2f       	mov	r24, r18
    2798:	df 91       	pop	r29
    279a:	cf 91       	pop	r28
    279c:	1f 91       	pop	r17
    279e:	0f 91       	pop	r16
    27a0:	08 95       	ret

000027a2 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
    27a2:	ff 92       	push	r15
    27a4:	0f 93       	push	r16
    27a6:	1f 93       	push	r17
    27a8:	cf 93       	push	r28
    27aa:	df 93       	push	r29
	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    27ac:	80 91 fb 02 	lds	r24, 0x02FB
    27b0:	88 23       	and	r24, r24
    27b2:	09 f0       	breq	.+2      	; 0x27b6 <vTaskIncrementTick+0x14>
    27b4:	61 c0       	rjmp	.+194    	; 0x2878 <vTaskIncrementTick+0xd6>
	{
		++xTickCount;
    27b6:	80 91 f9 02 	lds	r24, 0x02F9
    27ba:	90 91 fa 02 	lds	r25, 0x02FA
    27be:	01 96       	adiw	r24, 0x01	; 1
    27c0:	90 93 fa 02 	sts	0x02FA, r25
    27c4:	80 93 f9 02 	sts	0x02F9, r24
		if( xTickCount == ( portTickType ) 0 )
    27c8:	80 91 f9 02 	lds	r24, 0x02F9
    27cc:	90 91 fa 02 	lds	r25, 0x02FA
    27d0:	89 2b       	or	r24, r25
    27d2:	e9 f5       	brne	.+122    	; 0x284e <vTaskIncrementTick+0xac>
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			pxTemp = pxDelayedTaskList;
    27d4:	80 91 39 03 	lds	r24, 0x0339
    27d8:	90 91 3a 03 	lds	r25, 0x033A
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    27dc:	20 91 3b 03 	lds	r18, 0x033B
    27e0:	30 91 3c 03 	lds	r19, 0x033C
    27e4:	30 93 3a 03 	sts	0x033A, r19
    27e8:	20 93 39 03 	sts	0x0339, r18
			pxOverflowDelayedTaskList = pxTemp;
    27ec:	90 93 3c 03 	sts	0x033C, r25
    27f0:	80 93 3b 03 	sts	0x033B, r24
			xNumOfOverflows++;
    27f4:	80 91 f8 02 	lds	r24, 0x02F8
    27f8:	8f 5f       	subi	r24, 0xFF	; 255
    27fa:	80 93 f8 02 	sts	0x02F8, r24
    27fe:	27 c0       	rjmp	.+78     	; 0x284e <vTaskIncrementTick+0xac>
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    2800:	20 91 f9 02 	lds	r18, 0x02F9
    2804:	30 91 fa 02 	lds	r19, 0x02FA
    2808:	8a 81       	ldd	r24, Y+2	; 0x02
    280a:	9b 81       	ldd	r25, Y+3	; 0x03
    280c:	28 17       	cp	r18, r24
    280e:	39 07       	cpc	r19, r25
    2810:	c0 f1       	brcs	.+112    	; 0x2882 <vTaskIncrementTick+0xe0>
    2812:	8e 01       	movw	r16, r28
    2814:	0e 5f       	subi	r16, 0xFE	; 254
    2816:	1f 4f       	sbci	r17, 0xFF	; 255
    2818:	c8 01       	movw	r24, r16
    281a:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <vListRemove>
    281e:	8c 89       	ldd	r24, Y+20	; 0x14
    2820:	9d 89       	ldd	r25, Y+21	; 0x15
    2822:	89 2b       	or	r24, r25
    2824:	21 f0       	breq	.+8      	; 0x282e <vTaskIncrementTick+0x8c>
    2826:	ce 01       	movw	r24, r28
    2828:	0c 96       	adiw	r24, 0x0c	; 12
    282a:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <vListRemove>
    282e:	9e 89       	ldd	r25, Y+22	; 0x16
    2830:	80 91 fc 02 	lds	r24, 0x02FC
    2834:	89 17       	cp	r24, r25
    2836:	10 f4       	brcc	.+4      	; 0x283c <vTaskIncrementTick+0x9a>
    2838:	90 93 fc 02 	sts	0x02FC, r25
    283c:	9f 9d       	mul	r25, r15
    283e:	c0 01       	movw	r24, r0
    2840:	11 24       	eor	r1, r1
    2842:	8d 5f       	subi	r24, 0xFD	; 253
    2844:	9c 4f       	sbci	r25, 0xFC	; 252
    2846:	b8 01       	movw	r22, r16
    2848:	0e 94 7e 0f 	call	0x1efc	; 0x1efc <vListInsertEnd>
    284c:	02 c0       	rjmp	.+4      	; 0x2852 <vTaskIncrementTick+0xb0>
    284e:	89 e0       	ldi	r24, 0x09	; 9
    2850:	f8 2e       	mov	r15, r24
    2852:	e0 91 39 03 	lds	r30, 0x0339
    2856:	f0 91 3a 03 	lds	r31, 0x033A
    285a:	80 81       	ld	r24, Z
    285c:	88 23       	and	r24, r24
    285e:	89 f0       	breq	.+34     	; 0x2882 <vTaskIncrementTick+0xe0>
    2860:	e0 91 39 03 	lds	r30, 0x0339
    2864:	f0 91 3a 03 	lds	r31, 0x033A
    2868:	05 80       	ldd	r0, Z+5	; 0x05
    286a:	f6 81       	ldd	r31, Z+6	; 0x06
    286c:	e0 2d       	mov	r30, r0
    286e:	c6 81       	ldd	r28, Z+6	; 0x06
    2870:	d7 81       	ldd	r29, Z+7	; 0x07
    2872:	20 97       	sbiw	r28, 0x00	; 0
    2874:	29 f6       	brne	.-118    	; 0x2800 <vTaskIncrementTick+0x5e>
    2876:	05 c0       	rjmp	.+10     	; 0x2882 <vTaskIncrementTick+0xe0>
	}
	else
	{
		++uxMissedTicks;
    2878:	80 91 fd 02 	lds	r24, 0x02FD
    287c:	8f 5f       	subi	r24, 0xFF	; 255
    287e:	80 93 fd 02 	sts	0x02FD, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    2882:	df 91       	pop	r29
    2884:	cf 91       	pop	r28
    2886:	1f 91       	pop	r17
    2888:	0f 91       	pop	r16
    288a:	ff 90       	pop	r15
    288c:	08 95       	ret

0000288e <vTaskPlaceOnEventList>:
	vWriteTraceToBuffer();
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    288e:	0f 93       	push	r16
    2890:	1f 93       	push	r17
    2892:	8b 01       	movw	r16, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    2894:	60 91 f5 02 	lds	r22, 0x02F5
    2898:	70 91 f6 02 	lds	r23, 0x02F6
    289c:	64 5f       	subi	r22, 0xF4	; 244
    289e:	7f 4f       	sbci	r23, 0xFF	; 255
    28a0:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    28a4:	80 91 f5 02 	lds	r24, 0x02F5
    28a8:	90 91 f6 02 	lds	r25, 0x02F6
    28ac:	02 96       	adiw	r24, 0x02	; 2
    28ae:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    28b2:	80 91 f9 02 	lds	r24, 0x02F9
    28b6:	90 91 fa 02 	lds	r25, 0x02FA
    28ba:	80 0f       	add	r24, r16
    28bc:	91 1f       	adc	r25, r17

			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    28be:	e0 91 f5 02 	lds	r30, 0x02F5
    28c2:	f0 91 f6 02 	lds	r31, 0x02F6
    28c6:	93 83       	std	Z+3, r25	; 0x03
    28c8:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xTickCount )
    28ca:	20 91 f9 02 	lds	r18, 0x02F9
    28ce:	30 91 fa 02 	lds	r19, 0x02FA
    28d2:	82 17       	cp	r24, r18
    28d4:	93 07       	cpc	r25, r19
    28d6:	28 f4       	brcc	.+10     	; 0x28e2 <vTaskPlaceOnEventList+0x54>
			{
				/* Wake time has overflowed.  Place this item in the overflow list. */
				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    28d8:	80 91 3b 03 	lds	r24, 0x033B
    28dc:	90 91 3c 03 	lds	r25, 0x033C
    28e0:	04 c0       	rjmp	.+8      	; 0x28ea <vTaskPlaceOnEventList+0x5c>
			}
			else
			{
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    28e2:	80 91 39 03 	lds	r24, 0x0339
    28e6:	90 91 3a 03 	lds	r25, 0x033A
    28ea:	60 91 f5 02 	lds	r22, 0x02F5
    28ee:	70 91 f6 02 	lds	r23, 0x02F6
    28f2:	6e 5f       	subi	r22, 0xFE	; 254
    28f4:	7f 4f       	sbci	r23, 0xFF	; 255
    28f6:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <vListInsert>
			}
	}
	#endif
}
    28fa:	1f 91       	pop	r17
    28fc:	0f 91       	pop	r16
    28fe:	08 95       	ret

00002900 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    2900:	cf 92       	push	r12
    2902:	df 92       	push	r13
    2904:	ff 92       	push	r15
    2906:	0f 93       	push	r16
    2908:	1f 93       	push	r17
    290a:	df 93       	push	r29
    290c:	cf 93       	push	r28
    290e:	0f 92       	push	r0
    2910:	cd b7       	in	r28, 0x3d	; 61
    2912:	de b7       	in	r29, 0x3e	; 62
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	portENTER_CRITICAL();
    2914:	0f b6       	in	r0, 0x3f	; 63
    2916:	f8 94       	cli
    2918:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    291a:	80 91 fb 02 	lds	r24, 0x02FB
    291e:	81 50       	subi	r24, 0x01	; 1
    2920:	80 93 fb 02 	sts	0x02FB, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2924:	80 91 fb 02 	lds	r24, 0x02FB
    2928:	88 23       	and	r24, r24
    292a:	09 f0       	breq	.+2      	; 0x292e <xTaskResumeAll+0x2e>
    292c:	5b c0       	rjmp	.+182    	; 0x29e4 <xTaskResumeAll+0xe4>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
    292e:	80 91 fe 02 	lds	r24, 0x02FE
    2932:	88 23       	and	r24, r24
    2934:	09 f4       	brne	.+2      	; 0x2938 <xTaskResumeAll+0x38>
    2936:	56 c0       	rjmp	.+172    	; 0x29e4 <xTaskResumeAll+0xe4>
    2938:	19 82       	std	Y+1, r1	; 0x01
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    293a:	99 e0       	ldi	r25, 0x09	; 9
    293c:	f9 2e       	mov	r15, r25
    293e:	27 c0       	rjmp	.+78     	; 0x298e <xTaskResumeAll+0x8e>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
    2940:	c6 01       	movw	r24, r12
    2942:	0c 96       	adiw	r24, 0x0c	; 12
    2944:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    2948:	86 01       	movw	r16, r12
    294a:	0e 5f       	subi	r16, 0xFE	; 254
    294c:	1f 4f       	sbci	r17, 0xFF	; 255
    294e:	c8 01       	movw	r24, r16
    2950:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    2954:	d6 01       	movw	r26, r12
    2956:	56 96       	adiw	r26, 0x16	; 22
    2958:	9c 91       	ld	r25, X
    295a:	80 91 fc 02 	lds	r24, 0x02FC
    295e:	89 17       	cp	r24, r25
    2960:	10 f4       	brcc	.+4      	; 0x2966 <xTaskResumeAll+0x66>
    2962:	90 93 fc 02 	sts	0x02FC, r25
    2966:	9f 9d       	mul	r25, r15
    2968:	c0 01       	movw	r24, r0
    296a:	11 24       	eor	r1, r1
    296c:	8d 5f       	subi	r24, 0xFD	; 253
    296e:	9c 4f       	sbci	r25, 0xFC	; 252
    2970:	b8 01       	movw	r22, r16
    2972:	0e 94 7e 0f 	call	0x1efc	; 0x1efc <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2976:	e0 91 f5 02 	lds	r30, 0x02F5
    297a:	f0 91 f6 02 	lds	r31, 0x02F6
    297e:	d6 01       	movw	r26, r12
    2980:	56 96       	adiw	r26, 0x16	; 22
    2982:	9c 91       	ld	r25, X
    2984:	86 89       	ldd	r24, Z+22	; 0x16
    2986:	98 17       	cp	r25, r24
    2988:	10 f0       	brcs	.+4      	; 0x298e <xTaskResumeAll+0x8e>
    298a:	b1 e0       	ldi	r27, 0x01	; 1
    298c:	b9 83       	std	Y+1, r27	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
    298e:	80 91 3d 03 	lds	r24, 0x033D
    2992:	88 23       	and	r24, r24
    2994:	49 f0       	breq	.+18     	; 0x29a8 <xTaskResumeAll+0xa8>
    2996:	e0 91 42 03 	lds	r30, 0x0342
    299a:	f0 91 43 03 	lds	r31, 0x0343
    299e:	c6 80       	ldd	r12, Z+6	; 0x06
    29a0:	d7 80       	ldd	r13, Z+7	; 0x07
    29a2:	c1 14       	cp	r12, r1
    29a4:	d1 04       	cpc	r13, r1
    29a6:	61 f6       	brne	.-104    	; 0x2940 <xTaskResumeAll+0x40>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    29a8:	80 91 fd 02 	lds	r24, 0x02FD
    29ac:	88 23       	and	r24, r24
    29ae:	41 f4       	brne	.+16     	; 0x29c0 <xTaskResumeAll+0xc0>
    29b0:	0c c0       	rjmp	.+24     	; 0x29ca <xTaskResumeAll+0xca>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
    29b2:	0e 94 d1 13 	call	0x27a2	; 0x27a2 <vTaskIncrementTick>
						--uxMissedTicks;
    29b6:	80 91 fd 02 	lds	r24, 0x02FD
    29ba:	81 50       	subi	r24, 0x01	; 1
    29bc:	80 93 fd 02 	sts	0x02FD, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    29c0:	80 91 fd 02 	lds	r24, 0x02FD
    29c4:	88 23       	and	r24, r24
    29c6:	a9 f7       	brne	.-22     	; 0x29b2 <xTaskResumeAll+0xb2>
    29c8:	07 c0       	rjmp	.+14     	; 0x29d8 <xTaskResumeAll+0xd8>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    29ca:	e9 81       	ldd	r30, Y+1	; 0x01
    29cc:	e1 30       	cpi	r30, 0x01	; 1
    29ce:	21 f0       	breq	.+8      	; 0x29d8 <xTaskResumeAll+0xd8>
    29d0:	80 91 f7 02 	lds	r24, 0x02F7
    29d4:	81 30       	cpi	r24, 0x01	; 1
    29d6:	31 f4       	brne	.+12     	; 0x29e4 <xTaskResumeAll+0xe4>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    29d8:	10 92 f7 02 	sts	0x02F7, r1
					portYIELD_WITHIN_API();
    29dc:	0e 94 56 18 	call	0x30ac	; 0x30ac <vPortYield>
    29e0:	81 e0       	ldi	r24, 0x01	; 1
    29e2:	01 c0       	rjmp	.+2      	; 0x29e6 <xTaskResumeAll+0xe6>
    29e4:	80 e0       	ldi	r24, 0x00	; 0
				}
			}
		}
	}
	portEXIT_CRITICAL();
    29e6:	0f 90       	pop	r0
    29e8:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    29ea:	0f 90       	pop	r0
    29ec:	cf 91       	pop	r28
    29ee:	df 91       	pop	r29
    29f0:	1f 91       	pop	r17
    29f2:	0f 91       	pop	r16
    29f4:	ff 90       	pop	r15
    29f6:	df 90       	pop	r13
    29f8:	cf 90       	pop	r12
    29fa:	08 95       	ret

000029fc <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    29fc:	0f 93       	push	r16
    29fe:	1f 93       	push	r17
    2a00:	9c 01       	movw	r18, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
    2a02:	00 97       	sbiw	r24, 0x00	; 0
    2a04:	a1 f1       	breq	.+104    	; 0x2a6e <vTaskDelay+0x72>

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    2a06:	80 91 fb 02 	lds	r24, 0x02FB
    2a0a:	8f 5f       	subi	r24, 0xFF	; 255
    2a0c:	80 93 fb 02 	sts	0x02FB, r24
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2a10:	00 91 f9 02 	lds	r16, 0x02F9
    2a14:	10 91 fa 02 	lds	r17, 0x02FA
    2a18:	02 0f       	add	r16, r18
    2a1a:	13 1f       	adc	r17, r19

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2a1c:	80 91 f5 02 	lds	r24, 0x02F5
    2a20:	90 91 f6 02 	lds	r25, 0x02F6
    2a24:	02 96       	adiw	r24, 0x02	; 2
    2a26:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    2a2a:	e0 91 f5 02 	lds	r30, 0x02F5
    2a2e:	f0 91 f6 02 	lds	r31, 0x02F6
    2a32:	13 83       	std	Z+3, r17	; 0x03
    2a34:	02 83       	std	Z+2, r16	; 0x02

				if( xTimeToWake < xTickCount )
    2a36:	80 91 f9 02 	lds	r24, 0x02F9
    2a3a:	90 91 fa 02 	lds	r25, 0x02FA
    2a3e:	08 17       	cp	r16, r24
    2a40:	19 07       	cpc	r17, r25
    2a42:	28 f4       	brcc	.+10     	; 0x2a4e <vTaskDelay+0x52>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2a44:	80 91 3b 03 	lds	r24, 0x033B
    2a48:	90 91 3c 03 	lds	r25, 0x033C
    2a4c:	04 c0       	rjmp	.+8      	; 0x2a56 <vTaskDelay+0x5a>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2a4e:	80 91 39 03 	lds	r24, 0x0339
    2a52:	90 91 3a 03 	lds	r25, 0x033A
    2a56:	60 91 f5 02 	lds	r22, 0x02F5
    2a5a:	70 91 f6 02 	lds	r23, 0x02F6
    2a5e:	6e 5f       	subi	r22, 0xFE	; 254
    2a60:	7f 4f       	sbci	r23, 0xFF	; 255
    2a62:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <vListInsert>
				}
			}
			xAlreadyYielded = xTaskResumeAll();
    2a66:	0e 94 80 14 	call	0x2900	; 0x2900 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
    2a6a:	88 23       	and	r24, r24
    2a6c:	11 f4       	brne	.+4      	; 0x2a72 <vTaskDelay+0x76>
		{
			portYIELD_WITHIN_API();
    2a6e:	0e 94 56 18 	call	0x30ac	; 0x30ac <vPortYield>
		}
	}
    2a72:	1f 91       	pop	r17
    2a74:	0f 91       	pop	r16
    2a76:	08 95       	ret

00002a78 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    2a78:	cf 93       	push	r28
    2a7a:	df 93       	push	r29
    2a7c:	fc 01       	movw	r30, r24
    2a7e:	eb 01       	movw	r28, r22

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    2a80:	80 91 fb 02 	lds	r24, 0x02FB
    2a84:	8f 5f       	subi	r24, 0xFF	; 255
    2a86:	80 93 fb 02 	sts	0x02FB, r24
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		vTaskSuspendAll();
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2a8a:	20 81       	ld	r18, Z
    2a8c:	31 81       	ldd	r19, Z+1	; 0x01
    2a8e:	c2 0f       	add	r28, r18
    2a90:	d3 1f       	adc	r29, r19

			if( xTickCount < *pxPreviousWakeTime )
    2a92:	80 91 f9 02 	lds	r24, 0x02F9
    2a96:	90 91 fa 02 	lds	r25, 0x02FA
    2a9a:	82 17       	cp	r24, r18
    2a9c:	93 07       	cpc	r25, r19
    2a9e:	28 f4       	brcc	.+10     	; 0x2aaa <vTaskDelayUntil+0x32>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    2aa0:	c2 17       	cp	r28, r18
    2aa2:	d3 07       	cpc	r29, r19
    2aa4:	28 f0       	brcs	.+10     	; 0x2ab0 <vTaskDelayUntil+0x38>
    2aa6:	20 e0       	ldi	r18, 0x00	; 0
    2aa8:	0c c0       	rjmp	.+24     	; 0x2ac2 <vTaskDelayUntil+0x4a>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    2aaa:	c2 17       	cp	r28, r18
    2aac:	d3 07       	cpc	r29, r19
    2aae:	40 f0       	brcs	.+16     	; 0x2ac0 <vTaskDelayUntil+0x48>
    2ab0:	80 91 f9 02 	lds	r24, 0x02F9
    2ab4:	90 91 fa 02 	lds	r25, 0x02FA
    2ab8:	20 e0       	ldi	r18, 0x00	; 0
    2aba:	8c 17       	cp	r24, r28
    2abc:	9d 07       	cpc	r25, r29
    2abe:	08 f4       	brcc	.+2      	; 0x2ac2 <vTaskDelayUntil+0x4a>
    2ac0:	21 e0       	ldi	r18, 0x01	; 1
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2ac2:	d1 83       	std	Z+1, r29	; 0x01
    2ac4:	c0 83       	st	Z, r28

			if( xShouldDelay )
    2ac6:	22 23       	and	r18, r18
    2ac8:	29 f1       	breq	.+74     	; 0x2b14 <vTaskDelayUntil+0x9c>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2aca:	80 91 f5 02 	lds	r24, 0x02F5
    2ace:	90 91 f6 02 	lds	r25, 0x02F6
    2ad2:	02 96       	adiw	r24, 0x02	; 2
    2ad4:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    2ad8:	e0 91 f5 02 	lds	r30, 0x02F5
    2adc:	f0 91 f6 02 	lds	r31, 0x02F6
    2ae0:	d3 83       	std	Z+3, r29	; 0x03
    2ae2:	c2 83       	std	Z+2, r28	; 0x02

				if( xTimeToWake < xTickCount )
    2ae4:	80 91 f9 02 	lds	r24, 0x02F9
    2ae8:	90 91 fa 02 	lds	r25, 0x02FA
    2aec:	c8 17       	cp	r28, r24
    2aee:	d9 07       	cpc	r29, r25
    2af0:	28 f4       	brcc	.+10     	; 0x2afc <vTaskDelayUntil+0x84>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2af2:	80 91 3b 03 	lds	r24, 0x033B
    2af6:	90 91 3c 03 	lds	r25, 0x033C
    2afa:	04 c0       	rjmp	.+8      	; 0x2b04 <vTaskDelayUntil+0x8c>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2afc:	80 91 39 03 	lds	r24, 0x0339
    2b00:	90 91 3a 03 	lds	r25, 0x033A
    2b04:	60 91 f5 02 	lds	r22, 0x02F5
    2b08:	70 91 f6 02 	lds	r23, 0x02F6
    2b0c:	6e 5f       	subi	r22, 0xFE	; 254
    2b0e:	7f 4f       	sbci	r23, 0xFF	; 255
    2b10:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <vListInsert>
				}
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    2b14:	0e 94 80 14 	call	0x2900	; 0x2900 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
    2b18:	88 23       	and	r24, r24
    2b1a:	11 f4       	brne	.+4      	; 0x2b20 <vTaskDelayUntil+0xa8>
		{
			portYIELD_WITHIN_API();
    2b1c:	0e 94 56 18 	call	0x30ac	; 0x30ac <vPortYield>
		}
	}
    2b20:	df 91       	pop	r29
    2b22:	cf 91       	pop	r28
    2b24:	08 95       	ret

00002b26 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    2b26:	ef 92       	push	r14
    2b28:	ff 92       	push	r15
    2b2a:	0f 93       	push	r16
    2b2c:	1f 93       	push	r17
    2b2e:	cf 93       	push	r28
    2b30:	df 93       	push	r29
    2b32:	8c 01       	movw	r16, r24
	tskTCB *pxTCB;

		portENTER_CRITICAL();
    2b34:	0f b6       	in	r0, 0x3f	; 63
    2b36:	f8 94       	cli
    2b38:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    2b3a:	80 91 f5 02 	lds	r24, 0x02F5
    2b3e:	90 91 f6 02 	lds	r25, 0x02F6
    2b42:	08 17       	cp	r16, r24
    2b44:	19 07       	cpc	r17, r25
    2b46:	19 f4       	brne	.+6      	; 0x2b4e <vTaskDelete+0x28>
    2b48:	00 e0       	ldi	r16, 0x00	; 0
    2b4a:	10 e0       	ldi	r17, 0x00	; 0
    2b4c:	03 c0       	rjmp	.+6      	; 0x2b54 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    2b4e:	01 15       	cp	r16, r1
    2b50:	11 05       	cpc	r17, r1
    2b52:	29 f4       	brne	.+10     	; 0x2b5e <vTaskDelete+0x38>
    2b54:	c0 91 f5 02 	lds	r28, 0x02F5
    2b58:	d0 91 f6 02 	lds	r29, 0x02F6
    2b5c:	01 c0       	rjmp	.+2      	; 0x2b60 <vTaskDelete+0x3a>
    2b5e:	e8 01       	movw	r28, r16

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    2b60:	22 e0       	ldi	r18, 0x02	; 2
    2b62:	e2 2e       	mov	r14, r18
    2b64:	f1 2c       	mov	r15, r1
    2b66:	ec 0e       	add	r14, r28
    2b68:	fd 1e       	adc	r15, r29
    2b6a:	c7 01       	movw	r24, r14
    2b6c:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer )
    2b70:	8c 89       	ldd	r24, Y+20	; 0x14
    2b72:	9d 89       	ldd	r25, Y+21	; 0x15
    2b74:	89 2b       	or	r24, r25
    2b76:	21 f0       	breq	.+8      	; 0x2b80 <vTaskDelete+0x5a>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    2b78:	ce 01       	movw	r24, r28
    2b7a:	0c 96       	adiw	r24, 0x0c	; 12
    2b7c:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    2b80:	86 e4       	ldi	r24, 0x46	; 70
    2b82:	93 e0       	ldi	r25, 0x03	; 3
    2b84:	b7 01       	movw	r22, r14
    2b86:	0e 94 7e 0f 	call	0x1efc	; 0x1efc <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    2b8a:	80 91 00 03 	lds	r24, 0x0300
    2b8e:	8f 5f       	subi	r24, 0xFF	; 255
    2b90:	80 93 00 03 	sts	0x0300, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    2b94:	80 91 01 03 	lds	r24, 0x0301
    2b98:	8f 5f       	subi	r24, 0xFF	; 255
    2b9a:	80 93 01 03 	sts	0x0301, r24

			traceTASK_DELETE( pxTCB );
		}
		portEXIT_CRITICAL();
    2b9e:	0f 90       	pop	r0
    2ba0:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    2ba2:	80 91 ff 02 	lds	r24, 0x02FF
    2ba6:	88 23       	and	r24, r24
    2ba8:	21 f0       	breq	.+8      	; 0x2bb2 <vTaskDelete+0x8c>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    2baa:	01 2b       	or	r16, r17
    2bac:	11 f4       	brne	.+4      	; 0x2bb2 <vTaskDelete+0x8c>
			{
				portYIELD_WITHIN_API();
    2bae:	0e 94 56 18 	call	0x30ac	; 0x30ac <vPortYield>
			}
		}
	}
    2bb2:	df 91       	pop	r29
    2bb4:	cf 91       	pop	r28
    2bb6:	1f 91       	pop	r17
    2bb8:	0f 91       	pop	r16
    2bba:	ff 90       	pop	r15
    2bbc:	ef 90       	pop	r14
    2bbe:	08 95       	ret

00002bc0 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    2bc0:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    2bc2:	10 92 ff 02 	sts	0x02FF, r1
	vPortEndScheduler();
    2bc6:	0e 94 f7 17 	call	0x2fee	; 0x2fee <vPortEndScheduler>
}
    2bca:	08 95       	ret

00002bcc <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    2bcc:	1f 93       	push	r17
    2bce:	cf 93       	push	r28
    2bd0:	df 93       	push	r29
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
    2bd2:	80 91 00 03 	lds	r24, 0x0300
    2bd6:	88 23       	and	r24, r24
    2bd8:	91 f1       	breq	.+100    	; 0x2c3e <prvIdleTask+0x72>

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    2bda:	80 91 fb 02 	lds	r24, 0x02FB
    2bde:	8f 5f       	subi	r24, 0xFF	; 255
    2be0:	80 93 fb 02 	sts	0x02FB, r24
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    2be4:	10 91 46 03 	lds	r17, 0x0346
			xTaskResumeAll();
    2be8:	0e 94 80 14 	call	0x2900	; 0x2900 <xTaskResumeAll>

			if( !xListIsEmpty )
    2bec:	11 23       	and	r17, r17
    2bee:	39 f1       	breq	.+78     	; 0x2c3e <prvIdleTask+0x72>
			{
				tskTCB *pxTCB;

				portENTER_CRITICAL();
    2bf0:	0f b6       	in	r0, 0x3f	; 63
    2bf2:	f8 94       	cli
    2bf4:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    2bf6:	80 91 46 03 	lds	r24, 0x0346
    2bfa:	88 23       	and	r24, r24
    2bfc:	19 f4       	brne	.+6      	; 0x2c04 <prvIdleTask+0x38>
    2bfe:	c0 e0       	ldi	r28, 0x00	; 0
    2c00:	d0 e0       	ldi	r29, 0x00	; 0
    2c02:	06 c0       	rjmp	.+12     	; 0x2c10 <prvIdleTask+0x44>
    2c04:	e0 91 4b 03 	lds	r30, 0x034B
    2c08:	f0 91 4c 03 	lds	r31, 0x034C
    2c0c:	c6 81       	ldd	r28, Z+6	; 0x06
    2c0e:	d7 81       	ldd	r29, Z+7	; 0x07
					vListRemove( &( pxTCB->xGenericListItem ) );
    2c10:	ce 01       	movw	r24, r28
    2c12:	02 96       	adiw	r24, 0x02	; 2
    2c14:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <vListRemove>
					--uxCurrentNumberOfTasks;
    2c18:	80 91 fe 02 	lds	r24, 0x02FE
    2c1c:	81 50       	subi	r24, 0x01	; 1
    2c1e:	80 93 fe 02 	sts	0x02FE, r24
					--uxTasksDeleted;
    2c22:	80 91 00 03 	lds	r24, 0x0300
    2c26:	81 50       	subi	r24, 0x01	; 1
    2c28:	80 93 00 03 	sts	0x0300, r24
				}
				portEXIT_CRITICAL();
    2c2c:	0f 90       	pop	r0
    2c2e:	0f be       	out	0x3f, r0	; 63

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    2c30:	8f 89       	ldd	r24, Y+23	; 0x17
    2c32:	98 8d       	ldd	r25, Y+24	; 0x18
    2c34:	0e 94 79 1a 	call	0x34f2	; 0x34f2 <vPortFree>
		vPortFree( pxTCB );
    2c38:	ce 01       	movw	r24, r28
    2c3a:	0e 94 79 1a 	call	0x34f2	; 0x34f2 <vPortFree>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    2c3e:	80 91 03 03 	lds	r24, 0x0303
    2c42:	82 30       	cpi	r24, 0x02	; 2
    2c44:	30 f2       	brcs	.-116    	; 0x2bd2 <prvIdleTask+0x6>
			{
				taskYIELD();
    2c46:	0e 94 56 18 	call	0x30ac	; 0x30ac <vPortYield>
    2c4a:	c3 cf       	rjmp	.-122    	; 0x2bd2 <prvIdleTask+0x6>

00002c4c <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    2c4c:	2f 92       	push	r2
    2c4e:	3f 92       	push	r3
    2c50:	5f 92       	push	r5
    2c52:	6f 92       	push	r6
    2c54:	7f 92       	push	r7
    2c56:	8f 92       	push	r8
    2c58:	9f 92       	push	r9
    2c5a:	af 92       	push	r10
    2c5c:	bf 92       	push	r11
    2c5e:	cf 92       	push	r12
    2c60:	df 92       	push	r13
    2c62:	ef 92       	push	r14
    2c64:	ff 92       	push	r15
    2c66:	0f 93       	push	r16
    2c68:	1f 93       	push	r17
    2c6a:	df 93       	push	r29
    2c6c:	cf 93       	push	r28
    2c6e:	00 d0       	rcall	.+0      	; 0x2c70 <xTaskGenericCreate+0x24>
    2c70:	00 d0       	rcall	.+0      	; 0x2c72 <xTaskGenericCreate+0x26>
    2c72:	cd b7       	in	r28, 0x3d	; 61
    2c74:	de b7       	in	r29, 0x3e	; 62
    2c76:	9a 83       	std	Y+2, r25	; 0x02
    2c78:	89 83       	std	Y+1, r24	; 0x01
    2c7a:	4b 01       	movw	r8, r22
    2c7c:	5a 01       	movw	r10, r20
    2c7e:	19 01       	movw	r2, r18
    2c80:	50 2e       	mov	r5, r16
    2c82:	37 01       	movw	r6, r14
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    2c84:	81 e2       	ldi	r24, 0x21	; 33
    2c86:	90 e0       	ldi	r25, 0x00	; 0
    2c88:	0e 94 89 1a 	call	0x3512	; 0x3512 <pvPortMalloc>
    2c8c:	8b 83       	std	Y+3, r24	; 0x03
    2c8e:	9c 83       	std	Y+4, r25	; 0x04

	if( pxNewTCB != NULL )
    2c90:	8b 81       	ldd	r24, Y+3	; 0x03
    2c92:	9c 81       	ldd	r25, Y+4	; 0x04
    2c94:	89 2b       	or	r24, r25
    2c96:	89 f0       	breq	.+34     	; 0x2cba <xTaskGenericCreate+0x6e>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    2c98:	c1 14       	cp	r12, r1
    2c9a:	d1 04       	cpc	r13, r1
    2c9c:	21 f4       	brne	.+8      	; 0x2ca6 <xTaskGenericCreate+0x5a>
    2c9e:	c5 01       	movw	r24, r10
    2ca0:	0e 94 89 1a 	call	0x3512	; 0x3512 <pvPortMalloc>
    2ca4:	6c 01       	movw	r12, r24
    2ca6:	eb 81       	ldd	r30, Y+3	; 0x03
    2ca8:	fc 81       	ldd	r31, Y+4	; 0x04
    2caa:	d0 8e       	std	Z+24, r13	; 0x18
    2cac:	c7 8a       	std	Z+23, r12	; 0x17

		if( pxNewTCB->pxStack == NULL )
    2cae:	c1 14       	cp	r12, r1
    2cb0:	d1 04       	cpc	r13, r1
    2cb2:	29 f4       	brne	.+10     	; 0x2cbe <xTaskGenericCreate+0x72>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    2cb4:	cf 01       	movw	r24, r30
    2cb6:	0e 94 79 1a 	call	0x34f2	; 0x34f2 <vPortFree>
    2cba:	8f ef       	ldi	r24, 0xFF	; 255
    2cbc:	d5 c0       	rjmp	.+426    	; 0x2e68 <xTaskGenericCreate+0x21c>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
    2cbe:	c6 01       	movw	r24, r12
    2cc0:	65 ea       	ldi	r22, 0xA5	; 165
    2cc2:	70 e0       	ldi	r23, 0x00	; 0
    2cc4:	a5 01       	movw	r20, r10
    2cc6:	0e 94 69 2c 	call	0x58d2	; 0x58d2 <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
    2cca:	08 94       	sec
    2ccc:	a1 08       	sbc	r10, r1
    2cce:	b1 08       	sbc	r11, r1
    2cd0:	eb 81       	ldd	r30, Y+3	; 0x03
    2cd2:	fc 81       	ldd	r31, Y+4	; 0x04
    2cd4:	e7 88       	ldd	r14, Z+23	; 0x17
    2cd6:	f0 8c       	ldd	r15, Z+24	; 0x18
    2cd8:	ea 0c       	add	r14, r10
    2cda:	fb 1c       	adc	r15, r11
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    2cdc:	cf 01       	movw	r24, r30
    2cde:	49 96       	adiw	r24, 0x19	; 25
    2ce0:	b4 01       	movw	r22, r8
    2ce2:	48 e0       	ldi	r20, 0x08	; 8
    2ce4:	50 e0       	ldi	r21, 0x00	; 0
    2ce6:	0e 94 70 2c 	call	0x58e0	; 0x58e0 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
    2cea:	eb 81       	ldd	r30, Y+3	; 0x03
    2cec:	fc 81       	ldd	r31, Y+4	; 0x04
    2cee:	10 a2       	std	Z+32, r1	; 0x20
    2cf0:	05 2d       	mov	r16, r5
    2cf2:	f3 e0       	ldi	r31, 0x03	; 3
    2cf4:	f5 15       	cp	r31, r5
    2cf6:	08 f4       	brcc	.+2      	; 0x2cfa <xTaskGenericCreate+0xae>
    2cf8:	03 e0       	ldi	r16, 0x03	; 3
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - 1;
	}

	pxTCB->uxPriority = uxPriority;
    2cfa:	eb 81       	ldd	r30, Y+3	; 0x03
    2cfc:	fc 81       	ldd	r31, Y+4	; 0x04
    2cfe:	06 8b       	std	Z+22, r16	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    2d00:	42 e0       	ldi	r20, 0x02	; 2
    2d02:	c4 2e       	mov	r12, r20
    2d04:	d1 2c       	mov	r13, r1
    2d06:	ce 0e       	add	r12, r30
    2d08:	df 1e       	adc	r13, r31
    2d0a:	c6 01       	movw	r24, r12
    2d0c:	0e 94 7a 0f 	call	0x1ef4	; 0x1ef4 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    2d10:	8b 81       	ldd	r24, Y+3	; 0x03
    2d12:	9c 81       	ldd	r25, Y+4	; 0x04
    2d14:	0c 96       	adiw	r24, 0x0c	; 12
    2d16:	0e 94 7a 0f 	call	0x1ef4	; 0x1ef4 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    2d1a:	8b 81       	ldd	r24, Y+3	; 0x03
    2d1c:	9c 81       	ldd	r25, Y+4	; 0x04
    2d1e:	fc 01       	movw	r30, r24
    2d20:	91 87       	std	Z+9, r25	; 0x09
    2d22:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    2d24:	84 e0       	ldi	r24, 0x04	; 4
    2d26:	90 e0       	ldi	r25, 0x00	; 0
    2d28:	80 1b       	sub	r24, r16
    2d2a:	91 09       	sbc	r25, r1
    2d2c:	95 87       	std	Z+13, r25	; 0x0d
    2d2e:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    2d30:	f3 8b       	std	Z+19, r31	; 0x13
    2d32:	e2 8b       	std	Z+18, r30	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    2d34:	c7 01       	movw	r24, r14
    2d36:	69 81       	ldd	r22, Y+1	; 0x01
    2d38:	7a 81       	ldd	r23, Y+2	; 0x02
    2d3a:	a1 01       	movw	r20, r2
    2d3c:	0e 94 75 17 	call	0x2eea	; 0x2eea <pxPortInitialiseStack>
    2d40:	eb 81       	ldd	r30, Y+3	; 0x03
    2d42:	fc 81       	ldd	r31, Y+4	; 0x04
    2d44:	91 83       	std	Z+1, r25	; 0x01
    2d46:	80 83       	st	Z, r24
		}
		#endif

		if( ( void * ) pxCreatedTask != NULL )
    2d48:	61 14       	cp	r6, r1
    2d4a:	71 04       	cpc	r7, r1
    2d4c:	21 f0       	breq	.+8      	; 0x2d56 <xTaskGenericCreate+0x10a>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    2d4e:	cf 01       	movw	r24, r30
    2d50:	f3 01       	movw	r30, r6
    2d52:	91 83       	std	Z+1, r25	; 0x01
    2d54:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		portENTER_CRITICAL();
    2d56:	0f b6       	in	r0, 0x3f	; 63
    2d58:	f8 94       	cli
    2d5a:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    2d5c:	80 91 fe 02 	lds	r24, 0x02FE
    2d60:	8f 5f       	subi	r24, 0xFF	; 255
    2d62:	80 93 fe 02 	sts	0x02FE, r24
			if( pxCurrentTCB == NULL )
    2d66:	80 91 f5 02 	lds	r24, 0x02F5
    2d6a:	90 91 f6 02 	lds	r25, 0x02F6
    2d6e:	89 2b       	or	r24, r25
    2d70:	b9 f5       	brne	.+110    	; 0x2de0 <xTaskGenericCreate+0x194>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    2d72:	eb 81       	ldd	r30, Y+3	; 0x03
    2d74:	fc 81       	ldd	r31, Y+4	; 0x04
    2d76:	f0 93 f6 02 	sts	0x02F6, r31
    2d7a:	e0 93 f5 02 	sts	0x02F5, r30

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    2d7e:	80 91 fe 02 	lds	r24, 0x02FE
    2d82:	81 30       	cpi	r24, 0x01	; 1
    2d84:	f1 f5       	brne	.+124    	; 0x2e02 <xTaskGenericCreate+0x1b6>
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    2d86:	83 e0       	ldi	r24, 0x03	; 3
    2d88:	93 e0       	ldi	r25, 0x03	; 3
    2d8a:	0e 94 6a 0f 	call	0x1ed4	; 0x1ed4 <vListInitialise>
    2d8e:	8c e0       	ldi	r24, 0x0C	; 12
    2d90:	93 e0       	ldi	r25, 0x03	; 3
    2d92:	0e 94 6a 0f 	call	0x1ed4	; 0x1ed4 <vListInitialise>
    2d96:	85 e1       	ldi	r24, 0x15	; 21
    2d98:	93 e0       	ldi	r25, 0x03	; 3
    2d9a:	0e 94 6a 0f 	call	0x1ed4	; 0x1ed4 <vListInitialise>
    2d9e:	8e e1       	ldi	r24, 0x1E	; 30
    2da0:	93 e0       	ldi	r25, 0x03	; 3
    2da2:	0e 94 6a 0f 	call	0x1ed4	; 0x1ed4 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    2da6:	37 e2       	ldi	r19, 0x27	; 39
    2da8:	e3 2e       	mov	r14, r19
    2daa:	33 e0       	ldi	r19, 0x03	; 3
    2dac:	f3 2e       	mov	r15, r19
    2dae:	c7 01       	movw	r24, r14
    2db0:	0e 94 6a 0f 	call	0x1ed4	; 0x1ed4 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    2db4:	00 e3       	ldi	r16, 0x30	; 48
    2db6:	13 e0       	ldi	r17, 0x03	; 3
    2db8:	c8 01       	movw	r24, r16
    2dba:	0e 94 6a 0f 	call	0x1ed4	; 0x1ed4 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    2dbe:	8d e3       	ldi	r24, 0x3D	; 61
    2dc0:	93 e0       	ldi	r25, 0x03	; 3
    2dc2:	0e 94 6a 0f 	call	0x1ed4	; 0x1ed4 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    2dc6:	86 e4       	ldi	r24, 0x46	; 70
    2dc8:	93 e0       	ldi	r25, 0x03	; 3
    2dca:	0e 94 6a 0f 	call	0x1ed4	; 0x1ed4 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    2dce:	f0 92 3a 03 	sts	0x033A, r15
    2dd2:	e0 92 39 03 	sts	0x0339, r14
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    2dd6:	10 93 3c 03 	sts	0x033C, r17
    2dda:	00 93 3b 03 	sts	0x033B, r16
    2dde:	11 c0       	rjmp	.+34     	; 0x2e02 <xTaskGenericCreate+0x1b6>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    2de0:	80 91 ff 02 	lds	r24, 0x02FF
    2de4:	88 23       	and	r24, r24
    2de6:	69 f4       	brne	.+26     	; 0x2e02 <xTaskGenericCreate+0x1b6>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    2de8:	e0 91 f5 02 	lds	r30, 0x02F5
    2dec:	f0 91 f6 02 	lds	r31, 0x02F6
    2df0:	86 89       	ldd	r24, Z+22	; 0x16
    2df2:	58 16       	cp	r5, r24
    2df4:	30 f0       	brcs	.+12     	; 0x2e02 <xTaskGenericCreate+0x1b6>
					{
						pxCurrentTCB = pxNewTCB;
    2df6:	8b 81       	ldd	r24, Y+3	; 0x03
    2df8:	9c 81       	ldd	r25, Y+4	; 0x04
    2dfa:	90 93 f6 02 	sts	0x02F6, r25
    2dfe:	80 93 f5 02 	sts	0x02F5, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    2e02:	eb 81       	ldd	r30, Y+3	; 0x03
    2e04:	fc 81       	ldd	r31, Y+4	; 0x04
    2e06:	96 89       	ldd	r25, Z+22	; 0x16
    2e08:	80 91 02 03 	lds	r24, 0x0302
    2e0c:	89 17       	cp	r24, r25
    2e0e:	10 f4       	brcc	.+4      	; 0x2e14 <xTaskGenericCreate+0x1c8>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    2e10:	90 93 02 03 	sts	0x0302, r25
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    2e14:	80 91 01 03 	lds	r24, 0x0301
    2e18:	8f 5f       	subi	r24, 0xFF	; 255
    2e1a:	80 93 01 03 	sts	0x0301, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    2e1e:	eb 81       	ldd	r30, Y+3	; 0x03
    2e20:	fc 81       	ldd	r31, Y+4	; 0x04
    2e22:	96 89       	ldd	r25, Z+22	; 0x16
    2e24:	80 91 fc 02 	lds	r24, 0x02FC
    2e28:	89 17       	cp	r24, r25
    2e2a:	10 f4       	brcc	.+4      	; 0x2e30 <xTaskGenericCreate+0x1e4>
    2e2c:	90 93 fc 02 	sts	0x02FC, r25
    2e30:	eb 81       	ldd	r30, Y+3	; 0x03
    2e32:	fc 81       	ldd	r31, Y+4	; 0x04
    2e34:	86 89       	ldd	r24, Z+22	; 0x16
    2e36:	29 e0       	ldi	r18, 0x09	; 9
    2e38:	82 9f       	mul	r24, r18
    2e3a:	c0 01       	movw	r24, r0
    2e3c:	11 24       	eor	r1, r1
    2e3e:	8d 5f       	subi	r24, 0xFD	; 253
    2e40:	9c 4f       	sbci	r25, 0xFC	; 252
    2e42:	b6 01       	movw	r22, r12
    2e44:	0e 94 7e 0f 	call	0x1efc	; 0x1efc <vListInsertEnd>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		portEXIT_CRITICAL();
    2e48:	0f 90       	pop	r0
    2e4a:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED( pxNewTCB );
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    2e4c:	80 91 ff 02 	lds	r24, 0x02FF
    2e50:	88 23       	and	r24, r24
    2e52:	49 f0       	breq	.+18     	; 0x2e66 <xTaskGenericCreate+0x21a>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    2e54:	e0 91 f5 02 	lds	r30, 0x02F5
    2e58:	f0 91 f6 02 	lds	r31, 0x02F6
    2e5c:	86 89       	ldd	r24, Z+22	; 0x16
    2e5e:	85 15       	cp	r24, r5
    2e60:	10 f4       	brcc	.+4      	; 0x2e66 <xTaskGenericCreate+0x21a>
			{
				portYIELD_WITHIN_API();
    2e62:	0e 94 56 18 	call	0x30ac	; 0x30ac <vPortYield>
    2e66:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    2e68:	0f 90       	pop	r0
    2e6a:	0f 90       	pop	r0
    2e6c:	0f 90       	pop	r0
    2e6e:	0f 90       	pop	r0
    2e70:	cf 91       	pop	r28
    2e72:	df 91       	pop	r29
    2e74:	1f 91       	pop	r17
    2e76:	0f 91       	pop	r16
    2e78:	ff 90       	pop	r15
    2e7a:	ef 90       	pop	r14
    2e7c:	df 90       	pop	r13
    2e7e:	cf 90       	pop	r12
    2e80:	bf 90       	pop	r11
    2e82:	af 90       	pop	r10
    2e84:	9f 90       	pop	r9
    2e86:	8f 90       	pop	r8
    2e88:	7f 90       	pop	r7
    2e8a:	6f 90       	pop	r6
    2e8c:	5f 90       	pop	r5
    2e8e:	3f 90       	pop	r3
    2e90:	2f 90       	pop	r2
    2e92:	08 95       	ret

00002e94 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    2e94:	af 92       	push	r10
    2e96:	bf 92       	push	r11
    2e98:	cf 92       	push	r12
    2e9a:	df 92       	push	r13
    2e9c:	ef 92       	push	r14
    2e9e:	ff 92       	push	r15
    2ea0:	0f 93       	push	r16
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
    2ea2:	86 ee       	ldi	r24, 0xE6	; 230
    2ea4:	95 e1       	ldi	r25, 0x15	; 21
    2ea6:	64 e9       	ldi	r22, 0x94	; 148
    2ea8:	72 e0       	ldi	r23, 0x02	; 2
    2eaa:	45 e5       	ldi	r20, 0x55	; 85
    2eac:	50 e0       	ldi	r21, 0x00	; 0
    2eae:	20 e0       	ldi	r18, 0x00	; 0
    2eb0:	30 e0       	ldi	r19, 0x00	; 0
    2eb2:	00 e0       	ldi	r16, 0x00	; 0
    2eb4:	ee 24       	eor	r14, r14
    2eb6:	ff 24       	eor	r15, r15
    2eb8:	cc 24       	eor	r12, r12
    2eba:	dd 24       	eor	r13, r13
    2ebc:	aa 24       	eor	r10, r10
    2ebe:	bb 24       	eor	r11, r11
    2ec0:	0e 94 26 16 	call	0x2c4c	; 0x2c4c <xTaskGenericCreate>

	if( xReturn == pdPASS )
    2ec4:	81 30       	cpi	r24, 0x01	; 1
    2ec6:	49 f4       	brne	.+18     	; 0x2eda <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    2ec8:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    2eca:	80 93 ff 02 	sts	0x02FF, r24
		xTickCount = ( portTickType ) 0;
    2ece:	10 92 fa 02 	sts	0x02FA, r1
    2ed2:	10 92 f9 02 	sts	0x02F9, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
    2ed6:	0e 94 bd 17 	call	0x2f7a	; 0x2f7a <xPortStartScheduler>
		else
		{
			/* Should only reach here if a task calls xTaskEndScheduler(). */
		}
	}
}
    2eda:	0f 91       	pop	r16
    2edc:	ff 90       	pop	r15
    2ede:	ef 90       	pop	r14
    2ee0:	df 90       	pop	r13
    2ee2:	cf 90       	pop	r12
    2ee4:	bf 90       	pop	r11
    2ee6:	af 90       	pop	r10
    2ee8:	08 95       	ret

00002eea <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    2eea:	fc 01       	movw	r30, r24
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    2eec:	91 e1       	ldi	r25, 0x11	; 17
    2eee:	90 83       	st	Z, r25
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    2ef0:	22 e2       	ldi	r18, 0x22	; 34
    2ef2:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    2ef4:	83 e3       	ldi	r24, 0x33	; 51
    2ef6:	82 93       	st	-Z, r24
	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	

	usAddress = ( unsigned short ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2ef8:	62 93       	st	-Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2efa:	72 93       	st	-Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    2efc:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    2efe:	80 e8       	ldi	r24, 0x80	; 128
    2f00:	82 93       	st	-Z, r24
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    2f02:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    2f04:	82 e0       	ldi	r24, 0x02	; 2
    2f06:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    2f08:	83 e0       	ldi	r24, 0x03	; 3
    2f0a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    2f0c:	84 e0       	ldi	r24, 0x04	; 4
    2f0e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    2f10:	85 e0       	ldi	r24, 0x05	; 5
    2f12:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    2f14:	86 e0       	ldi	r24, 0x06	; 6
    2f16:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    2f18:	87 e0       	ldi	r24, 0x07	; 7
    2f1a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    2f1c:	88 e0       	ldi	r24, 0x08	; 8
    2f1e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    2f20:	89 e0       	ldi	r24, 0x09	; 9
    2f22:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    2f24:	80 e1       	ldi	r24, 0x10	; 16
    2f26:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    2f28:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    2f2a:	82 e1       	ldi	r24, 0x12	; 18
    2f2c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    2f2e:	83 e1       	ldi	r24, 0x13	; 19
    2f30:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    2f32:	84 e1       	ldi	r24, 0x14	; 20
    2f34:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    2f36:	85 e1       	ldi	r24, 0x15	; 21
    2f38:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    2f3a:	86 e1       	ldi	r24, 0x16	; 22
    2f3c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    2f3e:	87 e1       	ldi	r24, 0x17	; 23
    2f40:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    2f42:	88 e1       	ldi	r24, 0x18	; 24
    2f44:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    2f46:	89 e1       	ldi	r24, 0x19	; 25
    2f48:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    2f4a:	80 e2       	ldi	r24, 0x20	; 32
    2f4c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    2f4e:	81 e2       	ldi	r24, 0x21	; 33
    2f50:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    2f52:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    2f54:	83 e2       	ldi	r24, 0x23	; 35
    2f56:	82 93       	st	-Z, r24
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */

	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2f58:	42 93       	st	-Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2f5a:	52 93       	st	-Z, r21
	pxTopOfStack--;


	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    2f5c:	86 e2       	ldi	r24, 0x26	; 38
    2f5e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    2f60:	87 e2       	ldi	r24, 0x27	; 39
    2f62:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    2f64:	88 e2       	ldi	r24, 0x28	; 40
    2f66:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    2f68:	89 e2       	ldi	r24, 0x29	; 41
    2f6a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    2f6c:	80 e3       	ldi	r24, 0x30	; 48
    2f6e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    2f70:	81 e3       	ldi	r24, 0x31	; 49
    2f72:	82 93       	st	-Z, r24
    2f74:	31 97       	sbiw	r30, 0x01	; 1
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    2f76:	cf 01       	movw	r24, r30
    2f78:	08 95       	ret

00002f7a <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	OCR1AH = ucHighByte;
    2f7a:	10 92 89 00 	sts	0x0089, r1
	OCR1AL = ucLowByte;
    2f7e:	89 ef       	ldi	r24, 0xF9	; 249
    2f80:	80 93 88 00 	sts	0x0088, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    2f84:	8b e0       	ldi	r24, 0x0B	; 11
    2f86:	80 93 81 00 	sts	0x0081, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
    2f8a:	ef e6       	ldi	r30, 0x6F	; 111
    2f8c:	f0 e0       	ldi	r31, 0x00	; 0
    2f8e:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    2f90:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
    2f92:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    2f94:	a0 91 f5 02 	lds	r26, 0x02F5
    2f98:	b0 91 f6 02 	lds	r27, 0x02F6
    2f9c:	cd 91       	ld	r28, X+
    2f9e:	cd bf       	out	0x3d, r28	; 61
    2fa0:	dd 91       	ld	r29, X+
    2fa2:	de bf       	out	0x3e, r29	; 62
    2fa4:	ff 91       	pop	r31
    2fa6:	ef 91       	pop	r30
    2fa8:	df 91       	pop	r29
    2faa:	cf 91       	pop	r28
    2fac:	bf 91       	pop	r27
    2fae:	af 91       	pop	r26
    2fb0:	9f 91       	pop	r25
    2fb2:	8f 91       	pop	r24
    2fb4:	7f 91       	pop	r23
    2fb6:	6f 91       	pop	r22
    2fb8:	5f 91       	pop	r21
    2fba:	4f 91       	pop	r20
    2fbc:	3f 91       	pop	r19
    2fbe:	2f 91       	pop	r18
    2fc0:	1f 91       	pop	r17
    2fc2:	0f 91       	pop	r16
    2fc4:	ff 90       	pop	r15
    2fc6:	ef 90       	pop	r14
    2fc8:	df 90       	pop	r13
    2fca:	cf 90       	pop	r12
    2fcc:	bf 90       	pop	r11
    2fce:	af 90       	pop	r10
    2fd0:	9f 90       	pop	r9
    2fd2:	8f 90       	pop	r8
    2fd4:	7f 90       	pop	r7
    2fd6:	6f 90       	pop	r6
    2fd8:	5f 90       	pop	r5
    2fda:	4f 90       	pop	r4
    2fdc:	3f 90       	pop	r3
    2fde:	2f 90       	pop	r2
    2fe0:	1f 90       	pop	r1
    2fe2:	0f 90       	pop	r0
    2fe4:	0f be       	out	0x3f, r0	; 63
    2fe6:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    2fe8:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    2fea:	81 e0       	ldi	r24, 0x01	; 1
    2fec:	08 95       	ret

00002fee <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    2fee:	08 95       	ret

00002ff0 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2ff0:	0f 92       	push	r0
    2ff2:	0f b6       	in	r0, 0x3f	; 63
    2ff4:	f8 94       	cli
    2ff6:	0f 92       	push	r0
    2ff8:	1f 92       	push	r1
    2ffa:	11 24       	eor	r1, r1
    2ffc:	2f 92       	push	r2
    2ffe:	3f 92       	push	r3
    3000:	4f 92       	push	r4
    3002:	5f 92       	push	r5
    3004:	6f 92       	push	r6
    3006:	7f 92       	push	r7
    3008:	8f 92       	push	r8
    300a:	9f 92       	push	r9
    300c:	af 92       	push	r10
    300e:	bf 92       	push	r11
    3010:	cf 92       	push	r12
    3012:	df 92       	push	r13
    3014:	ef 92       	push	r14
    3016:	ff 92       	push	r15
    3018:	0f 93       	push	r16
    301a:	1f 93       	push	r17
    301c:	2f 93       	push	r18
    301e:	3f 93       	push	r19
    3020:	4f 93       	push	r20
    3022:	5f 93       	push	r21
    3024:	6f 93       	push	r22
    3026:	7f 93       	push	r23
    3028:	8f 93       	push	r24
    302a:	9f 93       	push	r25
    302c:	af 93       	push	r26
    302e:	bf 93       	push	r27
    3030:	cf 93       	push	r28
    3032:	df 93       	push	r29
    3034:	ef 93       	push	r30
    3036:	ff 93       	push	r31
    3038:	a0 91 f5 02 	lds	r26, 0x02F5
    303c:	b0 91 f6 02 	lds	r27, 0x02F6
    3040:	0d b6       	in	r0, 0x3d	; 61
    3042:	0d 92       	st	X+, r0
    3044:	0e b6       	in	r0, 0x3e	; 62
    3046:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    3048:	0e 94 d1 13 	call	0x27a2	; 0x27a2 <vTaskIncrementTick>
	vTaskSwitchContext();
    304c:	0e 94 03 13 	call	0x2606	; 0x2606 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    3050:	a0 91 f5 02 	lds	r26, 0x02F5
    3054:	b0 91 f6 02 	lds	r27, 0x02F6
    3058:	cd 91       	ld	r28, X+
    305a:	cd bf       	out	0x3d, r28	; 61
    305c:	dd 91       	ld	r29, X+
    305e:	de bf       	out	0x3e, r29	; 62
    3060:	ff 91       	pop	r31
    3062:	ef 91       	pop	r30
    3064:	df 91       	pop	r29
    3066:	cf 91       	pop	r28
    3068:	bf 91       	pop	r27
    306a:	af 91       	pop	r26
    306c:	9f 91       	pop	r25
    306e:	8f 91       	pop	r24
    3070:	7f 91       	pop	r23
    3072:	6f 91       	pop	r22
    3074:	5f 91       	pop	r21
    3076:	4f 91       	pop	r20
    3078:	3f 91       	pop	r19
    307a:	2f 91       	pop	r18
    307c:	1f 91       	pop	r17
    307e:	0f 91       	pop	r16
    3080:	ff 90       	pop	r15
    3082:	ef 90       	pop	r14
    3084:	df 90       	pop	r13
    3086:	cf 90       	pop	r12
    3088:	bf 90       	pop	r11
    308a:	af 90       	pop	r10
    308c:	9f 90       	pop	r9
    308e:	8f 90       	pop	r8
    3090:	7f 90       	pop	r7
    3092:	6f 90       	pop	r6
    3094:	5f 90       	pop	r5
    3096:	4f 90       	pop	r4
    3098:	3f 90       	pop	r3
    309a:	2f 90       	pop	r2
    309c:	1f 90       	pop	r1
    309e:	0f 90       	pop	r0
    30a0:	0f be       	out	0x3f, r0	; 63
    30a2:	0f 90       	pop	r0

	asm volatile ( "ret" );
    30a4:	08 95       	ret

000030a6 <__vector_17>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    30a6:	0e 94 f8 17 	call	0x2ff0	; 0x2ff0 <vPortYieldFromTick>
		asm volatile ( "reti" );
    30aa:	18 95       	reti

000030ac <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    30ac:	0f 92       	push	r0
    30ae:	0f b6       	in	r0, 0x3f	; 63
    30b0:	f8 94       	cli
    30b2:	0f 92       	push	r0
    30b4:	1f 92       	push	r1
    30b6:	11 24       	eor	r1, r1
    30b8:	2f 92       	push	r2
    30ba:	3f 92       	push	r3
    30bc:	4f 92       	push	r4
    30be:	5f 92       	push	r5
    30c0:	6f 92       	push	r6
    30c2:	7f 92       	push	r7
    30c4:	8f 92       	push	r8
    30c6:	9f 92       	push	r9
    30c8:	af 92       	push	r10
    30ca:	bf 92       	push	r11
    30cc:	cf 92       	push	r12
    30ce:	df 92       	push	r13
    30d0:	ef 92       	push	r14
    30d2:	ff 92       	push	r15
    30d4:	0f 93       	push	r16
    30d6:	1f 93       	push	r17
    30d8:	2f 93       	push	r18
    30da:	3f 93       	push	r19
    30dc:	4f 93       	push	r20
    30de:	5f 93       	push	r21
    30e0:	6f 93       	push	r22
    30e2:	7f 93       	push	r23
    30e4:	8f 93       	push	r24
    30e6:	9f 93       	push	r25
    30e8:	af 93       	push	r26
    30ea:	bf 93       	push	r27
    30ec:	cf 93       	push	r28
    30ee:	df 93       	push	r29
    30f0:	ef 93       	push	r30
    30f2:	ff 93       	push	r31
    30f4:	a0 91 f5 02 	lds	r26, 0x02F5
    30f8:	b0 91 f6 02 	lds	r27, 0x02F6
    30fc:	0d b6       	in	r0, 0x3d	; 61
    30fe:	0d 92       	st	X+, r0
    3100:	0e b6       	in	r0, 0x3e	; 62
    3102:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    3104:	0e 94 03 13 	call	0x2606	; 0x2606 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    3108:	a0 91 f5 02 	lds	r26, 0x02F5
    310c:	b0 91 f6 02 	lds	r27, 0x02F6
    3110:	cd 91       	ld	r28, X+
    3112:	cd bf       	out	0x3d, r28	; 61
    3114:	dd 91       	ld	r29, X+
    3116:	de bf       	out	0x3e, r29	; 62
    3118:	ff 91       	pop	r31
    311a:	ef 91       	pop	r30
    311c:	df 91       	pop	r29
    311e:	cf 91       	pop	r28
    3120:	bf 91       	pop	r27
    3122:	af 91       	pop	r26
    3124:	9f 91       	pop	r25
    3126:	8f 91       	pop	r24
    3128:	7f 91       	pop	r23
    312a:	6f 91       	pop	r22
    312c:	5f 91       	pop	r21
    312e:	4f 91       	pop	r20
    3130:	3f 91       	pop	r19
    3132:	2f 91       	pop	r18
    3134:	1f 91       	pop	r17
    3136:	0f 91       	pop	r16
    3138:	ff 90       	pop	r15
    313a:	ef 90       	pop	r14
    313c:	df 90       	pop	r13
    313e:	cf 90       	pop	r12
    3140:	bf 90       	pop	r11
    3142:	af 90       	pop	r10
    3144:	9f 90       	pop	r9
    3146:	8f 90       	pop	r8
    3148:	7f 90       	pop	r7
    314a:	6f 90       	pop	r6
    314c:	5f 90       	pop	r5
    314e:	4f 90       	pop	r4
    3150:	3f 90       	pop	r3
    3152:	2f 90       	pop	r2
    3154:	1f 90       	pop	r1
    3156:	0f 90       	pop	r0
    3158:	0f be       	out	0x3f, r0	; 63
    315a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    315c:	08 95       	ret

0000315e <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    315e:	0f 93       	push	r16
    3160:	1f 93       	push	r17
    3162:	cf 93       	push	r28
    3164:	df 93       	push	r29
    3166:	fc 01       	movw	r30, r24
corCRCB *pxUnblockedCRCB;
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    3168:	80 81       	ld	r24, Z
    316a:	88 23       	and	r24, r24
    316c:	19 f4       	brne	.+6      	; 0x3174 <xCoRoutineRemoveFromEventList+0x16>
    316e:	c0 e0       	ldi	r28, 0x00	; 0
    3170:	d0 e0       	ldi	r29, 0x00	; 0
    3172:	05 c0       	rjmp	.+10     	; 0x317e <xCoRoutineRemoveFromEventList+0x20>
    3174:	05 80       	ldd	r0, Z+5	; 0x05
    3176:	f6 81       	ldd	r31, Z+6	; 0x06
    3178:	e0 2d       	mov	r30, r0
    317a:	c6 81       	ldd	r28, Z+6	; 0x06
    317c:	d7 81       	ldd	r29, Z+7	; 0x07
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    317e:	8e 01       	movw	r16, r28
    3180:	04 5f       	subi	r16, 0xF4	; 244
    3182:	1f 4f       	sbci	r17, 0xFF	; 255
    3184:	c8 01       	movw	r24, r16
    3186:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    318a:	80 e8       	ldi	r24, 0x80	; 128
    318c:	93 e0       	ldi	r25, 0x03	; 3
    318e:	b8 01       	movw	r22, r16
    3190:	0e 94 7e 0f 	call	0x1efc	; 0x1efc <vListInsertEnd>
    3194:	20 e0       	ldi	r18, 0x00	; 0
    3196:	e0 91 4f 03 	lds	r30, 0x034F
    319a:	f0 91 50 03 	lds	r31, 0x0350
    319e:	9e 89       	ldd	r25, Y+22	; 0x16
    31a0:	86 89       	ldd	r24, Z+22	; 0x16
    31a2:	98 17       	cp	r25, r24
    31a4:	08 f0       	brcs	.+2      	; 0x31a8 <xCoRoutineRemoveFromEventList+0x4a>
    31a6:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    31a8:	82 2f       	mov	r24, r18
    31aa:	df 91       	pop	r29
    31ac:	cf 91       	pop	r28
    31ae:	1f 91       	pop	r17
    31b0:	0f 91       	pop	r16
    31b2:	08 95       	ret

000031b4 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    31b4:	ff 92       	push	r15
    31b6:	0f 93       	push	r16
    31b8:	1f 93       	push	r17
    31ba:	cf 93       	push	r28
    31bc:	df 93       	push	r29
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    31be:	99 e0       	ldi	r25, 0x09	; 9
    31c0:	f9 2e       	mov	r15, r25
    31c2:	28 c0       	rjmp	.+80     	; 0x3214 <vCoRoutineSchedule+0x60>
	while( !listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    31c4:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    31c6:	80 91 80 03 	lds	r24, 0x0380
    31ca:	88 23       	and	r24, r24
    31cc:	19 f4       	brne	.+6      	; 0x31d4 <vCoRoutineSchedule+0x20>
    31ce:	c0 e0       	ldi	r28, 0x00	; 0
    31d0:	d0 e0       	ldi	r29, 0x00	; 0
    31d2:	06 c0       	rjmp	.+12     	; 0x31e0 <vCoRoutineSchedule+0x2c>
    31d4:	e0 91 85 03 	lds	r30, 0x0385
    31d8:	f0 91 86 03 	lds	r31, 0x0386
    31dc:	c6 81       	ldd	r28, Z+6	; 0x06
    31de:	d7 81       	ldd	r29, Z+7	; 0x07
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    31e0:	ce 01       	movw	r24, r28
    31e2:	0c 96       	adiw	r24, 0x0c	; 12
    31e4:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <vListRemove>
		}
		portENABLE_INTERRUPTS();
    31e8:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    31ea:	8e 01       	movw	r16, r28
    31ec:	0e 5f       	subi	r16, 0xFE	; 254
    31ee:	1f 4f       	sbci	r17, 0xFF	; 255
    31f0:	c8 01       	movw	r24, r16
    31f2:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    31f6:	9e 89       	ldd	r25, Y+22	; 0x16
    31f8:	80 91 51 03 	lds	r24, 0x0351
    31fc:	89 17       	cp	r24, r25
    31fe:	10 f4       	brcc	.+4      	; 0x3204 <vCoRoutineSchedule+0x50>
    3200:	90 93 51 03 	sts	0x0351, r25
    3204:	9f 9d       	mul	r25, r15
    3206:	c0 01       	movw	r24, r0
    3208:	11 24       	eor	r1, r1
    320a:	88 5a       	subi	r24, 0xA8	; 168
    320c:	9c 4f       	sbci	r25, 0xFC	; 252
    320e:	b8 01       	movw	r22, r16
    3210:	0e 94 7e 0f 	call	0x1efc	; 0x1efc <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( !listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) )
    3214:	80 91 80 03 	lds	r24, 0x0380
    3218:	88 23       	and	r24, r24
    321a:	a1 f6       	brne	.-88     	; 0x31c4 <vCoRoutineSchedule+0x10>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    321c:	0e 94 ef 12 	call	0x25de	; 0x25de <xTaskGetTickCount>
    3220:	20 91 52 03 	lds	r18, 0x0352
    3224:	30 91 53 03 	lds	r19, 0x0353
    3228:	82 1b       	sub	r24, r18
    322a:	93 0b       	sbc	r25, r19
    322c:	90 93 55 03 	sts	0x0355, r25
    3230:	80 93 54 03 	sts	0x0354, r24
					vListRemove( &( pxCRCB->xEventListItem ) );											
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    3234:	89 e0       	ldi	r24, 0x09	; 9
    3236:	f8 2e       	mov	r15, r24
    3238:	54 c0       	rjmp	.+168    	; 0x32e2 <vCoRoutineSchedule+0x12e>
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    323a:	01 96       	adiw	r24, 0x01	; 1
    323c:	90 93 57 03 	sts	0x0357, r25
    3240:	80 93 56 03 	sts	0x0356, r24
		xPassedTicks--;
    3244:	21 50       	subi	r18, 0x01	; 1
    3246:	30 40       	sbci	r19, 0x00	; 0
    3248:	30 93 55 03 	sts	0x0355, r19
    324c:	20 93 54 03 	sts	0x0354, r18

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    3250:	89 2b       	or	r24, r25
    3252:	c9 f5       	brne	.+114    	; 0x32c6 <vCoRoutineSchedule+0x112>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    3254:	20 91 7c 03 	lds	r18, 0x037C
    3258:	30 91 7d 03 	lds	r19, 0x037D
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    325c:	80 91 7e 03 	lds	r24, 0x037E
    3260:	90 91 7f 03 	lds	r25, 0x037F
    3264:	90 93 7d 03 	sts	0x037D, r25
    3268:	80 93 7c 03 	sts	0x037C, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    326c:	30 93 7f 03 	sts	0x037F, r19
    3270:	20 93 7e 03 	sts	0x037E, r18
    3274:	28 c0       	rjmp	.+80     	; 0x32c6 <vCoRoutineSchedule+0x112>
		}

		/* See if this tick has made a timeout expire. */
		while( ( pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList ) ) != NULL )
		{	
			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    3276:	20 91 56 03 	lds	r18, 0x0356
    327a:	30 91 57 03 	lds	r19, 0x0357
    327e:	8a 81       	ldd	r24, Y+2	; 0x02
    3280:	9b 81       	ldd	r25, Y+3	; 0x03
    3282:	28 17       	cp	r18, r24
    3284:	39 07       	cpc	r19, r25
    3286:	68 f1       	brcs	.+90     	; 0x32e2 <vCoRoutineSchedule+0x12e>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    3288:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    328a:	8e 01       	movw	r16, r28
    328c:	0e 5f       	subi	r16, 0xFE	; 254
    328e:	1f 4f       	sbci	r17, 0xFF	; 255
    3290:	c8 01       	movw	r24, r16
    3292:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    3296:	8c 89       	ldd	r24, Y+20	; 0x14
    3298:	9d 89       	ldd	r25, Y+21	; 0x15
    329a:	89 2b       	or	r24, r25
    329c:	21 f0       	breq	.+8      	; 0x32a6 <vCoRoutineSchedule+0xf2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    329e:	ce 01       	movw	r24, r28
    32a0:	0c 96       	adiw	r24, 0x0c	; 12
    32a2:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    32a6:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    32a8:	9e 89       	ldd	r25, Y+22	; 0x16
    32aa:	80 91 51 03 	lds	r24, 0x0351
    32ae:	89 17       	cp	r24, r25
    32b0:	10 f4       	brcc	.+4      	; 0x32b6 <vCoRoutineSchedule+0x102>
    32b2:	90 93 51 03 	sts	0x0351, r25
    32b6:	9f 9d       	mul	r25, r15
    32b8:	c0 01       	movw	r24, r0
    32ba:	11 24       	eor	r1, r1
    32bc:	88 5a       	subi	r24, 0xA8	; 168
    32be:	9c 4f       	sbci	r25, 0xFC	; 252
    32c0:	b8 01       	movw	r22, r16
    32c2:	0e 94 7e 0f 	call	0x1efc	; 0x1efc <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( ( pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList ) ) != NULL )
    32c6:	e0 91 7c 03 	lds	r30, 0x037C
    32ca:	f0 91 7d 03 	lds	r31, 0x037D
    32ce:	80 81       	ld	r24, Z
    32d0:	88 23       	and	r24, r24
    32d2:	39 f0       	breq	.+14     	; 0x32e2 <vCoRoutineSchedule+0x12e>
    32d4:	05 80       	ldd	r0, Z+5	; 0x05
    32d6:	f6 81       	ldd	r31, Z+6	; 0x06
    32d8:	e0 2d       	mov	r30, r0
    32da:	c6 81       	ldd	r28, Z+6	; 0x06
    32dc:	d7 81       	ldd	r29, Z+7	; 0x07
    32de:	20 97       	sbiw	r28, 0x00	; 0
    32e0:	51 f6       	brne	.-108    	; 0x3276 <vCoRoutineSchedule+0xc2>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    32e2:	20 91 54 03 	lds	r18, 0x0354
    32e6:	30 91 55 03 	lds	r19, 0x0355
    32ea:	80 91 56 03 	lds	r24, 0x0356
    32ee:	90 91 57 03 	lds	r25, 0x0357
    32f2:	21 15       	cp	r18, r1
    32f4:	31 05       	cpc	r19, r1
    32f6:	09 f0       	breq	.+2      	; 0x32fa <vCoRoutineSchedule+0x146>
    32f8:	a0 cf       	rjmp	.-192    	; 0x323a <vCoRoutineSchedule+0x86>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    32fa:	90 93 53 03 	sts	0x0353, r25
    32fe:	80 93 52 03 	sts	0x0352, r24
    3302:	90 91 51 03 	lds	r25, 0x0351

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    3306:	29 e0       	ldi	r18, 0x09	; 9
    3308:	06 c0       	rjmp	.+12     	; 0x3316 <vCoRoutineSchedule+0x162>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    330a:	99 23       	and	r25, r25
    330c:	19 f4       	brne	.+6      	; 0x3314 <vCoRoutineSchedule+0x160>
    330e:	10 92 51 03 	sts	0x0351, r1
    3312:	32 c0       	rjmp	.+100    	; 0x3378 <vCoRoutineSchedule+0x1c4>
    3314:	91 50       	subi	r25, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    3316:	92 9f       	mul	r25, r18
    3318:	d0 01       	movw	r26, r0
    331a:	11 24       	eor	r1, r1
    331c:	a8 5a       	subi	r26, 0xA8	; 168
    331e:	bc 4f       	sbci	r27, 0xFC	; 252
    3320:	8c 91       	ld	r24, X
    3322:	88 23       	and	r24, r24
    3324:	91 f3       	breq	.-28     	; 0x330a <vCoRoutineSchedule+0x156>
    3326:	90 93 51 03 	sts	0x0351, r25
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    332a:	11 96       	adiw	r26, 0x01	; 1
    332c:	ed 91       	ld	r30, X+
    332e:	fc 91       	ld	r31, X
    3330:	12 97       	sbiw	r26, 0x02	; 2
    3332:	02 80       	ldd	r0, Z+2	; 0x02
    3334:	f3 81       	ldd	r31, Z+3	; 0x03
    3336:	e0 2d       	mov	r30, r0
    3338:	12 96       	adiw	r26, 0x02	; 2
    333a:	fc 93       	st	X, r31
    333c:	ee 93       	st	-X, r30
    333e:	11 97       	sbiw	r26, 0x01	; 1
    3340:	cd 01       	movw	r24, r26
    3342:	03 96       	adiw	r24, 0x03	; 3
    3344:	e8 17       	cp	r30, r24
    3346:	f9 07       	cpc	r31, r25
    3348:	31 f4       	brne	.+12     	; 0x3356 <vCoRoutineSchedule+0x1a2>
    334a:	82 81       	ldd	r24, Z+2	; 0x02
    334c:	93 81       	ldd	r25, Z+3	; 0x03
    334e:	12 96       	adiw	r26, 0x02	; 2
    3350:	9c 93       	st	X, r25
    3352:	8e 93       	st	-X, r24
    3354:	11 97       	sbiw	r26, 0x01	; 1
    3356:	11 96       	adiw	r26, 0x01	; 1
    3358:	ed 91       	ld	r30, X+
    335a:	fc 91       	ld	r31, X
    335c:	12 97       	sbiw	r26, 0x02	; 2
    335e:	06 80       	ldd	r0, Z+6	; 0x06
    3360:	f7 81       	ldd	r31, Z+7	; 0x07
    3362:	e0 2d       	mov	r30, r0
    3364:	f0 93 50 03 	sts	0x0350, r31
    3368:	e0 93 4f 03 	sts	0x034F, r30

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    336c:	20 81       	ld	r18, Z
    336e:	31 81       	ldd	r19, Z+1	; 0x01
    3370:	cf 01       	movw	r24, r30
    3372:	67 89       	ldd	r22, Z+23	; 0x17
    3374:	f9 01       	movw	r30, r18
    3376:	09 95       	icall

	return;
}
    3378:	df 91       	pop	r29
    337a:	cf 91       	pop	r28
    337c:	1f 91       	pop	r17
    337e:	0f 91       	pop	r16
    3380:	ff 90       	pop	r15
    3382:	08 95       	ret

00003384 <vCoRoutineAddToDelayedList>:
	return xReturn;	
}
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    3384:	0f 93       	push	r16
    3386:	1f 93       	push	r17
    3388:	cf 93       	push	r28
    338a:	df 93       	push	r29
    338c:	eb 01       	movw	r28, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    338e:	00 91 56 03 	lds	r16, 0x0356
    3392:	10 91 57 03 	lds	r17, 0x0357
    3396:	08 0f       	add	r16, r24
    3398:	19 1f       	adc	r17, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    339a:	80 91 4f 03 	lds	r24, 0x034F
    339e:	90 91 50 03 	lds	r25, 0x0350
    33a2:	02 96       	adiw	r24, 0x02	; 2
    33a4:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    33a8:	e0 91 4f 03 	lds	r30, 0x034F
    33ac:	f0 91 50 03 	lds	r31, 0x0350
    33b0:	13 83       	std	Z+3, r17	; 0x03
    33b2:	02 83       	std	Z+2, r16	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    33b4:	80 91 56 03 	lds	r24, 0x0356
    33b8:	90 91 57 03 	lds	r25, 0x0357
    33bc:	bf 01       	movw	r22, r30
    33be:	6e 5f       	subi	r22, 0xFE	; 254
    33c0:	7f 4f       	sbci	r23, 0xFF	; 255
    33c2:	08 17       	cp	r16, r24
    33c4:	19 07       	cpc	r17, r25
    33c6:	28 f4       	brcc	.+10     	; 0x33d2 <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    33c8:	80 91 7e 03 	lds	r24, 0x037E
    33cc:	90 91 7f 03 	lds	r25, 0x037F
    33d0:	04 c0       	rjmp	.+8      	; 0x33da <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    33d2:	80 91 7c 03 	lds	r24, 0x037C
    33d6:	90 91 7d 03 	lds	r25, 0x037D
    33da:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <vListInsert>
	}

	if( pxEventList )
    33de:	20 97       	sbiw	r28, 0x00	; 0
    33e0:	49 f0       	breq	.+18     	; 0x33f4 <vCoRoutineAddToDelayedList+0x70>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    33e2:	60 91 4f 03 	lds	r22, 0x034F
    33e6:	70 91 50 03 	lds	r23, 0x0350
    33ea:	64 5f       	subi	r22, 0xF4	; 244
    33ec:	7f 4f       	sbci	r23, 0xFF	; 255
    33ee:	ce 01       	movw	r24, r28
    33f0:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <vListInsert>
	}
}
    33f4:	df 91       	pop	r29
    33f6:	cf 91       	pop	r28
    33f8:	1f 91       	pop	r17
    33fa:	0f 91       	pop	r16
    33fc:	08 95       	ret

000033fe <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    33fe:	af 92       	push	r10
    3400:	bf 92       	push	r11
    3402:	cf 92       	push	r12
    3404:	df 92       	push	r13
    3406:	ef 92       	push	r14
    3408:	ff 92       	push	r15
    340a:	0f 93       	push	r16
    340c:	1f 93       	push	r17
    340e:	cf 93       	push	r28
    3410:	df 93       	push	r29
    3412:	6c 01       	movw	r12, r24
    3414:	b6 2e       	mov	r11, r22
    3416:	a4 2e       	mov	r10, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    3418:	8a e1       	ldi	r24, 0x1A	; 26
    341a:	90 e0       	ldi	r25, 0x00	; 0
    341c:	0e 94 89 1a 	call	0x3512	; 0x3512 <pvPortMalloc>
    3420:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
    3422:	00 97       	sbiw	r24, 0x00	; 0
    3424:	11 f4       	brne	.+4      	; 0x342a <xCoRoutineCreate+0x2c>
    3426:	8f ef       	ldi	r24, 0xFF	; 255
    3428:	59 c0       	rjmp	.+178    	; 0x34dc <xCoRoutineCreate+0xde>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    342a:	80 91 4f 03 	lds	r24, 0x034F
    342e:	90 91 50 03 	lds	r25, 0x0350
    3432:	89 2b       	or	r24, r25
    3434:	21 f5       	brne	.+72     	; 0x347e <xCoRoutineCreate+0x80>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    3436:	d0 93 50 03 	sts	0x0350, r29
    343a:	c0 93 4f 03 	sts	0x034F, r28
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    343e:	88 e5       	ldi	r24, 0x58	; 88
    3440:	93 e0       	ldi	r25, 0x03	; 3
    3442:	0e 94 6a 0f 	call	0x1ed4	; 0x1ed4 <vListInitialise>
    3446:	81 e6       	ldi	r24, 0x61	; 97
    3448:	93 e0       	ldi	r25, 0x03	; 3
    344a:	0e 94 6a 0f 	call	0x1ed4	; 0x1ed4 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    344e:	2a e6       	ldi	r18, 0x6A	; 106
    3450:	e2 2e       	mov	r14, r18
    3452:	23 e0       	ldi	r18, 0x03	; 3
    3454:	f2 2e       	mov	r15, r18
    3456:	c7 01       	movw	r24, r14
    3458:	0e 94 6a 0f 	call	0x1ed4	; 0x1ed4 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    345c:	03 e7       	ldi	r16, 0x73	; 115
    345e:	13 e0       	ldi	r17, 0x03	; 3
    3460:	c8 01       	movw	r24, r16
    3462:	0e 94 6a 0f 	call	0x1ed4	; 0x1ed4 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    3466:	80 e8       	ldi	r24, 0x80	; 128
    3468:	93 e0       	ldi	r25, 0x03	; 3
    346a:	0e 94 6a 0f 	call	0x1ed4	; 0x1ed4 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    346e:	f0 92 7d 03 	sts	0x037D, r15
    3472:	e0 92 7c 03 	sts	0x037C, r14
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    3476:	10 93 7f 03 	sts	0x037F, r17
    347a:	00 93 7e 03 	sts	0x037E, r16
    347e:	eb 2c       	mov	r14, r11
    3480:	bb 20       	and	r11, r11
    3482:	11 f0       	breq	.+4      	; 0x3488 <xCoRoutineCreate+0x8a>
    3484:	ee 24       	eor	r14, r14
    3486:	e3 94       	inc	r14
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    3488:	19 8e       	std	Y+25, r1	; 0x19
    348a:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    348c:	ee 8a       	std	Y+22, r14	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    348e:	af 8a       	std	Y+23, r10	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    3490:	fe 01       	movw	r30, r28
    3492:	c1 92       	st	Z+, r12
    3494:	d1 92       	st	Z+, r13
    3496:	8f 01       	movw	r16, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    3498:	cf 01       	movw	r24, r30
    349a:	0e 94 7a 0f 	call	0x1ef4	; 0x1ef4 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    349e:	ce 01       	movw	r24, r28
    34a0:	0c 96       	adiw	r24, 0x0c	; 12
    34a2:	0e 94 7a 0f 	call	0x1ef4	; 0x1ef4 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    34a6:	d9 87       	std	Y+9, r29	; 0x09
    34a8:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    34aa:	db 8b       	std	Y+19, r29	; 0x13
    34ac:	ca 8b       	std	Y+18, r28	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    34ae:	84 e0       	ldi	r24, 0x04	; 4
    34b0:	90 e0       	ldi	r25, 0x00	; 0
    34b2:	8e 19       	sub	r24, r14
    34b4:	91 09       	sbc	r25, r1
    34b6:	9d 87       	std	Y+13, r25	; 0x0d
    34b8:	8c 87       	std	Y+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    34ba:	9e 89       	ldd	r25, Y+22	; 0x16
    34bc:	80 91 51 03 	lds	r24, 0x0351
    34c0:	89 17       	cp	r24, r25
    34c2:	10 f4       	brcc	.+4      	; 0x34c8 <xCoRoutineCreate+0xca>
    34c4:	90 93 51 03 	sts	0x0351, r25
    34c8:	89 e0       	ldi	r24, 0x09	; 9
    34ca:	98 9f       	mul	r25, r24
    34cc:	c0 01       	movw	r24, r0
    34ce:	11 24       	eor	r1, r1
    34d0:	88 5a       	subi	r24, 0xA8	; 168
    34d2:	9c 4f       	sbci	r25, 0xFC	; 252
    34d4:	b8 01       	movw	r22, r16
    34d6:	0e 94 7e 0f 	call	0x1efc	; 0x1efc <vListInsertEnd>
    34da:	81 e0       	ldi	r24, 0x01	; 1
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
	}
	
	return xReturn;	
}
    34dc:	df 91       	pop	r29
    34de:	cf 91       	pop	r28
    34e0:	1f 91       	pop	r17
    34e2:	0f 91       	pop	r16
    34e4:	ff 90       	pop	r15
    34e6:	ef 90       	pop	r14
    34e8:	df 90       	pop	r13
    34ea:	cf 90       	pop	r12
    34ec:	bf 90       	pop	r11
    34ee:	af 90       	pop	r10
    34f0:	08 95       	ret

000034f2 <vPortFree>:
{
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    34f2:	08 95       	ret

000034f4 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    34f4:	10 92 8a 03 	sts	0x038A, r1
    34f8:	10 92 89 03 	sts	0x0389, r1
}
    34fc:	08 95       	ret

000034fe <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    34fe:	28 eb       	ldi	r18, 0xB8	; 184
    3500:	3b e0       	ldi	r19, 0x0B	; 11
    3502:	80 91 89 03 	lds	r24, 0x0389
    3506:	90 91 8a 03 	lds	r25, 0x038A
    350a:	28 1b       	sub	r18, r24
    350c:	39 0b       	sbc	r19, r25
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
}
    350e:	c9 01       	movw	r24, r18
    3510:	08 95       	ret

00003512 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    3512:	0f 93       	push	r16
    3514:	1f 93       	push	r17
    3516:	cf 93       	push	r28
    3518:	df 93       	push	r29
    351a:	8c 01       	movw	r16, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    351c:	0e 94 e9 12 	call	0x25d2	; 0x25d2 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    3520:	80 91 89 03 	lds	r24, 0x0389
    3524:	90 91 8a 03 	lds	r25, 0x038A
    3528:	98 01       	movw	r18, r16
    352a:	28 0f       	add	r18, r24
    352c:	39 1f       	adc	r19, r25
    352e:	4b e0       	ldi	r20, 0x0B	; 11
    3530:	28 3b       	cpi	r18, 0xB8	; 184
    3532:	34 07       	cpc	r19, r20
    3534:	58 f4       	brcc	.+22     	; 0x354c <pvPortMalloc+0x3a>
    3536:	82 17       	cp	r24, r18
    3538:	93 07       	cpc	r25, r19
    353a:	40 f4       	brcc	.+16     	; 0x354c <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    353c:	ec 01       	movw	r28, r24
    353e:	c5 57       	subi	r28, 0x75	; 117
    3540:	dc 4f       	sbci	r29, 0xFC	; 252
			xNextFreeByte += xWantedSize;			
    3542:	30 93 8a 03 	sts	0x038A, r19
    3546:	20 93 89 03 	sts	0x0389, r18
    354a:	02 c0       	rjmp	.+4      	; 0x3550 <pvPortMalloc+0x3e>
    354c:	c0 e0       	ldi	r28, 0x00	; 0
    354e:	d0 e0       	ldi	r29, 0x00	; 0
		}	
	}
	xTaskResumeAll();
    3550:	0e 94 80 14 	call	0x2900	; 0x2900 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
    3554:	ce 01       	movw	r24, r28
    3556:	df 91       	pop	r29
    3558:	cf 91       	pop	r28
    355a:	1f 91       	pop	r17
    355c:	0f 91       	pop	r16
    355e:	08 95       	ret

00003560 <prescaler_hex_to_value>:
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    3560:	e8 2f       	mov	r30, r24
    3562:	f0 e0       	ldi	r31, 0x00	; 0
    3564:	e7 70       	andi	r30, 0x07	; 7
    3566:	f0 70       	andi	r31, 0x00	; 0
    3568:	ee 0f       	add	r30, r30
    356a:	ff 1f       	adc	r31, r31
    356c:	e9 54       	subi	r30, 0x49	; 73
    356e:	fe 4f       	sbci	r31, 0xFE	; 254
    3570:	25 91       	lpm	r18, Z+
    3572:	34 91       	lpm	r19, Z+
}
    3574:	c9 01       	movw	r24, r18
    3576:	08 95       	ret

00003578 <prescaler_hex_to_value_for_timer2>:
uint16_t prescaler_hex_to_value_for_timer2(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to Timer2PrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(Timer2PrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    3578:	e8 2f       	mov	r30, r24
    357a:	f0 e0       	ldi	r31, 0x00	; 0
    357c:	e7 70       	andi	r30, 0x07	; 7
    357e:	f0 70       	andi	r31, 0x00	; 0
    3580:	ee 0f       	add	r30, r30
    3582:	ff 1f       	adc	r31, r31
    3584:	ed 53       	subi	r30, 0x3D	; 61
    3586:	fe 4f       	sbci	r31, 0xFE	; 254
    3588:	25 91       	lpm	r18, Z+
    358a:	34 91       	lpm	r19, Z+
}
    358c:	c9 01       	movw	r24, r18
    358e:	08 95       	ret

00003590 <get_timer0_prescaler>:

uint16_t get_timer0_prescaler(void)
{
  return prescaler_hex_to_value(TCCR0B);
    3590:	85 b5       	in	r24, 0x25	; 37
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    3592:	e8 2f       	mov	r30, r24
    3594:	f0 e0       	ldi	r31, 0x00	; 0
    3596:	e7 70       	andi	r30, 0x07	; 7
    3598:	f0 70       	andi	r31, 0x00	; 0
    359a:	ee 0f       	add	r30, r30
    359c:	ff 1f       	adc	r31, r31
    359e:	e9 54       	subi	r30, 0x49	; 73
    35a0:	fe 4f       	sbci	r31, 0xFE	; 254
    35a2:	25 91       	lpm	r18, Z+
    35a4:	34 91       	lpm	r19, Z+
}

uint16_t get_timer0_prescaler(void)
{
  return prescaler_hex_to_value(TCCR0B);
}
    35a6:	c9 01       	movw	r24, r18
    35a8:	08 95       	ret

000035aa <get_timer1_prescaler>:
uint16_t get_timer1_prescaler(void)
{
  return prescaler_hex_to_value(TCCR1B);
    35aa:	80 91 81 00 	lds	r24, 0x0081
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    35ae:	e8 2f       	mov	r30, r24
    35b0:	f0 e0       	ldi	r31, 0x00	; 0
    35b2:	e7 70       	andi	r30, 0x07	; 7
    35b4:	f0 70       	andi	r31, 0x00	; 0
    35b6:	ee 0f       	add	r30, r30
    35b8:	ff 1f       	adc	r31, r31
    35ba:	e9 54       	subi	r30, 0x49	; 73
    35bc:	fe 4f       	sbci	r31, 0xFE	; 254
    35be:	25 91       	lpm	r18, Z+
    35c0:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR0B);
}
uint16_t get_timer1_prescaler(void)
{
  return prescaler_hex_to_value(TCCR1B);
}
    35c2:	c9 01       	movw	r24, r18
    35c4:	08 95       	ret

000035c6 <get_timer2_prescaler>:
uint16_t get_timer2_prescaler(void)
{
  return prescaler_hex_to_value_for_timer2(TCCR2B);
    35c6:	80 91 b1 00 	lds	r24, 0x00B1
uint16_t prescaler_hex_to_value_for_timer2(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to Timer2PrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(Timer2PrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    35ca:	e8 2f       	mov	r30, r24
    35cc:	f0 e0       	ldi	r31, 0x00	; 0
    35ce:	e7 70       	andi	r30, 0x07	; 7
    35d0:	f0 70       	andi	r31, 0x00	; 0
    35d2:	ee 0f       	add	r30, r30
    35d4:	ff 1f       	adc	r31, r31
    35d6:	ed 53       	subi	r30, 0x3D	; 61
    35d8:	fe 4f       	sbci	r31, 0xFE	; 254
    35da:	25 91       	lpm	r18, Z+
    35dc:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR1B);
}
uint16_t get_timer2_prescaler(void)
{
  return prescaler_hex_to_value_for_timer2(TCCR2B);
}
    35de:	c9 01       	movw	r24, r18
    35e0:	08 95       	ret

000035e2 <get_timer3_prescaler>:
uint16_t get_timer3_prescaler(void)
{
  return prescaler_hex_to_value(TCCR3B);
    35e2:	80 91 91 00 	lds	r24, 0x0091
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    35e6:	e8 2f       	mov	r30, r24
    35e8:	f0 e0       	ldi	r31, 0x00	; 0
    35ea:	e7 70       	andi	r30, 0x07	; 7
    35ec:	f0 70       	andi	r31, 0x00	; 0
    35ee:	ee 0f       	add	r30, r30
    35f0:	ff 1f       	adc	r31, r31
    35f2:	e9 54       	subi	r30, 0x49	; 73
    35f4:	fe 4f       	sbci	r31, 0xFE	; 254
    35f6:	25 91       	lpm	r18, Z+
    35f8:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value_for_timer2(TCCR2B);
}
uint16_t get_timer3_prescaler(void)
{
  return prescaler_hex_to_value(TCCR3B);
}
    35fa:	c9 01       	movw	r24, r18
    35fc:	08 95       	ret

000035fe <get_timer4_prescaler>:
uint16_t get_timer4_prescaler(void)
{
  return prescaler_hex_to_value(TCCR4B);
    35fe:	80 91 a1 00 	lds	r24, 0x00A1
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    3602:	e8 2f       	mov	r30, r24
    3604:	f0 e0       	ldi	r31, 0x00	; 0
    3606:	e7 70       	andi	r30, 0x07	; 7
    3608:	f0 70       	andi	r31, 0x00	; 0
    360a:	ee 0f       	add	r30, r30
    360c:	ff 1f       	adc	r31, r31
    360e:	e9 54       	subi	r30, 0x49	; 73
    3610:	fe 4f       	sbci	r31, 0xFE	; 254
    3612:	25 91       	lpm	r18, Z+
    3614:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR3B);
}
uint16_t get_timer4_prescaler(void)
{
  return prescaler_hex_to_value(TCCR4B);
}
    3616:	c9 01       	movw	r24, r18
    3618:	08 95       	ret

0000361a <get_timer5_prescaler>:
uint16_t get_timer5_prescaler(void)
{
  return prescaler_hex_to_value(TCCR5B);
    361a:	80 91 21 01 	lds	r24, 0x0121
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    361e:	e8 2f       	mov	r30, r24
    3620:	f0 e0       	ldi	r31, 0x00	; 0
    3622:	e7 70       	andi	r30, 0x07	; 7
    3624:	f0 70       	andi	r31, 0x00	; 0
    3626:	ee 0f       	add	r30, r30
    3628:	ff 1f       	adc	r31, r31
    362a:	e9 54       	subi	r30, 0x49	; 73
    362c:	fe 4f       	sbci	r31, 0xFE	; 254
    362e:	25 91       	lpm	r18, Z+
    3630:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR4B);
}
uint16_t get_timer5_prescaler(void)
{
  return prescaler_hex_to_value(TCCR5B);
}
    3632:	c9 01       	movw	r24, r18
    3634:	08 95       	ret

00003636 <get_timer0_overflow>:

const uint32_t get_timer0_overflow(void)
{
    return timer0_ovrflow_cnt;
    3636:	20 91 25 12 	lds	r18, 0x1225
    363a:	30 91 26 12 	lds	r19, 0x1226
    363e:	40 91 27 12 	lds	r20, 0x1227
    3642:	50 91 28 12 	lds	r21, 0x1228
}
    3646:	b9 01       	movw	r22, r18
    3648:	ca 01       	movw	r24, r20
    364a:	08 95       	ret

0000364c <get_timer1_overflow>:
const uint32_t get_timer1_overflow(void)
{
    return timer1_ovrflow_cnt;
    364c:	20 91 21 12 	lds	r18, 0x1221
    3650:	30 91 22 12 	lds	r19, 0x1222
    3654:	40 91 23 12 	lds	r20, 0x1223
    3658:	50 91 24 12 	lds	r21, 0x1224
}
    365c:	b9 01       	movw	r22, r18
    365e:	ca 01       	movw	r24, r20
    3660:	08 95       	ret

00003662 <get_timer2_overflow>:
const uint32_t get_timer2_overflow(void)
{
    return timer2_ovrflow_cnt;
    3662:	20 91 29 12 	lds	r18, 0x1229
    3666:	30 91 2a 12 	lds	r19, 0x122A
    366a:	40 91 2b 12 	lds	r20, 0x122B
    366e:	50 91 2c 12 	lds	r21, 0x122C
}
    3672:	b9 01       	movw	r22, r18
    3674:	ca 01       	movw	r24, r20
    3676:	08 95       	ret

00003678 <get_timer3_overflow>:
const uint32_t get_timer3_overflow(void)
{
    return timer3_ovrflow_cnt;
    3678:	20 91 31 12 	lds	r18, 0x1231
    367c:	30 91 32 12 	lds	r19, 0x1232
    3680:	40 91 33 12 	lds	r20, 0x1233
    3684:	50 91 34 12 	lds	r21, 0x1234
}
    3688:	b9 01       	movw	r22, r18
    368a:	ca 01       	movw	r24, r20
    368c:	08 95       	ret

0000368e <get_timer4_overflow>:
const uint32_t get_timer4_overflow(void)
{
    return timer4_ovrflow_cnt;
    368e:	20 91 1d 12 	lds	r18, 0x121D
    3692:	30 91 1e 12 	lds	r19, 0x121E
    3696:	40 91 1f 12 	lds	r20, 0x121F
    369a:	50 91 20 12 	lds	r21, 0x1220
}
    369e:	b9 01       	movw	r22, r18
    36a0:	ca 01       	movw	r24, r20
    36a2:	08 95       	ret

000036a4 <get_timer5_overflow>:
const uint32_t get_timer5_overflow(void)
{
    return timer5_ovrflow_cnt;
    36a4:	20 91 35 12 	lds	r18, 0x1235
    36a8:	30 91 36 12 	lds	r19, 0x1236
    36ac:	40 91 37 12 	lds	r20, 0x1237
    36b0:	50 91 38 12 	lds	r21, 0x1238
}
    36b4:	b9 01       	movw	r22, r18
    36b6:	ca 01       	movw	r24, r20
    36b8:	08 95       	ret

000036ba <get_timer0_counter>:

const uint8_t get_timer0_counter(void)
{
    return TCNT0;
    36ba:	86 b5       	in	r24, 0x26	; 38
}
    36bc:	08 95       	ret

000036be <get_timer1_counter>:
const uint16_t get_timer1_counter(void)
{
    return TCNT1;
    36be:	20 91 84 00 	lds	r18, 0x0084
    36c2:	30 91 85 00 	lds	r19, 0x0085
}
    36c6:	c9 01       	movw	r24, r18
    36c8:	08 95       	ret

000036ca <get_timer2_counter>:
const uint8_t get_timer2_counter(void)
{
    return TCNT2;
    36ca:	80 91 b2 00 	lds	r24, 0x00B2
}
    36ce:	08 95       	ret

000036d0 <get_timer3_counter>:
const uint16_t get_timer3_counter(void)
{
    return TCNT3;
    36d0:	20 91 94 00 	lds	r18, 0x0094
    36d4:	30 91 95 00 	lds	r19, 0x0095
}
    36d8:	c9 01       	movw	r24, r18
    36da:	08 95       	ret

000036dc <get_timer4_counter>:
const uint16_t get_timer4_counter(void)
{
    return TCNT4;
    36dc:	20 91 a4 00 	lds	r18, 0x00A4
    36e0:	30 91 a5 00 	lds	r19, 0x00A5
}
    36e4:	c9 01       	movw	r24, r18
    36e6:	08 95       	ret

000036e8 <get_timer5_counter>:
const uint16_t get_timer5_counter(void)
{
    return TCNT5;
    36e8:	20 91 24 01 	lds	r18, 0x0124
    36ec:	30 91 25 01 	lds	r19, 0x0125
}
    36f0:	c9 01       	movw	r24, r18
    36f2:	08 95       	ret

000036f4 <reset_timer0>:

void reset_timer0(void)
{
    TCNT0 = timer0_ovrflow_cnt = 0;
    36f4:	10 92 25 12 	sts	0x1225, r1
    36f8:	10 92 26 12 	sts	0x1226, r1
    36fc:	10 92 27 12 	sts	0x1227, r1
    3700:	10 92 28 12 	sts	0x1228, r1
    3704:	16 bc       	out	0x26, r1	; 38
}
    3706:	08 95       	ret

00003708 <reset_timer1>:
void reset_timer1(void)
{
    TCNT1 = timer1_ovrflow_cnt = 0;
    3708:	10 92 21 12 	sts	0x1221, r1
    370c:	10 92 22 12 	sts	0x1222, r1
    3710:	10 92 23 12 	sts	0x1223, r1
    3714:	10 92 24 12 	sts	0x1224, r1
    3718:	10 92 85 00 	sts	0x0085, r1
    371c:	10 92 84 00 	sts	0x0084, r1
}
    3720:	08 95       	ret

00003722 <reset_timer2>:
void reset_timer2(void)
{
    TCNT2 = timer2_ovrflow_cnt = 0;
    3722:	10 92 29 12 	sts	0x1229, r1
    3726:	10 92 2a 12 	sts	0x122A, r1
    372a:	10 92 2b 12 	sts	0x122B, r1
    372e:	10 92 2c 12 	sts	0x122C, r1
    3732:	10 92 b2 00 	sts	0x00B2, r1
}
    3736:	08 95       	ret

00003738 <reset_timer3>:
void reset_timer3(void)
{
    TCNT3 = timer3_ovrflow_cnt = 0;
    3738:	10 92 31 12 	sts	0x1231, r1
    373c:	10 92 32 12 	sts	0x1232, r1
    3740:	10 92 33 12 	sts	0x1233, r1
    3744:	10 92 34 12 	sts	0x1234, r1
    3748:	10 92 95 00 	sts	0x0095, r1
    374c:	10 92 94 00 	sts	0x0094, r1
}
    3750:	08 95       	ret

00003752 <reset_timer4>:
void reset_timer4(void)
{
    TCNT4 = timer4_ovrflow_cnt = 0;
    3752:	10 92 1d 12 	sts	0x121D, r1
    3756:	10 92 1e 12 	sts	0x121E, r1
    375a:	10 92 1f 12 	sts	0x121F, r1
    375e:	10 92 20 12 	sts	0x1220, r1
    3762:	10 92 a5 00 	sts	0x00A5, r1
    3766:	10 92 a4 00 	sts	0x00A4, r1
}
    376a:	08 95       	ret

0000376c <reset_timer5>:
void reset_timer5(void)
{
    TCNT5 = timer5_ovrflow_cnt = 0;
    376c:	10 92 35 12 	sts	0x1235, r1
    3770:	10 92 36 12 	sts	0x1236, r1
    3774:	10 92 37 12 	sts	0x1237, r1
    3778:	10 92 38 12 	sts	0x1238, r1
    377c:	10 92 25 01 	sts	0x0125, r1
    3780:	10 92 24 01 	sts	0x0124, r1
}
    3784:	08 95       	ret

00003786 <delay_us>:

	delay_loops = ((time_us * CYCLES_PER_US)+3) / 5; // +3 for rounding up (dirty) 

	// one loop takes 5 cpu cycles 
	for (i=0; i < delay_loops; i++) {};
}
    3786:	08 95       	ret

00003788 <init_timer0>:

void init_timer0(const uint8_t prescaler)
{
  TCCR0B = prescaler;
    3788:	85 bd       	out	0x25, r24	; 37
  TIMSK0 = _BV(TOIE0); // enable interrupts
    378a:	81 e0       	ldi	r24, 0x01	; 1
    378c:	80 93 6e 00 	sts	0x006E, r24
    return TCNT5;
}

void reset_timer0(void)
{
    TCNT0 = timer0_ovrflow_cnt = 0;
    3790:	10 92 25 12 	sts	0x1225, r1
    3794:	10 92 26 12 	sts	0x1226, r1
    3798:	10 92 27 12 	sts	0x1227, r1
    379c:	10 92 28 12 	sts	0x1228, r1
    37a0:	16 bc       	out	0x26, r1	; 38
void init_timer0(const uint8_t prescaler)
{
  TCCR0B = prescaler;
  TIMSK0 = _BV(TOIE0); // enable interrupts
  reset_timer0(); // reset counter
}
    37a2:	08 95       	ret

000037a4 <init_timer1>:
void init_timer1(const uint8_t prescaler)
{
  TCCR1B = prescaler;
    37a4:	80 93 81 00 	sts	0x0081, r24
  TIMSK1 = _BV(TOIE1); // enable interrupts
    37a8:	81 e0       	ldi	r24, 0x01	; 1
    37aa:	80 93 6f 00 	sts	0x006F, r24
{
    TCNT0 = timer0_ovrflow_cnt = 0;
}
void reset_timer1(void)
{
    TCNT1 = timer1_ovrflow_cnt = 0;
    37ae:	10 92 21 12 	sts	0x1221, r1
    37b2:	10 92 22 12 	sts	0x1222, r1
    37b6:	10 92 23 12 	sts	0x1223, r1
    37ba:	10 92 24 12 	sts	0x1224, r1
    37be:	10 92 85 00 	sts	0x0085, r1
    37c2:	10 92 84 00 	sts	0x0084, r1
void init_timer1(const uint8_t prescaler)
{
  TCCR1B = prescaler;
  TIMSK1 = _BV(TOIE1); // enable interrupts
  reset_timer1(); // reset counter
}
    37c6:	08 95       	ret

000037c8 <init_timer2>:
void init_timer2(const uint8_t prescaler)
{
  TCCR2B = prescaler;
    37c8:	80 93 b1 00 	sts	0x00B1, r24
  TIMSK2 = _BV(TOIE2); // enable interrupts
    37cc:	81 e0       	ldi	r24, 0x01	; 1
    37ce:	80 93 70 00 	sts	0x0070, r24
{
    TCNT1 = timer1_ovrflow_cnt = 0;
}
void reset_timer2(void)
{
    TCNT2 = timer2_ovrflow_cnt = 0;
    37d2:	10 92 29 12 	sts	0x1229, r1
    37d6:	10 92 2a 12 	sts	0x122A, r1
    37da:	10 92 2b 12 	sts	0x122B, r1
    37de:	10 92 2c 12 	sts	0x122C, r1
    37e2:	10 92 b2 00 	sts	0x00B2, r1
void init_timer2(const uint8_t prescaler)
{
  TCCR2B = prescaler;
  TIMSK2 = _BV(TOIE2); // enable interrupts
  reset_timer2(); // reset counter
}
    37e6:	08 95       	ret

000037e8 <init_timer3>:
void init_timer3(const uint8_t prescaler)
{
  TCCR3B = prescaler;
    37e8:	80 93 91 00 	sts	0x0091, r24
  TIMSK3 = _BV(TOIE3); // enable interrupts
    37ec:	81 e0       	ldi	r24, 0x01	; 1
    37ee:	80 93 71 00 	sts	0x0071, r24
{
    TCNT2 = timer2_ovrflow_cnt = 0;
}
void reset_timer3(void)
{
    TCNT3 = timer3_ovrflow_cnt = 0;
    37f2:	10 92 31 12 	sts	0x1231, r1
    37f6:	10 92 32 12 	sts	0x1232, r1
    37fa:	10 92 33 12 	sts	0x1233, r1
    37fe:	10 92 34 12 	sts	0x1234, r1
    3802:	10 92 95 00 	sts	0x0095, r1
    3806:	10 92 94 00 	sts	0x0094, r1
void init_timer3(const uint8_t prescaler)
{
  TCCR3B = prescaler;
  TIMSK3 = _BV(TOIE3); // enable interrupts
  reset_timer3(); // reset counter
}
    380a:	08 95       	ret

0000380c <init_timer4>:
void init_timer4(const uint8_t prescaler)
{
  TCCR4B = prescaler;
    380c:	80 93 a1 00 	sts	0x00A1, r24
  TIMSK4 = _BV(TOIE4); // enable interrupts
    3810:	81 e0       	ldi	r24, 0x01	; 1
    3812:	80 93 72 00 	sts	0x0072, r24
{
    TCNT3 = timer3_ovrflow_cnt = 0;
}
void reset_timer4(void)
{
    TCNT4 = timer4_ovrflow_cnt = 0;
    3816:	10 92 1d 12 	sts	0x121D, r1
    381a:	10 92 1e 12 	sts	0x121E, r1
    381e:	10 92 1f 12 	sts	0x121F, r1
    3822:	10 92 20 12 	sts	0x1220, r1
    3826:	10 92 a5 00 	sts	0x00A5, r1
    382a:	10 92 a4 00 	sts	0x00A4, r1
void init_timer4(const uint8_t prescaler)
{
  TCCR4B = prescaler;
  TIMSK4 = _BV(TOIE4); // enable interrupts
  reset_timer4(); // reset counter
}
    382e:	08 95       	ret

00003830 <init_timer5>:
void init_timer5(const uint8_t prescaler)
{
  TCCR5B = prescaler;
    3830:	80 93 21 01 	sts	0x0121, r24
  TIMSK5 = _BV(TOIE5); // enable interrupts
    3834:	81 e0       	ldi	r24, 0x01	; 1
    3836:	80 93 73 00 	sts	0x0073, r24
{
    TCNT4 = timer4_ovrflow_cnt = 0;
}
void reset_timer5(void)
{
    TCNT5 = timer5_ovrflow_cnt = 0;
    383a:	10 92 35 12 	sts	0x1235, r1
    383e:	10 92 36 12 	sts	0x1236, r1
    3842:	10 92 37 12 	sts	0x1237, r1
    3846:	10 92 38 12 	sts	0x1238, r1
    384a:	10 92 25 01 	sts	0x0125, r1
    384e:	10 92 24 01 	sts	0x0124, r1
void init_timer5(const uint8_t prescaler)
{
  TCCR5B = prescaler;
  TIMSK5 = _BV(TOIE5); // enable interrupts
  reset_timer5(); // reset counter
}
    3852:	08 95       	ret

00003854 <timer_attach>:

void timer_attach(TimerInterrupt_t interrupt, void (*user_func)(void) )
{
  // set the interrupt function to run
  // the supplied user's function
  TimerIntFunc[interrupt] = user_func;
    3854:	e8 2f       	mov	r30, r24
    3856:	f0 e0       	ldi	r31, 0x00	; 0
    3858:	ee 0f       	add	r30, r30
    385a:	ff 1f       	adc	r31, r31
    385c:	ed 5b       	subi	r30, 0xBD	; 189
    385e:	f0 4f       	sbci	r31, 0xF0	; 240
    3860:	71 83       	std	Z+1, r23	; 0x01
    3862:	60 83       	st	Z, r22
}
    3864:	08 95       	ret

00003866 <timer_detach>:

void timer_detach(TimerInterrupt_t interrupt)
{
  // clear the user defined interrupt function
  TimerIntFunc[interrupt] = NULL;
    3866:	e8 2f       	mov	r30, r24
    3868:	f0 e0       	ldi	r31, 0x00	; 0
    386a:	ee 0f       	add	r30, r30
    386c:	ff 1f       	adc	r31, r31
    386e:	ed 5b       	subi	r30, 0xBD	; 189
    3870:	f0 4f       	sbci	r31, 0xF0	; 240
    3872:	11 82       	std	Z+1, r1	; 0x01
    3874:	10 82       	st	Z, r1
}
    3876:	08 95       	ret

00003878 <_delay_loop_2>:

void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3878:	01 97       	sbiw	r24, 0x01	; 1
    387a:	f1 f7       	brne	.-4      	; 0x3878 <_delay_loop_2>
		"1: sbiw %0,1" "\n\t"
		"brne 1b"
		: "=w" (__count)
		: "0" (__count)
	);
}
    387c:	08 95       	ret

0000387e <sleep>:

void sleep(uint16_t time_ms)
{
    387e:	af 92       	push	r10
    3880:	bf 92       	push	r11
    3882:	cf 92       	push	r12
    3884:	df 92       	push	r13
    3886:	ef 92       	push	r14
    3888:	ff 92       	push	r15
    388a:	0f 93       	push	r16
    388c:	1f 93       	push	r17
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * time_ms;
    388e:	a0 e0       	ldi	r26, 0x00	; 0
    3890:	b0 e0       	ldi	r27, 0x00	; 0
    3892:	bc 01       	movw	r22, r24
    3894:	cd 01       	movw	r24, r26
    3896:	0e 94 81 2d 	call	0x5b02	; 0x5b02 <__floatunsisf>
    389a:	5b 01       	movw	r10, r22
    389c:	6c 01       	movw	r12, r24
    389e:	20 e0       	ldi	r18, 0x00	; 0
    38a0:	30 e0       	ldi	r19, 0x00	; 0
    38a2:	4a e7       	ldi	r20, 0x7A	; 122
    38a4:	55 e4       	ldi	r21, 0x45	; 69
    38a6:	0e 94 37 2e 	call	0x5c6e	; 0x5c6e <__mulsf3>
    38aa:	7b 01       	movw	r14, r22
    38ac:	8c 01       	movw	r16, r24
	if (__tmp < 1.0)
    38ae:	20 e0       	ldi	r18, 0x00	; 0
    38b0:	30 e0       	ldi	r19, 0x00	; 0
    38b2:	40 e8       	ldi	r20, 0x80	; 128
    38b4:	5f e3       	ldi	r21, 0x3F	; 63
    38b6:	0e 94 e4 2c 	call	0x59c8	; 0x59c8 <__cmpsf2>
    38ba:	88 23       	and	r24, r24
    38bc:	1c f4       	brge	.+6      	; 0x38c4 <sleep+0x46>
    38be:	61 e0       	ldi	r22, 0x01	; 1
    38c0:	70 e0       	ldi	r23, 0x00	; 0
    38c2:	24 c0       	rjmp	.+72     	; 0x390c <sleep+0x8e>
		__ticks = 1;
	else if (__tmp > 65535)
    38c4:	c8 01       	movw	r24, r16
    38c6:	b7 01       	movw	r22, r14
    38c8:	20 e0       	ldi	r18, 0x00	; 0
    38ca:	3f ef       	ldi	r19, 0xFF	; 255
    38cc:	4f e7       	ldi	r20, 0x7F	; 127
    38ce:	57 e4       	ldi	r21, 0x47	; 71
    38d0:	0e 94 33 2e 	call	0x5c66	; 0x5c66 <__gesf2>
    38d4:	18 16       	cp	r1, r24
    38d6:	b4 f4       	brge	.+44     	; 0x3904 <sleep+0x86>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (time_ms * 10.0);
    38d8:	c6 01       	movw	r24, r12
    38da:	b5 01       	movw	r22, r10
    38dc:	20 e0       	ldi	r18, 0x00	; 0
    38de:	30 e0       	ldi	r19, 0x00	; 0
    38e0:	40 e2       	ldi	r20, 0x20	; 32
    38e2:	51 e4       	ldi	r21, 0x41	; 65
    38e4:	0e 94 37 2e 	call	0x5c6e	; 0x5c6e <__mulsf3>
    38e8:	0e 94 55 2d 	call	0x5aaa	; 0x5aaa <__fixunssfsi>
}

void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    38ec:	80 e9       	ldi	r24, 0x90	; 144
    38ee:	91 e0       	ldi	r25, 0x01	; 1
    38f0:	05 c0       	rjmp	.+10     	; 0x38fc <sleep+0x7e>
    38f2:	fc 01       	movw	r30, r24
    38f4:	31 97       	sbiw	r30, 0x01	; 1
    38f6:	f1 f7       	brne	.-4      	; 0x38f4 <sleep+0x76>
		__ticks = (uint16_t) (time_ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    38f8:	61 50       	subi	r22, 0x01	; 1
    38fa:	70 40       	sbci	r23, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (time_ms * 10.0);
		while(__ticks)
    38fc:	61 15       	cp	r22, r1
    38fe:	71 05       	cpc	r23, r1
    3900:	c1 f7       	brne	.-16     	; 0x38f2 <sleep+0x74>
    3902:	07 c0       	rjmp	.+14     	; 0x3912 <sleep+0x94>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3904:	c8 01       	movw	r24, r16
    3906:	b7 01       	movw	r22, r14
    3908:	0e 94 55 2d 	call	0x5aaa	; 0x5aaa <__fixunssfsi>
}

void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    390c:	cb 01       	movw	r24, r22
    390e:	01 97       	sbiw	r24, 0x01	; 1
    3910:	f1 f7       	brne	.-4      	; 0x390e <sleep+0x90>
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
	_delay_loop_2(__ticks);
}
    3912:	1f 91       	pop	r17
    3914:	0f 91       	pop	r16
    3916:	ff 90       	pop	r15
    3918:	ef 90       	pop	r14
    391a:	df 90       	pop	r13
    391c:	cf 90       	pop	r12
    391e:	bf 90       	pop	r11
    3920:	af 90       	pop	r10
    3922:	08 95       	ret

00003924 <__vector_23>:
    }
  }
}*/

ISR(TIMER0_OVF_vect) 
{
    3924:	1f 92       	push	r1
    3926:	0f 92       	push	r0
    3928:	0f b6       	in	r0, 0x3f	; 63
    392a:	0f 92       	push	r0
    392c:	11 24       	eor	r1, r1
    392e:	2f 93       	push	r18
    3930:	3f 93       	push	r19
    3932:	4f 93       	push	r20
    3934:	5f 93       	push	r21
    3936:	6f 93       	push	r22
    3938:	7f 93       	push	r23
    393a:	8f 93       	push	r24
    393c:	9f 93       	push	r25
    393e:	af 93       	push	r26
    3940:	bf 93       	push	r27
    3942:	ef 93       	push	r30
    3944:	ff 93       	push	r31
  timer0_ovrflow_cnt++;
    3946:	80 91 25 12 	lds	r24, 0x1225
    394a:	90 91 26 12 	lds	r25, 0x1226
    394e:	a0 91 27 12 	lds	r26, 0x1227
    3952:	b0 91 28 12 	lds	r27, 0x1228
    3956:	01 96       	adiw	r24, 0x01	; 1
    3958:	a1 1d       	adc	r26, r1
    395a:	b1 1d       	adc	r27, r1
    395c:	80 93 25 12 	sts	0x1225, r24
    3960:	90 93 26 12 	sts	0x1226, r25
    3964:	a0 93 27 12 	sts	0x1227, r26
    3968:	b0 93 28 12 	sts	0x1228, r27
  timer_sleep_cnt++;
    396c:	80 91 2d 12 	lds	r24, 0x122D
    3970:	90 91 2e 12 	lds	r25, 0x122E
    3974:	a0 91 2f 12 	lds	r26, 0x122F
    3978:	b0 91 30 12 	lds	r27, 0x1230
    397c:	01 96       	adiw	r24, 0x01	; 1
    397e:	a1 1d       	adc	r26, r1
    3980:	b1 1d       	adc	r27, r1
    3982:	80 93 2d 12 	sts	0x122D, r24
    3986:	90 93 2e 12 	sts	0x122E, r25
    398a:	a0 93 2f 12 	sts	0x122F, r26
    398e:	b0 93 30 12 	sts	0x1230, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER0_OVF_interrupt);
    3992:	80 91 47 0f 	lds	r24, 0x0F47
    3996:	90 91 48 0f 	lds	r25, 0x0F48
    399a:	89 2b       	or	r24, r25
    399c:	29 f0       	breq	.+10     	; 0x39a8 <__vector_23+0x84>
    399e:	e0 91 47 0f 	lds	r30, 0x0F47
    39a2:	f0 91 48 0f 	lds	r31, 0x0F48
    39a6:	09 95       	icall
}
    39a8:	ff 91       	pop	r31
    39aa:	ef 91       	pop	r30
    39ac:	bf 91       	pop	r27
    39ae:	af 91       	pop	r26
    39b0:	9f 91       	pop	r25
    39b2:	8f 91       	pop	r24
    39b4:	7f 91       	pop	r23
    39b6:	6f 91       	pop	r22
    39b8:	5f 91       	pop	r21
    39ba:	4f 91       	pop	r20
    39bc:	3f 91       	pop	r19
    39be:	2f 91       	pop	r18
    39c0:	0f 90       	pop	r0
    39c2:	0f be       	out	0x3f, r0	; 63
    39c4:	0f 90       	pop	r0
    39c6:	1f 90       	pop	r1
    39c8:	18 95       	reti

000039ca <__vector_20>:
ISR(TIMER1_OVF_vect) 
{
    39ca:	1f 92       	push	r1
    39cc:	0f 92       	push	r0
    39ce:	0f b6       	in	r0, 0x3f	; 63
    39d0:	0f 92       	push	r0
    39d2:	11 24       	eor	r1, r1
    39d4:	2f 93       	push	r18
    39d6:	3f 93       	push	r19
    39d8:	4f 93       	push	r20
    39da:	5f 93       	push	r21
    39dc:	6f 93       	push	r22
    39de:	7f 93       	push	r23
    39e0:	8f 93       	push	r24
    39e2:	9f 93       	push	r25
    39e4:	af 93       	push	r26
    39e6:	bf 93       	push	r27
    39e8:	ef 93       	push	r30
    39ea:	ff 93       	push	r31
  timer1_ovrflow_cnt++;
    39ec:	80 91 21 12 	lds	r24, 0x1221
    39f0:	90 91 22 12 	lds	r25, 0x1222
    39f4:	a0 91 23 12 	lds	r26, 0x1223
    39f8:	b0 91 24 12 	lds	r27, 0x1224
    39fc:	01 96       	adiw	r24, 0x01	; 1
    39fe:	a1 1d       	adc	r26, r1
    3a00:	b1 1d       	adc	r27, r1
    3a02:	80 93 21 12 	sts	0x1221, r24
    3a06:	90 93 22 12 	sts	0x1222, r25
    3a0a:	a0 93 23 12 	sts	0x1223, r26
    3a0e:	b0 93 24 12 	sts	0x1224, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER1_OVF_interrupt);
    3a12:	80 91 51 0f 	lds	r24, 0x0F51
    3a16:	90 91 52 0f 	lds	r25, 0x0F52
    3a1a:	89 2b       	or	r24, r25
    3a1c:	29 f0       	breq	.+10     	; 0x3a28 <__vector_20+0x5e>
    3a1e:	e0 91 51 0f 	lds	r30, 0x0F51
    3a22:	f0 91 52 0f 	lds	r31, 0x0F52
    3a26:	09 95       	icall
}
    3a28:	ff 91       	pop	r31
    3a2a:	ef 91       	pop	r30
    3a2c:	bf 91       	pop	r27
    3a2e:	af 91       	pop	r26
    3a30:	9f 91       	pop	r25
    3a32:	8f 91       	pop	r24
    3a34:	7f 91       	pop	r23
    3a36:	6f 91       	pop	r22
    3a38:	5f 91       	pop	r21
    3a3a:	4f 91       	pop	r20
    3a3c:	3f 91       	pop	r19
    3a3e:	2f 91       	pop	r18
    3a40:	0f 90       	pop	r0
    3a42:	0f be       	out	0x3f, r0	; 63
    3a44:	0f 90       	pop	r0
    3a46:	1f 90       	pop	r1
    3a48:	18 95       	reti

00003a4a <__vector_15>:
ISR(TIMER2_OVF_vect) 
{
    3a4a:	1f 92       	push	r1
    3a4c:	0f 92       	push	r0
    3a4e:	0f b6       	in	r0, 0x3f	; 63
    3a50:	0f 92       	push	r0
    3a52:	11 24       	eor	r1, r1
    3a54:	2f 93       	push	r18
    3a56:	3f 93       	push	r19
    3a58:	4f 93       	push	r20
    3a5a:	5f 93       	push	r21
    3a5c:	6f 93       	push	r22
    3a5e:	7f 93       	push	r23
    3a60:	8f 93       	push	r24
    3a62:	9f 93       	push	r25
    3a64:	af 93       	push	r26
    3a66:	bf 93       	push	r27
    3a68:	ef 93       	push	r30
    3a6a:	ff 93       	push	r31
  timer2_ovrflow_cnt++;
    3a6c:	80 91 29 12 	lds	r24, 0x1229
    3a70:	90 91 2a 12 	lds	r25, 0x122A
    3a74:	a0 91 2b 12 	lds	r26, 0x122B
    3a78:	b0 91 2c 12 	lds	r27, 0x122C
    3a7c:	01 96       	adiw	r24, 0x01	; 1
    3a7e:	a1 1d       	adc	r26, r1
    3a80:	b1 1d       	adc	r27, r1
    3a82:	80 93 29 12 	sts	0x1229, r24
    3a86:	90 93 2a 12 	sts	0x122A, r25
    3a8a:	a0 93 2b 12 	sts	0x122B, r26
    3a8e:	b0 93 2c 12 	sts	0x122C, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER2_OVF_interrupt);
    3a92:	80 91 57 0f 	lds	r24, 0x0F57
    3a96:	90 91 58 0f 	lds	r25, 0x0F58
    3a9a:	89 2b       	or	r24, r25
    3a9c:	29 f0       	breq	.+10     	; 0x3aa8 <__vector_15+0x5e>
    3a9e:	e0 91 57 0f 	lds	r30, 0x0F57
    3aa2:	f0 91 58 0f 	lds	r31, 0x0F58
    3aa6:	09 95       	icall
}
    3aa8:	ff 91       	pop	r31
    3aaa:	ef 91       	pop	r30
    3aac:	bf 91       	pop	r27
    3aae:	af 91       	pop	r26
    3ab0:	9f 91       	pop	r25
    3ab2:	8f 91       	pop	r24
    3ab4:	7f 91       	pop	r23
    3ab6:	6f 91       	pop	r22
    3ab8:	5f 91       	pop	r21
    3aba:	4f 91       	pop	r20
    3abc:	3f 91       	pop	r19
    3abe:	2f 91       	pop	r18
    3ac0:	0f 90       	pop	r0
    3ac2:	0f be       	out	0x3f, r0	; 63
    3ac4:	0f 90       	pop	r0
    3ac6:	1f 90       	pop	r1
    3ac8:	18 95       	reti

00003aca <__vector_35>:
ISR(TIMER3_OVF_vect) 
{
    3aca:	1f 92       	push	r1
    3acc:	0f 92       	push	r0
    3ace:	0f b6       	in	r0, 0x3f	; 63
    3ad0:	0f 92       	push	r0
    3ad2:	11 24       	eor	r1, r1
    3ad4:	2f 93       	push	r18
    3ad6:	3f 93       	push	r19
    3ad8:	4f 93       	push	r20
    3ada:	5f 93       	push	r21
    3adc:	6f 93       	push	r22
    3ade:	7f 93       	push	r23
    3ae0:	8f 93       	push	r24
    3ae2:	9f 93       	push	r25
    3ae4:	af 93       	push	r26
    3ae6:	bf 93       	push	r27
    3ae8:	ef 93       	push	r30
    3aea:	ff 93       	push	r31
  timer3_ovrflow_cnt++;
    3aec:	80 91 31 12 	lds	r24, 0x1231
    3af0:	90 91 32 12 	lds	r25, 0x1232
    3af4:	a0 91 33 12 	lds	r26, 0x1233
    3af8:	b0 91 34 12 	lds	r27, 0x1234
    3afc:	01 96       	adiw	r24, 0x01	; 1
    3afe:	a1 1d       	adc	r26, r1
    3b00:	b1 1d       	adc	r27, r1
    3b02:	80 93 31 12 	sts	0x1231, r24
    3b06:	90 93 32 12 	sts	0x1232, r25
    3b0a:	a0 93 33 12 	sts	0x1233, r26
    3b0e:	b0 93 34 12 	sts	0x1234, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER3_OVF_interrupt);
    3b12:	80 91 61 0f 	lds	r24, 0x0F61
    3b16:	90 91 62 0f 	lds	r25, 0x0F62
    3b1a:	89 2b       	or	r24, r25
    3b1c:	29 f0       	breq	.+10     	; 0x3b28 <__vector_35+0x5e>
    3b1e:	e0 91 61 0f 	lds	r30, 0x0F61
    3b22:	f0 91 62 0f 	lds	r31, 0x0F62
    3b26:	09 95       	icall
}
    3b28:	ff 91       	pop	r31
    3b2a:	ef 91       	pop	r30
    3b2c:	bf 91       	pop	r27
    3b2e:	af 91       	pop	r26
    3b30:	9f 91       	pop	r25
    3b32:	8f 91       	pop	r24
    3b34:	7f 91       	pop	r23
    3b36:	6f 91       	pop	r22
    3b38:	5f 91       	pop	r21
    3b3a:	4f 91       	pop	r20
    3b3c:	3f 91       	pop	r19
    3b3e:	2f 91       	pop	r18
    3b40:	0f 90       	pop	r0
    3b42:	0f be       	out	0x3f, r0	; 63
    3b44:	0f 90       	pop	r0
    3b46:	1f 90       	pop	r1
    3b48:	18 95       	reti

00003b4a <__vector_45>:
ISR(TIMER4_OVF_vect) 
{
    3b4a:	1f 92       	push	r1
    3b4c:	0f 92       	push	r0
    3b4e:	0f b6       	in	r0, 0x3f	; 63
    3b50:	0f 92       	push	r0
    3b52:	11 24       	eor	r1, r1
    3b54:	2f 93       	push	r18
    3b56:	3f 93       	push	r19
    3b58:	4f 93       	push	r20
    3b5a:	5f 93       	push	r21
    3b5c:	6f 93       	push	r22
    3b5e:	7f 93       	push	r23
    3b60:	8f 93       	push	r24
    3b62:	9f 93       	push	r25
    3b64:	af 93       	push	r26
    3b66:	bf 93       	push	r27
    3b68:	ef 93       	push	r30
    3b6a:	ff 93       	push	r31
  timer4_ovrflow_cnt++;
    3b6c:	80 91 1d 12 	lds	r24, 0x121D
    3b70:	90 91 1e 12 	lds	r25, 0x121E
    3b74:	a0 91 1f 12 	lds	r26, 0x121F
    3b78:	b0 91 20 12 	lds	r27, 0x1220
    3b7c:	01 96       	adiw	r24, 0x01	; 1
    3b7e:	a1 1d       	adc	r26, r1
    3b80:	b1 1d       	adc	r27, r1
    3b82:	80 93 1d 12 	sts	0x121D, r24
    3b86:	90 93 1e 12 	sts	0x121E, r25
    3b8a:	a0 93 1f 12 	sts	0x121F, r26
    3b8e:	b0 93 20 12 	sts	0x1220, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER4_OVF_interrupt);
    3b92:	80 91 6b 0f 	lds	r24, 0x0F6B
    3b96:	90 91 6c 0f 	lds	r25, 0x0F6C
    3b9a:	89 2b       	or	r24, r25
    3b9c:	29 f0       	breq	.+10     	; 0x3ba8 <__vector_45+0x5e>
    3b9e:	e0 91 6b 0f 	lds	r30, 0x0F6B
    3ba2:	f0 91 6c 0f 	lds	r31, 0x0F6C
    3ba6:	09 95       	icall
}
    3ba8:	ff 91       	pop	r31
    3baa:	ef 91       	pop	r30
    3bac:	bf 91       	pop	r27
    3bae:	af 91       	pop	r26
    3bb0:	9f 91       	pop	r25
    3bb2:	8f 91       	pop	r24
    3bb4:	7f 91       	pop	r23
    3bb6:	6f 91       	pop	r22
    3bb8:	5f 91       	pop	r21
    3bba:	4f 91       	pop	r20
    3bbc:	3f 91       	pop	r19
    3bbe:	2f 91       	pop	r18
    3bc0:	0f 90       	pop	r0
    3bc2:	0f be       	out	0x3f, r0	; 63
    3bc4:	0f 90       	pop	r0
    3bc6:	1f 90       	pop	r1
    3bc8:	18 95       	reti

00003bca <__vector_50>:
ISR(TIMER5_OVF_vect) 
{
    3bca:	1f 92       	push	r1
    3bcc:	0f 92       	push	r0
    3bce:	0f b6       	in	r0, 0x3f	; 63
    3bd0:	0f 92       	push	r0
    3bd2:	11 24       	eor	r1, r1
    3bd4:	2f 93       	push	r18
    3bd6:	3f 93       	push	r19
    3bd8:	4f 93       	push	r20
    3bda:	5f 93       	push	r21
    3bdc:	6f 93       	push	r22
    3bde:	7f 93       	push	r23
    3be0:	8f 93       	push	r24
    3be2:	9f 93       	push	r25
    3be4:	af 93       	push	r26
    3be6:	bf 93       	push	r27
    3be8:	ef 93       	push	r30
    3bea:	ff 93       	push	r31
  timer5_ovrflow_cnt++;
    3bec:	80 91 35 12 	lds	r24, 0x1235
    3bf0:	90 91 36 12 	lds	r25, 0x1236
    3bf4:	a0 91 37 12 	lds	r26, 0x1237
    3bf8:	b0 91 38 12 	lds	r27, 0x1238
    3bfc:	01 96       	adiw	r24, 0x01	; 1
    3bfe:	a1 1d       	adc	r26, r1
    3c00:	b1 1d       	adc	r27, r1
    3c02:	80 93 35 12 	sts	0x1235, r24
    3c06:	90 93 36 12 	sts	0x1236, r25
    3c0a:	a0 93 37 12 	sts	0x1237, r26
    3c0e:	b0 93 38 12 	sts	0x1238, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER5_OVF_interrupt);
    3c12:	80 91 75 0f 	lds	r24, 0x0F75
    3c16:	90 91 76 0f 	lds	r25, 0x0F76
    3c1a:	89 2b       	or	r24, r25
    3c1c:	29 f0       	breq	.+10     	; 0x3c28 <__vector_50+0x5e>
    3c1e:	e0 91 75 0f 	lds	r30, 0x0F75
    3c22:	f0 91 76 0f 	lds	r31, 0x0F76
    3c26:	09 95       	icall
}
    3c28:	ff 91       	pop	r31
    3c2a:	ef 91       	pop	r30
    3c2c:	bf 91       	pop	r27
    3c2e:	af 91       	pop	r26
    3c30:	9f 91       	pop	r25
    3c32:	8f 91       	pop	r24
    3c34:	7f 91       	pop	r23
    3c36:	6f 91       	pop	r22
    3c38:	5f 91       	pop	r21
    3c3a:	4f 91       	pop	r20
    3c3c:	3f 91       	pop	r19
    3c3e:	2f 91       	pop	r18
    3c40:	0f 90       	pop	r0
    3c42:	0f be       	out	0x3f, r0	; 63
    3c44:	0f 90       	pop	r0
    3c46:	1f 90       	pop	r1
    3c48:	18 95       	reti

00003c4a <__vector_21>:
ISR(TIMER0_COMPA_vect)
{
    3c4a:	1f 92       	push	r1
    3c4c:	0f 92       	push	r0
    3c4e:	0f b6       	in	r0, 0x3f	; 63
    3c50:	0f 92       	push	r0
    3c52:	11 24       	eor	r1, r1
    3c54:	2f 93       	push	r18
    3c56:	3f 93       	push	r19
    3c58:	4f 93       	push	r20
    3c5a:	5f 93       	push	r21
    3c5c:	6f 93       	push	r22
    3c5e:	7f 93       	push	r23
    3c60:	8f 93       	push	r24
    3c62:	9f 93       	push	r25
    3c64:	af 93       	push	r26
    3c66:	bf 93       	push	r27
    3c68:	ef 93       	push	r30
    3c6a:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER0_COMPA_interrupt);
    3c6c:	80 91 43 0f 	lds	r24, 0x0F43
    3c70:	90 91 44 0f 	lds	r25, 0x0F44
    3c74:	89 2b       	or	r24, r25
    3c76:	29 f0       	breq	.+10     	; 0x3c82 <__vector_21+0x38>
    3c78:	e0 91 43 0f 	lds	r30, 0x0F43
    3c7c:	f0 91 44 0f 	lds	r31, 0x0F44
    3c80:	09 95       	icall
}
    3c82:	ff 91       	pop	r31
    3c84:	ef 91       	pop	r30
    3c86:	bf 91       	pop	r27
    3c88:	af 91       	pop	r26
    3c8a:	9f 91       	pop	r25
    3c8c:	8f 91       	pop	r24
    3c8e:	7f 91       	pop	r23
    3c90:	6f 91       	pop	r22
    3c92:	5f 91       	pop	r21
    3c94:	4f 91       	pop	r20
    3c96:	3f 91       	pop	r19
    3c98:	2f 91       	pop	r18
    3c9a:	0f 90       	pop	r0
    3c9c:	0f be       	out	0x3f, r0	; 63
    3c9e:	0f 90       	pop	r0
    3ca0:	1f 90       	pop	r1
    3ca2:	18 95       	reti

00003ca4 <__vector_22>:
ISR(TIMER0_COMPB_vect)
{
    3ca4:	1f 92       	push	r1
    3ca6:	0f 92       	push	r0
    3ca8:	0f b6       	in	r0, 0x3f	; 63
    3caa:	0f 92       	push	r0
    3cac:	11 24       	eor	r1, r1
    3cae:	2f 93       	push	r18
    3cb0:	3f 93       	push	r19
    3cb2:	4f 93       	push	r20
    3cb4:	5f 93       	push	r21
    3cb6:	6f 93       	push	r22
    3cb8:	7f 93       	push	r23
    3cba:	8f 93       	push	r24
    3cbc:	9f 93       	push	r25
    3cbe:	af 93       	push	r26
    3cc0:	bf 93       	push	r27
    3cc2:	ef 93       	push	r30
    3cc4:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER0_COMPB_interrupt);
    3cc6:	80 91 45 0f 	lds	r24, 0x0F45
    3cca:	90 91 46 0f 	lds	r25, 0x0F46
    3cce:	89 2b       	or	r24, r25
    3cd0:	29 f0       	breq	.+10     	; 0x3cdc <__vector_22+0x38>
    3cd2:	e0 91 45 0f 	lds	r30, 0x0F45
    3cd6:	f0 91 46 0f 	lds	r31, 0x0F46
    3cda:	09 95       	icall
}
    3cdc:	ff 91       	pop	r31
    3cde:	ef 91       	pop	r30
    3ce0:	bf 91       	pop	r27
    3ce2:	af 91       	pop	r26
    3ce4:	9f 91       	pop	r25
    3ce6:	8f 91       	pop	r24
    3ce8:	7f 91       	pop	r23
    3cea:	6f 91       	pop	r22
    3cec:	5f 91       	pop	r21
    3cee:	4f 91       	pop	r20
    3cf0:	3f 91       	pop	r19
    3cf2:	2f 91       	pop	r18
    3cf4:	0f 90       	pop	r0
    3cf6:	0f be       	out	0x3f, r0	; 63
    3cf8:	0f 90       	pop	r0
    3cfa:	1f 90       	pop	r1
    3cfc:	18 95       	reti

00003cfe <__vector_16>:
ISR(TIMER1_CAPT_vect)
{
    3cfe:	1f 92       	push	r1
    3d00:	0f 92       	push	r0
    3d02:	0f b6       	in	r0, 0x3f	; 63
    3d04:	0f 92       	push	r0
    3d06:	11 24       	eor	r1, r1
    3d08:	2f 93       	push	r18
    3d0a:	3f 93       	push	r19
    3d0c:	4f 93       	push	r20
    3d0e:	5f 93       	push	r21
    3d10:	6f 93       	push	r22
    3d12:	7f 93       	push	r23
    3d14:	8f 93       	push	r24
    3d16:	9f 93       	push	r25
    3d18:	af 93       	push	r26
    3d1a:	bf 93       	push	r27
    3d1c:	ef 93       	push	r30
    3d1e:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER1_CAPT_interrupt);
    3d20:	80 91 49 0f 	lds	r24, 0x0F49
    3d24:	90 91 4a 0f 	lds	r25, 0x0F4A
    3d28:	89 2b       	or	r24, r25
    3d2a:	29 f0       	breq	.+10     	; 0x3d36 <__vector_16+0x38>
    3d2c:	e0 91 49 0f 	lds	r30, 0x0F49
    3d30:	f0 91 4a 0f 	lds	r31, 0x0F4A
    3d34:	09 95       	icall
}
    3d36:	ff 91       	pop	r31
    3d38:	ef 91       	pop	r30
    3d3a:	bf 91       	pop	r27
    3d3c:	af 91       	pop	r26
    3d3e:	9f 91       	pop	r25
    3d40:	8f 91       	pop	r24
    3d42:	7f 91       	pop	r23
    3d44:	6f 91       	pop	r22
    3d46:	5f 91       	pop	r21
    3d48:	4f 91       	pop	r20
    3d4a:	3f 91       	pop	r19
    3d4c:	2f 91       	pop	r18
    3d4e:	0f 90       	pop	r0
    3d50:	0f be       	out	0x3f, r0	; 63
    3d52:	0f 90       	pop	r0
    3d54:	1f 90       	pop	r1
    3d56:	18 95       	reti

00003d58 <__vector_18>:
{
  RUN_USER_DEFINE_INTERRUPT(TIMER1_COMPA_interrupt);
}
*/
ISR(TIMER1_COMPB_vect)
{
    3d58:	1f 92       	push	r1
    3d5a:	0f 92       	push	r0
    3d5c:	0f b6       	in	r0, 0x3f	; 63
    3d5e:	0f 92       	push	r0
    3d60:	11 24       	eor	r1, r1
    3d62:	2f 93       	push	r18
    3d64:	3f 93       	push	r19
    3d66:	4f 93       	push	r20
    3d68:	5f 93       	push	r21
    3d6a:	6f 93       	push	r22
    3d6c:	7f 93       	push	r23
    3d6e:	8f 93       	push	r24
    3d70:	9f 93       	push	r25
    3d72:	af 93       	push	r26
    3d74:	bf 93       	push	r27
    3d76:	ef 93       	push	r30
    3d78:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER1_COMPB_interrupt);
    3d7a:	80 91 4d 0f 	lds	r24, 0x0F4D
    3d7e:	90 91 4e 0f 	lds	r25, 0x0F4E
    3d82:	89 2b       	or	r24, r25
    3d84:	29 f0       	breq	.+10     	; 0x3d90 <__vector_18+0x38>
    3d86:	e0 91 4d 0f 	lds	r30, 0x0F4D
    3d8a:	f0 91 4e 0f 	lds	r31, 0x0F4E
    3d8e:	09 95       	icall
}
    3d90:	ff 91       	pop	r31
    3d92:	ef 91       	pop	r30
    3d94:	bf 91       	pop	r27
    3d96:	af 91       	pop	r26
    3d98:	9f 91       	pop	r25
    3d9a:	8f 91       	pop	r24
    3d9c:	7f 91       	pop	r23
    3d9e:	6f 91       	pop	r22
    3da0:	5f 91       	pop	r21
    3da2:	4f 91       	pop	r20
    3da4:	3f 91       	pop	r19
    3da6:	2f 91       	pop	r18
    3da8:	0f 90       	pop	r0
    3daa:	0f be       	out	0x3f, r0	; 63
    3dac:	0f 90       	pop	r0
    3dae:	1f 90       	pop	r1
    3db0:	18 95       	reti

00003db2 <__vector_19>:
ISR(TIMER1_COMPC_vect)
{
    3db2:	1f 92       	push	r1
    3db4:	0f 92       	push	r0
    3db6:	0f b6       	in	r0, 0x3f	; 63
    3db8:	0f 92       	push	r0
    3dba:	11 24       	eor	r1, r1
    3dbc:	2f 93       	push	r18
    3dbe:	3f 93       	push	r19
    3dc0:	4f 93       	push	r20
    3dc2:	5f 93       	push	r21
    3dc4:	6f 93       	push	r22
    3dc6:	7f 93       	push	r23
    3dc8:	8f 93       	push	r24
    3dca:	9f 93       	push	r25
    3dcc:	af 93       	push	r26
    3dce:	bf 93       	push	r27
    3dd0:	ef 93       	push	r30
    3dd2:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER1_COMPC_interrupt);
    3dd4:	80 91 4f 0f 	lds	r24, 0x0F4F
    3dd8:	90 91 50 0f 	lds	r25, 0x0F50
    3ddc:	89 2b       	or	r24, r25
    3dde:	29 f0       	breq	.+10     	; 0x3dea <__vector_19+0x38>
    3de0:	e0 91 4f 0f 	lds	r30, 0x0F4F
    3de4:	f0 91 50 0f 	lds	r31, 0x0F50
    3de8:	09 95       	icall
}
    3dea:	ff 91       	pop	r31
    3dec:	ef 91       	pop	r30
    3dee:	bf 91       	pop	r27
    3df0:	af 91       	pop	r26
    3df2:	9f 91       	pop	r25
    3df4:	8f 91       	pop	r24
    3df6:	7f 91       	pop	r23
    3df8:	6f 91       	pop	r22
    3dfa:	5f 91       	pop	r21
    3dfc:	4f 91       	pop	r20
    3dfe:	3f 91       	pop	r19
    3e00:	2f 91       	pop	r18
    3e02:	0f 90       	pop	r0
    3e04:	0f be       	out	0x3f, r0	; 63
    3e06:	0f 90       	pop	r0
    3e08:	1f 90       	pop	r1
    3e0a:	18 95       	reti

00003e0c <__vector_13>:
ISR(TIMER2_COMPA_vect)
{
    3e0c:	1f 92       	push	r1
    3e0e:	0f 92       	push	r0
    3e10:	0f b6       	in	r0, 0x3f	; 63
    3e12:	0f 92       	push	r0
    3e14:	11 24       	eor	r1, r1
    3e16:	2f 93       	push	r18
    3e18:	3f 93       	push	r19
    3e1a:	4f 93       	push	r20
    3e1c:	5f 93       	push	r21
    3e1e:	6f 93       	push	r22
    3e20:	7f 93       	push	r23
    3e22:	8f 93       	push	r24
    3e24:	9f 93       	push	r25
    3e26:	af 93       	push	r26
    3e28:	bf 93       	push	r27
    3e2a:	ef 93       	push	r30
    3e2c:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER2_COMPA_interrupt);
    3e2e:	80 91 53 0f 	lds	r24, 0x0F53
    3e32:	90 91 54 0f 	lds	r25, 0x0F54
    3e36:	89 2b       	or	r24, r25
    3e38:	29 f0       	breq	.+10     	; 0x3e44 <__vector_13+0x38>
    3e3a:	e0 91 53 0f 	lds	r30, 0x0F53
    3e3e:	f0 91 54 0f 	lds	r31, 0x0F54
    3e42:	09 95       	icall
}
    3e44:	ff 91       	pop	r31
    3e46:	ef 91       	pop	r30
    3e48:	bf 91       	pop	r27
    3e4a:	af 91       	pop	r26
    3e4c:	9f 91       	pop	r25
    3e4e:	8f 91       	pop	r24
    3e50:	7f 91       	pop	r23
    3e52:	6f 91       	pop	r22
    3e54:	5f 91       	pop	r21
    3e56:	4f 91       	pop	r20
    3e58:	3f 91       	pop	r19
    3e5a:	2f 91       	pop	r18
    3e5c:	0f 90       	pop	r0
    3e5e:	0f be       	out	0x3f, r0	; 63
    3e60:	0f 90       	pop	r0
    3e62:	1f 90       	pop	r1
    3e64:	18 95       	reti

00003e66 <__vector_14>:
ISR(TIMER2_COMPB_vect)
{
    3e66:	1f 92       	push	r1
    3e68:	0f 92       	push	r0
    3e6a:	0f b6       	in	r0, 0x3f	; 63
    3e6c:	0f 92       	push	r0
    3e6e:	11 24       	eor	r1, r1
    3e70:	2f 93       	push	r18
    3e72:	3f 93       	push	r19
    3e74:	4f 93       	push	r20
    3e76:	5f 93       	push	r21
    3e78:	6f 93       	push	r22
    3e7a:	7f 93       	push	r23
    3e7c:	8f 93       	push	r24
    3e7e:	9f 93       	push	r25
    3e80:	af 93       	push	r26
    3e82:	bf 93       	push	r27
    3e84:	ef 93       	push	r30
    3e86:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER2_COMPB_interrupt);
    3e88:	80 91 55 0f 	lds	r24, 0x0F55
    3e8c:	90 91 56 0f 	lds	r25, 0x0F56
    3e90:	89 2b       	or	r24, r25
    3e92:	29 f0       	breq	.+10     	; 0x3e9e <__vector_14+0x38>
    3e94:	e0 91 55 0f 	lds	r30, 0x0F55
    3e98:	f0 91 56 0f 	lds	r31, 0x0F56
    3e9c:	09 95       	icall
}
    3e9e:	ff 91       	pop	r31
    3ea0:	ef 91       	pop	r30
    3ea2:	bf 91       	pop	r27
    3ea4:	af 91       	pop	r26
    3ea6:	9f 91       	pop	r25
    3ea8:	8f 91       	pop	r24
    3eaa:	7f 91       	pop	r23
    3eac:	6f 91       	pop	r22
    3eae:	5f 91       	pop	r21
    3eb0:	4f 91       	pop	r20
    3eb2:	3f 91       	pop	r19
    3eb4:	2f 91       	pop	r18
    3eb6:	0f 90       	pop	r0
    3eb8:	0f be       	out	0x3f, r0	; 63
    3eba:	0f 90       	pop	r0
    3ebc:	1f 90       	pop	r1
    3ebe:	18 95       	reti

00003ec0 <__vector_31>:
ISR(TIMER3_CAPT_vect)
{
    3ec0:	1f 92       	push	r1
    3ec2:	0f 92       	push	r0
    3ec4:	0f b6       	in	r0, 0x3f	; 63
    3ec6:	0f 92       	push	r0
    3ec8:	11 24       	eor	r1, r1
    3eca:	2f 93       	push	r18
    3ecc:	3f 93       	push	r19
    3ece:	4f 93       	push	r20
    3ed0:	5f 93       	push	r21
    3ed2:	6f 93       	push	r22
    3ed4:	7f 93       	push	r23
    3ed6:	8f 93       	push	r24
    3ed8:	9f 93       	push	r25
    3eda:	af 93       	push	r26
    3edc:	bf 93       	push	r27
    3ede:	ef 93       	push	r30
    3ee0:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_CAPT_interrupt);
    3ee2:	80 91 59 0f 	lds	r24, 0x0F59
    3ee6:	90 91 5a 0f 	lds	r25, 0x0F5A
    3eea:	89 2b       	or	r24, r25
    3eec:	29 f0       	breq	.+10     	; 0x3ef8 <__vector_31+0x38>
    3eee:	e0 91 59 0f 	lds	r30, 0x0F59
    3ef2:	f0 91 5a 0f 	lds	r31, 0x0F5A
    3ef6:	09 95       	icall
}
    3ef8:	ff 91       	pop	r31
    3efa:	ef 91       	pop	r30
    3efc:	bf 91       	pop	r27
    3efe:	af 91       	pop	r26
    3f00:	9f 91       	pop	r25
    3f02:	8f 91       	pop	r24
    3f04:	7f 91       	pop	r23
    3f06:	6f 91       	pop	r22
    3f08:	5f 91       	pop	r21
    3f0a:	4f 91       	pop	r20
    3f0c:	3f 91       	pop	r19
    3f0e:	2f 91       	pop	r18
    3f10:	0f 90       	pop	r0
    3f12:	0f be       	out	0x3f, r0	; 63
    3f14:	0f 90       	pop	r0
    3f16:	1f 90       	pop	r1
    3f18:	18 95       	reti

00003f1a <__vector_32>:
ISR(TIMER3_COMPA_vect)
{
    3f1a:	1f 92       	push	r1
    3f1c:	0f 92       	push	r0
    3f1e:	0f b6       	in	r0, 0x3f	; 63
    3f20:	0f 92       	push	r0
    3f22:	11 24       	eor	r1, r1
    3f24:	2f 93       	push	r18
    3f26:	3f 93       	push	r19
    3f28:	4f 93       	push	r20
    3f2a:	5f 93       	push	r21
    3f2c:	6f 93       	push	r22
    3f2e:	7f 93       	push	r23
    3f30:	8f 93       	push	r24
    3f32:	9f 93       	push	r25
    3f34:	af 93       	push	r26
    3f36:	bf 93       	push	r27
    3f38:	ef 93       	push	r30
    3f3a:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_COMPA_interrupt);
    3f3c:	80 91 5b 0f 	lds	r24, 0x0F5B
    3f40:	90 91 5c 0f 	lds	r25, 0x0F5C
    3f44:	89 2b       	or	r24, r25
    3f46:	29 f0       	breq	.+10     	; 0x3f52 <__vector_32+0x38>
    3f48:	e0 91 5b 0f 	lds	r30, 0x0F5B
    3f4c:	f0 91 5c 0f 	lds	r31, 0x0F5C
    3f50:	09 95       	icall
}
    3f52:	ff 91       	pop	r31
    3f54:	ef 91       	pop	r30
    3f56:	bf 91       	pop	r27
    3f58:	af 91       	pop	r26
    3f5a:	9f 91       	pop	r25
    3f5c:	8f 91       	pop	r24
    3f5e:	7f 91       	pop	r23
    3f60:	6f 91       	pop	r22
    3f62:	5f 91       	pop	r21
    3f64:	4f 91       	pop	r20
    3f66:	3f 91       	pop	r19
    3f68:	2f 91       	pop	r18
    3f6a:	0f 90       	pop	r0
    3f6c:	0f be       	out	0x3f, r0	; 63
    3f6e:	0f 90       	pop	r0
    3f70:	1f 90       	pop	r1
    3f72:	18 95       	reti

00003f74 <__vector_33>:
ISR(TIMER3_COMPB_vect)
{
    3f74:	1f 92       	push	r1
    3f76:	0f 92       	push	r0
    3f78:	0f b6       	in	r0, 0x3f	; 63
    3f7a:	0f 92       	push	r0
    3f7c:	11 24       	eor	r1, r1
    3f7e:	2f 93       	push	r18
    3f80:	3f 93       	push	r19
    3f82:	4f 93       	push	r20
    3f84:	5f 93       	push	r21
    3f86:	6f 93       	push	r22
    3f88:	7f 93       	push	r23
    3f8a:	8f 93       	push	r24
    3f8c:	9f 93       	push	r25
    3f8e:	af 93       	push	r26
    3f90:	bf 93       	push	r27
    3f92:	ef 93       	push	r30
    3f94:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_COMPB_interrupt);
    3f96:	80 91 5d 0f 	lds	r24, 0x0F5D
    3f9a:	90 91 5e 0f 	lds	r25, 0x0F5E
    3f9e:	89 2b       	or	r24, r25
    3fa0:	29 f0       	breq	.+10     	; 0x3fac <__vector_33+0x38>
    3fa2:	e0 91 5d 0f 	lds	r30, 0x0F5D
    3fa6:	f0 91 5e 0f 	lds	r31, 0x0F5E
    3faa:	09 95       	icall
}
    3fac:	ff 91       	pop	r31
    3fae:	ef 91       	pop	r30
    3fb0:	bf 91       	pop	r27
    3fb2:	af 91       	pop	r26
    3fb4:	9f 91       	pop	r25
    3fb6:	8f 91       	pop	r24
    3fb8:	7f 91       	pop	r23
    3fba:	6f 91       	pop	r22
    3fbc:	5f 91       	pop	r21
    3fbe:	4f 91       	pop	r20
    3fc0:	3f 91       	pop	r19
    3fc2:	2f 91       	pop	r18
    3fc4:	0f 90       	pop	r0
    3fc6:	0f be       	out	0x3f, r0	; 63
    3fc8:	0f 90       	pop	r0
    3fca:	1f 90       	pop	r1
    3fcc:	18 95       	reti

00003fce <__vector_34>:
ISR(TIMER3_COMPC_vect)
{
    3fce:	1f 92       	push	r1
    3fd0:	0f 92       	push	r0
    3fd2:	0f b6       	in	r0, 0x3f	; 63
    3fd4:	0f 92       	push	r0
    3fd6:	11 24       	eor	r1, r1
    3fd8:	2f 93       	push	r18
    3fda:	3f 93       	push	r19
    3fdc:	4f 93       	push	r20
    3fde:	5f 93       	push	r21
    3fe0:	6f 93       	push	r22
    3fe2:	7f 93       	push	r23
    3fe4:	8f 93       	push	r24
    3fe6:	9f 93       	push	r25
    3fe8:	af 93       	push	r26
    3fea:	bf 93       	push	r27
    3fec:	ef 93       	push	r30
    3fee:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_COMPC_interrupt);
    3ff0:	80 91 5f 0f 	lds	r24, 0x0F5F
    3ff4:	90 91 60 0f 	lds	r25, 0x0F60
    3ff8:	89 2b       	or	r24, r25
    3ffa:	29 f0       	breq	.+10     	; 0x4006 <__vector_34+0x38>
    3ffc:	e0 91 5f 0f 	lds	r30, 0x0F5F
    4000:	f0 91 60 0f 	lds	r31, 0x0F60
    4004:	09 95       	icall
}
    4006:	ff 91       	pop	r31
    4008:	ef 91       	pop	r30
    400a:	bf 91       	pop	r27
    400c:	af 91       	pop	r26
    400e:	9f 91       	pop	r25
    4010:	8f 91       	pop	r24
    4012:	7f 91       	pop	r23
    4014:	6f 91       	pop	r22
    4016:	5f 91       	pop	r21
    4018:	4f 91       	pop	r20
    401a:	3f 91       	pop	r19
    401c:	2f 91       	pop	r18
    401e:	0f 90       	pop	r0
    4020:	0f be       	out	0x3f, r0	; 63
    4022:	0f 90       	pop	r0
    4024:	1f 90       	pop	r1
    4026:	18 95       	reti

00004028 <__vector_41>:
ISR(TIMER4_CAPT_vect)
{
    4028:	1f 92       	push	r1
    402a:	0f 92       	push	r0
    402c:	0f b6       	in	r0, 0x3f	; 63
    402e:	0f 92       	push	r0
    4030:	11 24       	eor	r1, r1
    4032:	2f 93       	push	r18
    4034:	3f 93       	push	r19
    4036:	4f 93       	push	r20
    4038:	5f 93       	push	r21
    403a:	6f 93       	push	r22
    403c:	7f 93       	push	r23
    403e:	8f 93       	push	r24
    4040:	9f 93       	push	r25
    4042:	af 93       	push	r26
    4044:	bf 93       	push	r27
    4046:	ef 93       	push	r30
    4048:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_CAPT_interrupt);
    404a:	80 91 63 0f 	lds	r24, 0x0F63
    404e:	90 91 64 0f 	lds	r25, 0x0F64
    4052:	89 2b       	or	r24, r25
    4054:	29 f0       	breq	.+10     	; 0x4060 <__vector_41+0x38>
    4056:	e0 91 63 0f 	lds	r30, 0x0F63
    405a:	f0 91 64 0f 	lds	r31, 0x0F64
    405e:	09 95       	icall
}
    4060:	ff 91       	pop	r31
    4062:	ef 91       	pop	r30
    4064:	bf 91       	pop	r27
    4066:	af 91       	pop	r26
    4068:	9f 91       	pop	r25
    406a:	8f 91       	pop	r24
    406c:	7f 91       	pop	r23
    406e:	6f 91       	pop	r22
    4070:	5f 91       	pop	r21
    4072:	4f 91       	pop	r20
    4074:	3f 91       	pop	r19
    4076:	2f 91       	pop	r18
    4078:	0f 90       	pop	r0
    407a:	0f be       	out	0x3f, r0	; 63
    407c:	0f 90       	pop	r0
    407e:	1f 90       	pop	r1
    4080:	18 95       	reti

00004082 <__vector_42>:
ISR(TIMER4_COMPA_vect)
{
    4082:	1f 92       	push	r1
    4084:	0f 92       	push	r0
    4086:	0f b6       	in	r0, 0x3f	; 63
    4088:	0f 92       	push	r0
    408a:	11 24       	eor	r1, r1
    408c:	2f 93       	push	r18
    408e:	3f 93       	push	r19
    4090:	4f 93       	push	r20
    4092:	5f 93       	push	r21
    4094:	6f 93       	push	r22
    4096:	7f 93       	push	r23
    4098:	8f 93       	push	r24
    409a:	9f 93       	push	r25
    409c:	af 93       	push	r26
    409e:	bf 93       	push	r27
    40a0:	ef 93       	push	r30
    40a2:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_COMPA_interrupt);
    40a4:	80 91 65 0f 	lds	r24, 0x0F65
    40a8:	90 91 66 0f 	lds	r25, 0x0F66
    40ac:	89 2b       	or	r24, r25
    40ae:	29 f0       	breq	.+10     	; 0x40ba <__vector_42+0x38>
    40b0:	e0 91 65 0f 	lds	r30, 0x0F65
    40b4:	f0 91 66 0f 	lds	r31, 0x0F66
    40b8:	09 95       	icall
}
    40ba:	ff 91       	pop	r31
    40bc:	ef 91       	pop	r30
    40be:	bf 91       	pop	r27
    40c0:	af 91       	pop	r26
    40c2:	9f 91       	pop	r25
    40c4:	8f 91       	pop	r24
    40c6:	7f 91       	pop	r23
    40c8:	6f 91       	pop	r22
    40ca:	5f 91       	pop	r21
    40cc:	4f 91       	pop	r20
    40ce:	3f 91       	pop	r19
    40d0:	2f 91       	pop	r18
    40d2:	0f 90       	pop	r0
    40d4:	0f be       	out	0x3f, r0	; 63
    40d6:	0f 90       	pop	r0
    40d8:	1f 90       	pop	r1
    40da:	18 95       	reti

000040dc <__vector_43>:
ISR(TIMER4_COMPB_vect)
{
    40dc:	1f 92       	push	r1
    40de:	0f 92       	push	r0
    40e0:	0f b6       	in	r0, 0x3f	; 63
    40e2:	0f 92       	push	r0
    40e4:	11 24       	eor	r1, r1
    40e6:	2f 93       	push	r18
    40e8:	3f 93       	push	r19
    40ea:	4f 93       	push	r20
    40ec:	5f 93       	push	r21
    40ee:	6f 93       	push	r22
    40f0:	7f 93       	push	r23
    40f2:	8f 93       	push	r24
    40f4:	9f 93       	push	r25
    40f6:	af 93       	push	r26
    40f8:	bf 93       	push	r27
    40fa:	ef 93       	push	r30
    40fc:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_COMPB_interrupt);
    40fe:	80 91 67 0f 	lds	r24, 0x0F67
    4102:	90 91 68 0f 	lds	r25, 0x0F68
    4106:	89 2b       	or	r24, r25
    4108:	29 f0       	breq	.+10     	; 0x4114 <__vector_43+0x38>
    410a:	e0 91 67 0f 	lds	r30, 0x0F67
    410e:	f0 91 68 0f 	lds	r31, 0x0F68
    4112:	09 95       	icall
}
    4114:	ff 91       	pop	r31
    4116:	ef 91       	pop	r30
    4118:	bf 91       	pop	r27
    411a:	af 91       	pop	r26
    411c:	9f 91       	pop	r25
    411e:	8f 91       	pop	r24
    4120:	7f 91       	pop	r23
    4122:	6f 91       	pop	r22
    4124:	5f 91       	pop	r21
    4126:	4f 91       	pop	r20
    4128:	3f 91       	pop	r19
    412a:	2f 91       	pop	r18
    412c:	0f 90       	pop	r0
    412e:	0f be       	out	0x3f, r0	; 63
    4130:	0f 90       	pop	r0
    4132:	1f 90       	pop	r1
    4134:	18 95       	reti

00004136 <__vector_44>:
ISR(TIMER4_COMPC_vect)
{
    4136:	1f 92       	push	r1
    4138:	0f 92       	push	r0
    413a:	0f b6       	in	r0, 0x3f	; 63
    413c:	0f 92       	push	r0
    413e:	11 24       	eor	r1, r1
    4140:	2f 93       	push	r18
    4142:	3f 93       	push	r19
    4144:	4f 93       	push	r20
    4146:	5f 93       	push	r21
    4148:	6f 93       	push	r22
    414a:	7f 93       	push	r23
    414c:	8f 93       	push	r24
    414e:	9f 93       	push	r25
    4150:	af 93       	push	r26
    4152:	bf 93       	push	r27
    4154:	ef 93       	push	r30
    4156:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_COMPC_interrupt);
    4158:	80 91 69 0f 	lds	r24, 0x0F69
    415c:	90 91 6a 0f 	lds	r25, 0x0F6A
    4160:	89 2b       	or	r24, r25
    4162:	29 f0       	breq	.+10     	; 0x416e <__vector_44+0x38>
    4164:	e0 91 69 0f 	lds	r30, 0x0F69
    4168:	f0 91 6a 0f 	lds	r31, 0x0F6A
    416c:	09 95       	icall
}
    416e:	ff 91       	pop	r31
    4170:	ef 91       	pop	r30
    4172:	bf 91       	pop	r27
    4174:	af 91       	pop	r26
    4176:	9f 91       	pop	r25
    4178:	8f 91       	pop	r24
    417a:	7f 91       	pop	r23
    417c:	6f 91       	pop	r22
    417e:	5f 91       	pop	r21
    4180:	4f 91       	pop	r20
    4182:	3f 91       	pop	r19
    4184:	2f 91       	pop	r18
    4186:	0f 90       	pop	r0
    4188:	0f be       	out	0x3f, r0	; 63
    418a:	0f 90       	pop	r0
    418c:	1f 90       	pop	r1
    418e:	18 95       	reti

00004190 <__vector_46>:
ISR(TIMER5_CAPT_vect)
{
    4190:	1f 92       	push	r1
    4192:	0f 92       	push	r0
    4194:	0f b6       	in	r0, 0x3f	; 63
    4196:	0f 92       	push	r0
    4198:	11 24       	eor	r1, r1
    419a:	2f 93       	push	r18
    419c:	3f 93       	push	r19
    419e:	4f 93       	push	r20
    41a0:	5f 93       	push	r21
    41a2:	6f 93       	push	r22
    41a4:	7f 93       	push	r23
    41a6:	8f 93       	push	r24
    41a8:	9f 93       	push	r25
    41aa:	af 93       	push	r26
    41ac:	bf 93       	push	r27
    41ae:	ef 93       	push	r30
    41b0:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_CAPT_interrupt);
    41b2:	80 91 6d 0f 	lds	r24, 0x0F6D
    41b6:	90 91 6e 0f 	lds	r25, 0x0F6E
    41ba:	89 2b       	or	r24, r25
    41bc:	29 f0       	breq	.+10     	; 0x41c8 <__vector_46+0x38>
    41be:	e0 91 6d 0f 	lds	r30, 0x0F6D
    41c2:	f0 91 6e 0f 	lds	r31, 0x0F6E
    41c6:	09 95       	icall
}
    41c8:	ff 91       	pop	r31
    41ca:	ef 91       	pop	r30
    41cc:	bf 91       	pop	r27
    41ce:	af 91       	pop	r26
    41d0:	9f 91       	pop	r25
    41d2:	8f 91       	pop	r24
    41d4:	7f 91       	pop	r23
    41d6:	6f 91       	pop	r22
    41d8:	5f 91       	pop	r21
    41da:	4f 91       	pop	r20
    41dc:	3f 91       	pop	r19
    41de:	2f 91       	pop	r18
    41e0:	0f 90       	pop	r0
    41e2:	0f be       	out	0x3f, r0	; 63
    41e4:	0f 90       	pop	r0
    41e6:	1f 90       	pop	r1
    41e8:	18 95       	reti

000041ea <__vector_47>:
ISR(TIMER5_COMPA_vect)
{
    41ea:	1f 92       	push	r1
    41ec:	0f 92       	push	r0
    41ee:	0f b6       	in	r0, 0x3f	; 63
    41f0:	0f 92       	push	r0
    41f2:	11 24       	eor	r1, r1
    41f4:	2f 93       	push	r18
    41f6:	3f 93       	push	r19
    41f8:	4f 93       	push	r20
    41fa:	5f 93       	push	r21
    41fc:	6f 93       	push	r22
    41fe:	7f 93       	push	r23
    4200:	8f 93       	push	r24
    4202:	9f 93       	push	r25
    4204:	af 93       	push	r26
    4206:	bf 93       	push	r27
    4208:	ef 93       	push	r30
    420a:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_COMPA_interrupt);
    420c:	80 91 6f 0f 	lds	r24, 0x0F6F
    4210:	90 91 70 0f 	lds	r25, 0x0F70
    4214:	89 2b       	or	r24, r25
    4216:	29 f0       	breq	.+10     	; 0x4222 <__vector_47+0x38>
    4218:	e0 91 6f 0f 	lds	r30, 0x0F6F
    421c:	f0 91 70 0f 	lds	r31, 0x0F70
    4220:	09 95       	icall
}
    4222:	ff 91       	pop	r31
    4224:	ef 91       	pop	r30
    4226:	bf 91       	pop	r27
    4228:	af 91       	pop	r26
    422a:	9f 91       	pop	r25
    422c:	8f 91       	pop	r24
    422e:	7f 91       	pop	r23
    4230:	6f 91       	pop	r22
    4232:	5f 91       	pop	r21
    4234:	4f 91       	pop	r20
    4236:	3f 91       	pop	r19
    4238:	2f 91       	pop	r18
    423a:	0f 90       	pop	r0
    423c:	0f be       	out	0x3f, r0	; 63
    423e:	0f 90       	pop	r0
    4240:	1f 90       	pop	r1
    4242:	18 95       	reti

00004244 <__vector_48>:
ISR(TIMER5_COMPB_vect)
{
    4244:	1f 92       	push	r1
    4246:	0f 92       	push	r0
    4248:	0f b6       	in	r0, 0x3f	; 63
    424a:	0f 92       	push	r0
    424c:	11 24       	eor	r1, r1
    424e:	2f 93       	push	r18
    4250:	3f 93       	push	r19
    4252:	4f 93       	push	r20
    4254:	5f 93       	push	r21
    4256:	6f 93       	push	r22
    4258:	7f 93       	push	r23
    425a:	8f 93       	push	r24
    425c:	9f 93       	push	r25
    425e:	af 93       	push	r26
    4260:	bf 93       	push	r27
    4262:	ef 93       	push	r30
    4264:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_COMPB_interrupt);
    4266:	80 91 71 0f 	lds	r24, 0x0F71
    426a:	90 91 72 0f 	lds	r25, 0x0F72
    426e:	89 2b       	or	r24, r25
    4270:	29 f0       	breq	.+10     	; 0x427c <__vector_48+0x38>
    4272:	e0 91 71 0f 	lds	r30, 0x0F71
    4276:	f0 91 72 0f 	lds	r31, 0x0F72
    427a:	09 95       	icall
}
    427c:	ff 91       	pop	r31
    427e:	ef 91       	pop	r30
    4280:	bf 91       	pop	r27
    4282:	af 91       	pop	r26
    4284:	9f 91       	pop	r25
    4286:	8f 91       	pop	r24
    4288:	7f 91       	pop	r23
    428a:	6f 91       	pop	r22
    428c:	5f 91       	pop	r21
    428e:	4f 91       	pop	r20
    4290:	3f 91       	pop	r19
    4292:	2f 91       	pop	r18
    4294:	0f 90       	pop	r0
    4296:	0f be       	out	0x3f, r0	; 63
    4298:	0f 90       	pop	r0
    429a:	1f 90       	pop	r1
    429c:	18 95       	reti

0000429e <__vector_49>:
ISR(TIMER5_COMPC_vect)
{
    429e:	1f 92       	push	r1
    42a0:	0f 92       	push	r0
    42a2:	0f b6       	in	r0, 0x3f	; 63
    42a4:	0f 92       	push	r0
    42a6:	11 24       	eor	r1, r1
    42a8:	2f 93       	push	r18
    42aa:	3f 93       	push	r19
    42ac:	4f 93       	push	r20
    42ae:	5f 93       	push	r21
    42b0:	6f 93       	push	r22
    42b2:	7f 93       	push	r23
    42b4:	8f 93       	push	r24
    42b6:	9f 93       	push	r25
    42b8:	af 93       	push	r26
    42ba:	bf 93       	push	r27
    42bc:	ef 93       	push	r30
    42be:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_COMPC_interrupt);
    42c0:	80 91 73 0f 	lds	r24, 0x0F73
    42c4:	90 91 74 0f 	lds	r25, 0x0F74
    42c8:	89 2b       	or	r24, r25
    42ca:	29 f0       	breq	.+10     	; 0x42d6 <__vector_49+0x38>
    42cc:	e0 91 73 0f 	lds	r30, 0x0F73
    42d0:	f0 91 74 0f 	lds	r31, 0x0F74
    42d4:	09 95       	icall
}
    42d6:	ff 91       	pop	r31
    42d8:	ef 91       	pop	r30
    42da:	bf 91       	pop	r27
    42dc:	af 91       	pop	r26
    42de:	9f 91       	pop	r25
    42e0:	8f 91       	pop	r24
    42e2:	7f 91       	pop	r23
    42e4:	6f 91       	pop	r22
    42e6:	5f 91       	pop	r21
    42e8:	4f 91       	pop	r20
    42ea:	3f 91       	pop	r19
    42ec:	2f 91       	pop	r18
    42ee:	0f 90       	pop	r0
    42f0:	0f be       	out	0x3f, r0	; 63
    42f2:	0f 90       	pop	r0
    42f4:	1f 90       	pop	r1
    42f6:	18 95       	reti

000042f8 <__vector_default>:

ISR(BADISR_vect)
{
    42f8:	1f 92       	push	r1
    42fa:	0f 92       	push	r0
    42fc:	0f b6       	in	r0, 0x3f	; 63
    42fe:	0f 92       	push	r0
    4300:	11 24       	eor	r1, r1
    4302:	2f 93       	push	r18
    4304:	3f 93       	push	r19
    4306:	4f 93       	push	r20
    4308:	5f 93       	push	r21
    430a:	6f 93       	push	r22
    430c:	7f 93       	push	r23
    430e:	8f 93       	push	r24
    4310:	9f 93       	push	r25
    4312:	af 93       	push	r26
    4314:	bf 93       	push	r27
    4316:	ef 93       	push	r30
    4318:	ff 93       	push	r31
  rprintf("BAD_vect called!");
    431a:	00 d0       	rcall	.+0      	; 0x431c <__vector_default+0x24>
    431c:	0f 92       	push	r0
    431e:	81 e0       	ldi	r24, 0x01	; 1
    4320:	ed b7       	in	r30, 0x3d	; 61
    4322:	fe b7       	in	r31, 0x3e	; 62
    4324:	81 83       	std	Z+1, r24	; 0x01
    4326:	83 ed       	ldi	r24, 0xD3	; 211
    4328:	91 e0       	ldi	r25, 0x01	; 1
    432a:	93 83       	std	Z+3, r25	; 0x03
    432c:	82 83       	std	Z+2, r24	; 0x02
    432e:	0e 94 46 29 	call	0x528c	; 0x528c <rprintf1RamRom>
    4332:	0f 90       	pop	r0
    4334:	0f 90       	pop	r0
    4336:	0f 90       	pop	r0
}
    4338:	ff 91       	pop	r31
    433a:	ef 91       	pop	r30
    433c:	bf 91       	pop	r27
    433e:	af 91       	pop	r26
    4340:	9f 91       	pop	r25
    4342:	8f 91       	pop	r24
    4344:	7f 91       	pop	r23
    4346:	6f 91       	pop	r22
    4348:	5f 91       	pop	r21
    434a:	4f 91       	pop	r20
    434c:	3f 91       	pop	r19
    434e:	2f 91       	pop	r18
    4350:	0f 90       	pop	r0
    4352:	0f be       	out	0x3f, r0	; 63
    4354:	0f 90       	pop	r0
    4356:	1f 90       	pop	r1
    4358:	18 95       	reti

0000435a <uartSetRxHandler>:
}

void uartSetRxHandler(u08 nUart, void (*rx_func)(unsigned char c))
{
	// make sure the uart number is within bounds
	if(nUart < 4)
    435a:	84 30       	cpi	r24, 0x04	; 4
    435c:	40 f4       	brcc	.+16     	; 0x436e <uartSetRxHandler+0x14>
	{
		// set the receive interrupt to run the supplied user function
		UartRxFunc[nUart] = rx_func;
    435e:	e8 2f       	mov	r30, r24
    4360:	f0 e0       	ldi	r31, 0x00	; 0
    4362:	ee 0f       	add	r30, r30
    4364:	ff 1f       	adc	r31, r31
    4366:	e9 54       	subi	r30, 0x49	; 73
    4368:	fe 4e       	sbci	r31, 0xEE	; 238
    436a:	71 83       	std	Z+1, r23	; 0x01
    436c:	60 83       	st	Z, r22
    436e:	08 95       	ret

00004370 <uartSetBaudRate>:
	}
}

void uartSetBaudRate(u08 nUart, u32 baudrate)
{
    4370:	1f 93       	push	r17
    4372:	18 2f       	mov	r17, r24
    4374:	9a 01       	movw	r18, r20
    4376:	ab 01       	movw	r20, r22
	// calculate division factor for requested baud rate, and set it
	u16 bauddiv = ((F_CPU+(baudrate*8L))/(baudrate*16L)-1);
    4378:	ca 01       	movw	r24, r20
    437a:	b9 01       	movw	r22, r18
    437c:	60 58       	subi	r22, 0x80	; 128
    437e:	7b 47       	sbci	r23, 0x7B	; 123
    4380:	81 4e       	sbci	r24, 0xE1	; 225
    4382:	9f 4f       	sbci	r25, 0xFF	; 255
    4384:	f3 e0       	ldi	r31, 0x03	; 3
    4386:	66 0f       	add	r22, r22
    4388:	77 1f       	adc	r23, r23
    438a:	88 1f       	adc	r24, r24
    438c:	99 1f       	adc	r25, r25
    438e:	fa 95       	dec	r31
    4390:	d1 f7       	brne	.-12     	; 0x4386 <uartSetBaudRate+0x16>
    4392:	e4 e0       	ldi	r30, 0x04	; 4
    4394:	22 0f       	add	r18, r18
    4396:	33 1f       	adc	r19, r19
    4398:	44 1f       	adc	r20, r20
    439a:	55 1f       	adc	r21, r21
    439c:	ea 95       	dec	r30
    439e:	d1 f7       	brne	.-12     	; 0x4394 <uartSetBaudRate+0x24>
    43a0:	0e 94 9c 30 	call	0x6138	; 0x6138 <__udivmodsi4>
    43a4:	21 50       	subi	r18, 0x01	; 1
    43a6:	30 40       	sbci	r19, 0x00	; 0
	if(nUart==3)
    43a8:	13 30       	cpi	r17, 0x03	; 3
    43aa:	29 f4       	brne	.+10     	; 0x43b6 <uartSetBaudRate+0x46>
	{
		outb(UBRR3L, bauddiv);
    43ac:	20 93 34 01 	sts	0x0134, r18
		#ifdef UBRR3H
		outb(UBRR3H, bauddiv>>8);
    43b0:	30 93 35 01 	sts	0x0135, r19
    43b4:	12 c0       	rjmp	.+36     	; 0x43da <uartSetBaudRate+0x6a>
		#endif
	}
	else if(nUart==2)
    43b6:	12 30       	cpi	r17, 0x02	; 2
    43b8:	29 f4       	brne	.+10     	; 0x43c4 <uartSetBaudRate+0x54>
	{
		outb(UBRR2L, bauddiv);
    43ba:	20 93 d4 00 	sts	0x00D4, r18
		#ifdef UBRR2H
		outb(UBRR2H, bauddiv>>8);
    43be:	30 93 d5 00 	sts	0x00D5, r19
    43c2:	0b c0       	rjmp	.+22     	; 0x43da <uartSetBaudRate+0x6a>
		#endif
	}
	else if(nUart==1)
    43c4:	11 30       	cpi	r17, 0x01	; 1
    43c6:	29 f4       	brne	.+10     	; 0x43d2 <uartSetBaudRate+0x62>
	{
		outb(UBRR1L, bauddiv);
    43c8:	20 93 cc 00 	sts	0x00CC, r18
		#ifdef UBRR1H
		outb(UBRR1H, bauddiv>>8);
    43cc:	30 93 cd 00 	sts	0x00CD, r19
    43d0:	04 c0       	rjmp	.+8      	; 0x43da <uartSetBaudRate+0x6a>
		#endif
	}
	else
	{
		outb(UBRR0L, bauddiv);
    43d2:	20 93 c4 00 	sts	0x00C4, r18
		#ifdef UBRR0H
		outb(UBRR0H, bauddiv>>8);
    43d6:	30 93 c5 00 	sts	0x00C5, r19
		#endif
	}
}
    43da:	1f 91       	pop	r17
    43dc:	08 95       	ret

000043de <uartGetRxBuffer>:

cBuffer* uartGetRxBuffer(u08 nUart)
{
    43de:	28 2f       	mov	r18, r24
    43e0:	30 e0       	ldi	r19, 0x00	; 0
    43e2:	a3 e0       	ldi	r26, 0x03	; 3
    43e4:	22 0f       	add	r18, r18
    43e6:	33 1f       	adc	r19, r19
    43e8:	aa 95       	dec	r26
    43ea:	e1 f7       	brne	.-8      	; 0x43e4 <uartGetRxBuffer+0x6>
    43ec:	23 5c       	subi	r18, 0xC3	; 195
    43ee:	3d 4e       	sbci	r19, 0xED	; 237
	// return rx buffer pointer
	return &uartRxBuffer[nUart];
}
    43f0:	c9 01       	movw	r24, r18
    43f2:	08 95       	ret

000043f4 <uartGetTxBuffer>:

cBuffer* uartGetTxBuffer(u08 nUart)
{
    43f4:	28 2f       	mov	r18, r24
    43f6:	30 e0       	ldi	r19, 0x00	; 0
    43f8:	b3 e0       	ldi	r27, 0x03	; 3
    43fa:	22 0f       	add	r18, r18
    43fc:	33 1f       	adc	r19, r19
    43fe:	ba 95       	dec	r27
    4400:	e1 f7       	brne	.-8      	; 0x43fa <uartGetTxBuffer+0x6>
    4402:	2f 59       	subi	r18, 0x9F	; 159
    4404:	3d 4e       	sbci	r19, 0xED	; 237
	// return tx buffer pointer
	return &uartTxBuffer[nUart];
}
    4406:	c9 01       	movw	r24, r18
    4408:	08 95       	ret

0000440a <uartSendByte>:

void uartSendByte(u08 nUart, u08 txData)
{
    440a:	e8 2f       	mov	r30, r24
	// wait for the transmitter to be ready
//	while(!uartReadyTx[nUart]);
	// send byte
	if(nUart==3)
    440c:	83 30       	cpi	r24, 0x03	; 3
    440e:	39 f4       	brne	.+14     	; 0x441e <uartSendByte+0x14>
	{
		while(!(UCSR3A & (1<<UDRE3)));
    4410:	80 91 30 01 	lds	r24, 0x0130
    4414:	85 ff       	sbrs	r24, 5
    4416:	fc cf       	rjmp	.-8      	; 0x4410 <uartSendByte+0x6>
		outb(UDR3, txData);
    4418:	60 93 36 01 	sts	0x0136, r22
    441c:	18 c0       	rjmp	.+48     	; 0x444e <uartSendByte+0x44>
	}
	else if(nUart==2)
    441e:	82 30       	cpi	r24, 0x02	; 2
    4420:	39 f4       	brne	.+14     	; 0x4430 <uartSendByte+0x26>
	{
		while(!(UCSR2A & (1<<UDRE2)));
    4422:	80 91 d0 00 	lds	r24, 0x00D0
    4426:	85 ff       	sbrs	r24, 5
    4428:	fc cf       	rjmp	.-8      	; 0x4422 <uartSendByte+0x18>
		outb(UDR2, txData);
    442a:	60 93 d6 00 	sts	0x00D6, r22
    442e:	0f c0       	rjmp	.+30     	; 0x444e <uartSendByte+0x44>
	}
	else if(nUart==1)
    4430:	81 30       	cpi	r24, 0x01	; 1
    4432:	39 f4       	brne	.+14     	; 0x4442 <uartSendByte+0x38>
	{
		while(!(UCSR1A & (1<<UDRE1)));
    4434:	80 91 c8 00 	lds	r24, 0x00C8
    4438:	85 ff       	sbrs	r24, 5
    443a:	fc cf       	rjmp	.-8      	; 0x4434 <uartSendByte+0x2a>
		outb(UDR1, txData);
    443c:	60 93 ce 00 	sts	0x00CE, r22
    4440:	06 c0       	rjmp	.+12     	; 0x444e <uartSendByte+0x44>
	}
	else
	{
		while(!(UCSR0A & (1<<UDRE0)));
    4442:	80 91 c0 00 	lds	r24, 0x00C0
    4446:	85 ff       	sbrs	r24, 5
    4448:	fc cf       	rjmp	.-8      	; 0x4442 <uartSendByte+0x38>
		outb(UDR0, txData);
    444a:	60 93 c6 00 	sts	0x00C6, r22
	}
	// set ready state to FALSE
	uartReadyTx[nUart] = FALSE;
    444e:	f0 e0       	ldi	r31, 0x00	; 0
    4450:	e7 5c       	subi	r30, 0xC7	; 199
    4452:	fd 4e       	sbci	r31, 0xED	; 237
    4454:	10 82       	st	Z, r1
}
    4456:	08 95       	ret

00004458 <uart0SendByte>:

void uart0SendByte(u08 data)
{
    4458:	68 2f       	mov	r22, r24
	// send byte on UART0
	uartSendByte(0, data);
    445a:	80 e0       	ldi	r24, 0x00	; 0
    445c:	0e 94 05 22 	call	0x440a	; 0x440a <uartSendByte>
}
    4460:	08 95       	ret

00004462 <uart1SendByte>:

void uart1SendByte(u08 data)
{
    4462:	68 2f       	mov	r22, r24
	// send byte on UART1
	uartSendByte(1, data);
    4464:	81 e0       	ldi	r24, 0x01	; 1
    4466:	0e 94 05 22 	call	0x440a	; 0x440a <uartSendByte>
}
    446a:	08 95       	ret

0000446c <uart2SendByte>:

void uart2SendByte(u08 data)
{
    446c:	68 2f       	mov	r22, r24
	// send byte on UART2
	uartSendByte(2, data);
    446e:	82 e0       	ldi	r24, 0x02	; 2
    4470:	0e 94 05 22 	call	0x440a	; 0x440a <uartSendByte>
}
    4474:	08 95       	ret

00004476 <uart3SendByte>:

void uart3SendByte(u08 data)
{
    4476:	68 2f       	mov	r22, r24
	// send byte on UART3
	uartSendByte(3, data);
    4478:	83 e0       	ldi	r24, 0x03	; 3
    447a:	0e 94 05 22 	call	0x440a	; 0x440a <uartSendByte>
}
    447e:	08 95       	ret

00004480 <uartReceiveBufferIsEmpty>:
	// flush all data from receive buffer
	bufferFlush(&uartRxBuffer[nUart]);
}

u08 uartReceiveBufferIsEmpty(u08 nUart)
{
    4480:	20 e0       	ldi	r18, 0x00	; 0
    4482:	e8 2f       	mov	r30, r24
    4484:	f0 e0       	ldi	r31, 0x00	; 0
    4486:	83 e0       	ldi	r24, 0x03	; 3
    4488:	ee 0f       	add	r30, r30
    448a:	ff 1f       	adc	r31, r31
    448c:	8a 95       	dec	r24
    448e:	e1 f7       	brne	.-8      	; 0x4488 <uartReceiveBufferIsEmpty+0x8>
    4490:	ef 5b       	subi	r30, 0xBF	; 191
    4492:	fd 4e       	sbci	r31, 0xED	; 237
    4494:	80 81       	ld	r24, Z
    4496:	91 81       	ldd	r25, Z+1	; 0x01
    4498:	89 2b       	or	r24, r25
    449a:	09 f4       	brne	.+2      	; 0x449e <uartReceiveBufferIsEmpty+0x1e>
    449c:	21 e0       	ldi	r18, 0x01	; 1
	return (uartRxBuffer[nUart].datalength == 0);
}
    449e:	82 2f       	mov	r24, r18
    44a0:	08 95       	ret

000044a2 <uartReceiveService>:
	}
}

// UART Receive Complete Interrupt Function
void uartReceiveService(u08 nUart)
{
    44a2:	cf 93       	push	r28
    44a4:	df 93       	push	r29
	u08 c;
	// get received char
	if(nUart==3)
    44a6:	83 30       	cpi	r24, 0x03	; 3
    44a8:	19 f4       	brne	.+6      	; 0x44b0 <uartReceiveService+0xe>
		c = inb(UDR3);
    44aa:	60 91 36 01 	lds	r22, 0x0136
    44ae:	0c c0       	rjmp	.+24     	; 0x44c8 <uartReceiveService+0x26>
	else if(nUart==2)
    44b0:	82 30       	cpi	r24, 0x02	; 2
    44b2:	19 f4       	brne	.+6      	; 0x44ba <uartReceiveService+0x18>
		c = inb(UDR2);
    44b4:	60 91 d6 00 	lds	r22, 0x00D6
    44b8:	07 c0       	rjmp	.+14     	; 0x44c8 <uartReceiveService+0x26>
	else if(nUart==1)
    44ba:	81 30       	cpi	r24, 0x01	; 1
    44bc:	19 f4       	brne	.+6      	; 0x44c4 <uartReceiveService+0x22>
		c = inb(UDR1);
    44be:	60 91 ce 00 	lds	r22, 0x00CE
    44c2:	02 c0       	rjmp	.+4      	; 0x44c8 <uartReceiveService+0x26>
	else
		c = inb(UDR0);
    44c4:	60 91 c6 00 	lds	r22, 0x00C6

	// if there's a user function to handle this receive event
	if(UartRxFunc[nUart])
    44c8:	28 2f       	mov	r18, r24
    44ca:	30 e0       	ldi	r19, 0x00	; 0
    44cc:	e9 01       	movw	r28, r18
    44ce:	cc 0f       	add	r28, r28
    44d0:	dd 1f       	adc	r29, r29
    44d2:	fe 01       	movw	r30, r28
    44d4:	e9 54       	subi	r30, 0x49	; 73
    44d6:	fe 4e       	sbci	r31, 0xEE	; 238
    44d8:	80 81       	ld	r24, Z
    44da:	91 81       	ldd	r25, Z+1	; 0x01
    44dc:	89 2b       	or	r24, r25
    44de:	31 f0       	breq	.+12     	; 0x44ec <uartReceiveService+0x4a>
	{
		// call it and pass the received data
		UartRxFunc[nUart](c);
    44e0:	01 90       	ld	r0, Z+
    44e2:	f0 81       	ld	r31, Z
    44e4:	e0 2d       	mov	r30, r0
    44e6:	86 2f       	mov	r24, r22
    44e8:	09 95       	icall
    44ea:	14 c0       	rjmp	.+40     	; 0x4514 <uartReceiveService+0x72>
	else
	{
		// otherwise do default processing
		// put received char in buffer
		// check if there's space
		if( !bufferAddToEnd(&uartRxBuffer[nUart], c) )
    44ec:	93 e0       	ldi	r25, 0x03	; 3
    44ee:	22 0f       	add	r18, r18
    44f0:	33 1f       	adc	r19, r19
    44f2:	9a 95       	dec	r25
    44f4:	e1 f7       	brne	.-8      	; 0x44ee <uartReceiveService+0x4c>
    44f6:	c9 01       	movw	r24, r18
    44f8:	83 5c       	subi	r24, 0xC3	; 195
    44fa:	9d 4e       	sbci	r25, 0xED	; 237
    44fc:	0e 94 5d 26 	call	0x4cba	; 0x4cba <bufferAddToEnd>
    4500:	88 23       	and	r24, r24
    4502:	41 f4       	brne	.+16     	; 0x4514 <uartReceiveService+0x72>
		{
			// no space in buffer
			// count overflow
			uartRxOverflow[nUart]++;
    4504:	fe 01       	movw	r30, r28
    4506:	ef 57       	subi	r30, 0x7F	; 127
    4508:	fd 4e       	sbci	r31, 0xED	; 237
    450a:	80 81       	ld	r24, Z
    450c:	91 81       	ldd	r25, Z+1	; 0x01
    450e:	01 96       	adiw	r24, 0x01	; 1
    4510:	91 83       	std	Z+1, r25	; 0x01
    4512:	80 83       	st	Z, r24
		}
	}
}
    4514:	df 91       	pop	r29
    4516:	cf 91       	pop	r28
    4518:	08 95       	ret

0000451a <__vector_54>:
{
	uartReceiveService(2);
}

UART_INTERRUPT_HANDLER(SIG_USART3_RECV)      
{
    451a:	1f 92       	push	r1
    451c:	0f 92       	push	r0
    451e:	0f b6       	in	r0, 0x3f	; 63
    4520:	0f 92       	push	r0
    4522:	11 24       	eor	r1, r1
    4524:	2f 93       	push	r18
    4526:	3f 93       	push	r19
    4528:	4f 93       	push	r20
    452a:	5f 93       	push	r21
    452c:	6f 93       	push	r22
    452e:	7f 93       	push	r23
    4530:	8f 93       	push	r24
    4532:	9f 93       	push	r25
    4534:	af 93       	push	r26
    4536:	bf 93       	push	r27
    4538:	ef 93       	push	r30
    453a:	ff 93       	push	r31
	uartReceiveService(3);
    453c:	83 e0       	ldi	r24, 0x03	; 3
    453e:	0e 94 51 22 	call	0x44a2	; 0x44a2 <uartReceiveService>
}
    4542:	ff 91       	pop	r31
    4544:	ef 91       	pop	r30
    4546:	bf 91       	pop	r27
    4548:	af 91       	pop	r26
    454a:	9f 91       	pop	r25
    454c:	8f 91       	pop	r24
    454e:	7f 91       	pop	r23
    4550:	6f 91       	pop	r22
    4552:	5f 91       	pop	r21
    4554:	4f 91       	pop	r20
    4556:	3f 91       	pop	r19
    4558:	2f 91       	pop	r18
    455a:	0f 90       	pop	r0
    455c:	0f be       	out	0x3f, r0	; 63
    455e:	0f 90       	pop	r0
    4560:	1f 90       	pop	r1
    4562:	18 95       	reti

00004564 <__vector_51>:
{
	uartReceiveService(1);
}

UART_INTERRUPT_HANDLER(SIG_USART2_RECV)      
{
    4564:	1f 92       	push	r1
    4566:	0f 92       	push	r0
    4568:	0f b6       	in	r0, 0x3f	; 63
    456a:	0f 92       	push	r0
    456c:	11 24       	eor	r1, r1
    456e:	2f 93       	push	r18
    4570:	3f 93       	push	r19
    4572:	4f 93       	push	r20
    4574:	5f 93       	push	r21
    4576:	6f 93       	push	r22
    4578:	7f 93       	push	r23
    457a:	8f 93       	push	r24
    457c:	9f 93       	push	r25
    457e:	af 93       	push	r26
    4580:	bf 93       	push	r27
    4582:	ef 93       	push	r30
    4584:	ff 93       	push	r31
	uartReceiveService(2);
    4586:	82 e0       	ldi	r24, 0x02	; 2
    4588:	0e 94 51 22 	call	0x44a2	; 0x44a2 <uartReceiveService>
}
    458c:	ff 91       	pop	r31
    458e:	ef 91       	pop	r30
    4590:	bf 91       	pop	r27
    4592:	af 91       	pop	r26
    4594:	9f 91       	pop	r25
    4596:	8f 91       	pop	r24
    4598:	7f 91       	pop	r23
    459a:	6f 91       	pop	r22
    459c:	5f 91       	pop	r21
    459e:	4f 91       	pop	r20
    45a0:	3f 91       	pop	r19
    45a2:	2f 91       	pop	r18
    45a4:	0f 90       	pop	r0
    45a6:	0f be       	out	0x3f, r0	; 63
    45a8:	0f 90       	pop	r0
    45aa:	1f 90       	pop	r1
    45ac:	18 95       	reti

000045ae <__vector_36>:
{
	uartReceiveService(0);
}

UART_INTERRUPT_HANDLER(SIG_USART1_RECV)      
{
    45ae:	1f 92       	push	r1
    45b0:	0f 92       	push	r0
    45b2:	0f b6       	in	r0, 0x3f	; 63
    45b4:	0f 92       	push	r0
    45b6:	11 24       	eor	r1, r1
    45b8:	2f 93       	push	r18
    45ba:	3f 93       	push	r19
    45bc:	4f 93       	push	r20
    45be:	5f 93       	push	r21
    45c0:	6f 93       	push	r22
    45c2:	7f 93       	push	r23
    45c4:	8f 93       	push	r24
    45c6:	9f 93       	push	r25
    45c8:	af 93       	push	r26
    45ca:	bf 93       	push	r27
    45cc:	ef 93       	push	r30
    45ce:	ff 93       	push	r31
	uartReceiveService(1);
    45d0:	81 e0       	ldi	r24, 0x01	; 1
    45d2:	0e 94 51 22 	call	0x44a2	; 0x44a2 <uartReceiveService>
}
    45d6:	ff 91       	pop	r31
    45d8:	ef 91       	pop	r30
    45da:	bf 91       	pop	r27
    45dc:	af 91       	pop	r26
    45de:	9f 91       	pop	r25
    45e0:	8f 91       	pop	r24
    45e2:	7f 91       	pop	r23
    45e4:	6f 91       	pop	r22
    45e6:	5f 91       	pop	r21
    45e8:	4f 91       	pop	r20
    45ea:	3f 91       	pop	r19
    45ec:	2f 91       	pop	r18
    45ee:	0f 90       	pop	r0
    45f0:	0f be       	out	0x3f, r0	; 63
    45f2:	0f 90       	pop	r0
    45f4:	1f 90       	pop	r1
    45f6:	18 95       	reti

000045f8 <__vector_25>:
	uartTransmitService(3);
}

	// service UART receive interrupt
UART_INTERRUPT_HANDLER(SIG_USART0_RECV)      
{
    45f8:	1f 92       	push	r1
    45fa:	0f 92       	push	r0
    45fc:	0f b6       	in	r0, 0x3f	; 63
    45fe:	0f 92       	push	r0
    4600:	11 24       	eor	r1, r1
    4602:	2f 93       	push	r18
    4604:	3f 93       	push	r19
    4606:	4f 93       	push	r20
    4608:	5f 93       	push	r21
    460a:	6f 93       	push	r22
    460c:	7f 93       	push	r23
    460e:	8f 93       	push	r24
    4610:	9f 93       	push	r25
    4612:	af 93       	push	r26
    4614:	bf 93       	push	r27
    4616:	ef 93       	push	r30
    4618:	ff 93       	push	r31
	uartReceiveService(0);
    461a:	80 e0       	ldi	r24, 0x00	; 0
    461c:	0e 94 51 22 	call	0x44a2	; 0x44a2 <uartReceiveService>
}
    4620:	ff 91       	pop	r31
    4622:	ef 91       	pop	r30
    4624:	bf 91       	pop	r27
    4626:	af 91       	pop	r26
    4628:	9f 91       	pop	r25
    462a:	8f 91       	pop	r24
    462c:	7f 91       	pop	r23
    462e:	6f 91       	pop	r22
    4630:	5f 91       	pop	r21
    4632:	4f 91       	pop	r20
    4634:	3f 91       	pop	r19
    4636:	2f 91       	pop	r18
    4638:	0f 90       	pop	r0
    463a:	0f be       	out	0x3f, r0	; 63
    463c:	0f 90       	pop	r0
    463e:	1f 90       	pop	r1
    4640:	18 95       	reti

00004642 <uartSendBuffer>:
	// send the first byte to get things going by interrupts
	uartSendByte(nUart, bufferGetFromFront(&uartTxBuffer[nUart]));
}

u08 uartSendBuffer(u08 nUart, char *buffer, u16 nBytes)
{
    4642:	8f 92       	push	r8
    4644:	9f 92       	push	r9
    4646:	af 92       	push	r10
    4648:	bf 92       	push	r11
    464a:	cf 92       	push	r12
    464c:	df 92       	push	r13
    464e:	ef 92       	push	r14
    4650:	ff 92       	push	r15
    4652:	0f 93       	push	r16
    4654:	1f 93       	push	r17
    4656:	cf 93       	push	r28
    4658:	df 93       	push	r29
    465a:	88 2e       	mov	r8, r24
    465c:	db 01       	movw	r26, r22
	register u08 first;
	register u16 i;

	// check if there's space (and that we have any bytes to send at all)
	if((uartTxBuffer[nUart].datalength + nBytes < uartTxBuffer[nUart].size) && nBytes)
    465e:	c8 2e       	mov	r12, r24
    4660:	dd 24       	eor	r13, r13
    4662:	f6 01       	movw	r30, r12
    4664:	13 e0       	ldi	r17, 0x03	; 3
    4666:	ee 0f       	add	r30, r30
    4668:	ff 1f       	adc	r31, r31
    466a:	1a 95       	dec	r17
    466c:	e1 f7       	brne	.-8      	; 0x4666 <uartSendBuffer+0x24>
    466e:	eb 59       	subi	r30, 0x9B	; 155
    4670:	fd 4e       	sbci	r31, 0xED	; 237
    4672:	20 81       	ld	r18, Z
    4674:	31 81       	ldd	r19, Z+1	; 0x01
    4676:	24 0f       	add	r18, r20
    4678:	35 1f       	adc	r19, r21
    467a:	f6 01       	movw	r30, r12
    467c:	73 e0       	ldi	r23, 0x03	; 3
    467e:	ee 0f       	add	r30, r30
    4680:	ff 1f       	adc	r31, r31
    4682:	7a 95       	dec	r23
    4684:	e1 f7       	brne	.-8      	; 0x467e <uartSendBuffer+0x3c>
    4686:	ed 59       	subi	r30, 0x9D	; 157
    4688:	fd 4e       	sbci	r31, 0xED	; 237
    468a:	80 81       	ld	r24, Z
    468c:	91 81       	ldd	r25, Z+1	; 0x01
    468e:	28 17       	cp	r18, r24
    4690:	39 07       	cpc	r19, r25
    4692:	70 f5       	brcc	.+92     	; 0x46f0 <uartSendBuffer+0xae>
    4694:	41 15       	cp	r20, r1
    4696:	51 05       	cpc	r21, r1
    4698:	59 f1       	breq	.+86     	; 0x46f0 <uartSendBuffer+0xae>
	{
		// grab first character
		first = *buffer++;
    469a:	9c 90       	ld	r9, X
		// copy user buffer to uart transmit buffer
		for(i = 0; i < nBytes-1; i++)
		{
			// put data bytes at end of buffer
			bufferAddToEnd(&uartTxBuffer[nUart], *buffer++);
    469c:	76 01       	movw	r14, r12
    469e:	63 e0       	ldi	r22, 0x03	; 3
    46a0:	ee 0c       	add	r14, r14
    46a2:	ff 1c       	adc	r15, r15
    46a4:	6a 95       	dec	r22
    46a6:	e1 f7       	brne	.-8      	; 0x46a0 <uartSendBuffer+0x5e>
    46a8:	81 e6       	ldi	r24, 0x61	; 97
    46aa:	92 e1       	ldi	r25, 0x12	; 18
    46ac:	e8 0e       	add	r14, r24
    46ae:	f9 1e       	adc	r15, r25
    46b0:	8d 01       	movw	r16, r26
    46b2:	c0 e0       	ldi	r28, 0x00	; 0
    46b4:	d0 e0       	ldi	r29, 0x00	; 0
	if((uartTxBuffer[nUart].datalength + nBytes < uartTxBuffer[nUart].size) && nBytes)
	{
		// grab first character
		first = *buffer++;
		// copy user buffer to uart transmit buffer
		for(i = 0; i < nBytes-1; i++)
    46b6:	5a 01       	movw	r10, r20
    46b8:	08 94       	sec
    46ba:	a1 08       	sbc	r10, r1
    46bc:	b1 08       	sbc	r11, r1
    46be:	06 c0       	rjmp	.+12     	; 0x46cc <uartSendBuffer+0x8a>
    46c0:	c7 01       	movw	r24, r14
    46c2:	f8 01       	movw	r30, r16
    46c4:	60 81       	ld	r22, Z
    46c6:	0e 94 5d 26 	call	0x4cba	; 0x4cba <bufferAddToEnd>
    46ca:	21 96       	adiw	r28, 0x01	; 1
    46cc:	0f 5f       	subi	r16, 0xFF	; 255
    46ce:	1f 4f       	sbci	r17, 0xFF	; 255
    46d0:	ca 15       	cp	r28, r10
    46d2:	db 05       	cpc	r29, r11
    46d4:	a8 f3       	brcs	.-22     	; 0x46c0 <uartSendBuffer+0x7e>
			// put data bytes at end of buffer
			bufferAddToEnd(&uartTxBuffer[nUart], *buffer++);
		}

		// send the first byte to get things going by interrupts
		uartBufferedTx[nUart] = TRUE;
    46d6:	8d e5       	ldi	r24, 0x5D	; 93
    46d8:	92 e1       	ldi	r25, 0x12	; 18
    46da:	c8 0e       	add	r12, r24
    46dc:	d9 1e       	adc	r13, r25
    46de:	8f ef       	ldi	r24, 0xFF	; 255
    46e0:	f6 01       	movw	r30, r12
    46e2:	80 83       	st	Z, r24
		uartSendByte(nUart, first);
    46e4:	88 2d       	mov	r24, r8
    46e6:	69 2d       	mov	r22, r9
    46e8:	0e 94 05 22 	call	0x440a	; 0x440a <uartSendByte>
    46ec:	8f ef       	ldi	r24, 0xFF	; 255
    46ee:	01 c0       	rjmp	.+2      	; 0x46f2 <uartSendBuffer+0xb0>
		// return success
		return TRUE;
    46f0:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		// return failure
		return FALSE;
	}
}
    46f2:	df 91       	pop	r29
    46f4:	cf 91       	pop	r28
    46f6:	1f 91       	pop	r17
    46f8:	0f 91       	pop	r16
    46fa:	ff 90       	pop	r15
    46fc:	ef 90       	pop	r14
    46fe:	df 90       	pop	r13
    4700:	cf 90       	pop	r12
    4702:	bf 90       	pop	r11
    4704:	af 90       	pop	r10
    4706:	9f 90       	pop	r9
    4708:	8f 90       	pop	r8
    470a:	08 95       	ret

0000470c <uartAddToTxBuffer>:
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    470c:	90 e0       	ldi	r25, 0x00	; 0
    470e:	23 e0       	ldi	r18, 0x03	; 3
    4710:	88 0f       	add	r24, r24
    4712:	99 1f       	adc	r25, r25
    4714:	2a 95       	dec	r18
    4716:	e1 f7       	brne	.-8      	; 0x4710 <uartAddToTxBuffer+0x4>
    4718:	8f 59       	subi	r24, 0x9F	; 159
    471a:	9d 4e       	sbci	r25, 0xED	; 237
    471c:	0e 94 5d 26 	call	0x4cba	; 0x4cba <bufferAddToEnd>
}
    4720:	08 95       	ret

00004722 <uart3AddToTxBuffer>:
{
	uartAddToTxBuffer(2,data);
}

void uart3AddToTxBuffer(u08 data)
{
    4722:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    4724:	89 e7       	ldi	r24, 0x79	; 121
    4726:	92 e1       	ldi	r25, 0x12	; 18
    4728:	0e 94 5d 26 	call	0x4cba	; 0x4cba <bufferAddToEnd>
}

void uart3AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(3,data);
}
    472c:	08 95       	ret

0000472e <uart2AddToTxBuffer>:
{
	uartAddToTxBuffer(1,data);
}

void uart2AddToTxBuffer(u08 data)
{
    472e:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    4730:	81 e7       	ldi	r24, 0x71	; 113
    4732:	92 e1       	ldi	r25, 0x12	; 18
    4734:	0e 94 5d 26 	call	0x4cba	; 0x4cba <bufferAddToEnd>
}

void uart2AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(2,data);
}
    4738:	08 95       	ret

0000473a <uart1AddToTxBuffer>:
{
	uartAddToTxBuffer(0,data);
}

void uart1AddToTxBuffer(u08 data)
{
    473a:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    473c:	89 e6       	ldi	r24, 0x69	; 105
    473e:	92 e1       	ldi	r25, 0x12	; 18
    4740:	0e 94 5d 26 	call	0x4cba	; 0x4cba <bufferAddToEnd>
}

void uart1AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(1,data);
}
    4744:	08 95       	ret

00004746 <uart0AddToTxBuffer>:
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
}

void uart0AddToTxBuffer(u08 data)
{
    4746:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    4748:	81 e6       	ldi	r24, 0x61	; 97
    474a:	92 e1       	ldi	r25, 0x12	; 18
    474c:	0e 94 5d 26 	call	0x4cba	; 0x4cba <bufferAddToEnd>
}

void uart0AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(0,data);
}
    4750:	08 95       	ret

00004752 <uartTransmitService>:
	}
}

// UART Transmit Complete Interrupt Function
void uartTransmitService(u08 nUart)
{
    4752:	cf 93       	push	r28
    4754:	df 93       	push	r29
    4756:	28 2f       	mov	r18, r24
	// check if buffered tx is enabled
	if(uartBufferedTx[nUart])
    4758:	a8 2f       	mov	r26, r24
    475a:	b0 e0       	ldi	r27, 0x00	; 0
    475c:	ed 01       	movw	r28, r26
    475e:	c3 5a       	subi	r28, 0xA3	; 163
    4760:	dd 4e       	sbci	r29, 0xED	; 237
    4762:	88 81       	ld	r24, Y
    4764:	88 23       	and	r24, r24
    4766:	79 f1       	breq	.+94     	; 0x47c6 <uartTransmitService+0x74>
	{
		// check if there's data left in the buffer
		if(uartTxBuffer[nUart].datalength)
    4768:	fd 01       	movw	r30, r26
    476a:	33 e0       	ldi	r19, 0x03	; 3
    476c:	ee 0f       	add	r30, r30
    476e:	ff 1f       	adc	r31, r31
    4770:	3a 95       	dec	r19
    4772:	e1 f7       	brne	.-8      	; 0x476c <uartTransmitService+0x1a>
    4774:	eb 59       	subi	r30, 0x9B	; 155
    4776:	fd 4e       	sbci	r31, 0xED	; 237
    4778:	80 81       	ld	r24, Z
    477a:	91 81       	ldd	r25, Z+1	; 0x01
    477c:	89 2b       	or	r24, r25
    477e:	11 f1       	breq	.+68     	; 0x47c4 <uartTransmitService+0x72>
		{
			// send byte from top of buffer
			if(nUart==3)
    4780:	23 30       	cpi	r18, 0x03	; 3
    4782:	39 f4       	brne	.+14     	; 0x4792 <uartTransmitService+0x40>
				outb(UDR3,  bufferGetFromFront(&uartTxBuffer[3]) );
    4784:	89 e7       	ldi	r24, 0x79	; 121
    4786:	92 e1       	ldi	r25, 0x12	; 18
    4788:	0e 94 f4 25 	call	0x4be8	; 0x4be8 <bufferGetFromFront>
    478c:	80 93 36 01 	sts	0x0136, r24
    4790:	1e c0       	rjmp	.+60     	; 0x47ce <uartTransmitService+0x7c>
			else if(nUart==2)
    4792:	22 30       	cpi	r18, 0x02	; 2
    4794:	39 f4       	brne	.+14     	; 0x47a4 <uartTransmitService+0x52>
				outb(UDR2,  bufferGetFromFront(&uartTxBuffer[2]) );
    4796:	81 e7       	ldi	r24, 0x71	; 113
    4798:	92 e1       	ldi	r25, 0x12	; 18
    479a:	0e 94 f4 25 	call	0x4be8	; 0x4be8 <bufferGetFromFront>
    479e:	80 93 d6 00 	sts	0x00D6, r24
    47a2:	15 c0       	rjmp	.+42     	; 0x47ce <uartTransmitService+0x7c>
			else if(nUart==1)
    47a4:	21 30       	cpi	r18, 0x01	; 1
    47a6:	39 f4       	brne	.+14     	; 0x47b6 <uartTransmitService+0x64>
				outb(UDR1,  bufferGetFromFront(&uartTxBuffer[1]) );
    47a8:	89 e6       	ldi	r24, 0x69	; 105
    47aa:	92 e1       	ldi	r25, 0x12	; 18
    47ac:	0e 94 f4 25 	call	0x4be8	; 0x4be8 <bufferGetFromFront>
    47b0:	80 93 ce 00 	sts	0x00CE, r24
    47b4:	0c c0       	rjmp	.+24     	; 0x47ce <uartTransmitService+0x7c>
			else
				outb(UDR0,  bufferGetFromFront(&uartTxBuffer[0]) );
    47b6:	81 e6       	ldi	r24, 0x61	; 97
    47b8:	92 e1       	ldi	r25, 0x12	; 18
    47ba:	0e 94 f4 25 	call	0x4be8	; 0x4be8 <bufferGetFromFront>
    47be:	80 93 c6 00 	sts	0x00C6, r24
    47c2:	05 c0       	rjmp	.+10     	; 0x47ce <uartTransmitService+0x7c>
		}
		else
		{
			// no data left
			uartBufferedTx[nUart] = FALSE;
    47c4:	18 82       	st	Y, r1
	}
	else
	{
		// we're using single-byte tx mode
		// indicate transmit complete, back to ready
		uartReadyTx[nUart] = TRUE;
    47c6:	a7 5c       	subi	r26, 0xC7	; 199
    47c8:	bd 4e       	sbci	r27, 0xED	; 237
    47ca:	8f ef       	ldi	r24, 0xFF	; 255
    47cc:	8c 93       	st	X, r24
	}
}
    47ce:	df 91       	pop	r29
    47d0:	cf 91       	pop	r28
    47d2:	08 95       	ret

000047d4 <__vector_56>:
{
	uartTransmitService(2);
}

UART_INTERRUPT_HANDLER(SIG_USART3_TRANS)      
{
    47d4:	1f 92       	push	r1
    47d6:	0f 92       	push	r0
    47d8:	0f b6       	in	r0, 0x3f	; 63
    47da:	0f 92       	push	r0
    47dc:	11 24       	eor	r1, r1
    47de:	2f 93       	push	r18
    47e0:	3f 93       	push	r19
    47e2:	4f 93       	push	r20
    47e4:	5f 93       	push	r21
    47e6:	6f 93       	push	r22
    47e8:	7f 93       	push	r23
    47ea:	8f 93       	push	r24
    47ec:	9f 93       	push	r25
    47ee:	af 93       	push	r26
    47f0:	bf 93       	push	r27
    47f2:	ef 93       	push	r30
    47f4:	ff 93       	push	r31
	uartTransmitService(3);
    47f6:	83 e0       	ldi	r24, 0x03	; 3
    47f8:	0e 94 a9 23 	call	0x4752	; 0x4752 <uartTransmitService>
}
    47fc:	ff 91       	pop	r31
    47fe:	ef 91       	pop	r30
    4800:	bf 91       	pop	r27
    4802:	af 91       	pop	r26
    4804:	9f 91       	pop	r25
    4806:	8f 91       	pop	r24
    4808:	7f 91       	pop	r23
    480a:	6f 91       	pop	r22
    480c:	5f 91       	pop	r21
    480e:	4f 91       	pop	r20
    4810:	3f 91       	pop	r19
    4812:	2f 91       	pop	r18
    4814:	0f 90       	pop	r0
    4816:	0f be       	out	0x3f, r0	; 63
    4818:	0f 90       	pop	r0
    481a:	1f 90       	pop	r1
    481c:	18 95       	reti

0000481e <__vector_53>:
{
	uartTransmitService(1);
}

UART_INTERRUPT_HANDLER(SIG_USART2_TRANS)      
{
    481e:	1f 92       	push	r1
    4820:	0f 92       	push	r0
    4822:	0f b6       	in	r0, 0x3f	; 63
    4824:	0f 92       	push	r0
    4826:	11 24       	eor	r1, r1
    4828:	2f 93       	push	r18
    482a:	3f 93       	push	r19
    482c:	4f 93       	push	r20
    482e:	5f 93       	push	r21
    4830:	6f 93       	push	r22
    4832:	7f 93       	push	r23
    4834:	8f 93       	push	r24
    4836:	9f 93       	push	r25
    4838:	af 93       	push	r26
    483a:	bf 93       	push	r27
    483c:	ef 93       	push	r30
    483e:	ff 93       	push	r31
	uartTransmitService(2);
    4840:	82 e0       	ldi	r24, 0x02	; 2
    4842:	0e 94 a9 23 	call	0x4752	; 0x4752 <uartTransmitService>
}
    4846:	ff 91       	pop	r31
    4848:	ef 91       	pop	r30
    484a:	bf 91       	pop	r27
    484c:	af 91       	pop	r26
    484e:	9f 91       	pop	r25
    4850:	8f 91       	pop	r24
    4852:	7f 91       	pop	r23
    4854:	6f 91       	pop	r22
    4856:	5f 91       	pop	r21
    4858:	4f 91       	pop	r20
    485a:	3f 91       	pop	r19
    485c:	2f 91       	pop	r18
    485e:	0f 90       	pop	r0
    4860:	0f be       	out	0x3f, r0	; 63
    4862:	0f 90       	pop	r0
    4864:	1f 90       	pop	r1
    4866:	18 95       	reti

00004868 <__vector_38>:
{
	uartTransmitService(0);
}

UART_INTERRUPT_HANDLER(SIG_USART1_TRANS)      
{
    4868:	1f 92       	push	r1
    486a:	0f 92       	push	r0
    486c:	0f b6       	in	r0, 0x3f	; 63
    486e:	0f 92       	push	r0
    4870:	11 24       	eor	r1, r1
    4872:	2f 93       	push	r18
    4874:	3f 93       	push	r19
    4876:	4f 93       	push	r20
    4878:	5f 93       	push	r21
    487a:	6f 93       	push	r22
    487c:	7f 93       	push	r23
    487e:	8f 93       	push	r24
    4880:	9f 93       	push	r25
    4882:	af 93       	push	r26
    4884:	bf 93       	push	r27
    4886:	ef 93       	push	r30
    4888:	ff 93       	push	r31
	uartTransmitService(1);
    488a:	81 e0       	ldi	r24, 0x01	; 1
    488c:	0e 94 a9 23 	call	0x4752	; 0x4752 <uartTransmitService>
}
    4890:	ff 91       	pop	r31
    4892:	ef 91       	pop	r30
    4894:	bf 91       	pop	r27
    4896:	af 91       	pop	r26
    4898:	9f 91       	pop	r25
    489a:	8f 91       	pop	r24
    489c:	7f 91       	pop	r23
    489e:	6f 91       	pop	r22
    48a0:	5f 91       	pop	r21
    48a2:	4f 91       	pop	r20
    48a4:	3f 91       	pop	r19
    48a6:	2f 91       	pop	r18
    48a8:	0f 90       	pop	r0
    48aa:	0f be       	out	0x3f, r0	; 63
    48ac:	0f 90       	pop	r0
    48ae:	1f 90       	pop	r1
    48b0:	18 95       	reti

000048b2 <__vector_27>:
	}
}

	// service UART transmit interrupt
UART_INTERRUPT_HANDLER(SIG_USART0_TRANS)      
{
    48b2:	1f 92       	push	r1
    48b4:	0f 92       	push	r0
    48b6:	0f b6       	in	r0, 0x3f	; 63
    48b8:	0f 92       	push	r0
    48ba:	11 24       	eor	r1, r1
    48bc:	2f 93       	push	r18
    48be:	3f 93       	push	r19
    48c0:	4f 93       	push	r20
    48c2:	5f 93       	push	r21
    48c4:	6f 93       	push	r22
    48c6:	7f 93       	push	r23
    48c8:	8f 93       	push	r24
    48ca:	9f 93       	push	r25
    48cc:	af 93       	push	r26
    48ce:	bf 93       	push	r27
    48d0:	ef 93       	push	r30
    48d2:	ff 93       	push	r31
	uartTransmitService(0);
    48d4:	80 e0       	ldi	r24, 0x00	; 0
    48d6:	0e 94 a9 23 	call	0x4752	; 0x4752 <uartTransmitService>
}
    48da:	ff 91       	pop	r31
    48dc:	ef 91       	pop	r30
    48de:	bf 91       	pop	r27
    48e0:	af 91       	pop	r26
    48e2:	9f 91       	pop	r25
    48e4:	8f 91       	pop	r24
    48e6:	7f 91       	pop	r23
    48e8:	6f 91       	pop	r22
    48ea:	5f 91       	pop	r21
    48ec:	4f 91       	pop	r20
    48ee:	3f 91       	pop	r19
    48f0:	2f 91       	pop	r18
    48f2:	0f 90       	pop	r0
    48f4:	0f be       	out	0x3f, r0	; 63
    48f6:	0f 90       	pop	r0
    48f8:	1f 90       	pop	r1
    48fa:	18 95       	reti

000048fc <uartSendTxBuffer>:
{
	uartAddToTxBuffer(3,data);
}

void uartSendTxBuffer(u08 nUart)
{
    48fc:	1f 93       	push	r17
    48fe:	18 2f       	mov	r17, r24
	// turn on buffered transmit
	uartBufferedTx[nUart] = TRUE;
    4900:	90 e0       	ldi	r25, 0x00	; 0
    4902:	fc 01       	movw	r30, r24
    4904:	e3 5a       	subi	r30, 0xA3	; 163
    4906:	fd 4e       	sbci	r31, 0xED	; 237
    4908:	2f ef       	ldi	r18, 0xFF	; 255
    490a:	20 83       	st	Z, r18
	// send the first byte to get things going by interrupts
	uartSendByte(nUart, bufferGetFromFront(&uartTxBuffer[nUart]));
    490c:	43 e0       	ldi	r20, 0x03	; 3
    490e:	88 0f       	add	r24, r24
    4910:	99 1f       	adc	r25, r25
    4912:	4a 95       	dec	r20
    4914:	e1 f7       	brne	.-8      	; 0x490e <uartSendTxBuffer+0x12>
    4916:	8f 59       	subi	r24, 0x9F	; 159
    4918:	9d 4e       	sbci	r25, 0xED	; 237
    491a:	0e 94 f4 25 	call	0x4be8	; 0x4be8 <bufferGetFromFront>
    491e:	68 2f       	mov	r22, r24
    4920:	81 2f       	mov	r24, r17
    4922:	0e 94 05 22 	call	0x440a	; 0x440a <uartSendByte>
}
    4926:	1f 91       	pop	r17
    4928:	08 95       	ret

0000492a <uartReceiveByte>:
		return -1;
}


u08 uartReceiveByte(u08 nUart, u08* rxData)
{
    492a:	cf 93       	push	r28
    492c:	df 93       	push	r29
    492e:	eb 01       	movw	r28, r22
	// make sure we have a receive buffer
	if(uartRxBuffer[nUart].size)
    4930:	28 2f       	mov	r18, r24
    4932:	30 e0       	ldi	r19, 0x00	; 0
    4934:	f9 01       	movw	r30, r18
    4936:	73 e0       	ldi	r23, 0x03	; 3
    4938:	ee 0f       	add	r30, r30
    493a:	ff 1f       	adc	r31, r31
    493c:	7a 95       	dec	r23
    493e:	e1 f7       	brne	.-8      	; 0x4938 <uartReceiveByte+0xe>
    4940:	e1 5c       	subi	r30, 0xC1	; 193
    4942:	fd 4e       	sbci	r31, 0xED	; 237
    4944:	80 81       	ld	r24, Z
    4946:	91 81       	ldd	r25, Z+1	; 0x01
    4948:	89 2b       	or	r24, r25
    494a:	c9 f0       	breq	.+50     	; 0x497e <uartReceiveByte+0x54>
	{
		// make sure we have data
		if(uartRxBuffer[nUart].datalength)
    494c:	f9 01       	movw	r30, r18
    494e:	63 e0       	ldi	r22, 0x03	; 3
    4950:	ee 0f       	add	r30, r30
    4952:	ff 1f       	adc	r31, r31
    4954:	6a 95       	dec	r22
    4956:	e1 f7       	brne	.-8      	; 0x4950 <uartReceiveByte+0x26>
    4958:	ef 5b       	subi	r30, 0xBF	; 191
    495a:	fd 4e       	sbci	r31, 0xED	; 237
    495c:	80 81       	ld	r24, Z
    495e:	91 81       	ldd	r25, Z+1	; 0x01
    4960:	89 2b       	or	r24, r25
    4962:	69 f0       	breq	.+26     	; 0x497e <uartReceiveByte+0x54>
		{
			// get byte from beginning of buffer
			*rxData = bufferGetFromFront(&uartRxBuffer[nUart]);
    4964:	53 e0       	ldi	r21, 0x03	; 3
    4966:	22 0f       	add	r18, r18
    4968:	33 1f       	adc	r19, r19
    496a:	5a 95       	dec	r21
    496c:	e1 f7       	brne	.-8      	; 0x4966 <uartReceiveByte+0x3c>
    496e:	c9 01       	movw	r24, r18
    4970:	83 5c       	subi	r24, 0xC3	; 195
    4972:	9d 4e       	sbci	r25, 0xED	; 237
    4974:	0e 94 f4 25 	call	0x4be8	; 0x4be8 <bufferGetFromFront>
    4978:	88 83       	st	Y, r24
    497a:	8f ef       	ldi	r24, 0xFF	; 255
    497c:	01 c0       	rjmp	.+2      	; 0x4980 <uartReceiveByte+0x56>
			return TRUE;
    497e:	80 e0       	ldi	r24, 0x00	; 0
		else
			return FALSE;			// no data
	}
	else
		return FALSE;				// no buffer
}
    4980:	df 91       	pop	r29
    4982:	cf 91       	pop	r28
    4984:	08 95       	ret

00004986 <uart3GetByte>:
	else
		return -1;
}

int uart3GetByte(void)
{
    4986:	df 93       	push	r29
    4988:	cf 93       	push	r28
    498a:	0f 92       	push	r0
    498c:	cd b7       	in	r28, 0x3d	; 61
    498e:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(3,&c))
    4990:	83 e0       	ldi	r24, 0x03	; 3
    4992:	be 01       	movw	r22, r28
    4994:	6f 5f       	subi	r22, 0xFF	; 255
    4996:	7f 4f       	sbci	r23, 0xFF	; 255
    4998:	0e 94 95 24 	call	0x492a	; 0x492a <uartReceiveByte>
    499c:	88 23       	and	r24, r24
    499e:	19 f4       	brne	.+6      	; 0x49a6 <uart3GetByte+0x20>
    49a0:	2f ef       	ldi	r18, 0xFF	; 255
    49a2:	3f ef       	ldi	r19, 0xFF	; 255
    49a4:	03 c0       	rjmp	.+6      	; 0x49ac <uart3GetByte+0x26>
		return c;
    49a6:	89 81       	ldd	r24, Y+1	; 0x01
    49a8:	28 2f       	mov	r18, r24
    49aa:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    49ac:	c9 01       	movw	r24, r18
    49ae:	0f 90       	pop	r0
    49b0:	cf 91       	pop	r28
    49b2:	df 91       	pop	r29
    49b4:	08 95       	ret

000049b6 <uart2GetByte>:
	else
		return -1;
}

int uart2GetByte(void)
{
    49b6:	df 93       	push	r29
    49b8:	cf 93       	push	r28
    49ba:	0f 92       	push	r0
    49bc:	cd b7       	in	r28, 0x3d	; 61
    49be:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(2,&c))
    49c0:	82 e0       	ldi	r24, 0x02	; 2
    49c2:	be 01       	movw	r22, r28
    49c4:	6f 5f       	subi	r22, 0xFF	; 255
    49c6:	7f 4f       	sbci	r23, 0xFF	; 255
    49c8:	0e 94 95 24 	call	0x492a	; 0x492a <uartReceiveByte>
    49cc:	88 23       	and	r24, r24
    49ce:	19 f4       	brne	.+6      	; 0x49d6 <uart2GetByte+0x20>
    49d0:	2f ef       	ldi	r18, 0xFF	; 255
    49d2:	3f ef       	ldi	r19, 0xFF	; 255
    49d4:	03 c0       	rjmp	.+6      	; 0x49dc <uart2GetByte+0x26>
		return c;
    49d6:	89 81       	ldd	r24, Y+1	; 0x01
    49d8:	28 2f       	mov	r18, r24
    49da:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    49dc:	c9 01       	movw	r24, r18
    49de:	0f 90       	pop	r0
    49e0:	cf 91       	pop	r28
    49e2:	df 91       	pop	r29
    49e4:	08 95       	ret

000049e6 <uart1GetByte>:
	else
		return -1;
}

int uart1GetByte(void)
{
    49e6:	df 93       	push	r29
    49e8:	cf 93       	push	r28
    49ea:	0f 92       	push	r0
    49ec:	cd b7       	in	r28, 0x3d	; 61
    49ee:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(1,&c))
    49f0:	81 e0       	ldi	r24, 0x01	; 1
    49f2:	be 01       	movw	r22, r28
    49f4:	6f 5f       	subi	r22, 0xFF	; 255
    49f6:	7f 4f       	sbci	r23, 0xFF	; 255
    49f8:	0e 94 95 24 	call	0x492a	; 0x492a <uartReceiveByte>
    49fc:	88 23       	and	r24, r24
    49fe:	19 f4       	brne	.+6      	; 0x4a06 <uart1GetByte+0x20>
    4a00:	2f ef       	ldi	r18, 0xFF	; 255
    4a02:	3f ef       	ldi	r19, 0xFF	; 255
    4a04:	03 c0       	rjmp	.+6      	; 0x4a0c <uart1GetByte+0x26>
		return c;
    4a06:	89 81       	ldd	r24, Y+1	; 0x01
    4a08:	28 2f       	mov	r18, r24
    4a0a:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    4a0c:	c9 01       	movw	r24, r18
    4a0e:	0f 90       	pop	r0
    4a10:	cf 91       	pop	r28
    4a12:	df 91       	pop	r29
    4a14:	08 95       	ret

00004a16 <uart0GetByte>:
	// send byte on UART3
	uartSendByte(3, data);
}

int uart0GetByte(void)
{
    4a16:	df 93       	push	r29
    4a18:	cf 93       	push	r28
    4a1a:	0f 92       	push	r0
    4a1c:	cd b7       	in	r28, 0x3d	; 61
    4a1e:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(0,&c))
    4a20:	80 e0       	ldi	r24, 0x00	; 0
    4a22:	be 01       	movw	r22, r28
    4a24:	6f 5f       	subi	r22, 0xFF	; 255
    4a26:	7f 4f       	sbci	r23, 0xFF	; 255
    4a28:	0e 94 95 24 	call	0x492a	; 0x492a <uartReceiveByte>
    4a2c:	88 23       	and	r24, r24
    4a2e:	19 f4       	brne	.+6      	; 0x4a36 <uart0GetByte+0x20>
    4a30:	2f ef       	ldi	r18, 0xFF	; 255
    4a32:	3f ef       	ldi	r19, 0xFF	; 255
    4a34:	03 c0       	rjmp	.+6      	; 0x4a3c <uart0GetByte+0x26>
		return c;
    4a36:	89 81       	ldd	r24, Y+1	; 0x01
    4a38:	28 2f       	mov	r18, r24
    4a3a:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    4a3c:	c9 01       	movw	r24, r18
    4a3e:	0f 90       	pop	r0
    4a40:	cf 91       	pop	r28
    4a42:	df 91       	pop	r29
    4a44:	08 95       	ret

00004a46 <uartFlushReceiveBuffer>:
}

void uartFlushReceiveBuffer(u08 nUart)
{
	// flush all data from receive buffer
	bufferFlush(&uartRxBuffer[nUart]);
    4a46:	90 e0       	ldi	r25, 0x00	; 0
    4a48:	e3 e0       	ldi	r30, 0x03	; 3
    4a4a:	88 0f       	add	r24, r24
    4a4c:	99 1f       	adc	r25, r25
    4a4e:	ea 95       	dec	r30
    4a50:	e1 f7       	brne	.-8      	; 0x4a4a <uartFlushReceiveBuffer+0x4>
    4a52:	83 5c       	subi	r24, 0xC3	; 195
    4a54:	9d 4e       	sbci	r25, 0xED	; 237
    4a56:	0e 94 90 26 	call	0x4d20	; 0x4d20 <bufferFlush>
}
    4a5a:	08 95       	ret

00004a5c <uart3InitBuffers>:

void uart3InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART3 buffers
		bufferInit(&uartRxBuffer[3], (u08*) uart3RxData, UART3_RX_BUFFER_SIZE);
    4a5c:	85 e5       	ldi	r24, 0x55	; 85
    4a5e:	92 e1       	ldi	r25, 0x12	; 18
    4a60:	67 e2       	ldi	r22, 0x27	; 39
    4a62:	71 e1       	ldi	r23, 0x11	; 17
    4a64:	40 e8       	ldi	r20, 0x80	; 128
    4a66:	50 e0       	ldi	r21, 0x00	; 0
    4a68:	0e 94 e7 25 	call	0x4bce	; 0x4bce <bufferInit>
		bufferInit(&uartTxBuffer[3], (u08*) uart3TxData, UART3_TX_BUFFER_SIZE);
    4a6c:	89 e7       	ldi	r24, 0x79	; 121
    4a6e:	92 e1       	ldi	r25, 0x12	; 18
    4a70:	67 ea       	ldi	r22, 0xA7	; 167
    4a72:	71 e1       	ldi	r23, 0x11	; 17
    4a74:	40 e1       	ldi	r20, 0x10	; 16
    4a76:	50 e0       	ldi	r21, 0x00	; 0
    4a78:	0e 94 e7 25 	call	0x4bce	; 0x4bce <bufferInit>
	#else
		// initialize the UART3 buffers
		bufferInit(&uartRxBuffer[3], (u08*) UART3_RX_BUFFER_ADDR, UART3_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[3], (u08*) UART3_TX_BUFFER_ADDR, UART3_TX_BUFFER_SIZE);
	#endif
}
    4a7c:	08 95       	ret

00004a7e <uart3Init>:
}

void uart3Init(void)
{
	// initialize the buffers
	uart3InitBuffers();
    4a7e:	0e 94 2e 25 	call	0x4a5c	; 0x4a5c <uart3InitBuffers>
	// initialize user receive handlers
	UartRxFunc[3] = 0;
    4a82:	10 92 be 11 	sts	0x11BE, r1
    4a86:	10 92 bd 11 	sts	0x11BD, r1
	// enable RxD/TxD and interrupts
	outb(UCSR3B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    4a8a:	88 ed       	ldi	r24, 0xD8	; 216
    4a8c:	80 93 31 01 	sts	0x0131, r24
	// set default baud rate
	uartSetBaudRate(3, UART3_DEFAULT_BAUD_RATE);
    4a90:	83 e0       	ldi	r24, 0x03	; 3
    4a92:	40 e8       	ldi	r20, 0x80	; 128
    4a94:	55 e2       	ldi	r21, 0x25	; 37
    4a96:	60 e0       	ldi	r22, 0x00	; 0
    4a98:	70 e0       	ldi	r23, 0x00	; 0
    4a9a:	0e 94 b8 21 	call	0x4370	; 0x4370 <uartSetBaudRate>
	// initialize states
	uartReadyTx[3] = TRUE;
    4a9e:	8f ef       	ldi	r24, 0xFF	; 255
    4aa0:	80 93 3c 12 	sts	0x123C, r24
	uartBufferedTx[3] = FALSE;
    4aa4:	10 92 60 12 	sts	0x1260, r1
	// clear overflow count
	uartRxOverflow[3] = 0;
    4aa8:	10 92 88 12 	sts	0x1288, r1
    4aac:	10 92 87 12 	sts	0x1287, r1
	// enable interrupts
	sei();
    4ab0:	78 94       	sei
}
    4ab2:	08 95       	ret

00004ab4 <uart2InitBuffers>:

void uart2InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART2 buffers
		bufferInit(&uartRxBuffer[2], (u08*) uart2RxData, UART2_RX_BUFFER_SIZE);
    4ab4:	8d e4       	ldi	r24, 0x4D	; 77
    4ab6:	92 e1       	ldi	r25, 0x12	; 18
    4ab8:	67 e9       	ldi	r22, 0x97	; 151
    4aba:	70 e1       	ldi	r23, 0x10	; 16
    4abc:	40 e8       	ldi	r20, 0x80	; 128
    4abe:	50 e0       	ldi	r21, 0x00	; 0
    4ac0:	0e 94 e7 25 	call	0x4bce	; 0x4bce <bufferInit>
		bufferInit(&uartTxBuffer[2], (u08*) uart2TxData, UART2_TX_BUFFER_SIZE);
    4ac4:	81 e7       	ldi	r24, 0x71	; 113
    4ac6:	92 e1       	ldi	r25, 0x12	; 18
    4ac8:	67 e1       	ldi	r22, 0x17	; 23
    4aca:	71 e1       	ldi	r23, 0x11	; 17
    4acc:	40 e1       	ldi	r20, 0x10	; 16
    4ace:	50 e0       	ldi	r21, 0x00	; 0
    4ad0:	0e 94 e7 25 	call	0x4bce	; 0x4bce <bufferInit>
	#else
		// initialize the UART2 buffers
		bufferInit(&uartRxBuffer[2], (u08*) UART2_RX_BUFFER_ADDR, UART2_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[2], (u08*) UART2_TX_BUFFER_ADDR, UART2_TX_BUFFER_SIZE);
	#endif
}
    4ad4:	08 95       	ret

00004ad6 <uart2Init>:
}

void uart2Init(void)
{
	// initialize the buffers
	uart2InitBuffers();
    4ad6:	0e 94 5a 25 	call	0x4ab4	; 0x4ab4 <uart2InitBuffers>
	// initialize user receive handlers
	UartRxFunc[2] = 0;
    4ada:	10 92 bc 11 	sts	0x11BC, r1
    4ade:	10 92 bb 11 	sts	0x11BB, r1
	// enable RxD/TxD and interrupts
	outb(UCSR2B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    4ae2:	88 ed       	ldi	r24, 0xD8	; 216
    4ae4:	80 93 d1 00 	sts	0x00D1, r24
	// set default baud rate
	uartSetBaudRate(2, UART2_DEFAULT_BAUD_RATE);
    4ae8:	82 e0       	ldi	r24, 0x02	; 2
    4aea:	40 e8       	ldi	r20, 0x80	; 128
    4aec:	55 e2       	ldi	r21, 0x25	; 37
    4aee:	60 e0       	ldi	r22, 0x00	; 0
    4af0:	70 e0       	ldi	r23, 0x00	; 0
    4af2:	0e 94 b8 21 	call	0x4370	; 0x4370 <uartSetBaudRate>
	// initialize states
	uartReadyTx[2] = TRUE;
    4af6:	8f ef       	ldi	r24, 0xFF	; 255
    4af8:	80 93 3b 12 	sts	0x123B, r24
	uartBufferedTx[2] = FALSE;
    4afc:	10 92 5f 12 	sts	0x125F, r1
	// clear overflow count
	uartRxOverflow[2] = 0;
    4b00:	10 92 86 12 	sts	0x1286, r1
    4b04:	10 92 85 12 	sts	0x1285, r1
	// enable interrupts
	sei();
    4b08:	78 94       	sei
}
    4b0a:	08 95       	ret

00004b0c <uart1InitBuffers>:

void uart1InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART1 buffers
		bufferInit(&uartRxBuffer[1], (u08*) uart1RxData, UART1_RX_BUFFER_SIZE);
    4b0c:	85 e4       	ldi	r24, 0x45	; 69
    4b0e:	92 e1       	ldi	r25, 0x12	; 18
    4b10:	67 e0       	ldi	r22, 0x07	; 7
    4b12:	70 e1       	ldi	r23, 0x10	; 16
    4b14:	40 e8       	ldi	r20, 0x80	; 128
    4b16:	50 e0       	ldi	r21, 0x00	; 0
    4b18:	0e 94 e7 25 	call	0x4bce	; 0x4bce <bufferInit>
		bufferInit(&uartTxBuffer[1], (u08*) uart1TxData, UART1_TX_BUFFER_SIZE);
    4b1c:	89 e6       	ldi	r24, 0x69	; 105
    4b1e:	92 e1       	ldi	r25, 0x12	; 18
    4b20:	67 e8       	ldi	r22, 0x87	; 135
    4b22:	70 e1       	ldi	r23, 0x10	; 16
    4b24:	40 e1       	ldi	r20, 0x10	; 16
    4b26:	50 e0       	ldi	r21, 0x00	; 0
    4b28:	0e 94 e7 25 	call	0x4bce	; 0x4bce <bufferInit>
	#else
		// initialize the UART1 buffers
		bufferInit(&uartRxBuffer[1], (u08*) UART1_RX_BUFFER_ADDR, UART1_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[1], (u08*) UART1_TX_BUFFER_ADDR, UART1_TX_BUFFER_SIZE);
	#endif
}
    4b2c:	08 95       	ret

00004b2e <uart1Init>:
}

void uart1Init(void)
{
	// initialize the buffers
	uart1InitBuffers();
    4b2e:	0e 94 86 25 	call	0x4b0c	; 0x4b0c <uart1InitBuffers>
	// initialize user receive handlers
	UartRxFunc[1] = 0;
    4b32:	10 92 ba 11 	sts	0x11BA, r1
    4b36:	10 92 b9 11 	sts	0x11B9, r1
	// enable RxD/TxD and interrupts
	outb(UCSR1B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    4b3a:	88 ed       	ldi	r24, 0xD8	; 216
    4b3c:	80 93 c9 00 	sts	0x00C9, r24
	// set default baud rate
	uartSetBaudRate(1, UART1_DEFAULT_BAUD_RATE);
    4b40:	81 e0       	ldi	r24, 0x01	; 1
    4b42:	40 e8       	ldi	r20, 0x80	; 128
    4b44:	55 e2       	ldi	r21, 0x25	; 37
    4b46:	60 e0       	ldi	r22, 0x00	; 0
    4b48:	70 e0       	ldi	r23, 0x00	; 0
    4b4a:	0e 94 b8 21 	call	0x4370	; 0x4370 <uartSetBaudRate>
	// initialize states
	uartReadyTx[1] = TRUE;
    4b4e:	8f ef       	ldi	r24, 0xFF	; 255
    4b50:	80 93 3a 12 	sts	0x123A, r24
	uartBufferedTx[1] = FALSE;
    4b54:	10 92 5e 12 	sts	0x125E, r1
	// clear overflow count
	uartRxOverflow[1] = 0;
    4b58:	10 92 84 12 	sts	0x1284, r1
    4b5c:	10 92 83 12 	sts	0x1283, r1
	// enable interrupts
	sei();
    4b60:	78 94       	sei
}
    4b62:	08 95       	ret

00004b64 <uart0InitBuffers>:

void uart0InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART0 buffers
		bufferInit(&uartRxBuffer[0], (u08*) uart0RxData, UART0_RX_BUFFER_SIZE);
    4b64:	8d e3       	ldi	r24, 0x3D	; 61
    4b66:	92 e1       	ldi	r25, 0x12	; 18
    4b68:	67 e7       	ldi	r22, 0x77	; 119
    4b6a:	7f e0       	ldi	r23, 0x0F	; 15
    4b6c:	40 e8       	ldi	r20, 0x80	; 128
    4b6e:	50 e0       	ldi	r21, 0x00	; 0
    4b70:	0e 94 e7 25 	call	0x4bce	; 0x4bce <bufferInit>
		bufferInit(&uartTxBuffer[0], (u08*) uart0TxData, UART0_TX_BUFFER_SIZE);
    4b74:	81 e6       	ldi	r24, 0x61	; 97
    4b76:	92 e1       	ldi	r25, 0x12	; 18
    4b78:	67 ef       	ldi	r22, 0xF7	; 247
    4b7a:	7f e0       	ldi	r23, 0x0F	; 15
    4b7c:	40 e1       	ldi	r20, 0x10	; 16
    4b7e:	50 e0       	ldi	r21, 0x00	; 0
    4b80:	0e 94 e7 25 	call	0x4bce	; 0x4bce <bufferInit>
	#else
		// initialize the UART0 buffers
		bufferInit(&uartRxBuffer[0], (u08*) UART0_RX_BUFFER_ADDR, UART0_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[0], (u08*) UART0_TX_BUFFER_ADDR, UART0_TX_BUFFER_SIZE);
	#endif
}
    4b84:	08 95       	ret

00004b86 <uart0Init>:
}

void uart0Init(void)
{
	// initialize the buffers
	uart0InitBuffers();
    4b86:	0e 94 b2 25 	call	0x4b64	; 0x4b64 <uart0InitBuffers>
	// initialize user receive handlers
	UartRxFunc[0] = 0;
    4b8a:	10 92 b8 11 	sts	0x11B8, r1
    4b8e:	10 92 b7 11 	sts	0x11B7, r1
	// enable RxD/TxD and interrupts
	outb(UCSR0B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    4b92:	88 ed       	ldi	r24, 0xD8	; 216
    4b94:	80 93 c1 00 	sts	0x00C1, r24
	// set default baud rate
	uartSetBaudRate(0, UART0_DEFAULT_BAUD_RATE); 
    4b98:	80 e0       	ldi	r24, 0x00	; 0
    4b9a:	40 e8       	ldi	r20, 0x80	; 128
    4b9c:	55 e2       	ldi	r21, 0x25	; 37
    4b9e:	60 e0       	ldi	r22, 0x00	; 0
    4ba0:	70 e0       	ldi	r23, 0x00	; 0
    4ba2:	0e 94 b8 21 	call	0x4370	; 0x4370 <uartSetBaudRate>
	// initialize states
	uartReadyTx[0] = TRUE;
    4ba6:	8f ef       	ldi	r24, 0xFF	; 255
    4ba8:	80 93 39 12 	sts	0x1239, r24
	uartBufferedTx[0] = FALSE;
    4bac:	10 92 5d 12 	sts	0x125D, r1
	// clear overflow count
	uartRxOverflow[0] = 0;
    4bb0:	10 92 82 12 	sts	0x1282, r1
    4bb4:	10 92 81 12 	sts	0x1281, r1
	// enable interrupts
	sei();
    4bb8:	78 94       	sei
}
    4bba:	08 95       	ret

00004bbc <uartInit>:
volatile static voidFuncPtru08 UartRxFunc[4];

void uartInit(void)
{
	// initialize all uarts
	uart0Init();
    4bbc:	0e 94 c3 25 	call	0x4b86	; 0x4b86 <uart0Init>
	uart1Init();
    4bc0:	0e 94 97 25 	call	0x4b2e	; 0x4b2e <uart1Init>
	uart2Init();
    4bc4:	0e 94 6b 25 	call	0x4ad6	; 0x4ad6 <uart2Init>
	uart3Init();
    4bc8:	0e 94 3f 25 	call	0x4a7e	; 0x4a7e <uart3Init>
}
    4bcc:	08 95       	ret

00004bce <bufferInit>:
// global variables

// initialization

void bufferInit(cBuffer* buffer, unsigned char *start, unsigned short size)
{
    4bce:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    4bd0:	8f b7       	in	r24, 0x3f	; 63
    4bd2:	f8 94       	cli
	// set start pointer of the buffer
	buffer->dataptr = start;
    4bd4:	71 83       	std	Z+1, r23	; 0x01
    4bd6:	60 83       	st	Z, r22
	buffer->size = size;
    4bd8:	53 83       	std	Z+3, r21	; 0x03
    4bda:	42 83       	std	Z+2, r20	; 0x02
	// initialize index and length
	buffer->dataindex = 0;
    4bdc:	17 82       	std	Z+7, r1	; 0x07
    4bde:	16 82       	std	Z+6, r1	; 0x06
	buffer->datalength = 0;
    4be0:	15 82       	std	Z+5, r1	; 0x05
    4be2:	14 82       	std	Z+4, r1	; 0x04
	// end critical section
	CRITICAL_SECTION_END;
    4be4:	8f bf       	out	0x3f, r24	; 63
}
    4be6:	08 95       	ret

00004be8 <bufferGetFromFront>:

// access routines
unsigned char  bufferGetFromFront(cBuffer* buffer)
{
    4be8:	dc 01       	movw	r26, r24
	unsigned char data = 0;
	// begin critical section
	CRITICAL_SECTION_START;
    4bea:	4f b7       	in	r20, 0x3f	; 63
    4bec:	f8 94       	cli
	// check to see if there's data in the buffer
	if(buffer->datalength)
    4bee:	14 96       	adiw	r26, 0x04	; 4
    4bf0:	8d 91       	ld	r24, X+
    4bf2:	9c 91       	ld	r25, X
    4bf4:	15 97       	sbiw	r26, 0x05	; 5
    4bf6:	89 2b       	or	r24, r25
    4bf8:	11 f4       	brne	.+4      	; 0x4bfe <bufferGetFromFront+0x16>
    4bfa:	e0 e0       	ldi	r30, 0x00	; 0
    4bfc:	25 c0       	rjmp	.+74     	; 0x4c48 <bufferGetFromFront+0x60>
	{
		// get the first character from buffer
		data = buffer->dataptr[buffer->dataindex];
    4bfe:	16 96       	adiw	r26, 0x06	; 6
    4c00:	8d 91       	ld	r24, X+
    4c02:	9c 91       	ld	r25, X
    4c04:	17 97       	sbiw	r26, 0x07	; 7
    4c06:	ed 91       	ld	r30, X+
    4c08:	fc 91       	ld	r31, X
    4c0a:	11 97       	sbiw	r26, 0x01	; 1
    4c0c:	e8 0f       	add	r30, r24
    4c0e:	f9 1f       	adc	r31, r25
    4c10:	e0 81       	ld	r30, Z
		// move index down and decrement length
		buffer->dataindex++;
    4c12:	01 96       	adiw	r24, 0x01	; 1
    4c14:	17 96       	adiw	r26, 0x07	; 7
    4c16:	9c 93       	st	X, r25
    4c18:	8e 93       	st	-X, r24
    4c1a:	16 97       	sbiw	r26, 0x06	; 6
		if(buffer->dataindex >= buffer->size)
    4c1c:	12 96       	adiw	r26, 0x02	; 2
    4c1e:	2d 91       	ld	r18, X+
    4c20:	3c 91       	ld	r19, X
    4c22:	13 97       	sbiw	r26, 0x03	; 3
    4c24:	82 17       	cp	r24, r18
    4c26:	93 07       	cpc	r25, r19
    4c28:	30 f0       	brcs	.+12     	; 0x4c36 <bufferGetFromFront+0x4e>
		{
			buffer->dataindex -= buffer->size;
    4c2a:	82 1b       	sub	r24, r18
    4c2c:	93 0b       	sbc	r25, r19
    4c2e:	17 96       	adiw	r26, 0x07	; 7
    4c30:	9c 93       	st	X, r25
    4c32:	8e 93       	st	-X, r24
    4c34:	16 97       	sbiw	r26, 0x06	; 6
		}
		buffer->datalength--;
    4c36:	14 96       	adiw	r26, 0x04	; 4
    4c38:	8d 91       	ld	r24, X+
    4c3a:	9c 91       	ld	r25, X
    4c3c:	15 97       	sbiw	r26, 0x05	; 5
    4c3e:	01 97       	sbiw	r24, 0x01	; 1
    4c40:	15 96       	adiw	r26, 0x05	; 5
    4c42:	9c 93       	st	X, r25
    4c44:	8e 93       	st	-X, r24
    4c46:	14 97       	sbiw	r26, 0x04	; 4
	}
	// end critical section
	CRITICAL_SECTION_END;
    4c48:	4f bf       	out	0x3f, r20	; 63
	// return
	return data;
}
    4c4a:	8e 2f       	mov	r24, r30
    4c4c:	08 95       	ret

00004c4e <bufferDumpFromFront>:

void bufferDumpFromFront(cBuffer* buffer, unsigned short numbytes)
{
    4c4e:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    4c50:	4f b7       	in	r20, 0x3f	; 63
    4c52:	f8 94       	cli
	// dump numbytes from the front of the buffer
	// are we dumping less than the entire buffer?
	if(numbytes < buffer->datalength)
    4c54:	84 81       	ldd	r24, Z+4	; 0x04
    4c56:	95 81       	ldd	r25, Z+5	; 0x05
    4c58:	68 17       	cp	r22, r24
    4c5a:	79 07       	cpc	r23, r25
    4c5c:	b0 f4       	brcc	.+44     	; 0x4c8a <bufferDumpFromFront+0x3c>
	{
		// move index down by numbytes and decrement length by numbytes
		buffer->dataindex += numbytes;
    4c5e:	86 81       	ldd	r24, Z+6	; 0x06
    4c60:	97 81       	ldd	r25, Z+7	; 0x07
    4c62:	86 0f       	add	r24, r22
    4c64:	97 1f       	adc	r25, r23
    4c66:	97 83       	std	Z+7, r25	; 0x07
    4c68:	86 83       	std	Z+6, r24	; 0x06
		if(buffer->dataindex >= buffer->size)
    4c6a:	22 81       	ldd	r18, Z+2	; 0x02
    4c6c:	33 81       	ldd	r19, Z+3	; 0x03
    4c6e:	82 17       	cp	r24, r18
    4c70:	93 07       	cpc	r25, r19
    4c72:	20 f0       	brcs	.+8      	; 0x4c7c <bufferDumpFromFront+0x2e>
		{
			buffer->dataindex -= buffer->size;
    4c74:	82 1b       	sub	r24, r18
    4c76:	93 0b       	sbc	r25, r19
    4c78:	97 83       	std	Z+7, r25	; 0x07
    4c7a:	86 83       	std	Z+6, r24	; 0x06
		}
		buffer->datalength -= numbytes;
    4c7c:	84 81       	ldd	r24, Z+4	; 0x04
    4c7e:	95 81       	ldd	r25, Z+5	; 0x05
    4c80:	86 1b       	sub	r24, r22
    4c82:	97 0b       	sbc	r25, r23
    4c84:	95 83       	std	Z+5, r25	; 0x05
    4c86:	84 83       	std	Z+4, r24	; 0x04
    4c88:	02 c0       	rjmp	.+4      	; 0x4c8e <bufferDumpFromFront+0x40>
	}
	else
	{
		// flush the whole buffer
		buffer->datalength = 0;
    4c8a:	15 82       	std	Z+5, r1	; 0x05
    4c8c:	14 82       	std	Z+4, r1	; 0x04
	}
	// end critical section
	CRITICAL_SECTION_END;
    4c8e:	4f bf       	out	0x3f, r20	; 63
}
    4c90:	08 95       	ret

00004c92 <bufferGetAtIndex>:

unsigned char bufferGetAtIndex(cBuffer* buffer, unsigned short index)
{
    4c92:	fc 01       	movw	r30, r24
    4c94:	cb 01       	movw	r24, r22
	// begin critical section
	CRITICAL_SECTION_START;
    4c96:	2f b7       	in	r18, 0x3f	; 63
    4c98:	f8 94       	cli
	// return character at index in buffer
	unsigned char data = buffer->dataptr[(buffer->dataindex+index)%(buffer->size)];
	// end critical section
	CRITICAL_SECTION_END;
    4c9a:	2f bf       	out	0x3f, r18	; 63
    4c9c:	26 81       	ldd	r18, Z+6	; 0x06
    4c9e:	37 81       	ldd	r19, Z+7	; 0x07
    4ca0:	62 81       	ldd	r22, Z+2	; 0x02
    4ca2:	73 81       	ldd	r23, Z+3	; 0x03
    4ca4:	82 0f       	add	r24, r18
    4ca6:	93 1f       	adc	r25, r19
    4ca8:	0e 94 75 30 	call	0x60ea	; 0x60ea <__udivmodhi4>
    4cac:	01 90       	ld	r0, Z+
    4cae:	f0 81       	ld	r31, Z
    4cb0:	e0 2d       	mov	r30, r0
    4cb2:	e8 0f       	add	r30, r24
    4cb4:	f9 1f       	adc	r31, r25
	return data;
}
    4cb6:	80 81       	ld	r24, Z
    4cb8:	08 95       	ret

00004cba <bufferAddToEnd>:

unsigned char bufferAddToEnd(cBuffer* buffer, unsigned char data)
{
    4cba:	1f 93       	push	r17
    4cbc:	cf 93       	push	r28
    4cbe:	df 93       	push	r29
    4cc0:	ec 01       	movw	r28, r24
    4cc2:	16 2f       	mov	r17, r22
	// begin critical section
	CRITICAL_SECTION_START;
    4cc4:	4f b7       	in	r20, 0x3f	; 63
    4cc6:	f8 94       	cli
	// make sure the buffer has room
	if(buffer->datalength < buffer->size)
    4cc8:	2c 81       	ldd	r18, Y+4	; 0x04
    4cca:	3d 81       	ldd	r19, Y+5	; 0x05
    4ccc:	6a 81       	ldd	r22, Y+2	; 0x02
    4cce:	7b 81       	ldd	r23, Y+3	; 0x03
    4cd0:	26 17       	cp	r18, r22
    4cd2:	37 07       	cpc	r19, r23
    4cd4:	98 f4       	brcc	.+38     	; 0x4cfc <bufferAddToEnd+0x42>
	{
		// save data byte at end of buffer
		buffer->dataptr[(buffer->dataindex + buffer->datalength) % buffer->size] = data;
    4cd6:	8e 81       	ldd	r24, Y+6	; 0x06
    4cd8:	9f 81       	ldd	r25, Y+7	; 0x07
    4cda:	82 0f       	add	r24, r18
    4cdc:	93 1f       	adc	r25, r19
    4cde:	0e 94 75 30 	call	0x60ea	; 0x60ea <__udivmodhi4>
    4ce2:	e8 81       	ld	r30, Y
    4ce4:	f9 81       	ldd	r31, Y+1	; 0x01
    4ce6:	e8 0f       	add	r30, r24
    4ce8:	f9 1f       	adc	r31, r25
    4cea:	10 83       	st	Z, r17
		// increment the length
		buffer->datalength++;
    4cec:	8c 81       	ldd	r24, Y+4	; 0x04
    4cee:	9d 81       	ldd	r25, Y+5	; 0x05
    4cf0:	01 96       	adiw	r24, 0x01	; 1
    4cf2:	9d 83       	std	Y+5, r25	; 0x05
    4cf4:	8c 83       	std	Y+4, r24	; 0x04
		// end critical section
		CRITICAL_SECTION_END;
    4cf6:	4f bf       	out	0x3f, r20	; 63
    4cf8:	8f ef       	ldi	r24, 0xFF	; 255
    4cfa:	02 c0       	rjmp	.+4      	; 0x4d00 <bufferAddToEnd+0x46>
		// return success
		return -1;
	}
	// end critical section
	CRITICAL_SECTION_END;
    4cfc:	4f bf       	out	0x3f, r20	; 63
    4cfe:	80 e0       	ldi	r24, 0x00	; 0
	// return failure
	return 0;
}
    4d00:	df 91       	pop	r29
    4d02:	cf 91       	pop	r28
    4d04:	1f 91       	pop	r17
    4d06:	08 95       	ret

00004d08 <bufferIsNotFull>:

unsigned short bufferIsNotFull(cBuffer* buffer)
{
    4d08:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    4d0a:	8f b7       	in	r24, 0x3f	; 63
    4d0c:	f8 94       	cli
	// check to see if the buffer has room
	// return true if there is room
	unsigned short bytesleft = (buffer->size - buffer->datalength);
	// end critical section
	CRITICAL_SECTION_END;
    4d0e:	8f bf       	out	0x3f, r24	; 63
    4d10:	22 81       	ldd	r18, Z+2	; 0x02
    4d12:	33 81       	ldd	r19, Z+3	; 0x03
    4d14:	84 81       	ldd	r24, Z+4	; 0x04
    4d16:	95 81       	ldd	r25, Z+5	; 0x05
    4d18:	28 1b       	sub	r18, r24
    4d1a:	39 0b       	sbc	r19, r25
	return bytesleft;
}
    4d1c:	c9 01       	movw	r24, r18
    4d1e:	08 95       	ret

00004d20 <bufferFlush>:

void bufferFlush(cBuffer* buffer)
{
    4d20:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    4d22:	8f b7       	in	r24, 0x3f	; 63
    4d24:	f8 94       	cli
	// flush contents of the buffer
	buffer->datalength = 0;
    4d26:	15 82       	std	Z+5, r1	; 0x05
    4d28:	14 82       	std	Z+4, r1	; 0x04
	// end critical section
	CRITICAL_SECTION_END;
    4d2a:	8f bf       	out	0x3f, r24	; 63
}
    4d2c:	08 95       	ret

00004d2e <a2dInit>:
// functions

// initialize a2d converter
void a2dInit(void)
{
	sbi(ADCSR, ADEN);				// enable ADC (turn on ADC power)
    4d2e:	aa e7       	ldi	r26, 0x7A	; 122
    4d30:	b0 e0       	ldi	r27, 0x00	; 0
    4d32:	8c 91       	ld	r24, X
    4d34:	80 68       	ori	r24, 0x80	; 128
    4d36:	8c 93       	st	X, r24
	cbi(ADCSR, ADFR);				// default to single sample convert mode
    4d38:	8c 91       	ld	r24, X
    4d3a:	8f 7d       	andi	r24, 0xDF	; 223
    4d3c:	8c 93       	st	X, r24
}

// configure A2D converter clock division (prescaling)
void a2dSetPrescaler(unsigned char prescale)
{
	outb(ADCSR, ((inb(ADCSR) & ~ADC_PRESCALE_MASK) | prescale));
    4d3e:	8c 91       	ld	r24, X
    4d40:	88 7f       	andi	r24, 0xF8	; 248
    4d42:	86 60       	ori	r24, 0x06	; 6
    4d44:	8c 93       	st	X, r24
}

// configure A2D converter voltage reference
void a2dSetReference(unsigned char ref)
{
	outb(ADMUX, ((inb(ADMUX) & ~ADC_REFERENCE_MASK) | (ref<<6)));
    4d46:	ec e7       	ldi	r30, 0x7C	; 124
    4d48:	f0 e0       	ldi	r31, 0x00	; 0
    4d4a:	80 81       	ld	r24, Z
    4d4c:	8f 73       	andi	r24, 0x3F	; 63
    4d4e:	80 64       	ori	r24, 0x40	; 64
    4d50:	80 83       	st	Z, r24
{
	sbi(ADCSR, ADEN);				// enable ADC (turn on ADC power)
	cbi(ADCSR, ADFR);				// default to single sample convert mode
	a2dSetPrescaler(ADC_PRESCALE);	// set default prescaler
	a2dSetReference(ADC_REFERENCE);	// set default reference
	cbi(ADMUX, ADLAR);				// set to right-adjusted result
    4d52:	80 81       	ld	r24, Z
    4d54:	8f 7d       	andi	r24, 0xDF	; 223
    4d56:	80 83       	st	Z, r24

	sbi(ADCSR, ADIE);				// enable ADC interrupts
    4d58:	8c 91       	ld	r24, X
    4d5a:	88 60       	ori	r24, 0x08	; 8
    4d5c:	8c 93       	st	X, r24

	a2dCompleteFlag = FALSE;		// clear conversion complete flag
    4d5e:	10 92 89 12 	sts	0x1289, r1
	sei();							// turn on interrupts (if not already on)
    4d62:	78 94       	sei
}
    4d64:	08 95       	ret

00004d66 <a2dOff>:

// turn off a2d converter
void a2dOff(void)
{
	cbi(ADCSR, ADIE);				// disable ADC interrupts
    4d66:	ea e7       	ldi	r30, 0x7A	; 122
    4d68:	f0 e0       	ldi	r31, 0x00	; 0
    4d6a:	80 81       	ld	r24, Z
    4d6c:	87 7f       	andi	r24, 0xF7	; 247
    4d6e:	80 83       	st	Z, r24
	cbi(ADCSR, ADEN);				// disable ADC (turn off ADC power)
    4d70:	80 81       	ld	r24, Z
    4d72:	8f 77       	andi	r24, 0x7F	; 127
    4d74:	80 83       	st	Z, r24
}
    4d76:	08 95       	ret

00004d78 <a2dSetPrescaler>:

// configure A2D converter clock division (prescaling)
void a2dSetPrescaler(unsigned char prescale)
{
	outb(ADCSR, ((inb(ADCSR) & ~ADC_PRESCALE_MASK) | prescale));
    4d78:	ea e7       	ldi	r30, 0x7A	; 122
    4d7a:	f0 e0       	ldi	r31, 0x00	; 0
    4d7c:	90 81       	ld	r25, Z
    4d7e:	98 7f       	andi	r25, 0xF8	; 248
    4d80:	98 2b       	or	r25, r24
    4d82:	90 83       	st	Z, r25
}
    4d84:	08 95       	ret

00004d86 <a2dSetReference>:

// configure A2D converter voltage reference
void a2dSetReference(unsigned char ref)
{
	outb(ADMUX, ((inb(ADMUX) & ~ADC_REFERENCE_MASK) | (ref<<6)));
    4d86:	ec e7       	ldi	r30, 0x7C	; 124
    4d88:	f0 e0       	ldi	r31, 0x00	; 0
    4d8a:	90 81       	ld	r25, Z
    4d8c:	82 95       	swap	r24
    4d8e:	88 0f       	add	r24, r24
    4d90:	88 0f       	add	r24, r24
    4d92:	80 7c       	andi	r24, 0xC0	; 192
    4d94:	9f 73       	andi	r25, 0x3F	; 63
    4d96:	98 2b       	or	r25, r24
    4d98:	90 83       	st	Z, r25
}
    4d9a:	08 95       	ret

00004d9c <a2dSetChannel>:

// sets the a2d input channel
void a2dSetChannel(unsigned char ch)
{
	outb(ADMUX, (inb(ADMUX) & ~ADC_MUX_MASK) | (ch & ADC_MUX_MASK));	// set channel
    4d9c:	ec e7       	ldi	r30, 0x7C	; 124
    4d9e:	f0 e0       	ldi	r31, 0x00	; 0
    4da0:	90 81       	ld	r25, Z
    4da2:	8f 71       	andi	r24, 0x1F	; 31
    4da4:	90 7e       	andi	r25, 0xE0	; 224
    4da6:	89 2b       	or	r24, r25
    4da8:	80 83       	st	Z, r24
}
    4daa:	08 95       	ret

00004dac <a2dStartConvert>:

// start a conversion on the current a2d input channel
void a2dStartConvert(void)
{
	sbi(ADCSR, ADIF);	// clear hardware "conversion complete" flag 
    4dac:	ea e7       	ldi	r30, 0x7A	; 122
    4dae:	f0 e0       	ldi	r31, 0x00	; 0
    4db0:	80 81       	ld	r24, Z
    4db2:	80 61       	ori	r24, 0x10	; 16
    4db4:	80 83       	st	Z, r24
	sbi(ADCSR, ADSC);	// start conversion
    4db6:	80 81       	ld	r24, Z
    4db8:	80 64       	ori	r24, 0x40	; 64
    4dba:	80 83       	st	Z, r24
}
    4dbc:	08 95       	ret

00004dbe <a2dIsComplete>:

// return TRUE if conversion is complete
u08 a2dIsComplete(void)
{
	return bit_is_set(ADCSR, ADSC);
    4dbe:	80 91 7a 00 	lds	r24, 0x007A
}
    4dc2:	80 74       	andi	r24, 0x40	; 64
    4dc4:	08 95       	ret

00004dc6 <a2dConvert10bit>:

// Perform a 10-bit conversion
// starts conversion, waits until conversion is done, and returns result
unsigned short a2dConvert10bit(unsigned char ch)
{
    4dc6:	98 2f       	mov	r25, r24
	a2dCompleteFlag = FALSE;				// clear conversion complete flag
    4dc8:	10 92 89 12 	sts	0x1289, r1

if (ch >= 8)
    4dcc:	88 30       	cpi	r24, 0x08	; 8
    4dce:	20 f0       	brcs	.+8      	; 0x4dd8 <a2dConvert10bit+0x12>
    ADCSRB |= _BV(MUX5);
    4dd0:	80 91 7b 00 	lds	r24, 0x007B
    4dd4:	88 60       	ori	r24, 0x08	; 8
    4dd6:	03 c0       	rjmp	.+6      	; 0x4dde <a2dConvert10bit+0x18>
else
    ADCSRB &= ~_BV(MUX5);
    4dd8:	80 91 7b 00 	lds	r24, 0x007B
    4ddc:	87 7f       	andi	r24, 0xF7	; 247
    4dde:	80 93 7b 00 	sts	0x007B, r24

   outb(ADMUX, (inb(ADMUX) & ~7) | (ch & 7));   // set channel
    4de2:	80 91 7c 00 	lds	r24, 0x007C
    4de6:	97 70       	andi	r25, 0x07	; 7
    4de8:	88 7f       	andi	r24, 0xF8	; 248
    4dea:	89 2b       	or	r24, r25
    4dec:	80 93 7c 00 	sts	0x007C, r24

	//outb(ADMUX, (inb(ADMUX) & ~ADC_MUX_MASK) | (ch & ADC_MUX_MASK));	// set channel
	sbi(ADCSR, ADIF);						// clear hardware "conversion complete" flag 
    4df0:	80 91 7a 00 	lds	r24, 0x007A
    4df4:	80 61       	ori	r24, 0x10	; 16
    4df6:	80 93 7a 00 	sts	0x007A, r24
	sbi(ADCSR, ADSC);						// start conversion
    4dfa:	80 91 7a 00 	lds	r24, 0x007A
    4dfe:	80 64       	ori	r24, 0x40	; 64
    4e00:	80 93 7a 00 	sts	0x007A, r24
	//while(!a2dCompleteFlag);				// wait until conversion complete
	//while( bit_is_clear(ADCSR, ADIF) );		// wait until conversion complete
	while( bit_is_set(ADCSR, ADSC) );		// wait until conversion complete
    4e04:	80 91 7a 00 	lds	r24, 0x007A
    4e08:	86 fd       	sbrc	r24, 6
    4e0a:	fc cf       	rjmp	.-8      	; 0x4e04 <a2dConvert10bit+0x3e>

	// CAUTION: MUST READ ADCL BEFORE ADCH!!!
	//return (inb(ADCL) | (inb(ADCH)<<8));	// read ADC (full 10 bits) //old version
	return ADC;//new version code
    4e0c:	20 91 78 00 	lds	r18, 0x0078
    4e10:	30 91 79 00 	lds	r19, 0x0079
}
    4e14:	c9 01       	movw	r24, r18
    4e16:	08 95       	ret

00004e18 <a2dConvert8bit>:
// Perform a 8-bit conversion.
// starts conversion, waits until conversion is done, and returns result
unsigned char a2dConvert8bit(unsigned char ch)
{
	// do 10-bit conversion and return highest 8 bits
	return a2dConvert10bit(ch)>>2;			// return ADC MSB byte
    4e18:	0e 94 e3 26 	call	0x4dc6	; 0x4dc6 <a2dConvert10bit>
    4e1c:	96 95       	lsr	r25
    4e1e:	87 95       	ror	r24
    4e20:	96 95       	lsr	r25
    4e22:	87 95       	ror	r24
}
    4e24:	08 95       	ret

00004e26 <__vector_29>:

//! Interrupt handler for ADC complete interrupt.
SIGNAL(SIG_ADC)
{
    4e26:	1f 92       	push	r1
    4e28:	0f 92       	push	r0
    4e2a:	0f b6       	in	r0, 0x3f	; 63
    4e2c:	0f 92       	push	r0
    4e2e:	11 24       	eor	r1, r1
    4e30:	8f 93       	push	r24
	// set the a2d conversion flag to indicate "complete"
	a2dCompleteFlag = TRUE;
    4e32:	8f ef       	ldi	r24, 0xFF	; 255
    4e34:	80 93 89 12 	sts	0x1289, r24
}
    4e38:	8f 91       	pop	r24
    4e3a:	0f 90       	pop	r0
    4e3c:	0f be       	out	0x3f, r0	; 63
    4e3e:	0f 90       	pop	r0
    4e40:	1f 90       	pop	r1
    4e42:	18 95       	reti

00004e44 <rprintfInit>:
// *** rprintf initialization ***
// you must call this function once and supply the character output
// routine before using other functions in this library
void rprintfInit(void (*putchar_func)(unsigned char c))
{
	rputchar = putchar_func;
    4e44:	90 93 c0 11 	sts	0x11C0, r25
    4e48:	80 93 bf 11 	sts	0x11BF, r24
}
    4e4c:	08 95       	ret

00004e4e <rprintfChar>:

// *** rprintfChar ***
// send a character/byte to the current output device
void rprintfChar(unsigned char c)
{
    4e4e:	1f 93       	push	r17
    4e50:	18 2f       	mov	r17, r24
	// do LF -> CR/LF translation
	if(c == '\n')
    4e52:	8a 30       	cpi	r24, 0x0A	; 10
    4e54:	31 f4       	brne	.+12     	; 0x4e62 <rprintfChar+0x14>
		rputchar('\r');
    4e56:	e0 91 bf 11 	lds	r30, 0x11BF
    4e5a:	f0 91 c0 11 	lds	r31, 0x11C0
    4e5e:	8d e0       	ldi	r24, 0x0D	; 13
    4e60:	09 95       	icall
	// send character
	rputchar(c);
    4e62:	e0 91 bf 11 	lds	r30, 0x11BF
    4e66:	f0 91 c0 11 	lds	r31, 0x11C0
    4e6a:	81 2f       	mov	r24, r17
    4e6c:	09 95       	icall
}
    4e6e:	1f 91       	pop	r17
    4e70:	08 95       	ret

00004e72 <rprintfStr>:

// *** rprintfStr ***
// prints a null-terminated string stored in RAM
void rprintfStr(char str[])
{
    4e72:	cf 93       	push	r28
    4e74:	df 93       	push	r29
    4e76:	ec 01       	movw	r28, r24
	// send a string stored in RAM
	// check to make sure we have a good pointer
	if (!str) return;
    4e78:	00 97       	sbiw	r24, 0x00	; 0
    4e7a:	21 f4       	brne	.+8      	; 0x4e84 <rprintfStr+0x12>
    4e7c:	06 c0       	rjmp	.+12     	; 0x4e8a <rprintfStr+0x18>

	// print the string until a null-terminator
	while (*str)
		rprintfChar(*str++);
    4e7e:	21 96       	adiw	r28, 0x01	; 1
    4e80:	0e 94 27 27 	call	0x4e4e	; 0x4e4e <rprintfChar>
	// send a string stored in RAM
	// check to make sure we have a good pointer
	if (!str) return;

	// print the string until a null-terminator
	while (*str)
    4e84:	88 81       	ld	r24, Y
    4e86:	88 23       	and	r24, r24
    4e88:	d1 f7       	brne	.-12     	; 0x4e7e <rprintfStr+0xc>
		rprintfChar(*str++);
}
    4e8a:	df 91       	pop	r29
    4e8c:	cf 91       	pop	r28
    4e8e:	08 95       	ret

00004e90 <rprintfStrLen>:
// *** rprintfStrLen ***
// prints a section of a string stored in RAM
// begins printing at position indicated by <start>
// prints number of characters indicated by <len>
void rprintfStrLen(char str[], unsigned int start, unsigned int len)
{
    4e90:	ef 92       	push	r14
    4e92:	ff 92       	push	r15
    4e94:	0f 93       	push	r16
    4e96:	1f 93       	push	r17
    4e98:	cf 93       	push	r28
    4e9a:	df 93       	push	r29
    4e9c:	8c 01       	movw	r16, r24
    4e9e:	7a 01       	movw	r14, r20
	register int i=0;

	// check to make sure we have a good pointer
	if (!str) return;
    4ea0:	00 97       	sbiw	r24, 0x00	; 0
    4ea2:	e9 f0       	breq	.+58     	; 0x4ede <rprintfStrLen+0x4e>
    4ea4:	20 e0       	ldi	r18, 0x00	; 0
    4ea6:	30 e0       	ldi	r19, 0x00	; 0
	// spin through characters up to requested start
	// keep going as long as there's no null
	while((i++<start) && (*str++));
    4ea8:	26 17       	cp	r18, r22
    4eaa:	37 07       	cpc	r19, r23
    4eac:	38 f4       	brcc	.+14     	; 0x4ebc <rprintfStrLen+0x2c>
    4eae:	f8 01       	movw	r30, r16
    4eb0:	81 91       	ld	r24, Z+
    4eb2:	8f 01       	movw	r16, r30
    4eb4:	2f 5f       	subi	r18, 0xFF	; 255
    4eb6:	3f 4f       	sbci	r19, 0xFF	; 255
    4eb8:	88 23       	and	r24, r24
    4eba:	b1 f7       	brne	.-20     	; 0x4ea8 <rprintfStrLen+0x18>
    4ebc:	c0 e0       	ldi	r28, 0x00	; 0
    4ebe:	d0 e0       	ldi	r29, 0x00	; 0
    4ec0:	0b c0       	rjmp	.+22     	; 0x4ed8 <rprintfStrLen+0x48>
	// then print exactly len characters
	for(i=0; i<len; i++)
	{
		// print data out of the string as long as we haven't reached a null yet
		// at the null, start printing spaces
		if(*str)
    4ec2:	f8 01       	movw	r30, r16
    4ec4:	80 81       	ld	r24, Z
    4ec6:	88 23       	and	r24, r24
    4ec8:	19 f0       	breq	.+6      	; 0x4ed0 <rprintfStrLen+0x40>
			rprintfChar(*str++);
    4eca:	0f 5f       	subi	r16, 0xFF	; 255
    4ecc:	1f 4f       	sbci	r17, 0xFF	; 255
    4ece:	01 c0       	rjmp	.+2      	; 0x4ed2 <rprintfStrLen+0x42>
		else
			rprintfChar(' ');
    4ed0:	80 e2       	ldi	r24, 0x20	; 32
    4ed2:	0e 94 27 27 	call	0x4e4e	; 0x4e4e <rprintfChar>
//		// keep steping through string as long as there's no null
//		if(*str) str++;
//	}

	// then print exactly len characters
	for(i=0; i<len; i++)
    4ed6:	21 96       	adiw	r28, 0x01	; 1
    4ed8:	ce 15       	cp	r28, r14
    4eda:	df 05       	cpc	r29, r15
    4edc:	90 f3       	brcs	.-28     	; 0x4ec2 <rprintfStrLen+0x32>
			rprintfChar(*str++);
		else
			rprintfChar(' ');
	}

}
    4ede:	df 91       	pop	r29
    4ee0:	cf 91       	pop	r28
    4ee2:	1f 91       	pop	r17
    4ee4:	0f 91       	pop	r16
    4ee6:	ff 90       	pop	r15
    4ee8:	ef 90       	pop	r14
    4eea:	08 95       	ret

00004eec <rprintfProgStr>:

// *** rprintfProgStr ***
// prints a null-terminated string stored in program ROM
void rprintfProgStr(const prog_char str[])
{
    4eec:	cf 93       	push	r28
    4eee:	df 93       	push	r29
    4ef0:	ec 01       	movw	r28, r24
	// print a string stored in program memory
	register char c;

	// check to make sure we have a good pointer
	if (!str) return;
    4ef2:	00 97       	sbiw	r24, 0x00	; 0
    4ef4:	19 f4       	brne	.+6      	; 0x4efc <rprintfProgStr+0x10>
    4ef6:	07 c0       	rjmp	.+14     	; 0x4f06 <rprintfProgStr+0x1a>
	
	// print the string until the null-terminator
	while((c = pgm_read_byte(str++)))
		rprintfChar(c);
    4ef8:	0e 94 27 27 	call	0x4e4e	; 0x4e4e <rprintfChar>
    4efc:	fe 01       	movw	r30, r28

	// check to make sure we have a good pointer
	if (!str) return;
	
	// print the string until the null-terminator
	while((c = pgm_read_byte(str++)))
    4efe:	21 96       	adiw	r28, 0x01	; 1
    4f00:	84 91       	lpm	r24, Z+
    4f02:	88 23       	and	r24, r24
    4f04:	c9 f7       	brne	.-14     	; 0x4ef8 <rprintfProgStr+0xc>
		rprintfChar(c);
}
    4f06:	df 91       	pop	r29
    4f08:	cf 91       	pop	r28
    4f0a:	08 95       	ret

00004f0c <rprintfCRLF>:
void rprintfCRLF(void)
{
	// print CR/LF
	//rprintfChar('\r');
	// LF -> CR/LF translation built-in to rprintfChar()
	rprintfChar('\n');
    4f0c:	8a e0       	ldi	r24, 0x0A	; 10
    4f0e:	0e 94 27 27 	call	0x4e4e	; 0x4e4e <rprintfChar>
}
    4f12:	08 95       	ret

00004f14 <rprintfu04>:
//	char Character = data&0x0f;
//	if (Character>9)
//		Character+='A'-10;
//	else
//		Character+='0';
	rprintfChar(hexchar(data));
    4f14:	e8 2f       	mov	r30, r24
    4f16:	f0 e0       	ldi	r31, 0x00	; 0
    4f18:	ef 70       	andi	r30, 0x0F	; 15
    4f1a:	f0 70       	andi	r31, 0x00	; 0
    4f1c:	ec 51       	subi	r30, 0x1C	; 28
    4f1e:	fe 4f       	sbci	r31, 0xFE	; 254
    4f20:	e4 91       	lpm	r30, Z+
    4f22:	8e 2f       	mov	r24, r30
    4f24:	0e 94 27 27 	call	0x4e4e	; 0x4e4e <rprintfChar>
}
    4f28:	08 95       	ret

00004f2a <rprintfu08>:

// *** rprintfu08 ***
// prints an unsigned 8-bit number in hex (2 digits)
void rprintfu08(unsigned char data)
{
    4f2a:	1f 93       	push	r17
    4f2c:	18 2f       	mov	r17, r24
	// print 8-bit hex value
	rprintfu04(data>>4);
    4f2e:	82 95       	swap	r24
    4f30:	8f 70       	andi	r24, 0x0F	; 15
    4f32:	0e 94 8a 27 	call	0x4f14	; 0x4f14 <rprintfu04>
	rprintfu04(data);
    4f36:	81 2f       	mov	r24, r17
    4f38:	0e 94 8a 27 	call	0x4f14	; 0x4f14 <rprintfu04>
}
    4f3c:	1f 91       	pop	r17
    4f3e:	08 95       	ret

00004f40 <rprintfu16>:

// *** rprintfu16 ***
// prints an unsigned 16-bit number in hex (4 digits)
void rprintfu16(unsigned short data)
{
    4f40:	1f 93       	push	r17
    4f42:	18 2f       	mov	r17, r24
	// print 16-bit hex value
	rprintfu08(data>>8);
    4f44:	89 2f       	mov	r24, r25
    4f46:	0e 94 95 27 	call	0x4f2a	; 0x4f2a <rprintfu08>
	rprintfu08(data);
    4f4a:	81 2f       	mov	r24, r17
    4f4c:	0e 94 95 27 	call	0x4f2a	; 0x4f2a <rprintfu08>
}
    4f50:	1f 91       	pop	r17
    4f52:	08 95       	ret

00004f54 <rprintfu32>:

// *** rprintfu32 ***
// prints an unsigned 32-bit number in hex (8 digits)
void rprintfu32(unsigned long data)
{
    4f54:	ef 92       	push	r14
    4f56:	ff 92       	push	r15
    4f58:	0f 93       	push	r16
    4f5a:	1f 93       	push	r17
    4f5c:	7b 01       	movw	r14, r22
    4f5e:	8c 01       	movw	r16, r24
	// print 32-bit hex value
	rprintfu16(data>>16);
    4f60:	c8 01       	movw	r24, r16
    4f62:	aa 27       	eor	r26, r26
    4f64:	bb 27       	eor	r27, r27
    4f66:	0e 94 a0 27 	call	0x4f40	; 0x4f40 <rprintfu16>
	rprintfu16(data);
    4f6a:	c7 01       	movw	r24, r14
    4f6c:	0e 94 a0 27 	call	0x4f40	; 0x4f40 <rprintfu16>
}
    4f70:	1f 91       	pop	r17
    4f72:	0f 91       	pop	r16
    4f74:	ff 90       	pop	r15
    4f76:	ef 90       	pop	r14
    4f78:	08 95       	ret

00004f7a <rprintfNum>:
//	Examples:
//	uartPrintfNum(10, 6,  TRUE, ' ',   1234);  -->  " +1234"
//	uartPrintfNum(10, 6, FALSE, '0',   1234);  -->  "001234"
//	uartPrintfNum(16, 6, FALSE, '.', 0x5AA5);  -->  "..5AA5"
void rprintfNum(char base, char numDigits, char isSigned, char padchar, long n)
{
    4f7a:	2f 92       	push	r2
    4f7c:	3f 92       	push	r3
    4f7e:	4f 92       	push	r4
    4f80:	5f 92       	push	r5
    4f82:	6f 92       	push	r6
    4f84:	7f 92       	push	r7
    4f86:	8f 92       	push	r8
    4f88:	9f 92       	push	r9
    4f8a:	af 92       	push	r10
    4f8c:	bf 92       	push	r11
    4f8e:	cf 92       	push	r12
    4f90:	df 92       	push	r13
    4f92:	ef 92       	push	r14
    4f94:	ff 92       	push	r15
    4f96:	0f 93       	push	r16
    4f98:	1f 93       	push	r17
    4f9a:	df 93       	push	r29
    4f9c:	cf 93       	push	r28
    4f9e:	cd b7       	in	r28, 0x3d	; 61
    4fa0:	de b7       	in	r29, 0x3e	; 62
    4fa2:	a3 97       	sbiw	r28, 0x23	; 35
    4fa4:	0f b6       	in	r0, 0x3f	; 63
    4fa6:	f8 94       	cli
    4fa8:	de bf       	out	0x3e, r29	; 62
    4faa:	0f be       	out	0x3f, r0	; 63
    4fac:	cd bf       	out	0x3d, r28	; 61
    4fae:	6a a3       	std	Y+34, r22	; 0x22
    4fb0:	24 2e       	mov	r2, r20
    4fb2:	2b a3       	std	Y+35, r18	; 0x23
    4fb4:	37 01       	movw	r6, r14
    4fb6:	48 01       	movw	r8, r16
	char *p, buf[32];
	unsigned long x;
	unsigned char count;

	// prepare negative number
	if( isSigned && (n < 0) )
    4fb8:	44 23       	and	r20, r20
    4fba:	51 f0       	breq	.+20     	; 0x4fd0 <rprintfNum+0x56>
    4fbc:	17 ff       	sbrs	r17, 7
    4fbe:	08 c0       	rjmp	.+16     	; 0x4fd0 <rprintfNum+0x56>
	{
		x = -n;
    4fc0:	ee 24       	eor	r14, r14
    4fc2:	ff 24       	eor	r15, r15
    4fc4:	87 01       	movw	r16, r14
    4fc6:	e6 18       	sub	r14, r6
    4fc8:	f7 08       	sbc	r15, r7
    4fca:	08 09       	sbc	r16, r8
    4fcc:	19 09       	sbc	r17, r9
    4fce:	02 c0       	rjmp	.+4      	; 0x4fd4 <rprintfNum+0x5a>
	}
	else
	{
	 	x = n;
    4fd0:	84 01       	movw	r16, r8
    4fd2:	73 01       	movw	r14, r6
	}

	// setup little string buffer
	count = (numDigits-1)-(isSigned?1:0);
    4fd4:	2a a1       	ldd	r18, Y+34	; 0x22
    4fd6:	21 50       	subi	r18, 0x01	; 1
    4fd8:	90 e0       	ldi	r25, 0x00	; 0
    4fda:	21 10       	cpse	r2, r1
    4fdc:	91 e0       	ldi	r25, 0x01	; 1
    4fde:	29 1b       	sub	r18, r25
    4fe0:	29 a3       	std	Y+33, r18	; 0x21
  	p = buf + sizeof (buf);
  	*--p = '\0';
    4fe2:	18 a2       	std	Y+32, r1	; 0x20
	
	// force calculation of first digit
	// (to prevent zero from not printing at all!!!)
	*--p = hexchar(x%base); x /= base;
    4fe4:	a8 2e       	mov	r10, r24
    4fe6:	bb 24       	eor	r11, r11
    4fe8:	cc 24       	eor	r12, r12
    4fea:	dd 24       	eor	r13, r13
    4fec:	c8 01       	movw	r24, r16
    4fee:	b7 01       	movw	r22, r14
    4ff0:	a6 01       	movw	r20, r12
    4ff2:	95 01       	movw	r18, r10
    4ff4:	0e 94 9c 30 	call	0x6138	; 0x6138 <__udivmodsi4>
    4ff8:	fb 01       	movw	r30, r22
    4ffa:	ef 70       	andi	r30, 0x0F	; 15
    4ffc:	f0 70       	andi	r31, 0x00	; 0
    4ffe:	ec 51       	subi	r30, 0x1C	; 28
    5000:	fe 4f       	sbci	r31, 0xFE	; 254
    5002:	64 91       	lpm	r22, Z+
    5004:	6f 8f       	std	Y+31, r22	; 0x1f
    5006:	c8 01       	movw	r24, r16
    5008:	b7 01       	movw	r22, r14
    500a:	a6 01       	movw	r20, r12
    500c:	95 01       	movw	r18, r10
    500e:	0e 94 9c 30 	call	0x6138	; 0x6138 <__udivmodsi4>
    5012:	c9 01       	movw	r24, r18
    5014:	da 01       	movw	r26, r20
    5016:	7c 01       	movw	r14, r24
    5018:	8d 01       	movw	r16, r26
    501a:	9e e1       	ldi	r25, 0x1E	; 30
    501c:	49 2e       	mov	r4, r25
    501e:	51 2c       	mov	r5, r1
    5020:	4c 0e       	add	r4, r28
    5022:	5d 1e       	adc	r5, r29
    5024:	39 a0       	ldd	r3, Y+33	; 0x21
    5026:	25 c0       	rjmp	.+74     	; 0x5072 <rprintfNum+0xf8>
	// calculate remaining digits
	while(count--)
	{
		if(x != 0)
    5028:	e1 14       	cp	r14, r1
    502a:	f1 04       	cpc	r15, r1
    502c:	01 05       	cpc	r16, r1
    502e:	11 05       	cpc	r17, r1
    5030:	c9 f0       	breq	.+50     	; 0x5064 <rprintfNum+0xea>
		{
			// calculate next digit
			*--p = hexchar(x%base); x /= base;
    5032:	c8 01       	movw	r24, r16
    5034:	b7 01       	movw	r22, r14
    5036:	a6 01       	movw	r20, r12
    5038:	95 01       	movw	r18, r10
    503a:	0e 94 9c 30 	call	0x6138	; 0x6138 <__udivmodsi4>
    503e:	fb 01       	movw	r30, r22
    5040:	ef 70       	andi	r30, 0x0F	; 15
    5042:	f0 70       	andi	r31, 0x00	; 0
    5044:	ec 51       	subi	r30, 0x1C	; 28
    5046:	fe 4f       	sbci	r31, 0xFE	; 254
    5048:	64 91       	lpm	r22, Z+
    504a:	f2 01       	movw	r30, r4
    504c:	60 83       	st	Z, r22
    504e:	c8 01       	movw	r24, r16
    5050:	b7 01       	movw	r22, r14
    5052:	a6 01       	movw	r20, r12
    5054:	95 01       	movw	r18, r10
    5056:	0e 94 9c 30 	call	0x6138	; 0x6138 <__udivmodsi4>
    505a:	c9 01       	movw	r24, r18
    505c:	da 01       	movw	r26, r20
    505e:	7c 01       	movw	r14, r24
    5060:	8d 01       	movw	r16, r26
    5062:	03 c0       	rjmp	.+6      	; 0x506a <rprintfNum+0xf0>
		}
		else
		{
			// no more digits left, pad out to desired length
			*--p = padchar;
    5064:	2b a1       	ldd	r18, Y+35	; 0x23
    5066:	f2 01       	movw	r30, r4
    5068:	20 83       	st	Z, r18
    506a:	3a 94       	dec	r3
    506c:	08 94       	sec
    506e:	41 08       	sbc	r4, r1
    5070:	51 08       	sbc	r5, r1
	
	// force calculation of first digit
	// (to prevent zero from not printing at all!!!)
	*--p = hexchar(x%base); x /= base;
	// calculate remaining digits
	while(count--)
    5072:	33 20       	and	r3, r3
    5074:	c9 f6       	brne	.-78     	; 0x5028 <rprintfNum+0xae>
    5076:	ce 01       	movw	r24, r28
    5078:	4f 96       	adiw	r24, 0x1f	; 31
    507a:	8c 01       	movw	r16, r24
    507c:	e9 a1       	ldd	r30, Y+33	; 0x21
    507e:	0e 1b       	sub	r16, r30
    5080:	11 09       	sbc	r17, r1
			*--p = padchar;
		}
	}

	// apply signed notation if requested
	if( isSigned )
    5082:	22 20       	and	r2, r2
    5084:	f1 f0       	breq	.+60     	; 0x50c2 <rprintfNum+0x148>
	{
		if(n < 0)
    5086:	97 fe       	sbrs	r9, 7
    5088:	05 c0       	rjmp	.+10     	; 0x5094 <rprintfNum+0x11a>
		{
   			*--p = '-';
    508a:	8d e2       	ldi	r24, 0x2D	; 45
    508c:	f8 01       	movw	r30, r16
    508e:	82 93       	st	-Z, r24
    5090:	8f 01       	movw	r16, r30
    5092:	17 c0       	rjmp	.+46     	; 0x50c2 <rprintfNum+0x148>
    5094:	c8 01       	movw	r24, r16
    5096:	01 97       	sbiw	r24, 0x01	; 1
		}
		else if(n > 0)
    5098:	61 14       	cp	r6, r1
    509a:	71 04       	cpc	r7, r1
    509c:	81 04       	cpc	r8, r1
    509e:	91 04       	cpc	r9, r1
    50a0:	19 f0       	breq	.+6      	; 0x50a8 <rprintfNum+0x12e>
		{
	   		*--p = '+';
    50a2:	8c 01       	movw	r16, r24
    50a4:	8b e2       	ldi	r24, 0x2B	; 43
    50a6:	02 c0       	rjmp	.+4      	; 0x50ac <rprintfNum+0x132>
		}
		else
		{
	   		*--p = ' ';
    50a8:	8c 01       	movw	r16, r24
    50aa:	80 e2       	ldi	r24, 0x20	; 32
    50ac:	f8 01       	movw	r30, r16
    50ae:	80 83       	st	Z, r24
    50b0:	08 c0       	rjmp	.+16     	; 0x50c2 <rprintfNum+0x148>

	// print the string right-justified
	count = numDigits;
	while(count--)
	{
		rprintfChar(*p++);
    50b2:	f8 01       	movw	r30, r16
    50b4:	81 91       	ld	r24, Z+
    50b6:	8f 01       	movw	r16, r30
    50b8:	0e 94 27 27 	call	0x4e4e	; 0x4e4e <rprintfChar>
    50bc:	fa a1       	ldd	r31, Y+34	; 0x22
    50be:	f1 50       	subi	r31, 0x01	; 1
    50c0:	fa a3       	std	Y+34, r31	; 0x22
		}
	}

	// print the string right-justified
	count = numDigits;
	while(count--)
    50c2:	2a a1       	ldd	r18, Y+34	; 0x22
    50c4:	22 23       	and	r18, r18
    50c6:	a9 f7       	brne	.-22     	; 0x50b2 <rprintfNum+0x138>
	{
		rprintfChar(*p++);
	}
}
    50c8:	a3 96       	adiw	r28, 0x23	; 35
    50ca:	0f b6       	in	r0, 0x3f	; 63
    50cc:	f8 94       	cli
    50ce:	de bf       	out	0x3e, r29	; 62
    50d0:	0f be       	out	0x3f, r0	; 63
    50d2:	cd bf       	out	0x3d, r28	; 61
    50d4:	cf 91       	pop	r28
    50d6:	df 91       	pop	r29
    50d8:	1f 91       	pop	r17
    50da:	0f 91       	pop	r16
    50dc:	ff 90       	pop	r15
    50de:	ef 90       	pop	r14
    50e0:	df 90       	pop	r13
    50e2:	cf 90       	pop	r12
    50e4:	bf 90       	pop	r11
    50e6:	af 90       	pop	r10
    50e8:	9f 90       	pop	r9
    50ea:	8f 90       	pop	r8
    50ec:	7f 90       	pop	r7
    50ee:	6f 90       	pop	r6
    50f0:	5f 90       	pop	r5
    50f2:	4f 90       	pop	r4
    50f4:	3f 90       	pop	r3
    50f6:	2f 90       	pop	r2
    50f8:	08 95       	ret

000050fa <rprintfFloat>:

#ifdef RPRINTF_FLOAT
// *** rprintfFloat ***
// floating-point print
void rprintfFloat(char numDigits, double x)
{
    50fa:	4f 92       	push	r4
    50fc:	5f 92       	push	r5
    50fe:	6f 92       	push	r6
    5100:	7f 92       	push	r7
    5102:	8f 92       	push	r8
    5104:	9f 92       	push	r9
    5106:	af 92       	push	r10
    5108:	bf 92       	push	r11
    510a:	cf 92       	push	r12
    510c:	df 92       	push	r13
    510e:	ef 92       	push	r14
    5110:	ff 92       	push	r15
    5112:	0f 93       	push	r16
    5114:	1f 93       	push	r17
    5116:	cf 93       	push	r28
    5118:	df 93       	push	r29
    511a:	48 2e       	mov	r4, r24
    511c:	5a 01       	movw	r10, r20
    511e:	6b 01       	movw	r12, r22
	double place = 1.0;
	
	// save sign
	negative = (x<0);
	// convert to absolute value
	x = (x>0)?(x):(-x);
    5120:	cb 01       	movw	r24, r22
    5122:	ba 01       	movw	r22, r20
    5124:	20 e0       	ldi	r18, 0x00	; 0
    5126:	30 e0       	ldi	r19, 0x00	; 0
    5128:	40 e0       	ldi	r20, 0x00	; 0
    512a:	50 e0       	ldi	r21, 0x00	; 0
    512c:	0e 94 33 2e 	call	0x5c66	; 0x5c66 <__gesf2>
    5130:	18 16       	cp	r1, r24
    5132:	1c f4       	brge	.+6      	; 0x513a <rprintfFloat+0x40>
    5134:	35 01       	movw	r6, r10
    5136:	46 01       	movw	r8, r12
    5138:	06 c0       	rjmp	.+12     	; 0x5146 <rprintfFloat+0x4c>
    513a:	35 01       	movw	r6, r10
    513c:	46 01       	movw	r8, r12
    513e:	97 fa       	bst	r9, 7
    5140:	90 94       	com	r9
    5142:	97 f8       	bld	r9, 7
    5144:	90 94       	com	r9
    5146:	0f 2e       	mov	r0, r31
    5148:	f0 e0       	ldi	r31, 0x00	; 0
    514a:	ef 2e       	mov	r14, r31
    514c:	f0 e0       	ldi	r31, 0x00	; 0
    514e:	ff 2e       	mov	r15, r31
    5150:	f0 e8       	ldi	r31, 0x80	; 128
    5152:	0f 2f       	mov	r16, r31
    5154:	ff e3       	ldi	r31, 0x3F	; 63
    5156:	1f 2f       	mov	r17, r31
    5158:	f0 2d       	mov	r31, r0
    515a:	55 24       	eor	r5, r5
	
	// find starting digit place
	for(i=0; i<15; i++)
	{
		if((x/place) < 10.0)
    515c:	c4 01       	movw	r24, r8
    515e:	b3 01       	movw	r22, r6
    5160:	a8 01       	movw	r20, r16
    5162:	97 01       	movw	r18, r14
    5164:	0e 94 e8 2c 	call	0x59d0	; 0x59d0 <__divsf3>
    5168:	20 e0       	ldi	r18, 0x00	; 0
    516a:	30 e0       	ldi	r19, 0x00	; 0
    516c:	40 e2       	ldi	r20, 0x20	; 32
    516e:	51 e4       	ldi	r21, 0x41	; 65
    5170:	0e 94 e4 2c 	call	0x59c8	; 0x59c8 <__cmpsf2>
    5174:	87 fd       	sbrc	r24, 7
    5176:	0e c0       	rjmp	.+28     	; 0x5194 <rprintfFloat+0x9a>
			break;
		else
			place *= 10.0;
    5178:	c8 01       	movw	r24, r16
    517a:	b7 01       	movw	r22, r14
    517c:	20 e0       	ldi	r18, 0x00	; 0
    517e:	30 e0       	ldi	r19, 0x00	; 0
    5180:	40 e2       	ldi	r20, 0x20	; 32
    5182:	51 e4       	ldi	r21, 0x41	; 65
    5184:	0e 94 37 2e 	call	0x5c6e	; 0x5c6e <__mulsf3>
    5188:	7b 01       	movw	r14, r22
    518a:	8c 01       	movw	r16, r24
	negative = (x<0);
	// convert to absolute value
	x = (x>0)?(x):(-x);
	
	// find starting digit place
	for(i=0; i<15; i++)
    518c:	53 94       	inc	r5
    518e:	8f e0       	ldi	r24, 0x0F	; 15
    5190:	58 16       	cp	r5, r24
    5192:	21 f7       	brne	.-56     	; 0x515c <rprintfFloat+0x62>
			break;
		else
			place *= 10.0;
	}
	// print polarity character
	if(negative)
    5194:	c6 01       	movw	r24, r12
    5196:	b5 01       	movw	r22, r10
    5198:	20 e0       	ldi	r18, 0x00	; 0
    519a:	30 e0       	ldi	r19, 0x00	; 0
    519c:	40 e0       	ldi	r20, 0x00	; 0
    519e:	50 e0       	ldi	r21, 0x00	; 0
    51a0:	0e 94 e4 2c 	call	0x59c8	; 0x59c8 <__cmpsf2>
    51a4:	88 23       	and	r24, r24
    51a6:	14 f4       	brge	.+4      	; 0x51ac <rprintfFloat+0xb2>
		rprintfChar('-');
    51a8:	8d e2       	ldi	r24, 0x2D	; 45
    51aa:	01 c0       	rjmp	.+2      	; 0x51ae <rprintfFloat+0xb4>
	else
		rprintfChar('+');
    51ac:	8b e2       	ldi	r24, 0x2B	; 43
    51ae:	0e 94 27 27 	call	0x4e4e	; 0x4e4e <rprintfChar>
    51b2:	dd 24       	eor	r13, r13
    51b4:	aa 24       	eor	r10, r10
    51b6:	56 c0       	rjmp	.+172    	; 0x5264 <rprintfFloat+0x16a>

	// print digits
	for(i=0; i<numDigits; i++)
	{
		digit = (x/place);
    51b8:	c4 01       	movw	r24, r8
    51ba:	b3 01       	movw	r22, r6
    51bc:	a8 01       	movw	r20, r16
    51be:	97 01       	movw	r18, r14
    51c0:	0e 94 e8 2c 	call	0x59d0	; 0x59d0 <__divsf3>
    51c4:	0e 94 55 2d 	call	0x5aaa	; 0x5aaa <__fixunssfsi>
    51c8:	b6 2e       	mov	r11, r22

		if(digit | firstplace | (place == 1.0))
    51ca:	d6 2a       	or	r13, r22
    51cc:	cd 2d       	mov	r28, r13
    51ce:	d0 e0       	ldi	r29, 0x00	; 0
    51d0:	cc 24       	eor	r12, r12
    51d2:	dd 24       	eor	r13, r13
    51d4:	c8 01       	movw	r24, r16
    51d6:	b7 01       	movw	r22, r14
    51d8:	20 e0       	ldi	r18, 0x00	; 0
    51da:	30 e0       	ldi	r19, 0x00	; 0
    51dc:	40 e8       	ldi	r20, 0x80	; 128
    51de:	5f e3       	ldi	r21, 0x3F	; 63
    51e0:	0e 94 e4 2c 	call	0x59c8	; 0x59c8 <__cmpsf2>
    51e4:	88 23       	and	r24, r24
    51e6:	19 f4       	brne	.+6      	; 0x51ee <rprintfFloat+0xf4>
    51e8:	21 e0       	ldi	r18, 0x01	; 1
    51ea:	c2 2e       	mov	r12, r18
    51ec:	d1 2c       	mov	r13, r1
    51ee:	cc 29       	or	r28, r12
    51f0:	dd 29       	or	r29, r13
    51f2:	cd 2b       	or	r28, r29
    51f4:	39 f0       	breq	.+14     	; 0x5204 <rprintfFloat+0x10a>
		{
			firstplace = TRUE;
			rprintfChar(digit+0x30);
    51f6:	8b 2d       	mov	r24, r11
    51f8:	80 5d       	subi	r24, 0xD0	; 208
    51fa:	0e 94 27 27 	call	0x4e4e	; 0x4e4e <rprintfChar>
    51fe:	dd 24       	eor	r13, r13
    5200:	da 94       	dec	r13
    5202:	04 c0       	rjmp	.+8      	; 0x520c <rprintfFloat+0x112>
		}
		else
			rprintfChar(' ');
    5204:	80 e2       	ldi	r24, 0x20	; 32
    5206:	0e 94 27 27 	call	0x4e4e	; 0x4e4e <rprintfChar>
    520a:	dd 24       	eor	r13, r13
		
		if(place == 1.0)
    520c:	c8 01       	movw	r24, r16
    520e:	b7 01       	movw	r22, r14
    5210:	20 e0       	ldi	r18, 0x00	; 0
    5212:	30 e0       	ldi	r19, 0x00	; 0
    5214:	40 e8       	ldi	r20, 0x80	; 128
    5216:	5f e3       	ldi	r21, 0x3F	; 63
    5218:	0e 94 e4 2c 	call	0x59c8	; 0x59c8 <__cmpsf2>
    521c:	88 23       	and	r24, r24
    521e:	19 f4       	brne	.+6      	; 0x5226 <rprintfFloat+0x12c>
		{
			rprintfChar('.');
    5220:	8e e2       	ldi	r24, 0x2E	; 46
    5222:	0e 94 27 27 	call	0x4e4e	; 0x4e4e <rprintfChar>
		}
		
		x -= (digit*place);
    5226:	6b 2d       	mov	r22, r11
    5228:	70 e0       	ldi	r23, 0x00	; 0
    522a:	88 27       	eor	r24, r24
    522c:	77 fd       	sbrc	r23, 7
    522e:	80 95       	com	r24
    5230:	98 2f       	mov	r25, r24
    5232:	0e 94 83 2d 	call	0x5b06	; 0x5b06 <__floatsisf>
    5236:	a8 01       	movw	r20, r16
    5238:	97 01       	movw	r18, r14
    523a:	0e 94 37 2e 	call	0x5c6e	; 0x5c6e <__mulsf3>
    523e:	9b 01       	movw	r18, r22
    5240:	ac 01       	movw	r20, r24
    5242:	c4 01       	movw	r24, r8
    5244:	b3 01       	movw	r22, r6
    5246:	0e 94 7f 2c 	call	0x58fe	; 0x58fe <__subsf3>
    524a:	3b 01       	movw	r6, r22
    524c:	4c 01       	movw	r8, r24
		place /= 10.0;
    524e:	c8 01       	movw	r24, r16
    5250:	b7 01       	movw	r22, r14
    5252:	20 e0       	ldi	r18, 0x00	; 0
    5254:	30 e0       	ldi	r19, 0x00	; 0
    5256:	40 e2       	ldi	r20, 0x20	; 32
    5258:	51 e4       	ldi	r21, 0x41	; 65
    525a:	0e 94 e8 2c 	call	0x59d0	; 0x59d0 <__divsf3>
    525e:	7b 01       	movw	r14, r22
    5260:	8c 01       	movw	r16, r24
		rprintfChar('-');
	else
		rprintfChar('+');

	// print digits
	for(i=0; i<numDigits; i++)
    5262:	a3 94       	inc	r10
    5264:	a4 14       	cp	r10, r4
    5266:	08 f4       	brcc	.+2      	; 0x526a <rprintfFloat+0x170>
    5268:	a7 cf       	rjmp	.-178    	; 0x51b8 <rprintfFloat+0xbe>
		}
		
		x -= (digit*place);
		place /= 10.0;
	}
}
    526a:	df 91       	pop	r29
    526c:	cf 91       	pop	r28
    526e:	1f 91       	pop	r17
    5270:	0f 91       	pop	r16
    5272:	ff 90       	pop	r15
    5274:	ef 90       	pop	r14
    5276:	df 90       	pop	r13
    5278:	cf 90       	pop	r12
    527a:	bf 90       	pop	r11
    527c:	af 90       	pop	r10
    527e:	9f 90       	pop	r9
    5280:	8f 90       	pop	r8
    5282:	7f 90       	pop	r7
    5284:	6f 90       	pop	r6
    5286:	5f 90       	pop	r5
    5288:	4f 90       	pop	r4
    528a:	08 95       	ret

0000528c <rprintf1RamRom>:
// Supports:
// %d - decimal
// %x - hex
// %c - character
int rprintf1RamRom(unsigned char stringInRom, const char *format, ...)
{
    528c:	7f 92       	push	r7
    528e:	8f 92       	push	r8
    5290:	9f 92       	push	r9
    5292:	af 92       	push	r10
    5294:	bf 92       	push	r11
    5296:	cf 92       	push	r12
    5298:	df 92       	push	r13
    529a:	ef 92       	push	r14
    529c:	ff 92       	push	r15
    529e:	0f 93       	push	r16
    52a0:	1f 93       	push	r17
    52a2:	df 93       	push	r29
    52a4:	cf 93       	push	r28
    52a6:	cd b7       	in	r28, 0x3d	; 61
    52a8:	de b7       	in	r29, 0x3e	; 62
    52aa:	78 88       	ldd	r7, Y+16	; 0x10
    52ac:	c9 88       	ldd	r12, Y+17	; 0x11
    52ae:	da 88       	ldd	r13, Y+18	; 0x12
    52b0:	63 e1       	ldi	r22, 0x13	; 19
    52b2:	e6 2e       	mov	r14, r22
    52b4:	f1 2c       	mov	r15, r1
    52b6:	ec 0e       	add	r14, r28
    52b8:	fd 1e       	adc	r15, r29
    52ba:	14 c0       	rjmp	.+40     	; 0x52e4 <rprintf1RamRom+0x58>
	va_start(ap, format);
	for (;;)
	{
		while ((format_flag = READMEMBYTE(stringInRom,format++) ) != '%')
		{	// Until '%' or '\0'
			if (!format_flag)
    52bc:	88 23       	and	r24, r24
    52be:	81 f4       	brne	.+32     	; 0x52e0 <rprintf1RamRom+0x54>
				div_val /= base;
			} while (div_val);
		}
	}
	va_end(ap);
}
    52c0:	80 e0       	ldi	r24, 0x00	; 0
    52c2:	90 e0       	ldi	r25, 0x00	; 0
    52c4:	cf 91       	pop	r28
    52c6:	df 91       	pop	r29
    52c8:	1f 91       	pop	r17
    52ca:	0f 91       	pop	r16
    52cc:	ff 90       	pop	r15
    52ce:	ef 90       	pop	r14
    52d0:	df 90       	pop	r13
    52d2:	cf 90       	pop	r12
    52d4:	bf 90       	pop	r11
    52d6:	af 90       	pop	r10
    52d8:	9f 90       	pop	r9
    52da:	8f 90       	pop	r8
    52dc:	7f 90       	pop	r7
    52de:	08 95       	ret
			if (!format_flag)
			{
				va_end(ap);
				return(0);
			}
			rprintfChar(format_flag);
    52e0:	0e 94 27 27 	call	0x4e4e	; 0x4e4e <rprintfChar>
    52e4:	96 01       	movw	r18, r12
    52e6:	2f 5f       	subi	r18, 0xFF	; 255
    52e8:	3f 4f       	sbci	r19, 0xFF	; 255
	va_list ap;

	va_start(ap, format);
	for (;;)
	{
		while ((format_flag = READMEMBYTE(stringInRom,format++) ) != '%')
    52ea:	77 20       	and	r7, r7
    52ec:	21 f0       	breq	.+8      	; 0x52f6 <rprintf1RamRom+0x6a>
    52ee:	f6 01       	movw	r30, r12
    52f0:	69 01       	movw	r12, r18
    52f2:	84 91       	lpm	r24, Z+
    52f4:	03 c0       	rjmp	.+6      	; 0x52fc <rprintf1RamRom+0x70>
    52f6:	f6 01       	movw	r30, r12
    52f8:	80 81       	ld	r24, Z
    52fa:	69 01       	movw	r12, r18
    52fc:	85 32       	cpi	r24, 0x25	; 37
    52fe:	f1 f6       	brne	.-68     	; 0x52bc <rprintf1RamRom+0x30>
    5300:	2f 5f       	subi	r18, 0xFF	; 255
    5302:	3f 4f       	sbci	r19, 0xFF	; 255
				return(0);
			}
			rprintfChar(format_flag);
		}

		switch (format_flag = READMEMBYTE(stringInRom,format++) )
    5304:	77 20       	and	r7, r7
    5306:	21 f0       	breq	.+8      	; 0x5310 <rprintf1RamRom+0x84>
    5308:	f6 01       	movw	r30, r12
    530a:	69 01       	movw	r12, r18
    530c:	84 91       	lpm	r24, Z+
    530e:	03 c0       	rjmp	.+6      	; 0x5316 <rprintf1RamRom+0x8a>
    5310:	f6 01       	movw	r30, r12
    5312:	80 81       	ld	r24, Z
    5314:	69 01       	movw	r12, r18
    5316:	84 36       	cpi	r24, 0x64	; 100
    5318:	29 f0       	breq	.+10     	; 0x5324 <rprintf1RamRom+0x98>
    531a:	88 37       	cpi	r24, 0x78	; 120
    531c:	81 f0       	breq	.+32     	; 0x533e <rprintf1RamRom+0xb2>
    531e:	83 36       	cpi	r24, 0x63	; 99
    5320:	f9 f6       	brne	.-66     	; 0x52e0 <rprintf1RamRom+0x54>
    5322:	06 c0       	rjmp	.+12     	; 0x5330 <rprintf1RamRom+0xa4>
    5324:	00 e1       	ldi	r16, 0x10	; 16
    5326:	17 e2       	ldi	r17, 0x27	; 39
    5328:	5a e0       	ldi	r21, 0x0A	; 10
    532a:	a5 2e       	mov	r10, r21
    532c:	b1 2c       	mov	r11, r1
    532e:	0c c0       	rjmp	.+24     	; 0x5348 <rprintf1RamRom+0xbc>
		{
			case 'c': format_flag = va_arg(ap,int);
    5330:	f7 01       	movw	r30, r14
    5332:	80 81       	ld	r24, Z
    5334:	22 e0       	ldi	r18, 0x02	; 2
    5336:	30 e0       	ldi	r19, 0x00	; 0
    5338:	e2 0e       	add	r14, r18
    533a:	f3 1e       	adc	r15, r19
    533c:	d1 cf       	rjmp	.-94     	; 0x52e0 <rprintf1RamRom+0x54>
			default:  rprintfChar(format_flag); continue;
    533e:	00 e0       	ldi	r16, 0x00	; 0
    5340:	10 e1       	ldi	r17, 0x10	; 16
    5342:	40 e1       	ldi	r20, 0x10	; 16
    5344:	a4 2e       	mov	r10, r20
    5346:	b1 2c       	mov	r11, r1
			case 'd': base = 10; div_val = 10000; goto CONVERSION_LOOP;
//			case 'x': base = 16; div_val = 0x10;
			case 'x': base = 16; div_val = 0x1000;

			CONVERSION_LOOP:
			u_val = va_arg(ap,int);
    5348:	32 e0       	ldi	r19, 0x02	; 2
    534a:	83 2e       	mov	r8, r19
    534c:	91 2c       	mov	r9, r1
    534e:	8e 0c       	add	r8, r14
    5350:	9f 1c       	adc	r9, r15
    5352:	f7 01       	movw	r30, r14
    5354:	e0 80       	ld	r14, Z
    5356:	f1 80       	ldd	r15, Z+1	; 0x01
			if (format_flag == 'd')
    5358:	84 36       	cpi	r24, 0x64	; 100
    535a:	b1 f4       	brne	.+44     	; 0x5388 <rprintf1RamRom+0xfc>
			{
				if (((int)u_val) < 0)
    535c:	f7 fe       	sbrs	r15, 7
    535e:	11 c0       	rjmp	.+34     	; 0x5382 <rprintf1RamRom+0xf6>
				{
					u_val = - u_val;
    5360:	f0 94       	com	r15
    5362:	e1 94       	neg	r14
    5364:	f1 08       	sbc	r15, r1
    5366:	f3 94       	inc	r15
					rprintfChar('-');
    5368:	8d e2       	ldi	r24, 0x2D	; 45
    536a:	0e 94 27 27 	call	0x4e4e	; 0x4e4e <rprintfChar>
    536e:	09 c0       	rjmp	.+18     	; 0x5382 <rprintf1RamRom+0xf6>
				}
				while (div_val > 1 && div_val > u_val) div_val /= 10;
    5370:	c8 01       	movw	r24, r16
    5372:	6a e0       	ldi	r22, 0x0A	; 10
    5374:	70 e0       	ldi	r23, 0x00	; 0
    5376:	0e 94 75 30 	call	0x60ea	; 0x60ea <__udivmodhi4>
    537a:	8b 01       	movw	r16, r22
    537c:	62 30       	cpi	r22, 0x02	; 2
    537e:	71 05       	cpc	r23, r1
    5380:	18 f0       	brcs	.+6      	; 0x5388 <rprintf1RamRom+0xfc>
    5382:	e0 16       	cp	r14, r16
    5384:	f1 06       	cpc	r15, r17
    5386:	a0 f3       	brcs	.-24     	; 0x5370 <rprintf1RamRom+0xe4>
			}
			do
			{
				//rprintfChar(pgm_read_byte(HexChars+(u_val/div_val)));
				rprintfu04(u_val/div_val);
    5388:	c7 01       	movw	r24, r14
    538a:	b8 01       	movw	r22, r16
    538c:	0e 94 75 30 	call	0x60ea	; 0x60ea <__udivmodhi4>
    5390:	86 2f       	mov	r24, r22
    5392:	0e 94 8a 27 	call	0x4f14	; 0x4f14 <rprintfu04>
				u_val %= div_val;
    5396:	c7 01       	movw	r24, r14
    5398:	b8 01       	movw	r22, r16
    539a:	0e 94 75 30 	call	0x60ea	; 0x60ea <__udivmodhi4>
    539e:	7c 01       	movw	r14, r24
				div_val /= base;
    53a0:	c8 01       	movw	r24, r16
    53a2:	b5 01       	movw	r22, r10
    53a4:	0e 94 75 30 	call	0x60ea	; 0x60ea <__udivmodhi4>
    53a8:	8b 01       	movw	r16, r22
			} while (div_val);
    53aa:	61 15       	cp	r22, r1
    53ac:	71 05       	cpc	r23, r1
    53ae:	61 f7       	brne	.-40     	; 0x5388 <rprintf1RamRom+0xfc>
    53b0:	74 01       	movw	r14, r8
    53b2:	98 cf       	rjmp	.-208    	; 0x52e4 <rprintf1RamRom+0x58>

000053b4 <i2cSetBitrate>:
	// SCL freq = F_CPU/(16+2*TWBR))
	#ifdef TWPS0
		// for processors with additional bitrate division (mega128)
		// SCL freq = F_CPU/(16+2*TWBR*4^TWPS)
		// set TWPS to zero
		cbi(TWSR, TWPS0);
    53b4:	20 91 b9 00 	lds	r18, 0x00B9
    53b8:	2e 7f       	andi	r18, 0xFE	; 254
    53ba:	20 93 b9 00 	sts	0x00B9, r18
		cbi(TWSR, TWPS1);
    53be:	20 91 b9 00 	lds	r18, 0x00B9
    53c2:	2d 7f       	andi	r18, 0xFD	; 253
    53c4:	20 93 b9 00 	sts	0x00B9, r18
	#endif
	// calculate bitrate division	
	bitrate_div = ((F_CPU/1000l)/bitrateKHz);
    53c8:	9c 01       	movw	r18, r24
    53ca:	40 e0       	ldi	r20, 0x00	; 0
    53cc:	50 e0       	ldi	r21, 0x00	; 0
    53ce:	60 e8       	ldi	r22, 0x80	; 128
    53d0:	7e e3       	ldi	r23, 0x3E	; 62
    53d2:	80 e0       	ldi	r24, 0x00	; 0
    53d4:	90 e0       	ldi	r25, 0x00	; 0
    53d6:	0e 94 be 30 	call	0x617c	; 0x617c <__divmodsi4>
	if(bitrate_div >= 16)
    53da:	20 31       	cpi	r18, 0x10	; 16
    53dc:	30 f0       	brcs	.+12     	; 0x53ea <i2cSetBitrate+0x36>
		bitrate_div = (bitrate_div-16)/2;
    53de:	82 2f       	mov	r24, r18
    53e0:	90 e0       	ldi	r25, 0x00	; 0
    53e2:	40 97       	sbiw	r24, 0x10	; 16
    53e4:	95 95       	asr	r25
    53e6:	87 95       	ror	r24
    53e8:	28 2f       	mov	r18, r24
	outb(TWBR, bitrate_div);
    53ea:	20 93 b8 00 	sts	0x00B8, r18
}
    53ee:	08 95       	ret

000053f0 <i2cInit>:

// functions
void i2cInit(void)
{
	// set pull-up resistors on I2C bus pins
	sbi(PORTD, 0);	// i2c SCL on 640
    53f0:	58 9a       	sbi	0x0b, 0	; 11
	sbi(PORTD, 1);	// i2c SDA on 640
    53f2:	59 9a       	sbi	0x0b, 1	; 11

	// clear SlaveReceive and SlaveTransmit handler to null
	i2cSlaveReceive = 0;
    53f4:	10 92 08 12 	sts	0x1208, r1
    53f8:	10 92 07 12 	sts	0x1207, r1
	i2cSlaveTransmit = 0;
    53fc:	10 92 0a 12 	sts	0x120A, r1
    5400:	10 92 09 12 	sts	0x1209, r1
	// set i2c bit rate to 100KHz
	i2cSetBitrate(100);
    5404:	84 e6       	ldi	r24, 0x64	; 100
    5406:	90 e0       	ldi	r25, 0x00	; 0
    5408:	0e 94 da 29 	call	0x53b4	; 0x53b4 <i2cSetBitrate>
	// enable TWI (two-wire interface)
	sbi(TWCR, TWEN);
    540c:	ec eb       	ldi	r30, 0xBC	; 188
    540e:	f0 e0       	ldi	r31, 0x00	; 0
    5410:	80 81       	ld	r24, Z
    5412:	84 60       	ori	r24, 0x04	; 4
    5414:	80 83       	st	Z, r24
	// set state
	I2cState = I2C_IDLE;
    5416:	10 92 c1 11 	sts	0x11C1, r1
	// enable TWI interrupt and slave address ACK
	sbi(TWCR, TWIE);
    541a:	80 81       	ld	r24, Z
    541c:	81 60       	ori	r24, 0x01	; 1
    541e:	80 83       	st	Z, r24
	sbi(TWCR, TWEA);
    5420:	80 81       	ld	r24, Z
    5422:	80 64       	ori	r24, 0x40	; 64
    5424:	80 83       	st	Z, r24
	//outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
	// enable interrupts
	sei();
    5426:	78 94       	sei
}
    5428:	08 95       	ret

0000542a <i2cSetLocalDeviceAddr>:
}

void i2cSetLocalDeviceAddr(u08 deviceAddr, u08 genCallEn)
{
	// set local device address (used in slave mode only)
	outb(TWAR, ((deviceAddr&0xFE) | (genCallEn?1:0)) );
    542a:	90 e0       	ldi	r25, 0x00	; 0
    542c:	61 11       	cpse	r22, r1
    542e:	91 e0       	ldi	r25, 0x01	; 1
    5430:	8e 7f       	andi	r24, 0xFE	; 254
    5432:	98 2b       	or	r25, r24
    5434:	90 93 ba 00 	sts	0x00BA, r25
}
    5438:	08 95       	ret

0000543a <i2cSetSlaveReceiveHandler>:

void i2cSetSlaveReceiveHandler(void (*i2cSlaveRx_func)(u08 receiveDataLength, u08* recieveData))
{
	i2cSlaveReceive = i2cSlaveRx_func;
    543a:	90 93 08 12 	sts	0x1208, r25
    543e:	80 93 07 12 	sts	0x1207, r24
}
    5442:	08 95       	ret

00005444 <i2cSetSlaveTransmitHandler>:

void i2cSetSlaveTransmitHandler(u08 (*i2cSlaveTx_func)(u08 transmitDataLengthMax, u08* transmitData))
{
	i2cSlaveTransmit = i2cSlaveTx_func;
    5444:	90 93 0a 12 	sts	0x120A, r25
    5448:	80 93 09 12 	sts	0x1209, r24
}
    544c:	08 95       	ret

0000544e <i2cSendStart>:

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    544e:	ec eb       	ldi	r30, 0xBC	; 188
    5450:	f0 e0       	ldi	r31, 0x00	; 0
    5452:	80 81       	ld	r24, Z
    5454:	8f 70       	andi	r24, 0x0F	; 15
    5456:	80 6a       	ori	r24, 0xA0	; 160
    5458:	80 83       	st	Z, r24
}
    545a:	08 95       	ret

0000545c <i2cSendStop>:

inline void i2cSendStop(void)
{
	// transmit stop condition
	// leave with TWEA on for slave receiving
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA)|BV(TWSTO));
    545c:	ec eb       	ldi	r30, 0xBC	; 188
    545e:	f0 e0       	ldi	r31, 0x00	; 0
    5460:	80 81       	ld	r24, Z
    5462:	8f 70       	andi	r24, 0x0F	; 15
    5464:	80 6d       	ori	r24, 0xD0	; 208
    5466:	80 83       	st	Z, r24
}
    5468:	08 95       	ret

0000546a <i2cWaitForComplete>:

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    546a:	80 91 bc 00 	lds	r24, 0x00BC
    546e:	87 ff       	sbrs	r24, 7
    5470:	fc cf       	rjmp	.-8      	; 0x546a <i2cWaitForComplete>
}
    5472:	08 95       	ret

00005474 <i2cSendByte>:

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    5474:	80 93 bb 00 	sts	0x00BB, r24
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    5478:	ec eb       	ldi	r30, 0xBC	; 188
    547a:	f0 e0       	ldi	r31, 0x00	; 0
    547c:	80 81       	ld	r24, Z
    547e:	8f 70       	andi	r24, 0x0F	; 15
    5480:	80 68       	ori	r24, 0x80	; 128
    5482:	80 83       	st	Z, r24
}
    5484:	08 95       	ret

00005486 <i2cReceiveByte>:

inline void i2cReceiveByte(u08 ackFlag)
{
	// begin receive over i2c
	if( ackFlag )
    5486:	88 23       	and	r24, r24
    5488:	29 f0       	breq	.+10     	; 0x5494 <i2cReceiveByte+0xe>
	{
		// ackFlag = TRUE: ACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    548a:	80 91 bc 00 	lds	r24, 0x00BC
    548e:	8f 70       	andi	r24, 0x0F	; 15
    5490:	80 6c       	ori	r24, 0xC0	; 192
    5492:	04 c0       	rjmp	.+8      	; 0x549c <i2cReceiveByte+0x16>
	}
	else
	{
		// ackFlag = FALSE: NACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    5494:	80 91 bc 00 	lds	r24, 0x00BC
    5498:	8f 70       	andi	r24, 0x0F	; 15
    549a:	80 68       	ori	r24, 0x80	; 128
    549c:	80 93 bc 00 	sts	0x00BC, r24
    54a0:	08 95       	ret

000054a2 <i2cGetReceivedByte>:
}

inline u08 i2cGetReceivedByte(void)
{
	// retieve received data byte from i2c TWDR
	return( inb(TWDR) );
    54a2:	80 91 bb 00 	lds	r24, 0x00BB
}
    54a6:	08 95       	ret

000054a8 <i2cGetStatus>:

inline u08 i2cGetStatus(void)
{
	// retieve current i2c status from i2c TWSR
	return( inb(TWSR) );
    54a8:	80 91 b9 00 	lds	r24, 0x00B9
}
    54ac:	08 95       	ret

000054ae <i2cMasterSend>:

void i2cMasterSend(u08 deviceAddr, u08 length, u08* data)
{
    54ae:	98 2f       	mov	r25, r24
	u08 i;
	// wait for interface to be ready
	while(I2cState);
    54b0:	80 91 c1 11 	lds	r24, 0x11C1
    54b4:	88 23       	and	r24, r24
    54b6:	e1 f7       	brne	.-8      	; 0x54b0 <i2cMasterSend+0x2>
	// set state
	I2cState = I2C_MASTER_TX;
    54b8:	82 e0       	ldi	r24, 0x02	; 2
    54ba:	80 93 c1 11 	sts	0x11C1, r24
	// save data
	I2cDeviceAddrRW = (deviceAddr & 0xFE);	// RW cleared: write operation
    54be:	9e 7f       	andi	r25, 0xFE	; 254
    54c0:	90 93 c2 11 	sts	0x11C2, r25
    54c4:	a3 ec       	ldi	r26, 0xC3	; 195
    54c6:	b1 e1       	ldi	r27, 0x11	; 17
    54c8:	fa 01       	movw	r30, r20
    54ca:	02 c0       	rjmp	.+4      	; 0x54d0 <i2cMasterSend+0x22>
	for(i=0; i<length; i++)
		I2cSendData[i] = *data++;
    54cc:	81 91       	ld	r24, Z+
    54ce:	8d 93       	st	X+, r24
	while(I2cState);
	// set state
	I2cState = I2C_MASTER_TX;
	// save data
	I2cDeviceAddrRW = (deviceAddr & 0xFE);	// RW cleared: write operation
	for(i=0; i<length; i++)
    54d0:	8e 2f       	mov	r24, r30
    54d2:	84 1b       	sub	r24, r20
    54d4:	86 17       	cp	r24, r22
    54d6:	d0 f3       	brcs	.-12     	; 0x54cc <i2cMasterSend+0x1e>
		I2cSendData[i] = *data++;
	I2cSendDataIndex = 0;
    54d8:	10 92 e3 11 	sts	0x11E3, r1
	I2cSendDataLength = length;
    54dc:	60 93 e4 11 	sts	0x11E4, r22
}

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    54e0:	80 91 bc 00 	lds	r24, 0x00BC
    54e4:	8f 70       	andi	r24, 0x0F	; 15
    54e6:	80 6a       	ori	r24, 0xA0	; 160
    54e8:	80 93 bc 00 	sts	0x00BC, r24
		I2cSendData[i] = *data++;
	I2cSendDataIndex = 0;
	I2cSendDataLength = length;
	// send start condition
	i2cSendStart();
}
    54ec:	08 95       	ret

000054ee <i2cMasterReceive>:

void i2cMasterReceive(u08 deviceAddr, u08 length, u08* data)
{
    54ee:	98 2f       	mov	r25, r24
	u08 i;
	// wait for interface to be ready
	while(I2cState);
    54f0:	80 91 c1 11 	lds	r24, 0x11C1
    54f4:	88 23       	and	r24, r24
    54f6:	e1 f7       	brne	.-8      	; 0x54f0 <i2cMasterReceive+0x2>
	// set state
	I2cState = I2C_MASTER_RX;
    54f8:	83 e0       	ldi	r24, 0x03	; 3
    54fa:	80 93 c1 11 	sts	0x11C1, r24
	// save data
	I2cDeviceAddrRW = (deviceAddr|0x01);	// RW set: read operation
    54fe:	91 60       	ori	r25, 0x01	; 1
    5500:	90 93 c2 11 	sts	0x11C2, r25
	I2cReceiveDataIndex = 0;
    5504:	10 92 05 12 	sts	0x1205, r1
	I2cReceiveDataLength = length;
    5508:	60 93 06 12 	sts	0x1206, r22
}

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    550c:	80 91 bc 00 	lds	r24, 0x00BC
    5510:	8f 70       	andi	r24, 0x0F	; 15
    5512:	80 6a       	ori	r24, 0xA0	; 160
    5514:	80 93 bc 00 	sts	0x00BC, r24
	I2cReceiveDataIndex = 0;
	I2cReceiveDataLength = length;
	// send start condition
	i2cSendStart();
	// wait for data
	while(I2cState);
    5518:	80 91 c1 11 	lds	r24, 0x11C1
    551c:	88 23       	and	r24, r24
    551e:	e1 f7       	brne	.-8      	; 0x5518 <i2cMasterReceive+0x2a>
    5520:	a5 ee       	ldi	r26, 0xE5	; 229
    5522:	b1 e1       	ldi	r27, 0x11	; 17
    5524:	fa 01       	movw	r30, r20
    5526:	02 c0       	rjmp	.+4      	; 0x552c <i2cMasterReceive+0x3e>
	// return data
	for(i=0; i<length; i++)
		*data++ = I2cReceiveData[i];
    5528:	8d 91       	ld	r24, X+
    552a:	81 93       	st	Z+, r24
	// send start condition
	i2cSendStart();
	// wait for data
	while(I2cState);
	// return data
	for(i=0; i<length; i++)
    552c:	8e 2f       	mov	r24, r30
    552e:	84 1b       	sub	r24, r20
    5530:	86 17       	cp	r24, r22
    5532:	d0 f3       	brcs	.-12     	; 0x5528 <i2cMasterReceive+0x3a>
		*data++ = I2cReceiveData[i];
}
    5534:	08 95       	ret

00005536 <i2cMasterSendNI>:

u08 i2cMasterSendNI(u08 deviceAddr, u08 length, u08* data)
{
    5536:	98 2f       	mov	r25, r24
    5538:	fa 01       	movw	r30, r20
	u08 retval = I2C_OK;

	// disable TWI interrupt
	cbi(TWCR, TWIE);
    553a:	80 91 bc 00 	lds	r24, 0x00BC
    553e:	8e 7f       	andi	r24, 0xFE	; 254
    5540:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    5544:	80 91 bc 00 	lds	r24, 0x00BC
    5548:	8f 70       	andi	r24, 0x0F	; 15
    554a:	80 6a       	ori	r24, 0xA0	; 160
    554c:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    5550:	80 91 bc 00 	lds	r24, 0x00BC
    5554:	87 ff       	sbrs	r24, 7
    5556:	fc cf       	rjmp	.-8      	; 0x5550 <i2cMasterSendNI+0x1a>
	// send start condition
	i2cSendStart();
	i2cWaitForComplete();

	// send device address with write
	i2cSendByte( deviceAddr & 0xFE );
    5558:	9e 7f       	andi	r25, 0xFE	; 254
}

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    555a:	90 93 bb 00 	sts	0x00BB, r25
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    555e:	80 91 bc 00 	lds	r24, 0x00BC
    5562:	8f 70       	andi	r24, 0x0F	; 15
    5564:	80 68       	ori	r24, 0x80	; 128
    5566:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    556a:	80 91 bc 00 	lds	r24, 0x00BC
    556e:	87 ff       	sbrs	r24, 7
    5570:	fc cf       	rjmp	.-8      	; 0x556a <i2cMasterSendNI+0x34>
	// send device address with write
	i2cSendByte( deviceAddr & 0xFE );
	i2cWaitForComplete();

	// check if device is present and live
	if( inb(TWSR) == TW_MT_SLA_ACK)
    5572:	80 91 b9 00 	lds	r24, 0x00B9
    5576:	88 31       	cpi	r24, 0x18	; 24
    5578:	89 f0       	breq	.+34     	; 0x559c <i2cMasterSendNI+0x66>
    557a:	91 e0       	ldi	r25, 0x01	; 1
    557c:	12 c0       	rjmp	.+36     	; 0x55a2 <i2cMasterSendNI+0x6c>
	{
		// send data
		while(length)
		{
			i2cSendByte( *data++ );
    557e:	80 81       	ld	r24, Z
}

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    5580:	80 93 bb 00 	sts	0x00BB, r24
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    5584:	80 91 bc 00 	lds	r24, 0x00BC
    5588:	8f 70       	andi	r24, 0x0F	; 15
    558a:	80 68       	ori	r24, 0x80	; 128
    558c:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    5590:	80 91 bc 00 	lds	r24, 0x00BC
    5594:	87 ff       	sbrs	r24, 7
    5596:	fc cf       	rjmp	.-8      	; 0x5590 <i2cMasterSendNI+0x5a>
	if( inb(TWSR) == TW_MT_SLA_ACK)
	{
		// send data
		while(length)
		{
			i2cSendByte( *data++ );
    5598:	31 96       	adiw	r30, 0x01	; 1
			i2cWaitForComplete();
			length--;
    559a:	61 50       	subi	r22, 0x01	; 1

	// check if device is present and live
	if( inb(TWSR) == TW_MT_SLA_ACK)
	{
		// send data
		while(length)
    559c:	66 23       	and	r22, r22
    559e:	79 f7       	brne	.-34     	; 0x557e <i2cMasterSendNI+0x48>
    55a0:	90 e0       	ldi	r25, 0x00	; 0

inline void i2cSendStop(void)
{
	// transmit stop condition
	// leave with TWEA on for slave receiving
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA)|BV(TWSTO));
    55a2:	80 91 bc 00 	lds	r24, 0x00BC
    55a6:	8f 70       	andi	r24, 0x0F	; 15
    55a8:	80 6d       	ori	r24, 0xD0	; 208
    55aa:	80 93 bc 00 	sts	0x00BC, r24
	}

	// transmit stop condition
	// leave with TWEA on for slave receiving
	i2cSendStop();
	while( !(inb(TWCR) & BV(TWSTO)) );
    55ae:	80 91 bc 00 	lds	r24, 0x00BC
    55b2:	84 ff       	sbrs	r24, 4
    55b4:	fc cf       	rjmp	.-8      	; 0x55ae <i2cMasterSendNI+0x78>

	// enable TWI interrupt
	sbi(TWCR, TWIE);
    55b6:	80 91 bc 00 	lds	r24, 0x00BC
    55ba:	81 60       	ori	r24, 0x01	; 1
    55bc:	80 93 bc 00 	sts	0x00BC, r24

	return retval;
}
    55c0:	89 2f       	mov	r24, r25
    55c2:	08 95       	ret

000055c4 <i2cMasterReceiveNI>:

u08 i2cMasterReceiveNI(u08 deviceAddr, u08 length, u08 *data)
{
    55c4:	98 2f       	mov	r25, r24
    55c6:	fa 01       	movw	r30, r20
	u08 retval = I2C_OK;

	// disable TWI interrupt
	cbi(TWCR, TWIE);
    55c8:	80 91 bc 00 	lds	r24, 0x00BC
    55cc:	8e 7f       	andi	r24, 0xFE	; 254
    55ce:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    55d2:	80 91 bc 00 	lds	r24, 0x00BC
    55d6:	8f 70       	andi	r24, 0x0F	; 15
    55d8:	80 6a       	ori	r24, 0xA0	; 160
    55da:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    55de:	80 91 bc 00 	lds	r24, 0x00BC
    55e2:	87 ff       	sbrs	r24, 7
    55e4:	fc cf       	rjmp	.-8      	; 0x55de <i2cMasterReceiveNI+0x1a>
	// send start condition
	i2cSendStart();
	i2cWaitForComplete();

	// send device address with read
	i2cSendByte( deviceAddr | 0x01 );
    55e6:	91 60       	ori	r25, 0x01	; 1
}

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    55e8:	90 93 bb 00 	sts	0x00BB, r25
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    55ec:	80 91 bc 00 	lds	r24, 0x00BC
    55f0:	8f 70       	andi	r24, 0x0F	; 15
    55f2:	80 68       	ori	r24, 0x80	; 128
    55f4:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    55f8:	80 91 bc 00 	lds	r24, 0x00BC
    55fc:	87 ff       	sbrs	r24, 7
    55fe:	fc cf       	rjmp	.-8      	; 0x55f8 <i2cMasterReceiveNI+0x34>
	// send device address with read
	i2cSendByte( deviceAddr | 0x01 );
	i2cWaitForComplete();

	// check if device is present and live
	if( inb(TWSR) == TW_MR_SLA_ACK)
    5600:	80 91 b9 00 	lds	r24, 0x00B9
    5604:	80 34       	cpi	r24, 0x40	; 64
    5606:	81 f0       	breq	.+32     	; 0x5628 <i2cMasterReceiveNI+0x64>
    5608:	91 e0       	ldi	r25, 0x01	; 1
    560a:	1e c0       	rjmp	.+60     	; 0x5648 <i2cMasterReceiveNI+0x84>
{
	// begin receive over i2c
	if( ackFlag )
	{
		// ackFlag = TRUE: ACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    560c:	80 91 bc 00 	lds	r24, 0x00BC
    5610:	8f 70       	andi	r24, 0x0F	; 15
    5612:	80 6c       	ori	r24, 0xC0	; 192
    5614:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    5618:	80 91 bc 00 	lds	r24, 0x00BC
    561c:	87 ff       	sbrs	r24, 7
    561e:	fc cf       	rjmp	.-8      	; 0x5618 <i2cMasterReceiveNI+0x54>
}

inline u08 i2cGetReceivedByte(void)
{
	// retieve received data byte from i2c TWDR
	return( inb(TWDR) );
    5620:	80 91 bb 00 	lds	r24, 0x00BB
		// accept receive data and ack it
		while(length > 1)
		{
			i2cReceiveByte(TRUE);
			i2cWaitForComplete();
			*data++ = i2cGetReceivedByte();
    5624:	81 93       	st	Z+, r24
			// decrement length
			length--;
    5626:	61 50       	subi	r22, 0x01	; 1

	// check if device is present and live
	if( inb(TWSR) == TW_MR_SLA_ACK)
	{
		// accept receive data and ack it
		while(length > 1)
    5628:	62 30       	cpi	r22, 0x02	; 2
    562a:	80 f7       	brcc	.-32     	; 0x560c <i2cMasterReceiveNI+0x48>
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
	}
	else
	{
		// ackFlag = FALSE: NACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    562c:	80 91 bc 00 	lds	r24, 0x00BC
    5630:	8f 70       	andi	r24, 0x0F	; 15
    5632:	80 68       	ori	r24, 0x80	; 128
    5634:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    5638:	80 91 bc 00 	lds	r24, 0x00BC
    563c:	87 ff       	sbrs	r24, 7
    563e:	fc cf       	rjmp	.-8      	; 0x5638 <i2cMasterReceiveNI+0x74>
}

inline u08 i2cGetReceivedByte(void)
{
	// retieve received data byte from i2c TWDR
	return( inb(TWDR) );
    5640:	80 91 bb 00 	lds	r24, 0x00BB
		}

		// accept receive data and nack it (last-byte signal)
		i2cReceiveByte(FALSE);
		i2cWaitForComplete();
		*data++ = i2cGetReceivedByte();
    5644:	80 83       	st	Z, r24
    5646:	90 e0       	ldi	r25, 0x00	; 0

inline void i2cSendStop(void)
{
	// transmit stop condition
	// leave with TWEA on for slave receiving
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA)|BV(TWSTO));
    5648:	80 91 bc 00 	lds	r24, 0x00BC
    564c:	8f 70       	andi	r24, 0x0F	; 15
    564e:	80 6d       	ori	r24, 0xD0	; 208
    5650:	80 93 bc 00 	sts	0x00BC, r24
	// transmit stop condition
	// leave with TWEA on for slave receiving
	i2cSendStop();

	// enable TWI interrupt
	sbi(TWCR, TWIE);
    5654:	80 91 bc 00 	lds	r24, 0x00BC
    5658:	81 60       	ori	r24, 0x01	; 1
    565a:	80 93 bc 00 	sts	0x00BC, r24

	return retval;
}
    565e:	89 2f       	mov	r24, r25
    5660:	08 95       	ret

00005662 <__vector_39>:
}
*/

//! I2C (TWI) interrupt service routine
SIGNAL(SIG_2WIRE_SERIAL)
{
    5662:	1f 92       	push	r1
    5664:	0f 92       	push	r0
    5666:	0f b6       	in	r0, 0x3f	; 63
    5668:	0f 92       	push	r0
    566a:	11 24       	eor	r1, r1
    566c:	2f 93       	push	r18
    566e:	3f 93       	push	r19
    5670:	4f 93       	push	r20
    5672:	5f 93       	push	r21
    5674:	6f 93       	push	r22
    5676:	7f 93       	push	r23
    5678:	8f 93       	push	r24
    567a:	9f 93       	push	r25
    567c:	af 93       	push	r26
    567e:	bf 93       	push	r27
    5680:	ef 93       	push	r30
    5682:	ff 93       	push	r31
	// read status bits
	u08 status = inb(TWSR) & TWSR_STATUS_MASK;
    5684:	80 91 b9 00 	lds	r24, 0x00B9

	switch(status)
    5688:	88 7f       	andi	r24, 0xF8	; 248
    568a:	80 36       	cpi	r24, 0x60	; 96
    568c:	09 f4       	brne	.+2      	; 0x5690 <__vector_39+0x2e>
    568e:	a0 c0       	rjmp	.+320    	; 0x57d0 <__vector_39+0x16e>
    5690:	81 36       	cpi	r24, 0x61	; 97
    5692:	70 f5       	brcc	.+92     	; 0x56f0 <__vector_39+0x8e>
    5694:	88 32       	cpi	r24, 0x28	; 40
    5696:	09 f4       	brne	.+2      	; 0x569a <__vector_39+0x38>
    5698:	5f c0       	rjmp	.+190    	; 0x5758 <__vector_39+0xf6>
    569a:	89 32       	cpi	r24, 0x29	; 41
    569c:	98 f4       	brcc	.+38     	; 0x56c4 <__vector_39+0x62>
    569e:	80 31       	cpi	r24, 0x10	; 16
    56a0:	09 f4       	brne	.+2      	; 0x56a4 <__vector_39+0x42>
    56a2:	57 c0       	rjmp	.+174    	; 0x5752 <__vector_39+0xf0>
    56a4:	81 31       	cpi	r24, 0x11	; 17
    56a6:	38 f4       	brcc	.+14     	; 0x56b6 <__vector_39+0x54>
    56a8:	88 23       	and	r24, r24
    56aa:	09 f4       	brne	.+2      	; 0x56ae <__vector_39+0x4c>
    56ac:	ea c0       	rjmp	.+468    	; 0x5882 <__vector_39+0x220>
    56ae:	88 30       	cpi	r24, 0x08	; 8
    56b0:	09 f0       	breq	.+2      	; 0x56b4 <__vector_39+0x52>
    56b2:	ef c0       	rjmp	.+478    	; 0x5892 <__vector_39+0x230>
    56b4:	4e c0       	rjmp	.+156    	; 0x5752 <__vector_39+0xf0>
    56b6:	88 31       	cpi	r24, 0x18	; 24
    56b8:	09 f4       	brne	.+2      	; 0x56bc <__vector_39+0x5a>
    56ba:	4e c0       	rjmp	.+156    	; 0x5758 <__vector_39+0xf6>
    56bc:	80 32       	cpi	r24, 0x20	; 32
    56be:	09 f0       	breq	.+2      	; 0x56c2 <__vector_39+0x60>
    56c0:	e8 c0       	rjmp	.+464    	; 0x5892 <__vector_39+0x230>
    56c2:	df c0       	rjmp	.+446    	; 0x5882 <__vector_39+0x220>
    56c4:	80 34       	cpi	r24, 0x40	; 64
    56c6:	09 f4       	brne	.+2      	; 0x56ca <__vector_39+0x68>
    56c8:	77 c0       	rjmp	.+238    	; 0x57b8 <__vector_39+0x156>
    56ca:	81 34       	cpi	r24, 0x41	; 65
    56cc:	38 f4       	brcc	.+14     	; 0x56dc <__vector_39+0x7a>
    56ce:	80 33       	cpi	r24, 0x30	; 48
    56d0:	09 f4       	brne	.+2      	; 0x56d4 <__vector_39+0x72>
    56d2:	d7 c0       	rjmp	.+430    	; 0x5882 <__vector_39+0x220>
    56d4:	88 33       	cpi	r24, 0x38	; 56
    56d6:	09 f0       	breq	.+2      	; 0x56da <__vector_39+0x78>
    56d8:	dc c0       	rjmp	.+440    	; 0x5892 <__vector_39+0x230>
    56da:	5d c0       	rjmp	.+186    	; 0x5796 <__vector_39+0x134>
    56dc:	80 35       	cpi	r24, 0x50	; 80
    56de:	09 f4       	brne	.+2      	; 0x56e2 <__vector_39+0x80>
    56e0:	5f c0       	rjmp	.+190    	; 0x57a0 <__vector_39+0x13e>
    56e2:	88 35       	cpi	r24, 0x58	; 88
    56e4:	09 f4       	brne	.+2      	; 0x56e8 <__vector_39+0x86>
    56e6:	4a c0       	rjmp	.+148    	; 0x577c <__vector_39+0x11a>
    56e8:	88 34       	cpi	r24, 0x48	; 72
    56ea:	09 f0       	breq	.+2      	; 0x56ee <__vector_39+0x8c>
    56ec:	d2 c0       	rjmp	.+420    	; 0x5892 <__vector_39+0x230>
    56ee:	c9 c0       	rjmp	.+402    	; 0x5882 <__vector_39+0x220>
    56f0:	88 39       	cpi	r24, 0x98	; 152
    56f2:	09 f4       	brne	.+2      	; 0x56f6 <__vector_39+0x94>
    56f4:	ba c0       	rjmp	.+372    	; 0x586a <__vector_39+0x208>
    56f6:	89 39       	cpi	r24, 0x99	; 153
    56f8:	b0 f4       	brcc	.+44     	; 0x5726 <__vector_39+0xc4>
    56fa:	88 37       	cpi	r24, 0x78	; 120
    56fc:	09 f4       	brne	.+2      	; 0x5700 <__vector_39+0x9e>
    56fe:	68 c0       	rjmp	.+208    	; 0x57d0 <__vector_39+0x16e>
    5700:	89 37       	cpi	r24, 0x79	; 121
    5702:	38 f4       	brcc	.+14     	; 0x5712 <__vector_39+0xb0>
    5704:	88 36       	cpi	r24, 0x68	; 104
    5706:	09 f4       	brne	.+2      	; 0x570a <__vector_39+0xa8>
    5708:	63 c0       	rjmp	.+198    	; 0x57d0 <__vector_39+0x16e>
    570a:	80 37       	cpi	r24, 0x70	; 112
    570c:	09 f0       	breq	.+2      	; 0x5710 <__vector_39+0xae>
    570e:	c1 c0       	rjmp	.+386    	; 0x5892 <__vector_39+0x230>
    5710:	5f c0       	rjmp	.+190    	; 0x57d0 <__vector_39+0x16e>
    5712:	88 38       	cpi	r24, 0x88	; 136
    5714:	09 f4       	brne	.+2      	; 0x5718 <__vector_39+0xb6>
    5716:	a9 c0       	rjmp	.+338    	; 0x586a <__vector_39+0x208>
    5718:	80 39       	cpi	r24, 0x90	; 144
    571a:	09 f4       	brne	.+2      	; 0x571e <__vector_39+0xbc>
    571c:	5f c0       	rjmp	.+190    	; 0x57dc <__vector_39+0x17a>
    571e:	80 38       	cpi	r24, 0x80	; 128
    5720:	09 f0       	breq	.+2      	; 0x5724 <__vector_39+0xc2>
    5722:	b7 c0       	rjmp	.+366    	; 0x5892 <__vector_39+0x230>
    5724:	5b c0       	rjmp	.+182    	; 0x57dc <__vector_39+0x17a>
    5726:	80 3b       	cpi	r24, 0xB0	; 176
    5728:	09 f4       	brne	.+2      	; 0x572c <__vector_39+0xca>
    572a:	79 c0       	rjmp	.+242    	; 0x581e <__vector_39+0x1bc>
    572c:	81 3b       	cpi	r24, 0xB1	; 177
    572e:	38 f4       	brcc	.+14     	; 0x573e <__vector_39+0xdc>
    5730:	80 3a       	cpi	r24, 0xA0	; 160
    5732:	09 f4       	brne	.+2      	; 0x5736 <__vector_39+0xd4>
    5734:	62 c0       	rjmp	.+196    	; 0x57fa <__vector_39+0x198>
    5736:	88 3a       	cpi	r24, 0xA8	; 168
    5738:	09 f0       	breq	.+2      	; 0x573c <__vector_39+0xda>
    573a:	ab c0       	rjmp	.+342    	; 0x5892 <__vector_39+0x230>
    573c:	70 c0       	rjmp	.+224    	; 0x581e <__vector_39+0x1bc>
    573e:	80 3c       	cpi	r24, 0xC0	; 192
    5740:	09 f4       	brne	.+2      	; 0x5744 <__vector_39+0xe2>
    5742:	9a c0       	rjmp	.+308    	; 0x5878 <__vector_39+0x216>
    5744:	88 3c       	cpi	r24, 0xC8	; 200
    5746:	09 f4       	brne	.+2      	; 0x574a <__vector_39+0xe8>
    5748:	97 c0       	rjmp	.+302    	; 0x5878 <__vector_39+0x216>
    574a:	88 3b       	cpi	r24, 0xB8	; 184
    574c:	09 f0       	breq	.+2      	; 0x5750 <__vector_39+0xee>
    574e:	a1 c0       	rjmp	.+322    	; 0x5892 <__vector_39+0x230>
    5750:	77 c0       	rjmp	.+238    	; 0x5840 <__vector_39+0x1de>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: M->START\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// send device address
		i2cSendByte(I2cDeviceAddrRW);
    5752:	80 91 c2 11 	lds	r24, 0x11C2
    5756:	0f c0       	rjmp	.+30     	; 0x5776 <__vector_39+0x114>
		#ifdef I2C_DEBUG
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MT->SLA_ACK or DATA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		if(I2cSendDataIndex < I2cSendDataLength)
    5758:	90 91 e3 11 	lds	r25, 0x11E3
    575c:	80 91 e4 11 	lds	r24, 0x11E4
    5760:	98 17       	cp	r25, r24
    5762:	08 f0       	brcs	.+2      	; 0x5766 <__vector_39+0x104>
    5764:	8e c0       	rjmp	.+284    	; 0x5882 <__vector_39+0x220>
		{
			// send data
			i2cSendByte( I2cSendData[I2cSendDataIndex++] );
    5766:	e9 2f       	mov	r30, r25
    5768:	f0 e0       	ldi	r31, 0x00	; 0
    576a:	ed 53       	subi	r30, 0x3D	; 61
    576c:	fe 4e       	sbci	r31, 0xEE	; 238
    576e:	80 81       	ld	r24, Z
    5770:	9f 5f       	subi	r25, 0xFF	; 255
    5772:	90 93 e3 11 	sts	0x11E3, r25
}

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    5776:	80 93 bb 00 	sts	0x00BB, r24
    577a:	77 c0       	rjmp	.+238    	; 0x586a <__vector_39+0x208>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MR->DATA_NACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// store final received data byte
		I2cReceiveData[I2cReceiveDataIndex++] = inb(TWDR);
    577c:	80 91 05 12 	lds	r24, 0x1205
    5780:	90 91 bb 00 	lds	r25, 0x00BB
    5784:	e8 2f       	mov	r30, r24
    5786:	f0 e0       	ldi	r31, 0x00	; 0
    5788:	eb 51       	subi	r30, 0x1B	; 27
    578a:	fe 4e       	sbci	r31, 0xEE	; 238
    578c:	90 83       	st	Z, r25
    578e:	8f 5f       	subi	r24, 0xFF	; 255
    5790:	80 93 05 12 	sts	0x1205, r24
    5794:	76 c0       	rjmp	.+236    	; 0x5882 <__vector_39+0x220>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MT->ARB_LOST\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// release bus
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    5796:	80 91 bc 00 	lds	r24, 0x00BC
    579a:	8f 70       	andi	r24, 0x0F	; 15
    579c:	80 68       	ori	r24, 0x80	; 128
    579e:	75 c0       	rjmp	.+234    	; 0x588a <__vector_39+0x228>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MR->DATA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// store received data byte
		I2cReceiveData[I2cReceiveDataIndex++] = inb(TWDR);
    57a0:	80 91 05 12 	lds	r24, 0x1205
    57a4:	90 91 bb 00 	lds	r25, 0x00BB
    57a8:	e8 2f       	mov	r30, r24
    57aa:	f0 e0       	ldi	r31, 0x00	; 0
    57ac:	eb 51       	subi	r30, 0x1B	; 27
    57ae:	fe 4e       	sbci	r31, 0xEE	; 238
    57b0:	90 83       	st	Z, r25
    57b2:	8f 5f       	subi	r24, 0xFF	; 255
    57b4:	80 93 05 12 	sts	0x1205, r24
		#ifdef I2C_DEBUG
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MR->SLA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		if(I2cReceiveDataIndex < (I2cReceiveDataLength-1))
    57b8:	20 91 05 12 	lds	r18, 0x1205
    57bc:	30 e0       	ldi	r19, 0x00	; 0
    57be:	80 91 06 12 	lds	r24, 0x1206
    57c2:	90 e0       	ldi	r25, 0x00	; 0
    57c4:	01 97       	sbiw	r24, 0x01	; 1
    57c6:	28 17       	cp	r18, r24
    57c8:	39 07       	cpc	r19, r25
    57ca:	0c f0       	brlt	.+2      	; 0x57ce <__vector_39+0x16c>
    57cc:	4e c0       	rjmp	.+156    	; 0x586a <__vector_39+0x208>
    57ce:	48 c0       	rjmp	.+144    	; 0x5860 <__vector_39+0x1fe>
		rprintf("I2C: SR->SLA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// we are being addressed as slave for writing (data will be received from master)
		// set state
		I2cState = I2C_SLAVE_RX;
    57d0:	85 e0       	ldi	r24, 0x05	; 5
    57d2:	80 93 c1 11 	sts	0x11C1, r24
		// prepare buffer
		I2cReceiveDataIndex = 0;
    57d6:	10 92 05 12 	sts	0x1205, r1
    57da:	42 c0       	rjmp	.+132    	; 0x5860 <__vector_39+0x1fe>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: SR->DATA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// get previously received data byte
		I2cReceiveData[I2cReceiveDataIndex++] = inb(TWDR);
    57dc:	80 91 05 12 	lds	r24, 0x1205
    57e0:	90 91 bb 00 	lds	r25, 0x00BB
    57e4:	e8 2f       	mov	r30, r24
    57e6:	f0 e0       	ldi	r31, 0x00	; 0
    57e8:	eb 51       	subi	r30, 0x1B	; 27
    57ea:	fe 4e       	sbci	r31, 0xEE	; 238
    57ec:	90 83       	st	Z, r25
    57ee:	8f 5f       	subi	r24, 0xFF	; 255
    57f0:	80 93 05 12 	sts	0x1205, r24
		// check receive buffer status
		if(I2cReceiveDataIndex < I2C_RECEIVE_DATA_BUFFER_SIZE)
    57f4:	80 32       	cpi	r24, 0x20	; 32
    57f6:	c8 f5       	brcc	.+114    	; 0x586a <__vector_39+0x208>
    57f8:	33 c0       	rjmp	.+102    	; 0x5860 <__vector_39+0x1fe>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: SR->SR_STOP\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// switch to SR mode with SLA ACK
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    57fa:	80 91 bc 00 	lds	r24, 0x00BC
    57fe:	8f 70       	andi	r24, 0x0F	; 15
    5800:	80 6c       	ori	r24, 0xC0	; 192
    5802:	80 93 bc 00 	sts	0x00BC, r24
		// i2c receive is complete, call i2cSlaveReceive
		if(i2cSlaveReceive) i2cSlaveReceive(I2cReceiveDataIndex, I2cReceiveData);
    5806:	e0 91 07 12 	lds	r30, 0x1207
    580a:	f0 91 08 12 	lds	r31, 0x1208
    580e:	30 97       	sbiw	r30, 0x00	; 0
    5810:	f1 f1       	breq	.+124    	; 0x588e <__vector_39+0x22c>
    5812:	80 91 05 12 	lds	r24, 0x1205
    5816:	65 ee       	ldi	r22, 0xE5	; 229
    5818:	71 e1       	ldi	r23, 0x11	; 17
    581a:	09 95       	icall
    581c:	38 c0       	rjmp	.+112    	; 0x588e <__vector_39+0x22c>
		rprintf("I2C: ST->SLA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// we are being addressed as slave for reading (data must be transmitted back to master)
		// set state
		I2cState = I2C_SLAVE_TX;
    581e:	84 e0       	ldi	r24, 0x04	; 4
    5820:	80 93 c1 11 	sts	0x11C1, r24
		// request data from application
		if(i2cSlaveTransmit) I2cSendDataLength = i2cSlaveTransmit(I2C_SEND_DATA_BUFFER_SIZE, I2cSendData);
    5824:	e0 91 09 12 	lds	r30, 0x1209
    5828:	f0 91 0a 12 	lds	r31, 0x120A
    582c:	30 97       	sbiw	r30, 0x00	; 0
    582e:	31 f0       	breq	.+12     	; 0x583c <__vector_39+0x1da>
    5830:	80 e2       	ldi	r24, 0x20	; 32
    5832:	63 ec       	ldi	r22, 0xC3	; 195
    5834:	71 e1       	ldi	r23, 0x11	; 17
    5836:	09 95       	icall
    5838:	80 93 e4 11 	sts	0x11E4, r24
		// reset data index
		I2cSendDataIndex = 0;
    583c:	10 92 e3 11 	sts	0x11E3, r1
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: ST->DATA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// transmit data byte
		outb(TWDR, I2cSendData[I2cSendDataIndex++]);
    5840:	90 91 e3 11 	lds	r25, 0x11E3
    5844:	e9 2f       	mov	r30, r25
    5846:	f0 e0       	ldi	r31, 0x00	; 0
    5848:	ed 53       	subi	r30, 0x3D	; 61
    584a:	fe 4e       	sbci	r31, 0xEE	; 238
    584c:	80 81       	ld	r24, Z
    584e:	80 93 bb 00 	sts	0x00BB, r24
    5852:	9f 5f       	subi	r25, 0xFF	; 255
    5854:	90 93 e3 11 	sts	0x11E3, r25
		if(I2cSendDataIndex < I2cSendDataLength)
    5858:	80 91 e4 11 	lds	r24, 0x11E4
    585c:	98 17       	cp	r25, r24
    585e:	28 f4       	brcc	.+10     	; 0x586a <__vector_39+0x208>
			// expect ACK to data byte
			outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    5860:	80 91 bc 00 	lds	r24, 0x00BC
    5864:	8f 70       	andi	r24, 0x0F	; 15
    5866:	80 6c       	ori	r24, 0xC0	; 192
    5868:	04 c0       	rjmp	.+8      	; 0x5872 <__vector_39+0x210>
		else
			// expect NACK to data byte
			outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    586a:	80 91 bc 00 	lds	r24, 0x00BC
    586e:	8f 70       	andi	r24, 0x0F	; 15
    5870:	80 68       	ori	r24, 0x80	; 128
    5872:	80 93 bc 00 	sts	0x00BC, r24
    5876:	0d c0       	rjmp	.+26     	; 0x5892 <__vector_39+0x230>
		rprintf("I2C: ST->DATA_NACK or LAST_DATA\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// all done
		// switch to open slave
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    5878:	80 91 bc 00 	lds	r24, 0x00BC
    587c:	8f 70       	andi	r24, 0x0F	; 15
    587e:	80 6c       	ori	r24, 0xC0	; 192
    5880:	04 c0       	rjmp	.+8      	; 0x588a <__vector_39+0x228>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: BUS_ERROR\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// reset internal hardware and release bus
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTO)|BV(TWEA));
    5882:	80 91 bc 00 	lds	r24, 0x00BC
    5886:	8f 70       	andi	r24, 0x0F	; 15
    5888:	80 6d       	ori	r24, 0xD0	; 208
    588a:	80 93 bc 00 	sts	0x00BC, r24
		// set state
		I2cState = I2C_IDLE;
    588e:	10 92 c1 11 	sts	0x11C1, r1
		break;
	}
}
    5892:	ff 91       	pop	r31
    5894:	ef 91       	pop	r30
    5896:	bf 91       	pop	r27
    5898:	af 91       	pop	r26
    589a:	9f 91       	pop	r25
    589c:	8f 91       	pop	r24
    589e:	7f 91       	pop	r23
    58a0:	6f 91       	pop	r22
    58a2:	5f 91       	pop	r21
    58a4:	4f 91       	pop	r20
    58a6:	3f 91       	pop	r19
    58a8:	2f 91       	pop	r18
    58aa:	0f 90       	pop	r0
    58ac:	0f be       	out	0x3f, r0	; 63
    58ae:	0f 90       	pop	r0
    58b0:	1f 90       	pop	r1
    58b2:	18 95       	reti

000058b4 <i2cGetState>:

eI2cStateType i2cGetState(void)
{
	return I2cState;
    58b4:	80 91 c1 11 	lds	r24, 0x11C1
}
    58b8:	08 95       	ret

000058ba <exit>:
    58ba:	f8 94       	cli
    58bc:	0c 94 d9 30 	jmp	0x61b2	; 0x61b2 <_exit>

000058c0 <memcpy>:
    58c0:	fb 01       	movw	r30, r22
    58c2:	dc 01       	movw	r26, r24
    58c4:	02 c0       	rjmp	.+4      	; 0x58ca <memcpy+0xa>
    58c6:	01 90       	ld	r0, Z+
    58c8:	0d 92       	st	X+, r0
    58ca:	41 50       	subi	r20, 0x01	; 1
    58cc:	50 40       	sbci	r21, 0x00	; 0
    58ce:	d8 f7       	brcc	.-10     	; 0x58c6 <memcpy+0x6>
    58d0:	08 95       	ret

000058d2 <memset>:
    58d2:	dc 01       	movw	r26, r24
    58d4:	01 c0       	rjmp	.+2      	; 0x58d8 <memset+0x6>
    58d6:	6d 93       	st	X+, r22
    58d8:	41 50       	subi	r20, 0x01	; 1
    58da:	50 40       	sbci	r21, 0x00	; 0
    58dc:	e0 f7       	brcc	.-8      	; 0x58d6 <memset+0x4>
    58de:	08 95       	ret

000058e0 <strncpy>:
    58e0:	fb 01       	movw	r30, r22
    58e2:	dc 01       	movw	r26, r24
    58e4:	41 50       	subi	r20, 0x01	; 1
    58e6:	50 40       	sbci	r21, 0x00	; 0
    58e8:	48 f0       	brcs	.+18     	; 0x58fc <strncpy+0x1c>
    58ea:	01 90       	ld	r0, Z+
    58ec:	0d 92       	st	X+, r0
    58ee:	00 20       	and	r0, r0
    58f0:	c9 f7       	brne	.-14     	; 0x58e4 <strncpy+0x4>
    58f2:	01 c0       	rjmp	.+2      	; 0x58f6 <strncpy+0x16>
    58f4:	1d 92       	st	X+, r1
    58f6:	41 50       	subi	r20, 0x01	; 1
    58f8:	50 40       	sbci	r21, 0x00	; 0
    58fa:	e0 f7       	brcc	.-8      	; 0x58f4 <strncpy+0x14>
    58fc:	08 95       	ret

000058fe <__subsf3>:
    58fe:	50 58       	subi	r21, 0x80	; 128

00005900 <__addsf3>:
    5900:	bb 27       	eor	r27, r27
    5902:	aa 27       	eor	r26, r26
    5904:	0e d0       	rcall	.+28     	; 0x5922 <__addsf3x>
    5906:	75 c1       	rjmp	.+746    	; 0x5bf2 <__fp_round>
    5908:	66 d1       	rcall	.+716    	; 0x5bd6 <__fp_pscA>
    590a:	30 f0       	brcs	.+12     	; 0x5918 <__addsf3+0x18>
    590c:	6b d1       	rcall	.+726    	; 0x5be4 <__fp_pscB>
    590e:	20 f0       	brcs	.+8      	; 0x5918 <__addsf3+0x18>
    5910:	31 f4       	brne	.+12     	; 0x591e <__addsf3+0x1e>
    5912:	9f 3f       	cpi	r25, 0xFF	; 255
    5914:	11 f4       	brne	.+4      	; 0x591a <__addsf3+0x1a>
    5916:	1e f4       	brtc	.+6      	; 0x591e <__addsf3+0x1e>
    5918:	5b c1       	rjmp	.+694    	; 0x5bd0 <__fp_nan>
    591a:	0e f4       	brtc	.+2      	; 0x591e <__addsf3+0x1e>
    591c:	e0 95       	com	r30
    591e:	e7 fb       	bst	r30, 7
    5920:	51 c1       	rjmp	.+674    	; 0x5bc4 <__fp_inf>

00005922 <__addsf3x>:
    5922:	e9 2f       	mov	r30, r25
    5924:	77 d1       	rcall	.+750    	; 0x5c14 <__fp_split3>
    5926:	80 f3       	brcs	.-32     	; 0x5908 <__addsf3+0x8>
    5928:	ba 17       	cp	r27, r26
    592a:	62 07       	cpc	r22, r18
    592c:	73 07       	cpc	r23, r19
    592e:	84 07       	cpc	r24, r20
    5930:	95 07       	cpc	r25, r21
    5932:	18 f0       	brcs	.+6      	; 0x593a <__addsf3x+0x18>
    5934:	71 f4       	brne	.+28     	; 0x5952 <__addsf3x+0x30>
    5936:	9e f5       	brtc	.+102    	; 0x599e <__addsf3x+0x7c>
    5938:	8f c1       	rjmp	.+798    	; 0x5c58 <__fp_zero>
    593a:	0e f4       	brtc	.+2      	; 0x593e <__addsf3x+0x1c>
    593c:	e0 95       	com	r30
    593e:	0b 2e       	mov	r0, r27
    5940:	ba 2f       	mov	r27, r26
    5942:	a0 2d       	mov	r26, r0
    5944:	0b 01       	movw	r0, r22
    5946:	b9 01       	movw	r22, r18
    5948:	90 01       	movw	r18, r0
    594a:	0c 01       	movw	r0, r24
    594c:	ca 01       	movw	r24, r20
    594e:	a0 01       	movw	r20, r0
    5950:	11 24       	eor	r1, r1
    5952:	ff 27       	eor	r31, r31
    5954:	59 1b       	sub	r21, r25
    5956:	99 f0       	breq	.+38     	; 0x597e <__addsf3x+0x5c>
    5958:	59 3f       	cpi	r21, 0xF9	; 249
    595a:	50 f4       	brcc	.+20     	; 0x5970 <__addsf3x+0x4e>
    595c:	50 3e       	cpi	r21, 0xE0	; 224
    595e:	68 f1       	brcs	.+90     	; 0x59ba <__addsf3x+0x98>
    5960:	1a 16       	cp	r1, r26
    5962:	f0 40       	sbci	r31, 0x00	; 0
    5964:	a2 2f       	mov	r26, r18
    5966:	23 2f       	mov	r18, r19
    5968:	34 2f       	mov	r19, r20
    596a:	44 27       	eor	r20, r20
    596c:	58 5f       	subi	r21, 0xF8	; 248
    596e:	f3 cf       	rjmp	.-26     	; 0x5956 <__addsf3x+0x34>
    5970:	46 95       	lsr	r20
    5972:	37 95       	ror	r19
    5974:	27 95       	ror	r18
    5976:	a7 95       	ror	r26
    5978:	f0 40       	sbci	r31, 0x00	; 0
    597a:	53 95       	inc	r21
    597c:	c9 f7       	brne	.-14     	; 0x5970 <__addsf3x+0x4e>
    597e:	7e f4       	brtc	.+30     	; 0x599e <__addsf3x+0x7c>
    5980:	1f 16       	cp	r1, r31
    5982:	ba 0b       	sbc	r27, r26
    5984:	62 0b       	sbc	r22, r18
    5986:	73 0b       	sbc	r23, r19
    5988:	84 0b       	sbc	r24, r20
    598a:	ba f0       	brmi	.+46     	; 0x59ba <__addsf3x+0x98>
    598c:	91 50       	subi	r25, 0x01	; 1
    598e:	a1 f0       	breq	.+40     	; 0x59b8 <__addsf3x+0x96>
    5990:	ff 0f       	add	r31, r31
    5992:	bb 1f       	adc	r27, r27
    5994:	66 1f       	adc	r22, r22
    5996:	77 1f       	adc	r23, r23
    5998:	88 1f       	adc	r24, r24
    599a:	c2 f7       	brpl	.-16     	; 0x598c <__addsf3x+0x6a>
    599c:	0e c0       	rjmp	.+28     	; 0x59ba <__addsf3x+0x98>
    599e:	ba 0f       	add	r27, r26
    59a0:	62 1f       	adc	r22, r18
    59a2:	73 1f       	adc	r23, r19
    59a4:	84 1f       	adc	r24, r20
    59a6:	48 f4       	brcc	.+18     	; 0x59ba <__addsf3x+0x98>
    59a8:	87 95       	ror	r24
    59aa:	77 95       	ror	r23
    59ac:	67 95       	ror	r22
    59ae:	b7 95       	ror	r27
    59b0:	f7 95       	ror	r31
    59b2:	9e 3f       	cpi	r25, 0xFE	; 254
    59b4:	08 f0       	brcs	.+2      	; 0x59b8 <__addsf3x+0x96>
    59b6:	b3 cf       	rjmp	.-154    	; 0x591e <__addsf3+0x1e>
    59b8:	93 95       	inc	r25
    59ba:	88 0f       	add	r24, r24
    59bc:	08 f0       	brcs	.+2      	; 0x59c0 <__addsf3x+0x9e>
    59be:	99 27       	eor	r25, r25
    59c0:	ee 0f       	add	r30, r30
    59c2:	97 95       	ror	r25
    59c4:	87 95       	ror	r24
    59c6:	08 95       	ret

000059c8 <__cmpsf2>:
    59c8:	d9 d0       	rcall	.+434    	; 0x5b7c <__fp_cmp>
    59ca:	08 f4       	brcc	.+2      	; 0x59ce <__cmpsf2+0x6>
    59cc:	81 e0       	ldi	r24, 0x01	; 1
    59ce:	08 95       	ret

000059d0 <__divsf3>:
    59d0:	0c d0       	rcall	.+24     	; 0x59ea <__divsf3x>
    59d2:	0f c1       	rjmp	.+542    	; 0x5bf2 <__fp_round>
    59d4:	07 d1       	rcall	.+526    	; 0x5be4 <__fp_pscB>
    59d6:	40 f0       	brcs	.+16     	; 0x59e8 <__divsf3+0x18>
    59d8:	fe d0       	rcall	.+508    	; 0x5bd6 <__fp_pscA>
    59da:	30 f0       	brcs	.+12     	; 0x59e8 <__divsf3+0x18>
    59dc:	21 f4       	brne	.+8      	; 0x59e6 <__divsf3+0x16>
    59de:	5f 3f       	cpi	r21, 0xFF	; 255
    59e0:	19 f0       	breq	.+6      	; 0x59e8 <__divsf3+0x18>
    59e2:	f0 c0       	rjmp	.+480    	; 0x5bc4 <__fp_inf>
    59e4:	51 11       	cpse	r21, r1
    59e6:	39 c1       	rjmp	.+626    	; 0x5c5a <__fp_szero>
    59e8:	f3 c0       	rjmp	.+486    	; 0x5bd0 <__fp_nan>

000059ea <__divsf3x>:
    59ea:	14 d1       	rcall	.+552    	; 0x5c14 <__fp_split3>
    59ec:	98 f3       	brcs	.-26     	; 0x59d4 <__divsf3+0x4>

000059ee <__divsf3_pse>:
    59ee:	99 23       	and	r25, r25
    59f0:	c9 f3       	breq	.-14     	; 0x59e4 <__divsf3+0x14>
    59f2:	55 23       	and	r21, r21
    59f4:	b1 f3       	breq	.-20     	; 0x59e2 <__divsf3+0x12>
    59f6:	95 1b       	sub	r25, r21
    59f8:	55 0b       	sbc	r21, r21
    59fa:	bb 27       	eor	r27, r27
    59fc:	aa 27       	eor	r26, r26
    59fe:	62 17       	cp	r22, r18
    5a00:	73 07       	cpc	r23, r19
    5a02:	84 07       	cpc	r24, r20
    5a04:	38 f0       	brcs	.+14     	; 0x5a14 <__divsf3_pse+0x26>
    5a06:	9f 5f       	subi	r25, 0xFF	; 255
    5a08:	5f 4f       	sbci	r21, 0xFF	; 255
    5a0a:	22 0f       	add	r18, r18
    5a0c:	33 1f       	adc	r19, r19
    5a0e:	44 1f       	adc	r20, r20
    5a10:	aa 1f       	adc	r26, r26
    5a12:	a9 f3       	breq	.-22     	; 0x59fe <__divsf3_pse+0x10>
    5a14:	33 d0       	rcall	.+102    	; 0x5a7c <__divsf3_pse+0x8e>
    5a16:	0e 2e       	mov	r0, r30
    5a18:	3a f0       	brmi	.+14     	; 0x5a28 <__divsf3_pse+0x3a>
    5a1a:	e0 e8       	ldi	r30, 0x80	; 128
    5a1c:	30 d0       	rcall	.+96     	; 0x5a7e <__divsf3_pse+0x90>
    5a1e:	91 50       	subi	r25, 0x01	; 1
    5a20:	50 40       	sbci	r21, 0x00	; 0
    5a22:	e6 95       	lsr	r30
    5a24:	00 1c       	adc	r0, r0
    5a26:	ca f7       	brpl	.-14     	; 0x5a1a <__divsf3_pse+0x2c>
    5a28:	29 d0       	rcall	.+82     	; 0x5a7c <__divsf3_pse+0x8e>
    5a2a:	fe 2f       	mov	r31, r30
    5a2c:	27 d0       	rcall	.+78     	; 0x5a7c <__divsf3_pse+0x8e>
    5a2e:	66 0f       	add	r22, r22
    5a30:	77 1f       	adc	r23, r23
    5a32:	88 1f       	adc	r24, r24
    5a34:	bb 1f       	adc	r27, r27
    5a36:	26 17       	cp	r18, r22
    5a38:	37 07       	cpc	r19, r23
    5a3a:	48 07       	cpc	r20, r24
    5a3c:	ab 07       	cpc	r26, r27
    5a3e:	b0 e8       	ldi	r27, 0x80	; 128
    5a40:	09 f0       	breq	.+2      	; 0x5a44 <__divsf3_pse+0x56>
    5a42:	bb 0b       	sbc	r27, r27
    5a44:	80 2d       	mov	r24, r0
    5a46:	bf 01       	movw	r22, r30
    5a48:	ff 27       	eor	r31, r31
    5a4a:	93 58       	subi	r25, 0x83	; 131
    5a4c:	5f 4f       	sbci	r21, 0xFF	; 255
    5a4e:	2a f0       	brmi	.+10     	; 0x5a5a <__divsf3_pse+0x6c>
    5a50:	9e 3f       	cpi	r25, 0xFE	; 254
    5a52:	51 05       	cpc	r21, r1
    5a54:	68 f0       	brcs	.+26     	; 0x5a70 <__divsf3_pse+0x82>
    5a56:	b6 c0       	rjmp	.+364    	; 0x5bc4 <__fp_inf>
    5a58:	00 c1       	rjmp	.+512    	; 0x5c5a <__fp_szero>
    5a5a:	5f 3f       	cpi	r21, 0xFF	; 255
    5a5c:	ec f3       	brlt	.-6      	; 0x5a58 <__divsf3_pse+0x6a>
    5a5e:	98 3e       	cpi	r25, 0xE8	; 232
    5a60:	dc f3       	brlt	.-10     	; 0x5a58 <__divsf3_pse+0x6a>
    5a62:	86 95       	lsr	r24
    5a64:	77 95       	ror	r23
    5a66:	67 95       	ror	r22
    5a68:	b7 95       	ror	r27
    5a6a:	f7 95       	ror	r31
    5a6c:	9f 5f       	subi	r25, 0xFF	; 255
    5a6e:	c9 f7       	brne	.-14     	; 0x5a62 <__divsf3_pse+0x74>
    5a70:	88 0f       	add	r24, r24
    5a72:	91 1d       	adc	r25, r1
    5a74:	96 95       	lsr	r25
    5a76:	87 95       	ror	r24
    5a78:	97 f9       	bld	r25, 7
    5a7a:	08 95       	ret
    5a7c:	e1 e0       	ldi	r30, 0x01	; 1
    5a7e:	66 0f       	add	r22, r22
    5a80:	77 1f       	adc	r23, r23
    5a82:	88 1f       	adc	r24, r24
    5a84:	bb 1f       	adc	r27, r27
    5a86:	62 17       	cp	r22, r18
    5a88:	73 07       	cpc	r23, r19
    5a8a:	84 07       	cpc	r24, r20
    5a8c:	ba 07       	cpc	r27, r26
    5a8e:	20 f0       	brcs	.+8      	; 0x5a98 <__divsf3_pse+0xaa>
    5a90:	62 1b       	sub	r22, r18
    5a92:	73 0b       	sbc	r23, r19
    5a94:	84 0b       	sbc	r24, r20
    5a96:	ba 0b       	sbc	r27, r26
    5a98:	ee 1f       	adc	r30, r30
    5a9a:	88 f7       	brcc	.-30     	; 0x5a7e <__divsf3_pse+0x90>
    5a9c:	e0 95       	com	r30
    5a9e:	08 95       	ret

00005aa0 <__fixsfsi>:
    5aa0:	04 d0       	rcall	.+8      	; 0x5aaa <__fixunssfsi>
    5aa2:	68 94       	set
    5aa4:	b1 11       	cpse	r27, r1
    5aa6:	d9 c0       	rjmp	.+434    	; 0x5c5a <__fp_szero>
    5aa8:	08 95       	ret

00005aaa <__fixunssfsi>:
    5aaa:	bc d0       	rcall	.+376    	; 0x5c24 <__fp_splitA>
    5aac:	88 f0       	brcs	.+34     	; 0x5ad0 <__fixunssfsi+0x26>
    5aae:	9f 57       	subi	r25, 0x7F	; 127
    5ab0:	90 f0       	brcs	.+36     	; 0x5ad6 <__fixunssfsi+0x2c>
    5ab2:	b9 2f       	mov	r27, r25
    5ab4:	99 27       	eor	r25, r25
    5ab6:	b7 51       	subi	r27, 0x17	; 23
    5ab8:	a0 f0       	brcs	.+40     	; 0x5ae2 <__fixunssfsi+0x38>
    5aba:	d1 f0       	breq	.+52     	; 0x5af0 <__fixunssfsi+0x46>
    5abc:	66 0f       	add	r22, r22
    5abe:	77 1f       	adc	r23, r23
    5ac0:	88 1f       	adc	r24, r24
    5ac2:	99 1f       	adc	r25, r25
    5ac4:	1a f0       	brmi	.+6      	; 0x5acc <__fixunssfsi+0x22>
    5ac6:	ba 95       	dec	r27
    5ac8:	c9 f7       	brne	.-14     	; 0x5abc <__fixunssfsi+0x12>
    5aca:	12 c0       	rjmp	.+36     	; 0x5af0 <__fixunssfsi+0x46>
    5acc:	b1 30       	cpi	r27, 0x01	; 1
    5ace:	81 f0       	breq	.+32     	; 0x5af0 <__fixunssfsi+0x46>
    5ad0:	c3 d0       	rcall	.+390    	; 0x5c58 <__fp_zero>
    5ad2:	b1 e0       	ldi	r27, 0x01	; 1
    5ad4:	08 95       	ret
    5ad6:	c0 c0       	rjmp	.+384    	; 0x5c58 <__fp_zero>
    5ad8:	67 2f       	mov	r22, r23
    5ada:	78 2f       	mov	r23, r24
    5adc:	88 27       	eor	r24, r24
    5ade:	b8 5f       	subi	r27, 0xF8	; 248
    5ae0:	39 f0       	breq	.+14     	; 0x5af0 <__fixunssfsi+0x46>
    5ae2:	b9 3f       	cpi	r27, 0xF9	; 249
    5ae4:	cc f3       	brlt	.-14     	; 0x5ad8 <__fixunssfsi+0x2e>
    5ae6:	86 95       	lsr	r24
    5ae8:	77 95       	ror	r23
    5aea:	67 95       	ror	r22
    5aec:	b3 95       	inc	r27
    5aee:	d9 f7       	brne	.-10     	; 0x5ae6 <__fixunssfsi+0x3c>
    5af0:	3e f4       	brtc	.+14     	; 0x5b00 <__fixunssfsi+0x56>
    5af2:	90 95       	com	r25
    5af4:	80 95       	com	r24
    5af6:	70 95       	com	r23
    5af8:	61 95       	neg	r22
    5afa:	7f 4f       	sbci	r23, 0xFF	; 255
    5afc:	8f 4f       	sbci	r24, 0xFF	; 255
    5afe:	9f 4f       	sbci	r25, 0xFF	; 255
    5b00:	08 95       	ret

00005b02 <__floatunsisf>:
    5b02:	e8 94       	clt
    5b04:	09 c0       	rjmp	.+18     	; 0x5b18 <__floatsisf+0x12>

00005b06 <__floatsisf>:
    5b06:	97 fb       	bst	r25, 7
    5b08:	3e f4       	brtc	.+14     	; 0x5b18 <__floatsisf+0x12>
    5b0a:	90 95       	com	r25
    5b0c:	80 95       	com	r24
    5b0e:	70 95       	com	r23
    5b10:	61 95       	neg	r22
    5b12:	7f 4f       	sbci	r23, 0xFF	; 255
    5b14:	8f 4f       	sbci	r24, 0xFF	; 255
    5b16:	9f 4f       	sbci	r25, 0xFF	; 255
    5b18:	99 23       	and	r25, r25
    5b1a:	a9 f0       	breq	.+42     	; 0x5b46 <__floatsisf+0x40>
    5b1c:	f9 2f       	mov	r31, r25
    5b1e:	96 e9       	ldi	r25, 0x96	; 150
    5b20:	bb 27       	eor	r27, r27
    5b22:	93 95       	inc	r25
    5b24:	f6 95       	lsr	r31
    5b26:	87 95       	ror	r24
    5b28:	77 95       	ror	r23
    5b2a:	67 95       	ror	r22
    5b2c:	b7 95       	ror	r27
    5b2e:	f1 11       	cpse	r31, r1
    5b30:	f8 cf       	rjmp	.-16     	; 0x5b22 <__floatsisf+0x1c>
    5b32:	fa f4       	brpl	.+62     	; 0x5b72 <__floatsisf+0x6c>
    5b34:	bb 0f       	add	r27, r27
    5b36:	11 f4       	brne	.+4      	; 0x5b3c <__floatsisf+0x36>
    5b38:	60 ff       	sbrs	r22, 0
    5b3a:	1b c0       	rjmp	.+54     	; 0x5b72 <__floatsisf+0x6c>
    5b3c:	6f 5f       	subi	r22, 0xFF	; 255
    5b3e:	7f 4f       	sbci	r23, 0xFF	; 255
    5b40:	8f 4f       	sbci	r24, 0xFF	; 255
    5b42:	9f 4f       	sbci	r25, 0xFF	; 255
    5b44:	16 c0       	rjmp	.+44     	; 0x5b72 <__floatsisf+0x6c>
    5b46:	88 23       	and	r24, r24
    5b48:	11 f0       	breq	.+4      	; 0x5b4e <__floatsisf+0x48>
    5b4a:	96 e9       	ldi	r25, 0x96	; 150
    5b4c:	11 c0       	rjmp	.+34     	; 0x5b70 <__floatsisf+0x6a>
    5b4e:	77 23       	and	r23, r23
    5b50:	21 f0       	breq	.+8      	; 0x5b5a <__floatsisf+0x54>
    5b52:	9e e8       	ldi	r25, 0x8E	; 142
    5b54:	87 2f       	mov	r24, r23
    5b56:	76 2f       	mov	r23, r22
    5b58:	05 c0       	rjmp	.+10     	; 0x5b64 <__floatsisf+0x5e>
    5b5a:	66 23       	and	r22, r22
    5b5c:	71 f0       	breq	.+28     	; 0x5b7a <__floatsisf+0x74>
    5b5e:	96 e8       	ldi	r25, 0x86	; 134
    5b60:	86 2f       	mov	r24, r22
    5b62:	70 e0       	ldi	r23, 0x00	; 0
    5b64:	60 e0       	ldi	r22, 0x00	; 0
    5b66:	2a f0       	brmi	.+10     	; 0x5b72 <__floatsisf+0x6c>
    5b68:	9a 95       	dec	r25
    5b6a:	66 0f       	add	r22, r22
    5b6c:	77 1f       	adc	r23, r23
    5b6e:	88 1f       	adc	r24, r24
    5b70:	da f7       	brpl	.-10     	; 0x5b68 <__floatsisf+0x62>
    5b72:	88 0f       	add	r24, r24
    5b74:	96 95       	lsr	r25
    5b76:	87 95       	ror	r24
    5b78:	97 f9       	bld	r25, 7
    5b7a:	08 95       	ret

00005b7c <__fp_cmp>:
    5b7c:	99 0f       	add	r25, r25
    5b7e:	00 08       	sbc	r0, r0
    5b80:	55 0f       	add	r21, r21
    5b82:	aa 0b       	sbc	r26, r26
    5b84:	e0 e8       	ldi	r30, 0x80	; 128
    5b86:	fe ef       	ldi	r31, 0xFE	; 254
    5b88:	16 16       	cp	r1, r22
    5b8a:	17 06       	cpc	r1, r23
    5b8c:	e8 07       	cpc	r30, r24
    5b8e:	f9 07       	cpc	r31, r25
    5b90:	c0 f0       	brcs	.+48     	; 0x5bc2 <__fp_cmp+0x46>
    5b92:	12 16       	cp	r1, r18
    5b94:	13 06       	cpc	r1, r19
    5b96:	e4 07       	cpc	r30, r20
    5b98:	f5 07       	cpc	r31, r21
    5b9a:	98 f0       	brcs	.+38     	; 0x5bc2 <__fp_cmp+0x46>
    5b9c:	62 1b       	sub	r22, r18
    5b9e:	73 0b       	sbc	r23, r19
    5ba0:	84 0b       	sbc	r24, r20
    5ba2:	95 0b       	sbc	r25, r21
    5ba4:	39 f4       	brne	.+14     	; 0x5bb4 <__fp_cmp+0x38>
    5ba6:	0a 26       	eor	r0, r26
    5ba8:	61 f0       	breq	.+24     	; 0x5bc2 <__fp_cmp+0x46>
    5baa:	23 2b       	or	r18, r19
    5bac:	24 2b       	or	r18, r20
    5bae:	25 2b       	or	r18, r21
    5bb0:	21 f4       	brne	.+8      	; 0x5bba <__fp_cmp+0x3e>
    5bb2:	08 95       	ret
    5bb4:	0a 26       	eor	r0, r26
    5bb6:	09 f4       	brne	.+2      	; 0x5bba <__fp_cmp+0x3e>
    5bb8:	a1 40       	sbci	r26, 0x01	; 1
    5bba:	a6 95       	lsr	r26
    5bbc:	8f ef       	ldi	r24, 0xFF	; 255
    5bbe:	81 1d       	adc	r24, r1
    5bc0:	81 1d       	adc	r24, r1
    5bc2:	08 95       	ret

00005bc4 <__fp_inf>:
    5bc4:	97 f9       	bld	r25, 7
    5bc6:	9f 67       	ori	r25, 0x7F	; 127
    5bc8:	80 e8       	ldi	r24, 0x80	; 128
    5bca:	70 e0       	ldi	r23, 0x00	; 0
    5bcc:	60 e0       	ldi	r22, 0x00	; 0
    5bce:	08 95       	ret

00005bd0 <__fp_nan>:
    5bd0:	9f ef       	ldi	r25, 0xFF	; 255
    5bd2:	80 ec       	ldi	r24, 0xC0	; 192
    5bd4:	08 95       	ret

00005bd6 <__fp_pscA>:
    5bd6:	00 24       	eor	r0, r0
    5bd8:	0a 94       	dec	r0
    5bda:	16 16       	cp	r1, r22
    5bdc:	17 06       	cpc	r1, r23
    5bde:	18 06       	cpc	r1, r24
    5be0:	09 06       	cpc	r0, r25
    5be2:	08 95       	ret

00005be4 <__fp_pscB>:
    5be4:	00 24       	eor	r0, r0
    5be6:	0a 94       	dec	r0
    5be8:	12 16       	cp	r1, r18
    5bea:	13 06       	cpc	r1, r19
    5bec:	14 06       	cpc	r1, r20
    5bee:	05 06       	cpc	r0, r21
    5bf0:	08 95       	ret

00005bf2 <__fp_round>:
    5bf2:	09 2e       	mov	r0, r25
    5bf4:	03 94       	inc	r0
    5bf6:	00 0c       	add	r0, r0
    5bf8:	11 f4       	brne	.+4      	; 0x5bfe <__fp_round+0xc>
    5bfa:	88 23       	and	r24, r24
    5bfc:	52 f0       	brmi	.+20     	; 0x5c12 <__fp_round+0x20>
    5bfe:	bb 0f       	add	r27, r27
    5c00:	40 f4       	brcc	.+16     	; 0x5c12 <__fp_round+0x20>
    5c02:	bf 2b       	or	r27, r31
    5c04:	11 f4       	brne	.+4      	; 0x5c0a <__fp_round+0x18>
    5c06:	60 ff       	sbrs	r22, 0
    5c08:	04 c0       	rjmp	.+8      	; 0x5c12 <__fp_round+0x20>
    5c0a:	6f 5f       	subi	r22, 0xFF	; 255
    5c0c:	7f 4f       	sbci	r23, 0xFF	; 255
    5c0e:	8f 4f       	sbci	r24, 0xFF	; 255
    5c10:	9f 4f       	sbci	r25, 0xFF	; 255
    5c12:	08 95       	ret

00005c14 <__fp_split3>:
    5c14:	57 fd       	sbrc	r21, 7
    5c16:	90 58       	subi	r25, 0x80	; 128
    5c18:	44 0f       	add	r20, r20
    5c1a:	55 1f       	adc	r21, r21
    5c1c:	59 f0       	breq	.+22     	; 0x5c34 <__fp_splitA+0x10>
    5c1e:	5f 3f       	cpi	r21, 0xFF	; 255
    5c20:	71 f0       	breq	.+28     	; 0x5c3e <__fp_splitA+0x1a>
    5c22:	47 95       	ror	r20

00005c24 <__fp_splitA>:
    5c24:	88 0f       	add	r24, r24
    5c26:	97 fb       	bst	r25, 7
    5c28:	99 1f       	adc	r25, r25
    5c2a:	61 f0       	breq	.+24     	; 0x5c44 <__fp_splitA+0x20>
    5c2c:	9f 3f       	cpi	r25, 0xFF	; 255
    5c2e:	79 f0       	breq	.+30     	; 0x5c4e <__fp_splitA+0x2a>
    5c30:	87 95       	ror	r24
    5c32:	08 95       	ret
    5c34:	12 16       	cp	r1, r18
    5c36:	13 06       	cpc	r1, r19
    5c38:	14 06       	cpc	r1, r20
    5c3a:	55 1f       	adc	r21, r21
    5c3c:	f2 cf       	rjmp	.-28     	; 0x5c22 <__fp_split3+0xe>
    5c3e:	46 95       	lsr	r20
    5c40:	f1 df       	rcall	.-30     	; 0x5c24 <__fp_splitA>
    5c42:	08 c0       	rjmp	.+16     	; 0x5c54 <__fp_splitA+0x30>
    5c44:	16 16       	cp	r1, r22
    5c46:	17 06       	cpc	r1, r23
    5c48:	18 06       	cpc	r1, r24
    5c4a:	99 1f       	adc	r25, r25
    5c4c:	f1 cf       	rjmp	.-30     	; 0x5c30 <__fp_splitA+0xc>
    5c4e:	86 95       	lsr	r24
    5c50:	71 05       	cpc	r23, r1
    5c52:	61 05       	cpc	r22, r1
    5c54:	08 94       	sec
    5c56:	08 95       	ret

00005c58 <__fp_zero>:
    5c58:	e8 94       	clt

00005c5a <__fp_szero>:
    5c5a:	bb 27       	eor	r27, r27
    5c5c:	66 27       	eor	r22, r22
    5c5e:	77 27       	eor	r23, r23
    5c60:	cb 01       	movw	r24, r22
    5c62:	97 f9       	bld	r25, 7
    5c64:	08 95       	ret

00005c66 <__gesf2>:
    5c66:	8a df       	rcall	.-236    	; 0x5b7c <__fp_cmp>
    5c68:	08 f4       	brcc	.+2      	; 0x5c6c <__gesf2+0x6>
    5c6a:	8f ef       	ldi	r24, 0xFF	; 255
    5c6c:	08 95       	ret

00005c6e <__mulsf3>:
    5c6e:	0b d0       	rcall	.+22     	; 0x5c86 <__mulsf3x>
    5c70:	c0 cf       	rjmp	.-128    	; 0x5bf2 <__fp_round>
    5c72:	b1 df       	rcall	.-158    	; 0x5bd6 <__fp_pscA>
    5c74:	28 f0       	brcs	.+10     	; 0x5c80 <__mulsf3+0x12>
    5c76:	b6 df       	rcall	.-148    	; 0x5be4 <__fp_pscB>
    5c78:	18 f0       	brcs	.+6      	; 0x5c80 <__mulsf3+0x12>
    5c7a:	95 23       	and	r25, r21
    5c7c:	09 f0       	breq	.+2      	; 0x5c80 <__mulsf3+0x12>
    5c7e:	a2 cf       	rjmp	.-188    	; 0x5bc4 <__fp_inf>
    5c80:	a7 cf       	rjmp	.-178    	; 0x5bd0 <__fp_nan>
    5c82:	11 24       	eor	r1, r1
    5c84:	ea cf       	rjmp	.-44     	; 0x5c5a <__fp_szero>

00005c86 <__mulsf3x>:
    5c86:	c6 df       	rcall	.-116    	; 0x5c14 <__fp_split3>
    5c88:	a0 f3       	brcs	.-24     	; 0x5c72 <__mulsf3+0x4>

00005c8a <__mulsf3_pse>:
    5c8a:	95 9f       	mul	r25, r21
    5c8c:	d1 f3       	breq	.-12     	; 0x5c82 <__mulsf3+0x14>
    5c8e:	95 0f       	add	r25, r21
    5c90:	50 e0       	ldi	r21, 0x00	; 0
    5c92:	55 1f       	adc	r21, r21
    5c94:	62 9f       	mul	r22, r18
    5c96:	f0 01       	movw	r30, r0
    5c98:	72 9f       	mul	r23, r18
    5c9a:	bb 27       	eor	r27, r27
    5c9c:	f0 0d       	add	r31, r0
    5c9e:	b1 1d       	adc	r27, r1
    5ca0:	63 9f       	mul	r22, r19
    5ca2:	aa 27       	eor	r26, r26
    5ca4:	f0 0d       	add	r31, r0
    5ca6:	b1 1d       	adc	r27, r1
    5ca8:	aa 1f       	adc	r26, r26
    5caa:	64 9f       	mul	r22, r20
    5cac:	66 27       	eor	r22, r22
    5cae:	b0 0d       	add	r27, r0
    5cb0:	a1 1d       	adc	r26, r1
    5cb2:	66 1f       	adc	r22, r22
    5cb4:	82 9f       	mul	r24, r18
    5cb6:	22 27       	eor	r18, r18
    5cb8:	b0 0d       	add	r27, r0
    5cba:	a1 1d       	adc	r26, r1
    5cbc:	62 1f       	adc	r22, r18
    5cbe:	73 9f       	mul	r23, r19
    5cc0:	b0 0d       	add	r27, r0
    5cc2:	a1 1d       	adc	r26, r1
    5cc4:	62 1f       	adc	r22, r18
    5cc6:	83 9f       	mul	r24, r19
    5cc8:	a0 0d       	add	r26, r0
    5cca:	61 1d       	adc	r22, r1
    5ccc:	22 1f       	adc	r18, r18
    5cce:	74 9f       	mul	r23, r20
    5cd0:	33 27       	eor	r19, r19
    5cd2:	a0 0d       	add	r26, r0
    5cd4:	61 1d       	adc	r22, r1
    5cd6:	23 1f       	adc	r18, r19
    5cd8:	84 9f       	mul	r24, r20
    5cda:	60 0d       	add	r22, r0
    5cdc:	21 1d       	adc	r18, r1
    5cde:	82 2f       	mov	r24, r18
    5ce0:	76 2f       	mov	r23, r22
    5ce2:	6a 2f       	mov	r22, r26
    5ce4:	11 24       	eor	r1, r1
    5ce6:	9f 57       	subi	r25, 0x7F	; 127
    5ce8:	50 40       	sbci	r21, 0x00	; 0
    5cea:	8a f0       	brmi	.+34     	; 0x5d0e <__mulsf3_pse+0x84>
    5cec:	e1 f0       	breq	.+56     	; 0x5d26 <__mulsf3_pse+0x9c>
    5cee:	88 23       	and	r24, r24
    5cf0:	4a f0       	brmi	.+18     	; 0x5d04 <__mulsf3_pse+0x7a>
    5cf2:	ee 0f       	add	r30, r30
    5cf4:	ff 1f       	adc	r31, r31
    5cf6:	bb 1f       	adc	r27, r27
    5cf8:	66 1f       	adc	r22, r22
    5cfa:	77 1f       	adc	r23, r23
    5cfc:	88 1f       	adc	r24, r24
    5cfe:	91 50       	subi	r25, 0x01	; 1
    5d00:	50 40       	sbci	r21, 0x00	; 0
    5d02:	a9 f7       	brne	.-22     	; 0x5cee <__mulsf3_pse+0x64>
    5d04:	9e 3f       	cpi	r25, 0xFE	; 254
    5d06:	51 05       	cpc	r21, r1
    5d08:	70 f0       	brcs	.+28     	; 0x5d26 <__mulsf3_pse+0x9c>
    5d0a:	5c cf       	rjmp	.-328    	; 0x5bc4 <__fp_inf>
    5d0c:	a6 cf       	rjmp	.-180    	; 0x5c5a <__fp_szero>
    5d0e:	5f 3f       	cpi	r21, 0xFF	; 255
    5d10:	ec f3       	brlt	.-6      	; 0x5d0c <__mulsf3_pse+0x82>
    5d12:	98 3e       	cpi	r25, 0xE8	; 232
    5d14:	dc f3       	brlt	.-10     	; 0x5d0c <__mulsf3_pse+0x82>
    5d16:	86 95       	lsr	r24
    5d18:	77 95       	ror	r23
    5d1a:	67 95       	ror	r22
    5d1c:	b7 95       	ror	r27
    5d1e:	f7 95       	ror	r31
    5d20:	e7 95       	ror	r30
    5d22:	9f 5f       	subi	r25, 0xFF	; 255
    5d24:	c1 f7       	brne	.-16     	; 0x5d16 <__mulsf3_pse+0x8c>
    5d26:	fe 2b       	or	r31, r30
    5d28:	88 0f       	add	r24, r24
    5d2a:	91 1d       	adc	r25, r1
    5d2c:	96 95       	lsr	r25
    5d2e:	87 95       	ror	r24
    5d30:	97 f9       	bld	r25, 7
    5d32:	08 95       	ret

00005d34 <pow>:
    5d34:	fa 01       	movw	r30, r20
    5d36:	ee 0f       	add	r30, r30
    5d38:	ff 1f       	adc	r31, r31
    5d3a:	30 96       	adiw	r30, 0x00	; 0
    5d3c:	21 05       	cpc	r18, r1
    5d3e:	31 05       	cpc	r19, r1
    5d40:	99 f1       	breq	.+102    	; 0x5da8 <pow+0x74>
    5d42:	61 15       	cp	r22, r1
    5d44:	71 05       	cpc	r23, r1
    5d46:	61 f4       	brne	.+24     	; 0x5d60 <pow+0x2c>
    5d48:	80 38       	cpi	r24, 0x80	; 128
    5d4a:	bf e3       	ldi	r27, 0x3F	; 63
    5d4c:	9b 07       	cpc	r25, r27
    5d4e:	49 f1       	breq	.+82     	; 0x5da2 <pow+0x6e>
    5d50:	68 94       	set
    5d52:	90 38       	cpi	r25, 0x80	; 128
    5d54:	81 05       	cpc	r24, r1
    5d56:	61 f0       	breq	.+24     	; 0x5d70 <pow+0x3c>
    5d58:	80 38       	cpi	r24, 0x80	; 128
    5d5a:	bf ef       	ldi	r27, 0xFF	; 255
    5d5c:	9b 07       	cpc	r25, r27
    5d5e:	41 f0       	breq	.+16     	; 0x5d70 <pow+0x3c>
    5d60:	99 23       	and	r25, r25
    5d62:	42 f5       	brpl	.+80     	; 0x5db4 <pow+0x80>
    5d64:	ff 3f       	cpi	r31, 0xFF	; 255
    5d66:	e1 05       	cpc	r30, r1
    5d68:	31 05       	cpc	r19, r1
    5d6a:	21 05       	cpc	r18, r1
    5d6c:	11 f1       	breq	.+68     	; 0x5db2 <pow+0x7e>
    5d6e:	e8 94       	clt
    5d70:	08 94       	sec
    5d72:	e7 95       	ror	r30
    5d74:	d9 01       	movw	r26, r18
    5d76:	aa 23       	and	r26, r26
    5d78:	29 f4       	brne	.+10     	; 0x5d84 <pow+0x50>
    5d7a:	ab 2f       	mov	r26, r27
    5d7c:	be 2f       	mov	r27, r30
    5d7e:	f8 5f       	subi	r31, 0xF8	; 248
    5d80:	d0 f3       	brcs	.-12     	; 0x5d76 <pow+0x42>
    5d82:	10 c0       	rjmp	.+32     	; 0x5da4 <pow+0x70>
    5d84:	ff 5f       	subi	r31, 0xFF	; 255
    5d86:	70 f4       	brcc	.+28     	; 0x5da4 <pow+0x70>
    5d88:	a6 95       	lsr	r26
    5d8a:	e0 f7       	brcc	.-8      	; 0x5d84 <pow+0x50>
    5d8c:	f7 39       	cpi	r31, 0x97	; 151
    5d8e:	50 f0       	brcs	.+20     	; 0x5da4 <pow+0x70>
    5d90:	19 f0       	breq	.+6      	; 0x5d98 <pow+0x64>
    5d92:	ff 3a       	cpi	r31, 0xAF	; 175
    5d94:	38 f4       	brcc	.+14     	; 0x5da4 <pow+0x70>
    5d96:	9f 77       	andi	r25, 0x7F	; 127
    5d98:	9f 93       	push	r25
    5d9a:	0c d0       	rcall	.+24     	; 0x5db4 <pow+0x80>
    5d9c:	0f 90       	pop	r0
    5d9e:	07 fc       	sbrc	r0, 7
    5da0:	90 58       	subi	r25, 0x80	; 128
    5da2:	08 95       	ret
    5da4:	3e f0       	brts	.+14     	; 0x5db4 <pow+0x80>
    5da6:	14 cf       	rjmp	.-472    	; 0x5bd0 <__fp_nan>
    5da8:	60 e0       	ldi	r22, 0x00	; 0
    5daa:	70 e0       	ldi	r23, 0x00	; 0
    5dac:	80 e8       	ldi	r24, 0x80	; 128
    5dae:	9f e3       	ldi	r25, 0x3F	; 63
    5db0:	08 95       	ret
    5db2:	4f e7       	ldi	r20, 0x7F	; 127
    5db4:	9f 77       	andi	r25, 0x7F	; 127
    5db6:	5f 93       	push	r21
    5db8:	4f 93       	push	r20
    5dba:	3f 93       	push	r19
    5dbc:	2f 93       	push	r18
    5dbe:	03 d1       	rcall	.+518    	; 0x5fc6 <log>
    5dc0:	2f 91       	pop	r18
    5dc2:	3f 91       	pop	r19
    5dc4:	4f 91       	pop	r20
    5dc6:	5f 91       	pop	r21
    5dc8:	52 df       	rcall	.-348    	; 0x5c6e <__mulsf3>
    5dca:	53 c0       	rjmp	.+166    	; 0x5e72 <exp>
    5dcc:	11 f4       	brne	.+4      	; 0x5dd2 <pow+0x9e>
    5dce:	0e f4       	brtc	.+2      	; 0x5dd2 <pow+0x9e>
    5dd0:	ff ce       	rjmp	.-514    	; 0x5bd0 <__fp_nan>
    5dd2:	7b c0       	rjmp	.+246    	; 0x5eca <__fp_mpack>

00005dd4 <sqrt>:
    5dd4:	27 df       	rcall	.-434    	; 0x5c24 <__fp_splitA>
    5dd6:	d0 f3       	brcs	.-12     	; 0x5dcc <pow+0x98>
    5dd8:	99 23       	and	r25, r25
    5dda:	d9 f3       	breq	.-10     	; 0x5dd2 <pow+0x9e>
    5ddc:	ce f3       	brts	.-14     	; 0x5dd0 <pow+0x9c>
    5dde:	9f 57       	subi	r25, 0x7F	; 127
    5de0:	55 0b       	sbc	r21, r21
    5de2:	87 ff       	sbrs	r24, 7
    5de4:	82 d0       	rcall	.+260    	; 0x5eea <__fp_norm2>
    5de6:	56 95       	lsr	r21
    5de8:	97 95       	ror	r25
    5dea:	b0 e0       	ldi	r27, 0x00	; 0
    5dec:	20 f4       	brcc	.+8      	; 0x5df6 <sqrt+0x22>
    5dee:	66 0f       	add	r22, r22
    5df0:	77 1f       	adc	r23, r23
    5df2:	88 1f       	adc	r24, r24
    5df4:	bb 1f       	adc	r27, r27
    5df6:	1f 93       	push	r17
    5df8:	0f 93       	push	r16
    5dfa:	00 24       	eor	r0, r0
    5dfc:	90 01       	movw	r18, r0
    5dfe:	a0 01       	movw	r20, r0
    5e00:	80 01       	movw	r16, r0
    5e02:	f0 01       	movw	r30, r0
    5e04:	a0 e8       	ldi	r26, 0x80	; 128
    5e06:	0e 0f       	add	r16, r30
    5e08:	1f 1f       	adc	r17, r31
    5e0a:	0a 1e       	adc	r0, r26
    5e0c:	51 1d       	adc	r21, r1
    5e0e:	60 1b       	sub	r22, r16
    5e10:	71 0b       	sbc	r23, r17
    5e12:	80 09       	sbc	r24, r0
    5e14:	b5 0b       	sbc	r27, r21
    5e16:	48 f4       	brcc	.+18     	; 0x5e2a <sqrt+0x56>
    5e18:	60 0f       	add	r22, r16
    5e1a:	71 1f       	adc	r23, r17
    5e1c:	80 1d       	adc	r24, r0
    5e1e:	b5 1f       	adc	r27, r21
    5e20:	0e 1b       	sub	r16, r30
    5e22:	1f 0b       	sbc	r17, r31
    5e24:	0a 0a       	sbc	r0, r26
    5e26:	51 09       	sbc	r21, r1
    5e28:	07 c0       	rjmp	.+14     	; 0x5e38 <sqrt+0x64>
    5e2a:	2e 0f       	add	r18, r30
    5e2c:	3f 1f       	adc	r19, r31
    5e2e:	4a 1f       	adc	r20, r26
    5e30:	0e 0f       	add	r16, r30
    5e32:	1f 1f       	adc	r17, r31
    5e34:	0a 1e       	adc	r0, r26
    5e36:	51 1d       	adc	r21, r1
    5e38:	66 0f       	add	r22, r22
    5e3a:	77 1f       	adc	r23, r23
    5e3c:	88 1f       	adc	r24, r24
    5e3e:	bb 1f       	adc	r27, r27
    5e40:	a6 95       	lsr	r26
    5e42:	f7 95       	ror	r31
    5e44:	e7 95       	ror	r30
    5e46:	f8 f6       	brcc	.-66     	; 0x5e06 <sqrt+0x32>
    5e48:	06 17       	cp	r16, r22
    5e4a:	17 07       	cpc	r17, r23
    5e4c:	08 06       	cpc	r0, r24
    5e4e:	5b 07       	cpc	r21, r27
    5e50:	21 1d       	adc	r18, r1
    5e52:	31 1d       	adc	r19, r1
    5e54:	41 1d       	adc	r20, r1
    5e56:	0f 91       	pop	r16
    5e58:	1f 91       	pop	r17
    5e5a:	b9 01       	movw	r22, r18
    5e5c:	84 2f       	mov	r24, r20
    5e5e:	91 58       	subi	r25, 0x81	; 129
    5e60:	88 0f       	add	r24, r24
    5e62:	96 95       	lsr	r25
    5e64:	87 95       	ror	r24
    5e66:	08 95       	ret
    5e68:	19 f4       	brne	.+6      	; 0x5e70 <sqrt+0x9c>
    5e6a:	0e f0       	brts	.+2      	; 0x5e6e <sqrt+0x9a>
    5e6c:	ab ce       	rjmp	.-682    	; 0x5bc4 <__fp_inf>
    5e6e:	f4 ce       	rjmp	.-536    	; 0x5c58 <__fp_zero>
    5e70:	af ce       	rjmp	.-674    	; 0x5bd0 <__fp_nan>

00005e72 <exp>:
    5e72:	d8 de       	rcall	.-592    	; 0x5c24 <__fp_splitA>
    5e74:	c8 f3       	brcs	.-14     	; 0x5e68 <sqrt+0x94>
    5e76:	96 38       	cpi	r25, 0x86	; 134
    5e78:	c0 f7       	brcc	.-16     	; 0x5e6a <sqrt+0x96>
    5e7a:	07 f8       	bld	r0, 7
    5e7c:	0f 92       	push	r0
    5e7e:	e8 94       	clt
    5e80:	2b e3       	ldi	r18, 0x3B	; 59
    5e82:	3a ea       	ldi	r19, 0xAA	; 170
    5e84:	48 eb       	ldi	r20, 0xB8	; 184
    5e86:	5f e7       	ldi	r21, 0x7F	; 127
    5e88:	00 df       	rcall	.-512    	; 0x5c8a <__mulsf3_pse>
    5e8a:	0f 92       	push	r0
    5e8c:	0f 92       	push	r0
    5e8e:	0f 92       	push	r0
    5e90:	4d b7       	in	r20, 0x3d	; 61
    5e92:	5e b7       	in	r21, 0x3e	; 62
    5e94:	0f 92       	push	r0
    5e96:	d7 d0       	rcall	.+430    	; 0x6046 <modf>
    5e98:	e4 ee       	ldi	r30, 0xE4	; 228
    5e9a:	f0 e0       	ldi	r31, 0x00	; 0
    5e9c:	2d d0       	rcall	.+90     	; 0x5ef8 <__fp_powser>
    5e9e:	4f 91       	pop	r20
    5ea0:	5f 91       	pop	r21
    5ea2:	ef 91       	pop	r30
    5ea4:	ff 91       	pop	r31
    5ea6:	e5 95       	asr	r30
    5ea8:	ee 1f       	adc	r30, r30
    5eaa:	ff 1f       	adc	r31, r31
    5eac:	49 f0       	breq	.+18     	; 0x5ec0 <exp+0x4e>
    5eae:	fe 57       	subi	r31, 0x7E	; 126
    5eb0:	e0 68       	ori	r30, 0x80	; 128
    5eb2:	44 27       	eor	r20, r20
    5eb4:	ee 0f       	add	r30, r30
    5eb6:	44 1f       	adc	r20, r20
    5eb8:	fa 95       	dec	r31
    5eba:	e1 f7       	brne	.-8      	; 0x5eb4 <exp+0x42>
    5ebc:	41 95       	neg	r20
    5ebe:	55 0b       	sbc	r21, r21
    5ec0:	49 d0       	rcall	.+146    	; 0x5f54 <ldexp>
    5ec2:	0f 90       	pop	r0
    5ec4:	07 fe       	sbrs	r0, 7
    5ec6:	3d c0       	rjmp	.+122    	; 0x5f42 <inverse>
    5ec8:	08 95       	ret

00005eca <__fp_mpack>:
    5eca:	9f 3f       	cpi	r25, 0xFF	; 255
    5ecc:	49 f0       	breq	.+18     	; 0x5ee0 <__fp_mpack+0x16>
    5ece:	91 50       	subi	r25, 0x01	; 1
    5ed0:	28 f4       	brcc	.+10     	; 0x5edc <__fp_mpack+0x12>
    5ed2:	86 95       	lsr	r24
    5ed4:	77 95       	ror	r23
    5ed6:	67 95       	ror	r22
    5ed8:	b7 95       	ror	r27
    5eda:	9f 5f       	subi	r25, 0xFF	; 255
    5edc:	80 38       	cpi	r24, 0x80	; 128
    5ede:	9f 4f       	sbci	r25, 0xFF	; 255
    5ee0:	88 0f       	add	r24, r24
    5ee2:	96 95       	lsr	r25
    5ee4:	87 95       	ror	r24
    5ee6:	97 f9       	bld	r25, 7
    5ee8:	08 95       	ret

00005eea <__fp_norm2>:
    5eea:	91 50       	subi	r25, 0x01	; 1
    5eec:	50 40       	sbci	r21, 0x00	; 0
    5eee:	66 0f       	add	r22, r22
    5ef0:	77 1f       	adc	r23, r23
    5ef2:	88 1f       	adc	r24, r24
    5ef4:	d2 f7       	brpl	.-12     	; 0x5eea <__fp_norm2>
    5ef6:	08 95       	ret

00005ef8 <__fp_powser>:
    5ef8:	df 93       	push	r29
    5efa:	cf 93       	push	r28
    5efc:	1f 93       	push	r17
    5efe:	0f 93       	push	r16
    5f00:	ff 92       	push	r15
    5f02:	ef 92       	push	r14
    5f04:	df 92       	push	r13
    5f06:	7b 01       	movw	r14, r22
    5f08:	8c 01       	movw	r16, r24
    5f0a:	68 94       	set
    5f0c:	05 c0       	rjmp	.+10     	; 0x5f18 <__fp_powser+0x20>
    5f0e:	da 2e       	mov	r13, r26
    5f10:	ef 01       	movw	r28, r30
    5f12:	b9 de       	rcall	.-654    	; 0x5c86 <__mulsf3x>
    5f14:	fe 01       	movw	r30, r28
    5f16:	e8 94       	clt
    5f18:	a5 91       	lpm	r26, Z+
    5f1a:	25 91       	lpm	r18, Z+
    5f1c:	35 91       	lpm	r19, Z+
    5f1e:	45 91       	lpm	r20, Z+
    5f20:	55 91       	lpm	r21, Z+
    5f22:	ae f3       	brts	.-22     	; 0x5f0e <__fp_powser+0x16>
    5f24:	ef 01       	movw	r28, r30
    5f26:	fd dc       	rcall	.-1542   	; 0x5922 <__addsf3x>
    5f28:	fe 01       	movw	r30, r28
    5f2a:	97 01       	movw	r18, r14
    5f2c:	a8 01       	movw	r20, r16
    5f2e:	da 94       	dec	r13
    5f30:	79 f7       	brne	.-34     	; 0x5f10 <__fp_powser+0x18>
    5f32:	df 90       	pop	r13
    5f34:	ef 90       	pop	r14
    5f36:	ff 90       	pop	r15
    5f38:	0f 91       	pop	r16
    5f3a:	1f 91       	pop	r17
    5f3c:	cf 91       	pop	r28
    5f3e:	df 91       	pop	r29
    5f40:	08 95       	ret

00005f42 <inverse>:
    5f42:	9b 01       	movw	r18, r22
    5f44:	ac 01       	movw	r20, r24
    5f46:	60 e0       	ldi	r22, 0x00	; 0
    5f48:	70 e0       	ldi	r23, 0x00	; 0
    5f4a:	80 e8       	ldi	r24, 0x80	; 128
    5f4c:	9f e3       	ldi	r25, 0x3F	; 63
    5f4e:	40 cd       	rjmp	.-1408   	; 0x59d0 <__divsf3>
    5f50:	39 ce       	rjmp	.-910    	; 0x5bc4 <__fp_inf>
    5f52:	bb cf       	rjmp	.-138    	; 0x5eca <__fp_mpack>

00005f54 <ldexp>:
    5f54:	67 de       	rcall	.-818    	; 0x5c24 <__fp_splitA>
    5f56:	e8 f3       	brcs	.-6      	; 0x5f52 <inverse+0x10>
    5f58:	99 23       	and	r25, r25
    5f5a:	d9 f3       	breq	.-10     	; 0x5f52 <inverse+0x10>
    5f5c:	94 0f       	add	r25, r20
    5f5e:	51 1d       	adc	r21, r1
    5f60:	bb f3       	brvs	.-18     	; 0x5f50 <inverse+0xe>
    5f62:	91 50       	subi	r25, 0x01	; 1
    5f64:	50 40       	sbci	r21, 0x00	; 0
    5f66:	94 f0       	brlt	.+36     	; 0x5f8c <ldexp+0x38>
    5f68:	59 f0       	breq	.+22     	; 0x5f80 <ldexp+0x2c>
    5f6a:	88 23       	and	r24, r24
    5f6c:	32 f0       	brmi	.+12     	; 0x5f7a <ldexp+0x26>
    5f6e:	66 0f       	add	r22, r22
    5f70:	77 1f       	adc	r23, r23
    5f72:	88 1f       	adc	r24, r24
    5f74:	91 50       	subi	r25, 0x01	; 1
    5f76:	50 40       	sbci	r21, 0x00	; 0
    5f78:	c1 f7       	brne	.-16     	; 0x5f6a <ldexp+0x16>
    5f7a:	9e 3f       	cpi	r25, 0xFE	; 254
    5f7c:	51 05       	cpc	r21, r1
    5f7e:	44 f7       	brge	.-48     	; 0x5f50 <inverse+0xe>
    5f80:	88 0f       	add	r24, r24
    5f82:	91 1d       	adc	r25, r1
    5f84:	96 95       	lsr	r25
    5f86:	87 95       	ror	r24
    5f88:	97 f9       	bld	r25, 7
    5f8a:	08 95       	ret
    5f8c:	5f 3f       	cpi	r21, 0xFF	; 255
    5f8e:	ac f0       	brlt	.+42     	; 0x5fba <ldexp+0x66>
    5f90:	98 3e       	cpi	r25, 0xE8	; 232
    5f92:	9c f0       	brlt	.+38     	; 0x5fba <ldexp+0x66>
    5f94:	bb 27       	eor	r27, r27
    5f96:	86 95       	lsr	r24
    5f98:	77 95       	ror	r23
    5f9a:	67 95       	ror	r22
    5f9c:	b7 95       	ror	r27
    5f9e:	08 f4       	brcc	.+2      	; 0x5fa2 <ldexp+0x4e>
    5fa0:	b1 60       	ori	r27, 0x01	; 1
    5fa2:	93 95       	inc	r25
    5fa4:	c1 f7       	brne	.-16     	; 0x5f96 <ldexp+0x42>
    5fa6:	bb 0f       	add	r27, r27
    5fa8:	58 f7       	brcc	.-42     	; 0x5f80 <ldexp+0x2c>
    5faa:	11 f4       	brne	.+4      	; 0x5fb0 <ldexp+0x5c>
    5fac:	60 ff       	sbrs	r22, 0
    5fae:	e8 cf       	rjmp	.-48     	; 0x5f80 <ldexp+0x2c>
    5fb0:	6f 5f       	subi	r22, 0xFF	; 255
    5fb2:	7f 4f       	sbci	r23, 0xFF	; 255
    5fb4:	8f 4f       	sbci	r24, 0xFF	; 255
    5fb6:	9f 4f       	sbci	r25, 0xFF	; 255
    5fb8:	e3 cf       	rjmp	.-58     	; 0x5f80 <ldexp+0x2c>
    5fba:	4f ce       	rjmp	.-866    	; 0x5c5a <__fp_szero>
    5fbc:	0e f0       	brts	.+2      	; 0x5fc0 <ldexp+0x6c>
    5fbe:	85 cf       	rjmp	.-246    	; 0x5eca <__fp_mpack>
    5fc0:	07 ce       	rjmp	.-1010   	; 0x5bd0 <__fp_nan>
    5fc2:	68 94       	set
    5fc4:	ff cd       	rjmp	.-1026   	; 0x5bc4 <__fp_inf>

00005fc6 <log>:
    5fc6:	2e de       	rcall	.-932    	; 0x5c24 <__fp_splitA>
    5fc8:	c8 f3       	brcs	.-14     	; 0x5fbc <ldexp+0x68>
    5fca:	99 23       	and	r25, r25
    5fcc:	d1 f3       	breq	.-12     	; 0x5fc2 <ldexp+0x6e>
    5fce:	c6 f3       	brts	.-16     	; 0x5fc0 <ldexp+0x6c>
    5fd0:	df 93       	push	r29
    5fd2:	cf 93       	push	r28
    5fd4:	1f 93       	push	r17
    5fd6:	0f 93       	push	r16
    5fd8:	ff 92       	push	r15
    5fda:	c9 2f       	mov	r28, r25
    5fdc:	dd 27       	eor	r29, r29
    5fde:	88 23       	and	r24, r24
    5fe0:	2a f0       	brmi	.+10     	; 0x5fec <log+0x26>
    5fe2:	21 97       	sbiw	r28, 0x01	; 1
    5fe4:	66 0f       	add	r22, r22
    5fe6:	77 1f       	adc	r23, r23
    5fe8:	88 1f       	adc	r24, r24
    5fea:	da f7       	brpl	.-10     	; 0x5fe2 <log+0x1c>
    5fec:	20 e0       	ldi	r18, 0x00	; 0
    5fee:	30 e0       	ldi	r19, 0x00	; 0
    5ff0:	40 e8       	ldi	r20, 0x80	; 128
    5ff2:	5f eb       	ldi	r21, 0xBF	; 191
    5ff4:	9f e3       	ldi	r25, 0x3F	; 63
    5ff6:	88 39       	cpi	r24, 0x98	; 152
    5ff8:	20 f0       	brcs	.+8      	; 0x6002 <log+0x3c>
    5ffa:	80 3e       	cpi	r24, 0xE0	; 224
    5ffc:	30 f0       	brcs	.+12     	; 0x600a <log+0x44>
    5ffe:	21 96       	adiw	r28, 0x01	; 1
    6000:	8f 77       	andi	r24, 0x7F	; 127
    6002:	7e dc       	rcall	.-1796   	; 0x5900 <__addsf3>
    6004:	ec e0       	ldi	r30, 0x0C	; 12
    6006:	f1 e0       	ldi	r31, 0x01	; 1
    6008:	03 c0       	rjmp	.+6      	; 0x6010 <log+0x4a>
    600a:	7a dc       	rcall	.-1804   	; 0x5900 <__addsf3>
    600c:	e9 e3       	ldi	r30, 0x39	; 57
    600e:	f1 e0       	ldi	r31, 0x01	; 1
    6010:	73 df       	rcall	.-282    	; 0x5ef8 <__fp_powser>
    6012:	8b 01       	movw	r16, r22
    6014:	be 01       	movw	r22, r28
    6016:	ec 01       	movw	r28, r24
    6018:	fb 2e       	mov	r15, r27
    601a:	6f 57       	subi	r22, 0x7F	; 127
    601c:	71 09       	sbc	r23, r1
    601e:	75 95       	asr	r23
    6020:	77 1f       	adc	r23, r23
    6022:	88 0b       	sbc	r24, r24
    6024:	99 0b       	sbc	r25, r25
    6026:	6f dd       	rcall	.-1314   	; 0x5b06 <__floatsisf>
    6028:	28 e1       	ldi	r18, 0x18	; 24
    602a:	32 e7       	ldi	r19, 0x72	; 114
    602c:	41 e3       	ldi	r20, 0x31	; 49
    602e:	5f e3       	ldi	r21, 0x3F	; 63
    6030:	2a de       	rcall	.-940    	; 0x5c86 <__mulsf3x>
    6032:	af 2d       	mov	r26, r15
    6034:	98 01       	movw	r18, r16
    6036:	ae 01       	movw	r20, r28
    6038:	ff 90       	pop	r15
    603a:	0f 91       	pop	r16
    603c:	1f 91       	pop	r17
    603e:	cf 91       	pop	r28
    6040:	df 91       	pop	r29
    6042:	6f dc       	rcall	.-1826   	; 0x5922 <__addsf3x>
    6044:	d6 cd       	rjmp	.-1108   	; 0x5bf2 <__fp_round>

00006046 <modf>:
    6046:	fa 01       	movw	r30, r20
    6048:	dc 01       	movw	r26, r24
    604a:	aa 0f       	add	r26, r26
    604c:	bb 1f       	adc	r27, r27
    604e:	9b 01       	movw	r18, r22
    6050:	ac 01       	movw	r20, r24
    6052:	bf 57       	subi	r27, 0x7F	; 127
    6054:	28 f4       	brcc	.+10     	; 0x6060 <modf+0x1a>
    6056:	22 27       	eor	r18, r18
    6058:	33 27       	eor	r19, r19
    605a:	44 27       	eor	r20, r20
    605c:	50 78       	andi	r21, 0x80	; 128
    605e:	1f c0       	rjmp	.+62     	; 0x609e <modf+0x58>
    6060:	b7 51       	subi	r27, 0x17	; 23
    6062:	88 f4       	brcc	.+34     	; 0x6086 <modf+0x40>
    6064:	ab 2f       	mov	r26, r27
    6066:	00 24       	eor	r0, r0
    6068:	46 95       	lsr	r20
    606a:	37 95       	ror	r19
    606c:	27 95       	ror	r18
    606e:	01 1c       	adc	r0, r1
    6070:	a3 95       	inc	r26
    6072:	d2 f3       	brmi	.-12     	; 0x6068 <modf+0x22>
    6074:	00 20       	and	r0, r0
    6076:	69 f0       	breq	.+26     	; 0x6092 <modf+0x4c>
    6078:	22 0f       	add	r18, r18
    607a:	33 1f       	adc	r19, r19
    607c:	44 1f       	adc	r20, r20
    607e:	b3 95       	inc	r27
    6080:	da f3       	brmi	.-10     	; 0x6078 <modf+0x32>
    6082:	0d d0       	rcall	.+26     	; 0x609e <modf+0x58>
    6084:	3c cc       	rjmp	.-1928   	; 0x58fe <__subsf3>
    6086:	61 30       	cpi	r22, 0x01	; 1
    6088:	71 05       	cpc	r23, r1
    608a:	a0 e8       	ldi	r26, 0x80	; 128
    608c:	8a 07       	cpc	r24, r26
    608e:	b9 46       	sbci	r27, 0x69	; 105
    6090:	30 f4       	brcc	.+12     	; 0x609e <modf+0x58>
    6092:	9b 01       	movw	r18, r22
    6094:	ac 01       	movw	r20, r24
    6096:	66 27       	eor	r22, r22
    6098:	77 27       	eor	r23, r23
    609a:	88 27       	eor	r24, r24
    609c:	90 78       	andi	r25, 0x80	; 128
    609e:	30 96       	adiw	r30, 0x00	; 0
    60a0:	21 f0       	breq	.+8      	; 0x60aa <modf+0x64>
    60a2:	20 83       	st	Z, r18
    60a4:	31 83       	std	Z+1, r19	; 0x01
    60a6:	42 83       	std	Z+2, r20	; 0x02
    60a8:	53 83       	std	Z+3, r21	; 0x03
    60aa:	08 95       	ret

000060ac <__mulsi3>:
    60ac:	62 9f       	mul	r22, r18
    60ae:	d0 01       	movw	r26, r0
    60b0:	73 9f       	mul	r23, r19
    60b2:	f0 01       	movw	r30, r0
    60b4:	82 9f       	mul	r24, r18
    60b6:	e0 0d       	add	r30, r0
    60b8:	f1 1d       	adc	r31, r1
    60ba:	64 9f       	mul	r22, r20
    60bc:	e0 0d       	add	r30, r0
    60be:	f1 1d       	adc	r31, r1
    60c0:	92 9f       	mul	r25, r18
    60c2:	f0 0d       	add	r31, r0
    60c4:	83 9f       	mul	r24, r19
    60c6:	f0 0d       	add	r31, r0
    60c8:	74 9f       	mul	r23, r20
    60ca:	f0 0d       	add	r31, r0
    60cc:	65 9f       	mul	r22, r21
    60ce:	f0 0d       	add	r31, r0
    60d0:	99 27       	eor	r25, r25
    60d2:	72 9f       	mul	r23, r18
    60d4:	b0 0d       	add	r27, r0
    60d6:	e1 1d       	adc	r30, r1
    60d8:	f9 1f       	adc	r31, r25
    60da:	63 9f       	mul	r22, r19
    60dc:	b0 0d       	add	r27, r0
    60de:	e1 1d       	adc	r30, r1
    60e0:	f9 1f       	adc	r31, r25
    60e2:	bd 01       	movw	r22, r26
    60e4:	cf 01       	movw	r24, r30
    60e6:	11 24       	eor	r1, r1
    60e8:	08 95       	ret

000060ea <__udivmodhi4>:
    60ea:	aa 1b       	sub	r26, r26
    60ec:	bb 1b       	sub	r27, r27
    60ee:	51 e1       	ldi	r21, 0x11	; 17
    60f0:	07 c0       	rjmp	.+14     	; 0x6100 <__udivmodhi4_ep>

000060f2 <__udivmodhi4_loop>:
    60f2:	aa 1f       	adc	r26, r26
    60f4:	bb 1f       	adc	r27, r27
    60f6:	a6 17       	cp	r26, r22
    60f8:	b7 07       	cpc	r27, r23
    60fa:	10 f0       	brcs	.+4      	; 0x6100 <__udivmodhi4_ep>
    60fc:	a6 1b       	sub	r26, r22
    60fe:	b7 0b       	sbc	r27, r23

00006100 <__udivmodhi4_ep>:
    6100:	88 1f       	adc	r24, r24
    6102:	99 1f       	adc	r25, r25
    6104:	5a 95       	dec	r21
    6106:	a9 f7       	brne	.-22     	; 0x60f2 <__udivmodhi4_loop>
    6108:	80 95       	com	r24
    610a:	90 95       	com	r25
    610c:	bc 01       	movw	r22, r24
    610e:	cd 01       	movw	r24, r26
    6110:	08 95       	ret

00006112 <__divmodhi4>:
    6112:	97 fb       	bst	r25, 7
    6114:	09 2e       	mov	r0, r25
    6116:	07 26       	eor	r0, r23
    6118:	0a d0       	rcall	.+20     	; 0x612e <__divmodhi4_neg1>
    611a:	77 fd       	sbrc	r23, 7
    611c:	04 d0       	rcall	.+8      	; 0x6126 <__divmodhi4_neg2>
    611e:	e5 df       	rcall	.-54     	; 0x60ea <__udivmodhi4>
    6120:	06 d0       	rcall	.+12     	; 0x612e <__divmodhi4_neg1>
    6122:	00 20       	and	r0, r0
    6124:	1a f4       	brpl	.+6      	; 0x612c <__divmodhi4_exit>

00006126 <__divmodhi4_neg2>:
    6126:	70 95       	com	r23
    6128:	61 95       	neg	r22
    612a:	7f 4f       	sbci	r23, 0xFF	; 255

0000612c <__divmodhi4_exit>:
    612c:	08 95       	ret

0000612e <__divmodhi4_neg1>:
    612e:	f6 f7       	brtc	.-4      	; 0x612c <__divmodhi4_exit>
    6130:	90 95       	com	r25
    6132:	81 95       	neg	r24
    6134:	9f 4f       	sbci	r25, 0xFF	; 255
    6136:	08 95       	ret

00006138 <__udivmodsi4>:
    6138:	a1 e2       	ldi	r26, 0x21	; 33
    613a:	1a 2e       	mov	r1, r26
    613c:	aa 1b       	sub	r26, r26
    613e:	bb 1b       	sub	r27, r27
    6140:	fd 01       	movw	r30, r26
    6142:	0d c0       	rjmp	.+26     	; 0x615e <__udivmodsi4_ep>

00006144 <__udivmodsi4_loop>:
    6144:	aa 1f       	adc	r26, r26
    6146:	bb 1f       	adc	r27, r27
    6148:	ee 1f       	adc	r30, r30
    614a:	ff 1f       	adc	r31, r31
    614c:	a2 17       	cp	r26, r18
    614e:	b3 07       	cpc	r27, r19
    6150:	e4 07       	cpc	r30, r20
    6152:	f5 07       	cpc	r31, r21
    6154:	20 f0       	brcs	.+8      	; 0x615e <__udivmodsi4_ep>
    6156:	a2 1b       	sub	r26, r18
    6158:	b3 0b       	sbc	r27, r19
    615a:	e4 0b       	sbc	r30, r20
    615c:	f5 0b       	sbc	r31, r21

0000615e <__udivmodsi4_ep>:
    615e:	66 1f       	adc	r22, r22
    6160:	77 1f       	adc	r23, r23
    6162:	88 1f       	adc	r24, r24
    6164:	99 1f       	adc	r25, r25
    6166:	1a 94       	dec	r1
    6168:	69 f7       	brne	.-38     	; 0x6144 <__udivmodsi4_loop>
    616a:	60 95       	com	r22
    616c:	70 95       	com	r23
    616e:	80 95       	com	r24
    6170:	90 95       	com	r25
    6172:	9b 01       	movw	r18, r22
    6174:	ac 01       	movw	r20, r24
    6176:	bd 01       	movw	r22, r26
    6178:	cf 01       	movw	r24, r30
    617a:	08 95       	ret

0000617c <__divmodsi4>:
    617c:	97 fb       	bst	r25, 7
    617e:	09 2e       	mov	r0, r25
    6180:	05 26       	eor	r0, r21
    6182:	0e d0       	rcall	.+28     	; 0x61a0 <__divmodsi4_neg1>
    6184:	57 fd       	sbrc	r21, 7
    6186:	04 d0       	rcall	.+8      	; 0x6190 <__divmodsi4_neg2>
    6188:	d7 df       	rcall	.-82     	; 0x6138 <__udivmodsi4>
    618a:	0a d0       	rcall	.+20     	; 0x61a0 <__divmodsi4_neg1>
    618c:	00 1c       	adc	r0, r0
    618e:	38 f4       	brcc	.+14     	; 0x619e <__divmodsi4_exit>

00006190 <__divmodsi4_neg2>:
    6190:	50 95       	com	r21
    6192:	40 95       	com	r20
    6194:	30 95       	com	r19
    6196:	21 95       	neg	r18
    6198:	3f 4f       	sbci	r19, 0xFF	; 255
    619a:	4f 4f       	sbci	r20, 0xFF	; 255
    619c:	5f 4f       	sbci	r21, 0xFF	; 255

0000619e <__divmodsi4_exit>:
    619e:	08 95       	ret

000061a0 <__divmodsi4_neg1>:
    61a0:	f6 f7       	brtc	.-4      	; 0x619e <__divmodsi4_exit>
    61a2:	90 95       	com	r25
    61a4:	80 95       	com	r24
    61a6:	70 95       	com	r23
    61a8:	61 95       	neg	r22
    61aa:	7f 4f       	sbci	r23, 0xFF	; 255
    61ac:	8f 4f       	sbci	r24, 0xFF	; 255
    61ae:	9f 4f       	sbci	r25, 0xFF	; 255
    61b0:	08 95       	ret

000061b2 <_exit>:
    61b2:	f8 94       	cli

000061b4 <__stop_program>:
    61b4:	ff cf       	rjmp	.-2      	; 0x61b4 <__stop_program>


lbRTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000ac  00800200  000060be  00006152  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000060be  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000100b  008002ac  008002ac  000061fe  2**0
                  ALLOC
  3 .debug_aranges 000001a0  00000000  00000000  000061fe  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 0000189a  00000000  00000000  0000639e  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00005d66  00000000  00000000  00007c38  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 0000172d  00000000  00000000  0000d99e  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00004b82  00000000  00000000  0000f0cb  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000011f0  00000000  00000000  00013c50  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000246e  00000000  00000000  00014e40  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00002b03  00000000  00000000  000172ae  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000000c0  00000000  00000000  00019db1  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 ee 00 	jmp	0x1dc	; 0x1dc <__ctors_end>
       4:	0c 94 0b 01 	jmp	0x216	; 0x216 <__bad_interrupt>
       8:	0c 94 0b 01 	jmp	0x216	; 0x216 <__bad_interrupt>
       c:	0c 94 0b 01 	jmp	0x216	; 0x216 <__bad_interrupt>
      10:	0c 94 0b 01 	jmp	0x216	; 0x216 <__bad_interrupt>
      14:	0c 94 0b 01 	jmp	0x216	; 0x216 <__bad_interrupt>
      18:	0c 94 0b 01 	jmp	0x216	; 0x216 <__bad_interrupt>
      1c:	0c 94 0b 01 	jmp	0x216	; 0x216 <__bad_interrupt>
      20:	0c 94 0b 01 	jmp	0x216	; 0x216 <__bad_interrupt>
      24:	0c 94 0b 01 	jmp	0x216	; 0x216 <__bad_interrupt>
      28:	0c 94 0b 01 	jmp	0x216	; 0x216 <__bad_interrupt>
      2c:	0c 94 0b 01 	jmp	0x216	; 0x216 <__bad_interrupt>
      30:	0c 94 0b 01 	jmp	0x216	; 0x216 <__bad_interrupt>
      34:	0c 94 46 20 	jmp	0x408c	; 0x408c <__vector_13>
      38:	0c 94 73 20 	jmp	0x40e6	; 0x40e6 <__vector_14>
      3c:	0c 94 65 1e 	jmp	0x3cca	; 0x3cca <__vector_15>
      40:	0c 94 bf 1f 	jmp	0x3f7e	; 0x3f7e <__vector_16>
      44:	0c 94 93 19 	jmp	0x3326	; 0x3326 <__vector_17>
      48:	0c 94 ec 1f 	jmp	0x3fd8	; 0x3fd8 <__vector_18>
      4c:	0c 94 19 20 	jmp	0x4032	; 0x4032 <__vector_19>
      50:	0c 94 25 1e 	jmp	0x3c4a	; 0x3c4a <__vector_20>
      54:	0c 94 65 1f 	jmp	0x3eca	; 0x3eca <__vector_21>
      58:	0c 94 92 1f 	jmp	0x3f24	; 0x3f24 <__vector_22>
      5c:	0c 94 d2 1d 	jmp	0x3ba4	; 0x3ba4 <__vector_23>
      60:	0c 94 0b 01 	jmp	0x216	; 0x216 <__bad_interrupt>
      64:	0c 94 3c 24 	jmp	0x4878	; 0x4878 <__vector_25>
      68:	0c 94 0b 01 	jmp	0x216	; 0x216 <__bad_interrupt>
      6c:	0c 94 99 25 	jmp	0x4b32	; 0x4b32 <__vector_27>
      70:	0c 94 0b 01 	jmp	0x216	; 0x216 <__bad_interrupt>
      74:	0c 94 53 28 	jmp	0x50a6	; 0x50a6 <__vector_29>
      78:	0c 94 0b 01 	jmp	0x216	; 0x216 <__bad_interrupt>
      7c:	0c 94 a0 20 	jmp	0x4140	; 0x4140 <__vector_31>
      80:	0c 94 cd 20 	jmp	0x419a	; 0x419a <__vector_32>
      84:	0c 94 fa 20 	jmp	0x41f4	; 0x41f4 <__vector_33>
      88:	0c 94 27 21 	jmp	0x424e	; 0x424e <__vector_34>
      8c:	0c 94 a5 1e 	jmp	0x3d4a	; 0x3d4a <__vector_35>
      90:	0c 94 17 24 	jmp	0x482e	; 0x482e <__vector_36>
      94:	0c 94 0b 01 	jmp	0x216	; 0x216 <__bad_interrupt>
      98:	0c 94 74 25 	jmp	0x4ae8	; 0x4ae8 <__vector_38>
      9c:	0c 94 71 2c 	jmp	0x58e2	; 0x58e2 <__vector_39>
      a0:	0c 94 0b 01 	jmp	0x216	; 0x216 <__bad_interrupt>
      a4:	0c 94 54 21 	jmp	0x42a8	; 0x42a8 <__vector_41>
      a8:	0c 94 81 21 	jmp	0x4302	; 0x4302 <__vector_42>
      ac:	0c 94 ae 21 	jmp	0x435c	; 0x435c <__vector_43>
      b0:	0c 94 db 21 	jmp	0x43b6	; 0x43b6 <__vector_44>
      b4:	0c 94 e5 1e 	jmp	0x3dca	; 0x3dca <__vector_45>
      b8:	0c 94 08 22 	jmp	0x4410	; 0x4410 <__vector_46>
      bc:	0c 94 35 22 	jmp	0x446a	; 0x446a <__vector_47>
      c0:	0c 94 62 22 	jmp	0x44c4	; 0x44c4 <__vector_48>
      c4:	0c 94 8f 22 	jmp	0x451e	; 0x451e <__vector_49>
      c8:	0c 94 25 1f 	jmp	0x3e4a	; 0x3e4a <__vector_50>
      cc:	0c 94 f2 23 	jmp	0x47e4	; 0x47e4 <__vector_51>
      d0:	0c 94 0b 01 	jmp	0x216	; 0x216 <__bad_interrupt>
      d4:	0c 94 4f 25 	jmp	0x4a9e	; 0x4a9e <__vector_53>
      d8:	0c 94 cd 23 	jmp	0x479a	; 0x479a <__vector_54>
      dc:	0c 94 0b 01 	jmp	0x216	; 0x216 <__bad_interrupt>
      e0:	0c 94 2a 25 	jmp	0x4a54	; 0x4a54 <__vector_56>

000000e4 <__c.3365>:
      e4:	44 45 41 54 48 0a 00                                DEATH..

000000eb <__c.3354>:
      eb:	63 6d 64 5f 61 6e 67 6c 65 3a 20 00                 cmd_angle: .

000000f7 <__c.3352>:
      f7:	63 6d 64 5f 61 6e 67 6c 65 3a 20 00                 cmd_angle: .

00000103 <__c.3234>:
     103:	0a 00                                               ..

00000105 <__c.3232>:
     105:	25 64 00                                            %d.

00000108 <__c.3220>:
     108:	25 64 0a 00                                         %d..

0000010c <__c.3185>:
     10c:	52 49 47 48 54 56 65 6c 3a 20 25 64 09 76 5f 6f     RIGHTVel: %d.v_o
     11c:	75 74 5f 52 3a 20 25 64 0a 00                       ut_R: %d..

00000126 <__c.3183>:
     126:	4c 45 46 54 56 65 6c 3a 20 25 64 09 76 5f 6f 75     LEFTVel: %d.v_ou
     136:	74 5f 4c 3a 20 25 64 09 00                          t_L: %d..

0000013f <__c.3155>:
     13f:	09 25 64 2c 20 76 5f 72 69 67 68 74 3a 20 25 64     .%d, v_right: %d
     14f:	0a 00                                               ..

00000151 <__c.3134>:
     151:	0a 4c 56 43 3a 20 25 64 2c 20 76 5f 6f 75 74 3a     .LVC: %d, v_out:
     161:	20 25 64 0a 00                                       %d..

00000166 <__c.3105>:
     166:	49 6e 69 74 69 61 6c 69 7a 61 74 69 6f 6e 20 43     Initialization C
     176:	6f 6d 70 6c 65 74 65 20 0d 0a 00                    omplete ...

00000181 <__c.3100>:
     181:	2e 00                                               ..

00000183 <__c.3098>:
     183:	0d 0a 53 79 73 74 65 6d 20 57 61 72 6d 65 64 20     ..System Warmed 
     193:	55 70 00                                            Up.

00000196 <__c.3040>:
     196:	57 52 0a 00                                         WR..

0000019a <__c.3009>:
     19a:	57 52 0a 00                                         WR..

0000019e <TimerPrescaleFactor>:
     19e:	00 00 01 00 08 00 40 00 00 01 00 04                 ......@.....

000001aa <Timer2PrescaleFactor>:
     1aa:	00 00 01 00 08 00 20 00 40 00 80 00 00 01 00 04     ...... .@.......

000001ba <__c.1991>:
     1ba:	42 41 44 5f 76 65 63 74 20 63 61 6c 6c 65 64 21     BAD_vect called!
	...

000001cb <HexChars>:
     1cb:	30 31 32 33 34 35 36 37 38 39 41 42 43 44 45 46     0123456789ABCDEF
	...

000001dc <__ctors_end>:
     1dc:	11 24       	eor	r1, r1
     1de:	1f be       	out	0x3f, r1	; 63
     1e0:	cf ef       	ldi	r28, 0xFF	; 255
     1e2:	d1 e2       	ldi	r29, 0x21	; 33
     1e4:	de bf       	out	0x3e, r29	; 62
     1e6:	cd bf       	out	0x3d, r28	; 61

000001e8 <__do_copy_data>:
     1e8:	12 e0       	ldi	r17, 0x02	; 2
     1ea:	a0 e0       	ldi	r26, 0x00	; 0
     1ec:	b2 e0       	ldi	r27, 0x02	; 2
     1ee:	ee eb       	ldi	r30, 0xBE	; 190
     1f0:	f0 e6       	ldi	r31, 0x60	; 96
     1f2:	02 c0       	rjmp	.+4      	; 0x1f8 <.do_copy_data_start>

000001f4 <.do_copy_data_loop>:
     1f4:	05 90       	lpm	r0, Z+
     1f6:	0d 92       	st	X+, r0

000001f8 <.do_copy_data_start>:
     1f8:	ac 3a       	cpi	r26, 0xAC	; 172
     1fa:	b1 07       	cpc	r27, r17
     1fc:	d9 f7       	brne	.-10     	; 0x1f4 <.do_copy_data_loop>

000001fe <__do_clear_bss>:
     1fe:	12 e1       	ldi	r17, 0x12	; 18
     200:	ac ea       	ldi	r26, 0xAC	; 172
     202:	b2 e0       	ldi	r27, 0x02	; 2
     204:	01 c0       	rjmp	.+2      	; 0x208 <.do_clear_bss_start>

00000206 <.do_clear_bss_loop>:
     206:	1d 92       	st	X+, r1

00000208 <.do_clear_bss_start>:
     208:	a7 3b       	cpi	r26, 0xB7	; 183
     20a:	b1 07       	cpc	r27, r17
     20c:	e1 f7       	brne	.-8      	; 0x206 <.do_clear_bss_loop>
     20e:	0e 94 55 10 	call	0x20aa	; 0x20aa <main>
     212:	0c 94 9d 2d 	jmp	0x5b3a	; 0x5b3a <exit>

00000216 <__bad_interrupt>:
     216:	0c 94 bc 22 	jmp	0x4578	; 0x4578 <__vector_default>

0000021a <PWM_Init_timer1_LED>:

//OC1B  pin B6 (attached to green LED)
void PWM_Init_timer1_LED(u08 bitRes)
{
	// enable timer2 as 8,9,10bit PWM
	if(bitRes == 9)
     21a:	89 30       	cpi	r24, 0x09	; 9
     21c:	49 f4       	brne	.+18     	; 0x230 <PWM_Init_timer1_LED+0x16>
	{	// 9bit mode
		sbi(TCCR1A,PWM11);
     21e:	80 91 80 00 	lds	r24, 0x0080
     222:	82 60       	ori	r24, 0x02	; 2
     224:	80 93 80 00 	sts	0x0080, r24
		cbi(TCCR1A,PWM10);
     228:	80 91 80 00 	lds	r24, 0x0080
     22c:	8e 7f       	andi	r24, 0xFE	; 254
     22e:	0e c0       	rjmp	.+28     	; 0x24c <PWM_Init_timer1_LED+0x32>
	}
	else if( bitRes == 10 )
     230:	8a 30       	cpi	r24, 0x0A	; 10
     232:	21 f4       	brne	.+8      	; 0x23c <PWM_Init_timer1_LED+0x22>
	{	// 10bit mode
		sbi(TCCR1A,PWM11);
     234:	80 91 80 00 	lds	r24, 0x0080
     238:	82 60       	ori	r24, 0x02	; 2
     23a:	03 c0       	rjmp	.+6      	; 0x242 <PWM_Init_timer1_LED+0x28>
		sbi(TCCR1A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR1A,PWM11);
     23c:	80 91 80 00 	lds	r24, 0x0080
     240:	8d 7f       	andi	r24, 0xFD	; 253
     242:	80 93 80 00 	sts	0x0080, r24
		sbi(TCCR1A,PWM10);
     246:	80 91 80 00 	lds	r24, 0x0080
     24a:	81 60       	ori	r24, 0x01	; 1
     24c:	80 93 80 00 	sts	0x0080, r24
	}
	// clear output compare values
	OCR1B = 0;
     250:	10 92 8b 00 	sts	0x008B, r1
     254:	10 92 8a 00 	sts	0x008A, r1
}
     258:	08 95       	ret

0000025a <PWM_Init_timer2_H6>:
//pin H6, timer2
void PWM_Init_timer2_H6(u08 bitRes)
{
	// enable timer2 as 8,9,10bit PWM
	if(bitRes == 9)
     25a:	89 30       	cpi	r24, 0x09	; 9
     25c:	49 f4       	brne	.+18     	; 0x270 <PWM_Init_timer2_H6+0x16>
	{	// 9bit mode
		sbi(TCCR2A,PWM11);
     25e:	80 91 b0 00 	lds	r24, 0x00B0
     262:	82 60       	ori	r24, 0x02	; 2
     264:	80 93 b0 00 	sts	0x00B0, r24
		cbi(TCCR2A,PWM10);
     268:	80 91 b0 00 	lds	r24, 0x00B0
     26c:	8e 7f       	andi	r24, 0xFE	; 254
     26e:	0e c0       	rjmp	.+28     	; 0x28c <PWM_Init_timer2_H6+0x32>
	}
	else if( bitRes == 10 )
     270:	8a 30       	cpi	r24, 0x0A	; 10
     272:	21 f4       	brne	.+8      	; 0x27c <PWM_Init_timer2_H6+0x22>
	{	// 10bit mode
		sbi(TCCR2A,PWM11);
     274:	80 91 b0 00 	lds	r24, 0x00B0
     278:	82 60       	ori	r24, 0x02	; 2
     27a:	03 c0       	rjmp	.+6      	; 0x282 <PWM_Init_timer2_H6+0x28>
		sbi(TCCR2A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR2A,PWM11);
     27c:	80 91 b0 00 	lds	r24, 0x00B0
     280:	8d 7f       	andi	r24, 0xFD	; 253
     282:	80 93 b0 00 	sts	0x00B0, r24
		sbi(TCCR2A,PWM10);
     286:	80 91 b0 00 	lds	r24, 0x00B0
     28a:	81 60       	ori	r24, 0x01	; 1
     28c:	80 93 b0 00 	sts	0x00B0, r24
	}
	// clear output compare values
	OCR2B = 0;
     290:	10 92 b4 00 	sts	0x00B4, r1
}
     294:	08 95       	ret

00000296 <PWM_Init_timer3_E3>:
//pin E3
void PWM_Init_timer3_E3(u08 bitRes)
{
	// enable timer3 as 8,9,10bit PWM
	if(bitRes == 9)
     296:	89 30       	cpi	r24, 0x09	; 9
     298:	49 f4       	brne	.+18     	; 0x2ac <PWM_Init_timer3_E3+0x16>
	{	// 9bit mode
		sbi(TCCR3A,PWM11);
     29a:	80 91 90 00 	lds	r24, 0x0090
     29e:	82 60       	ori	r24, 0x02	; 2
     2a0:	80 93 90 00 	sts	0x0090, r24
		cbi(TCCR3A,PWM10);
     2a4:	80 91 90 00 	lds	r24, 0x0090
     2a8:	8e 7f       	andi	r24, 0xFE	; 254
     2aa:	0e c0       	rjmp	.+28     	; 0x2c8 <PWM_Init_timer3_E3+0x32>
	}
	else if( bitRes == 10 )
     2ac:	8a 30       	cpi	r24, 0x0A	; 10
     2ae:	21 f4       	brne	.+8      	; 0x2b8 <PWM_Init_timer3_E3+0x22>
	{	// 10bit mode
		sbi(TCCR3A,PWM11);
     2b0:	80 91 90 00 	lds	r24, 0x0090
     2b4:	82 60       	ori	r24, 0x02	; 2
     2b6:	03 c0       	rjmp	.+6      	; 0x2be <PWM_Init_timer3_E3+0x28>
		sbi(TCCR3A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR3A,PWM11);
     2b8:	80 91 90 00 	lds	r24, 0x0090
     2bc:	8d 7f       	andi	r24, 0xFD	; 253
     2be:	80 93 90 00 	sts	0x0090, r24
		sbi(TCCR3A,PWM10);
     2c2:	80 91 90 00 	lds	r24, 0x0090
     2c6:	81 60       	ori	r24, 0x01	; 1
     2c8:	80 93 90 00 	sts	0x0090, r24
	}
	// clear output compare values
	OCR3A = 0;
     2cc:	10 92 99 00 	sts	0x0099, r1
     2d0:	10 92 98 00 	sts	0x0098, r1
	//timer3PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     2d4:	08 95       	ret

000002d6 <PWM_Init_timer3_E4>:
//pin E4
void PWM_Init_timer3_E4(u08 bitRes)
{
	// enable timer3 as 8,9,10bit PWM
	if(bitRes == 9)
     2d6:	89 30       	cpi	r24, 0x09	; 9
     2d8:	49 f4       	brne	.+18     	; 0x2ec <PWM_Init_timer3_E4+0x16>
	{	// 9bit mode
		sbi(TCCR3B,PWM11);
     2da:	80 91 91 00 	lds	r24, 0x0091
     2de:	82 60       	ori	r24, 0x02	; 2
     2e0:	80 93 91 00 	sts	0x0091, r24
		cbi(TCCR3B,PWM10);
     2e4:	80 91 91 00 	lds	r24, 0x0091
     2e8:	8e 7f       	andi	r24, 0xFE	; 254
     2ea:	0e c0       	rjmp	.+28     	; 0x308 <PWM_Init_timer3_E4+0x32>
	}
	else if( bitRes == 10 )
     2ec:	8a 30       	cpi	r24, 0x0A	; 10
     2ee:	21 f4       	brne	.+8      	; 0x2f8 <PWM_Init_timer3_E4+0x22>
	{	// 10bit mode
		sbi(TCCR3B,PWM11);
     2f0:	80 91 91 00 	lds	r24, 0x0091
     2f4:	82 60       	ori	r24, 0x02	; 2
     2f6:	03 c0       	rjmp	.+6      	; 0x2fe <PWM_Init_timer3_E4+0x28>
		sbi(TCCR3B,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR3B,PWM11);
     2f8:	80 91 91 00 	lds	r24, 0x0091
     2fc:	8d 7f       	andi	r24, 0xFD	; 253
     2fe:	80 93 91 00 	sts	0x0091, r24
		sbi(TCCR3B,PWM10);
     302:	80 91 91 00 	lds	r24, 0x0091
     306:	81 60       	ori	r24, 0x01	; 1
     308:	80 93 91 00 	sts	0x0091, r24
	}
	// clear output compare values
	OCR3B = 0;
     30c:	10 92 9b 00 	sts	0x009B, r1
     310:	10 92 9a 00 	sts	0x009A, r1
	//timer3PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     314:	08 95       	ret

00000316 <PWM_Init_timer3_E5>:
//pin E5
void PWM_Init_timer3_E5(u08 bitRes)
{
	// enable timer3 as 8,9,10bit PWM
	if(bitRes == 9)
     316:	89 30       	cpi	r24, 0x09	; 9
     318:	49 f4       	brne	.+18     	; 0x32c <PWM_Init_timer3_E5+0x16>
	{	// 9bit mode
		sbi(TCCR3C,PWM11);
     31a:	80 91 92 00 	lds	r24, 0x0092
     31e:	82 60       	ori	r24, 0x02	; 2
     320:	80 93 92 00 	sts	0x0092, r24
		cbi(TCCR3C,PWM10);
     324:	80 91 92 00 	lds	r24, 0x0092
     328:	8e 7f       	andi	r24, 0xFE	; 254
     32a:	0e c0       	rjmp	.+28     	; 0x348 <PWM_Init_timer3_E5+0x32>
	}
	else if( bitRes == 10 )
     32c:	8a 30       	cpi	r24, 0x0A	; 10
     32e:	21 f4       	brne	.+8      	; 0x338 <PWM_Init_timer3_E5+0x22>
	{	// 10bit mode
		sbi(TCCR3C,PWM11);
     330:	80 91 92 00 	lds	r24, 0x0092
     334:	82 60       	ori	r24, 0x02	; 2
     336:	03 c0       	rjmp	.+6      	; 0x33e <PWM_Init_timer3_E5+0x28>
		sbi(TCCR3C,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR3C,PWM11);
     338:	80 91 92 00 	lds	r24, 0x0092
     33c:	8d 7f       	andi	r24, 0xFD	; 253
     33e:	80 93 92 00 	sts	0x0092, r24
		sbi(TCCR3C,PWM10);
     342:	80 91 92 00 	lds	r24, 0x0092
     346:	81 60       	ori	r24, 0x01	; 1
     348:	80 93 92 00 	sts	0x0092, r24
	}
	// clear output compare values
	OCR3C = 0;
     34c:	10 92 9d 00 	sts	0x009D, r1
     350:	10 92 9c 00 	sts	0x009C, r1
	//timer3PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     354:	08 95       	ret

00000356 <PWM_Init_timer4_H3>:
//pin H3, timer4
void PWM_Init_timer4_H3(u08 bitRes)
{
	// enable timer4 as 8,9,10bit PWM
	if(bitRes == 9)
     356:	89 30       	cpi	r24, 0x09	; 9
     358:	49 f4       	brne	.+18     	; 0x36c <PWM_Init_timer4_H3+0x16>
	{	// 9bit mode
		sbi(TCCR4A,PWM11);
     35a:	80 91 a0 00 	lds	r24, 0x00A0
     35e:	82 60       	ori	r24, 0x02	; 2
     360:	80 93 a0 00 	sts	0x00A0, r24
		cbi(TCCR4A,PWM10);
     364:	80 91 a0 00 	lds	r24, 0x00A0
     368:	8e 7f       	andi	r24, 0xFE	; 254
     36a:	0e c0       	rjmp	.+28     	; 0x388 <PWM_Init_timer4_H3+0x32>
	}
	else if( bitRes == 10 )
     36c:	8a 30       	cpi	r24, 0x0A	; 10
     36e:	21 f4       	brne	.+8      	; 0x378 <PWM_Init_timer4_H3+0x22>
	{	// 10bit mode
		sbi(TCCR4A,PWM11);
     370:	80 91 a0 00 	lds	r24, 0x00A0
     374:	82 60       	ori	r24, 0x02	; 2
     376:	03 c0       	rjmp	.+6      	; 0x37e <PWM_Init_timer4_H3+0x28>
		sbi(TCCR4A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR4A,PWM11);
     378:	80 91 a0 00 	lds	r24, 0x00A0
     37c:	8d 7f       	andi	r24, 0xFD	; 253
     37e:	80 93 a0 00 	sts	0x00A0, r24
		sbi(TCCR4A,PWM10);
     382:	80 91 a0 00 	lds	r24, 0x00A0
     386:	81 60       	ori	r24, 0x01	; 1
     388:	80 93 a0 00 	sts	0x00A0, r24
	}
	// clear output compare values
	OCR4A = 0;
     38c:	10 92 a9 00 	sts	0x00A9, r1
     390:	10 92 a8 00 	sts	0x00A8, r1
	//timer4PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     394:	08 95       	ret

00000396 <PWM_Init_timer4_H4>:
//pin H4, timer4
void PWM_Init_timer4_H4(u08 bitRes)
{
	// enable timer4 as 8,9,10bit PWM
	if(bitRes == 9)
     396:	89 30       	cpi	r24, 0x09	; 9
     398:	49 f4       	brne	.+18     	; 0x3ac <PWM_Init_timer4_H4+0x16>
	{	// 9bit mode
		sbi(TCCR4B,PWM11);
     39a:	80 91 a1 00 	lds	r24, 0x00A1
     39e:	82 60       	ori	r24, 0x02	; 2
     3a0:	80 93 a1 00 	sts	0x00A1, r24
		cbi(TCCR4B,PWM10);
     3a4:	80 91 a1 00 	lds	r24, 0x00A1
     3a8:	8e 7f       	andi	r24, 0xFE	; 254
     3aa:	0e c0       	rjmp	.+28     	; 0x3c8 <PWM_Init_timer4_H4+0x32>
	}
	else if( bitRes == 10 )
     3ac:	8a 30       	cpi	r24, 0x0A	; 10
     3ae:	21 f4       	brne	.+8      	; 0x3b8 <PWM_Init_timer4_H4+0x22>
	{	// 10bit mode
		sbi(TCCR4B,PWM11);
     3b0:	80 91 a1 00 	lds	r24, 0x00A1
     3b4:	82 60       	ori	r24, 0x02	; 2
     3b6:	03 c0       	rjmp	.+6      	; 0x3be <PWM_Init_timer4_H4+0x28>
		sbi(TCCR4B,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR4B,PWM11);
     3b8:	80 91 a1 00 	lds	r24, 0x00A1
     3bc:	8d 7f       	andi	r24, 0xFD	; 253
     3be:	80 93 a1 00 	sts	0x00A1, r24
		sbi(TCCR4B,PWM10);
     3c2:	80 91 a1 00 	lds	r24, 0x00A1
     3c6:	81 60       	ori	r24, 0x01	; 1
     3c8:	80 93 a1 00 	sts	0x00A1, r24
	}
	// clear output compare values
	OCR4B = 0;
     3cc:	10 92 ab 00 	sts	0x00AB, r1
     3d0:	10 92 aa 00 	sts	0x00AA, r1
	//timer4PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     3d4:	08 95       	ret

000003d6 <PWM_Init_timer4_H5>:
//pin H5, timer4
void PWM_Init_timer4_H5(u08 bitRes)
{
	// enable timer4 as 8,9,10bit PWM
	if(bitRes == 9)
     3d6:	89 30       	cpi	r24, 0x09	; 9
     3d8:	49 f4       	brne	.+18     	; 0x3ec <PWM_Init_timer4_H5+0x16>
	{	// 9bit mode
		sbi(TCCR4A,PWM11);
     3da:	80 91 a0 00 	lds	r24, 0x00A0
     3de:	82 60       	ori	r24, 0x02	; 2
     3e0:	80 93 a0 00 	sts	0x00A0, r24
		cbi(TCCR4A,PWM10);
     3e4:	80 91 a0 00 	lds	r24, 0x00A0
     3e8:	8e 7f       	andi	r24, 0xFE	; 254
     3ea:	0e c0       	rjmp	.+28     	; 0x408 <PWM_Init_timer4_H5+0x32>
	}
	else if( bitRes == 10 )
     3ec:	8a 30       	cpi	r24, 0x0A	; 10
     3ee:	21 f4       	brne	.+8      	; 0x3f8 <PWM_Init_timer4_H5+0x22>
	{	// 10bit mode
		sbi(TCCR4A,PWM11);
     3f0:	80 91 a0 00 	lds	r24, 0x00A0
     3f4:	82 60       	ori	r24, 0x02	; 2
     3f6:	03 c0       	rjmp	.+6      	; 0x3fe <PWM_Init_timer4_H5+0x28>
		sbi(TCCR4A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR4A,PWM11);
     3f8:	80 91 a0 00 	lds	r24, 0x00A0
     3fc:	8d 7f       	andi	r24, 0xFD	; 253
     3fe:	80 93 a0 00 	sts	0x00A0, r24
		sbi(TCCR4A,PWM10);
     402:	80 91 a0 00 	lds	r24, 0x00A0
     406:	81 60       	ori	r24, 0x01	; 1
     408:	80 93 a0 00 	sts	0x00A0, r24
	}
	// clear output compare values
	OCR4C = 0;
     40c:	10 92 ad 00 	sts	0x00AD, r1
     410:	10 92 ac 00 	sts	0x00AC, r1
	//timer4PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     414:	08 95       	ret

00000416 <timer1PWMInitICR>:
// include support for arbitrary top-count PWM
// on new AVR processors that support it
void timer1PWMInitICR(u16 topcount)
{
	// set PWM mode with ICR top-count
	cbi(TCCR1A,WGM10);
     416:	e0 e8       	ldi	r30, 0x80	; 128
     418:	f0 e0       	ldi	r31, 0x00	; 0
     41a:	20 81       	ld	r18, Z
     41c:	2e 7f       	andi	r18, 0xFE	; 254
     41e:	20 83       	st	Z, r18
	sbi(TCCR1A,WGM11);
     420:	20 81       	ld	r18, Z
     422:	22 60       	ori	r18, 0x02	; 2
     424:	20 83       	st	Z, r18
	sbi(TCCR1B,WGM12);
     426:	e1 e8       	ldi	r30, 0x81	; 129
     428:	f0 e0       	ldi	r31, 0x00	; 0
     42a:	20 81       	ld	r18, Z
     42c:	28 60       	ori	r18, 0x08	; 8
     42e:	20 83       	st	Z, r18
	sbi(TCCR1B,WGM13);
     430:	20 81       	ld	r18, Z
     432:	20 61       	ori	r18, 0x10	; 16
     434:	20 83       	st	Z, r18
	
	// set top count value
	ICR1 = topcount;
     436:	90 93 87 00 	sts	0x0087, r25
     43a:	80 93 86 00 	sts	0x0086, r24
	
	// clear output compare values
	OCR1A = 0;
     43e:	10 92 89 00 	sts	0x0089, r1
     442:	10 92 88 00 	sts	0x0088, r1
	OCR1B = 0;
     446:	10 92 8b 00 	sts	0x008B, r1
     44a:	10 92 8a 00 	sts	0x008A, r1
	OCR1C = 0;
     44e:	10 92 8d 00 	sts	0x008D, r1
     452:	10 92 8c 00 	sts	0x008C, r1
}
     456:	08 95       	ret

00000458 <timer3PWMInitICR>:
void timer3PWMInitICR(u16 topcount)
{
	// set PWM mode with ICR top-count
	cbi(TCCR3A,WGM10);
     458:	e0 e9       	ldi	r30, 0x90	; 144
     45a:	f0 e0       	ldi	r31, 0x00	; 0
     45c:	20 81       	ld	r18, Z
     45e:	2e 7f       	andi	r18, 0xFE	; 254
     460:	20 83       	st	Z, r18
	sbi(TCCR3A,WGM11);
     462:	20 81       	ld	r18, Z
     464:	22 60       	ori	r18, 0x02	; 2
     466:	20 83       	st	Z, r18
	sbi(TCCR3B,WGM12);
     468:	e1 e9       	ldi	r30, 0x91	; 145
     46a:	f0 e0       	ldi	r31, 0x00	; 0
     46c:	20 81       	ld	r18, Z
     46e:	28 60       	ori	r18, 0x08	; 8
     470:	20 83       	st	Z, r18
	sbi(TCCR3B,WGM13);
     472:	20 81       	ld	r18, Z
     474:	20 61       	ori	r18, 0x10	; 16
     476:	20 83       	st	Z, r18
	
	// set top count value
	ICR3 = topcount;
     478:	90 93 97 00 	sts	0x0097, r25
     47c:	80 93 96 00 	sts	0x0096, r24
	
	// clear output compare values
	OCR3A = 0;
     480:	10 92 99 00 	sts	0x0099, r1
     484:	10 92 98 00 	sts	0x0098, r1
	OCR3B = 0;
     488:	10 92 9b 00 	sts	0x009B, r1
     48c:	10 92 9a 00 	sts	0x009A, r1
	OCR3C = 0;
     490:	10 92 9d 00 	sts	0x009D, r1
     494:	10 92 9c 00 	sts	0x009C, r1
}
     498:	08 95       	ret

0000049a <timer4PWMInitICR>:
void timer4PWMInitICR(u16 topcount)
{
	// set PWM mode with ICR top-count
	cbi(TCCR4A,WGM10);
     49a:	e0 ea       	ldi	r30, 0xA0	; 160
     49c:	f0 e0       	ldi	r31, 0x00	; 0
     49e:	20 81       	ld	r18, Z
     4a0:	2e 7f       	andi	r18, 0xFE	; 254
     4a2:	20 83       	st	Z, r18
	sbi(TCCR4A,WGM11);
     4a4:	20 81       	ld	r18, Z
     4a6:	22 60       	ori	r18, 0x02	; 2
     4a8:	20 83       	st	Z, r18
	sbi(TCCR4B,WGM12);
     4aa:	e1 ea       	ldi	r30, 0xA1	; 161
     4ac:	f0 e0       	ldi	r31, 0x00	; 0
     4ae:	20 81       	ld	r18, Z
     4b0:	28 60       	ori	r18, 0x08	; 8
     4b2:	20 83       	st	Z, r18
	sbi(TCCR4B,WGM13);
     4b4:	20 81       	ld	r18, Z
     4b6:	20 61       	ori	r18, 0x10	; 16
     4b8:	20 83       	st	Z, r18
	
	// set top count value
	ICR4 = topcount;
     4ba:	90 93 a7 00 	sts	0x00A7, r25
     4be:	80 93 a6 00 	sts	0x00A6, r24
	
	// clear output compare values
	OCR4A = 0;
     4c2:	10 92 a9 00 	sts	0x00A9, r1
     4c6:	10 92 a8 00 	sts	0x00A8, r1
	OCR4B = 0;
     4ca:	10 92 ab 00 	sts	0x00AB, r1
     4ce:	10 92 aa 00 	sts	0x00AA, r1
	OCR4C = 0;
     4d2:	10 92 ad 00 	sts	0x00AD, r1
     4d6:	10 92 ac 00 	sts	0x00AC, r1
}
     4da:	08 95       	ret

000004dc <PWM_timer1_On_LED>:
#endif

//on commands
void PWM_timer1_On_LED(void)
{
	sbi(TCCR1A,COM1B1);
     4dc:	e0 e8       	ldi	r30, 0x80	; 128
     4de:	f0 e0       	ldi	r31, 0x00	; 0
     4e0:	80 81       	ld	r24, Z
     4e2:	80 62       	ori	r24, 0x20	; 32
     4e4:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B0);
     4e6:	80 81       	ld	r24, Z
     4e8:	8f 7e       	andi	r24, 0xEF	; 239
     4ea:	80 83       	st	Z, r24
}
     4ec:	08 95       	ret

000004ee <PWM_timer2_On_H6>:
void PWM_timer2_On_H6(void)
{
	sbi(TCCR2A,COM2B1);
     4ee:	e0 eb       	ldi	r30, 0xB0	; 176
     4f0:	f0 e0       	ldi	r31, 0x00	; 0
     4f2:	80 81       	ld	r24, Z
     4f4:	80 62       	ori	r24, 0x20	; 32
     4f6:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B0);
     4f8:	80 81       	ld	r24, Z
     4fa:	8f 7e       	andi	r24, 0xEF	; 239
     4fc:	80 83       	st	Z, r24
}
     4fe:	08 95       	ret

00000500 <PWM_timer3_On_E3>:
void PWM_timer3_On_E3(void)
{
	sbi(TCCR3A,COM3A1);
     500:	e0 e9       	ldi	r30, 0x90	; 144
     502:	f0 e0       	ldi	r31, 0x00	; 0
     504:	80 81       	ld	r24, Z
     506:	80 68       	ori	r24, 0x80	; 128
     508:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3A0);
     50a:	80 81       	ld	r24, Z
     50c:	8f 7b       	andi	r24, 0xBF	; 191
     50e:	80 83       	st	Z, r24
}
     510:	08 95       	ret

00000512 <PWM_timer3_On_E4>:
void PWM_timer3_On_E4(void)
{
	sbi(TCCR3A,COM3B1);
     512:	e0 e9       	ldi	r30, 0x90	; 144
     514:	f0 e0       	ldi	r31, 0x00	; 0
     516:	80 81       	ld	r24, Z
     518:	80 62       	ori	r24, 0x20	; 32
     51a:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3B0);
     51c:	80 81       	ld	r24, Z
     51e:	8f 7e       	andi	r24, 0xEF	; 239
     520:	80 83       	st	Z, r24
}
     522:	08 95       	ret

00000524 <PWM_timer3_On_E5>:
void PWM_timer3_On_E5(void)
{
	sbi(TCCR3A,COM3C1);
     524:	e0 e9       	ldi	r30, 0x90	; 144
     526:	f0 e0       	ldi	r31, 0x00	; 0
     528:	80 81       	ld	r24, Z
     52a:	88 60       	ori	r24, 0x08	; 8
     52c:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C0);
     52e:	80 81       	ld	r24, Z
     530:	8b 7f       	andi	r24, 0xFB	; 251
     532:	80 83       	st	Z, r24
}
     534:	08 95       	ret

00000536 <PWM_timer4_On_H3>:
void PWM_timer4_On_H3(void)
{
	sbi(TCCR4A,COM4A1);
     536:	e0 ea       	ldi	r30, 0xA0	; 160
     538:	f0 e0       	ldi	r31, 0x00	; 0
     53a:	80 81       	ld	r24, Z
     53c:	80 68       	ori	r24, 0x80	; 128
     53e:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4A0);
     540:	80 81       	ld	r24, Z
     542:	8f 7b       	andi	r24, 0xBF	; 191
     544:	80 83       	st	Z, r24
}
     546:	08 95       	ret

00000548 <PWM_timer4_On_H4>:
void PWM_timer4_On_H4(void)
{
	sbi(TCCR4A,COM4B1);
     548:	e0 ea       	ldi	r30, 0xA0	; 160
     54a:	f0 e0       	ldi	r31, 0x00	; 0
     54c:	80 81       	ld	r24, Z
     54e:	80 62       	ori	r24, 0x20	; 32
     550:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4B0);
     552:	80 81       	ld	r24, Z
     554:	8f 7e       	andi	r24, 0xEF	; 239
     556:	80 83       	st	Z, r24
}
     558:	08 95       	ret

0000055a <PWM_timer4_On_H5>:
void PWM_timer4_On_H5(void)
{
	sbi(TCCR4A,COM4C1);
     55a:	e0 ea       	ldi	r30, 0xA0	; 160
     55c:	f0 e0       	ldi	r31, 0x00	; 0
     55e:	80 81       	ld	r24, Z
     560:	88 60       	ori	r24, 0x08	; 8
     562:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4C0);
     564:	80 81       	ld	r24, Z
     566:	8b 7f       	andi	r24, 0xFB	; 251
     568:	80 83       	st	Z, r24
}
     56a:	08 95       	ret

0000056c <PWM_timer1_Off_LED>:

//off commands
void PWM_timer1_Off_LED(void)
{
	cbi(TCCR1A,COM1B1);
     56c:	e0 e8       	ldi	r30, 0x80	; 128
     56e:	f0 e0       	ldi	r31, 0x00	; 0
     570:	80 81       	ld	r24, Z
     572:	8f 7d       	andi	r24, 0xDF	; 223
     574:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B0);
     576:	80 81       	ld	r24, Z
     578:	8f 7e       	andi	r24, 0xEF	; 239
     57a:	80 83       	st	Z, r24
}
     57c:	08 95       	ret

0000057e <PWM_timer2_Off_H6>:
void PWM_timer2_Off_H6(void)
{
	cbi(TCCR2A,COM2B1);
     57e:	e0 eb       	ldi	r30, 0xB0	; 176
     580:	f0 e0       	ldi	r31, 0x00	; 0
     582:	80 81       	ld	r24, Z
     584:	8f 7d       	andi	r24, 0xDF	; 223
     586:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B0);
     588:	80 81       	ld	r24, Z
     58a:	8f 7e       	andi	r24, 0xEF	; 239
     58c:	80 83       	st	Z, r24
}
     58e:	08 95       	ret

00000590 <PWM_timer3_Off_E3>:
void PWM_timer3_Off_E3(void)
{
	cbi(TCCR3A,COM3A1);
     590:	e0 e9       	ldi	r30, 0x90	; 144
     592:	f0 e0       	ldi	r31, 0x00	; 0
     594:	80 81       	ld	r24, Z
     596:	8f 77       	andi	r24, 0x7F	; 127
     598:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3A0);
     59a:	80 81       	ld	r24, Z
     59c:	8f 7b       	andi	r24, 0xBF	; 191
     59e:	80 83       	st	Z, r24
}
     5a0:	08 95       	ret

000005a2 <PWM_timer3_Off_E4>:
void PWM_timer3_Off_E4(void)
{
	cbi(TCCR3A,COM3B1);
     5a2:	e0 e9       	ldi	r30, 0x90	; 144
     5a4:	f0 e0       	ldi	r31, 0x00	; 0
     5a6:	80 81       	ld	r24, Z
     5a8:	8f 7d       	andi	r24, 0xDF	; 223
     5aa:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3B0);
     5ac:	80 81       	ld	r24, Z
     5ae:	8f 7e       	andi	r24, 0xEF	; 239
     5b0:	80 83       	st	Z, r24
}
     5b2:	08 95       	ret

000005b4 <PWM_timer3_Off_E5>:
void PWM_timer3_Off_E5(void)
{
	cbi(TCCR3A,COM3C1);
     5b4:	e0 e9       	ldi	r30, 0x90	; 144
     5b6:	f0 e0       	ldi	r31, 0x00	; 0
     5b8:	80 81       	ld	r24, Z
     5ba:	87 7f       	andi	r24, 0xF7	; 247
     5bc:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C0);
     5be:	80 81       	ld	r24, Z
     5c0:	8b 7f       	andi	r24, 0xFB	; 251
     5c2:	80 83       	st	Z, r24
}
     5c4:	08 95       	ret

000005c6 <PWM_timer4_Off_H3>:
void PWM_timer4_Off_H3(void)
{
	cbi(TCCR4A,COM4A1);
     5c6:	e0 ea       	ldi	r30, 0xA0	; 160
     5c8:	f0 e0       	ldi	r31, 0x00	; 0
     5ca:	80 81       	ld	r24, Z
     5cc:	8f 77       	andi	r24, 0x7F	; 127
     5ce:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4A0);
     5d0:	80 81       	ld	r24, Z
     5d2:	8f 7b       	andi	r24, 0xBF	; 191
     5d4:	80 83       	st	Z, r24
}
     5d6:	08 95       	ret

000005d8 <PWM_timer4_Off_H4>:
void PWM_timer4_Off_H4(void)
{
	cbi(TCCR4A,COM4B1);
     5d8:	e0 ea       	ldi	r30, 0xA0	; 160
     5da:	f0 e0       	ldi	r31, 0x00	; 0
     5dc:	80 81       	ld	r24, Z
     5de:	8f 7d       	andi	r24, 0xDF	; 223
     5e0:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4B0);
     5e2:	80 81       	ld	r24, Z
     5e4:	8f 7e       	andi	r24, 0xEF	; 239
     5e6:	80 83       	st	Z, r24
}
     5e8:	08 95       	ret

000005ea <PWM_timer4_Off_H5>:
void PWM_timer4_Off_H5(void)
{
	cbi(TCCR4A,COM4C1);
     5ea:	e0 ea       	ldi	r30, 0xA0	; 160
     5ec:	f0 e0       	ldi	r31, 0x00	; 0
     5ee:	80 81       	ld	r24, Z
     5f0:	87 7f       	andi	r24, 0xF7	; 247
     5f2:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4C0);
     5f4:	80 81       	ld	r24, Z
     5f6:	8b 7f       	andi	r24, 0xFB	; 251
     5f8:	80 83       	st	Z, r24
}
     5fa:	08 95       	ret

000005fc <PWM_timer1_Off_All>:


void PWM_timer1_Off_All(void)
{
	cbi(TCCR1A,PWM11);
     5fc:	e0 e8       	ldi	r30, 0x80	; 128
     5fe:	f0 e0       	ldi	r31, 0x00	; 0
     600:	80 81       	ld	r24, Z
     602:	8d 7f       	andi	r24, 0xFD	; 253
     604:	80 83       	st	Z, r24
	cbi(TCCR1A,PWM10);
     606:	80 81       	ld	r24, Z
     608:	8e 7f       	andi	r24, 0xFE	; 254
     60a:	80 83       	st	Z, r24
}

//off commands
void PWM_timer1_Off_LED(void)
{
	cbi(TCCR1A,COM1B1);
     60c:	80 81       	ld	r24, Z
     60e:	8f 7d       	andi	r24, 0xDF	; 223
     610:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B0);
     612:	80 81       	ld	r24, Z
     614:	8f 7e       	andi	r24, 0xEF	; 239
     616:	80 83       	st	Z, r24
	cbi(TCCR1A,PWM11);
	cbi(TCCR1A,PWM10);
	//timer2PWMAOff();
	PWM_timer1_Off_LED();
	//timer2PWMCOff();
}
     618:	08 95       	ret

0000061a <PWM_timer2_Off_All>:
void PWM_timer2_Off_All(void)
{
	cbi(TCCR2A,PWM11);
     61a:	e0 eb       	ldi	r30, 0xB0	; 176
     61c:	f0 e0       	ldi	r31, 0x00	; 0
     61e:	80 81       	ld	r24, Z
     620:	8d 7f       	andi	r24, 0xFD	; 253
     622:	80 83       	st	Z, r24
	cbi(TCCR2A,PWM10);
     624:	80 81       	ld	r24, Z
     626:	8e 7f       	andi	r24, 0xFE	; 254
     628:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B1);
	cbi(TCCR1A,COM1B0);
}
void PWM_timer2_Off_H6(void)
{
	cbi(TCCR2A,COM2B1);
     62a:	80 81       	ld	r24, Z
     62c:	8f 7d       	andi	r24, 0xDF	; 223
     62e:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B0);
     630:	80 81       	ld	r24, Z
     632:	8f 7e       	andi	r24, 0xEF	; 239
     634:	80 83       	st	Z, r24
	cbi(TCCR2A,PWM11);
	cbi(TCCR2A,PWM10);
	//timer2PWMAOff();
	PWM_timer2_Off_H6();
	//timer2PWMCOff();
}
     636:	08 95       	ret

00000638 <PWM_timer3_Off_All>:
void PWM_timer3_Off_All(void)
{
	cbi(TCCR3A,PWM11);
     638:	e0 e9       	ldi	r30, 0x90	; 144
     63a:	f0 e0       	ldi	r31, 0x00	; 0
     63c:	80 81       	ld	r24, Z
     63e:	8d 7f       	andi	r24, 0xFD	; 253
     640:	80 83       	st	Z, r24
	cbi(TCCR3A,PWM10);
     642:	80 81       	ld	r24, Z
     644:	8e 7f       	andi	r24, 0xFE	; 254
     646:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B1);
	cbi(TCCR2A,COM2B0);
}
void PWM_timer3_Off_E3(void)
{
	cbi(TCCR3A,COM3A1);
     648:	80 81       	ld	r24, Z
     64a:	8f 77       	andi	r24, 0x7F	; 127
     64c:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3A0);
     64e:	80 81       	ld	r24, Z
     650:	8f 7b       	andi	r24, 0xBF	; 191
     652:	80 83       	st	Z, r24
}
void PWM_timer3_Off_E4(void)
{
	cbi(TCCR3A,COM3B1);
     654:	80 81       	ld	r24, Z
     656:	8f 7d       	andi	r24, 0xDF	; 223
     658:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3B0);
     65a:	80 81       	ld	r24, Z
     65c:	8f 7e       	andi	r24, 0xEF	; 239
     65e:	80 83       	st	Z, r24
}
void PWM_timer3_Off_E5(void)
{
	cbi(TCCR3A,COM3C1);
     660:	80 81       	ld	r24, Z
     662:	87 7f       	andi	r24, 0xF7	; 247
     664:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C0);
     666:	80 81       	ld	r24, Z
     668:	8b 7f       	andi	r24, 0xFB	; 251
     66a:	80 83       	st	Z, r24
	//timer2PWMAOff();
	PWM_timer3_Off_E3();
	PWM_timer3_Off_E4();
	PWM_timer3_Off_E5();
	//timer2PWMCOff();
}
     66c:	08 95       	ret

0000066e <PWM_timer4_Off_All>:
void PWM_timer4_Off_All(void)
{
	cbi(TCCR4A,PWM11);
     66e:	e0 ea       	ldi	r30, 0xA0	; 160
     670:	f0 e0       	ldi	r31, 0x00	; 0
     672:	80 81       	ld	r24, Z
     674:	8d 7f       	andi	r24, 0xFD	; 253
     676:	80 83       	st	Z, r24
	cbi(TCCR4A,PWM10);
     678:	80 81       	ld	r24, Z
     67a:	8e 7f       	andi	r24, 0xFE	; 254
     67c:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C1);
	cbi(TCCR3A,COM3C0);
}
void PWM_timer4_Off_H3(void)
{
	cbi(TCCR4A,COM4A1);
     67e:	80 81       	ld	r24, Z
     680:	8f 77       	andi	r24, 0x7F	; 127
     682:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4A0);
     684:	80 81       	ld	r24, Z
     686:	8f 7b       	andi	r24, 0xBF	; 191
     688:	80 83       	st	Z, r24
}
void PWM_timer4_Off_H4(void)
{
	cbi(TCCR4A,COM4B1);
     68a:	80 81       	ld	r24, Z
     68c:	8f 7d       	andi	r24, 0xDF	; 223
     68e:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4B0);
     690:	80 81       	ld	r24, Z
     692:	8f 7e       	andi	r24, 0xEF	; 239
     694:	80 83       	st	Z, r24
}
void PWM_timer4_Off_H5(void)
{
	cbi(TCCR4A,COM4C1);
     696:	80 81       	ld	r24, Z
     698:	87 7f       	andi	r24, 0xF7	; 247
     69a:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4C0);
     69c:	80 81       	ld	r24, Z
     69e:	8b 7f       	andi	r24, 0xFB	; 251
     6a0:	80 83       	st	Z, r24
	//timer2PWMAOff();
	PWM_timer4_Off_H3();
	PWM_timer4_Off_H4();
	PWM_timer4_Off_H5();
	//timer2PWMCOff();
}
     6a2:	08 95       	ret

000006a4 <PWM_timer1_Set_LED>:
// this PWM output is generated on OC2B pin
// NOTE:	pwmDuty should be in the range 0-255 for 8bit PWM
//			pwmDuty should be in the range 0-511 for 9bit PWM
//			pwmDuty should be in the range 0-1023 for 10bit PWM
void PWM_timer1_Set_LED(u16 pwmDuty)
	{OCR1B = pwmDuty;}
     6a4:	90 93 8b 00 	sts	0x008B, r25
     6a8:	80 93 8a 00 	sts	0x008A, r24
     6ac:	08 95       	ret

000006ae <PWM_timer2_Set_H6>:
void PWM_timer2_Set_H6(u16 pwmDuty)
	{OCR2B = pwmDuty;}
     6ae:	80 93 b4 00 	sts	0x00B4, r24
     6b2:	08 95       	ret

000006b4 <PWM_timer3_Set_E3>:
void PWM_timer3_Set_E3(u16 pwmDuty)
	{OCR3A = pwmDuty;}
     6b4:	90 93 99 00 	sts	0x0099, r25
     6b8:	80 93 98 00 	sts	0x0098, r24
     6bc:	08 95       	ret

000006be <PWM_timer3_Set_E4>:
void PWM_timer3_Set_E4(u16 pwmDuty)
	{OCR3B = pwmDuty;}
     6be:	90 93 9b 00 	sts	0x009B, r25
     6c2:	80 93 9a 00 	sts	0x009A, r24
     6c6:	08 95       	ret

000006c8 <PWM_timer3_Set_E5>:
void PWM_timer3_Set_E5(u16 pwmDuty)
	{OCR3C = pwmDuty;}
     6c8:	90 93 9d 00 	sts	0x009D, r25
     6cc:	80 93 9c 00 	sts	0x009C, r24
     6d0:	08 95       	ret

000006d2 <PWM_timer4_Set_H3>:
void PWM_timer4_Set_H3(u16 pwmDuty)
	{OCR4A = pwmDuty;}
     6d2:	90 93 a9 00 	sts	0x00A9, r25
     6d6:	80 93 a8 00 	sts	0x00A8, r24
     6da:	08 95       	ret

000006dc <PWM_timer4_Set_H4>:
void PWM_timer4_Set_H4(u16 pwmDuty)
	{OCR4B = pwmDuty;}
     6dc:	90 93 ab 00 	sts	0x00AB, r25
     6e0:	80 93 aa 00 	sts	0x00AA, r24
     6e4:	08 95       	ret

000006e6 <PWM_timer4_Set_H5>:
void PWM_timer4_Set_H5(u16 pwmDuty)
	{OCR4C = pwmDuty;}
     6e6:	90 93 ad 00 	sts	0x00AD, r25
     6ea:	80 93 ac 00 	sts	0x00AC, r24
     6ee:	08 95       	ret

000006f0 <configure_ports>:
	//cbi(DDRG, PG5);  //set G5 as input pin

	//ANALOG PORTS
	//useful for sensors, SharpIR, photoresistors, etc.
	//analog ports can be configured as digital ports if desired
	DDRF = 0b00000000;  //configure all F ports for input				0x00
     6f0:	10 ba       	out	0x10, r1	; 16
	PORTF = 0b00000000; //make sure pull-up resistors are turned off	0x00
     6f2:	11 ba       	out	0x11, r1	; 17
	DDRK = 0b00000000;  //configure all K ports for input				0x00
     6f4:	10 92 07 01 	sts	0x0107, r1
	PORTK = 0b00000000; //make sure pull-up resistors are turned off	0x00
     6f8:	10 92 08 01 	sts	0x0108, r1

	//DIGITAL PORTS
	//useful for servos, PWM, LED's, UART, interrupts, timers
	DDRA = 0b11111111;  //configure ports for output
     6fc:	9f ef       	ldi	r25, 0xFF	; 255
     6fe:	91 b9       	out	0x01, r25	; 1
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	//PORTB reserved for programmer (use programmer pins if you know what you are doing)
	DDRB = _BV (PB6);	//PB6 is LED, hold low to turn it on
     700:	80 e4       	ldi	r24, 0x40	; 64
     702:	84 b9       	out	0x04, r24	; 4
	DDRC = 0b11111111;  //configure ports for output
     704:	97 b9       	out	0x07, r25	; 7
	//       ||||\______3: 
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 	
	sbi(PORTD, PD0); // SCL pull-up
     706:	58 9a       	sbi	0x0b, 0	; 11
	sbi(PORTD, PD1); // SDA pull-up
     708:	59 9a       	sbi	0x0b, 1	; 11
	DDRD = 0b11110011;  //configure ports for output
     70a:	83 ef       	ldi	r24, 0xF3	; 243
     70c:	8a b9       	out	0x0a, r24	; 10
	//       ||||\______3: serial TXD1, output -> 1
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: timer0
	DDRE = 0b11111110;  //configure ports for output
     70e:	8e ef       	ldi	r24, 0xFE	; 254
     710:	8d b9       	out	0x0d, r24	; 13
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	//cbi(PORTG, PG5);  // disable pull-up resistor for Axon v1e and earlier
	sbi(PORTG, PG5);  // enable pull-up resistor for v1f and later
     712:	a5 9a       	sbi	0x14, 5	; 20
	cbi(DDRG, PG5);	//PG5 is for the button, make a digital input
     714:	9d 98       	cbi	0x13, 5	; 19
	//note that button actions are inverted between both versions!!!
	DDRH = 0b11111110;  //configure ports for output
     716:	80 93 01 01 	sts	0x0101, r24
	//       ||||\______3: 
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	DDRJ = 0b11111110;  //configure ports for output
     71a:	80 93 04 01 	sts	0x0104, r24
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	//PORTL has no headers
	};
     71e:	08 95       	ret

00000720 <delay_cycles>:
void delay_cycles(unsigned long int cycles)
	{
	cycles=cycles;//doubled frequency but too lazy to change times
	while(cycles > 0)
		cycles--;
	}
     720:	08 95       	ret

00000722 <LED_off>:


//***************STATUS LED**************
//tank test
void LED_off(void)
	{PORT_ON(PORTB,6);}
     722:	2e 9a       	sbi	0x05, 6	; 5
     724:	08 95       	ret

00000726 <LED_on>:
void LED_on(void)
	{PORT_OFF(PORTB,6);}
     726:	2e 98       	cbi	0x05, 6	; 5
     728:	08 95       	ret

0000072a <button_pressed>:


//*****************BUTTON****************
int button_pressed(void)
	{
	return (bit_is_clear(PING, 5));
     72a:	22 b3       	in	r18, 0x12	; 18
     72c:	30 e0       	ldi	r19, 0x00	; 0
     72e:	85 e0       	ldi	r24, 0x05	; 5
     730:	36 95       	lsr	r19
     732:	27 95       	ror	r18
     734:	8a 95       	dec	r24
     736:	e1 f7       	brne	.-8      	; 0x730 <button_pressed+0x6>
     738:	20 95       	com	r18
     73a:	30 95       	com	r19
     73c:	21 70       	andi	r18, 0x01	; 1
     73e:	30 70       	andi	r19, 0x00	; 0
	//return ((PING) & (1<<PG5));//old version, went high when button pushed
	}
     740:	c9 01       	movw	r24, r18
     742:	08 95       	ret

00000744 <cos_SoR>:
signed int angtable[73]={100,100,98,97,94,91,87,82,77,71,64,57,50,42,34,26,17,9,0,-9,-17,-26,-34,-42,-50,-57,-64,-71,-77,-82,-87,-91,-94,-97,-98,-100,
						 -100,-100,-98,-97,-94,-91,-87,-82,-77,-71,-64,-57,-50,-42,-34,-26,-17,-9,0,9,17,26,34,42,50,57,64,71,77,82,87,91,94,97,98,100,100};

signed int cos_SoR(long signed int degrees)//returns cos*100
	{
	if (degrees >= 0)//positive angles
     744:	97 fd       	sbrc	r25, 7
     746:	10 c0       	rjmp	.+32     	; 0x768 <cos_SoR+0x24>
		return angtable[degrees/5];
     748:	25 e0       	ldi	r18, 0x05	; 5
     74a:	30 e0       	ldi	r19, 0x00	; 0
     74c:	40 e0       	ldi	r20, 0x00	; 0
     74e:	50 e0       	ldi	r21, 0x00	; 0
     750:	0e 94 42 30 	call	0x6084	; 0x6084 <__divmodsi4>
     754:	da 01       	movw	r26, r20
     756:	c9 01       	movw	r24, r18
     758:	88 0f       	add	r24, r24
     75a:	99 1f       	adc	r25, r25
     75c:	8d 5e       	subi	r24, 0xED	; 237
     75e:	9d 4f       	sbci	r25, 0xFD	; 253
     760:	fc 01       	movw	r30, r24
     762:	20 81       	ld	r18, Z
     764:	31 81       	ldd	r19, Z+1	; 0x01
     766:	17 c0       	rjmp	.+46     	; 0x796 <cos_SoR+0x52>
	else
		return -angtable[72-(-degrees)/5];
     768:	25 e0       	ldi	r18, 0x05	; 5
     76a:	30 e0       	ldi	r19, 0x00	; 0
     76c:	40 e0       	ldi	r20, 0x00	; 0
     76e:	50 e0       	ldi	r21, 0x00	; 0
     770:	0e 94 42 30 	call	0x6084	; 0x6084 <__divmodsi4>
     774:	da 01       	movw	r26, r20
     776:	c9 01       	movw	r24, r18
     778:	88 5b       	subi	r24, 0xB8	; 184
     77a:	9f 4f       	sbci	r25, 0xFF	; 255
     77c:	af 4f       	sbci	r26, 0xFF	; 255
     77e:	bf 4f       	sbci	r27, 0xFF	; 255
     780:	88 0f       	add	r24, r24
     782:	99 1f       	adc	r25, r25
     784:	8d 5e       	subi	r24, 0xED	; 237
     786:	9d 4f       	sbci	r25, 0xFD	; 253
     788:	fc 01       	movw	r30, r24
     78a:	80 81       	ld	r24, Z
     78c:	91 81       	ldd	r25, Z+1	; 0x01
     78e:	22 27       	eor	r18, r18
     790:	33 27       	eor	r19, r19
     792:	28 1b       	sub	r18, r24
     794:	39 0b       	sbc	r19, r25
	}
     796:	c9 01       	movw	r24, r18
     798:	08 95       	ret

0000079a <sin_SoR>:

signed int sin_SoR(long signed int degrees)//returns sin*100
	{
	degrees=degrees - 90;//phase shift 90 degrees
     79a:	6a 55       	subi	r22, 0x5A	; 90
     79c:	70 40       	sbci	r23, 0x00	; 0
     79e:	80 40       	sbci	r24, 0x00	; 0
     7a0:	90 40       	sbci	r25, 0x00	; 0

	if (degrees >= 0)//positive angles
     7a2:	97 fd       	sbrc	r25, 7
     7a4:	10 c0       	rjmp	.+32     	; 0x7c6 <sin_SoR+0x2c>
		return angtable[degrees/5];
     7a6:	25 e0       	ldi	r18, 0x05	; 5
     7a8:	30 e0       	ldi	r19, 0x00	; 0
     7aa:	40 e0       	ldi	r20, 0x00	; 0
     7ac:	50 e0       	ldi	r21, 0x00	; 0
     7ae:	0e 94 42 30 	call	0x6084	; 0x6084 <__divmodsi4>
     7b2:	da 01       	movw	r26, r20
     7b4:	c9 01       	movw	r24, r18
     7b6:	88 0f       	add	r24, r24
     7b8:	99 1f       	adc	r25, r25
     7ba:	8d 5e       	subi	r24, 0xED	; 237
     7bc:	9d 4f       	sbci	r25, 0xFD	; 253
     7be:	fc 01       	movw	r30, r24
     7c0:	20 81       	ld	r18, Z
     7c2:	31 81       	ldd	r19, Z+1	; 0x01
     7c4:	17 c0       	rjmp	.+46     	; 0x7f4 <sin_SoR+0x5a>
	else
		return -angtable[72-(-degrees)/5];
     7c6:	25 e0       	ldi	r18, 0x05	; 5
     7c8:	30 e0       	ldi	r19, 0x00	; 0
     7ca:	40 e0       	ldi	r20, 0x00	; 0
     7cc:	50 e0       	ldi	r21, 0x00	; 0
     7ce:	0e 94 42 30 	call	0x6084	; 0x6084 <__divmodsi4>
     7d2:	da 01       	movw	r26, r20
     7d4:	c9 01       	movw	r24, r18
     7d6:	88 5b       	subi	r24, 0xB8	; 184
     7d8:	9f 4f       	sbci	r25, 0xFF	; 255
     7da:	af 4f       	sbci	r26, 0xFF	; 255
     7dc:	bf 4f       	sbci	r27, 0xFF	; 255
     7de:	88 0f       	add	r24, r24
     7e0:	99 1f       	adc	r25, r25
     7e2:	8d 5e       	subi	r24, 0xED	; 237
     7e4:	9d 4f       	sbci	r25, 0xFD	; 253
     7e6:	fc 01       	movw	r30, r24
     7e8:	80 81       	ld	r24, Z
     7ea:	91 81       	ldd	r25, Z+1	; 0x01
     7ec:	22 27       	eor	r18, r18
     7ee:	33 27       	eor	r19, r19
     7f0:	28 1b       	sub	r18, r24
     7f2:	39 0b       	sbc	r19, r25
	}
     7f4:	c9 01       	movw	r24, r18
     7f6:	08 95       	ret

000007f8 <tan_SoR>:

signed int tan_SoR(long signed int degrees)//returns tan * 10
	{
     7f8:	cf 92       	push	r12
     7fa:	df 92       	push	r13
     7fc:	ef 92       	push	r14
     7fe:	ff 92       	push	r15
     800:	0f 93       	push	r16
     802:	1f 93       	push	r17
     804:	6b 01       	movw	r12, r22
     806:	7c 01       	movw	r14, r24
	//tan(x) = sin(x)/cos(x)
	if (degrees == 90 || degrees == -90 || degrees == 270 || degrees == -270)//blows up
     808:	8a e5       	ldi	r24, 0x5A	; 90
     80a:	c8 16       	cp	r12, r24
     80c:	d1 04       	cpc	r13, r1
     80e:	e1 04       	cpc	r14, r1
     810:	f1 04       	cpc	r15, r1
     812:	a1 f1       	breq	.+104    	; 0x87c <tan_SoR+0x84>
     814:	86 ea       	ldi	r24, 0xA6	; 166
     816:	c8 16       	cp	r12, r24
     818:	8f ef       	ldi	r24, 0xFF	; 255
     81a:	d8 06       	cpc	r13, r24
     81c:	8f ef       	ldi	r24, 0xFF	; 255
     81e:	e8 06       	cpc	r14, r24
     820:	8f ef       	ldi	r24, 0xFF	; 255
     822:	f8 06       	cpc	r15, r24
     824:	59 f1       	breq	.+86     	; 0x87c <tan_SoR+0x84>
     826:	8e e0       	ldi	r24, 0x0E	; 14
     828:	c8 16       	cp	r12, r24
     82a:	81 e0       	ldi	r24, 0x01	; 1
     82c:	d8 06       	cpc	r13, r24
     82e:	80 e0       	ldi	r24, 0x00	; 0
     830:	e8 06       	cpc	r14, r24
     832:	80 e0       	ldi	r24, 0x00	; 0
     834:	f8 06       	cpc	r15, r24
     836:	11 f1       	breq	.+68     	; 0x87c <tan_SoR+0x84>
     838:	82 ef       	ldi	r24, 0xF2	; 242
     83a:	c8 16       	cp	r12, r24
     83c:	8e ef       	ldi	r24, 0xFE	; 254
     83e:	d8 06       	cpc	r13, r24
     840:	8f ef       	ldi	r24, 0xFF	; 255
     842:	e8 06       	cpc	r14, r24
     844:	8f ef       	ldi	r24, 0xFF	; 255
     846:	f8 06       	cpc	r15, r24
     848:	c9 f0       	breq	.+50     	; 0x87c <tan_SoR+0x84>
		return 0;//what else should I return?!?!?
	return sin_SoR(degrees)/cos_SoR(degrees)*10;
     84a:	c7 01       	movw	r24, r14
     84c:	b6 01       	movw	r22, r12
     84e:	0e 94 cd 03 	call	0x79a	; 0x79a <sin_SoR>
     852:	8c 01       	movw	r16, r24
     854:	c7 01       	movw	r24, r14
     856:	b6 01       	movw	r22, r12
     858:	0e 94 a2 03 	call	0x744	; 0x744 <cos_SoR>
     85c:	bc 01       	movw	r22, r24
     85e:	c8 01       	movw	r24, r16
     860:	0e 94 0d 30 	call	0x601a	; 0x601a <__divmodhi4>
     864:	cb 01       	movw	r24, r22
     866:	9b 01       	movw	r18, r22
     868:	73 e0       	ldi	r23, 0x03	; 3
     86a:	22 0f       	add	r18, r18
     86c:	33 1f       	adc	r19, r19
     86e:	7a 95       	dec	r23
     870:	e1 f7       	brne	.-8      	; 0x86a <tan_SoR+0x72>
     872:	88 0f       	add	r24, r24
     874:	99 1f       	adc	r25, r25
     876:	28 0f       	add	r18, r24
     878:	39 1f       	adc	r19, r25
     87a:	02 c0       	rjmp	.+4      	; 0x880 <tan_SoR+0x88>
     87c:	20 e0       	ldi	r18, 0x00	; 0
     87e:	30 e0       	ldi	r19, 0x00	; 0
	}
     880:	c9 01       	movw	r24, r18
     882:	1f 91       	pop	r17
     884:	0f 91       	pop	r16
     886:	ff 90       	pop	r15
     888:	ef 90       	pop	r14
     88a:	df 90       	pop	r13
     88c:	cf 90       	pop	r12
     88e:	08 95       	ret

00000890 <prvPWMSetup>:
//-----------------------------**&&**


void prvPWMSetup(){

	PWM_Init_timer3_E4(10); // Left wheel
     890:	8a e0       	ldi	r24, 0x0A	; 10
     892:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <PWM_Init_timer3_E4>
	PWM_Init_timer3_E3(10); // Right wheel
     896:	8a e0       	ldi	r24, 0x0A	; 10
     898:	0e 94 4b 01 	call	0x296	; 0x296 <PWM_Init_timer3_E3>
	PWM_Init_timer4_H3(10);	// Left sprayer
     89c:	8a e0       	ldi	r24, 0x0A	; 10
     89e:	0e 94 ab 01 	call	0x356	; 0x356 <PWM_Init_timer4_H3>
	PWM_Init_timer4_H4(10);	// Right sprayer
     8a2:	8a e0       	ldi	r24, 0x0A	; 10
     8a4:	0e 94 cb 01 	call	0x396	; 0x396 <PWM_Init_timer4_H4>

}
     8a8:	08 95       	ret

000008aa <char2hex>:

char char2hex(char c){
     8aa:	98 2f       	mov	r25, r24
	
	if((c > 47) && (c <58)){
     8ac:	80 53       	subi	r24, 0x30	; 48
     8ae:	8a 30       	cpi	r24, 0x0A	; 10
     8b0:	38 f0       	brcs	.+14     	; 0x8c0 <char2hex+0x16>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     8b2:	81 51       	subi	r24, 0x11	; 17
     8b4:	86 30       	cpi	r24, 0x06	; 6
     8b6:	10 f0       	brcs	.+4      	; 0x8bc <char2hex+0x12>
     8b8:	89 2f       	mov	r24, r25
     8ba:	08 95       	ret
		c -= 55;
     8bc:	89 2f       	mov	r24, r25
     8be:	87 53       	subi	r24, 0x37	; 55
	}
	return c;
}
     8c0:	08 95       	ret

000008c2 <retConv_s16>:

s16 retConv_s16(char* ch_head){
     8c2:	fc 01       	movw	r30, r24

	s16 int_val = 0x0000;
	char iv1 = *(ch_head);
     8c4:	90 81       	ld	r25, Z
	char iv2 = *(ch_head + 1);
     8c6:	21 81       	ldd	r18, Z+1	; 0x01
	char iv3 = *(ch_head + 2);
     8c8:	42 81       	ldd	r20, Z+2	; 0x02
	char iv4 = *(ch_head + 3);
     8ca:	53 81       	ldd	r21, Z+3	; 0x03

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     8cc:	89 2f       	mov	r24, r25
     8ce:	80 53       	subi	r24, 0x30	; 48
     8d0:	8a 30       	cpi	r24, 0x0A	; 10
     8d2:	10 f4       	brcc	.+4      	; 0x8d8 <retConv_s16+0x16>
     8d4:	98 2f       	mov	r25, r24
     8d6:	05 c0       	rjmp	.+10     	; 0x8e2 <retConv_s16+0x20>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     8d8:	89 2f       	mov	r24, r25
     8da:	81 54       	subi	r24, 0x41	; 65
     8dc:	86 30       	cpi	r24, 0x06	; 6
     8de:	08 f4       	brcc	.+2      	; 0x8e2 <retConv_s16+0x20>
		c -= 55;
     8e0:	97 53       	subi	r25, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     8e2:	82 2f       	mov	r24, r18
     8e4:	80 53       	subi	r24, 0x30	; 48
     8e6:	8a 30       	cpi	r24, 0x0A	; 10
     8e8:	10 f4       	brcc	.+4      	; 0x8ee <retConv_s16+0x2c>
     8ea:	28 2f       	mov	r18, r24
     8ec:	05 c0       	rjmp	.+10     	; 0x8f8 <retConv_s16+0x36>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     8ee:	82 2f       	mov	r24, r18
     8f0:	81 54       	subi	r24, 0x41	; 65
     8f2:	86 30       	cpi	r24, 0x06	; 6
     8f4:	08 f4       	brcc	.+2      	; 0x8f8 <retConv_s16+0x36>
		c -= 55;
     8f6:	27 53       	subi	r18, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     8f8:	84 2f       	mov	r24, r20
     8fa:	80 53       	subi	r24, 0x30	; 48
     8fc:	8a 30       	cpi	r24, 0x0A	; 10
     8fe:	10 f4       	brcc	.+4      	; 0x904 <retConv_s16+0x42>
     900:	48 2f       	mov	r20, r24
     902:	05 c0       	rjmp	.+10     	; 0x90e <retConv_s16+0x4c>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     904:	84 2f       	mov	r24, r20
     906:	81 54       	subi	r24, 0x41	; 65
     908:	86 30       	cpi	r24, 0x06	; 6
     90a:	08 f4       	brcc	.+2      	; 0x90e <retConv_s16+0x4c>
		c -= 55;
     90c:	47 53       	subi	r20, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     90e:	85 2f       	mov	r24, r21
     910:	80 53       	subi	r24, 0x30	; 48
     912:	8a 30       	cpi	r24, 0x0A	; 10
     914:	10 f4       	brcc	.+4      	; 0x91a <retConv_s16+0x58>
     916:	58 2f       	mov	r21, r24
     918:	05 c0       	rjmp	.+10     	; 0x924 <retConv_s16+0x62>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     91a:	85 2f       	mov	r24, r21
     91c:	81 54       	subi	r24, 0x41	; 65
     91e:	86 30       	cpi	r24, 0x06	; 6
     920:	08 f4       	brcc	.+2      	; 0x924 <retConv_s16+0x62>
		c -= 55;
     922:	57 53       	subi	r21, 0x37	; 55
	iv2 = char2hex(iv2);
	iv3 = char2hex(iv3);
	iv4 = char2hex(iv4);

	int_val = (int_val | iv1);
	int_val = ((int_val<<4) | iv2);
     924:	30 e0       	ldi	r19, 0x00	; 0
     926:	89 2f       	mov	r24, r25
     928:	90 e0       	ldi	r25, 0x00	; 0
     92a:	a4 e0       	ldi	r26, 0x04	; 4
     92c:	88 0f       	add	r24, r24
     92e:	99 1f       	adc	r25, r25
     930:	aa 95       	dec	r26
     932:	e1 f7       	brne	.-8      	; 0x92c <retConv_s16+0x6a>
     934:	28 2b       	or	r18, r24
     936:	39 2b       	or	r19, r25
	int_val = ((int_val<<4) | iv3);
     938:	f4 e0       	ldi	r31, 0x04	; 4
     93a:	22 0f       	add	r18, r18
     93c:	33 1f       	adc	r19, r19
     93e:	fa 95       	dec	r31
     940:	e1 f7       	brne	.-8      	; 0x93a <retConv_s16+0x78>
     942:	84 2f       	mov	r24, r20
     944:	90 e0       	ldi	r25, 0x00	; 0
     946:	82 2b       	or	r24, r18
     948:	93 2b       	or	r25, r19
	int_val = ((int_val<<4) | iv4);
     94a:	e4 e0       	ldi	r30, 0x04	; 4
     94c:	88 0f       	add	r24, r24
     94e:	99 1f       	adc	r25, r25
     950:	ea 95       	dec	r30
     952:	e1 f7       	brne	.-8      	; 0x94c <retConv_s16+0x8a>
     954:	25 2f       	mov	r18, r21
     956:	30 e0       	ldi	r19, 0x00	; 0
     958:	28 2b       	or	r18, r24
     95a:	39 2b       	or	r19, r25
	return int_val;
}
     95c:	c9 01       	movw	r24, r18
     95e:	08 95       	ret

00000960 <retConv_s32>:

s32 retConv_s32(char* ch_head){
     960:	ff 92       	push	r15
     962:	0f 93       	push	r16
     964:	1f 93       	push	r17
     966:	fc 01       	movw	r30, r24

	s32 int_val = 0x00000000;
	char iv1 = *(ch_head);
     968:	90 81       	ld	r25, Z
	char iv2 = *(ch_head + 1);
     96a:	21 81       	ldd	r18, Z+1	; 0x01
	char iv3 = *(ch_head + 2);
     96c:	62 81       	ldd	r22, Z+2	; 0x02
	char iv4 = *(ch_head + 3);
     96e:	73 81       	ldd	r23, Z+3	; 0x03
	char iv5 = *(ch_head + 4);
     970:	14 81       	ldd	r17, Z+4	; 0x04
	char iv6 = *(ch_head + 5);
     972:	05 81       	ldd	r16, Z+5	; 0x05
	char iv7 = *(ch_head + 6);
     974:	f6 80       	ldd	r15, Z+6	; 0x06
	char iv8 = *(ch_head + 7);
     976:	e7 81       	ldd	r30, Z+7	; 0x07

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     978:	89 2f       	mov	r24, r25
     97a:	80 53       	subi	r24, 0x30	; 48
     97c:	8a 30       	cpi	r24, 0x0A	; 10
     97e:	10 f4       	brcc	.+4      	; 0x984 <retConv_s32+0x24>
     980:	98 2f       	mov	r25, r24
     982:	05 c0       	rjmp	.+10     	; 0x98e <retConv_s32+0x2e>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     984:	89 2f       	mov	r24, r25
     986:	81 54       	subi	r24, 0x41	; 65
     988:	86 30       	cpi	r24, 0x06	; 6
     98a:	08 f4       	brcc	.+2      	; 0x98e <retConv_s32+0x2e>
		c -= 55;
     98c:	97 53       	subi	r25, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     98e:	82 2f       	mov	r24, r18
     990:	80 53       	subi	r24, 0x30	; 48
     992:	8a 30       	cpi	r24, 0x0A	; 10
     994:	10 f4       	brcc	.+4      	; 0x99a <retConv_s32+0x3a>
     996:	28 2f       	mov	r18, r24
     998:	05 c0       	rjmp	.+10     	; 0x9a4 <retConv_s32+0x44>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     99a:	82 2f       	mov	r24, r18
     99c:	81 54       	subi	r24, 0x41	; 65
     99e:	86 30       	cpi	r24, 0x06	; 6
     9a0:	08 f4       	brcc	.+2      	; 0x9a4 <retConv_s32+0x44>
		c -= 55;
     9a2:	27 53       	subi	r18, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     9a4:	86 2f       	mov	r24, r22
     9a6:	80 53       	subi	r24, 0x30	; 48
     9a8:	8a 30       	cpi	r24, 0x0A	; 10
     9aa:	10 f4       	brcc	.+4      	; 0x9b0 <retConv_s32+0x50>
     9ac:	68 2f       	mov	r22, r24
     9ae:	05 c0       	rjmp	.+10     	; 0x9ba <retConv_s32+0x5a>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     9b0:	86 2f       	mov	r24, r22
     9b2:	81 54       	subi	r24, 0x41	; 65
     9b4:	86 30       	cpi	r24, 0x06	; 6
     9b6:	08 f4       	brcc	.+2      	; 0x9ba <retConv_s32+0x5a>
		c -= 55;
     9b8:	67 53       	subi	r22, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     9ba:	87 2f       	mov	r24, r23
     9bc:	80 53       	subi	r24, 0x30	; 48
     9be:	8a 30       	cpi	r24, 0x0A	; 10
     9c0:	10 f4       	brcc	.+4      	; 0x9c6 <retConv_s32+0x66>
     9c2:	78 2f       	mov	r23, r24
     9c4:	05 c0       	rjmp	.+10     	; 0x9d0 <retConv_s32+0x70>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     9c6:	87 2f       	mov	r24, r23
     9c8:	81 54       	subi	r24, 0x41	; 65
     9ca:	86 30       	cpi	r24, 0x06	; 6
     9cc:	08 f4       	brcc	.+2      	; 0x9d0 <retConv_s32+0x70>
		c -= 55;
     9ce:	77 53       	subi	r23, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     9d0:	81 2f       	mov	r24, r17
     9d2:	80 53       	subi	r24, 0x30	; 48
     9d4:	8a 30       	cpi	r24, 0x0A	; 10
     9d6:	10 f4       	brcc	.+4      	; 0x9dc <retConv_s32+0x7c>
     9d8:	18 2f       	mov	r17, r24
     9da:	05 c0       	rjmp	.+10     	; 0x9e6 <retConv_s32+0x86>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     9dc:	81 2f       	mov	r24, r17
     9de:	81 54       	subi	r24, 0x41	; 65
     9e0:	86 30       	cpi	r24, 0x06	; 6
     9e2:	08 f4       	brcc	.+2      	; 0x9e6 <retConv_s32+0x86>
		c -= 55;
     9e4:	17 53       	subi	r17, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     9e6:	80 2f       	mov	r24, r16
     9e8:	80 53       	subi	r24, 0x30	; 48
     9ea:	8a 30       	cpi	r24, 0x0A	; 10
     9ec:	10 f4       	brcc	.+4      	; 0x9f2 <retConv_s32+0x92>
     9ee:	08 2f       	mov	r16, r24
     9f0:	05 c0       	rjmp	.+10     	; 0x9fc <retConv_s32+0x9c>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     9f2:	80 2f       	mov	r24, r16
     9f4:	81 54       	subi	r24, 0x41	; 65
     9f6:	86 30       	cpi	r24, 0x06	; 6
     9f8:	08 f4       	brcc	.+2      	; 0x9fc <retConv_s32+0x9c>
		c -= 55;
     9fa:	07 53       	subi	r16, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     9fc:	8f 2d       	mov	r24, r15
     9fe:	80 53       	subi	r24, 0x30	; 48
     a00:	8a 30       	cpi	r24, 0x0A	; 10
     a02:	10 f4       	brcc	.+4      	; 0xa08 <retConv_s32+0xa8>
     a04:	f8 2e       	mov	r15, r24
     a06:	06 c0       	rjmp	.+12     	; 0xa14 <retConv_s32+0xb4>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     a08:	8f 2d       	mov	r24, r15
     a0a:	81 54       	subi	r24, 0x41	; 65
     a0c:	86 30       	cpi	r24, 0x06	; 6
     a0e:	10 f4       	brcc	.+4      	; 0xa14 <retConv_s32+0xb4>
		c -= 55;
     a10:	89 ec       	ldi	r24, 0xC9	; 201
     a12:	f8 0e       	add	r15, r24

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     a14:	8e 2f       	mov	r24, r30
     a16:	80 53       	subi	r24, 0x30	; 48
     a18:	8a 30       	cpi	r24, 0x0A	; 10
     a1a:	10 f4       	brcc	.+4      	; 0xa20 <retConv_s32+0xc0>
     a1c:	e8 2f       	mov	r30, r24
     a1e:	05 c0       	rjmp	.+10     	; 0xa2a <retConv_s32+0xca>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     a20:	8e 2f       	mov	r24, r30
     a22:	81 54       	subi	r24, 0x41	; 65
     a24:	86 30       	cpi	r24, 0x06	; 6
     a26:	08 f4       	brcc	.+2      	; 0xa2a <retConv_s32+0xca>
		c -= 55;
     a28:	e7 53       	subi	r30, 0x37	; 55
	iv6 = char2hex(iv6);
	iv7 = char2hex(iv7);
	iv8 = char2hex(iv8);

	int_val = (int_val | iv1);
	int_val = ((int_val<<4) | iv2);
     a2a:	30 e0       	ldi	r19, 0x00	; 0
     a2c:	40 e0       	ldi	r20, 0x00	; 0
     a2e:	50 e0       	ldi	r21, 0x00	; 0
     a30:	89 2f       	mov	r24, r25
     a32:	90 e0       	ldi	r25, 0x00	; 0
     a34:	a0 e0       	ldi	r26, 0x00	; 0
     a36:	b0 e0       	ldi	r27, 0x00	; 0
     a38:	f4 e0       	ldi	r31, 0x04	; 4
     a3a:	88 0f       	add	r24, r24
     a3c:	99 1f       	adc	r25, r25
     a3e:	aa 1f       	adc	r26, r26
     a40:	bb 1f       	adc	r27, r27
     a42:	fa 95       	dec	r31
     a44:	d1 f7       	brne	.-12     	; 0xa3a <retConv_s32+0xda>
     a46:	28 2b       	or	r18, r24
     a48:	39 2b       	or	r19, r25
     a4a:	4a 2b       	or	r20, r26
     a4c:	5b 2b       	or	r21, r27
	int_val = ((int_val<<4) | iv3);
     a4e:	a4 e0       	ldi	r26, 0x04	; 4
     a50:	22 0f       	add	r18, r18
     a52:	33 1f       	adc	r19, r19
     a54:	44 1f       	adc	r20, r20
     a56:	55 1f       	adc	r21, r21
     a58:	aa 95       	dec	r26
     a5a:	d1 f7       	brne	.-12     	; 0xa50 <retConv_s32+0xf0>
     a5c:	86 2f       	mov	r24, r22
     a5e:	90 e0       	ldi	r25, 0x00	; 0
     a60:	a0 e0       	ldi	r26, 0x00	; 0
     a62:	b0 e0       	ldi	r27, 0x00	; 0
     a64:	82 2b       	or	r24, r18
     a66:	93 2b       	or	r25, r19
     a68:	a4 2b       	or	r26, r20
     a6a:	b5 2b       	or	r27, r21
	int_val = ((int_val<<4) | iv4);
     a6c:	f4 e0       	ldi	r31, 0x04	; 4
     a6e:	88 0f       	add	r24, r24
     a70:	99 1f       	adc	r25, r25
     a72:	aa 1f       	adc	r26, r26
     a74:	bb 1f       	adc	r27, r27
     a76:	fa 95       	dec	r31
     a78:	d1 f7       	brne	.-12     	; 0xa6e <retConv_s32+0x10e>
     a7a:	27 2f       	mov	r18, r23
     a7c:	30 e0       	ldi	r19, 0x00	; 0
     a7e:	40 e0       	ldi	r20, 0x00	; 0
     a80:	50 e0       	ldi	r21, 0x00	; 0
     a82:	28 2b       	or	r18, r24
     a84:	39 2b       	or	r19, r25
     a86:	4a 2b       	or	r20, r26
     a88:	5b 2b       	or	r21, r27
	int_val = ((int_val<<4) | iv5);
     a8a:	64 e0       	ldi	r22, 0x04	; 4
     a8c:	22 0f       	add	r18, r18
     a8e:	33 1f       	adc	r19, r19
     a90:	44 1f       	adc	r20, r20
     a92:	55 1f       	adc	r21, r21
     a94:	6a 95       	dec	r22
     a96:	d1 f7       	brne	.-12     	; 0xa8c <retConv_s32+0x12c>
     a98:	81 2f       	mov	r24, r17
     a9a:	90 e0       	ldi	r25, 0x00	; 0
     a9c:	a0 e0       	ldi	r26, 0x00	; 0
     a9e:	b0 e0       	ldi	r27, 0x00	; 0
     aa0:	82 2b       	or	r24, r18
     aa2:	93 2b       	or	r25, r19
     aa4:	a4 2b       	or	r26, r20
     aa6:	b5 2b       	or	r27, r21
	int_val = ((int_val<<4) | iv6);
     aa8:	24 e0       	ldi	r18, 0x04	; 4
     aaa:	88 0f       	add	r24, r24
     aac:	99 1f       	adc	r25, r25
     aae:	aa 1f       	adc	r26, r26
     ab0:	bb 1f       	adc	r27, r27
     ab2:	2a 95       	dec	r18
     ab4:	d1 f7       	brne	.-12     	; 0xaaa <retConv_s32+0x14a>
     ab6:	20 2f       	mov	r18, r16
     ab8:	30 e0       	ldi	r19, 0x00	; 0
     aba:	40 e0       	ldi	r20, 0x00	; 0
     abc:	50 e0       	ldi	r21, 0x00	; 0
     abe:	28 2b       	or	r18, r24
     ac0:	39 2b       	or	r19, r25
     ac2:	4a 2b       	or	r20, r26
     ac4:	5b 2b       	or	r21, r27
	int_val = ((int_val<<4) | iv7);
     ac6:	04 e0       	ldi	r16, 0x04	; 4
     ac8:	22 0f       	add	r18, r18
     aca:	33 1f       	adc	r19, r19
     acc:	44 1f       	adc	r20, r20
     ace:	55 1f       	adc	r21, r21
     ad0:	0a 95       	dec	r16
     ad2:	d1 f7       	brne	.-12     	; 0xac8 <retConv_s32+0x168>
     ad4:	8f 2d       	mov	r24, r15
     ad6:	90 e0       	ldi	r25, 0x00	; 0
     ad8:	a0 e0       	ldi	r26, 0x00	; 0
     ada:	b0 e0       	ldi	r27, 0x00	; 0
     adc:	82 2b       	or	r24, r18
     ade:	93 2b       	or	r25, r19
     ae0:	a4 2b       	or	r26, r20
     ae2:	b5 2b       	or	r27, r21
	int_val = ((int_val<<4) | iv8);
     ae4:	14 e0       	ldi	r17, 0x04	; 4
     ae6:	88 0f       	add	r24, r24
     ae8:	99 1f       	adc	r25, r25
     aea:	aa 1f       	adc	r26, r26
     aec:	bb 1f       	adc	r27, r27
     aee:	1a 95       	dec	r17
     af0:	d1 f7       	brne	.-12     	; 0xae6 <retConv_s32+0x186>
     af2:	2e 2f       	mov	r18, r30
     af4:	30 e0       	ldi	r19, 0x00	; 0
     af6:	40 e0       	ldi	r20, 0x00	; 0
     af8:	50 e0       	ldi	r21, 0x00	; 0
     afa:	28 2b       	or	r18, r24
     afc:	39 2b       	or	r19, r25
     afe:	4a 2b       	or	r20, r26
     b00:	5b 2b       	or	r21, r27
	return int_val;
}
     b02:	b9 01       	movw	r22, r18
     b04:	ca 01       	movw	r24, r20
     b06:	1f 91       	pop	r17
     b08:	0f 91       	pop	r16
     b0a:	ff 90       	pop	r15
     b0c:	08 95       	ret

00000b0e <wheel_L>:
}

/*************************************************/


void wheel_L(float cmd_vel){
     b0e:	ef 92       	push	r14
     b10:	ff 92       	push	r15
     b12:	0f 93       	push	r16
     b14:	1f 93       	push	r17
     b16:	7b 01       	movw	r14, r22
     b18:	8c 01       	movw	r16, r24
		if(cmd_vel > 36){cmd_vel = 36;}
     b1a:	20 e0       	ldi	r18, 0x00	; 0
     b1c:	30 e0       	ldi	r19, 0x00	; 0
     b1e:	40 e1       	ldi	r20, 0x10	; 16
     b20:	52 e4       	ldi	r21, 0x42	; 66
     b22:	0e 94 73 2f 	call	0x5ee6	; 0x5ee6 <__gesf2>
     b26:	18 16       	cp	r1, r24
     b28:	5c f4       	brge	.+22     	; 0xb40 <wheel_L+0x32>
     b2a:	0f 2e       	mov	r0, r31
     b2c:	f0 e0       	ldi	r31, 0x00	; 0
     b2e:	ef 2e       	mov	r14, r31
     b30:	f0 e0       	ldi	r31, 0x00	; 0
     b32:	ff 2e       	mov	r15, r31
     b34:	f0 e1       	ldi	r31, 0x10	; 16
     b36:	0f 2f       	mov	r16, r31
     b38:	f2 e4       	ldi	r31, 0x42	; 66
     b3a:	1f 2f       	mov	r17, r31
     b3c:	f0 2d       	mov	r31, r0
     b3e:	14 c0       	rjmp	.+40     	; 0xb68 <wheel_L+0x5a>
		if(cmd_vel < -36){cmd_vel = -36;}
     b40:	c8 01       	movw	r24, r16
     b42:	b7 01       	movw	r22, r14
     b44:	20 e0       	ldi	r18, 0x00	; 0
     b46:	30 e0       	ldi	r19, 0x00	; 0
     b48:	40 e1       	ldi	r20, 0x10	; 16
     b4a:	52 ec       	ldi	r21, 0xC2	; 194
     b4c:	0e 94 24 2e 	call	0x5c48	; 0x5c48 <__cmpsf2>
     b50:	88 23       	and	r24, r24
     b52:	54 f4       	brge	.+20     	; 0xb68 <wheel_L+0x5a>
     b54:	0f 2e       	mov	r0, r31
     b56:	f0 e0       	ldi	r31, 0x00	; 0
     b58:	ef 2e       	mov	r14, r31
     b5a:	f0 e0       	ldi	r31, 0x00	; 0
     b5c:	ff 2e       	mov	r15, r31
     b5e:	f0 e1       	ldi	r31, 0x10	; 16
     b60:	0f 2f       	mov	r16, r31
     b62:	f2 ec       	ldi	r31, 0xC2	; 194
     b64:	1f 2f       	mov	r17, r31
     b66:	f0 2d       	mov	r31, r0
		
		float s_out = -0.4928 * (cmd_vel) + 185.27;
		
		taskENTER_CRITICAL();
     b68:	0f b6       	in	r0, 0x3f	; 63
     b6a:	f8 94       	cli
     b6c:	0f 92       	push	r0
		PWM_timer3_Set_E4((int)s_out);
     b6e:	c8 01       	movw	r24, r16
     b70:	b7 01       	movw	r22, r14
     b72:	28 e4       	ldi	r18, 0x48	; 72
     b74:	30 e5       	ldi	r19, 0x50	; 80
     b76:	4c ef       	ldi	r20, 0xFC	; 252
     b78:	5e eb       	ldi	r21, 0xBE	; 190
     b7a:	0e 94 77 2f 	call	0x5eee	; 0x5eee <__mulsf3>
     b7e:	2f e1       	ldi	r18, 0x1F	; 31
     b80:	35 e4       	ldi	r19, 0x45	; 69
     b82:	49 e3       	ldi	r20, 0x39	; 57
     b84:	53 e4       	ldi	r21, 0x43	; 67
     b86:	0e 94 c0 2d 	call	0x5b80	; 0x5b80 <__addsf3>
     b8a:	0e 94 90 2e 	call	0x5d20	; 0x5d20 <__fixsfsi>
void PWM_timer2_Set_H6(u16 pwmDuty)
	{OCR2B = pwmDuty;}
void PWM_timer3_Set_E3(u16 pwmDuty)
	{OCR3A = pwmDuty;}
void PWM_timer3_Set_E4(u16 pwmDuty)
	{OCR3B = pwmDuty;}
     b8e:	70 93 9b 00 	sts	0x009B, r23
     b92:	60 93 9a 00 	sts	0x009A, r22
		taskEXIT_CRITICAL();
     b96:	0f 90       	pop	r0
     b98:	0f be       	out	0x3f, r0	; 63


}
     b9a:	1f 91       	pop	r17
     b9c:	0f 91       	pop	r16
     b9e:	ff 90       	pop	r15
     ba0:	ef 90       	pop	r14
     ba2:	08 95       	ret

00000ba4 <wheel_R>:

void wheel_R(float cmd_vel){
     ba4:	ef 92       	push	r14
     ba6:	ff 92       	push	r15
     ba8:	0f 93       	push	r16
     baa:	1f 93       	push	r17
     bac:	7b 01       	movw	r14, r22
     bae:	8c 01       	movw	r16, r24
		if(cmd_vel > 36){cmd_vel = 36;}
     bb0:	20 e0       	ldi	r18, 0x00	; 0
     bb2:	30 e0       	ldi	r19, 0x00	; 0
     bb4:	40 e1       	ldi	r20, 0x10	; 16
     bb6:	52 e4       	ldi	r21, 0x42	; 66
     bb8:	0e 94 73 2f 	call	0x5ee6	; 0x5ee6 <__gesf2>
     bbc:	18 16       	cp	r1, r24
     bbe:	5c f4       	brge	.+22     	; 0xbd6 <wheel_R+0x32>
     bc0:	0f 2e       	mov	r0, r31
     bc2:	f0 e0       	ldi	r31, 0x00	; 0
     bc4:	ef 2e       	mov	r14, r31
     bc6:	f0 e0       	ldi	r31, 0x00	; 0
     bc8:	ff 2e       	mov	r15, r31
     bca:	f0 e1       	ldi	r31, 0x10	; 16
     bcc:	0f 2f       	mov	r16, r31
     bce:	f2 e4       	ldi	r31, 0x42	; 66
     bd0:	1f 2f       	mov	r17, r31
     bd2:	f0 2d       	mov	r31, r0
     bd4:	14 c0       	rjmp	.+40     	; 0xbfe <wheel_R+0x5a>
		if(cmd_vel < -36){cmd_vel = -36;}
     bd6:	c8 01       	movw	r24, r16
     bd8:	b7 01       	movw	r22, r14
     bda:	20 e0       	ldi	r18, 0x00	; 0
     bdc:	30 e0       	ldi	r19, 0x00	; 0
     bde:	40 e1       	ldi	r20, 0x10	; 16
     be0:	52 ec       	ldi	r21, 0xC2	; 194
     be2:	0e 94 24 2e 	call	0x5c48	; 0x5c48 <__cmpsf2>
     be6:	88 23       	and	r24, r24
     be8:	54 f4       	brge	.+20     	; 0xbfe <wheel_R+0x5a>
     bea:	0f 2e       	mov	r0, r31
     bec:	f0 e0       	ldi	r31, 0x00	; 0
     bee:	ef 2e       	mov	r14, r31
     bf0:	f0 e0       	ldi	r31, 0x00	; 0
     bf2:	ff 2e       	mov	r15, r31
     bf4:	f0 e1       	ldi	r31, 0x10	; 16
     bf6:	0f 2f       	mov	r16, r31
     bf8:	f2 ec       	ldi	r31, 0xC2	; 194
     bfa:	1f 2f       	mov	r17, r31
     bfc:	f0 2d       	mov	r31, r0
				
		float s_out = -0.5421 * (cmd_vel) + 188.41;

		taskENTER_CRITICAL();
     bfe:	0f b6       	in	r0, 0x3f	; 63
     c00:	f8 94       	cli
     c02:	0f 92       	push	r0
		PWM_timer3_Set_E3((int)s_out);
     c04:	c8 01       	movw	r24, r16
     c06:	b7 01       	movw	r22, r14
     c08:	21 e1       	ldi	r18, 0x11	; 17
     c0a:	37 ec       	ldi	r19, 0xC7	; 199
     c0c:	4a e0       	ldi	r20, 0x0A	; 10
     c0e:	5f eb       	ldi	r21, 0xBF	; 191
     c10:	0e 94 77 2f 	call	0x5eee	; 0x5eee <__mulsf3>
     c14:	26 ef       	ldi	r18, 0xF6	; 246
     c16:	38 e6       	ldi	r19, 0x68	; 104
     c18:	4c e3       	ldi	r20, 0x3C	; 60
     c1a:	53 e4       	ldi	r21, 0x43	; 67
     c1c:	0e 94 c0 2d 	call	0x5b80	; 0x5b80 <__addsf3>
     c20:	0e 94 90 2e 	call	0x5d20	; 0x5d20 <__fixsfsi>
void PWM_timer1_Set_LED(u16 pwmDuty)
	{OCR1B = pwmDuty;}
void PWM_timer2_Set_H6(u16 pwmDuty)
	{OCR2B = pwmDuty;}
void PWM_timer3_Set_E3(u16 pwmDuty)
	{OCR3A = pwmDuty;}
     c24:	70 93 99 00 	sts	0x0099, r23
     c28:	60 93 98 00 	sts	0x0098, r22
		taskEXIT_CRITICAL();
     c2c:	0f 90       	pop	r0
     c2e:	0f be       	out	0x3f, r0	; 63


}
     c30:	1f 91       	pop	r17
     c32:	0f 91       	pop	r16
     c34:	ff 90       	pop	r15
     c36:	ef 90       	pop	r14
     c38:	08 95       	ret

00000c3a <num2char>:
	}
}



char num2char(char c){
     c3a:	98 2f       	mov	r25, r24
	
	if(c <10){
     c3c:	8a 30       	cpi	r24, 0x0A	; 10
     c3e:	10 f4       	brcc	.+4      	; 0xc44 <num2char+0xa>
		c += 48;
     c40:	90 5d       	subi	r25, 0xD0	; 208
     c42:	04 c0       	rjmp	.+8      	; 0xc4c <num2char+0x12>
	}
	else if((c >= 10) && (c <= 16)){
     c44:	8a 50       	subi	r24, 0x0A	; 10
     c46:	87 30       	cpi	r24, 0x07	; 7
     c48:	08 f4       	brcc	.+2      	; 0xc4c <num2char+0x12>
		c += 55;
     c4a:	99 5c       	subi	r25, 0xC9	; 201
	}
	return c;
}
     c4c:	89 2f       	mov	r24, r25
     c4e:	08 95       	ret

00000c50 <vServoTm>:
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
		LED_off();
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));	}
}

void vServoTm(){
     c50:	1f 93       	push	r17
     c52:	cf 93       	push	r28
     c54:	df 93       	push	r29
	char adj;
	for(;;){
		adj = uart1GetByte();
		if(adj == 'p'){ spray_time++;}
		else if(adj == 'l'){ spray_time--;}
		rprintf("%d\n", spray_time);
     c56:	11 e0       	ldi	r17, 0x01	; 1
     c58:	c8 e0       	ldi	r28, 0x08	; 8
     c5a:	d1 e0       	ldi	r29, 0x01	; 1
}

void vServoTm(){
	char adj;
	for(;;){
		adj = uart1GetByte();
     c5c:	0e 94 33 26 	call	0x4c66	; 0x4c66 <uart1GetByte>
		if(adj == 'p'){ spray_time++;}
     c60:	80 37       	cpi	r24, 0x70	; 112
     c62:	31 f4       	brne	.+12     	; 0xc70 <vServoTm+0x20>
     c64:	80 91 a5 02 	lds	r24, 0x02A5
     c68:	90 91 a6 02 	lds	r25, 0x02A6
     c6c:	01 96       	adiw	r24, 0x01	; 1
     c6e:	07 c0       	rjmp	.+14     	; 0xc7e <vServoTm+0x2e>
		else if(adj == 'l'){ spray_time--;}
     c70:	8c 36       	cpi	r24, 0x6C	; 108
     c72:	49 f4       	brne	.+18     	; 0xc86 <vServoTm+0x36>
     c74:	80 91 a5 02 	lds	r24, 0x02A5
     c78:	90 91 a6 02 	lds	r25, 0x02A6
     c7c:	01 97       	sbiw	r24, 0x01	; 1
     c7e:	90 93 a6 02 	sts	0x02A6, r25
     c82:	80 93 a5 02 	sts	0x02A5, r24
		rprintf("%d\n", spray_time);
     c86:	00 d0       	rcall	.+0      	; 0xc88 <vServoTm+0x38>
     c88:	00 d0       	rcall	.+0      	; 0xc8a <vServoTm+0x3a>
     c8a:	0f 92       	push	r0
     c8c:	ed b7       	in	r30, 0x3d	; 61
     c8e:	fe b7       	in	r31, 0x3e	; 62
     c90:	31 96       	adiw	r30, 0x01	; 1
     c92:	ad b7       	in	r26, 0x3d	; 61
     c94:	be b7       	in	r27, 0x3e	; 62
     c96:	11 96       	adiw	r26, 0x01	; 1
     c98:	1c 93       	st	X, r17
     c9a:	d2 83       	std	Z+2, r29	; 0x02
     c9c:	c1 83       	std	Z+1, r28	; 0x01
     c9e:	80 91 a5 02 	lds	r24, 0x02A5
     ca2:	90 91 a6 02 	lds	r25, 0x02A6
     ca6:	94 83       	std	Z+4, r25	; 0x04
     ca8:	83 83       	std	Z+3, r24	; 0x03
     caa:	0e 94 86 2a 	call	0x550c	; 0x550c <rprintf1RamRom>
     cae:	0f 90       	pop	r0
     cb0:	0f 90       	pop	r0
     cb2:	0f 90       	pop	r0
     cb4:	0f 90       	pop	r0
     cb6:	0f 90       	pop	r0
     cb8:	d1 cf       	rjmp	.-94     	; 0xc5c <vServoTm+0xc>

00000cba <fwdSer_L>:
		
			//taskYIELD();
	//	}
		
}
void fwdSer_L(unsigned char c){
     cba:	98 2f       	mov	r25, r24
	static char d_flag;
	static char vel_rough[4];  //store ascii chars
	static char dis_rough[8];  //store ascii chars

		//rprintf("%c",c);
		if(c != 0xff){
     cbc:	8f 3f       	cpi	r24, 0xFF	; 255
     cbe:	09 f4       	brne	.+2      	; 0xcc2 <fwdSer_L+0x8>
     cc0:	7c c0       	rjmp	.+248    	; 0xdba <fwdSer_L+0x100>
		//if the data isn't whitespace (0xff), post it
		//	rprintf("%c",c);

			if(c == 0x0A){lf_flag = SET;} //line feed detected, the character will be a 'D' or a 'V'
     cc2:	8a 30       	cpi	r24, 0x0A	; 10
     cc4:	21 f4       	brne	.+8      	; 0xcce <fwdSer_L+0x14>
     cc6:	81 e0       	ldi	r24, 0x01	; 1
     cc8:	80 93 0b 03 	sts	0x030B, r24
     ccc:	33 c0       	rjmp	.+102    	; 0xd34 <fwdSer_L+0x7a>
	
			else if((lf_flag) && (c == 'V')){ //set velocity flag
     cce:	80 91 0b 03 	lds	r24, 0x030B
     cd2:	88 23       	and	r24, r24
     cd4:	91 f0       	breq	.+36     	; 0xcfa <fwdSer_L+0x40>
     cd6:	96 35       	cpi	r25, 0x56	; 86
     cd8:	31 f4       	brne	.+12     	; 0xce6 <fwdSer_L+0x2c>
				v_flag = SET;
     cda:	81 e0       	ldi	r24, 0x01	; 1
     cdc:	80 93 08 03 	sts	0x0308, r24
				v_iter = 0;
     ce0:	10 92 0a 03 	sts	0x030A, r1
     ce4:	07 c0       	rjmp	.+14     	; 0xcf4 <fwdSer_L+0x3a>
				lf_flag = UNSET;
				return;
			} 
			else if((lf_flag) && (c == 'D')){ //set distance flag
     ce6:	94 34       	cpi	r25, 0x44	; 68
     ce8:	41 f4       	brne	.+16     	; 0xcfa <fwdSer_L+0x40>
				d_flag = SET;
     cea:	81 e0       	ldi	r24, 0x01	; 1
     cec:	80 93 07 03 	sts	0x0307, r24
				d_iter = 0;
     cf0:	10 92 09 03 	sts	0x0309, r1
				lf_flag = UNSET;
     cf4:	10 92 0b 03 	sts	0x030B, r1
     cf8:	08 95       	ret
			//	rprintf("%c",c);
				return;
			}
			else if(v_flag){
     cfa:	80 91 08 03 	lds	r24, 0x0308
     cfe:	88 23       	and	r24, r24
     d00:	59 f0       	breq	.+22     	; 0xd18 <fwdSer_L+0x5e>
				vel_rough[v_iter++] = c;	//store then increment	
     d02:	80 91 0a 03 	lds	r24, 0x030A
     d06:	e8 2f       	mov	r30, r24
     d08:	f0 e0       	ldi	r31, 0x00	; 0
     d0a:	ed 5f       	subi	r30, 0xFD	; 253
     d0c:	fc 4f       	sbci	r31, 0xFC	; 252
     d0e:	90 83       	st	Z, r25
     d10:	8f 5f       	subi	r24, 0xFF	; 255
     d12:	80 93 0a 03 	sts	0x030A, r24
     d16:	0e c0       	rjmp	.+28     	; 0xd34 <fwdSer_L+0x7a>
				//rprintf("%c",c);
			}	
			else if(d_flag){
     d18:	80 91 07 03 	lds	r24, 0x0307
     d1c:	88 23       	and	r24, r24
     d1e:	51 f0       	breq	.+20     	; 0xd34 <fwdSer_L+0x7a>
				dis_rough[d_iter++] = c;	//store then increment	
     d20:	80 91 09 03 	lds	r24, 0x0309
     d24:	e8 2f       	mov	r30, r24
     d26:	f0 e0       	ldi	r31, 0x00	; 0
     d28:	e5 50       	subi	r30, 0x05	; 5
     d2a:	fd 4f       	sbci	r31, 0xFD	; 253
     d2c:	90 83       	st	Z, r25
     d2e:	8f 5f       	subi	r24, 0xFF	; 255
     d30:	80 93 09 03 	sts	0x0309, r24
			//	rprintf("%c",c);
			}

			if(v_iter == 4){
     d34:	80 91 0a 03 	lds	r24, 0x030A
     d38:	84 30       	cpi	r24, 0x04	; 4
     d3a:	01 f5       	brne	.+64     	; 0xd7c <fwdSer_L+0xc2>
				LEFTVel_current = CM_TICK * retConv_s16(&vel_rough);
     d3c:	83 e0       	ldi	r24, 0x03	; 3
     d3e:	93 e0       	ldi	r25, 0x03	; 3
     d40:	0e 94 61 04 	call	0x8c2	; 0x8c2 <retConv_s16>
     d44:	aa 27       	eor	r26, r26
     d46:	97 fd       	sbrc	r25, 7
     d48:	a0 95       	com	r26
     d4a:	ba 2f       	mov	r27, r26
     d4c:	bc 01       	movw	r22, r24
     d4e:	cd 01       	movw	r24, r26
     d50:	0e 94 c3 2e 	call	0x5d86	; 0x5d86 <__floatsisf>
     d54:	20 e0       	ldi	r18, 0x00	; 0
     d56:	30 e0       	ldi	r19, 0x00	; 0
     d58:	40 e8       	ldi	r20, 0x80	; 128
     d5a:	5e e3       	ldi	r21, 0x3E	; 62
     d5c:	0e 94 77 2f 	call	0x5eee	; 0x5eee <__mulsf3>
     d60:	0e 94 90 2e 	call	0x5d20	; 0x5d20 <__fixsfsi>
     d64:	70 93 b9 02 	sts	0x02B9, r23
     d68:	60 93 b8 02 	sts	0x02B8, r22
				v_flag = UNSET;
     d6c:	10 92 08 03 	sts	0x0308, r1
				v_iter = 0;
     d70:	10 92 0a 03 	sts	0x030A, r1
				LEFTVel_ready = SET;
     d74:	81 e0       	ldi	r24, 0x01	; 1
     d76:	80 93 ba 02 	sts	0x02BA, r24
     d7a:	08 95       	ret
			//	rprintf("LEFTVel_ready: %d\n", LEFTVel_ready);
			//	rprintf("LLL VVV: ");
			//	rprintfu16(RIGHTVel_current);
			//	rprintf("\n");
			}
			else if(d_iter == 8){
     d7c:	80 91 09 03 	lds	r24, 0x0309
     d80:	88 30       	cpi	r24, 0x08	; 8
     d82:	51 f5       	brne	.+84     	; 0xdd8 <fwdSer_L+0x11e>
				LEFTDis_current = CM_TICK * retConv_s32(&dis_rough);
     d84:	8b ef       	ldi	r24, 0xFB	; 251
     d86:	92 e0       	ldi	r25, 0x02	; 2
     d88:	0e 94 b0 04 	call	0x960	; 0x960 <retConv_s32>
     d8c:	0e 94 c3 2e 	call	0x5d86	; 0x5d86 <__floatsisf>
     d90:	20 e0       	ldi	r18, 0x00	; 0
     d92:	30 e0       	ldi	r19, 0x00	; 0
     d94:	40 e8       	ldi	r20, 0x80	; 128
     d96:	5e e3       	ldi	r21, 0x3E	; 62
     d98:	0e 94 77 2f 	call	0x5eee	; 0x5eee <__mulsf3>
     d9c:	0e 94 90 2e 	call	0x5d20	; 0x5d20 <__fixsfsi>
     da0:	60 93 bb 02 	sts	0x02BB, r22
     da4:	70 93 bc 02 	sts	0x02BC, r23
     da8:	80 93 bd 02 	sts	0x02BD, r24
     dac:	90 93 be 02 	sts	0x02BE, r25
			//	rprintf("dL: %d\n",dLEFTDis);
				d_flag = UNSET;
     db0:	10 92 07 03 	sts	0x0307, r1
				d_iter = 0;
     db4:	10 92 09 03 	sts	0x0309, r1
     db8:	08 95       	ret
			//	rprintf("\n");
			}
		
		}

		else{rprintf("WR\n");}
     dba:	00 d0       	rcall	.+0      	; 0xdbc <fwdSer_L+0x102>
     dbc:	0f 92       	push	r0
     dbe:	81 e0       	ldi	r24, 0x01	; 1
     dc0:	ed b7       	in	r30, 0x3d	; 61
     dc2:	fe b7       	in	r31, 0x3e	; 62
     dc4:	81 83       	std	Z+1, r24	; 0x01
     dc6:	86 e9       	ldi	r24, 0x96	; 150
     dc8:	91 e0       	ldi	r25, 0x01	; 1
     dca:	93 83       	std	Z+3, r25	; 0x03
     dcc:	82 83       	std	Z+2, r24	; 0x02
     dce:	0e 94 86 2a 	call	0x550c	; 0x550c <rprintf1RamRom>
     dd2:	0f 90       	pop	r0
     dd4:	0f 90       	pop	r0
     dd6:	0f 90       	pop	r0
     dd8:	08 95       	ret

00000dda <fwdSer_R>:
	int_val = ((int_val<<4) | iv8);
	return int_val;
}


void fwdSer_R(unsigned char c){
     dda:	98 2f       	mov	r25, r24
	static char d_flag;
	static char vel_rough[4];  //store ascii chars
	static char dis_rough[8];  //store ascii chars

		//rprintf("%c",c);
		if(c != 0xff){
     ddc:	8f 3f       	cpi	r24, 0xFF	; 255
     dde:	09 f4       	brne	.+2      	; 0xde2 <fwdSer_R+0x8>
     de0:	7c c0       	rjmp	.+248    	; 0xeda <fwdSer_R+0x100>
		//if the data isn't whitespace (0xff), post it
		//	rprintf("%c",c);

			if(c == 0x0A){lf_flag = SET;} //line feed detected, the character will be a 'D' or a 'V'
     de2:	8a 30       	cpi	r24, 0x0A	; 10
     de4:	21 f4       	brne	.+8      	; 0xdee <fwdSer_R+0x14>
     de6:	81 e0       	ldi	r24, 0x01	; 1
     de8:	80 93 1c 03 	sts	0x031C, r24
     dec:	33 c0       	rjmp	.+102    	; 0xe54 <fwdSer_R+0x7a>
	
			else if((lf_flag) && (c == 'V')){ //set velocity flag
     dee:	80 91 1c 03 	lds	r24, 0x031C
     df2:	88 23       	and	r24, r24
     df4:	91 f0       	breq	.+36     	; 0xe1a <fwdSer_R+0x40>
     df6:	96 35       	cpi	r25, 0x56	; 86
     df8:	31 f4       	brne	.+12     	; 0xe06 <fwdSer_R+0x2c>
				v_flag = SET;
     dfa:	81 e0       	ldi	r24, 0x01	; 1
     dfc:	80 93 19 03 	sts	0x0319, r24
				v_iter = 0;
     e00:	10 92 1b 03 	sts	0x031B, r1
     e04:	07 c0       	rjmp	.+14     	; 0xe14 <fwdSer_R+0x3a>
				lf_flag = UNSET;
				return;
			} 
			else if((lf_flag) && (c == 'D')){ //set distance flag
     e06:	94 34       	cpi	r25, 0x44	; 68
     e08:	41 f4       	brne	.+16     	; 0xe1a <fwdSer_R+0x40>
				d_flag = SET;
     e0a:	81 e0       	ldi	r24, 0x01	; 1
     e0c:	80 93 18 03 	sts	0x0318, r24
				d_iter = 0;
     e10:	10 92 1a 03 	sts	0x031A, r1
				lf_flag = UNSET;
     e14:	10 92 1c 03 	sts	0x031C, r1
     e18:	08 95       	ret
			//	rprintf("%c",c);
				return;
			}
			else if(v_flag){
     e1a:	80 91 19 03 	lds	r24, 0x0319
     e1e:	88 23       	and	r24, r24
     e20:	59 f0       	breq	.+22     	; 0xe38 <fwdSer_R+0x5e>
				vel_rough[v_iter++] = c;	//store then increment	
     e22:	80 91 1b 03 	lds	r24, 0x031B
     e26:	e8 2f       	mov	r30, r24
     e28:	f0 e0       	ldi	r31, 0x00	; 0
     e2a:	ec 5e       	subi	r30, 0xEC	; 236
     e2c:	fc 4f       	sbci	r31, 0xFC	; 252
     e2e:	90 83       	st	Z, r25
     e30:	8f 5f       	subi	r24, 0xFF	; 255
     e32:	80 93 1b 03 	sts	0x031B, r24
     e36:	0e c0       	rjmp	.+28     	; 0xe54 <fwdSer_R+0x7a>
				//rprintf("%c",c);
			}	
			else if(d_flag){
     e38:	80 91 18 03 	lds	r24, 0x0318
     e3c:	88 23       	and	r24, r24
     e3e:	51 f0       	breq	.+20     	; 0xe54 <fwdSer_R+0x7a>
				dis_rough[d_iter++] = c;	//store then increment	
     e40:	80 91 1a 03 	lds	r24, 0x031A
     e44:	e8 2f       	mov	r30, r24
     e46:	f0 e0       	ldi	r31, 0x00	; 0
     e48:	e4 5f       	subi	r30, 0xF4	; 244
     e4a:	fc 4f       	sbci	r31, 0xFC	; 252
     e4c:	90 83       	st	Z, r25
     e4e:	8f 5f       	subi	r24, 0xFF	; 255
     e50:	80 93 1a 03 	sts	0x031A, r24
			//	rprintf("%c",c);
			}

			if(v_iter == 4){
     e54:	80 91 1b 03 	lds	r24, 0x031B
     e58:	84 30       	cpi	r24, 0x04	; 4
     e5a:	01 f5       	brne	.+64     	; 0xe9c <fwdSer_R+0xc2>
				RIGHTVel_current = CM_TICK * retConv_s16(&vel_rough);
     e5c:	84 e1       	ldi	r24, 0x14	; 20
     e5e:	93 e0       	ldi	r25, 0x03	; 3
     e60:	0e 94 61 04 	call	0x8c2	; 0x8c2 <retConv_s16>
     e64:	aa 27       	eor	r26, r26
     e66:	97 fd       	sbrc	r25, 7
     e68:	a0 95       	com	r26
     e6a:	ba 2f       	mov	r27, r26
     e6c:	bc 01       	movw	r22, r24
     e6e:	cd 01       	movw	r24, r26
     e70:	0e 94 c3 2e 	call	0x5d86	; 0x5d86 <__floatsisf>
     e74:	20 e0       	ldi	r18, 0x00	; 0
     e76:	30 e0       	ldi	r19, 0x00	; 0
     e78:	40 e8       	ldi	r20, 0x80	; 128
     e7a:	5e e3       	ldi	r21, 0x3E	; 62
     e7c:	0e 94 77 2f 	call	0x5eee	; 0x5eee <__mulsf3>
     e80:	0e 94 90 2e 	call	0x5d20	; 0x5d20 <__fixsfsi>
     e84:	70 93 c6 02 	sts	0x02C6, r23
     e88:	60 93 c5 02 	sts	0x02C5, r22
				v_flag = UNSET;
     e8c:	10 92 19 03 	sts	0x0319, r1
				v_iter = 0;
     e90:	10 92 1b 03 	sts	0x031B, r1
				RIGHTVel_ready = SET;
     e94:	81 e0       	ldi	r24, 0x01	; 1
     e96:	80 93 c7 02 	sts	0x02C7, r24
     e9a:	08 95       	ret

			//	rprintf("RRR VVV: ");
			//	rprintfu16(RIGHTVel_current);
			//	rprintf("\n");
			}
			else if(d_iter == 8){
     e9c:	80 91 1a 03 	lds	r24, 0x031A
     ea0:	88 30       	cpi	r24, 0x08	; 8
     ea2:	51 f5       	brne	.+84     	; 0xef8 <fwdSer_R+0x11e>
				RIGHTDis_current = CM_TICK * retConv_s32(&dis_rough);
     ea4:	8c e0       	ldi	r24, 0x0C	; 12
     ea6:	93 e0       	ldi	r25, 0x03	; 3
     ea8:	0e 94 b0 04 	call	0x960	; 0x960 <retConv_s32>
     eac:	0e 94 c3 2e 	call	0x5d86	; 0x5d86 <__floatsisf>
     eb0:	20 e0       	ldi	r18, 0x00	; 0
     eb2:	30 e0       	ldi	r19, 0x00	; 0
     eb4:	40 e8       	ldi	r20, 0x80	; 128
     eb6:	5e e3       	ldi	r21, 0x3E	; 62
     eb8:	0e 94 77 2f 	call	0x5eee	; 0x5eee <__mulsf3>
     ebc:	0e 94 90 2e 	call	0x5d20	; 0x5d20 <__fixsfsi>
     ec0:	60 93 c8 02 	sts	0x02C8, r22
     ec4:	70 93 c9 02 	sts	0x02C9, r23
     ec8:	80 93 ca 02 	sts	0x02CA, r24
     ecc:	90 93 cb 02 	sts	0x02CB, r25
				//rprintf("dR: %d\n",dRIGHTDis);
				d_flag = UNSET;
     ed0:	10 92 18 03 	sts	0x0318, r1
				d_iter = 0;
     ed4:	10 92 1a 03 	sts	0x031A, r1
     ed8:	08 95       	ret
				//rprintf("\n");
			}
		
		}

		else{rprintf("WR\n");}
     eda:	00 d0       	rcall	.+0      	; 0xedc <fwdSer_R+0x102>
     edc:	0f 92       	push	r0
     ede:	81 e0       	ldi	r24, 0x01	; 1
     ee0:	ed b7       	in	r30, 0x3d	; 61
     ee2:	fe b7       	in	r31, 0x3e	; 62
     ee4:	81 83       	std	Z+1, r24	; 0x01
     ee6:	8a e9       	ldi	r24, 0x9A	; 154
     ee8:	91 e0       	ldi	r25, 0x01	; 1
     eea:	93 83       	std	Z+3, r25	; 0x03
     eec:	82 83       	std	Z+2, r24	; 0x02
     eee:	0e 94 86 2a 	call	0x550c	; 0x550c <rprintf1RamRom>
     ef2:	0f 90       	pop	r0
     ef4:	0f 90       	pop	r0
     ef6:	0f 90       	pop	r0
     ef8:	08 95       	ret

00000efa <vScript>:
		
	}

}

void vScript(){
     efa:	3f 92       	push	r3
     efc:	4f 92       	push	r4
     efe:	5f 92       	push	r5
     f00:	6f 92       	push	r6
     f02:	7f 92       	push	r7
     f04:	8f 92       	push	r8
     f06:	9f 92       	push	r9
     f08:	af 92       	push	r10
     f0a:	bf 92       	push	r11
     f0c:	cf 92       	push	r12
     f0e:	df 92       	push	r13
     f10:	ef 92       	push	r14
     f12:	ff 92       	push	r15
     f14:	0f 93       	push	r16
     f16:	1f 93       	push	r17
     f18:	df 93       	push	r29
     f1a:	cf 93       	push	r28
     f1c:	00 d0       	rcall	.+0      	; 0xf1e <vScript+0x24>
     f1e:	cd b7       	in	r28, 0x3d	; 61
     f20:	de b7       	in	r29, 0x3e	; 62
	const portTickType xTicksToWait = 10000 / portTICK_RATE_MS;
	portTickType xLastWakeTime;

	for(;;){
		cmd_angle = 0;
     f22:	0f 2e       	mov	r0, r31
     f24:	f0 e0       	ldi	r31, 0x00	; 0
     f26:	af 2e       	mov	r10, r31
     f28:	f0 e0       	ldi	r31, 0x00	; 0
     f2a:	bf 2e       	mov	r11, r31
     f2c:	f0 e0       	ldi	r31, 0x00	; 0
     f2e:	cf 2e       	mov	r12, r31
     f30:	f0 e0       	ldi	r31, 0x00	; 0
     f32:	df 2e       	mov	r13, r31
     f34:	f0 2d       	mov	r31, r0
		rprintf("cmd_angle: ");
     f36:	33 24       	eor	r3, r3
     f38:	33 94       	inc	r3
     f3a:	b7 ef       	ldi	r27, 0xF7	; 247
     f3c:	4b 2e       	mov	r4, r27
     f3e:	b0 e0       	ldi	r27, 0x00	; 0
     f40:	5b 2e       	mov	r5, r27
		rprintfFloat(5, cmd_angle);
		rprintfCRLF();
		vTaskDelayUntil(&xLastWakeTime, xTicksToWait);
     f42:	4e 01       	movw	r8, r28
     f44:	08 94       	sec
     f46:	81 1c       	adc	r8, r1
     f48:	91 1c       	adc	r9, r1
		cmd_angle = 90*(M_PI/180);
     f4a:	0f 2e       	mov	r0, r31
     f4c:	fb ed       	ldi	r31, 0xDB	; 219
     f4e:	ef 2e       	mov	r14, r31
     f50:	ff e0       	ldi	r31, 0x0F	; 15
     f52:	ff 2e       	mov	r15, r31
     f54:	f9 ec       	ldi	r31, 0xC9	; 201
     f56:	0f 2f       	mov	r16, r31
     f58:	ff e3       	ldi	r31, 0x3F	; 63
     f5a:	1f 2f       	mov	r17, r31
     f5c:	f0 2d       	mov	r31, r0
		rprintf("cmd_angle: ");
     f5e:	ab ee       	ldi	r26, 0xEB	; 235
     f60:	6a 2e       	mov	r6, r26
     f62:	a0 e0       	ldi	r26, 0x00	; 0
     f64:	7a 2e       	mov	r7, r26
void vScript(){
	const portTickType xTicksToWait = 10000 / portTICK_RATE_MS;
	portTickType xLastWakeTime;

	for(;;){
		cmd_angle = 0;
     f66:	a0 92 da 02 	sts	0x02DA, r10
     f6a:	b0 92 db 02 	sts	0x02DB, r11
     f6e:	c0 92 dc 02 	sts	0x02DC, r12
     f72:	d0 92 dd 02 	sts	0x02DD, r13
		rprintf("cmd_angle: ");
     f76:	00 d0       	rcall	.+0      	; 0xf78 <vScript+0x7e>
     f78:	0f 92       	push	r0
     f7a:	ed b7       	in	r30, 0x3d	; 61
     f7c:	fe b7       	in	r31, 0x3e	; 62
     f7e:	31 82       	std	Z+1, r3	; 0x01
     f80:	53 82       	std	Z+3, r5	; 0x03
     f82:	42 82       	std	Z+2, r4	; 0x02
     f84:	0e 94 86 2a 	call	0x550c	; 0x550c <rprintf1RamRom>
		rprintfFloat(5, cmd_angle);
     f88:	0f 90       	pop	r0
     f8a:	0f 90       	pop	r0
     f8c:	0f 90       	pop	r0
     f8e:	40 91 da 02 	lds	r20, 0x02DA
     f92:	50 91 db 02 	lds	r21, 0x02DB
     f96:	60 91 dc 02 	lds	r22, 0x02DC
     f9a:	70 91 dd 02 	lds	r23, 0x02DD
     f9e:	85 e0       	ldi	r24, 0x05	; 5
     fa0:	0e 94 bd 29 	call	0x537a	; 0x537a <rprintfFloat>
		rprintfCRLF();
     fa4:	0e 94 c6 28 	call	0x518c	; 0x518c <rprintfCRLF>
		vTaskDelayUntil(&xLastWakeTime, xTicksToWait);
     fa8:	c4 01       	movw	r24, r8
     faa:	60 e1       	ldi	r22, 0x10	; 16
     fac:	77 e2       	ldi	r23, 0x27	; 39
     fae:	0e 94 7c 16 	call	0x2cf8	; 0x2cf8 <vTaskDelayUntil>
		cmd_angle = 90*(M_PI/180);
     fb2:	e0 92 da 02 	sts	0x02DA, r14
     fb6:	f0 92 db 02 	sts	0x02DB, r15
     fba:	00 93 dc 02 	sts	0x02DC, r16
     fbe:	10 93 dd 02 	sts	0x02DD, r17
		rprintf("cmd_angle: ");
     fc2:	00 d0       	rcall	.+0      	; 0xfc4 <vScript+0xca>
     fc4:	0f 92       	push	r0
     fc6:	ed b7       	in	r30, 0x3d	; 61
     fc8:	fe b7       	in	r31, 0x3e	; 62
     fca:	31 82       	std	Z+1, r3	; 0x01
     fcc:	73 82       	std	Z+3, r7	; 0x03
     fce:	62 82       	std	Z+2, r6	; 0x02
     fd0:	0e 94 86 2a 	call	0x550c	; 0x550c <rprintf1RamRom>
		rprintfFloat(5, cmd_angle);
     fd4:	0f 90       	pop	r0
     fd6:	0f 90       	pop	r0
     fd8:	0f 90       	pop	r0
     fda:	40 91 da 02 	lds	r20, 0x02DA
     fde:	50 91 db 02 	lds	r21, 0x02DB
     fe2:	60 91 dc 02 	lds	r22, 0x02DC
     fe6:	70 91 dd 02 	lds	r23, 0x02DD
     fea:	85 e0       	ldi	r24, 0x05	; 5
     fec:	0e 94 bd 29 	call	0x537a	; 0x537a <rprintfFloat>
		rprintfCRLF();
     ff0:	0e 94 c6 28 	call	0x518c	; 0x518c <rprintfCRLF>
		vTaskDelayUntil(&xLastWakeTime, xTicksToWait);
     ff4:	c4 01       	movw	r24, r8
     ff6:	60 e1       	ldi	r22, 0x10	; 16
     ff8:	77 e2       	ldi	r23, 0x27	; 39
     ffa:	0e 94 7c 16 	call	0x2cf8	; 0x2cf8 <vTaskDelayUntil>
     ffe:	b3 cf       	rjmp	.-154    	; 0xf66 <vScript+0x6c>

00001000 <vRampVel>:
	uart3SendByte(r2);
	uart3SendByte(r1);
	uart3SendByte('\n'); //line feed
}

void vRampVel(){
    1000:	6f 92       	push	r6
    1002:	7f 92       	push	r7
    1004:	8f 92       	push	r8
    1006:	9f 92       	push	r9
    1008:	af 92       	push	r10
    100a:	bf 92       	push	r11
    100c:	cf 92       	push	r12
    100e:	df 92       	push	r13
    1010:	ef 92       	push	r14
    1012:	ff 92       	push	r15
    1014:	0f 93       	push	r16
    1016:	1f 93       	push	r17
    1018:	df 93       	push	r29
    101a:	cf 93       	push	r28
    101c:	00 d0       	rcall	.+0      	; 0x101e <vRampVel+0x1e>
    101e:	cd b7       	in	r28, 0x3d	; 61
    1020:	de b7       	in	r29, 0x3e	; 62
	const portTickType xTicksToWait = 1000 / portTICK_RATE_MS;
	portTickType xLastWakeTime;
	v_command = 0;
    1022:	80 e0       	ldi	r24, 0x00	; 0
    1024:	90 e0       	ldi	r25, 0x00	; 0
    1026:	a0 e0       	ldi	r26, 0x00	; 0
    1028:	b0 e0       	ldi	r27, 0x00	; 0
    102a:	80 93 ac 02 	sts	0x02AC, r24
    102e:	90 93 ad 02 	sts	0x02AD, r25
    1032:	a0 93 ae 02 	sts	0x02AE, r26
    1036:	b0 93 af 02 	sts	0x02AF, r27
	inst_cmd_vel = 25;
    103a:	80 e0       	ldi	r24, 0x00	; 0
    103c:	90 e0       	ldi	r25, 0x00	; 0
    103e:	a8 ec       	ldi	r26, 0xC8	; 200
    1040:	b1 e4       	ldi	r27, 0x41	; 65
    1042:	80 93 b0 02 	sts	0x02B0, r24
    1046:	90 93 b1 02 	sts	0x02B1, r25
    104a:	a0 93 b2 02 	sts	0x02B2, r26
    104e:	b0 93 b3 02 	sts	0x02B3, r27
	vTaskDelayUntil(&xLastWakeTime, 10000 / portTICK_RATE_MS);	//leave velocity at zero briefly
    1052:	ce 01       	movw	r24, r28
    1054:	01 96       	adiw	r24, 0x01	; 1
    1056:	60 e1       	ldi	r22, 0x10	; 16
    1058:	77 e2       	ldi	r23, 0x27	; 39
    105a:	0e 94 7c 16 	call	0x2cf8	; 0x2cf8 <vTaskDelayUntil>
	sbi(TCCR3A,COM3A1);
	cbi(TCCR3A,COM3A0);
}
void PWM_timer3_On_E4(void)
{
	sbi(TCCR3A,COM3B1);
    105e:	80 91 90 00 	lds	r24, 0x0090
    1062:	80 62       	ori	r24, 0x20	; 32
    1064:	80 93 90 00 	sts	0x0090, r24
	cbi(TCCR3A,COM3B0);
    1068:	80 91 90 00 	lds	r24, 0x0090
    106c:	8f 7e       	andi	r24, 0xEF	; 239
    106e:	80 93 90 00 	sts	0x0090, r24
	sbi(TCCR2A,COM2B1);
	cbi(TCCR2A,COM2B0);
}
void PWM_timer3_On_E3(void)
{
	sbi(TCCR3A,COM3A1);
    1072:	80 91 90 00 	lds	r24, 0x0090
    1076:	80 68       	ori	r24, 0x80	; 128
    1078:	80 93 90 00 	sts	0x0090, r24
	cbi(TCCR3A,COM3A0);
    107c:	80 91 90 00 	lds	r24, 0x0090
    1080:	8f 7b       	andi	r24, 0xBF	; 191
    1082:	80 93 90 00 	sts	0x0090, r24
		if(cmd_vel > 36){cmd_vel = 36;}
		if(cmd_vel < -36){cmd_vel = -36;}
		
		float s_out = -0.4928 * (cmd_vel) + 185.27;
		
		taskENTER_CRITICAL();
    1086:	0f b6       	in	r0, 0x3f	; 63
    1088:	f8 94       	cli
    108a:	0f 92       	push	r0
void PWM_timer2_Set_H6(u16 pwmDuty)
	{OCR2B = pwmDuty;}
void PWM_timer3_Set_E3(u16 pwmDuty)
	{OCR3A = pwmDuty;}
void PWM_timer3_Set_E4(u16 pwmDuty)
	{OCR3B = pwmDuty;}
    108c:	8c ea       	ldi	r24, 0xAC	; 172
    108e:	90 e0       	ldi	r25, 0x00	; 0
    1090:	90 93 9b 00 	sts	0x009B, r25
    1094:	80 93 9a 00 	sts	0x009A, r24
		PWM_timer3_Set_E4((int)s_out);
		taskEXIT_CRITICAL();
    1098:	0f 90       	pop	r0
    109a:	0f be       	out	0x3f, r0	; 63
		if(cmd_vel > 36){cmd_vel = 36;}
		if(cmd_vel < -36){cmd_vel = -36;}
				
		float s_out = -0.5421 * (cmd_vel) + 188.41;

		taskENTER_CRITICAL();
    109c:	0f b6       	in	r0, 0x3f	; 63
    109e:	f8 94       	cli
    10a0:	0f 92       	push	r0
void PWM_timer1_Set_LED(u16 pwmDuty)
	{OCR1B = pwmDuty;}
void PWM_timer2_Set_H6(u16 pwmDuty)
	{OCR2B = pwmDuty;}
void PWM_timer3_Set_E3(u16 pwmDuty)
	{OCR3A = pwmDuty;}
    10a2:	89 ec       	ldi	r24, 0xC9	; 201
    10a4:	90 e0       	ldi	r25, 0x00	; 0
    10a6:	90 93 99 00 	sts	0x0099, r25
    10aa:	80 93 98 00 	sts	0x0098, r24
		PWM_timer3_Set_E3((int)s_out);
		taskEXIT_CRITICAL();
    10ae:	0f 90       	pop	r0
    10b0:	0f be       	out	0x3f, r0	; 63
	vTaskDelayUntil(&xLastWakeTime, 10000 / portTICK_RATE_MS);	//leave velocity at zero briefly
	wheel_L_on();
	wheel_R_on();
	wheel_L(25);
	wheel_R(-25);
	v_left = v_right = 25;
    10b2:	89 e1       	ldi	r24, 0x19	; 25
    10b4:	90 e0       	ldi	r25, 0x00	; 0
    10b6:	90 93 b7 02 	sts	0x02B7, r25
    10ba:	80 93 b6 02 	sts	0x02B6, r24
    10be:	90 93 b5 02 	sts	0x02B5, r25
    10c2:	80 93 b4 02 	sts	0x02B4, r24

	for(;;){
		
		vTaskDelayUntil(&xLastWakeTime, xTicksToWait);
    10c6:	3e 01       	movw	r6, r28
    10c8:	08 94       	sec
    10ca:	61 1c       	adc	r6, r1
    10cc:	71 1c       	adc	r7, r1
		//if(v_command != inst_cmd_vel){v_command++;}
		v_command = 25;
    10ce:	0f 2e       	mov	r0, r31
    10d0:	f0 e0       	ldi	r31, 0x00	; 0
    10d2:	ef 2e       	mov	r14, r31
    10d4:	f0 e0       	ldi	r31, 0x00	; 0
    10d6:	ff 2e       	mov	r15, r31
    10d8:	f8 ec       	ldi	r31, 0xC8	; 200
    10da:	0f 2f       	mov	r16, r31
    10dc:	f1 e4       	ldi	r31, 0x41	; 65
    10de:	1f 2f       	mov	r17, r31
    10e0:	f0 2d       	mov	r31, r0
		v_left = v_right = v_command;
    10e2:	29 e1       	ldi	r18, 0x19	; 25
    10e4:	c2 2e       	mov	r12, r18
    10e6:	d1 2c       	mov	r13, r1
void PWM_timer3_Set_E4(u16 pwmDuty)
	{OCR3B = pwmDuty;}
    10e8:	9c ea       	ldi	r25, 0xAC	; 172
    10ea:	89 2e       	mov	r8, r25
    10ec:	91 2c       	mov	r9, r1
void PWM_timer1_Set_LED(u16 pwmDuty)
	{OCR1B = pwmDuty;}
void PWM_timer2_Set_H6(u16 pwmDuty)
	{OCR2B = pwmDuty;}
void PWM_timer3_Set_E3(u16 pwmDuty)
	{OCR3A = pwmDuty;}
    10ee:	89 ec       	ldi	r24, 0xC9	; 201
    10f0:	a8 2e       	mov	r10, r24
    10f2:	b1 2c       	mov	r11, r1
	wheel_R(-25);
	v_left = v_right = 25;

	for(;;){
		
		vTaskDelayUntil(&xLastWakeTime, xTicksToWait);
    10f4:	c3 01       	movw	r24, r6
    10f6:	68 ee       	ldi	r22, 0xE8	; 232
    10f8:	73 e0       	ldi	r23, 0x03	; 3
    10fa:	0e 94 7c 16 	call	0x2cf8	; 0x2cf8 <vTaskDelayUntil>
		//if(v_command != inst_cmd_vel){v_command++;}
		v_command = 25;
    10fe:	e0 92 ac 02 	sts	0x02AC, r14
    1102:	f0 92 ad 02 	sts	0x02AD, r15
    1106:	00 93 ae 02 	sts	0x02AE, r16
    110a:	10 93 af 02 	sts	0x02AF, r17
		v_left = v_right = v_command;
    110e:	d0 92 b7 02 	sts	0x02B7, r13
    1112:	c0 92 b6 02 	sts	0x02B6, r12
    1116:	d0 92 b5 02 	sts	0x02B5, r13
    111a:	c0 92 b4 02 	sts	0x02B4, r12
		if(cmd_vel > 36){cmd_vel = 36;}
		if(cmd_vel < -36){cmd_vel = -36;}
		
		float s_out = -0.4928 * (cmd_vel) + 185.27;
		
		taskENTER_CRITICAL();
    111e:	0f b6       	in	r0, 0x3f	; 63
    1120:	f8 94       	cli
    1122:	0f 92       	push	r0
void PWM_timer3_Set_E4(u16 pwmDuty)
	{OCR3B = pwmDuty;}
    1124:	90 92 9b 00 	sts	0x009B, r9
    1128:	80 92 9a 00 	sts	0x009A, r8
		PWM_timer3_Set_E4((int)s_out);
		taskEXIT_CRITICAL();
    112c:	0f 90       	pop	r0
    112e:	0f be       	out	0x3f, r0	; 63
		if(cmd_vel > 36){cmd_vel = 36;}
		if(cmd_vel < -36){cmd_vel = -36;}
				
		float s_out = -0.5421 * (cmd_vel) + 188.41;

		taskENTER_CRITICAL();
    1130:	0f b6       	in	r0, 0x3f	; 63
    1132:	f8 94       	cli
    1134:	0f 92       	push	r0
void PWM_timer1_Set_LED(u16 pwmDuty)
	{OCR1B = pwmDuty;}
void PWM_timer2_Set_H6(u16 pwmDuty)
	{OCR2B = pwmDuty;}
void PWM_timer3_Set_E3(u16 pwmDuty)
	{OCR3A = pwmDuty;}
    1136:	b0 92 99 00 	sts	0x0099, r11
    113a:	a0 92 98 00 	sts	0x0098, r10
		PWM_timer3_Set_E3((int)s_out);
		taskEXIT_CRITICAL();
    113e:	0f 90       	pop	r0
    1140:	0f be       	out	0x3f, r0	; 63
    1142:	d8 cf       	rjmp	.-80     	; 0x10f4 <vRampVel+0xf4>

00001144 <vServoOsc>:
	}

}


void vServoOsc(){
    1144:	7f 92       	push	r7
    1146:	8f 92       	push	r8
    1148:	9f 92       	push	r9
    114a:	af 92       	push	r10
    114c:	bf 92       	push	r11
    114e:	cf 92       	push	r12
    1150:	df 92       	push	r13
    1152:	ef 92       	push	r14
    1154:	ff 92       	push	r15
    1156:	0f 93       	push	r16
    1158:	1f 93       	push	r17
    115a:	df 93       	push	r29
    115c:	cf 93       	push	r28
    115e:	00 d0       	rcall	.+0      	; 0x1160 <vServoOsc+0x1c>
    1160:	cd b7       	in	r28, 0x3d	; 61
    1162:	de b7       	in	r29, 0x3e	; 62
	sbi(TCCR4A,COM4A1);
	cbi(TCCR4A,COM4A0);
}
void PWM_timer4_On_H4(void)
{
	sbi(TCCR4A,COM4B1);
    1164:	80 91 a0 00 	lds	r24, 0x00A0
    1168:	80 62       	ori	r24, 0x20	; 32
    116a:	80 93 a0 00 	sts	0x00A0, r24
	cbi(TCCR4A,COM4B0);
    116e:	80 91 a0 00 	lds	r24, 0x00A0
    1172:	8f 7e       	andi	r24, 0xEF	; 239
    1174:	80 93 a0 00 	sts	0x00A0, r24
	sbi(TCCR3A,COM3C1);
	cbi(TCCR3A,COM3C0);
}
void PWM_timer4_On_H3(void)
{
	sbi(TCCR4A,COM4A1);
    1178:	80 91 a0 00 	lds	r24, 0x00A0
    117c:	80 68       	ori	r24, 0x80	; 128
    117e:	80 93 a0 00 	sts	0x00A0, r24
	cbi(TCCR4A,COM4A0);
    1182:	80 91 a0 00 	lds	r24, 0x00A0
    1186:	8f 7b       	andi	r24, 0xBF	; 191
    1188:	80 93 a0 00 	sts	0x00A0, r24
    118c:	0a e7       	ldi	r16, 0x7A	; 122
    118e:	10 e0       	ldi	r17, 0x00	; 0
void PWM_timer3_Set_E5(u16 pwmDuty)
	{OCR3C = pwmDuty;}
void PWM_timer4_Set_H3(u16 pwmDuty)
	{OCR4A = pwmDuty;}
void PWM_timer4_Set_H4(u16 pwmDuty)
	{OCR4B = pwmDuty;}
    1190:	5c ec       	ldi	r21, 0xCC	; 204
    1192:	85 2e       	mov	r8, r21
    1194:	91 2c       	mov	r9, r1
		taskENTER_CRITICAL();
	//	PWM_timer3_Set_E3(i);	//right
		PWM_timer4_Set_H3(h3duty);	//left sprayer //originally 204
		PWM_timer4_Set_H4(204);	//right sprayer
		taskEXIT_CRITICAL();
		vTaskDelayUntil(&xLastWakeTime, (spray_time / portTICK_RATE_MS));
    1196:	5e 01       	movw	r10, r28
    1198:	08 94       	sec
    119a:	a1 1c       	adc	r10, r1
    119c:	b1 1c       	adc	r11, r1
		PWM_timer4_Set_H4(135);	
		taskEXIT_CRITICAL();
		vTaskDelayUntil(&xLastWakeTime, (spray_time / portTICK_RATE_MS));
		*/

		rprintf("%d", h3duty);
    119e:	77 24       	eor	r7, r7
    11a0:	73 94       	inc	r7
    11a2:	45 e0       	ldi	r20, 0x05	; 5
    11a4:	c4 2e       	mov	r12, r20
    11a6:	41 e0       	ldi	r20, 0x01	; 1
    11a8:	d4 2e       	mov	r13, r20
		//rprintf(",");
		//rprintfNum(10, 5, 1, ' ', LEFTVel_current);
		rprintf("\n");
    11aa:	33 e0       	ldi	r19, 0x03	; 3
    11ac:	e3 2e       	mov	r14, r19
    11ae:	31 e0       	ldi	r19, 0x01	; 1
    11b0:	f3 2e       	mov	r15, r19
	spray_R_on();
	spray_L_on();
	uint16_t h3duty = 122;

	for(;;){
		if(h3duty > 1023){ h3duty = 0;}
    11b2:	84 e0       	ldi	r24, 0x04	; 4
    11b4:	00 30       	cpi	r16, 0x00	; 0
    11b6:	18 07       	cpc	r17, r24
    11b8:	10 f0       	brcs	.+4      	; 0x11be <vServoOsc+0x7a>
    11ba:	00 e0       	ldi	r16, 0x00	; 0
    11bc:	10 e0       	ldi	r17, 0x00	; 0
		taskENTER_CRITICAL();
    11be:	0f b6       	in	r0, 0x3f	; 63
    11c0:	f8 94       	cli
    11c2:	0f 92       	push	r0
void PWM_timer3_Set_E4(u16 pwmDuty)
	{OCR3B = pwmDuty;}
void PWM_timer3_Set_E5(u16 pwmDuty)
	{OCR3C = pwmDuty;}
void PWM_timer4_Set_H3(u16 pwmDuty)
	{OCR4A = pwmDuty;}
    11c4:	10 93 a9 00 	sts	0x00A9, r17
    11c8:	00 93 a8 00 	sts	0x00A8, r16
void PWM_timer4_Set_H4(u16 pwmDuty)
	{OCR4B = pwmDuty;}
    11cc:	90 92 ab 00 	sts	0x00AB, r9
    11d0:	80 92 aa 00 	sts	0x00AA, r8
	//	PWM_timer3_Set_E3(i);	//right
		PWM_timer4_Set_H3(h3duty);	//left sprayer //originally 204
		PWM_timer4_Set_H4(204);	//right sprayer
		taskEXIT_CRITICAL();
    11d4:	0f 90       	pop	r0
    11d6:	0f be       	out	0x3f, r0	; 63
		vTaskDelayUntil(&xLastWakeTime, (spray_time / portTICK_RATE_MS));
    11d8:	60 91 a5 02 	lds	r22, 0x02A5
    11dc:	70 91 a6 02 	lds	r23, 0x02A6
    11e0:	c5 01       	movw	r24, r10
    11e2:	0e 94 7c 16 	call	0x2cf8	; 0x2cf8 <vTaskDelayUntil>
		adj = uart1GetByte();
    11e6:	0e 94 33 26 	call	0x4c66	; 0x4c66 <uart1GetByte>
		if(adj == 'p'){ h3duty++;;}
    11ea:	80 37       	cpi	r24, 0x70	; 112
    11ec:	19 f4       	brne	.+6      	; 0x11f4 <vServoOsc+0xb0>
    11ee:	0f 5f       	subi	r16, 0xFF	; 255
    11f0:	1f 4f       	sbci	r17, 0xFF	; 255
    11f2:	04 c0       	rjmp	.+8      	; 0x11fc <vServoOsc+0xb8>
		else if(adj == 'l'){ h3duty--;}
    11f4:	8c 36       	cpi	r24, 0x6C	; 108
    11f6:	11 f4       	brne	.+4      	; 0x11fc <vServoOsc+0xb8>
    11f8:	01 50       	subi	r16, 0x01	; 1
    11fa:	10 40       	sbci	r17, 0x00	; 0
		PWM_timer4_Set_H4(135);	
		taskEXIT_CRITICAL();
		vTaskDelayUntil(&xLastWakeTime, (spray_time / portTICK_RATE_MS));
		*/

		rprintf("%d", h3duty);
    11fc:	00 d0       	rcall	.+0      	; 0x11fe <vServoOsc+0xba>
    11fe:	00 d0       	rcall	.+0      	; 0x1200 <vServoOsc+0xbc>
    1200:	0f 92       	push	r0
    1202:	ed b7       	in	r30, 0x3d	; 61
    1204:	fe b7       	in	r31, 0x3e	; 62
    1206:	31 96       	adiw	r30, 0x01	; 1
    1208:	ad b7       	in	r26, 0x3d	; 61
    120a:	be b7       	in	r27, 0x3e	; 62
    120c:	11 96       	adiw	r26, 0x01	; 1
    120e:	7c 92       	st	X, r7
    1210:	d2 82       	std	Z+2, r13	; 0x02
    1212:	c1 82       	std	Z+1, r12	; 0x01
    1214:	14 83       	std	Z+4, r17	; 0x04
    1216:	03 83       	std	Z+3, r16	; 0x03
    1218:	0e 94 86 2a 	call	0x550c	; 0x550c <rprintf1RamRom>
		//rprintf(",");
		//rprintfNum(10, 5, 1, ' ', LEFTVel_current);
		rprintf("\n");
    121c:	0f 90       	pop	r0
    121e:	0f 90       	pop	r0
    1220:	ed b7       	in	r30, 0x3d	; 61
    1222:	fe b7       	in	r31, 0x3e	; 62
    1224:	71 82       	std	Z+1, r7	; 0x01
    1226:	f3 82       	std	Z+3, r15	; 0x03
    1228:	e2 82       	std	Z+2, r14	; 0x02
    122a:	0e 94 86 2a 	call	0x550c	; 0x550c <rprintf1RamRom>
	
		h3duty++;
    122e:	0f 5f       	subi	r16, 0xFF	; 255
    1230:	1f 4f       	sbci	r17, 0xFF	; 255
    1232:	0f 90       	pop	r0
    1234:	0f 90       	pop	r0
    1236:	0f 90       	pop	r0
    1238:	bc cf       	rjmp	.-136    	; 0x11b2 <vServoOsc+0x6e>

0000123a <vLight1On>:
		PORT_OFF(PORTA, 0);
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
		
	}
}
void vLight1On(void *pvParameters){
    123a:	0f 93       	push	r16
    123c:	1f 93       	push	r17
    123e:	df 93       	push	r29
    1240:	cf 93       	push	r28
    1242:	00 d0       	rcall	.+0      	; 0x1244 <vLight1On+0xa>
    1244:	cd b7       	in	r28, 0x3d	; 61
    1246:	de b7       	in	r29, 0x3e	; 62
	portTickType xLastWakeTime;
	for(;;){
		LED_on();
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
    1248:	8e 01       	movw	r16, r28
    124a:	0f 5f       	subi	r16, 0xFF	; 255
    124c:	1f 4f       	sbci	r17, 0xFF	; 255
//***************STATUS LED**************
//tank test
void LED_off(void)
	{PORT_ON(PORTB,6);}
void LED_on(void)
	{PORT_OFF(PORTB,6);}
    124e:	2e 98       	cbi	0x05, 6	; 5
    1250:	c8 01       	movw	r24, r16
    1252:	62 e3       	ldi	r22, 0x32	; 50
    1254:	70 e0       	ldi	r23, 0x00	; 0
    1256:	0e 94 7c 16 	call	0x2cf8	; 0x2cf8 <vTaskDelayUntil>


//***************STATUS LED**************
//tank test
void LED_off(void)
	{PORT_ON(PORTB,6);}
    125a:	2e 9a       	sbi	0x05, 6	; 5
		LED_off();
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));	}
    125c:	c8 01       	movw	r24, r16
    125e:	62 e3       	ldi	r22, 0x32	; 50
    1260:	70 e0       	ldi	r23, 0x00	; 0
    1262:	0e 94 7c 16 	call	0x2cf8	; 0x2cf8 <vTaskDelayUntil>
    1266:	f3 cf       	rjmp	.-26     	; 0x124e <vLight1On+0x14>

00001268 <vLight0On>:
		vTaskDelayUntil(&xLastWakeTime, (100 / portTICK_RATE_MS));
	}

}

void vLight0On(void *pvParameters){
    1268:	0f 93       	push	r16
    126a:	1f 93       	push	r17
    126c:	df 93       	push	r29
    126e:	cf 93       	push	r28
    1270:	00 d0       	rcall	.+0      	; 0x1272 <vLight0On+0xa>
    1272:	cd b7       	in	r28, 0x3d	; 61
    1274:	de b7       	in	r29, 0x3e	; 62
	portTickType xLastWakeTime;
	for(;;){
		PORT_ON(PORTA, 0);
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
    1276:	8e 01       	movw	r16, r28
    1278:	0f 5f       	subi	r16, 0xFF	; 255
    127a:	1f 4f       	sbci	r17, 0xFF	; 255
}

void vLight0On(void *pvParameters){
	portTickType xLastWakeTime;
	for(;;){
		PORT_ON(PORTA, 0);
    127c:	10 9a       	sbi	0x02, 0	; 2
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
    127e:	c8 01       	movw	r24, r16
    1280:	62 e3       	ldi	r22, 0x32	; 50
    1282:	70 e0       	ldi	r23, 0x00	; 0
    1284:	0e 94 7c 16 	call	0x2cf8	; 0x2cf8 <vTaskDelayUntil>
		//taskYIELD();	
		PORT_OFF(PORTA, 0);
    1288:	10 98       	cbi	0x02, 0	; 2
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
    128a:	c8 01       	movw	r24, r16
    128c:	62 e3       	ldi	r22, 0x32	; 50
    128e:	70 e0       	ldi	r23, 0x00	; 0
    1290:	0e 94 7c 16 	call	0x2cf8	; 0x2cf8 <vTaskDelayUntil>
    1294:	f3 cf       	rjmp	.-26     	; 0x127c <vLight0On+0x14>

00001296 <vPID>:
			
		vTaskDelayUntil(&xLastWakeTime, (100 / portTICK_RATE_MS));
	}
}

void vPID(void* pvParameters){
    1296:	2f 92       	push	r2
    1298:	3f 92       	push	r3
    129a:	4f 92       	push	r4
    129c:	5f 92       	push	r5
    129e:	6f 92       	push	r6
    12a0:	7f 92       	push	r7
    12a2:	8f 92       	push	r8
    12a4:	9f 92       	push	r9
    12a6:	af 92       	push	r10
    12a8:	bf 92       	push	r11
    12aa:	cf 92       	push	r12
    12ac:	df 92       	push	r13
    12ae:	ef 92       	push	r14
    12b0:	ff 92       	push	r15
    12b2:	0f 93       	push	r16
    12b4:	1f 93       	push	r17
    12b6:	df 93       	push	r29
    12b8:	cf 93       	push	r28
    12ba:	cd b7       	in	r28, 0x3d	; 61
    12bc:	de b7       	in	r29, 0x3e	; 62
    12be:	62 97       	sbiw	r28, 0x12	; 18
    12c0:	0f b6       	in	r0, 0x3f	; 63
    12c2:	f8 94       	cli
    12c4:	de bf       	out	0x3e, r29	; 62
    12c6:	0f be       	out	0x3f, r0	; 63
    12c8:	cd bf       	out	0x3d, r28	; 61
	sbi(TCCR3A,COM3A1);
	cbi(TCCR3A,COM3A0);
}
void PWM_timer3_On_E4(void)
{
	sbi(TCCR3A,COM3B1);
    12ca:	80 91 90 00 	lds	r24, 0x0090
    12ce:	80 62       	ori	r24, 0x20	; 32
    12d0:	80 93 90 00 	sts	0x0090, r24
	cbi(TCCR3A,COM3B0);
    12d4:	80 91 90 00 	lds	r24, 0x0090
    12d8:	8f 7e       	andi	r24, 0xEF	; 239
    12da:	80 93 90 00 	sts	0x0090, r24
	sbi(TCCR2A,COM2B1);
	cbi(TCCR2A,COM2B0);
}
void PWM_timer3_On_E3(void)
{
	sbi(TCCR3A,COM3A1);
    12de:	80 91 90 00 	lds	r24, 0x0090
    12e2:	80 68       	ori	r24, 0x80	; 128
    12e4:	80 93 90 00 	sts	0x0090, r24
	cbi(TCCR3A,COM3A0);
    12e8:	80 91 90 00 	lds	r24, 0x0090
    12ec:	8f 7b       	andi	r24, 0xBF	; 191
    12ee:	80 93 90 00 	sts	0x0090, r24
    12f2:	80 e0       	ldi	r24, 0x00	; 0
    12f4:	90 e0       	ldi	r25, 0x00	; 0
    12f6:	a0 e0       	ldi	r26, 0x00	; 0
    12f8:	b0 e0       	ldi	r27, 0x00	; 0
    12fa:	8b 87       	std	Y+11, r24	; 0x0b
    12fc:	9c 87       	std	Y+12, r25	; 0x0c
    12fe:	ad 87       	std	Y+13, r26	; 0x0d
    1300:	be 87       	std	Y+14, r27	; 0x0e
    1302:	8b 83       	std	Y+3, r24	; 0x03
    1304:	9c 83       	std	Y+4, r25	; 0x04
    1306:	ad 83       	std	Y+5, r26	; 0x05
    1308:	be 83       	std	Y+6, r27	; 0x06
			wheel_L(v_out_L);
			wheel_R(-v_out_R);
			taskEXIT_CRITICAL();
			

		vTaskDelayUntil(&xLastWakeTime, (100 / portTICK_RATE_MS));
    130a:	1e 01       	movw	r2, r28
    130c:	08 94       	sec
    130e:	21 1c       	adc	r2, r1
    1310:	31 1c       	adc	r3, r1
	wheel_L_on();
	wheel_R_on();

	for(;;){

			error_L = v_left - LEFTVel_current;
    1312:	c0 90 b8 02 	lds	r12, 0x02B8
    1316:	d0 90 b9 02 	lds	r13, 0x02B9
    131a:	60 91 b4 02 	lds	r22, 0x02B4
    131e:	70 91 b5 02 	lds	r23, 0x02B5
    1322:	6c 19       	sub	r22, r12
    1324:	7d 09       	sbc	r23, r13
    1326:	88 27       	eor	r24, r24
    1328:	77 fd       	sbrc	r23, 7
    132a:	80 95       	com	r24
    132c:	98 2f       	mov	r25, r24
    132e:	0e 94 c3 2e 	call	0x5d86	; 0x5d86 <__floatsisf>
    1332:	6f 87       	std	Y+15, r22	; 0x0f
    1334:	78 8b       	std	Y+16, r23	; 0x10
    1336:	89 8b       	std	Y+17, r24	; 0x11
    1338:	9a 8b       	std	Y+18, r25	; 0x12
			error_R = v_right - (-RIGHTVel_current);
    133a:	60 91 c5 02 	lds	r22, 0x02C5
    133e:	70 91 c6 02 	lds	r23, 0x02C6
    1342:	20 91 b6 02 	lds	r18, 0x02B6
    1346:	30 91 b7 02 	lds	r19, 0x02B7
    134a:	62 0f       	add	r22, r18
    134c:	73 1f       	adc	r23, r19
    134e:	88 27       	eor	r24, r24
    1350:	77 fd       	sbrc	r23, 7
    1352:	80 95       	com	r24
    1354:	98 2f       	mov	r25, r24
    1356:	0e 94 c3 2e 	call	0x5d86	; 0x5d86 <__floatsisf>
    135a:	6f 83       	std	Y+7, r22	; 0x07
    135c:	78 87       	std	Y+8, r23	; 0x08
    135e:	89 87       	std	Y+9, r24	; 0x09
    1360:	9a 87       	std	Y+10, r25	; 0x0a
			
			v_out_L = KP_L*error_L + KI_L*acc_error_L;
    1362:	6f 85       	ldd	r22, Y+15	; 0x0f
    1364:	78 89       	ldd	r23, Y+16	; 0x10
    1366:	89 89       	ldd	r24, Y+17	; 0x11
    1368:	9a 89       	ldd	r25, Y+18	; 0x12
    136a:	2c e4       	ldi	r18, 0x4C	; 76
    136c:	33 e9       	ldi	r19, 0x93	; 147
    136e:	49 e1       	ldi	r20, 0x19	; 25
    1370:	5c e3       	ldi	r21, 0x3C	; 60
    1372:	0e 94 77 2f 	call	0x5eee	; 0x5eee <__mulsf3>
    1376:	7b 01       	movw	r14, r22
    1378:	8c 01       	movw	r16, r24
    137a:	6b 85       	ldd	r22, Y+11	; 0x0b
    137c:	7c 85       	ldd	r23, Y+12	; 0x0c
    137e:	8d 85       	ldd	r24, Y+13	; 0x0d
    1380:	9e 85       	ldd	r25, Y+14	; 0x0e
    1382:	20 ea       	ldi	r18, 0xA0	; 160
    1384:	33 e0       	ldi	r19, 0x03	; 3
    1386:	4f eb       	ldi	r20, 0xBF	; 191
    1388:	5c e3       	ldi	r21, 0x3C	; 60
    138a:	0e 94 77 2f 	call	0x5eee	; 0x5eee <__mulsf3>
    138e:	9b 01       	movw	r18, r22
    1390:	ac 01       	movw	r20, r24
    1392:	c8 01       	movw	r24, r16
    1394:	b7 01       	movw	r22, r14
    1396:	0e 94 c0 2d 	call	0x5b80	; 0x5b80 <__addsf3>
    139a:	4b 01       	movw	r8, r22
    139c:	5c 01       	movw	r10, r24
			v_out_R = KP_R*error_R + KI_R*acc_error_R;
    139e:	6f 81       	ldd	r22, Y+7	; 0x07
    13a0:	78 85       	ldd	r23, Y+8	; 0x08
    13a2:	89 85       	ldd	r24, Y+9	; 0x09
    13a4:	9a 85       	ldd	r25, Y+10	; 0x0a
    13a6:	2d e8       	ldi	r18, 0x8D	; 141
    13a8:	30 e9       	ldi	r19, 0x90	; 144
    13aa:	48 e0       	ldi	r20, 0x08	; 8
    13ac:	5c e3       	ldi	r21, 0x3C	; 60
    13ae:	0e 94 77 2f 	call	0x5eee	; 0x5eee <__mulsf3>
    13b2:	7b 01       	movw	r14, r22
    13b4:	8c 01       	movw	r16, r24
    13b6:	6b 81       	ldd	r22, Y+3	; 0x03
    13b8:	7c 81       	ldd	r23, Y+4	; 0x04
    13ba:	8d 81       	ldd	r24, Y+5	; 0x05
    13bc:	9e 81       	ldd	r25, Y+6	; 0x06
    13be:	26 e1       	ldi	r18, 0x16	; 22
    13c0:	35 e4       	ldi	r19, 0x45	; 69
    13c2:	40 e8       	ldi	r20, 0x80	; 128
    13c4:	5c e3       	ldi	r21, 0x3C	; 60
    13c6:	0e 94 77 2f 	call	0x5eee	; 0x5eee <__mulsf3>
    13ca:	9b 01       	movw	r18, r22
    13cc:	ac 01       	movw	r20, r24
    13ce:	c8 01       	movw	r24, r16
    13d0:	b7 01       	movw	r22, r14
    13d2:	0e 94 c0 2d 	call	0x5b80	; 0x5b80 <__addsf3>
    13d6:	2b 01       	movw	r4, r22
    13d8:	3c 01       	movw	r6, r24
		
			acc_error_L += error_L;
			acc_error_R += error_R;

			taskENTER_CRITICAL();
    13da:	0f b6       	in	r0, 0x3f	; 63
    13dc:	f8 94       	cli
    13de:	0f 92       	push	r0
			rprintf("LEFTVel: %d\tv_out_L: %d\t", LEFTVel_current, (int)v_out_L);
    13e0:	ad b7       	in	r26, 0x3d	; 61
    13e2:	be b7       	in	r27, 0x3e	; 62
    13e4:	17 97       	sbiw	r26, 0x07	; 7
    13e6:	0f b6       	in	r0, 0x3f	; 63
    13e8:	f8 94       	cli
    13ea:	be bf       	out	0x3e, r27	; 62
    13ec:	0f be       	out	0x3f, r0	; 63
    13ee:	ad bf       	out	0x3d, r26	; 61
    13f0:	0d b7       	in	r16, 0x3d	; 61
    13f2:	1e b7       	in	r17, 0x3e	; 62
    13f4:	0f 5f       	subi	r16, 0xFF	; 255
    13f6:	1f 4f       	sbci	r17, 0xFF	; 255
    13f8:	e1 e0       	ldi	r30, 0x01	; 1
    13fa:	11 96       	adiw	r26, 0x01	; 1
    13fc:	ec 93       	st	X, r30
    13fe:	e6 e2       	ldi	r30, 0x26	; 38
    1400:	f1 e0       	ldi	r31, 0x01	; 1
    1402:	d8 01       	movw	r26, r16
    1404:	12 96       	adiw	r26, 0x02	; 2
    1406:	fc 93       	st	X, r31
    1408:	ee 93       	st	-X, r30
    140a:	11 97       	sbiw	r26, 0x01	; 1
    140c:	14 96       	adiw	r26, 0x04	; 4
    140e:	dc 92       	st	X, r13
    1410:	ce 92       	st	-X, r12
    1412:	13 97       	sbiw	r26, 0x03	; 3
    1414:	c5 01       	movw	r24, r10
    1416:	b4 01       	movw	r22, r8
    1418:	0e 94 90 2e 	call	0x5d20	; 0x5d20 <__fixsfsi>
    141c:	d8 01       	movw	r26, r16
    141e:	16 96       	adiw	r26, 0x06	; 6
    1420:	7c 93       	st	X, r23
    1422:	6e 93       	st	-X, r22
    1424:	15 97       	sbiw	r26, 0x05	; 5
    1426:	0e 94 86 2a 	call	0x550c	; 0x550c <rprintf1RamRom>
			rprintf("RIGHTVel: %d\tv_out_R: %d\n",-RIGHTVel_current,(int)v_out_R);
    142a:	0d b7       	in	r16, 0x3d	; 61
    142c:	1e b7       	in	r17, 0x3e	; 62
    142e:	0f 5f       	subi	r16, 0xFF	; 255
    1430:	1f 4f       	sbci	r17, 0xFF	; 255
    1432:	81 e0       	ldi	r24, 0x01	; 1
    1434:	ed b7       	in	r30, 0x3d	; 61
    1436:	fe b7       	in	r31, 0x3e	; 62
    1438:	81 83       	std	Z+1, r24	; 0x01
    143a:	ec e0       	ldi	r30, 0x0C	; 12
    143c:	f1 e0       	ldi	r31, 0x01	; 1
    143e:	d8 01       	movw	r26, r16
    1440:	12 96       	adiw	r26, 0x02	; 2
    1442:	fc 93       	st	X, r31
    1444:	ee 93       	st	-X, r30
    1446:	11 97       	sbiw	r26, 0x01	; 1
    1448:	80 91 c5 02 	lds	r24, 0x02C5
    144c:	90 91 c6 02 	lds	r25, 0x02C6
    1450:	90 95       	com	r25
    1452:	81 95       	neg	r24
    1454:	9f 4f       	sbci	r25, 0xFF	; 255
    1456:	14 96       	adiw	r26, 0x04	; 4
    1458:	9c 93       	st	X, r25
    145a:	8e 93       	st	-X, r24
    145c:	13 97       	sbiw	r26, 0x03	; 3
    145e:	c3 01       	movw	r24, r6
    1460:	b2 01       	movw	r22, r4
    1462:	0e 94 90 2e 	call	0x5d20	; 0x5d20 <__fixsfsi>
    1466:	d8 01       	movw	r26, r16
    1468:	16 96       	adiw	r26, 0x06	; 6
    146a:	7c 93       	st	X, r23
    146c:	6e 93       	st	-X, r22
    146e:	15 97       	sbiw	r26, 0x05	; 5
    1470:	0e 94 86 2a 	call	0x550c	; 0x550c <rprintf1RamRom>
			taskEXIT_CRITICAL();
    1474:	0f 90       	pop	r0
    1476:	0f be       	out	0x3f, r0	; 63

			if(v_out_L > 36){
    1478:	ed b7       	in	r30, 0x3d	; 61
    147a:	fe b7       	in	r31, 0x3e	; 62
    147c:	37 96       	adiw	r30, 0x07	; 7
    147e:	0f b6       	in	r0, 0x3f	; 63
    1480:	f8 94       	cli
    1482:	fe bf       	out	0x3e, r31	; 62
    1484:	0f be       	out	0x3f, r0	; 63
    1486:	ed bf       	out	0x3d, r30	; 61
    1488:	c5 01       	movw	r24, r10
    148a:	b4 01       	movw	r22, r8
    148c:	20 e0       	ldi	r18, 0x00	; 0
    148e:	30 e0       	ldi	r19, 0x00	; 0
    1490:	40 e1       	ldi	r20, 0x10	; 16
    1492:	52 e4       	ldi	r21, 0x42	; 66
    1494:	0e 94 73 2f 	call	0x5ee6	; 0x5ee6 <__gesf2>
    1498:	18 16       	cp	r1, r24
    149a:	9c f4       	brge	.+38     	; 0x14c2 <vPID+0x22c>
    149c:	80 e0       	ldi	r24, 0x00	; 0
    149e:	90 e8       	ldi	r25, 0x80	; 128
    14a0:	ab eb       	ldi	r26, 0xBB	; 187
    14a2:	b4 e4       	ldi	r27, 0x44	; 68
    14a4:	8b 87       	std	Y+11, r24	; 0x0b
    14a6:	9c 87       	std	Y+12, r25	; 0x0c
    14a8:	ad 87       	std	Y+13, r26	; 0x0d
    14aa:	be 87       	std	Y+14, r27	; 0x0e
    14ac:	0f 2e       	mov	r0, r31
    14ae:	f0 e0       	ldi	r31, 0x00	; 0
    14b0:	8f 2e       	mov	r8, r31
    14b2:	f0 e0       	ldi	r31, 0x00	; 0
    14b4:	9f 2e       	mov	r9, r31
    14b6:	f0 e1       	ldi	r31, 0x10	; 16
    14b8:	af 2e       	mov	r10, r31
    14ba:	f2 e4       	ldi	r31, 0x42	; 66
    14bc:	bf 2e       	mov	r11, r31
    14be:	f0 2d       	mov	r31, r0
    14c0:	2b c0       	rjmp	.+86     	; 0x1518 <vPID+0x282>
				v_out_L = 36;
				acc_error_L = 1500;
				}
			else if(v_out_L < -36){
    14c2:	c5 01       	movw	r24, r10
    14c4:	b4 01       	movw	r22, r8
    14c6:	20 e0       	ldi	r18, 0x00	; 0
    14c8:	30 e0       	ldi	r19, 0x00	; 0
    14ca:	40 e1       	ldi	r20, 0x10	; 16
    14cc:	52 ec       	ldi	r21, 0xC2	; 194
    14ce:	0e 94 24 2e 	call	0x5c48	; 0x5c48 <__cmpsf2>
    14d2:	88 23       	and	r24, r24
    14d4:	9c f4       	brge	.+38     	; 0x14fc <vPID+0x266>
    14d6:	80 e0       	ldi	r24, 0x00	; 0
    14d8:	90 e8       	ldi	r25, 0x80	; 128
    14da:	ab eb       	ldi	r26, 0xBB	; 187
    14dc:	b4 ec       	ldi	r27, 0xC4	; 196
    14de:	8b 87       	std	Y+11, r24	; 0x0b
    14e0:	9c 87       	std	Y+12, r25	; 0x0c
    14e2:	ad 87       	std	Y+13, r26	; 0x0d
    14e4:	be 87       	std	Y+14, r27	; 0x0e
    14e6:	0f 2e       	mov	r0, r31
    14e8:	f0 e0       	ldi	r31, 0x00	; 0
    14ea:	8f 2e       	mov	r8, r31
    14ec:	f0 e0       	ldi	r31, 0x00	; 0
    14ee:	9f 2e       	mov	r9, r31
    14f0:	f0 e1       	ldi	r31, 0x10	; 16
    14f2:	af 2e       	mov	r10, r31
    14f4:	f2 ec       	ldi	r31, 0xC2	; 194
    14f6:	bf 2e       	mov	r11, r31
    14f8:	f0 2d       	mov	r31, r0
    14fa:	0e c0       	rjmp	.+28     	; 0x1518 <vPID+0x282>
			error_R = v_right - (-RIGHTVel_current);
			
			v_out_L = KP_L*error_L + KI_L*acc_error_L;
			v_out_R = KP_R*error_R + KI_R*acc_error_R;
		
			acc_error_L += error_L;
    14fc:	6b 85       	ldd	r22, Y+11	; 0x0b
    14fe:	7c 85       	ldd	r23, Y+12	; 0x0c
    1500:	8d 85       	ldd	r24, Y+13	; 0x0d
    1502:	9e 85       	ldd	r25, Y+14	; 0x0e
    1504:	2f 85       	ldd	r18, Y+15	; 0x0f
    1506:	38 89       	ldd	r19, Y+16	; 0x10
    1508:	49 89       	ldd	r20, Y+17	; 0x11
    150a:	5a 89       	ldd	r21, Y+18	; 0x12
    150c:	0e 94 c0 2d 	call	0x5b80	; 0x5b80 <__addsf3>
    1510:	6b 87       	std	Y+11, r22	; 0x0b
    1512:	7c 87       	std	Y+12, r23	; 0x0c
    1514:	8d 87       	std	Y+13, r24	; 0x0d
    1516:	9e 87       	std	Y+14, r25	; 0x0e
			else if(v_out_L < -36){
				v_out_L = -36;
				acc_error_L = -1500;
				}

			if(v_out_R > 36){
    1518:	c3 01       	movw	r24, r6
    151a:	b2 01       	movw	r22, r4
    151c:	20 e0       	ldi	r18, 0x00	; 0
    151e:	30 e0       	ldi	r19, 0x00	; 0
    1520:	40 e1       	ldi	r20, 0x10	; 16
    1522:	52 e4       	ldi	r21, 0x42	; 66
    1524:	0e 94 73 2f 	call	0x5ee6	; 0x5ee6 <__gesf2>
    1528:	18 16       	cp	r1, r24
    152a:	9c f4       	brge	.+38     	; 0x1552 <vPID+0x2bc>
    152c:	80 e0       	ldi	r24, 0x00	; 0
    152e:	90 e8       	ldi	r25, 0x80	; 128
    1530:	ab eb       	ldi	r26, 0xBB	; 187
    1532:	b4 e4       	ldi	r27, 0x44	; 68
    1534:	8b 83       	std	Y+3, r24	; 0x03
    1536:	9c 83       	std	Y+4, r25	; 0x04
    1538:	ad 83       	std	Y+5, r26	; 0x05
    153a:	be 83       	std	Y+6, r27	; 0x06
    153c:	0f 2e       	mov	r0, r31
    153e:	f0 e0       	ldi	r31, 0x00	; 0
    1540:	4f 2e       	mov	r4, r31
    1542:	f0 e0       	ldi	r31, 0x00	; 0
    1544:	5f 2e       	mov	r5, r31
    1546:	f0 e1       	ldi	r31, 0x10	; 16
    1548:	6f 2e       	mov	r6, r31
    154a:	f2 e4       	ldi	r31, 0x42	; 66
    154c:	7f 2e       	mov	r7, r31
    154e:	f0 2d       	mov	r31, r0
    1550:	2b c0       	rjmp	.+86     	; 0x15a8 <vPID+0x312>
				v_out_R = 36;
				acc_error_R = 1500;
				}
			else if(v_out_R < -36){
    1552:	c3 01       	movw	r24, r6
    1554:	b2 01       	movw	r22, r4
    1556:	20 e0       	ldi	r18, 0x00	; 0
    1558:	30 e0       	ldi	r19, 0x00	; 0
    155a:	40 e1       	ldi	r20, 0x10	; 16
    155c:	52 ec       	ldi	r21, 0xC2	; 194
    155e:	0e 94 24 2e 	call	0x5c48	; 0x5c48 <__cmpsf2>
    1562:	88 23       	and	r24, r24
    1564:	9c f4       	brge	.+38     	; 0x158c <vPID+0x2f6>
    1566:	80 e0       	ldi	r24, 0x00	; 0
    1568:	90 e8       	ldi	r25, 0x80	; 128
    156a:	ab eb       	ldi	r26, 0xBB	; 187
    156c:	b4 ec       	ldi	r27, 0xC4	; 196
    156e:	8b 83       	std	Y+3, r24	; 0x03
    1570:	9c 83       	std	Y+4, r25	; 0x04
    1572:	ad 83       	std	Y+5, r26	; 0x05
    1574:	be 83       	std	Y+6, r27	; 0x06
    1576:	0f 2e       	mov	r0, r31
    1578:	f0 e0       	ldi	r31, 0x00	; 0
    157a:	4f 2e       	mov	r4, r31
    157c:	f0 e0       	ldi	r31, 0x00	; 0
    157e:	5f 2e       	mov	r5, r31
    1580:	f0 e1       	ldi	r31, 0x10	; 16
    1582:	6f 2e       	mov	r6, r31
    1584:	f2 ec       	ldi	r31, 0xC2	; 194
    1586:	7f 2e       	mov	r7, r31
    1588:	f0 2d       	mov	r31, r0
    158a:	0e c0       	rjmp	.+28     	; 0x15a8 <vPID+0x312>
			
			v_out_L = KP_L*error_L + KI_L*acc_error_L;
			v_out_R = KP_R*error_R + KI_R*acc_error_R;
		
			acc_error_L += error_L;
			acc_error_R += error_R;
    158c:	6b 81       	ldd	r22, Y+3	; 0x03
    158e:	7c 81       	ldd	r23, Y+4	; 0x04
    1590:	8d 81       	ldd	r24, Y+5	; 0x05
    1592:	9e 81       	ldd	r25, Y+6	; 0x06
    1594:	2f 81       	ldd	r18, Y+7	; 0x07
    1596:	38 85       	ldd	r19, Y+8	; 0x08
    1598:	49 85       	ldd	r20, Y+9	; 0x09
    159a:	5a 85       	ldd	r21, Y+10	; 0x0a
    159c:	0e 94 c0 2d 	call	0x5b80	; 0x5b80 <__addsf3>
    15a0:	6b 83       	std	Y+3, r22	; 0x03
    15a2:	7c 83       	std	Y+4, r23	; 0x04
    15a4:	8d 83       	std	Y+5, r24	; 0x05
    15a6:	9e 83       	std	Y+6, r25	; 0x06
				v_out_R = -36;
				acc_error_R = -1500;
				}
			
			
			taskENTER_CRITICAL();
    15a8:	0f b6       	in	r0, 0x3f	; 63
    15aa:	f8 94       	cli
    15ac:	0f 92       	push	r0

/*************************************************/


void wheel_L(float cmd_vel){
		if(cmd_vel > 36){cmd_vel = 36;}
    15ae:	c5 01       	movw	r24, r10
    15b0:	b4 01       	movw	r22, r8
    15b2:	20 e0       	ldi	r18, 0x00	; 0
    15b4:	30 e0       	ldi	r19, 0x00	; 0
    15b6:	40 e1       	ldi	r20, 0x10	; 16
    15b8:	52 e4       	ldi	r21, 0x42	; 66
    15ba:	0e 94 73 2f 	call	0x5ee6	; 0x5ee6 <__gesf2>
    15be:	18 16       	cp	r1, r24
    15c0:	5c f4       	brge	.+22     	; 0x15d8 <vPID+0x342>
    15c2:	0f 2e       	mov	r0, r31
    15c4:	f0 e0       	ldi	r31, 0x00	; 0
    15c6:	8f 2e       	mov	r8, r31
    15c8:	f0 e0       	ldi	r31, 0x00	; 0
    15ca:	9f 2e       	mov	r9, r31
    15cc:	f0 e1       	ldi	r31, 0x10	; 16
    15ce:	af 2e       	mov	r10, r31
    15d0:	f2 e4       	ldi	r31, 0x42	; 66
    15d2:	bf 2e       	mov	r11, r31
    15d4:	f0 2d       	mov	r31, r0
    15d6:	14 c0       	rjmp	.+40     	; 0x1600 <vPID+0x36a>
		if(cmd_vel < -36){cmd_vel = -36;}
    15d8:	c5 01       	movw	r24, r10
    15da:	b4 01       	movw	r22, r8
    15dc:	20 e0       	ldi	r18, 0x00	; 0
    15de:	30 e0       	ldi	r19, 0x00	; 0
    15e0:	40 e1       	ldi	r20, 0x10	; 16
    15e2:	52 ec       	ldi	r21, 0xC2	; 194
    15e4:	0e 94 24 2e 	call	0x5c48	; 0x5c48 <__cmpsf2>
    15e8:	88 23       	and	r24, r24
    15ea:	54 f4       	brge	.+20     	; 0x1600 <vPID+0x36a>
    15ec:	0f 2e       	mov	r0, r31
    15ee:	f0 e0       	ldi	r31, 0x00	; 0
    15f0:	8f 2e       	mov	r8, r31
    15f2:	f0 e0       	ldi	r31, 0x00	; 0
    15f4:	9f 2e       	mov	r9, r31
    15f6:	f0 e1       	ldi	r31, 0x10	; 16
    15f8:	af 2e       	mov	r10, r31
    15fa:	f2 ec       	ldi	r31, 0xC2	; 194
    15fc:	bf 2e       	mov	r11, r31
    15fe:	f0 2d       	mov	r31, r0
		
		float s_out = -0.4928 * (cmd_vel) + 185.27;
		
		taskENTER_CRITICAL();
    1600:	0f b6       	in	r0, 0x3f	; 63
    1602:	f8 94       	cli
    1604:	0f 92       	push	r0
		PWM_timer3_Set_E4((int)s_out);
    1606:	c5 01       	movw	r24, r10
    1608:	b4 01       	movw	r22, r8
    160a:	28 e4       	ldi	r18, 0x48	; 72
    160c:	30 e5       	ldi	r19, 0x50	; 80
    160e:	4c ef       	ldi	r20, 0xFC	; 252
    1610:	5e eb       	ldi	r21, 0xBE	; 190
    1612:	0e 94 77 2f 	call	0x5eee	; 0x5eee <__mulsf3>
    1616:	2f e1       	ldi	r18, 0x1F	; 31
    1618:	35 e4       	ldi	r19, 0x45	; 69
    161a:	49 e3       	ldi	r20, 0x39	; 57
    161c:	53 e4       	ldi	r21, 0x43	; 67
    161e:	0e 94 c0 2d 	call	0x5b80	; 0x5b80 <__addsf3>
    1622:	0e 94 90 2e 	call	0x5d20	; 0x5d20 <__fixsfsi>
void PWM_timer2_Set_H6(u16 pwmDuty)
	{OCR2B = pwmDuty;}
void PWM_timer3_Set_E3(u16 pwmDuty)
	{OCR3A = pwmDuty;}
void PWM_timer3_Set_E4(u16 pwmDuty)
	{OCR3B = pwmDuty;}
    1626:	70 93 9b 00 	sts	0x009B, r23
    162a:	60 93 9a 00 	sts	0x009A, r22
		taskEXIT_CRITICAL();
    162e:	0f 90       	pop	r0
    1630:	0f be       	out	0x3f, r0	; 63
				}
			
			
			taskENTER_CRITICAL();
			wheel_L(v_out_L);
			wheel_R(-v_out_R);
    1632:	83 01       	movw	r16, r6
    1634:	72 01       	movw	r14, r4
    1636:	17 fb       	bst	r17, 7
    1638:	10 95       	com	r17
    163a:	17 f9       	bld	r17, 7
    163c:	10 95       	com	r17


}

void wheel_R(float cmd_vel){
		if(cmd_vel > 36){cmd_vel = 36;}
    163e:	c8 01       	movw	r24, r16
    1640:	b7 01       	movw	r22, r14
    1642:	20 e0       	ldi	r18, 0x00	; 0
    1644:	30 e0       	ldi	r19, 0x00	; 0
    1646:	40 e1       	ldi	r20, 0x10	; 16
    1648:	52 e4       	ldi	r21, 0x42	; 66
    164a:	0e 94 73 2f 	call	0x5ee6	; 0x5ee6 <__gesf2>
    164e:	18 16       	cp	r1, r24
    1650:	5c f4       	brge	.+22     	; 0x1668 <vPID+0x3d2>
    1652:	0f 2e       	mov	r0, r31
    1654:	f0 e0       	ldi	r31, 0x00	; 0
    1656:	ef 2e       	mov	r14, r31
    1658:	f0 e0       	ldi	r31, 0x00	; 0
    165a:	ff 2e       	mov	r15, r31
    165c:	f0 e1       	ldi	r31, 0x10	; 16
    165e:	0f 2f       	mov	r16, r31
    1660:	f2 e4       	ldi	r31, 0x42	; 66
    1662:	1f 2f       	mov	r17, r31
    1664:	f0 2d       	mov	r31, r0
    1666:	14 c0       	rjmp	.+40     	; 0x1690 <vPID+0x3fa>
		if(cmd_vel < -36){cmd_vel = -36;}
    1668:	c8 01       	movw	r24, r16
    166a:	b7 01       	movw	r22, r14
    166c:	20 e0       	ldi	r18, 0x00	; 0
    166e:	30 e0       	ldi	r19, 0x00	; 0
    1670:	40 e1       	ldi	r20, 0x10	; 16
    1672:	52 ec       	ldi	r21, 0xC2	; 194
    1674:	0e 94 24 2e 	call	0x5c48	; 0x5c48 <__cmpsf2>
    1678:	88 23       	and	r24, r24
    167a:	54 f4       	brge	.+20     	; 0x1690 <vPID+0x3fa>
    167c:	0f 2e       	mov	r0, r31
    167e:	f0 e0       	ldi	r31, 0x00	; 0
    1680:	ef 2e       	mov	r14, r31
    1682:	f0 e0       	ldi	r31, 0x00	; 0
    1684:	ff 2e       	mov	r15, r31
    1686:	f0 e1       	ldi	r31, 0x10	; 16
    1688:	0f 2f       	mov	r16, r31
    168a:	f2 ec       	ldi	r31, 0xC2	; 194
    168c:	1f 2f       	mov	r17, r31
    168e:	f0 2d       	mov	r31, r0
				
		float s_out = -0.5421 * (cmd_vel) + 188.41;

		taskENTER_CRITICAL();
    1690:	0f b6       	in	r0, 0x3f	; 63
    1692:	f8 94       	cli
    1694:	0f 92       	push	r0
		PWM_timer3_Set_E3((int)s_out);
    1696:	c8 01       	movw	r24, r16
    1698:	b7 01       	movw	r22, r14
    169a:	21 e1       	ldi	r18, 0x11	; 17
    169c:	37 ec       	ldi	r19, 0xC7	; 199
    169e:	4a e0       	ldi	r20, 0x0A	; 10
    16a0:	5f eb       	ldi	r21, 0xBF	; 191
    16a2:	0e 94 77 2f 	call	0x5eee	; 0x5eee <__mulsf3>
    16a6:	26 ef       	ldi	r18, 0xF6	; 246
    16a8:	38 e6       	ldi	r19, 0x68	; 104
    16aa:	4c e3       	ldi	r20, 0x3C	; 60
    16ac:	53 e4       	ldi	r21, 0x43	; 67
    16ae:	0e 94 c0 2d 	call	0x5b80	; 0x5b80 <__addsf3>
    16b2:	0e 94 90 2e 	call	0x5d20	; 0x5d20 <__fixsfsi>
void PWM_timer1_Set_LED(u16 pwmDuty)
	{OCR1B = pwmDuty;}
void PWM_timer2_Set_H6(u16 pwmDuty)
	{OCR2B = pwmDuty;}
void PWM_timer3_Set_E3(u16 pwmDuty)
	{OCR3A = pwmDuty;}
    16b6:	70 93 99 00 	sts	0x0099, r23
    16ba:	60 93 98 00 	sts	0x0098, r22
		taskEXIT_CRITICAL();
    16be:	0f 90       	pop	r0
    16c0:	0f be       	out	0x3f, r0	; 63
			
			
			taskENTER_CRITICAL();
			wheel_L(v_out_L);
			wheel_R(-v_out_R);
			taskEXIT_CRITICAL();
    16c2:	0f 90       	pop	r0
    16c4:	0f be       	out	0x3f, r0	; 63
			

		vTaskDelayUntil(&xLastWakeTime, (100 / portTICK_RATE_MS));
    16c6:	c1 01       	movw	r24, r2
    16c8:	64 e6       	ldi	r22, 0x64	; 100
    16ca:	70 e0       	ldi	r23, 0x00	; 0
    16cc:	0e 94 7c 16 	call	0x2cf8	; 0x2cf8 <vTaskDelayUntil>
    16d0:	20 ce       	rjmp	.-960    	; 0x1312 <vPID+0x7c>

000016d2 <vPID_R>:
		vTaskDelayUntil(&xLastWakeTime, (100 / portTICK_RATE_MS));
	}

}

void vPID_R(void* pvParameters){
    16d2:	2f 92       	push	r2
    16d4:	3f 92       	push	r3
    16d6:	4f 92       	push	r4
    16d8:	5f 92       	push	r5
    16da:	6f 92       	push	r6
    16dc:	7f 92       	push	r7
    16de:	8f 92       	push	r8
    16e0:	9f 92       	push	r9
    16e2:	af 92       	push	r10
    16e4:	bf 92       	push	r11
    16e6:	cf 92       	push	r12
    16e8:	df 92       	push	r13
    16ea:	ef 92       	push	r14
    16ec:	ff 92       	push	r15
    16ee:	0f 93       	push	r16
    16f0:	1f 93       	push	r17
    16f2:	df 93       	push	r29
    16f4:	cf 93       	push	r28
    16f6:	00 d0       	rcall	.+0      	; 0x16f8 <vPID_R+0x26>
    16f8:	cd b7       	in	r28, 0x3d	; 61
    16fa:	de b7       	in	r29, 0x3e	; 62
	sbi(TCCR2A,COM2B1);
	cbi(TCCR2A,COM2B0);
}
void PWM_timer3_On_E3(void)
{
	sbi(TCCR3A,COM3A1);
    16fc:	80 91 90 00 	lds	r24, 0x0090
    1700:	80 68       	ori	r24, 0x80	; 128
    1702:	80 93 90 00 	sts	0x0090, r24
	cbi(TCCR3A,COM3A0);
    1706:	80 91 90 00 	lds	r24, 0x0090
    170a:	8f 7b       	andi	r24, 0xBF	; 191
    170c:	80 93 90 00 	sts	0x0090, r24
    1710:	0f 2e       	mov	r0, r31
    1712:	f0 e0       	ldi	r31, 0x00	; 0
    1714:	af 2e       	mov	r10, r31
    1716:	f0 e0       	ldi	r31, 0x00	; 0
    1718:	bf 2e       	mov	r11, r31
    171a:	f0 e0       	ldi	r31, 0x00	; 0
    171c:	cf 2e       	mov	r12, r31
    171e:	f0 e0       	ldi	r31, 0x00	; 0
    1720:	df 2e       	mov	r13, r31
    1722:	f0 2d       	mov	r31, r0

	char adj;
	for(;;){
			
			
			error = v_right - (-RIGHTVel_current);
    1724:	20 90 b6 02 	lds	r2, 0x02B6
    1728:	30 90 b7 02 	lds	r3, 0x02B7
    172c:	40 90 c5 02 	lds	r4, 0x02C5
    1730:	50 90 c6 02 	lds	r5, 0x02C6
			v_out = (signed int)(KP*error + KI*acc_error);
    1734:	b2 01       	movw	r22, r4
    1736:	62 0d       	add	r22, r2
    1738:	73 1d       	adc	r23, r3
    173a:	88 27       	eor	r24, r24
    173c:	77 fd       	sbrc	r23, 7
    173e:	80 95       	com	r24
    1740:	98 2f       	mov	r25, r24
    1742:	0e 94 c3 2e 	call	0x5d86	; 0x5d86 <__floatsisf>
    1746:	3b 01       	movw	r6, r22
    1748:	4c 01       	movw	r8, r24
    174a:	2d e8       	ldi	r18, 0x8D	; 141
    174c:	30 e9       	ldi	r19, 0x90	; 144
    174e:	48 e0       	ldi	r20, 0x08	; 8
    1750:	5c e3       	ldi	r21, 0x3C	; 60
    1752:	0e 94 77 2f 	call	0x5eee	; 0x5eee <__mulsf3>
    1756:	7b 01       	movw	r14, r22
    1758:	8c 01       	movw	r16, r24
    175a:	c6 01       	movw	r24, r12
    175c:	b5 01       	movw	r22, r10
    175e:	26 e1       	ldi	r18, 0x16	; 22
    1760:	35 e4       	ldi	r19, 0x45	; 69
    1762:	40 e8       	ldi	r20, 0x80	; 128
    1764:	5c e3       	ldi	r21, 0x3C	; 60
    1766:	0e 94 77 2f 	call	0x5eee	; 0x5eee <__mulsf3>
    176a:	9b 01       	movw	r18, r22
    176c:	ac 01       	movw	r20, r24
    176e:	c8 01       	movw	r24, r16
    1770:	b7 01       	movw	r22, r14
    1772:	0e 94 c0 2d 	call	0x5b80	; 0x5b80 <__addsf3>
    1776:	0e 94 90 2e 	call	0x5d20	; 0x5d20 <__fixsfsi>
    177a:	cb 01       	movw	r24, r22
			// Anti windup
	//		if((v_out >= 36) || (v_out <= -36)){
	//			v_out -= KI*acc_error;
	//		}
			if(v_out > 36){v_out = 36;}
    177c:	65 32       	cpi	r22, 0x25	; 37
    177e:	71 05       	cpc	r23, r1
    1780:	1c f0       	brlt	.+6      	; 0x1788 <vPID_R+0xb6>
    1782:	84 e2       	ldi	r24, 0x24	; 36
    1784:	90 e0       	ldi	r25, 0x00	; 0
    1786:	06 c0       	rjmp	.+12     	; 0x1794 <vPID_R+0xc2>
			if(v_out < -36){v_out = -36;}
    1788:	2f ef       	ldi	r18, 0xFF	; 255
    178a:	6c 3d       	cpi	r22, 0xDC	; 220
    178c:	72 07       	cpc	r23, r18
    178e:	14 f4       	brge	.+4      	; 0x1794 <vPID_R+0xc2>
    1790:	8c ed       	ldi	r24, 0xDC	; 220
    1792:	9f ef       	ldi	r25, 0xFF	; 255
			
			taskENTER_CRITICAL();
    1794:	0f b6       	in	r0, 0x3f	; 63
    1796:	f8 94       	cli
    1798:	0f 92       	push	r0
			wheel_R(-v_out);
    179a:	66 27       	eor	r22, r22
    179c:	77 27       	eor	r23, r23
    179e:	68 1b       	sub	r22, r24
    17a0:	79 0b       	sbc	r23, r25
    17a2:	88 27       	eor	r24, r24
    17a4:	77 fd       	sbrc	r23, 7
    17a6:	80 95       	com	r24
    17a8:	98 2f       	mov	r25, r24
    17aa:	0e 94 c3 2e 	call	0x5d86	; 0x5d86 <__floatsisf>
    17ae:	7b 01       	movw	r14, r22
    17b0:	8c 01       	movw	r16, r24


}

void wheel_R(float cmd_vel){
		if(cmd_vel > 36){cmd_vel = 36;}
    17b2:	20 e0       	ldi	r18, 0x00	; 0
    17b4:	30 e0       	ldi	r19, 0x00	; 0
    17b6:	40 e1       	ldi	r20, 0x10	; 16
    17b8:	52 e4       	ldi	r21, 0x42	; 66
    17ba:	0e 94 73 2f 	call	0x5ee6	; 0x5ee6 <__gesf2>
    17be:	18 16       	cp	r1, r24
    17c0:	5c f4       	brge	.+22     	; 0x17d8 <vPID_R+0x106>
    17c2:	0f 2e       	mov	r0, r31
    17c4:	f0 e0       	ldi	r31, 0x00	; 0
    17c6:	ef 2e       	mov	r14, r31
    17c8:	f0 e0       	ldi	r31, 0x00	; 0
    17ca:	ff 2e       	mov	r15, r31
    17cc:	f0 e1       	ldi	r31, 0x10	; 16
    17ce:	0f 2f       	mov	r16, r31
    17d0:	f2 e4       	ldi	r31, 0x42	; 66
    17d2:	1f 2f       	mov	r17, r31
    17d4:	f0 2d       	mov	r31, r0
    17d6:	14 c0       	rjmp	.+40     	; 0x1800 <vPID_R+0x12e>
		if(cmd_vel < -36){cmd_vel = -36;}
    17d8:	c8 01       	movw	r24, r16
    17da:	b7 01       	movw	r22, r14
    17dc:	20 e0       	ldi	r18, 0x00	; 0
    17de:	30 e0       	ldi	r19, 0x00	; 0
    17e0:	40 e1       	ldi	r20, 0x10	; 16
    17e2:	52 ec       	ldi	r21, 0xC2	; 194
    17e4:	0e 94 24 2e 	call	0x5c48	; 0x5c48 <__cmpsf2>
    17e8:	88 23       	and	r24, r24
    17ea:	54 f4       	brge	.+20     	; 0x1800 <vPID_R+0x12e>
    17ec:	0f 2e       	mov	r0, r31
    17ee:	f0 e0       	ldi	r31, 0x00	; 0
    17f0:	ef 2e       	mov	r14, r31
    17f2:	f0 e0       	ldi	r31, 0x00	; 0
    17f4:	ff 2e       	mov	r15, r31
    17f6:	f0 e1       	ldi	r31, 0x10	; 16
    17f8:	0f 2f       	mov	r16, r31
    17fa:	f2 ec       	ldi	r31, 0xC2	; 194
    17fc:	1f 2f       	mov	r17, r31
    17fe:	f0 2d       	mov	r31, r0
				
		float s_out = -0.5421 * (cmd_vel) + 188.41;

		taskENTER_CRITICAL();
    1800:	0f b6       	in	r0, 0x3f	; 63
    1802:	f8 94       	cli
    1804:	0f 92       	push	r0
		PWM_timer3_Set_E3((int)s_out);
    1806:	c8 01       	movw	r24, r16
    1808:	b7 01       	movw	r22, r14
    180a:	21 e1       	ldi	r18, 0x11	; 17
    180c:	37 ec       	ldi	r19, 0xC7	; 199
    180e:	4a e0       	ldi	r20, 0x0A	; 10
    1810:	5f eb       	ldi	r21, 0xBF	; 191
    1812:	0e 94 77 2f 	call	0x5eee	; 0x5eee <__mulsf3>
    1816:	26 ef       	ldi	r18, 0xF6	; 246
    1818:	38 e6       	ldi	r19, 0x68	; 104
    181a:	4c e3       	ldi	r20, 0x3C	; 60
    181c:	53 e4       	ldi	r21, 0x43	; 67
    181e:	0e 94 c0 2d 	call	0x5b80	; 0x5b80 <__addsf3>
    1822:	0e 94 90 2e 	call	0x5d20	; 0x5d20 <__fixsfsi>
void PWM_timer1_Set_LED(u16 pwmDuty)
	{OCR1B = pwmDuty;}
void PWM_timer2_Set_H6(u16 pwmDuty)
	{OCR2B = pwmDuty;}
void PWM_timer3_Set_E3(u16 pwmDuty)
	{OCR3A = pwmDuty;}
    1826:	70 93 99 00 	sts	0x0099, r23
    182a:	60 93 98 00 	sts	0x0098, r22
		taskEXIT_CRITICAL();
    182e:	0f 90       	pop	r0
    1830:	0f be       	out	0x3f, r0	; 63
			if(v_out > 36){v_out = 36;}
			if(v_out < -36){v_out = -36;}
			
			taskENTER_CRITICAL();
			wheel_R(-v_out);
			taskEXIT_CRITICAL();
    1832:	0f 90       	pop	r0
    1834:	0f be       	out	0x3f, r0	; 63
			rprintf("\t%d, v_right: %d\n",-RIGHTVel_current,v_right);
    1836:	8d b7       	in	r24, 0x3d	; 61
    1838:	9e b7       	in	r25, 0x3e	; 62
    183a:	07 97       	sbiw	r24, 0x07	; 7
    183c:	0f b6       	in	r0, 0x3f	; 63
    183e:	f8 94       	cli
    1840:	9e bf       	out	0x3e, r25	; 62
    1842:	0f be       	out	0x3f, r0	; 63
    1844:	8d bf       	out	0x3d, r24	; 61
    1846:	ed b7       	in	r30, 0x3d	; 61
    1848:	fe b7       	in	r31, 0x3e	; 62
    184a:	31 96       	adiw	r30, 0x01	; 1
    184c:	21 e0       	ldi	r18, 0x01	; 1
    184e:	ad b7       	in	r26, 0x3d	; 61
    1850:	be b7       	in	r27, 0x3e	; 62
    1852:	11 96       	adiw	r26, 0x01	; 1
    1854:	2c 93       	st	X, r18
    1856:	8f e3       	ldi	r24, 0x3F	; 63
    1858:	91 e0       	ldi	r25, 0x01	; 1
    185a:	92 83       	std	Z+2, r25	; 0x02
    185c:	81 83       	std	Z+1, r24	; 0x01
    185e:	88 27       	eor	r24, r24
    1860:	99 27       	eor	r25, r25
    1862:	84 19       	sub	r24, r4
    1864:	95 09       	sbc	r25, r5
    1866:	94 83       	std	Z+4, r25	; 0x04
    1868:	83 83       	std	Z+3, r24	; 0x03
    186a:	36 82       	std	Z+6, r3	; 0x06
    186c:	25 82       	std	Z+5, r2	; 0x05
    186e:	0e 94 86 2a 	call	0x550c	; 0x550c <rprintf1RamRom>
			acc_error += error;
    1872:	c6 01       	movw	r24, r12
    1874:	b5 01       	movw	r22, r10
    1876:	a4 01       	movw	r20, r8
    1878:	93 01       	movw	r18, r6
    187a:	0e 94 c0 2d 	call	0x5b80	; 0x5b80 <__addsf3>
    187e:	5b 01       	movw	r10, r22
    1880:	6c 01       	movw	r12, r24
			
		vTaskDelayUntil(&xLastWakeTime, (100 / portTICK_RATE_MS));
    1882:	ad b7       	in	r26, 0x3d	; 61
    1884:	be b7       	in	r27, 0x3e	; 62
    1886:	17 96       	adiw	r26, 0x07	; 7
    1888:	0f b6       	in	r0, 0x3f	; 63
    188a:	f8 94       	cli
    188c:	be bf       	out	0x3e, r27	; 62
    188e:	0f be       	out	0x3f, r0	; 63
    1890:	ad bf       	out	0x3d, r26	; 61
    1892:	ce 01       	movw	r24, r28
    1894:	01 96       	adiw	r24, 0x01	; 1
    1896:	64 e6       	ldi	r22, 0x64	; 100
    1898:	70 e0       	ldi	r23, 0x00	; 0
    189a:	0e 94 7c 16 	call	0x2cf8	; 0x2cf8 <vTaskDelayUntil>
    189e:	42 cf       	rjmp	.-380    	; 0x1724 <vPID_R+0x52>

000018a0 <vPID_L>:
		taskEXIT_CRITICAL();


}

void vPID_L(void* pvParameters){
    18a0:	2f 92       	push	r2
    18a2:	3f 92       	push	r3
    18a4:	4f 92       	push	r4
    18a6:	5f 92       	push	r5
    18a8:	6f 92       	push	r6
    18aa:	7f 92       	push	r7
    18ac:	8f 92       	push	r8
    18ae:	9f 92       	push	r9
    18b0:	af 92       	push	r10
    18b2:	bf 92       	push	r11
    18b4:	cf 92       	push	r12
    18b6:	df 92       	push	r13
    18b8:	ef 92       	push	r14
    18ba:	ff 92       	push	r15
    18bc:	0f 93       	push	r16
    18be:	1f 93       	push	r17
    18c0:	df 93       	push	r29
    18c2:	cf 93       	push	r28
    18c4:	00 d0       	rcall	.+0      	; 0x18c6 <vPID_L+0x26>
    18c6:	00 d0       	rcall	.+0      	; 0x18c8 <vPID_L+0x28>
    18c8:	00 d0       	rcall	.+0      	; 0x18ca <vPID_L+0x2a>
    18ca:	cd b7       	in	r28, 0x3d	; 61
    18cc:	de b7       	in	r29, 0x3e	; 62
	sbi(TCCR3A,COM3A1);
	cbi(TCCR3A,COM3A0);
}
void PWM_timer3_On_E4(void)
{
	sbi(TCCR3A,COM3B1);
    18ce:	80 91 90 00 	lds	r24, 0x0090
    18d2:	80 62       	ori	r24, 0x20	; 32
    18d4:	80 93 90 00 	sts	0x0090, r24
	cbi(TCCR3A,COM3B0);
    18d8:	80 91 90 00 	lds	r24, 0x0090
    18dc:	8f 7e       	andi	r24, 0xEF	; 239
    18de:	80 93 90 00 	sts	0x0090, r24
    18e2:	80 e0       	ldi	r24, 0x00	; 0
    18e4:	90 e0       	ldi	r25, 0x00	; 0
    18e6:	a0 e0       	ldi	r26, 0x00	; 0
    18e8:	b0 e0       	ldi	r27, 0x00	; 0
    18ea:	8b 83       	std	Y+3, r24	; 0x03
    18ec:	9c 83       	std	Y+4, r25	; 0x04
    18ee:	ad 83       	std	Y+5, r26	; 0x05
    18f0:	be 83       	std	Y+6, r27	; 0x06
				rprintfFloat(5,acc_error);
				rprintfCRLF();
			}
			*/

		vTaskDelayUntil(&xLastWakeTime, (100 / portTICK_RATE_MS));
    18f2:	1e 01       	movw	r2, r28
    18f4:	08 94       	sec
    18f6:	21 1c       	adc	r2, r1
    18f8:	31 1c       	adc	r3, r1
	
	wheel_L_on();

	for(;;){

			error = v_left - LEFTVel_current;
    18fa:	80 90 b8 02 	lds	r8, 0x02B8
    18fe:	90 90 b9 02 	lds	r9, 0x02B9
    1902:	60 91 b4 02 	lds	r22, 0x02B4
    1906:	70 91 b5 02 	lds	r23, 0x02B5
    190a:	68 19       	sub	r22, r8
    190c:	79 09       	sbc	r23, r9
    190e:	88 27       	eor	r24, r24
    1910:	77 fd       	sbrc	r23, 7
    1912:	80 95       	com	r24
    1914:	98 2f       	mov	r25, r24
    1916:	0e 94 c3 2e 	call	0x5d86	; 0x5d86 <__floatsisf>
    191a:	5b 01       	movw	r10, r22
    191c:	6c 01       	movw	r12, r24
			
			v_out = (float)(KP*error + KI*acc_error);
    191e:	2c e4       	ldi	r18, 0x4C	; 76
    1920:	33 e9       	ldi	r19, 0x93	; 147
    1922:	49 e1       	ldi	r20, 0x19	; 25
    1924:	5c e3       	ldi	r21, 0x3C	; 60
    1926:	0e 94 77 2f 	call	0x5eee	; 0x5eee <__mulsf3>
    192a:	7b 01       	movw	r14, r22
    192c:	8c 01       	movw	r16, r24
    192e:	6b 81       	ldd	r22, Y+3	; 0x03
    1930:	7c 81       	ldd	r23, Y+4	; 0x04
    1932:	8d 81       	ldd	r24, Y+5	; 0x05
    1934:	9e 81       	ldd	r25, Y+6	; 0x06
    1936:	20 ea       	ldi	r18, 0xA0	; 160
    1938:	33 e0       	ldi	r19, 0x03	; 3
    193a:	4f eb       	ldi	r20, 0xBF	; 191
    193c:	5c e3       	ldi	r21, 0x3C	; 60
    193e:	0e 94 77 2f 	call	0x5eee	; 0x5eee <__mulsf3>
    1942:	9b 01       	movw	r18, r22
    1944:	ac 01       	movw	r20, r24
    1946:	c8 01       	movw	r24, r16
    1948:	b7 01       	movw	r22, r14
    194a:	0e 94 c0 2d 	call	0x5b80	; 0x5b80 <__addsf3>
    194e:	2b 01       	movw	r4, r22
    1950:	3c 01       	movw	r6, r24
			taskENTER_CRITICAL();
    1952:	0f b6       	in	r0, 0x3f	; 63
    1954:	f8 94       	cli
    1956:	0f 92       	push	r0
			rprintf("\nLVC: %d, v_out: %d\n",LEFTVel_current,(int)v_out);
    1958:	ad b7       	in	r26, 0x3d	; 61
    195a:	be b7       	in	r27, 0x3e	; 62
    195c:	17 97       	sbiw	r26, 0x07	; 7
    195e:	0f b6       	in	r0, 0x3f	; 63
    1960:	f8 94       	cli
    1962:	be bf       	out	0x3e, r27	; 62
    1964:	0f be       	out	0x3f, r0	; 63
    1966:	ad bf       	out	0x3d, r26	; 61
    1968:	0d b7       	in	r16, 0x3d	; 61
    196a:	1e b7       	in	r17, 0x3e	; 62
    196c:	0f 5f       	subi	r16, 0xFF	; 255
    196e:	1f 4f       	sbci	r17, 0xFF	; 255
    1970:	e1 e0       	ldi	r30, 0x01	; 1
    1972:	11 96       	adiw	r26, 0x01	; 1
    1974:	ec 93       	st	X, r30
    1976:	e1 e5       	ldi	r30, 0x51	; 81
    1978:	f1 e0       	ldi	r31, 0x01	; 1
    197a:	d8 01       	movw	r26, r16
    197c:	12 96       	adiw	r26, 0x02	; 2
    197e:	fc 93       	st	X, r31
    1980:	ee 93       	st	-X, r30
    1982:	11 97       	sbiw	r26, 0x01	; 1
    1984:	14 96       	adiw	r26, 0x04	; 4
    1986:	9c 92       	st	X, r9
    1988:	8e 92       	st	-X, r8
    198a:	13 97       	sbiw	r26, 0x03	; 3
    198c:	0e 94 90 2e 	call	0x5d20	; 0x5d20 <__fixsfsi>
    1990:	d8 01       	movw	r26, r16
    1992:	16 96       	adiw	r26, 0x06	; 6
    1994:	7c 93       	st	X, r23
    1996:	6e 93       	st	-X, r22
    1998:	15 97       	sbiw	r26, 0x05	; 5
    199a:	0e 94 86 2a 	call	0x550c	; 0x550c <rprintf1RamRom>
			taskEXIT_CRITICAL();
    199e:	0f 90       	pop	r0
    19a0:	0f be       	out	0x3f, r0	; 63
			// Anti windup
	//		if((v_out >= 36) || (v_out <= -36)){
	//			v_out -= KI*acc_error;
	//		}
		//if(LEFTVel_ready){	
			acc_error += error;
    19a2:	6b 81       	ldd	r22, Y+3	; 0x03
    19a4:	7c 81       	ldd	r23, Y+4	; 0x04
    19a6:	8d 81       	ldd	r24, Y+5	; 0x05
    19a8:	9e 81       	ldd	r25, Y+6	; 0x06
    19aa:	a6 01       	movw	r20, r12
    19ac:	95 01       	movw	r18, r10
    19ae:	0e 94 c0 2d 	call	0x5b80	; 0x5b80 <__addsf3>
    19b2:	6b 83       	std	Y+3, r22	; 0x03
    19b4:	7c 83       	std	Y+4, r23	; 0x04
    19b6:	8d 83       	std	Y+5, r24	; 0x05
    19b8:	9e 83       	std	Y+6, r25	; 0x06
		//}
			if(v_out > 36){v_out = 36;}
    19ba:	ed b7       	in	r30, 0x3d	; 61
    19bc:	fe b7       	in	r31, 0x3e	; 62
    19be:	37 96       	adiw	r30, 0x07	; 7
    19c0:	0f b6       	in	r0, 0x3f	; 63
    19c2:	f8 94       	cli
    19c4:	fe bf       	out	0x3e, r31	; 62
    19c6:	0f be       	out	0x3f, r0	; 63
    19c8:	ed bf       	out	0x3d, r30	; 61
    19ca:	c3 01       	movw	r24, r6
    19cc:	b2 01       	movw	r22, r4
    19ce:	20 e0       	ldi	r18, 0x00	; 0
    19d0:	30 e0       	ldi	r19, 0x00	; 0
    19d2:	40 e1       	ldi	r20, 0x10	; 16
    19d4:	52 e4       	ldi	r21, 0x42	; 66
    19d6:	0e 94 73 2f 	call	0x5ee6	; 0x5ee6 <__gesf2>
    19da:	18 16       	cp	r1, r24
    19dc:	5c f4       	brge	.+22     	; 0x19f4 <vPID_L+0x154>
    19de:	0f 2e       	mov	r0, r31
    19e0:	f0 e0       	ldi	r31, 0x00	; 0
    19e2:	4f 2e       	mov	r4, r31
    19e4:	f0 e0       	ldi	r31, 0x00	; 0
    19e6:	5f 2e       	mov	r5, r31
    19e8:	f0 e1       	ldi	r31, 0x10	; 16
    19ea:	6f 2e       	mov	r6, r31
    19ec:	f2 e4       	ldi	r31, 0x42	; 66
    19ee:	7f 2e       	mov	r7, r31
    19f0:	f0 2d       	mov	r31, r0
    19f2:	14 c0       	rjmp	.+40     	; 0x1a1c <vPID_L+0x17c>
			if(v_out < -36){v_out = -36;}
    19f4:	c3 01       	movw	r24, r6
    19f6:	b2 01       	movw	r22, r4
    19f8:	20 e0       	ldi	r18, 0x00	; 0
    19fa:	30 e0       	ldi	r19, 0x00	; 0
    19fc:	40 e1       	ldi	r20, 0x10	; 16
    19fe:	52 ec       	ldi	r21, 0xC2	; 194
    1a00:	0e 94 24 2e 	call	0x5c48	; 0x5c48 <__cmpsf2>
    1a04:	88 23       	and	r24, r24
    1a06:	54 f4       	brge	.+20     	; 0x1a1c <vPID_L+0x17c>
    1a08:	0f 2e       	mov	r0, r31
    1a0a:	f0 e0       	ldi	r31, 0x00	; 0
    1a0c:	4f 2e       	mov	r4, r31
    1a0e:	f0 e0       	ldi	r31, 0x00	; 0
    1a10:	5f 2e       	mov	r5, r31
    1a12:	f0 e1       	ldi	r31, 0x10	; 16
    1a14:	6f 2e       	mov	r6, r31
    1a16:	f2 ec       	ldi	r31, 0xC2	; 194
    1a18:	7f 2e       	mov	r7, r31
    1a1a:	f0 2d       	mov	r31, r0
			
			
			taskENTER_CRITICAL();
    1a1c:	0f b6       	in	r0, 0x3f	; 63
    1a1e:	f8 94       	cli
    1a20:	0f 92       	push	r0

/*************************************************/


void wheel_L(float cmd_vel){
		if(cmd_vel > 36){cmd_vel = 36;}
    1a22:	c3 01       	movw	r24, r6
    1a24:	b2 01       	movw	r22, r4
    1a26:	20 e0       	ldi	r18, 0x00	; 0
    1a28:	30 e0       	ldi	r19, 0x00	; 0
    1a2a:	40 e1       	ldi	r20, 0x10	; 16
    1a2c:	52 e4       	ldi	r21, 0x42	; 66
    1a2e:	0e 94 73 2f 	call	0x5ee6	; 0x5ee6 <__gesf2>
    1a32:	18 16       	cp	r1, r24
    1a34:	5c f4       	brge	.+22     	; 0x1a4c <vPID_L+0x1ac>
    1a36:	0f 2e       	mov	r0, r31
    1a38:	f0 e0       	ldi	r31, 0x00	; 0
    1a3a:	4f 2e       	mov	r4, r31
    1a3c:	f0 e0       	ldi	r31, 0x00	; 0
    1a3e:	5f 2e       	mov	r5, r31
    1a40:	f0 e1       	ldi	r31, 0x10	; 16
    1a42:	6f 2e       	mov	r6, r31
    1a44:	f2 e4       	ldi	r31, 0x42	; 66
    1a46:	7f 2e       	mov	r7, r31
    1a48:	f0 2d       	mov	r31, r0
    1a4a:	14 c0       	rjmp	.+40     	; 0x1a74 <vPID_L+0x1d4>
		if(cmd_vel < -36){cmd_vel = -36;}
    1a4c:	c3 01       	movw	r24, r6
    1a4e:	b2 01       	movw	r22, r4
    1a50:	20 e0       	ldi	r18, 0x00	; 0
    1a52:	30 e0       	ldi	r19, 0x00	; 0
    1a54:	40 e1       	ldi	r20, 0x10	; 16
    1a56:	52 ec       	ldi	r21, 0xC2	; 194
    1a58:	0e 94 24 2e 	call	0x5c48	; 0x5c48 <__cmpsf2>
    1a5c:	88 23       	and	r24, r24
    1a5e:	54 f4       	brge	.+20     	; 0x1a74 <vPID_L+0x1d4>
    1a60:	0f 2e       	mov	r0, r31
    1a62:	f0 e0       	ldi	r31, 0x00	; 0
    1a64:	4f 2e       	mov	r4, r31
    1a66:	f0 e0       	ldi	r31, 0x00	; 0
    1a68:	5f 2e       	mov	r5, r31
    1a6a:	f0 e1       	ldi	r31, 0x10	; 16
    1a6c:	6f 2e       	mov	r6, r31
    1a6e:	f2 ec       	ldi	r31, 0xC2	; 194
    1a70:	7f 2e       	mov	r7, r31
    1a72:	f0 2d       	mov	r31, r0
		
		float s_out = -0.4928 * (cmd_vel) + 185.27;
		
		taskENTER_CRITICAL();
    1a74:	0f b6       	in	r0, 0x3f	; 63
    1a76:	f8 94       	cli
    1a78:	0f 92       	push	r0
		PWM_timer3_Set_E4((int)s_out);
    1a7a:	c3 01       	movw	r24, r6
    1a7c:	b2 01       	movw	r22, r4
    1a7e:	28 e4       	ldi	r18, 0x48	; 72
    1a80:	30 e5       	ldi	r19, 0x50	; 80
    1a82:	4c ef       	ldi	r20, 0xFC	; 252
    1a84:	5e eb       	ldi	r21, 0xBE	; 190
    1a86:	0e 94 77 2f 	call	0x5eee	; 0x5eee <__mulsf3>
    1a8a:	2f e1       	ldi	r18, 0x1F	; 31
    1a8c:	35 e4       	ldi	r19, 0x45	; 69
    1a8e:	49 e3       	ldi	r20, 0x39	; 57
    1a90:	53 e4       	ldi	r21, 0x43	; 67
    1a92:	0e 94 c0 2d 	call	0x5b80	; 0x5b80 <__addsf3>
    1a96:	0e 94 90 2e 	call	0x5d20	; 0x5d20 <__fixsfsi>
void PWM_timer2_Set_H6(u16 pwmDuty)
	{OCR2B = pwmDuty;}
void PWM_timer3_Set_E3(u16 pwmDuty)
	{OCR3A = pwmDuty;}
void PWM_timer3_Set_E4(u16 pwmDuty)
	{OCR3B = pwmDuty;}
    1a9a:	70 93 9b 00 	sts	0x009B, r23
    1a9e:	60 93 9a 00 	sts	0x009A, r22
		taskEXIT_CRITICAL();
    1aa2:	0f 90       	pop	r0
    1aa4:	0f be       	out	0x3f, r0	; 63
			if(v_out < -36){v_out = -36;}
			
			
			taskENTER_CRITICAL();
			wheel_L(v_out);
			taskEXIT_CRITICAL();
    1aa6:	0f 90       	pop	r0
    1aa8:	0f be       	out	0x3f, r0	; 63
			

			key = uart1GetByte();
    1aaa:	0e 94 33 26 	call	0x4c66	; 0x4c66 <uart1GetByte>
				rprintfFloat(5,acc_error);
				rprintfCRLF();
			}
			*/

		vTaskDelayUntil(&xLastWakeTime, (100 / portTICK_RATE_MS));
    1aae:	c1 01       	movw	r24, r2
    1ab0:	64 e6       	ldi	r22, 0x64	; 100
    1ab2:	70 e0       	ldi	r23, 0x00	; 0
    1ab4:	0e 94 7c 16 	call	0x2cf8	; 0x2cf8 <vTaskDelayUntil>
    1ab8:	20 cf       	rjmp	.-448    	; 0x18fa <vPID_L+0x5a>

00001aba <vEnc_UpdatePose>:
		//rprintf("RIGHTVel_current: %d\n",RIGHTVel_current);
	
	}
}

void vEnc_UpdatePose(){
    1aba:	ef 92       	push	r14
    1abc:	ff 92       	push	r15
    1abe:	0f 93       	push	r16
    1ac0:	1f 93       	push	r17

	for(;;){
		
		//The below formula yields the encoder calculated angular velocity of the robot
		//as it rotates about some ICC(Instantaneous Center of Curvature)
		reset_timer0();
    1ac2:	0e 94 ba 1c 	call	0x3974	; 0x3974 <reset_timer0>
		enc_ang_vel = ((-RIGHTVel_current) - LEFTVel_current) / ROBOT_DIAMETER;
    1ac6:	60 91 c5 02 	lds	r22, 0x02C5
    1aca:	70 91 c6 02 	lds	r23, 0x02C6
    1ace:	70 95       	com	r23
    1ad0:	61 95       	neg	r22
    1ad2:	7f 4f       	sbci	r23, 0xFF	; 255
    1ad4:	20 91 b8 02 	lds	r18, 0x02B8
    1ad8:	30 91 b9 02 	lds	r19, 0x02B9
    1adc:	62 1b       	sub	r22, r18
    1ade:	73 0b       	sbc	r23, r19
    1ae0:	88 27       	eor	r24, r24
    1ae2:	77 fd       	sbrc	r23, 7
    1ae4:	80 95       	com	r24
    1ae6:	98 2f       	mov	r25, r24
    1ae8:	0e 94 c3 2e 	call	0x5d86	; 0x5d86 <__floatsisf>
    1aec:	26 e6       	ldi	r18, 0x66	; 102
    1aee:	36 e6       	ldi	r19, 0x66	; 102
    1af0:	46 e8       	ldi	r20, 0x86	; 134
    1af2:	51 e4       	ldi	r21, 0x41	; 65
    1af4:	0e 94 28 2e 	call	0x5c50	; 0x5c50 <__divsf3>
    1af8:	60 93 d6 02 	sts	0x02D6, r22
    1afc:	70 93 d7 02 	sts	0x02D7, r23
    1b00:	80 93 d8 02 	sts	0x02D8, r24
    1b04:	90 93 d9 02 	sts	0x02D9, r25
		elapsed_time = ((get_timer0_overflow()*255 + TCNT0) * 0.256) / 1000;
    1b08:	0e 94 5b 1c 	call	0x38b6	; 0x38b6 <get_timer0_overflow>
    1b0c:	16 b5       	in	r17, 0x26	; 38
		//dRL = dRIGHTDis - dLEFTDis;
		//dis_enc_heading += sin((dRL)/ ROBOT_DIAMETER);
		//dRIGHTDis = dLEFTDis = 0;
		enc_heading += enc_ang_vel * elapsed_time;
    1b0e:	2f ef       	ldi	r18, 0xFF	; 255
    1b10:	30 e0       	ldi	r19, 0x00	; 0
    1b12:	40 e0       	ldi	r20, 0x00	; 0
    1b14:	50 e0       	ldi	r21, 0x00	; 0
    1b16:	0e 94 da 2f 	call	0x5fb4	; 0x5fb4 <__mulsi3>
    1b1a:	61 0f       	add	r22, r17
    1b1c:	71 1d       	adc	r23, r1
    1b1e:	81 1d       	adc	r24, r1
    1b20:	91 1d       	adc	r25, r1
    1b22:	0e 94 c1 2e 	call	0x5d82	; 0x5d82 <__floatunsisf>
    1b26:	2f e6       	ldi	r18, 0x6F	; 111
    1b28:	32 e1       	ldi	r19, 0x12	; 18
    1b2a:	43 e8       	ldi	r20, 0x83	; 131
    1b2c:	5e e3       	ldi	r21, 0x3E	; 62
    1b2e:	0e 94 77 2f 	call	0x5eee	; 0x5eee <__mulsf3>
    1b32:	20 e0       	ldi	r18, 0x00	; 0
    1b34:	30 e0       	ldi	r19, 0x00	; 0
    1b36:	4a e7       	ldi	r20, 0x7A	; 122
    1b38:	54 e4       	ldi	r21, 0x44	; 68
    1b3a:	0e 94 28 2e 	call	0x5c50	; 0x5c50 <__divsf3>
    1b3e:	20 91 d6 02 	lds	r18, 0x02D6
    1b42:	30 91 d7 02 	lds	r19, 0x02D7
    1b46:	40 91 d8 02 	lds	r20, 0x02D8
    1b4a:	50 91 d9 02 	lds	r21, 0x02D9
    1b4e:	0e 94 77 2f 	call	0x5eee	; 0x5eee <__mulsf3>
    1b52:	20 91 d2 02 	lds	r18, 0x02D2
    1b56:	30 91 d3 02 	lds	r19, 0x02D3
    1b5a:	40 91 d4 02 	lds	r20, 0x02D4
    1b5e:	50 91 d5 02 	lds	r21, 0x02D5
    1b62:	0e 94 c0 2d 	call	0x5b80	; 0x5b80 <__addsf3>
    1b66:	9b 01       	movw	r18, r22
    1b68:	ac 01       	movw	r20, r24
    1b6a:	60 93 d2 02 	sts	0x02D2, r22
    1b6e:	70 93 d3 02 	sts	0x02D3, r23
    1b72:	80 93 d4 02 	sts	0x02D4, r24
    1b76:	90 93 d5 02 	sts	0x02D5, r25
		cmd_ang_vel = pow(cmd_angle - enc_heading,2)/(pow(cmd_angle - enc_heading,2) + pow(3,2));
    1b7a:	60 91 da 02 	lds	r22, 0x02DA
    1b7e:	70 91 db 02 	lds	r23, 0x02DB
    1b82:	80 91 dc 02 	lds	r24, 0x02DC
    1b86:	90 91 dd 02 	lds	r25, 0x02DD
    1b8a:	0e 94 bf 2d 	call	0x5b7e	; 0x5b7e <__subsf3>
    1b8e:	9b 01       	movw	r18, r22
    1b90:	ac 01       	movw	r20, r24
    1b92:	0e 94 77 2f 	call	0x5eee	; 0x5eee <__mulsf3>
    1b96:	7b 01       	movw	r14, r22
    1b98:	8c 01       	movw	r16, r24
    1b9a:	c8 01       	movw	r24, r16
    1b9c:	b7 01       	movw	r22, r14
    1b9e:	20 e0       	ldi	r18, 0x00	; 0
    1ba0:	30 e0       	ldi	r19, 0x00	; 0
    1ba2:	40 e1       	ldi	r20, 0x10	; 16
    1ba4:	51 e4       	ldi	r21, 0x41	; 65
    1ba6:	0e 94 c0 2d 	call	0x5b80	; 0x5b80 <__addsf3>
    1baa:	9b 01       	movw	r18, r22
    1bac:	ac 01       	movw	r20, r24
    1bae:	c8 01       	movw	r24, r16
    1bb0:	b7 01       	movw	r22, r14
    1bb2:	0e 94 28 2e 	call	0x5c50	; 0x5c50 <__divsf3>
    1bb6:	60 93 de 02 	sts	0x02DE, r22
    1bba:	70 93 df 02 	sts	0x02DF, r23
    1bbe:	80 93 e0 02 	sts	0x02E0, r24
    1bc2:	90 93 e1 02 	sts	0x02E1, r25
    1bc6:	7d cf       	rjmp	.-262    	; 0x1ac2 <vEnc_UpdatePose+0x8>

00001bc8 <send_frame>:
	}
	return c;
}


void send_frame(char flag, int16_t data){
    1bc8:	ff 92       	push	r15
    1bca:	0f 93       	push	r16
    1bcc:	1f 93       	push	r17
    1bce:	cf 93       	push	r28
    1bd0:	df 93       	push	r29
    1bd2:	eb 01       	movw	r28, r22
	uint8_t r1 = 0;
	uint8_t r2 = 0;
	uint8_t r3 = 0;
	uint8_t r4 = 0;

	uart3SendByte(flag);
    1bd4:	0e 94 7b 23 	call	0x46f6	; 0x46f6 <uart3SendByte>

	r1 = num2char(0x0F & (uint8_t)data);
    1bd8:	ff e0       	ldi	r31, 0x0F	; 15
    1bda:	ff 2e       	mov	r15, r31
    1bdc:	fc 22       	and	r15, r28



char num2char(char c){
	
	if(c <10){
    1bde:	89 e0       	ldi	r24, 0x09	; 9
    1be0:	8f 15       	cp	r24, r15
    1be2:	18 f0       	brcs	.+6      	; 0x1bea <send_frame+0x22>
		c += 48;
    1be4:	90 e3       	ldi	r25, 0x30	; 48
    1be6:	f9 0e       	add	r15, r25
    1be8:	06 c0       	rjmp	.+12     	; 0x1bf6 <send_frame+0x2e>
	}
	else if((c >= 10) && (c <= 16)){
    1bea:	8f 2d       	mov	r24, r15
    1bec:	8a 50       	subi	r24, 0x0A	; 10
    1bee:	87 30       	cpi	r24, 0x07	; 7
    1bf0:	10 f4       	brcc	.+4      	; 0x1bf6 <send_frame+0x2e>
		c += 55;
    1bf2:	87 e3       	ldi	r24, 0x37	; 55
    1bf4:	f8 0e       	add	r15, r24
	uint8_t r4 = 0;

	uart3SendByte(flag);

	r1 = num2char(0x0F & (uint8_t)data);
	r2 = num2char(0x0F & ((uint8_t)(data >> 4)) );
    1bf6:	ce 01       	movw	r24, r28
    1bf8:	e4 e0       	ldi	r30, 0x04	; 4
    1bfa:	95 95       	asr	r25
    1bfc:	87 95       	ror	r24
    1bfe:	ea 95       	dec	r30
    1c00:	e1 f7       	brne	.-8      	; 0x1bfa <send_frame+0x32>
    1c02:	08 2f       	mov	r16, r24
    1c04:	0f 70       	andi	r16, 0x0F	; 15



char num2char(char c){
	
	if(c <10){
    1c06:	0a 30       	cpi	r16, 0x0A	; 10
    1c08:	10 f4       	brcc	.+4      	; 0x1c0e <send_frame+0x46>
		c += 48;
    1c0a:	00 5d       	subi	r16, 0xD0	; 208
    1c0c:	05 c0       	rjmp	.+10     	; 0x1c18 <send_frame+0x50>
	}
	else if((c >= 10) && (c <= 16)){
    1c0e:	80 2f       	mov	r24, r16
    1c10:	8a 50       	subi	r24, 0x0A	; 10
    1c12:	87 30       	cpi	r24, 0x07	; 7
    1c14:	08 f4       	brcc	.+2      	; 0x1c18 <send_frame+0x50>
		c += 55;
    1c16:	09 5c       	subi	r16, 0xC9	; 201

	uart3SendByte(flag);

	r1 = num2char(0x0F & (uint8_t)data);
	r2 = num2char(0x0F & ((uint8_t)(data >> 4)) );
	r3 = num2char(0x0F & ((uint8_t)(data >> 8)) );
    1c18:	8d 2f       	mov	r24, r29
    1c1a:	99 27       	eor	r25, r25
    1c1c:	87 fd       	sbrc	r24, 7
    1c1e:	9a 95       	dec	r25
    1c20:	18 2f       	mov	r17, r24
    1c22:	1f 70       	andi	r17, 0x0F	; 15



char num2char(char c){
	
	if(c <10){
    1c24:	1a 30       	cpi	r17, 0x0A	; 10
    1c26:	10 f4       	brcc	.+4      	; 0x1c2c <send_frame+0x64>
		c += 48;
    1c28:	10 5d       	subi	r17, 0xD0	; 208
    1c2a:	05 c0       	rjmp	.+10     	; 0x1c36 <send_frame+0x6e>
	}
	else if((c >= 10) && (c <= 16)){
    1c2c:	81 2f       	mov	r24, r17
    1c2e:	8a 50       	subi	r24, 0x0A	; 10
    1c30:	87 30       	cpi	r24, 0x07	; 7
    1c32:	08 f4       	brcc	.+2      	; 0x1c36 <send_frame+0x6e>
		c += 55;
    1c34:	19 5c       	subi	r17, 0xC9	; 201
	uart3SendByte(flag);

	r1 = num2char(0x0F & (uint8_t)data);
	r2 = num2char(0x0F & ((uint8_t)(data >> 4)) );
	r3 = num2char(0x0F & ((uint8_t)(data >> 8)) );
	r4 = num2char(0x0F & ((uint8_t)(data >> 12)) );
    1c36:	c0 e1       	ldi	r28, 0x10	; 16
    1c38:	dc 02       	muls	r29, r28
    1c3a:	c1 2d       	mov	r28, r1
    1c3c:	dd 0b       	sbc	r29, r29
    1c3e:	11 24       	eor	r1, r1
    1c40:	ce 01       	movw	r24, r28
    1c42:	8f 70       	andi	r24, 0x0F	; 15
    1c44:	68 2f       	mov	r22, r24



char num2char(char c){
	
	if(c <10){
    1c46:	8a 30       	cpi	r24, 0x0A	; 10
    1c48:	10 f4       	brcc	.+4      	; 0x1c4e <send_frame+0x86>
		c += 48;
    1c4a:	60 5d       	subi	r22, 0xD0	; 208
    1c4c:	04 c0       	rjmp	.+8      	; 0x1c56 <send_frame+0x8e>
	}
	else if((c >= 10) && (c <= 16)){
    1c4e:	8a 50       	subi	r24, 0x0A	; 10
    1c50:	87 30       	cpi	r24, 0x07	; 7
    1c52:	08 f4       	brcc	.+2      	; 0x1c56 <send_frame+0x8e>
		c += 55;
    1c54:	69 5c       	subi	r22, 0xC9	; 201
	r1 = num2char(0x0F & (uint8_t)data);
	r2 = num2char(0x0F & ((uint8_t)(data >> 4)) );
	r3 = num2char(0x0F & ((uint8_t)(data >> 8)) );
	r4 = num2char(0x0F & ((uint8_t)(data >> 12)) );

	uart3SendByte(r4);
    1c56:	86 2f       	mov	r24, r22
    1c58:	0e 94 7b 23 	call	0x46f6	; 0x46f6 <uart3SendByte>
	uart3SendByte(r3);
    1c5c:	81 2f       	mov	r24, r17
    1c5e:	0e 94 7b 23 	call	0x46f6	; 0x46f6 <uart3SendByte>
	uart3SendByte(r2);
    1c62:	80 2f       	mov	r24, r16
    1c64:	0e 94 7b 23 	call	0x46f6	; 0x46f6 <uart3SendByte>
	uart3SendByte(r1);
    1c68:	8f 2d       	mov	r24, r15
    1c6a:	0e 94 7b 23 	call	0x46f6	; 0x46f6 <uart3SendByte>
	uart3SendByte('\n'); //line feed
    1c6e:	8a e0       	ldi	r24, 0x0A	; 10
    1c70:	0e 94 7b 23 	call	0x46f6	; 0x46f6 <uart3SendByte>
}
    1c74:	df 91       	pop	r29
    1c76:	cf 91       	pop	r28
    1c78:	1f 91       	pop	r17
    1c7a:	0f 91       	pop	r16
    1c7c:	ff 90       	pop	r15
    1c7e:	08 95       	ret

00001c80 <vUpdatePose>:
		*/

	}
}

void vUpdatePose(){
    1c80:	6f 92       	push	r6
    1c82:	7f 92       	push	r7
    1c84:	8f 92       	push	r8
    1c86:	9f 92       	push	r9
    1c88:	af 92       	push	r10
    1c8a:	bf 92       	push	r11
    1c8c:	cf 92       	push	r12
    1c8e:	df 92       	push	r13
    1c90:	ef 92       	push	r14
    1c92:	ff 92       	push	r15
    1c94:	0f 93       	push	r16
    1c96:	1f 93       	push	r17
	s16 dDis;
	float CMD_K = 0.5;
	float COR_K = 1;

	for(;;){
		robot.heading = (180 * enc_heading) / M_PI; 
    1c98:	60 91 d2 02 	lds	r22, 0x02D2
    1c9c:	70 91 d3 02 	lds	r23, 0x02D3
    1ca0:	80 91 d4 02 	lds	r24, 0x02D4
    1ca4:	90 91 d5 02 	lds	r25, 0x02D5
    1ca8:	20 e0       	ldi	r18, 0x00	; 0
    1caa:	30 e0       	ldi	r19, 0x00	; 0
    1cac:	44 e3       	ldi	r20, 0x34	; 52
    1cae:	53 e4       	ldi	r21, 0x43	; 67
    1cb0:	0e 94 77 2f 	call	0x5eee	; 0x5eee <__mulsf3>
    1cb4:	2b ed       	ldi	r18, 0xDB	; 219
    1cb6:	3f e0       	ldi	r19, 0x0F	; 15
    1cb8:	49 e4       	ldi	r20, 0x49	; 73
    1cba:	50 e4       	ldi	r21, 0x40	; 64
    1cbc:	0e 94 28 2e 	call	0x5c50	; 0x5c50 <__divsf3>
    1cc0:	3b 01       	movw	r6, r22
    1cc2:	4c 01       	movw	r8, r24
    1cc4:	60 93 37 12 	sts	0x1237, r22
    1cc8:	70 93 38 12 	sts	0x1238, r23
    1ccc:	80 93 39 12 	sts	0x1239, r24
    1cd0:	90 93 3a 12 	sts	0x123A, r25
		//v_offset = (0.5 * robot.heading) + CMD_K*cmd_angle + COR_K*correction_angle;
		v_left = (signed int)(v_command - cmd_ang_vel*ROBOT_RADIUS);
    1cd4:	a0 90 ac 02 	lds	r10, 0x02AC
    1cd8:	b0 90 ad 02 	lds	r11, 0x02AD
    1cdc:	c0 90 ae 02 	lds	r12, 0x02AE
    1ce0:	d0 90 af 02 	lds	r13, 0x02AF
    1ce4:	e0 90 de 02 	lds	r14, 0x02DE
    1ce8:	f0 90 df 02 	lds	r15, 0x02DF
    1cec:	00 91 e0 02 	lds	r16, 0x02E0
    1cf0:	10 91 e1 02 	lds	r17, 0x02E1
    1cf4:	c8 01       	movw	r24, r16
    1cf6:	b7 01       	movw	r22, r14
    1cf8:	23 e3       	ldi	r18, 0x33	; 51
    1cfa:	33 e3       	ldi	r19, 0x33	; 51
    1cfc:	43 e0       	ldi	r20, 0x03	; 3
    1cfe:	51 ec       	ldi	r21, 0xC1	; 193
    1d00:	0e 94 77 2f 	call	0x5eee	; 0x5eee <__mulsf3>
    1d04:	9b 01       	movw	r18, r22
    1d06:	ac 01       	movw	r20, r24
    1d08:	c6 01       	movw	r24, r12
    1d0a:	b5 01       	movw	r22, r10
    1d0c:	0e 94 c0 2d 	call	0x5b80	; 0x5b80 <__addsf3>
    1d10:	0e 94 90 2e 	call	0x5d20	; 0x5d20 <__fixsfsi>
    1d14:	70 93 b5 02 	sts	0x02B5, r23
    1d18:	60 93 b4 02 	sts	0x02B4, r22
		//rprintf("v_left: %d\n",v_left);
		v_right = (signed int)(v_command + cmd_ang_vel*ROBOT_RADIUS);
    1d1c:	c8 01       	movw	r24, r16
    1d1e:	b7 01       	movw	r22, r14
    1d20:	23 e3       	ldi	r18, 0x33	; 51
    1d22:	33 e3       	ldi	r19, 0x33	; 51
    1d24:	43 e0       	ldi	r20, 0x03	; 3
    1d26:	51 e4       	ldi	r21, 0x41	; 65
    1d28:	0e 94 77 2f 	call	0x5eee	; 0x5eee <__mulsf3>
    1d2c:	9b 01       	movw	r18, r22
    1d2e:	ac 01       	movw	r20, r24
    1d30:	c6 01       	movw	r24, r12
    1d32:	b5 01       	movw	r22, r10
    1d34:	0e 94 c0 2d 	call	0x5b80	; 0x5b80 <__addsf3>
    1d38:	0e 94 90 2e 	call	0x5d20	; 0x5d20 <__fixsfsi>
    1d3c:	70 93 b7 02 	sts	0x02B7, r23
    1d40:	60 93 b6 02 	sts	0x02B6, r22
		robot.vel = (LEFTVel_current + (-RIGHTVel_current)) / 2;
    1d44:	80 91 b8 02 	lds	r24, 0x02B8
    1d48:	90 91 b9 02 	lds	r25, 0x02B9
    1d4c:	20 91 c5 02 	lds	r18, 0x02C5
    1d50:	30 91 c6 02 	lds	r19, 0x02C6
    1d54:	82 1b       	sub	r24, r18
    1d56:	93 0b       	sbc	r25, r19
    1d58:	62 e0       	ldi	r22, 0x02	; 2
    1d5a:	70 e0       	ldi	r23, 0x00	; 0
    1d5c:	0e 94 0d 30 	call	0x601a	; 0x601a <__divmodhi4>
    1d60:	88 27       	eor	r24, r24
    1d62:	77 fd       	sbrc	r23, 7
    1d64:	80 95       	com	r24
    1d66:	98 2f       	mov	r25, r24
    1d68:	0e 94 c3 2e 	call	0x5d86	; 0x5d86 <__floatsisf>
    1d6c:	60 93 3b 12 	sts	0x123B, r22
    1d70:	70 93 3c 12 	sts	0x123C, r23
    1d74:	80 93 3d 12 	sts	0x123D, r24
    1d78:	90 93 3e 12 	sts	0x123E, r25
		
		dRIGHTDis = (-RIGHTDis_current) - (-RIGHTDis_prev); 
    1d7c:	80 91 c8 02 	lds	r24, 0x02C8
    1d80:	90 91 c9 02 	lds	r25, 0x02C9
    1d84:	a0 91 ca 02 	lds	r26, 0x02CA
    1d88:	b0 91 cb 02 	lds	r27, 0x02CB
    1d8c:	e0 90 cc 02 	lds	r14, 0x02CC
    1d90:	f0 90 cd 02 	lds	r15, 0x02CD
    1d94:	e8 1a       	sub	r14, r24
    1d96:	f9 0a       	sbc	r15, r25
		RIGHTDis_prev = RIGHTDis_current;
    1d98:	80 93 cc 02 	sts	0x02CC, r24
    1d9c:	90 93 cd 02 	sts	0x02CD, r25
    1da0:	a0 93 ce 02 	sts	0x02CE, r26
    1da4:	b0 93 cf 02 	sts	0x02CF, r27
		dLEFTDis = LEFTDis_current - LEFTDis_prev;
    1da8:	80 91 bb 02 	lds	r24, 0x02BB
    1dac:	90 91 bc 02 	lds	r25, 0x02BC
    1db0:	a0 91 bd 02 	lds	r26, 0x02BD
    1db4:	b0 91 be 02 	lds	r27, 0x02BE
    1db8:	20 91 bf 02 	lds	r18, 0x02BF
    1dbc:	30 91 c0 02 	lds	r19, 0x02C0
    1dc0:	8c 01       	movw	r16, r24
    1dc2:	02 1b       	sub	r16, r18
    1dc4:	13 0b       	sbc	r17, r19
		LEFTDis_prev = LEFTDis_current;
    1dc6:	80 93 bf 02 	sts	0x02BF, r24
    1dca:	90 93 c0 02 	sts	0x02C0, r25
    1dce:	a0 93 c1 02 	sts	0x02C1, r26
    1dd2:	b0 93 c2 02 	sts	0x02C2, r27
		
		dDis = (10*(dRIGHTDis + dLEFTDis))/2;	//Send shifted value to avoid decimals
		dRIGHTDis = dLEFTDis = 0;
    1dd6:	10 92 c4 02 	sts	0x02C4, r1
    1dda:	10 92 c3 02 	sts	0x02C3, r1
    1dde:	10 92 d1 02 	sts	0x02D1, r1
    1de2:	10 92 d0 02 	sts	0x02D0, r1
		
		send_frame('H', robot.heading);
    1de6:	c4 01       	movw	r24, r8
    1de8:	b3 01       	movw	r22, r6
    1dea:	0e 94 90 2e 	call	0x5d20	; 0x5d20 <__fixsfsi>
    1dee:	9b 01       	movw	r18, r22
    1df0:	ac 01       	movw	r20, r24
    1df2:	88 e4       	ldi	r24, 0x48	; 72
    1df4:	b9 01       	movw	r22, r18
    1df6:	0e 94 e4 0d 	call	0x1bc8	; 0x1bc8 <send_frame>
		send_frame('V', robot.vel);
    1dfa:	60 91 3b 12 	lds	r22, 0x123B
    1dfe:	70 91 3c 12 	lds	r23, 0x123C
    1e02:	80 91 3d 12 	lds	r24, 0x123D
    1e06:	90 91 3e 12 	lds	r25, 0x123E
    1e0a:	0e 94 90 2e 	call	0x5d20	; 0x5d20 <__fixsfsi>
    1e0e:	9b 01       	movw	r18, r22
    1e10:	ac 01       	movw	r20, r24
    1e12:	86 e5       	ldi	r24, 0x56	; 86
    1e14:	b9 01       	movw	r22, r18
    1e16:	0e 94 e4 0d 	call	0x1bc8	; 0x1bc8 <send_frame>
		send_frame('S', dDis);
    1e1a:	0e 0d       	add	r16, r14
    1e1c:	1f 1d       	adc	r17, r15
    1e1e:	b8 01       	movw	r22, r16
    1e20:	66 0f       	add	r22, r22
    1e22:	77 1f       	adc	r23, r23
    1e24:	66 0f       	add	r22, r22
    1e26:	77 1f       	adc	r23, r23
    1e28:	60 0f       	add	r22, r16
    1e2a:	71 1f       	adc	r23, r17
    1e2c:	83 e5       	ldi	r24, 0x53	; 83
    1e2e:	0e 94 e4 0d 	call	0x1bc8	; 0x1bc8 <send_frame>
    1e32:	32 cf       	rjmp	.-412    	; 0x1c98 <vUpdatePose+0x18>

00001e34 <ubRcv>:
		
			//taskYIELD();
	//	}
}

void ubRcv(unsigned char c){
    1e34:	1f 93       	push	r17
	static char dis_iter; //count iterator for commanded distance
	static char rot_flag;
	static char dis_flag;
	static s16 rot_rough = 0;  //store ascii chars
	static s16 dis_rough = 0;  //store ascii chars
		c = c & 0b01111111;		//for some reason, every byte has its first bit set to 1
    1e36:	18 2f       	mov	r17, r24
    1e38:	1f 77       	andi	r17, 0x7F	; 127
		uart1SendByte(c);
    1e3a:	81 2f       	mov	r24, r17
    1e3c:	0e 94 71 23 	call	0x46e2	; 0x46e2 <uart1SendByte>
		if(c != 0xff){
		//if the data isn't whitespace (0xff), post it
		

			if(c == 0x0a){lf_flag = SET;} //line feed detected, the character will be a 'R' or a 'D'
    1e40:	1a 30       	cpi	r17, 0x0A	; 10
    1e42:	21 f4       	brne	.+8      	; 0x1e4c <ubRcv+0x18>
    1e44:	81 e0       	ldi	r24, 0x01	; 1
    1e46:	80 93 fa 02 	sts	0x02FA, r24
    1e4a:	61 c0       	rjmp	.+194    	; 0x1f0e <ubRcv+0xda>
	
			else if((lf_flag) && (c == 'R')){ //set rotation flag
    1e4c:	80 91 fa 02 	lds	r24, 0x02FA
    1e50:	88 23       	and	r24, r24
    1e52:	91 f0       	breq	.+36     	; 0x1e78 <ubRcv+0x44>
    1e54:	12 35       	cpi	r17, 0x52	; 82
    1e56:	31 f4       	brne	.+12     	; 0x1e64 <ubRcv+0x30>
				rot_flag = SET;
    1e58:	81 e0       	ldi	r24, 0x01	; 1
    1e5a:	80 93 f7 02 	sts	0x02F7, r24
				rot_iter = 0;
    1e5e:	10 92 f9 02 	sts	0x02F9, r1
    1e62:	07 c0       	rjmp	.+14     	; 0x1e72 <ubRcv+0x3e>
				lf_flag = UNSET;
				//rprintf("R: char: %c ",c);
				return;
			} 
			else if((lf_flag) && (c == 'M')){ //set distance flag
    1e64:	1d 34       	cpi	r17, 0x4D	; 77
    1e66:	41 f4       	brne	.+16     	; 0x1e78 <ubRcv+0x44>
				dis_flag = SET;
    1e68:	81 e0       	ldi	r24, 0x01	; 1
    1e6a:	80 93 f6 02 	sts	0x02F6, r24
				dis_iter = 0;
    1e6e:	10 92 f8 02 	sts	0x02F8, r1
				lf_flag = UNSET;
    1e72:	10 92 fa 02 	sts	0x02FA, r1
    1e76:	86 c0       	rjmp	.+268    	; 0x1f84 <ubRcv+0x150>
			//	rprintf("%c",c);
				return;
			}
			else if(rot_flag){
    1e78:	80 91 f7 02 	lds	r24, 0x02F7
    1e7c:	88 23       	and	r24, r24
    1e7e:	11 f1       	breq	.+68     	; 0x1ec4 <ubRcv+0x90>

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
    1e80:	81 2f       	mov	r24, r17
    1e82:	80 53       	subi	r24, 0x30	; 48
    1e84:	8a 30       	cpi	r24, 0x0A	; 10
    1e86:	10 f4       	brcc	.+4      	; 0x1e8c <ubRcv+0x58>
    1e88:	18 2f       	mov	r17, r24
    1e8a:	05 c0       	rjmp	.+10     	; 0x1e96 <ubRcv+0x62>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
    1e8c:	81 2f       	mov	r24, r17
    1e8e:	81 54       	subi	r24, 0x41	; 65
    1e90:	86 30       	cpi	r24, 0x06	; 6
    1e92:	08 f4       	brcc	.+2      	; 0x1e96 <ubRcv+0x62>
		c -= 55;
    1e94:	17 53       	subi	r17, 0x37	; 55
				lf_flag = UNSET;
			//	rprintf("%c",c);
				return;
			}
			else if(rot_flag){
				rot_rough = (char2hex(c) | (rot_rough << 4));	//store then increment	
    1e96:	81 2f       	mov	r24, r17
    1e98:	90 e0       	ldi	r25, 0x00	; 0
    1e9a:	20 91 f4 02 	lds	r18, 0x02F4
    1e9e:	30 91 f5 02 	lds	r19, 0x02F5
    1ea2:	14 e0       	ldi	r17, 0x04	; 4
    1ea4:	22 0f       	add	r18, r18
    1ea6:	33 1f       	adc	r19, r19
    1ea8:	1a 95       	dec	r17
    1eaa:	e1 f7       	brne	.-8      	; 0x1ea4 <ubRcv+0x70>
    1eac:	82 2b       	or	r24, r18
    1eae:	93 2b       	or	r25, r19
    1eb0:	90 93 f5 02 	sts	0x02F5, r25
    1eb4:	80 93 f4 02 	sts	0x02F4, r24
				rot_iter++;
    1eb8:	80 91 f9 02 	lds	r24, 0x02F9
    1ebc:	8f 5f       	subi	r24, 0xFF	; 255
    1ebe:	80 93 f9 02 	sts	0x02F9, r24
    1ec2:	25 c0       	rjmp	.+74     	; 0x1f0e <ubRcv+0xda>
				//rprintf(" #%c\t:%d\t",c,rot_iter);
				//rprintfu08(c); rprintf("\t");
				//rprintfu16(rot_rough);
				//rprintfCRLF();
			}	
			else if(dis_flag){
    1ec4:	80 91 f6 02 	lds	r24, 0x02F6
    1ec8:	88 23       	and	r24, r24
    1eca:	09 f1       	breq	.+66     	; 0x1f0e <ubRcv+0xda>

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
    1ecc:	81 2f       	mov	r24, r17
    1ece:	80 53       	subi	r24, 0x30	; 48
    1ed0:	8a 30       	cpi	r24, 0x0A	; 10
    1ed2:	10 f4       	brcc	.+4      	; 0x1ed8 <ubRcv+0xa4>
    1ed4:	18 2f       	mov	r17, r24
    1ed6:	05 c0       	rjmp	.+10     	; 0x1ee2 <ubRcv+0xae>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
    1ed8:	81 2f       	mov	r24, r17
    1eda:	81 54       	subi	r24, 0x41	; 65
    1edc:	86 30       	cpi	r24, 0x06	; 6
    1ede:	08 f4       	brcc	.+2      	; 0x1ee2 <ubRcv+0xae>
		c -= 55;
    1ee0:	17 53       	subi	r17, 0x37	; 55
				//rprintfu08(c); rprintf("\t");
				//rprintfu16(rot_rough);
				//rprintfCRLF();
			}	
			else if(dis_flag){
				dis_rough = (char2hex(c) | (dis_rough << 4));	//store then increment	
    1ee2:	81 2f       	mov	r24, r17
    1ee4:	90 e0       	ldi	r25, 0x00	; 0
    1ee6:	20 91 f2 02 	lds	r18, 0x02F2
    1eea:	30 91 f3 02 	lds	r19, 0x02F3
    1eee:	b4 e0       	ldi	r27, 0x04	; 4
    1ef0:	22 0f       	add	r18, r18
    1ef2:	33 1f       	adc	r19, r19
    1ef4:	ba 95       	dec	r27
    1ef6:	e1 f7       	brne	.-8      	; 0x1ef0 <ubRcv+0xbc>
    1ef8:	82 2b       	or	r24, r18
    1efa:	93 2b       	or	r25, r19
    1efc:	90 93 f3 02 	sts	0x02F3, r25
    1f00:	80 93 f2 02 	sts	0x02F2, r24
				dis_iter++;
    1f04:	80 91 f8 02 	lds	r24, 0x02F8
    1f08:	8f 5f       	subi	r24, 0xFF	; 255
    1f0a:	80 93 f8 02 	sts	0x02F8, r24
			//	rprintf("%c",c);
			}

			if(rot_iter == 4){
    1f0e:	80 91 f9 02 	lds	r24, 0x02F9
    1f12:	84 30       	cpi	r24, 0x04	; 4
    1f14:	d9 f4       	brne	.+54     	; 0x1f4c <ubRcv+0x118>
				//cmd_angle = retConv_s16(&rot_rough);
				cmd_angle = rot_rough;
    1f16:	60 91 f4 02 	lds	r22, 0x02F4
    1f1a:	70 91 f5 02 	lds	r23, 0x02F5
    1f1e:	88 27       	eor	r24, r24
    1f20:	77 fd       	sbrc	r23, 7
    1f22:	80 95       	com	r24
    1f24:	98 2f       	mov	r25, r24
    1f26:	0e 94 c3 2e 	call	0x5d86	; 0x5d86 <__floatsisf>
    1f2a:	60 93 da 02 	sts	0x02DA, r22
    1f2e:	70 93 db 02 	sts	0x02DB, r23
    1f32:	80 93 dc 02 	sts	0x02DC, r24
    1f36:	90 93 dd 02 	sts	0x02DD, r25
				rot_flag = UNSET;
    1f3a:	10 92 f7 02 	sts	0x02F7, r1
				rot_iter = 0;
    1f3e:	10 92 f9 02 	sts	0x02F9, r1
				//rprintfu16(rot_rough);
				//rprintf("\n\n");
				rot_rough = 0;
    1f42:	10 92 f5 02 	sts	0x02F5, r1
    1f46:	10 92 f4 02 	sts	0x02F4, r1
    1f4a:	1c c0       	rjmp	.+56     	; 0x1f84 <ubRcv+0x150>
			}
			else if(dis_iter == 4){
    1f4c:	80 91 f8 02 	lds	r24, 0x02F8
    1f50:	84 30       	cpi	r24, 0x04	; 4
    1f52:	c1 f4       	brne	.+48     	; 0x1f84 <ubRcv+0x150>
				cmd_dist = dis_rough;
    1f54:	80 91 f2 02 	lds	r24, 0x02F2
    1f58:	90 91 f3 02 	lds	r25, 0x02F3
    1f5c:	aa 27       	eor	r26, r26
    1f5e:	97 fd       	sbrc	r25, 7
    1f60:	a0 95       	com	r26
    1f62:	ba 2f       	mov	r27, r26
    1f64:	80 93 e2 02 	sts	0x02E2, r24
    1f68:	90 93 e3 02 	sts	0x02E3, r25
    1f6c:	a0 93 e4 02 	sts	0x02E4, r26
    1f70:	b0 93 e5 02 	sts	0x02E5, r27
				dis_flag = UNSET;
    1f74:	10 92 f6 02 	sts	0x02F6, r1
				dis_iter = 0;
    1f78:	10 92 f8 02 	sts	0x02F8, r1
				dis_rough = 0;
    1f7c:	10 92 f3 02 	sts	0x02F3, r1
    1f80:	10 92 f2 02 	sts	0x02F2, r1
		
		}

		else{rprintf("WR\n");}
		
}
    1f84:	1f 91       	pop	r17
    1f86:	08 95       	ret

00001f88 <prvSetupHardware>:

void prvSetupHardware(){
    1f88:	0f 93       	push	r16
    1f8a:	1f 93       	push	r17
    1f8c:	cf 93       	push	r28
    1f8e:	df 93       	push	r29
	delay_cycles(65535);
	delay_cycles(65535);
	
	

	uartInit();  // initialize the UART (serial port)
    1f90:	0e 94 1e 27 	call	0x4e3c	; 0x4e3c <uartInit>
    uartSetBaudRate(0, 38400); // set UARTE speed, for Bluetooth
    1f94:	80 e0       	ldi	r24, 0x00	; 0
    1f96:	40 e0       	ldi	r20, 0x00	; 0
    1f98:	56 e9       	ldi	r21, 0x96	; 150
    1f9a:	60 e0       	ldi	r22, 0x00	; 0
    1f9c:	70 e0       	ldi	r23, 0x00	; 0
    1f9e:	0e 94 f8 22 	call	0x45f0	; 0x45f0 <uartSetBaudRate>
    uartSetBaudRate(1, 115200); // set UARTD speed, for USB connection, up to 500k, try 115200 if it doesn't work
    1fa2:	81 e0       	ldi	r24, 0x01	; 1
    1fa4:	40 e0       	ldi	r20, 0x00	; 0
    1fa6:	52 ec       	ldi	r21, 0xC2	; 194
    1fa8:	61 e0       	ldi	r22, 0x01	; 1
    1faa:	70 e0       	ldi	r23, 0x00	; 0
    1fac:	0e 94 f8 22 	call	0x45f0	; 0x45f0 <uartSetBaudRate>
    uartSetBaudRate(2, 38400); // set UARTH speed
    1fb0:	82 e0       	ldi	r24, 0x02	; 2
    1fb2:	40 e0       	ldi	r20, 0x00	; 0
    1fb4:	56 e9       	ldi	r21, 0x96	; 150
    1fb6:	60 e0       	ldi	r22, 0x00	; 0
    1fb8:	70 e0       	ldi	r23, 0x00	; 0
    1fba:	0e 94 f8 22 	call	0x45f0	; 0x45f0 <uartSetBaudRate>
    uartSetBaudRate(3, 38400); // set UARTJ speed, for Blackfin
    1fbe:	83 e0       	ldi	r24, 0x03	; 3
    1fc0:	40 e0       	ldi	r20, 0x00	; 0
    1fc2:	56 e9       	ldi	r21, 0x96	; 150
    1fc4:	60 e0       	ldi	r22, 0x00	; 0
    1fc6:	70 e0       	ldi	r23, 0x00	; 0
    1fc8:	0e 94 f8 22 	call	0x45f0	; 0x45f0 <uartSetBaudRate>
	//G=Ground, T=Tx (connect to external Rx), R=Rx (connect to external Tx)

	rprintfInit(uart1SendByte);// initialize rprintf system and configure uart1 (USB) for rprintf
    1fcc:	81 e7       	ldi	r24, 0x71	; 113
    1fce:	93 e2       	ldi	r25, 0x23	; 35
    1fd0:	0e 94 62 28 	call	0x50c4	; 0x50c4 <rprintfInit>

	configure_ports(); // configure which ports are analog, digital, etc.
    1fd4:	0e 94 78 03 	call	0x6f0	; 0x6f0 <configure_ports>
	*/

	
	//UART ISR *** UART ISR ***
	
	uartSetRxHandler(2, &fwdSer_L);
    1fd8:	82 e0       	ldi	r24, 0x02	; 2
    1fda:	6d e5       	ldi	r22, 0x5D	; 93
    1fdc:	76 e0       	ldi	r23, 0x06	; 6
    1fde:	0e 94 ed 22 	call	0x45da	; 0x45da <uartSetRxHandler>
	uartSetRxHandler(0, &fwdSer_R);
    1fe2:	80 e0       	ldi	r24, 0x00	; 0
    1fe4:	6d ee       	ldi	r22, 0xED	; 237
    1fe6:	76 e0       	ldi	r23, 0x06	; 6
    1fe8:	0e 94 ed 22 	call	0x45da	; 0x45da <uartSetRxHandler>
void LED_on(void)
	{PORT_OFF(PORTB,6);}
    1fec:	2e 98       	cbi	0x05, 6	; 5

	//UART ISR *** UART ISR ***

	LED_on();

	rprintf("\r\nSystem Warmed Up");
    1fee:	00 d0       	rcall	.+0      	; 0x1ff0 <prvSetupHardware+0x68>
    1ff0:	0f 92       	push	r0
    1ff2:	81 e0       	ldi	r24, 0x01	; 1
    1ff4:	ed b7       	in	r30, 0x3d	; 61
    1ff6:	fe b7       	in	r31, 0x3e	; 62
    1ff8:	81 83       	std	Z+1, r24	; 0x01
    1ffa:	83 e8       	ldi	r24, 0x83	; 131
    1ffc:	91 e0       	ldi	r25, 0x01	; 1
    1ffe:	93 83       	std	Z+3, r25	; 0x03
    2000:	82 83       	std	Z+2, r24	; 0x02
    2002:	0e 94 86 2a 	call	0x550c	; 0x550c <rprintf1RamRom>

	// initialize the timer system
 	init_timer0(TIMER_CLK_1024);
    2006:	0f 90       	pop	r0
    2008:	0f 90       	pop	r0
    200a:	0f 90       	pop	r0
    200c:	85 e0       	ldi	r24, 0x05	; 5
    200e:	0e 94 04 1d 	call	0x3a08	; 0x3a08 <init_timer0>
// 	init_timer1(TIMER_CLK_64); // Timer 1 is initialized by FreeRTOS
 	init_timer2(TIMER2_CLK_64);
    2012:	84 e0       	ldi	r24, 0x04	; 4
    2014:	0e 94 24 1d 	call	0x3a48	; 0x3a48 <init_timer2>
 	init_timer3(TIMER_CLK_64);
    2018:	83 e0       	ldi	r24, 0x03	; 3
    201a:	0e 94 34 1d 	call	0x3a68	; 0x3a68 <init_timer3>
 	init_timer4(TIMER_CLK_64);
    201e:	83 e0       	ldi	r24, 0x03	; 3
    2020:	0e 94 46 1d 	call	0x3a8c	; 0x3a8c <init_timer4>
 	init_timer5(TIMER_CLK_64);
    2024:	83 e0       	ldi	r24, 0x03	; 3
    2026:	0e 94 58 1d 	call	0x3ab0	; 0x3ab0 <init_timer5>

	a2dInit(); // initialize analog to digital converter (ADC)
    202a:	0e 94 d7 27 	call	0x4fae	; 0x4fae <a2dInit>
	a2dSetPrescaler(ADC_PRESCALE_DIV32); // configure ADC scaling
    202e:	85 e0       	ldi	r24, 0x05	; 5
    2030:	0e 94 fc 27 	call	0x4ff8	; 0x4ff8 <a2dSetPrescaler>
	a2dSetReference(ADC_REFERENCE_AVCC); // configure ADC reference voltage
    2034:	81 e0       	ldi	r24, 0x01	; 1
    2036:	0e 94 03 28 	call	0x5006	; 0x5006 <a2dSetReference>
    203a:	10 e0       	ldi	r17, 0x00	; 0
	//let system stabelize for X time
	for(i=0;i<16;i++)
		{
		j=a2dConvert8bit(i);//read each ADC once to get it working accurately
		delay_cycles(5000); //keep LED on long enough to see Axon reseting
		rprintf(".");
    203c:	01 e0       	ldi	r16, 0x01	; 1
    203e:	c1 e8       	ldi	r28, 0x81	; 129
    2040:	d1 e0       	ldi	r29, 0x01	; 1
	a2dSetReference(ADC_REFERENCE_AVCC); // configure ADC reference voltage

	//let system stabelize for X time
	for(i=0;i<16;i++)
		{
		j=a2dConvert8bit(i);//read each ADC once to get it working accurately
    2042:	81 2f       	mov	r24, r17
    2044:	0e 94 4c 28 	call	0x5098	; 0x5098 <a2dConvert8bit>
		delay_cycles(5000); //keep LED on long enough to see Axon reseting
		rprintf(".");
    2048:	00 d0       	rcall	.+0      	; 0x204a <prvSetupHardware+0xc2>
    204a:	0f 92       	push	r0
    204c:	ed b7       	in	r30, 0x3d	; 61
    204e:	fe b7       	in	r31, 0x3e	; 62
    2050:	01 83       	std	Z+1, r16	; 0x01
    2052:	d3 83       	std	Z+3, r29	; 0x03
    2054:	c2 83       	std	Z+2, r28	; 0x02
    2056:	0e 94 86 2a 	call	0x550c	; 0x550c <rprintf1RamRom>
    205a:	1f 5f       	subi	r17, 0xFF	; 255
	a2dInit(); // initialize analog to digital converter (ADC)
	a2dSetPrescaler(ADC_PRESCALE_DIV32); // configure ADC scaling
	a2dSetReference(ADC_REFERENCE_AVCC); // configure ADC reference voltage

	//let system stabelize for X time
	for(i=0;i<16;i++)
    205c:	0f 90       	pop	r0
    205e:	0f 90       	pop	r0
    2060:	0f 90       	pop	r0
    2062:	10 31       	cpi	r17, 0x10	; 16
    2064:	71 f7       	brne	.-36     	; 0x2042 <prvSetupHardware+0xba>


//***************STATUS LED**************
//tank test
void LED_off(void)
	{PORT_ON(PORTB,6);}
    2066:	2e 9a       	sbi	0x05, 6	; 5
		rprintf(".");
		}

	LED_off();

	rprintf("Initialization Complete \r\n");
    2068:	00 d0       	rcall	.+0      	; 0x206a <prvSetupHardware+0xe2>
    206a:	0f 92       	push	r0
    206c:	ed b7       	in	r30, 0x3d	; 61
    206e:	fe b7       	in	r31, 0x3e	; 62
    2070:	01 83       	std	Z+1, r16	; 0x01
    2072:	86 e6       	ldi	r24, 0x66	; 102
    2074:	91 e0       	ldi	r25, 0x01	; 1
    2076:	93 83       	std	Z+3, r25	; 0x03
    2078:	82 83       	std	Z+2, r24	; 0x02
    207a:	0e 94 86 2a 	call	0x550c	; 0x550c <rprintf1RamRom>

	//reset all timers to zero
	reset_timer0();
    207e:	0f 90       	pop	r0
    2080:	0f 90       	pop	r0
    2082:	0f 90       	pop	r0
    2084:	0e 94 ba 1c 	call	0x3974	; 0x3974 <reset_timer0>
	reset_timer1();
    2088:	0e 94 c4 1c 	call	0x3988	; 0x3988 <reset_timer1>
	reset_timer2();
    208c:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <reset_timer2>
	reset_timer3();
    2090:	0e 94 dc 1c 	call	0x39b8	; 0x39b8 <reset_timer3>
	reset_timer4();
    2094:	0e 94 e9 1c 	call	0x39d2	; 0x39d2 <reset_timer4>
	reset_timer5();
    2098:	0e 94 f6 1c 	call	0x39ec	; 0x39ec <reset_timer5>



	/********PWM Setup***********/
	prvPWMSetup();
    209c:	0e 94 48 04 	call	0x890	; 0x890 <prvPWMSetup>

}
    20a0:	df 91       	pop	r29
    20a2:	cf 91       	pop	r28
    20a4:	1f 91       	pop	r17
    20a6:	0f 91       	pop	r16
    20a8:	08 95       	ret

000020aa <main>:
float elapsed_time;
float current_time = 0;
float previous_time = 0;

int main(void)
{
    20aa:	af 92       	push	r10
    20ac:	bf 92       	push	r11
    20ae:	cf 92       	push	r12
    20b0:	df 92       	push	r13
    20b2:	ef 92       	push	r14
    20b4:	ff 92       	push	r15
    20b6:	0f 93       	push	r16
    20b8:	cf 93       	push	r28
    20ba:	df 93       	push	r29
	prvSetupHardware();
    20bc:	0e 94 c4 0f 	call	0x1f88	; 0x1f88 <prvSetupHardware>

	key = uart1GetByte();
    20c0:	0e 94 33 26 	call	0x4c66	; 0x4c66 <uart1GetByte>
    20c4:	80 93 43 12 	sts	0x1243, r24
	delay_ms(500);
    20c8:	84 ef       	ldi	r24, 0xF4	; 244
    20ca:	91 e0       	ldi	r25, 0x01	; 1
    20cc:	0e 94 7f 1d 	call	0x3afe	; 0x3afe <sleep>
*/	

//	for(;;);

	
	v_left = v_right = 25;
    20d0:	89 e1       	ldi	r24, 0x19	; 25
    20d2:	90 e0       	ldi	r25, 0x00	; 0
    20d4:	90 93 b7 02 	sts	0x02B7, r25
    20d8:	80 93 b6 02 	sts	0x02B6, r24
    20dc:	90 93 b5 02 	sts	0x02B5, r25
    20e0:	80 93 b4 02 	sts	0x02B4, r24

	xTaskCreate(vLight0On, "Light0", 100, NULL, 1, NULL);
    20e4:	84 e3       	ldi	r24, 0x34	; 52
    20e6:	99 e0       	ldi	r25, 0x09	; 9
    20e8:	60 e0       	ldi	r22, 0x00	; 0
    20ea:	72 e0       	ldi	r23, 0x02	; 2
    20ec:	44 e6       	ldi	r20, 0x64	; 100
    20ee:	50 e0       	ldi	r21, 0x00	; 0
    20f0:	20 e0       	ldi	r18, 0x00	; 0
    20f2:	30 e0       	ldi	r19, 0x00	; 0
    20f4:	01 e0       	ldi	r16, 0x01	; 1
    20f6:	ee 24       	eor	r14, r14
    20f8:	ff 24       	eor	r15, r15
    20fa:	cc 24       	eor	r12, r12
    20fc:	dd 24       	eor	r13, r13
    20fe:	aa 24       	eor	r10, r10
    2100:	bb 24       	eor	r11, r11
    2102:	0e 94 66 17 	call	0x2ecc	; 0x2ecc <xTaskGenericCreate>
	xTaskCreate(vLight1On, "Light1", 100, NULL, 1, NULL);
    2106:	8d e1       	ldi	r24, 0x1D	; 29
    2108:	99 e0       	ldi	r25, 0x09	; 9
    210a:	67 e0       	ldi	r22, 0x07	; 7
    210c:	72 e0       	ldi	r23, 0x02	; 2
    210e:	44 e6       	ldi	r20, 0x64	; 100
    2110:	50 e0       	ldi	r21, 0x00	; 0
    2112:	20 e0       	ldi	r18, 0x00	; 0
    2114:	30 e0       	ldi	r19, 0x00	; 0
    2116:	0e 94 66 17 	call	0x2ecc	; 0x2ecc <xTaskGenericCreate>
//	xTaskCreate(vEnc_UpdatePose, "enUpdtPs", 500, NULL, 1, NULL);
//	xTaskCreate(vServoOsc, "ServoGo", 200, NULL, 1, NULL);
//	xTaskCreate(vServoTm, "ServoTm", 200, NULL, 1, NULL);
//	xTaskCreate(vPID_L, "vPID_L", 500, NULL, 2, NULL);
//	xTaskCreate(vPID_R, "vPID_R", 500, NULL, 2, NULL);
	xTaskCreate(vPID, "vPID", 500, NULL, 2, NULL);
    211a:	8b e4       	ldi	r24, 0x4B	; 75
    211c:	99 e0       	ldi	r25, 0x09	; 9
    211e:	6e e0       	ldi	r22, 0x0E	; 14
    2120:	72 e0       	ldi	r23, 0x02	; 2
    2122:	44 ef       	ldi	r20, 0xF4	; 244
    2124:	51 e0       	ldi	r21, 0x01	; 1
    2126:	20 e0       	ldi	r18, 0x00	; 0
    2128:	30 e0       	ldi	r19, 0x00	; 0
    212a:	02 e0       	ldi	r16, 0x02	; 2
    212c:	0e 94 66 17 	call	0x2ecc	; 0x2ecc <xTaskGenericCreate>
//	xTaskCreate(vScript, "vScript", 100, NULL, 2, NULL);


	vTaskStartScheduler();
    2130:	0e 94 8a 18 	call	0x3114	; 0x3114 <vTaskStartScheduler>
	for(;;){rprintf("DEATH\n");}
    2134:	01 e0       	ldi	r16, 0x01	; 1
    2136:	c4 ee       	ldi	r28, 0xE4	; 228
    2138:	d0 e0       	ldi	r29, 0x00	; 0
    213a:	00 d0       	rcall	.+0      	; 0x213c <main+0x92>
    213c:	0f 92       	push	r0
    213e:	ed b7       	in	r30, 0x3d	; 61
    2140:	fe b7       	in	r31, 0x3e	; 62
    2142:	01 83       	std	Z+1, r16	; 0x01
    2144:	d3 83       	std	Z+3, r29	; 0x03
    2146:	c2 83       	std	Z+2, r28	; 0x02
    2148:	0e 94 86 2a 	call	0x550c	; 0x550c <rprintf1RamRom>
    214c:	0f 90       	pop	r0
    214e:	0f 90       	pop	r0
    2150:	0f 90       	pop	r0
    2152:	f3 cf       	rjmp	.-26     	; 0x213a <main+0x90>

00002154 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    2154:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    2156:	9c 01       	movw	r18, r24
    2158:	2d 5f       	subi	r18, 0xFD	; 253
    215a:	3f 4f       	sbci	r19, 0xFF	; 255
    215c:	32 83       	std	Z+2, r19	; 0x02
    215e:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    2160:	8f ef       	ldi	r24, 0xFF	; 255
    2162:	9f ef       	ldi	r25, 0xFF	; 255
    2164:	94 83       	std	Z+4, r25	; 0x04
    2166:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    2168:	36 83       	std	Z+6, r19	; 0x06
    216a:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    216c:	30 87       	std	Z+8, r19	; 0x08
    216e:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = 0;
    2170:	10 82       	st	Z, r1
}
    2172:	08 95       	ret

00002174 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    2174:	fc 01       	movw	r30, r24
    2176:	11 86       	std	Z+9, r1	; 0x09
    2178:	10 86       	std	Z+8, r1	; 0x08
}
    217a:	08 95       	ret

0000217c <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    217c:	cf 93       	push	r28
    217e:	df 93       	push	r29
    2180:	ac 01       	movw	r20, r24
    2182:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    2184:	ec 01       	movw	r28, r24
    2186:	29 81       	ldd	r18, Y+1	; 0x01
    2188:	3a 81       	ldd	r19, Y+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    218a:	f9 01       	movw	r30, r18
    218c:	82 81       	ldd	r24, Z+2	; 0x02
    218e:	93 81       	ldd	r25, Z+3	; 0x03
    2190:	13 96       	adiw	r26, 0x03	; 3
    2192:	9c 93       	st	X, r25
    2194:	8e 93       	st	-X, r24
    2196:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
    2198:	89 81       	ldd	r24, Y+1	; 0x01
    219a:	9a 81       	ldd	r25, Y+2	; 0x02
    219c:	15 96       	adiw	r26, 0x05	; 5
    219e:	9c 93       	st	X, r25
    21a0:	8e 93       	st	-X, r24
    21a2:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    21a4:	02 80       	ldd	r0, Z+2	; 0x02
    21a6:	f3 81       	ldd	r31, Z+3	; 0x03
    21a8:	e0 2d       	mov	r30, r0
    21aa:	75 83       	std	Z+5, r23	; 0x05
    21ac:	64 83       	std	Z+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    21ae:	e9 01       	movw	r28, r18
    21b0:	7b 83       	std	Y+3, r23	; 0x03
    21b2:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    21b4:	fa 01       	movw	r30, r20
    21b6:	72 83       	std	Z+2, r23	; 0x02
    21b8:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    21ba:	19 96       	adiw	r26, 0x09	; 9
    21bc:	5c 93       	st	X, r21
    21be:	4e 93       	st	-X, r20
    21c0:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
    21c2:	80 81       	ld	r24, Z
    21c4:	8f 5f       	subi	r24, 0xFF	; 255
    21c6:	80 83       	st	Z, r24
}
    21c8:	df 91       	pop	r29
    21ca:	cf 91       	pop	r28
    21cc:	08 95       	ret

000021ce <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    21ce:	cf 93       	push	r28
    21d0:	df 93       	push	r29
    21d2:	9c 01       	movw	r18, r24
    21d4:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    21d6:	48 81       	ld	r20, Y
    21d8:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as 
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the 
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    21da:	8f ef       	ldi	r24, 0xFF	; 255
    21dc:	4f 3f       	cpi	r20, 0xFF	; 255
    21de:	58 07       	cpc	r21, r24
    21e0:	21 f4       	brne	.+8      	; 0x21ea <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    21e2:	f9 01       	movw	r30, r18
    21e4:	a7 81       	ldd	r26, Z+7	; 0x07
    21e6:	b0 85       	ldd	r27, Z+8	; 0x08
    21e8:	10 c0       	rjmp	.+32     	; 0x220a <__stack+0xb>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips. 
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    21ea:	d9 01       	movw	r26, r18
    21ec:	13 96       	adiw	r26, 0x03	; 3
    21ee:	04 c0       	rjmp	.+8      	; 0x21f8 <vListInsert+0x2a>
    21f0:	12 96       	adiw	r26, 0x02	; 2
    21f2:	0d 90       	ld	r0, X+
    21f4:	bc 91       	ld	r27, X
    21f6:	a0 2d       	mov	r26, r0
    21f8:	12 96       	adiw	r26, 0x02	; 2
    21fa:	ed 91       	ld	r30, X+
    21fc:	fc 91       	ld	r31, X
    21fe:	13 97       	sbiw	r26, 0x03	; 3
    2200:	80 81       	ld	r24, Z
    2202:	91 81       	ldd	r25, Z+1	; 0x01
    2204:	48 17       	cp	r20, r24
    2206:	59 07       	cpc	r21, r25
    2208:	98 f7       	brcc	.-26     	; 0x21f0 <vListInsert+0x22>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    220a:	12 96       	adiw	r26, 0x02	; 2
    220c:	ed 91       	ld	r30, X+
    220e:	fc 91       	ld	r31, X
    2210:	13 97       	sbiw	r26, 0x03	; 3
    2212:	fb 83       	std	Y+3, r31	; 0x03
    2214:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    2216:	d5 83       	std	Z+5, r29	; 0x05
    2218:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    221a:	bd 83       	std	Y+5, r27	; 0x05
    221c:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    221e:	13 96       	adiw	r26, 0x03	; 3
    2220:	dc 93       	st	X, r29
    2222:	ce 93       	st	-X, r28
    2224:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2226:	39 87       	std	Y+9, r19	; 0x09
    2228:	28 87       	std	Y+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    222a:	f9 01       	movw	r30, r18
    222c:	80 81       	ld	r24, Z
    222e:	8f 5f       	subi	r24, 0xFF	; 255
    2230:	80 83       	st	Z, r24
}
    2232:	df 91       	pop	r29
    2234:	cf 91       	pop	r28
    2236:	08 95       	ret

00002238 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    2238:	cf 93       	push	r28
    223a:	df 93       	push	r29
    223c:	dc 01       	movw	r26, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    223e:	12 96       	adiw	r26, 0x02	; 2
    2240:	ed 91       	ld	r30, X+
    2242:	fc 91       	ld	r31, X
    2244:	13 97       	sbiw	r26, 0x03	; 3
    2246:	14 96       	adiw	r26, 0x04	; 4
    2248:	8d 91       	ld	r24, X+
    224a:	9c 91       	ld	r25, X
    224c:	15 97       	sbiw	r26, 0x05	; 5
    224e:	95 83       	std	Z+5, r25	; 0x05
    2250:	84 83       	std	Z+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2252:	14 96       	adiw	r26, 0x04	; 4
    2254:	cd 91       	ld	r28, X+
    2256:	dc 91       	ld	r29, X
    2258:	15 97       	sbiw	r26, 0x05	; 5
    225a:	fb 83       	std	Y+3, r31	; 0x03
    225c:	ea 83       	std	Y+2, r30	; 0x02
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    225e:	18 96       	adiw	r26, 0x08	; 8
    2260:	ed 91       	ld	r30, X+
    2262:	fc 91       	ld	r31, X
    2264:	19 97       	sbiw	r26, 0x09	; 9

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    2266:	81 81       	ldd	r24, Z+1	; 0x01
    2268:	92 81       	ldd	r25, Z+2	; 0x02
    226a:	8a 17       	cp	r24, r26
    226c:	9b 07       	cpc	r25, r27
    226e:	11 f4       	brne	.+4      	; 0x2274 <vListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    2270:	d2 83       	std	Z+2, r29	; 0x02
    2272:	c1 83       	std	Z+1, r28	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    2274:	19 96       	adiw	r26, 0x09	; 9
    2276:	1c 92       	st	X, r1
    2278:	1e 92       	st	-X, r1
    227a:	18 97       	sbiw	r26, 0x08	; 8
	( pxList->uxNumberOfItems )--;
    227c:	80 81       	ld	r24, Z
    227e:	81 50       	subi	r24, 0x01	; 1
    2280:	80 83       	st	Z, r24
}
    2282:	df 91       	pop	r29
    2284:	cf 91       	pop	r28
    2286:	08 95       	ret

00002288 <uxQueueMessagesWaiting>:
	return xReturn;
}
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    2288:	fc 01       	movw	r30, r24
unsigned portBASE_TYPE uxReturn;

	taskENTER_CRITICAL();
    228a:	0f b6       	in	r0, 0x3f	; 63
    228c:	f8 94       	cli
    228e:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    2290:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    2292:	0f 90       	pop	r0
    2294:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    2296:	08 95       	ret

00002298 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    2298:	fc 01       	movw	r30, r24
unsigned portBASE_TYPE uxReturn;

	uxReturn = pxQueue->uxMessagesWaiting;
    229a:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
    229c:	08 95       	ret

0000229e <xQueueIsQueueEmptyFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    229e:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    22a0:	82 8d       	ldd	r24, Z+26	; 0x1a
    22a2:	90 e0       	ldi	r25, 0x00	; 0
    22a4:	88 23       	and	r24, r24
    22a6:	09 f4       	brne	.+2      	; 0x22aa <xQueueIsQueueEmptyFromISR+0xc>
    22a8:	91 e0       	ldi	r25, 0x01	; 1

	return xReturn;
}
    22aa:	89 2f       	mov	r24, r25
    22ac:	08 95       	ret

000022ae <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    22ae:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    22b0:	92 8d       	ldd	r25, Z+26	; 0x1a
    22b2:	20 e0       	ldi	r18, 0x00	; 0
    22b4:	83 8d       	ldd	r24, Z+27	; 0x1b
    22b6:	98 17       	cp	r25, r24
    22b8:	09 f4       	brne	.+2      	; 0x22bc <xQueueIsQueueFullFromISR+0xe>
    22ba:	21 e0       	ldi	r18, 0x01	; 1

	return xReturn;
}
    22bc:	82 2f       	mov	r24, r18
    22be:	08 95       	ret

000022c0 <vQueueDelete>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    22c0:	0f 93       	push	r16
    22c2:	1f 93       	push	r17
    22c4:	8c 01       	movw	r16, r24
	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    22c6:	fc 01       	movw	r30, r24
    22c8:	80 81       	ld	r24, Z
    22ca:	91 81       	ldd	r25, Z+1	; 0x01
    22cc:	0e 94 b9 1b 	call	0x3772	; 0x3772 <vPortFree>
	vPortFree( pxQueue );
    22d0:	c8 01       	movw	r24, r16
    22d2:	0e 94 b9 1b 	call	0x3772	; 0x3772 <vPortFree>
}
    22d6:	1f 91       	pop	r17
    22d8:	0f 91       	pop	r16
    22da:	08 95       	ret

000022dc <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    22dc:	0f 93       	push	r16
    22de:	1f 93       	push	r17
    22e0:	cf 93       	push	r28
    22e2:	df 93       	push	r29
    22e4:	ec 01       	movw	r28, r24
    22e6:	fb 01       	movw	r30, r22
    22e8:	8a 01       	movw	r16, r20
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    22ea:	8a 8d       	ldd	r24, Y+26	; 0x1a
    22ec:	88 23       	and	r24, r24
    22ee:	81 f1       	breq	.+96     	; 0x2350 <xQueueReceiveFromISR+0x74>
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    22f0:	48 81       	ld	r20, Y
    22f2:	59 81       	ldd	r21, Y+1	; 0x01
    22f4:	41 15       	cp	r20, r1
    22f6:	51 05       	cpc	r21, r1
    22f8:	a9 f0       	breq	.+42     	; 0x2324 <xQueueReceiveFromISR+0x48>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    22fa:	8c 8d       	ldd	r24, Y+28	; 0x1c
    22fc:	2e 81       	ldd	r18, Y+6	; 0x06
    22fe:	3f 81       	ldd	r19, Y+7	; 0x07
    2300:	28 0f       	add	r18, r24
    2302:	31 1d       	adc	r19, r1
    2304:	3f 83       	std	Y+7, r19	; 0x07
    2306:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    2308:	8a 81       	ldd	r24, Y+2	; 0x02
    230a:	9b 81       	ldd	r25, Y+3	; 0x03
    230c:	28 17       	cp	r18, r24
    230e:	39 07       	cpc	r19, r25
    2310:	10 f0       	brcs	.+4      	; 0x2316 <xQueueReceiveFromISR+0x3a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    2312:	5f 83       	std	Y+7, r21	; 0x07
    2314:	4e 83       	std	Y+6, r20	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    2316:	4c 8d       	ldd	r20, Y+28	; 0x1c
    2318:	6e 81       	ldd	r22, Y+6	; 0x06
    231a:	7f 81       	ldd	r23, Y+7	; 0x07
    231c:	cf 01       	movw	r24, r30
    231e:	50 e0       	ldi	r21, 0x00	; 0
    2320:	0e 94 a0 2d 	call	0x5b40	; 0x5b40 <memcpy>
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
			--( pxQueue->uxMessagesWaiting );
    2324:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2326:	81 50       	subi	r24, 0x01	; 1
    2328:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    232a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    232c:	8f 3f       	cpi	r24, 0xFF	; 255
    232e:	69 f4       	brne	.+26     	; 0x234a <xQueueReceiveFromISR+0x6e>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
    2330:	88 85       	ldd	r24, Y+8	; 0x08
    2332:	88 23       	and	r24, r24
    2334:	61 f0       	breq	.+24     	; 0x234e <xQueueReceiveFromISR+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2336:	ce 01       	movw	r24, r28
    2338:	08 96       	adiw	r24, 0x08	; 8
    233a:	0e 94 ce 14 	call	0x299c	; 0x299c <xTaskRemoveFromEventList>
    233e:	88 23       	and	r24, r24
    2340:	31 f0       	breq	.+12     	; 0x234e <xQueueReceiveFromISR+0x72>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    2342:	81 e0       	ldi	r24, 0x01	; 1
    2344:	f8 01       	movw	r30, r16
    2346:	80 83       	st	Z, r24
    2348:	03 c0       	rjmp	.+6      	; 0x2350 <xQueueReceiveFromISR+0x74>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    234a:	8f 5f       	subi	r24, 0xFF	; 255
    234c:	8d 8f       	std	Y+29, r24	; 0x1d
    234e:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    2350:	df 91       	pop	r29
    2352:	cf 91       	pop	r28
    2354:	1f 91       	pop	r17
    2356:	0f 91       	pop	r16
    2358:	08 95       	ret

0000235a <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    235a:	cf 93       	push	r28
    235c:	df 93       	push	r29
    235e:	ec 01       	movw	r28, r24
    2360:	84 2f       	mov	r24, r20
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    2362:	4c 8d       	ldd	r20, Y+28	; 0x1c
    2364:	44 23       	and	r20, r20
    2366:	a1 f1       	breq	.+104    	; 0x23d0 <prvCopyDataToQueue+0x76>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    2368:	88 23       	and	r24, r24
    236a:	b1 f4       	brne	.+44     	; 0x2398 <prvCopyDataToQueue+0x3e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    236c:	8c 81       	ldd	r24, Y+4	; 0x04
    236e:	9d 81       	ldd	r25, Y+5	; 0x05
    2370:	50 e0       	ldi	r21, 0x00	; 0
    2372:	0e 94 a0 2d 	call	0x5b40	; 0x5b40 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    2376:	8c 8d       	ldd	r24, Y+28	; 0x1c
    2378:	2c 81       	ldd	r18, Y+4	; 0x04
    237a:	3d 81       	ldd	r19, Y+5	; 0x05
    237c:	28 0f       	add	r18, r24
    237e:	31 1d       	adc	r19, r1
    2380:	3d 83       	std	Y+5, r19	; 0x05
    2382:	2c 83       	std	Y+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    2384:	8a 81       	ldd	r24, Y+2	; 0x02
    2386:	9b 81       	ldd	r25, Y+3	; 0x03
    2388:	28 17       	cp	r18, r24
    238a:	39 07       	cpc	r19, r25
    238c:	08 f1       	brcs	.+66     	; 0x23d0 <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    238e:	88 81       	ld	r24, Y
    2390:	99 81       	ldd	r25, Y+1	; 0x01
    2392:	9d 83       	std	Y+5, r25	; 0x05
    2394:	8c 83       	std	Y+4, r24	; 0x04
    2396:	1c c0       	rjmp	.+56     	; 0x23d0 <prvCopyDataToQueue+0x76>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    2398:	8e 81       	ldd	r24, Y+6	; 0x06
    239a:	9f 81       	ldd	r25, Y+7	; 0x07
    239c:	50 e0       	ldi	r21, 0x00	; 0
    239e:	0e 94 a0 2d 	call	0x5b40	; 0x5b40 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    23a2:	8c 8d       	ldd	r24, Y+28	; 0x1c
    23a4:	90 e0       	ldi	r25, 0x00	; 0
    23a6:	44 27       	eor	r20, r20
    23a8:	55 27       	eor	r21, r21
    23aa:	48 1b       	sub	r20, r24
    23ac:	59 0b       	sbc	r21, r25
    23ae:	8e 81       	ldd	r24, Y+6	; 0x06
    23b0:	9f 81       	ldd	r25, Y+7	; 0x07
    23b2:	84 0f       	add	r24, r20
    23b4:	95 1f       	adc	r25, r21
    23b6:	9f 83       	std	Y+7, r25	; 0x07
    23b8:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    23ba:	28 81       	ld	r18, Y
    23bc:	39 81       	ldd	r19, Y+1	; 0x01
    23be:	82 17       	cp	r24, r18
    23c0:	93 07       	cpc	r25, r19
    23c2:	30 f4       	brcc	.+12     	; 0x23d0 <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    23c4:	8a 81       	ldd	r24, Y+2	; 0x02
    23c6:	9b 81       	ldd	r25, Y+3	; 0x03
    23c8:	84 0f       	add	r24, r20
    23ca:	95 1f       	adc	r25, r21
    23cc:	9f 83       	std	Y+7, r25	; 0x07
    23ce:	8e 83       	std	Y+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    23d0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    23d2:	8f 5f       	subi	r24, 0xFF	; 255
    23d4:	8a 8f       	std	Y+26, r24	; 0x1a
}
    23d6:	df 91       	pop	r29
    23d8:	cf 91       	pop	r28
    23da:	08 95       	ret

000023dc <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    23dc:	0f 93       	push	r16
    23de:	1f 93       	push	r17
    23e0:	cf 93       	push	r28
    23e2:	df 93       	push	r29
    23e4:	ec 01       	movw	r28, r24
    23e6:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    23e8:	9a 8d       	ldd	r25, Y+26	; 0x1a
    23ea:	8b 8d       	ldd	r24, Y+27	; 0x1b
    23ec:	98 17       	cp	r25, r24
    23ee:	10 f0       	brcs	.+4      	; 0x23f4 <xQueueGenericSendFromISR+0x18>
    23f0:	80 e0       	ldi	r24, 0x00	; 0
    23f2:	17 c0       	rjmp	.+46     	; 0x2422 <xQueueGenericSendFromISR+0x46>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    23f4:	ce 01       	movw	r24, r28
    23f6:	42 2f       	mov	r20, r18
    23f8:	0e 94 ad 11 	call	0x235a	; 0x235a <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    23fc:	8e 8d       	ldd	r24, Y+30	; 0x1e
    23fe:	8f 3f       	cpi	r24, 0xFF	; 255
    2400:	69 f4       	brne	.+26     	; 0x241c <xQueueGenericSendFromISR+0x40>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    2402:	89 89       	ldd	r24, Y+17	; 0x11
    2404:	88 23       	and	r24, r24
    2406:	61 f0       	breq	.+24     	; 0x2420 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2408:	ce 01       	movw	r24, r28
    240a:	41 96       	adiw	r24, 0x11	; 17
    240c:	0e 94 ce 14 	call	0x299c	; 0x299c <xTaskRemoveFromEventList>
    2410:	88 23       	and	r24, r24
    2412:	31 f0       	breq	.+12     	; 0x2420 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    2414:	81 e0       	ldi	r24, 0x01	; 1
    2416:	f8 01       	movw	r30, r16
    2418:	80 83       	st	Z, r24
    241a:	03 c0       	rjmp	.+6      	; 0x2422 <xQueueGenericSendFromISR+0x46>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    241c:	8f 5f       	subi	r24, 0xFF	; 255
    241e:	8e 8f       	std	Y+30, r24	; 0x1e
    2420:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    2422:	df 91       	pop	r29
    2424:	cf 91       	pop	r28
    2426:	1f 91       	pop	r17
    2428:	0f 91       	pop	r16
    242a:	08 95       	ret

0000242c <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    242c:	0f 93       	push	r16
    242e:	1f 93       	push	r17
    2430:	cf 93       	push	r28
    2432:	df 93       	push	r29
    2434:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    2436:	0f b6       	in	r0, 0x3f	; 63
    2438:	f8 94       	cli
    243a:	0f 92       	push	r0
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    243c:	8c 01       	movw	r16, r24
    243e:	0f 5e       	subi	r16, 0xEF	; 239
    2440:	1f 4f       	sbci	r17, 0xFF	; 255
    2442:	0d c0       	rjmp	.+26     	; 0x245e <prvUnlockQueue+0x32>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    2444:	89 89       	ldd	r24, Y+17	; 0x11
    2446:	88 23       	and	r24, r24
    2448:	69 f0       	breq	.+26     	; 0x2464 <prvUnlockQueue+0x38>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    244a:	c8 01       	movw	r24, r16
    244c:	0e 94 ce 14 	call	0x299c	; 0x299c <xTaskRemoveFromEventList>
    2450:	88 23       	and	r24, r24
    2452:	11 f0       	breq	.+4      	; 0x2458 <prvUnlockQueue+0x2c>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    2454:	0e 94 ca 14 	call	0x2994	; 0x2994 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    2458:	8e 8d       	ldd	r24, Y+30	; 0x1e
    245a:	81 50       	subi	r24, 0x01	; 1
    245c:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    245e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2460:	18 16       	cp	r1, r24
    2462:	84 f3       	brlt	.-32     	; 0x2444 <prvUnlockQueue+0x18>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    2464:	8f ef       	ldi	r24, 0xFF	; 255
    2466:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    2468:	0f 90       	pop	r0
    246a:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    246c:	0f b6       	in	r0, 0x3f	; 63
    246e:	f8 94       	cli
    2470:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2472:	8e 01       	movw	r16, r28
    2474:	08 5f       	subi	r16, 0xF8	; 248
    2476:	1f 4f       	sbci	r17, 0xFF	; 255
    2478:	0d c0       	rjmp	.+26     	; 0x2494 <prvUnlockQueue+0x68>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
    247a:	88 85       	ldd	r24, Y+8	; 0x08
    247c:	88 23       	and	r24, r24
    247e:	69 f0       	breq	.+26     	; 0x249a <prvUnlockQueue+0x6e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2480:	c8 01       	movw	r24, r16
    2482:	0e 94 ce 14 	call	0x299c	; 0x299c <xTaskRemoveFromEventList>
    2486:	88 23       	and	r24, r24
    2488:	11 f0       	breq	.+4      	; 0x248e <prvUnlockQueue+0x62>
				{
					vTaskMissedYield();
    248a:	0e 94 ca 14 	call	0x2994	; 0x2994 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    248e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2490:	81 50       	subi	r24, 0x01	; 1
    2492:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2494:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2496:	18 16       	cp	r1, r24
    2498:	84 f3       	brlt	.-32     	; 0x247a <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    249a:	8f ef       	ldi	r24, 0xFF	; 255
    249c:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    249e:	0f 90       	pop	r0
    24a0:	0f be       	out	0x3f, r0	; 63
}
    24a2:	df 91       	pop	r29
    24a4:	cf 91       	pop	r28
    24a6:	1f 91       	pop	r17
    24a8:	0f 91       	pop	r16
    24aa:	08 95       	ret

000024ac <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    24ac:	7f 92       	push	r7
    24ae:	8f 92       	push	r8
    24b0:	9f 92       	push	r9
    24b2:	af 92       	push	r10
    24b4:	bf 92       	push	r11
    24b6:	cf 92       	push	r12
    24b8:	df 92       	push	r13
    24ba:	ef 92       	push	r14
    24bc:	ff 92       	push	r15
    24be:	0f 93       	push	r16
    24c0:	1f 93       	push	r17
    24c2:	df 93       	push	r29
    24c4:	cf 93       	push	r28
    24c6:	00 d0       	rcall	.+0      	; 0x24c8 <xQueueGenericReceive+0x1c>
    24c8:	00 d0       	rcall	.+0      	; 0x24ca <xQueueGenericReceive+0x1e>
    24ca:	0f 92       	push	r0
    24cc:	cd b7       	in	r28, 0x3d	; 61
    24ce:	de b7       	in	r29, 0x3e	; 62
    24d0:	8c 01       	movw	r16, r24
    24d2:	96 2e       	mov	r9, r22
    24d4:	87 2e       	mov	r8, r23
    24d6:	5d 83       	std	Y+5, r21	; 0x05
    24d8:	4c 83       	std	Y+4, r20	; 0x04
    24da:	72 2e       	mov	r7, r18
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    24dc:	91 e1       	ldi	r25, 0x11	; 17
    24de:	c9 2e       	mov	r12, r25
    24e0:	d1 2c       	mov	r13, r1
    24e2:	c0 0e       	add	r12, r16
    24e4:	d1 1e       	adc	r13, r17
    24e6:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    24e8:	7e 01       	movw	r14, r28
    24ea:	08 94       	sec
    24ec:	e1 1c       	adc	r14, r1
    24ee:	f1 1c       	adc	r15, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    24f0:	84 e0       	ldi	r24, 0x04	; 4
    24f2:	a8 2e       	mov	r10, r24
    24f4:	b1 2c       	mov	r11, r1
    24f6:	ac 0e       	add	r10, r28
    24f8:	bd 1e       	adc	r11, r29
    24fa:	01 c0       	rjmp	.+2      	; 0x24fe <xQueueGenericReceive+0x52>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    24fc:	21 e0       	ldi	r18, 0x01	; 1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    24fe:	0f b6       	in	r0, 0x3f	; 63
    2500:	f8 94       	cli
    2502:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    2504:	f8 01       	movw	r30, r16
    2506:	82 8d       	ldd	r24, Z+26	; 0x1a
    2508:	88 23       	and	r24, r24
    250a:	09 f4       	brne	.+2      	; 0x250e <xQueueGenericReceive+0x62>
    250c:	3e c0       	rjmp	.+124    	; 0x258a <xQueueGenericReceive+0xde>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    250e:	e6 80       	ldd	r14, Z+6	; 0x06
    2510:	f7 80       	ldd	r15, Z+7	; 0x07
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    2512:	40 81       	ld	r20, Z
    2514:	51 81       	ldd	r21, Z+1	; 0x01
    2516:	41 15       	cp	r20, r1
    2518:	51 05       	cpc	r21, r1
    251a:	b1 f0       	breq	.+44     	; 0x2548 <xQueueGenericReceive+0x9c>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    251c:	84 8d       	ldd	r24, Z+28	; 0x1c
    251e:	97 01       	movw	r18, r14
    2520:	28 0f       	add	r18, r24
    2522:	31 1d       	adc	r19, r1
    2524:	37 83       	std	Z+7, r19	; 0x07
    2526:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    2528:	82 81       	ldd	r24, Z+2	; 0x02
    252a:	93 81       	ldd	r25, Z+3	; 0x03
    252c:	28 17       	cp	r18, r24
    252e:	39 07       	cpc	r19, r25
    2530:	10 f0       	brcs	.+4      	; 0x2536 <xQueueGenericReceive+0x8a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    2532:	57 83       	std	Z+7, r21	; 0x07
    2534:	46 83       	std	Z+6, r20	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    2536:	f8 01       	movw	r30, r16
    2538:	44 8d       	ldd	r20, Z+28	; 0x1c
    253a:	66 81       	ldd	r22, Z+6	; 0x06
    253c:	77 81       	ldd	r23, Z+7	; 0x07
    253e:	89 2d       	mov	r24, r9
    2540:	98 2d       	mov	r25, r8
    2542:	50 e0       	ldi	r21, 0x00	; 0
    2544:	0e 94 a0 2d 	call	0x5b40	; 0x5b40 <memcpy>
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
    2548:	77 20       	and	r7, r7
    254a:	71 f4       	brne	.+28     	; 0x2568 <xQueueGenericReceive+0xbc>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    254c:	f8 01       	movw	r30, r16
    254e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2550:	81 50       	subi	r24, 0x01	; 1
    2552:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2554:	80 85       	ldd	r24, Z+8	; 0x08
    2556:	88 23       	and	r24, r24
    2558:	a1 f0       	breq	.+40     	; 0x2582 <xQueueGenericReceive+0xd6>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    255a:	c8 01       	movw	r24, r16
    255c:	08 96       	adiw	r24, 0x08	; 8
    255e:	0e 94 ce 14 	call	0x299c	; 0x299c <xTaskRemoveFromEventList>
    2562:	81 30       	cpi	r24, 0x01	; 1
    2564:	71 f4       	brne	.+28     	; 0x2582 <xQueueGenericReceive+0xd6>
    2566:	0b c0       	rjmp	.+22     	; 0x257e <xQueueGenericReceive+0xd2>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    2568:	f8 01       	movw	r30, r16
    256a:	f7 82       	std	Z+7, r15	; 0x07
    256c:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    256e:	81 89       	ldd	r24, Z+17	; 0x11
    2570:	88 23       	and	r24, r24
    2572:	39 f0       	breq	.+14     	; 0x2582 <xQueueGenericReceive+0xd6>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2574:	c6 01       	movw	r24, r12
    2576:	0e 94 ce 14 	call	0x299c	; 0x299c <xTaskRemoveFromEventList>
    257a:	88 23       	and	r24, r24
    257c:	11 f0       	breq	.+4      	; 0x2582 <xQueueGenericReceive+0xd6>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    257e:	0e 94 96 19 	call	0x332c	; 0x332c <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    2582:	0f 90       	pop	r0
    2584:	0f be       	out	0x3f, r0	; 63
    2586:	81 e0       	ldi	r24, 0x01	; 1
    2588:	4a c0       	rjmp	.+148    	; 0x261e <xQueueGenericReceive+0x172>
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    258a:	8c 81       	ldd	r24, Y+4	; 0x04
    258c:	9d 81       	ldd	r25, Y+5	; 0x05
    258e:	89 2b       	or	r24, r25
    2590:	19 f4       	brne	.+6      	; 0x2598 <xQueueGenericReceive+0xec>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2592:	0f 90       	pop	r0
    2594:	0f be       	out	0x3f, r0	; 63
    2596:	42 c0       	rjmp	.+132    	; 0x261c <xQueueGenericReceive+0x170>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    2598:	22 23       	and	r18, r18
    259a:	19 f4       	brne	.+6      	; 0x25a2 <xQueueGenericReceive+0xf6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    259c:	c7 01       	movw	r24, r14
    259e:	0e 94 85 14 	call	0x290a	; 0x290a <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    25a2:	0f 90       	pop	r0
    25a4:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    25a6:	0e 94 29 14 	call	0x2852	; 0x2852 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    25aa:	0f b6       	in	r0, 0x3f	; 63
    25ac:	f8 94       	cli
    25ae:	0f 92       	push	r0
    25b0:	f8 01       	movw	r30, r16
    25b2:	85 8d       	ldd	r24, Z+29	; 0x1d
    25b4:	8f 3f       	cpi	r24, 0xFF	; 255
    25b6:	09 f4       	brne	.+2      	; 0x25ba <xQueueGenericReceive+0x10e>
    25b8:	15 8e       	std	Z+29, r1	; 0x1d
    25ba:	f8 01       	movw	r30, r16
    25bc:	86 8d       	ldd	r24, Z+30	; 0x1e
    25be:	8f 3f       	cpi	r24, 0xFF	; 255
    25c0:	09 f4       	brne	.+2      	; 0x25c4 <xQueueGenericReceive+0x118>
    25c2:	16 8e       	std	Z+30, r1	; 0x1e
    25c4:	0f 90       	pop	r0
    25c6:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    25c8:	c7 01       	movw	r24, r14
    25ca:	b5 01       	movw	r22, r10
    25cc:	0e 94 90 14 	call	0x2920	; 0x2920 <xTaskCheckForTimeOut>
    25d0:	88 23       	and	r24, r24
    25d2:	f9 f4       	brne	.+62     	; 0x2612 <xQueueGenericReceive+0x166>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    25d4:	0f b6       	in	r0, 0x3f	; 63
    25d6:	f8 94       	cli
    25d8:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    25da:	f8 01       	movw	r30, r16
    25dc:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    25de:	0f 90       	pop	r0
    25e0:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
    25e2:	88 23       	and	r24, r24
    25e4:	81 f4       	brne	.+32     	; 0x2606 <xQueueGenericReceive+0x15a>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    25e6:	6c 81       	ldd	r22, Y+4	; 0x04
    25e8:	7d 81       	ldd	r23, Y+5	; 0x05
    25ea:	c6 01       	movw	r24, r12
    25ec:	0e 94 87 15 	call	0x2b0e	; 0x2b0e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    25f0:	c8 01       	movw	r24, r16
    25f2:	0e 94 16 12 	call	0x242c	; 0x242c <prvUnlockQueue>
				if( !xTaskResumeAll() )
    25f6:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <xTaskResumeAll>
    25fa:	88 23       	and	r24, r24
    25fc:	09 f0       	breq	.+2      	; 0x2600 <xQueueGenericReceive+0x154>
    25fe:	7e cf       	rjmp	.-260    	; 0x24fc <xQueueGenericReceive+0x50>
				{
					portYIELD_WITHIN_API();
    2600:	0e 94 96 19 	call	0x332c	; 0x332c <vPortYield>
    2604:	7b cf       	rjmp	.-266    	; 0x24fc <xQueueGenericReceive+0x50>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2606:	c8 01       	movw	r24, r16
    2608:	0e 94 16 12 	call	0x242c	; 0x242c <prvUnlockQueue>
				( void ) xTaskResumeAll();
    260c:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <xTaskResumeAll>
    2610:	75 cf       	rjmp	.-278    	; 0x24fc <xQueueGenericReceive+0x50>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    2612:	c8 01       	movw	r24, r16
    2614:	0e 94 16 12 	call	0x242c	; 0x242c <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2618:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <xTaskResumeAll>
    261c:	80 e0       	ldi	r24, 0x00	; 0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
    261e:	0f 90       	pop	r0
    2620:	0f 90       	pop	r0
    2622:	0f 90       	pop	r0
    2624:	0f 90       	pop	r0
    2626:	0f 90       	pop	r0
    2628:	cf 91       	pop	r28
    262a:	df 91       	pop	r29
    262c:	1f 91       	pop	r17
    262e:	0f 91       	pop	r16
    2630:	ff 90       	pop	r15
    2632:	ef 90       	pop	r14
    2634:	df 90       	pop	r13
    2636:	cf 90       	pop	r12
    2638:	bf 90       	pop	r11
    263a:	af 90       	pop	r10
    263c:	9f 90       	pop	r9
    263e:	8f 90       	pop	r8
    2640:	7f 90       	pop	r7
    2642:	08 95       	ret

00002644 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    2644:	7f 92       	push	r7
    2646:	8f 92       	push	r8
    2648:	9f 92       	push	r9
    264a:	af 92       	push	r10
    264c:	bf 92       	push	r11
    264e:	cf 92       	push	r12
    2650:	df 92       	push	r13
    2652:	ef 92       	push	r14
    2654:	ff 92       	push	r15
    2656:	0f 93       	push	r16
    2658:	1f 93       	push	r17
    265a:	df 93       	push	r29
    265c:	cf 93       	push	r28
    265e:	00 d0       	rcall	.+0      	; 0x2660 <xQueueGenericSend+0x1c>
    2660:	00 d0       	rcall	.+0      	; 0x2662 <xQueueGenericSend+0x1e>
    2662:	0f 92       	push	r0
    2664:	cd b7       	in	r28, 0x3d	; 61
    2666:	de b7       	in	r29, 0x3e	; 62
    2668:	8c 01       	movw	r16, r24
    266a:	6b 01       	movw	r12, r22
    266c:	5d 83       	std	Y+5, r21	; 0x05
    266e:	4c 83       	std	Y+4, r20	; 0x04
    2670:	72 2e       	mov	r7, r18
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2672:	48 e0       	ldi	r20, 0x08	; 8
    2674:	e4 2e       	mov	r14, r20
    2676:	f1 2c       	mov	r15, r1
    2678:	e8 0e       	add	r14, r24
    267a:	f9 1e       	adc	r15, r25
    267c:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    267e:	5e 01       	movw	r10, r28
    2680:	08 94       	sec
    2682:	a1 1c       	adc	r10, r1
    2684:	b1 1c       	adc	r11, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2686:	34 e0       	ldi	r19, 0x04	; 4
    2688:	83 2e       	mov	r8, r19
    268a:	91 2c       	mov	r9, r1
    268c:	8c 0e       	add	r8, r28
    268e:	9d 1e       	adc	r9, r29
    2690:	01 c0       	rjmp	.+2      	; 0x2694 <xQueueGenericSend+0x50>
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2692:	21 e0       	ldi	r18, 0x01	; 1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2694:	0f b6       	in	r0, 0x3f	; 63
    2696:	f8 94       	cli
    2698:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    269a:	f8 01       	movw	r30, r16
    269c:	92 8d       	ldd	r25, Z+26	; 0x1a
    269e:	83 8d       	ldd	r24, Z+27	; 0x1b
    26a0:	98 17       	cp	r25, r24
    26a2:	a8 f4       	brcc	.+42     	; 0x26ce <xQueueGenericSend+0x8a>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    26a4:	c8 01       	movw	r24, r16
    26a6:	b6 01       	movw	r22, r12
    26a8:	47 2d       	mov	r20, r7
    26aa:	0e 94 ad 11 	call	0x235a	; 0x235a <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    26ae:	f8 01       	movw	r30, r16
    26b0:	81 89       	ldd	r24, Z+17	; 0x11
    26b2:	88 23       	and	r24, r24
    26b4:	41 f0       	breq	.+16     	; 0x26c6 <xQueueGenericSend+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    26b6:	c8 01       	movw	r24, r16
    26b8:	41 96       	adiw	r24, 0x11	; 17
    26ba:	0e 94 ce 14 	call	0x299c	; 0x299c <xTaskRemoveFromEventList>
    26be:	81 30       	cpi	r24, 0x01	; 1
    26c0:	11 f4       	brne	.+4      	; 0x26c6 <xQueueGenericSend+0x82>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    26c2:	0e 94 96 19 	call	0x332c	; 0x332c <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    26c6:	0f 90       	pop	r0
    26c8:	0f be       	out	0x3f, r0	; 63
    26ca:	81 e0       	ldi	r24, 0x01	; 1
    26cc:	4c c0       	rjmp	.+152    	; 0x2766 <xQueueGenericSend+0x122>
				function. */
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    26ce:	8c 81       	ldd	r24, Y+4	; 0x04
    26d0:	9d 81       	ldd	r25, Y+5	; 0x05
    26d2:	89 2b       	or	r24, r25
    26d4:	19 f4       	brne	.+6      	; 0x26dc <xQueueGenericSend+0x98>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    26d6:	0f 90       	pop	r0
    26d8:	0f be       	out	0x3f, r0	; 63
    26da:	44 c0       	rjmp	.+136    	; 0x2764 <xQueueGenericSend+0x120>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    26dc:	22 23       	and	r18, r18
    26de:	19 f4       	brne	.+6      	; 0x26e6 <xQueueGenericSend+0xa2>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    26e0:	c5 01       	movw	r24, r10
    26e2:	0e 94 85 14 	call	0x290a	; 0x290a <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    26e6:	0f 90       	pop	r0
    26e8:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    26ea:	0e 94 29 14 	call	0x2852	; 0x2852 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    26ee:	0f b6       	in	r0, 0x3f	; 63
    26f0:	f8 94       	cli
    26f2:	0f 92       	push	r0
    26f4:	f8 01       	movw	r30, r16
    26f6:	85 8d       	ldd	r24, Z+29	; 0x1d
    26f8:	8f 3f       	cpi	r24, 0xFF	; 255
    26fa:	09 f4       	brne	.+2      	; 0x26fe <xQueueGenericSend+0xba>
    26fc:	15 8e       	std	Z+29, r1	; 0x1d
    26fe:	f8 01       	movw	r30, r16
    2700:	86 8d       	ldd	r24, Z+30	; 0x1e
    2702:	8f 3f       	cpi	r24, 0xFF	; 255
    2704:	09 f4       	brne	.+2      	; 0x2708 <xQueueGenericSend+0xc4>
    2706:	16 8e       	std	Z+30, r1	; 0x1e
    2708:	0f 90       	pop	r0
    270a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    270c:	c5 01       	movw	r24, r10
    270e:	b4 01       	movw	r22, r8
    2710:	0e 94 90 14 	call	0x2920	; 0x2920 <xTaskCheckForTimeOut>
    2714:	88 23       	and	r24, r24
    2716:	09 f5       	brne	.+66     	; 0x275a <xQueueGenericSend+0x116>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    2718:	0f b6       	in	r0, 0x3f	; 63
    271a:	f8 94       	cli
    271c:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    271e:	f8 01       	movw	r30, r16
    2720:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    2722:	0f 90       	pop	r0
    2724:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
    2726:	f8 01       	movw	r30, r16
    2728:	83 8d       	ldd	r24, Z+27	; 0x1b
    272a:	98 17       	cp	r25, r24
    272c:	81 f4       	brne	.+32     	; 0x274e <xQueueGenericSend+0x10a>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    272e:	6c 81       	ldd	r22, Y+4	; 0x04
    2730:	7d 81       	ldd	r23, Y+5	; 0x05
    2732:	c7 01       	movw	r24, r14
    2734:	0e 94 87 15 	call	0x2b0e	; 0x2b0e <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    2738:	c8 01       	movw	r24, r16
    273a:	0e 94 16 12 	call	0x242c	; 0x242c <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
    273e:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <xTaskResumeAll>
    2742:	88 23       	and	r24, r24
    2744:	09 f0       	breq	.+2      	; 0x2748 <xQueueGenericSend+0x104>
    2746:	a5 cf       	rjmp	.-182    	; 0x2692 <xQueueGenericSend+0x4e>
				{
					portYIELD_WITHIN_API();
    2748:	0e 94 96 19 	call	0x332c	; 0x332c <vPortYield>
    274c:	a2 cf       	rjmp	.-188    	; 0x2692 <xQueueGenericSend+0x4e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    274e:	c8 01       	movw	r24, r16
    2750:	0e 94 16 12 	call	0x242c	; 0x242c <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2754:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <xTaskResumeAll>
    2758:	9c cf       	rjmp	.-200    	; 0x2692 <xQueueGenericSend+0x4e>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    275a:	c8 01       	movw	r24, r16
    275c:	0e 94 16 12 	call	0x242c	; 0x242c <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2760:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <xTaskResumeAll>
    2764:	80 e0       	ldi	r24, 0x00	; 0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
    2766:	0f 90       	pop	r0
    2768:	0f 90       	pop	r0
    276a:	0f 90       	pop	r0
    276c:	0f 90       	pop	r0
    276e:	0f 90       	pop	r0
    2770:	cf 91       	pop	r28
    2772:	df 91       	pop	r29
    2774:	1f 91       	pop	r17
    2776:	0f 91       	pop	r16
    2778:	ff 90       	pop	r15
    277a:	ef 90       	pop	r14
    277c:	df 90       	pop	r13
    277e:	cf 90       	pop	r12
    2780:	bf 90       	pop	r11
    2782:	af 90       	pop	r10
    2784:	9f 90       	pop	r9
    2786:	8f 90       	pop	r8
    2788:	7f 90       	pop	r7
    278a:	08 95       	ret

0000278c <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    278c:	8f 92       	push	r8
    278e:	9f 92       	push	r9
    2790:	af 92       	push	r10
    2792:	bf 92       	push	r11
    2794:	cf 92       	push	r12
    2796:	df 92       	push	r13
    2798:	ef 92       	push	r14
    279a:	ff 92       	push	r15
    279c:	0f 93       	push	r16
    279e:	1f 93       	push	r17
    27a0:	cf 93       	push	r28
    27a2:	df 93       	push	r29
    27a4:	98 2e       	mov	r9, r24
    27a6:	86 2e       	mov	r8, r22
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    27a8:	88 23       	and	r24, r24
    27aa:	09 f4       	brne	.+2      	; 0x27ae <xQueueCreate+0x22>
    27ac:	42 c0       	rjmp	.+132    	; 0x2832 <xQueueCreate+0xa6>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    27ae:	8f e1       	ldi	r24, 0x1F	; 31
    27b0:	90 e0       	ldi	r25, 0x00	; 0
    27b2:	0e 94 c9 1b 	call	0x3792	; 0x3792 <pvPortMalloc>
    27b6:	8c 01       	movw	r16, r24
    27b8:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    27ba:	00 97       	sbiw	r24, 0x00	; 0
    27bc:	e1 f1       	breq	.+120    	; 0x2836 <xQueueCreate+0xaa>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    27be:	c9 2c       	mov	r12, r9
    27c0:	dd 24       	eor	r13, r13
    27c2:	a8 2c       	mov	r10, r8
    27c4:	bb 24       	eor	r11, r11
    27c6:	ac 9c       	mul	r10, r12
    27c8:	70 01       	movw	r14, r0
    27ca:	ad 9c       	mul	r10, r13
    27cc:	f0 0c       	add	r15, r0
    27ce:	bc 9c       	mul	r11, r12
    27d0:	f0 0c       	add	r15, r0
    27d2:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    27d4:	c7 01       	movw	r24, r14
    27d6:	01 96       	adiw	r24, 0x01	; 1
    27d8:	0e 94 c9 1b 	call	0x3792	; 0x3792 <pvPortMalloc>
    27dc:	9c 01       	movw	r18, r24
    27de:	99 83       	std	Y+1, r25	; 0x01
    27e0:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    27e2:	00 97       	sbiw	r24, 0x00	; 0
    27e4:	19 f1       	breq	.+70     	; 0x282c <xQueueCreate+0xa0>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    27e6:	e8 0e       	add	r14, r24
    27e8:	f9 1e       	adc	r15, r25
    27ea:	fb 82       	std	Y+3, r15	; 0x03
    27ec:	ea 82       	std	Y+2, r14	; 0x02
				pxNewQueue->uxMessagesWaiting = 0;
    27ee:	1a 8e       	std	Y+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    27f0:	9d 83       	std	Y+5, r25	; 0x05
    27f2:	8c 83       	std	Y+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
    27f4:	08 94       	sec
    27f6:	c1 08       	sbc	r12, r1
    27f8:	d1 08       	sbc	r13, r1
    27fa:	ca 9c       	mul	r12, r10
    27fc:	c0 01       	movw	r24, r0
    27fe:	cb 9c       	mul	r12, r11
    2800:	90 0d       	add	r25, r0
    2802:	da 9c       	mul	r13, r10
    2804:	90 0d       	add	r25, r0
    2806:	11 24       	eor	r1, r1
    2808:	28 0f       	add	r18, r24
    280a:	39 1f       	adc	r19, r25
    280c:	3f 83       	std	Y+7, r19	; 0x07
    280e:	2e 83       	std	Y+6, r18	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    2810:	9b 8e       	std	Y+27, r9	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    2812:	8c 8e       	std	Y+28, r8	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    2814:	8f ef       	ldi	r24, 0xFF	; 255
    2816:	8d 8f       	std	Y+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    2818:	8e 8f       	std	Y+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    281a:	c8 01       	movw	r24, r16
    281c:	08 96       	adiw	r24, 0x08	; 8
    281e:	0e 94 aa 10 	call	0x2154	; 0x2154 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    2822:	c8 01       	movw	r24, r16
    2824:	41 96       	adiw	r24, 0x11	; 17
    2826:	0e 94 aa 10 	call	0x2154	; 0x2154 <vListInitialise>
    282a:	05 c0       	rjmp	.+10     	; 0x2836 <xQueueCreate+0xaa>
				return  pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    282c:	c8 01       	movw	r24, r16
    282e:	0e 94 b9 1b 	call	0x3772	; 0x3772 <vPortFree>
    2832:	c0 e0       	ldi	r28, 0x00	; 0
    2834:	d0 e0       	ldi	r29, 0x00	; 0
	}

	/* Will only reach here if we could not allocate enough memory or no memory
	was required. */
	return NULL;
}
    2836:	ce 01       	movw	r24, r28
    2838:	df 91       	pop	r29
    283a:	cf 91       	pop	r28
    283c:	1f 91       	pop	r17
    283e:	0f 91       	pop	r16
    2840:	ff 90       	pop	r15
    2842:	ef 90       	pop	r14
    2844:	df 90       	pop	r13
    2846:	cf 90       	pop	r12
    2848:	bf 90       	pop	r11
    284a:	af 90       	pop	r10
    284c:	9f 90       	pop	r9
    284e:	8f 90       	pop	r8
    2850:	08 95       	ret

00002852 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    2852:	80 91 23 03 	lds	r24, 0x0323
    2856:	8f 5f       	subi	r24, 0xFF	; 255
    2858:	80 93 23 03 	sts	0x0323, r24
}
    285c:	08 95       	ret

0000285e <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portENTER_CRITICAL();
    285e:	0f b6       	in	r0, 0x3f	; 63
    2860:	f8 94       	cli
    2862:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    2864:	20 91 21 03 	lds	r18, 0x0321
    2868:	30 91 22 03 	lds	r19, 0x0322
	}
	portEXIT_CRITICAL();
    286c:	0f 90       	pop	r0
    286e:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    2870:	c9 01       	movw	r24, r18
    2872:	08 95       	ret

00002874 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
	return xTickCount;
    2874:	20 91 21 03 	lds	r18, 0x0321
    2878:	30 91 22 03 	lds	r19, 0x0322
}
    287c:	c9 01       	movw	r24, r18
    287e:	08 95       	ret

00002880 <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    2880:	80 91 26 03 	lds	r24, 0x0326
}
    2884:	08 95       	ret

00002886 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2886:	80 91 23 03 	lds	r24, 0x0323
    288a:	88 23       	and	r24, r24
    288c:	51 f0       	breq	.+20     	; 0x28a2 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    288e:	81 e0       	ldi	r24, 0x01	; 1
    2890:	80 93 1f 03 	sts	0x031F, r24
    2894:	08 95       	ret
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
	{
		--uxTopReadyPriority;
    2896:	80 91 24 03 	lds	r24, 0x0324
    289a:	81 50       	subi	r24, 0x01	; 1
    289c:	80 93 24 03 	sts	0x0324, r24
    28a0:	01 c0       	rjmp	.+2      	; 0x28a4 <vTaskSwitchContext+0x1e>

	taskFIRST_CHECK_FOR_STACK_OVERFLOW();
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    28a2:	99 e0       	ldi	r25, 0x09	; 9
    28a4:	e0 91 24 03 	lds	r30, 0x0324
    28a8:	e9 9f       	mul	r30, r25
    28aa:	f0 01       	movw	r30, r0
    28ac:	11 24       	eor	r1, r1
    28ae:	e5 5d       	subi	r30, 0xD5	; 213
    28b0:	fc 4f       	sbci	r31, 0xFC	; 252
    28b2:	80 81       	ld	r24, Z
    28b4:	88 23       	and	r24, r24
    28b6:	79 f3       	breq	.-34     	; 0x2896 <vTaskSwitchContext+0x10>
		--uxTopReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    28b8:	90 91 24 03 	lds	r25, 0x0324
    28bc:	89 e0       	ldi	r24, 0x09	; 9
    28be:	98 9f       	mul	r25, r24
    28c0:	d0 01       	movw	r26, r0
    28c2:	11 24       	eor	r1, r1
    28c4:	a5 5d       	subi	r26, 0xD5	; 213
    28c6:	bc 4f       	sbci	r27, 0xFC	; 252
    28c8:	11 96       	adiw	r26, 0x01	; 1
    28ca:	ed 91       	ld	r30, X+
    28cc:	fc 91       	ld	r31, X
    28ce:	12 97       	sbiw	r26, 0x02	; 2
    28d0:	02 80       	ldd	r0, Z+2	; 0x02
    28d2:	f3 81       	ldd	r31, Z+3	; 0x03
    28d4:	e0 2d       	mov	r30, r0
    28d6:	12 96       	adiw	r26, 0x02	; 2
    28d8:	fc 93       	st	X, r31
    28da:	ee 93       	st	-X, r30
    28dc:	11 97       	sbiw	r26, 0x01	; 1
    28de:	cd 01       	movw	r24, r26
    28e0:	03 96       	adiw	r24, 0x03	; 3
    28e2:	e8 17       	cp	r30, r24
    28e4:	f9 07       	cpc	r31, r25
    28e6:	31 f4       	brne	.+12     	; 0x28f4 <vTaskSwitchContext+0x6e>
    28e8:	82 81       	ldd	r24, Z+2	; 0x02
    28ea:	93 81       	ldd	r25, Z+3	; 0x03
    28ec:	12 96       	adiw	r26, 0x02	; 2
    28ee:	9c 93       	st	X, r25
    28f0:	8e 93       	st	-X, r24
    28f2:	11 97       	sbiw	r26, 0x01	; 1
    28f4:	11 96       	adiw	r26, 0x01	; 1
    28f6:	ed 91       	ld	r30, X+
    28f8:	fc 91       	ld	r31, X
    28fa:	12 97       	sbiw	r26, 0x02	; 2
    28fc:	86 81       	ldd	r24, Z+6	; 0x06
    28fe:	97 81       	ldd	r25, Z+7	; 0x07
    2900:	90 93 1e 03 	sts	0x031E, r25
    2904:	80 93 1d 03 	sts	0x031D, r24
    2908:	08 95       	ret

0000290a <vTaskSetTimeOutState>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    290a:	fc 01       	movw	r30, r24
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    290c:	80 91 20 03 	lds	r24, 0x0320
    2910:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    2912:	80 91 21 03 	lds	r24, 0x0321
    2916:	90 91 22 03 	lds	r25, 0x0322
    291a:	92 83       	std	Z+2, r25	; 0x02
    291c:	81 83       	std	Z+1, r24	; 0x01
}
    291e:	08 95       	ret

00002920 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    2920:	fc 01       	movw	r30, r24
    2922:	db 01       	movw	r26, r22
portBASE_TYPE xReturn;

	portENTER_CRITICAL();
    2924:	0f b6       	in	r0, 0x3f	; 63
    2926:	f8 94       	cli
    2928:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    292a:	90 91 20 03 	lds	r25, 0x0320
    292e:	80 81       	ld	r24, Z
    2930:	98 17       	cp	r25, r24
    2932:	49 f0       	breq	.+18     	; 0x2946 <xTaskCheckForTimeOut+0x26>
    2934:	20 91 21 03 	lds	r18, 0x0321
    2938:	30 91 22 03 	lds	r19, 0x0322
    293c:	81 81       	ldd	r24, Z+1	; 0x01
    293e:	92 81       	ldd	r25, Z+2	; 0x02
    2940:	28 17       	cp	r18, r24
    2942:	39 07       	cpc	r19, r25
    2944:	18 f5       	brcc	.+70     	; 0x298c <xTaskCheckForTimeOut+0x6c>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    2946:	80 91 21 03 	lds	r24, 0x0321
    294a:	90 91 22 03 	lds	r25, 0x0322
    294e:	21 81       	ldd	r18, Z+1	; 0x01
    2950:	32 81       	ldd	r19, Z+2	; 0x02
    2952:	4d 91       	ld	r20, X+
    2954:	5c 91       	ld	r21, X
    2956:	11 97       	sbiw	r26, 0x01	; 1
    2958:	82 1b       	sub	r24, r18
    295a:	93 0b       	sbc	r25, r19
    295c:	84 17       	cp	r24, r20
    295e:	95 07       	cpc	r25, r21
    2960:	a8 f4       	brcc	.+42     	; 0x298c <xTaskCheckForTimeOut+0x6c>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    2962:	80 91 21 03 	lds	r24, 0x0321
    2966:	90 91 22 03 	lds	r25, 0x0322
    296a:	28 1b       	sub	r18, r24
    296c:	39 0b       	sbc	r19, r25
    296e:	24 0f       	add	r18, r20
    2970:	35 1f       	adc	r19, r21
    2972:	2d 93       	st	X+, r18
    2974:	3c 93       	st	X, r19
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2976:	80 91 20 03 	lds	r24, 0x0320
    297a:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    297c:	80 91 21 03 	lds	r24, 0x0321
    2980:	90 91 22 03 	lds	r25, 0x0322
    2984:	92 83       	std	Z+2, r25	; 0x02
    2986:	81 83       	std	Z+1, r24	; 0x01
    2988:	80 e0       	ldi	r24, 0x00	; 0
    298a:	01 c0       	rjmp	.+2      	; 0x298e <xTaskCheckForTimeOut+0x6e>
    298c:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			xReturn = pdTRUE;
		}
	}
	portEXIT_CRITICAL();
    298e:	0f 90       	pop	r0
    2990:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2992:	08 95       	ret

00002994 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    2994:	81 e0       	ldi	r24, 0x01	; 1
    2996:	80 93 1f 03 	sts	0x031F, r24
}
    299a:	08 95       	ret

0000299c <xTaskRemoveFromEventList>:
	#endif
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    299c:	0f 93       	push	r16
    299e:	1f 93       	push	r17
    29a0:	cf 93       	push	r28
    29a2:	df 93       	push	r29
    29a4:	fc 01       	movw	r30, r24
	it to the ready list.

	If an event is for a queue that is locked then this function will never
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    29a6:	80 81       	ld	r24, Z
    29a8:	88 23       	and	r24, r24
    29aa:	19 f4       	brne	.+6      	; 0x29b2 <xTaskRemoveFromEventList+0x16>
    29ac:	c0 e0       	ldi	r28, 0x00	; 0
    29ae:	d0 e0       	ldi	r29, 0x00	; 0
    29b0:	05 c0       	rjmp	.+10     	; 0x29bc <xTaskRemoveFromEventList+0x20>
    29b2:	05 80       	ldd	r0, Z+5	; 0x05
    29b4:	f6 81       	ldd	r31, Z+6	; 0x06
    29b6:	e0 2d       	mov	r30, r0
    29b8:	c6 81       	ldd	r28, Z+6	; 0x06
    29ba:	d7 81       	ldd	r29, Z+7	; 0x07
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    29bc:	8e 01       	movw	r16, r28
    29be:	04 5f       	subi	r16, 0xF4	; 244
    29c0:	1f 4f       	sbci	r17, 0xFF	; 255
    29c2:	c8 01       	movw	r24, r16
    29c4:	0e 94 1c 11 	call	0x2238	; 0x2238 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    29c8:	80 91 23 03 	lds	r24, 0x0323
    29cc:	88 23       	and	r24, r24
    29ce:	a1 f4       	brne	.+40     	; 0x29f8 <xTaskRemoveFromEventList+0x5c>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    29d0:	8e 01       	movw	r16, r28
    29d2:	0e 5f       	subi	r16, 0xFE	; 254
    29d4:	1f 4f       	sbci	r17, 0xFF	; 255
    29d6:	c8 01       	movw	r24, r16
    29d8:	0e 94 1c 11 	call	0x2238	; 0x2238 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    29dc:	9e 89       	ldd	r25, Y+22	; 0x16
    29de:	80 91 24 03 	lds	r24, 0x0324
    29e2:	89 17       	cp	r24, r25
    29e4:	10 f4       	brcc	.+4      	; 0x29ea <xTaskRemoveFromEventList+0x4e>
    29e6:	90 93 24 03 	sts	0x0324, r25
    29ea:	89 e0       	ldi	r24, 0x09	; 9
    29ec:	98 9f       	mul	r25, r24
    29ee:	c0 01       	movw	r24, r0
    29f0:	11 24       	eor	r1, r1
    29f2:	85 5d       	subi	r24, 0xD5	; 213
    29f4:	9c 4f       	sbci	r25, 0xFC	; 252
    29f6:	02 c0       	rjmp	.+4      	; 0x29fc <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    29f8:	85 e6       	ldi	r24, 0x65	; 101
    29fa:	93 e0       	ldi	r25, 0x03	; 3
    29fc:	b8 01       	movw	r22, r16
    29fe:	0e 94 be 10 	call	0x217c	; 0x217c <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2a02:	e0 91 1d 03 	lds	r30, 0x031D
    2a06:	f0 91 1e 03 	lds	r31, 0x031E
    2a0a:	20 e0       	ldi	r18, 0x00	; 0
    2a0c:	9e 89       	ldd	r25, Y+22	; 0x16
    2a0e:	86 89       	ldd	r24, Z+22	; 0x16
    2a10:	98 17       	cp	r25, r24
    2a12:	08 f0       	brcs	.+2      	; 0x2a16 <xTaskRemoveFromEventList+0x7a>
    2a14:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    2a16:	82 2f       	mov	r24, r18
    2a18:	df 91       	pop	r29
    2a1a:	cf 91       	pop	r28
    2a1c:	1f 91       	pop	r17
    2a1e:	0f 91       	pop	r16
    2a20:	08 95       	ret

00002a22 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
    2a22:	ff 92       	push	r15
    2a24:	0f 93       	push	r16
    2a26:	1f 93       	push	r17
    2a28:	cf 93       	push	r28
    2a2a:	df 93       	push	r29
	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2a2c:	80 91 23 03 	lds	r24, 0x0323
    2a30:	88 23       	and	r24, r24
    2a32:	09 f0       	breq	.+2      	; 0x2a36 <vTaskIncrementTick+0x14>
    2a34:	61 c0       	rjmp	.+194    	; 0x2af8 <vTaskIncrementTick+0xd6>
	{
		++xTickCount;
    2a36:	80 91 21 03 	lds	r24, 0x0321
    2a3a:	90 91 22 03 	lds	r25, 0x0322
    2a3e:	01 96       	adiw	r24, 0x01	; 1
    2a40:	90 93 22 03 	sts	0x0322, r25
    2a44:	80 93 21 03 	sts	0x0321, r24
		if( xTickCount == ( portTickType ) 0 )
    2a48:	80 91 21 03 	lds	r24, 0x0321
    2a4c:	90 91 22 03 	lds	r25, 0x0322
    2a50:	89 2b       	or	r24, r25
    2a52:	e9 f5       	brne	.+122    	; 0x2ace <vTaskIncrementTick+0xac>
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			pxTemp = pxDelayedTaskList;
    2a54:	80 91 61 03 	lds	r24, 0x0361
    2a58:	90 91 62 03 	lds	r25, 0x0362
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    2a5c:	20 91 63 03 	lds	r18, 0x0363
    2a60:	30 91 64 03 	lds	r19, 0x0364
    2a64:	30 93 62 03 	sts	0x0362, r19
    2a68:	20 93 61 03 	sts	0x0361, r18
			pxOverflowDelayedTaskList = pxTemp;
    2a6c:	90 93 64 03 	sts	0x0364, r25
    2a70:	80 93 63 03 	sts	0x0363, r24
			xNumOfOverflows++;
    2a74:	80 91 20 03 	lds	r24, 0x0320
    2a78:	8f 5f       	subi	r24, 0xFF	; 255
    2a7a:	80 93 20 03 	sts	0x0320, r24
    2a7e:	27 c0       	rjmp	.+78     	; 0x2ace <vTaskIncrementTick+0xac>
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    2a80:	20 91 21 03 	lds	r18, 0x0321
    2a84:	30 91 22 03 	lds	r19, 0x0322
    2a88:	8a 81       	ldd	r24, Y+2	; 0x02
    2a8a:	9b 81       	ldd	r25, Y+3	; 0x03
    2a8c:	28 17       	cp	r18, r24
    2a8e:	39 07       	cpc	r19, r25
    2a90:	c0 f1       	brcs	.+112    	; 0x2b02 <vTaskIncrementTick+0xe0>
    2a92:	8e 01       	movw	r16, r28
    2a94:	0e 5f       	subi	r16, 0xFE	; 254
    2a96:	1f 4f       	sbci	r17, 0xFF	; 255
    2a98:	c8 01       	movw	r24, r16
    2a9a:	0e 94 1c 11 	call	0x2238	; 0x2238 <vListRemove>
    2a9e:	8c 89       	ldd	r24, Y+20	; 0x14
    2aa0:	9d 89       	ldd	r25, Y+21	; 0x15
    2aa2:	89 2b       	or	r24, r25
    2aa4:	21 f0       	breq	.+8      	; 0x2aae <vTaskIncrementTick+0x8c>
    2aa6:	ce 01       	movw	r24, r28
    2aa8:	0c 96       	adiw	r24, 0x0c	; 12
    2aaa:	0e 94 1c 11 	call	0x2238	; 0x2238 <vListRemove>
    2aae:	9e 89       	ldd	r25, Y+22	; 0x16
    2ab0:	80 91 24 03 	lds	r24, 0x0324
    2ab4:	89 17       	cp	r24, r25
    2ab6:	10 f4       	brcc	.+4      	; 0x2abc <vTaskIncrementTick+0x9a>
    2ab8:	90 93 24 03 	sts	0x0324, r25
    2abc:	9f 9d       	mul	r25, r15
    2abe:	c0 01       	movw	r24, r0
    2ac0:	11 24       	eor	r1, r1
    2ac2:	85 5d       	subi	r24, 0xD5	; 213
    2ac4:	9c 4f       	sbci	r25, 0xFC	; 252
    2ac6:	b8 01       	movw	r22, r16
    2ac8:	0e 94 be 10 	call	0x217c	; 0x217c <vListInsertEnd>
    2acc:	02 c0       	rjmp	.+4      	; 0x2ad2 <vTaskIncrementTick+0xb0>
    2ace:	89 e0       	ldi	r24, 0x09	; 9
    2ad0:	f8 2e       	mov	r15, r24
    2ad2:	e0 91 61 03 	lds	r30, 0x0361
    2ad6:	f0 91 62 03 	lds	r31, 0x0362
    2ada:	80 81       	ld	r24, Z
    2adc:	88 23       	and	r24, r24
    2ade:	89 f0       	breq	.+34     	; 0x2b02 <vTaskIncrementTick+0xe0>
    2ae0:	e0 91 61 03 	lds	r30, 0x0361
    2ae4:	f0 91 62 03 	lds	r31, 0x0362
    2ae8:	05 80       	ldd	r0, Z+5	; 0x05
    2aea:	f6 81       	ldd	r31, Z+6	; 0x06
    2aec:	e0 2d       	mov	r30, r0
    2aee:	c6 81       	ldd	r28, Z+6	; 0x06
    2af0:	d7 81       	ldd	r29, Z+7	; 0x07
    2af2:	20 97       	sbiw	r28, 0x00	; 0
    2af4:	29 f6       	brne	.-118    	; 0x2a80 <vTaskIncrementTick+0x5e>
    2af6:	05 c0       	rjmp	.+10     	; 0x2b02 <vTaskIncrementTick+0xe0>
	}
	else
	{
		++uxMissedTicks;
    2af8:	80 91 25 03 	lds	r24, 0x0325
    2afc:	8f 5f       	subi	r24, 0xFF	; 255
    2afe:	80 93 25 03 	sts	0x0325, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    2b02:	df 91       	pop	r29
    2b04:	cf 91       	pop	r28
    2b06:	1f 91       	pop	r17
    2b08:	0f 91       	pop	r16
    2b0a:	ff 90       	pop	r15
    2b0c:	08 95       	ret

00002b0e <vTaskPlaceOnEventList>:
	vWriteTraceToBuffer();
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2b0e:	0f 93       	push	r16
    2b10:	1f 93       	push	r17
    2b12:	8b 01       	movw	r16, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    2b14:	60 91 1d 03 	lds	r22, 0x031D
    2b18:	70 91 1e 03 	lds	r23, 0x031E
    2b1c:	64 5f       	subi	r22, 0xF4	; 244
    2b1e:	7f 4f       	sbci	r23, 0xFF	; 255
    2b20:	0e 94 e7 10 	call	0x21ce	; 0x21ce <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2b24:	80 91 1d 03 	lds	r24, 0x031D
    2b28:	90 91 1e 03 	lds	r25, 0x031E
    2b2c:	02 96       	adiw	r24, 0x02	; 2
    2b2e:	0e 94 1c 11 	call	0x2238	; 0x2238 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    2b32:	80 91 21 03 	lds	r24, 0x0321
    2b36:	90 91 22 03 	lds	r25, 0x0322
    2b3a:	80 0f       	add	r24, r16
    2b3c:	91 1f       	adc	r25, r17

			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    2b3e:	e0 91 1d 03 	lds	r30, 0x031D
    2b42:	f0 91 1e 03 	lds	r31, 0x031E
    2b46:	93 83       	std	Z+3, r25	; 0x03
    2b48:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xTickCount )
    2b4a:	20 91 21 03 	lds	r18, 0x0321
    2b4e:	30 91 22 03 	lds	r19, 0x0322
    2b52:	82 17       	cp	r24, r18
    2b54:	93 07       	cpc	r25, r19
    2b56:	28 f4       	brcc	.+10     	; 0x2b62 <vTaskPlaceOnEventList+0x54>
			{
				/* Wake time has overflowed.  Place this item in the overflow list. */
				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2b58:	80 91 63 03 	lds	r24, 0x0363
    2b5c:	90 91 64 03 	lds	r25, 0x0364
    2b60:	04 c0       	rjmp	.+8      	; 0x2b6a <vTaskPlaceOnEventList+0x5c>
			}
			else
			{
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2b62:	80 91 61 03 	lds	r24, 0x0361
    2b66:	90 91 62 03 	lds	r25, 0x0362
    2b6a:	60 91 1d 03 	lds	r22, 0x031D
    2b6e:	70 91 1e 03 	lds	r23, 0x031E
    2b72:	6e 5f       	subi	r22, 0xFE	; 254
    2b74:	7f 4f       	sbci	r23, 0xFF	; 255
    2b76:	0e 94 e7 10 	call	0x21ce	; 0x21ce <vListInsert>
			}
	}
	#endif
}
    2b7a:	1f 91       	pop	r17
    2b7c:	0f 91       	pop	r16
    2b7e:	08 95       	ret

00002b80 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    2b80:	cf 92       	push	r12
    2b82:	df 92       	push	r13
    2b84:	ff 92       	push	r15
    2b86:	0f 93       	push	r16
    2b88:	1f 93       	push	r17
    2b8a:	df 93       	push	r29
    2b8c:	cf 93       	push	r28
    2b8e:	0f 92       	push	r0
    2b90:	cd b7       	in	r28, 0x3d	; 61
    2b92:	de b7       	in	r29, 0x3e	; 62
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	portENTER_CRITICAL();
    2b94:	0f b6       	in	r0, 0x3f	; 63
    2b96:	f8 94       	cli
    2b98:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2b9a:	80 91 23 03 	lds	r24, 0x0323
    2b9e:	81 50       	subi	r24, 0x01	; 1
    2ba0:	80 93 23 03 	sts	0x0323, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2ba4:	80 91 23 03 	lds	r24, 0x0323
    2ba8:	88 23       	and	r24, r24
    2baa:	09 f0       	breq	.+2      	; 0x2bae <xTaskResumeAll+0x2e>
    2bac:	5b c0       	rjmp	.+182    	; 0x2c64 <xTaskResumeAll+0xe4>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
    2bae:	80 91 26 03 	lds	r24, 0x0326
    2bb2:	88 23       	and	r24, r24
    2bb4:	09 f4       	brne	.+2      	; 0x2bb8 <xTaskResumeAll+0x38>
    2bb6:	56 c0       	rjmp	.+172    	; 0x2c64 <xTaskResumeAll+0xe4>
    2bb8:	19 82       	std	Y+1, r1	; 0x01
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    2bba:	99 e0       	ldi	r25, 0x09	; 9
    2bbc:	f9 2e       	mov	r15, r25
    2bbe:	27 c0       	rjmp	.+78     	; 0x2c0e <xTaskResumeAll+0x8e>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
    2bc0:	c6 01       	movw	r24, r12
    2bc2:	0c 96       	adiw	r24, 0x0c	; 12
    2bc4:	0e 94 1c 11 	call	0x2238	; 0x2238 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    2bc8:	86 01       	movw	r16, r12
    2bca:	0e 5f       	subi	r16, 0xFE	; 254
    2bcc:	1f 4f       	sbci	r17, 0xFF	; 255
    2bce:	c8 01       	movw	r24, r16
    2bd0:	0e 94 1c 11 	call	0x2238	; 0x2238 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    2bd4:	d6 01       	movw	r26, r12
    2bd6:	56 96       	adiw	r26, 0x16	; 22
    2bd8:	9c 91       	ld	r25, X
    2bda:	80 91 24 03 	lds	r24, 0x0324
    2bde:	89 17       	cp	r24, r25
    2be0:	10 f4       	brcc	.+4      	; 0x2be6 <xTaskResumeAll+0x66>
    2be2:	90 93 24 03 	sts	0x0324, r25
    2be6:	9f 9d       	mul	r25, r15
    2be8:	c0 01       	movw	r24, r0
    2bea:	11 24       	eor	r1, r1
    2bec:	85 5d       	subi	r24, 0xD5	; 213
    2bee:	9c 4f       	sbci	r25, 0xFC	; 252
    2bf0:	b8 01       	movw	r22, r16
    2bf2:	0e 94 be 10 	call	0x217c	; 0x217c <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2bf6:	e0 91 1d 03 	lds	r30, 0x031D
    2bfa:	f0 91 1e 03 	lds	r31, 0x031E
    2bfe:	d6 01       	movw	r26, r12
    2c00:	56 96       	adiw	r26, 0x16	; 22
    2c02:	9c 91       	ld	r25, X
    2c04:	86 89       	ldd	r24, Z+22	; 0x16
    2c06:	98 17       	cp	r25, r24
    2c08:	10 f0       	brcs	.+4      	; 0x2c0e <xTaskResumeAll+0x8e>
    2c0a:	b1 e0       	ldi	r27, 0x01	; 1
    2c0c:	b9 83       	std	Y+1, r27	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
    2c0e:	80 91 65 03 	lds	r24, 0x0365
    2c12:	88 23       	and	r24, r24
    2c14:	49 f0       	breq	.+18     	; 0x2c28 <xTaskResumeAll+0xa8>
    2c16:	e0 91 6a 03 	lds	r30, 0x036A
    2c1a:	f0 91 6b 03 	lds	r31, 0x036B
    2c1e:	c6 80       	ldd	r12, Z+6	; 0x06
    2c20:	d7 80       	ldd	r13, Z+7	; 0x07
    2c22:	c1 14       	cp	r12, r1
    2c24:	d1 04       	cpc	r13, r1
    2c26:	61 f6       	brne	.-104    	; 0x2bc0 <xTaskResumeAll+0x40>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    2c28:	80 91 25 03 	lds	r24, 0x0325
    2c2c:	88 23       	and	r24, r24
    2c2e:	41 f4       	brne	.+16     	; 0x2c40 <xTaskResumeAll+0xc0>
    2c30:	0c c0       	rjmp	.+24     	; 0x2c4a <xTaskResumeAll+0xca>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
    2c32:	0e 94 11 15 	call	0x2a22	; 0x2a22 <vTaskIncrementTick>
						--uxMissedTicks;
    2c36:	80 91 25 03 	lds	r24, 0x0325
    2c3a:	81 50       	subi	r24, 0x01	; 1
    2c3c:	80 93 25 03 	sts	0x0325, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    2c40:	80 91 25 03 	lds	r24, 0x0325
    2c44:	88 23       	and	r24, r24
    2c46:	a9 f7       	brne	.-22     	; 0x2c32 <xTaskResumeAll+0xb2>
    2c48:	07 c0       	rjmp	.+14     	; 0x2c58 <xTaskResumeAll+0xd8>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    2c4a:	e9 81       	ldd	r30, Y+1	; 0x01
    2c4c:	e1 30       	cpi	r30, 0x01	; 1
    2c4e:	21 f0       	breq	.+8      	; 0x2c58 <xTaskResumeAll+0xd8>
    2c50:	80 91 1f 03 	lds	r24, 0x031F
    2c54:	81 30       	cpi	r24, 0x01	; 1
    2c56:	31 f4       	brne	.+12     	; 0x2c64 <xTaskResumeAll+0xe4>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    2c58:	10 92 1f 03 	sts	0x031F, r1
					portYIELD_WITHIN_API();
    2c5c:	0e 94 96 19 	call	0x332c	; 0x332c <vPortYield>
    2c60:	81 e0       	ldi	r24, 0x01	; 1
    2c62:	01 c0       	rjmp	.+2      	; 0x2c66 <xTaskResumeAll+0xe6>
    2c64:	80 e0       	ldi	r24, 0x00	; 0
				}
			}
		}
	}
	portEXIT_CRITICAL();
    2c66:	0f 90       	pop	r0
    2c68:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    2c6a:	0f 90       	pop	r0
    2c6c:	cf 91       	pop	r28
    2c6e:	df 91       	pop	r29
    2c70:	1f 91       	pop	r17
    2c72:	0f 91       	pop	r16
    2c74:	ff 90       	pop	r15
    2c76:	df 90       	pop	r13
    2c78:	cf 90       	pop	r12
    2c7a:	08 95       	ret

00002c7c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    2c7c:	0f 93       	push	r16
    2c7e:	1f 93       	push	r17
    2c80:	9c 01       	movw	r18, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
    2c82:	00 97       	sbiw	r24, 0x00	; 0
    2c84:	a1 f1       	breq	.+104    	; 0x2cee <vTaskDelay+0x72>

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    2c86:	80 91 23 03 	lds	r24, 0x0323
    2c8a:	8f 5f       	subi	r24, 0xFF	; 255
    2c8c:	80 93 23 03 	sts	0x0323, r24
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2c90:	00 91 21 03 	lds	r16, 0x0321
    2c94:	10 91 22 03 	lds	r17, 0x0322
    2c98:	02 0f       	add	r16, r18
    2c9a:	13 1f       	adc	r17, r19

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2c9c:	80 91 1d 03 	lds	r24, 0x031D
    2ca0:	90 91 1e 03 	lds	r25, 0x031E
    2ca4:	02 96       	adiw	r24, 0x02	; 2
    2ca6:	0e 94 1c 11 	call	0x2238	; 0x2238 <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    2caa:	e0 91 1d 03 	lds	r30, 0x031D
    2cae:	f0 91 1e 03 	lds	r31, 0x031E
    2cb2:	13 83       	std	Z+3, r17	; 0x03
    2cb4:	02 83       	std	Z+2, r16	; 0x02

				if( xTimeToWake < xTickCount )
    2cb6:	80 91 21 03 	lds	r24, 0x0321
    2cba:	90 91 22 03 	lds	r25, 0x0322
    2cbe:	08 17       	cp	r16, r24
    2cc0:	19 07       	cpc	r17, r25
    2cc2:	28 f4       	brcc	.+10     	; 0x2cce <vTaskDelay+0x52>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2cc4:	80 91 63 03 	lds	r24, 0x0363
    2cc8:	90 91 64 03 	lds	r25, 0x0364
    2ccc:	04 c0       	rjmp	.+8      	; 0x2cd6 <vTaskDelay+0x5a>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2cce:	80 91 61 03 	lds	r24, 0x0361
    2cd2:	90 91 62 03 	lds	r25, 0x0362
    2cd6:	60 91 1d 03 	lds	r22, 0x031D
    2cda:	70 91 1e 03 	lds	r23, 0x031E
    2cde:	6e 5f       	subi	r22, 0xFE	; 254
    2ce0:	7f 4f       	sbci	r23, 0xFF	; 255
    2ce2:	0e 94 e7 10 	call	0x21ce	; 0x21ce <vListInsert>
				}
			}
			xAlreadyYielded = xTaskResumeAll();
    2ce6:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
    2cea:	88 23       	and	r24, r24
    2cec:	11 f4       	brne	.+4      	; 0x2cf2 <vTaskDelay+0x76>
		{
			portYIELD_WITHIN_API();
    2cee:	0e 94 96 19 	call	0x332c	; 0x332c <vPortYield>
		}
	}
    2cf2:	1f 91       	pop	r17
    2cf4:	0f 91       	pop	r16
    2cf6:	08 95       	ret

00002cf8 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    2cf8:	cf 93       	push	r28
    2cfa:	df 93       	push	r29
    2cfc:	fc 01       	movw	r30, r24
    2cfe:	eb 01       	movw	r28, r22

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    2d00:	80 91 23 03 	lds	r24, 0x0323
    2d04:	8f 5f       	subi	r24, 0xFF	; 255
    2d06:	80 93 23 03 	sts	0x0323, r24
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		vTaskSuspendAll();
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2d0a:	20 81       	ld	r18, Z
    2d0c:	31 81       	ldd	r19, Z+1	; 0x01
    2d0e:	c2 0f       	add	r28, r18
    2d10:	d3 1f       	adc	r29, r19

			if( xTickCount < *pxPreviousWakeTime )
    2d12:	80 91 21 03 	lds	r24, 0x0321
    2d16:	90 91 22 03 	lds	r25, 0x0322
    2d1a:	82 17       	cp	r24, r18
    2d1c:	93 07       	cpc	r25, r19
    2d1e:	28 f4       	brcc	.+10     	; 0x2d2a <vTaskDelayUntil+0x32>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    2d20:	c2 17       	cp	r28, r18
    2d22:	d3 07       	cpc	r29, r19
    2d24:	28 f0       	brcs	.+10     	; 0x2d30 <vTaskDelayUntil+0x38>
    2d26:	20 e0       	ldi	r18, 0x00	; 0
    2d28:	0c c0       	rjmp	.+24     	; 0x2d42 <vTaskDelayUntil+0x4a>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    2d2a:	c2 17       	cp	r28, r18
    2d2c:	d3 07       	cpc	r29, r19
    2d2e:	40 f0       	brcs	.+16     	; 0x2d40 <vTaskDelayUntil+0x48>
    2d30:	80 91 21 03 	lds	r24, 0x0321
    2d34:	90 91 22 03 	lds	r25, 0x0322
    2d38:	20 e0       	ldi	r18, 0x00	; 0
    2d3a:	8c 17       	cp	r24, r28
    2d3c:	9d 07       	cpc	r25, r29
    2d3e:	08 f4       	brcc	.+2      	; 0x2d42 <vTaskDelayUntil+0x4a>
    2d40:	21 e0       	ldi	r18, 0x01	; 1
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2d42:	d1 83       	std	Z+1, r29	; 0x01
    2d44:	c0 83       	st	Z, r28

			if( xShouldDelay )
    2d46:	22 23       	and	r18, r18
    2d48:	29 f1       	breq	.+74     	; 0x2d94 <vTaskDelayUntil+0x9c>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2d4a:	80 91 1d 03 	lds	r24, 0x031D
    2d4e:	90 91 1e 03 	lds	r25, 0x031E
    2d52:	02 96       	adiw	r24, 0x02	; 2
    2d54:	0e 94 1c 11 	call	0x2238	; 0x2238 <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    2d58:	e0 91 1d 03 	lds	r30, 0x031D
    2d5c:	f0 91 1e 03 	lds	r31, 0x031E
    2d60:	d3 83       	std	Z+3, r29	; 0x03
    2d62:	c2 83       	std	Z+2, r28	; 0x02

				if( xTimeToWake < xTickCount )
    2d64:	80 91 21 03 	lds	r24, 0x0321
    2d68:	90 91 22 03 	lds	r25, 0x0322
    2d6c:	c8 17       	cp	r28, r24
    2d6e:	d9 07       	cpc	r29, r25
    2d70:	28 f4       	brcc	.+10     	; 0x2d7c <vTaskDelayUntil+0x84>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2d72:	80 91 63 03 	lds	r24, 0x0363
    2d76:	90 91 64 03 	lds	r25, 0x0364
    2d7a:	04 c0       	rjmp	.+8      	; 0x2d84 <vTaskDelayUntil+0x8c>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2d7c:	80 91 61 03 	lds	r24, 0x0361
    2d80:	90 91 62 03 	lds	r25, 0x0362
    2d84:	60 91 1d 03 	lds	r22, 0x031D
    2d88:	70 91 1e 03 	lds	r23, 0x031E
    2d8c:	6e 5f       	subi	r22, 0xFE	; 254
    2d8e:	7f 4f       	sbci	r23, 0xFF	; 255
    2d90:	0e 94 e7 10 	call	0x21ce	; 0x21ce <vListInsert>
				}
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    2d94:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
    2d98:	88 23       	and	r24, r24
    2d9a:	11 f4       	brne	.+4      	; 0x2da0 <vTaskDelayUntil+0xa8>
		{
			portYIELD_WITHIN_API();
    2d9c:	0e 94 96 19 	call	0x332c	; 0x332c <vPortYield>
		}
	}
    2da0:	df 91       	pop	r29
    2da2:	cf 91       	pop	r28
    2da4:	08 95       	ret

00002da6 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    2da6:	ef 92       	push	r14
    2da8:	ff 92       	push	r15
    2daa:	0f 93       	push	r16
    2dac:	1f 93       	push	r17
    2dae:	cf 93       	push	r28
    2db0:	df 93       	push	r29
    2db2:	8c 01       	movw	r16, r24
	tskTCB *pxTCB;

		portENTER_CRITICAL();
    2db4:	0f b6       	in	r0, 0x3f	; 63
    2db6:	f8 94       	cli
    2db8:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    2dba:	80 91 1d 03 	lds	r24, 0x031D
    2dbe:	90 91 1e 03 	lds	r25, 0x031E
    2dc2:	08 17       	cp	r16, r24
    2dc4:	19 07       	cpc	r17, r25
    2dc6:	19 f4       	brne	.+6      	; 0x2dce <vTaskDelete+0x28>
    2dc8:	00 e0       	ldi	r16, 0x00	; 0
    2dca:	10 e0       	ldi	r17, 0x00	; 0
    2dcc:	03 c0       	rjmp	.+6      	; 0x2dd4 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    2dce:	01 15       	cp	r16, r1
    2dd0:	11 05       	cpc	r17, r1
    2dd2:	29 f4       	brne	.+10     	; 0x2dde <vTaskDelete+0x38>
    2dd4:	c0 91 1d 03 	lds	r28, 0x031D
    2dd8:	d0 91 1e 03 	lds	r29, 0x031E
    2ddc:	01 c0       	rjmp	.+2      	; 0x2de0 <vTaskDelete+0x3a>
    2dde:	e8 01       	movw	r28, r16

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    2de0:	22 e0       	ldi	r18, 0x02	; 2
    2de2:	e2 2e       	mov	r14, r18
    2de4:	f1 2c       	mov	r15, r1
    2de6:	ec 0e       	add	r14, r28
    2de8:	fd 1e       	adc	r15, r29
    2dea:	c7 01       	movw	r24, r14
    2dec:	0e 94 1c 11 	call	0x2238	; 0x2238 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer )
    2df0:	8c 89       	ldd	r24, Y+20	; 0x14
    2df2:	9d 89       	ldd	r25, Y+21	; 0x15
    2df4:	89 2b       	or	r24, r25
    2df6:	21 f0       	breq	.+8      	; 0x2e00 <vTaskDelete+0x5a>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    2df8:	ce 01       	movw	r24, r28
    2dfa:	0c 96       	adiw	r24, 0x0c	; 12
    2dfc:	0e 94 1c 11 	call	0x2238	; 0x2238 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    2e00:	8e e6       	ldi	r24, 0x6E	; 110
    2e02:	93 e0       	ldi	r25, 0x03	; 3
    2e04:	b7 01       	movw	r22, r14
    2e06:	0e 94 be 10 	call	0x217c	; 0x217c <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    2e0a:	80 91 28 03 	lds	r24, 0x0328
    2e0e:	8f 5f       	subi	r24, 0xFF	; 255
    2e10:	80 93 28 03 	sts	0x0328, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    2e14:	80 91 29 03 	lds	r24, 0x0329
    2e18:	8f 5f       	subi	r24, 0xFF	; 255
    2e1a:	80 93 29 03 	sts	0x0329, r24

			traceTASK_DELETE( pxTCB );
		}
		portEXIT_CRITICAL();
    2e1e:	0f 90       	pop	r0
    2e20:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    2e22:	80 91 27 03 	lds	r24, 0x0327
    2e26:	88 23       	and	r24, r24
    2e28:	21 f0       	breq	.+8      	; 0x2e32 <vTaskDelete+0x8c>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    2e2a:	01 2b       	or	r16, r17
    2e2c:	11 f4       	brne	.+4      	; 0x2e32 <vTaskDelete+0x8c>
			{
				portYIELD_WITHIN_API();
    2e2e:	0e 94 96 19 	call	0x332c	; 0x332c <vPortYield>
			}
		}
	}
    2e32:	df 91       	pop	r29
    2e34:	cf 91       	pop	r28
    2e36:	1f 91       	pop	r17
    2e38:	0f 91       	pop	r16
    2e3a:	ff 90       	pop	r15
    2e3c:	ef 90       	pop	r14
    2e3e:	08 95       	ret

00002e40 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    2e40:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    2e42:	10 92 27 03 	sts	0x0327, r1
	vPortEndScheduler();
    2e46:	0e 94 37 19 	call	0x326e	; 0x326e <vPortEndScheduler>
}
    2e4a:	08 95       	ret

00002e4c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    2e4c:	1f 93       	push	r17
    2e4e:	cf 93       	push	r28
    2e50:	df 93       	push	r29
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
    2e52:	80 91 28 03 	lds	r24, 0x0328
    2e56:	88 23       	and	r24, r24
    2e58:	91 f1       	breq	.+100    	; 0x2ebe <prvIdleTask+0x72>

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    2e5a:	80 91 23 03 	lds	r24, 0x0323
    2e5e:	8f 5f       	subi	r24, 0xFF	; 255
    2e60:	80 93 23 03 	sts	0x0323, r24
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    2e64:	10 91 6e 03 	lds	r17, 0x036E
			xTaskResumeAll();
    2e68:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <xTaskResumeAll>

			if( !xListIsEmpty )
    2e6c:	11 23       	and	r17, r17
    2e6e:	39 f1       	breq	.+78     	; 0x2ebe <prvIdleTask+0x72>
			{
				tskTCB *pxTCB;

				portENTER_CRITICAL();
    2e70:	0f b6       	in	r0, 0x3f	; 63
    2e72:	f8 94       	cli
    2e74:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    2e76:	80 91 6e 03 	lds	r24, 0x036E
    2e7a:	88 23       	and	r24, r24
    2e7c:	19 f4       	brne	.+6      	; 0x2e84 <prvIdleTask+0x38>
    2e7e:	c0 e0       	ldi	r28, 0x00	; 0
    2e80:	d0 e0       	ldi	r29, 0x00	; 0
    2e82:	06 c0       	rjmp	.+12     	; 0x2e90 <prvIdleTask+0x44>
    2e84:	e0 91 73 03 	lds	r30, 0x0373
    2e88:	f0 91 74 03 	lds	r31, 0x0374
    2e8c:	c6 81       	ldd	r28, Z+6	; 0x06
    2e8e:	d7 81       	ldd	r29, Z+7	; 0x07
					vListRemove( &( pxTCB->xGenericListItem ) );
    2e90:	ce 01       	movw	r24, r28
    2e92:	02 96       	adiw	r24, 0x02	; 2
    2e94:	0e 94 1c 11 	call	0x2238	; 0x2238 <vListRemove>
					--uxCurrentNumberOfTasks;
    2e98:	80 91 26 03 	lds	r24, 0x0326
    2e9c:	81 50       	subi	r24, 0x01	; 1
    2e9e:	80 93 26 03 	sts	0x0326, r24
					--uxTasksDeleted;
    2ea2:	80 91 28 03 	lds	r24, 0x0328
    2ea6:	81 50       	subi	r24, 0x01	; 1
    2ea8:	80 93 28 03 	sts	0x0328, r24
				}
				portEXIT_CRITICAL();
    2eac:	0f 90       	pop	r0
    2eae:	0f be       	out	0x3f, r0	; 63

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    2eb0:	8f 89       	ldd	r24, Y+23	; 0x17
    2eb2:	98 8d       	ldd	r25, Y+24	; 0x18
    2eb4:	0e 94 b9 1b 	call	0x3772	; 0x3772 <vPortFree>
		vPortFree( pxTCB );
    2eb8:	ce 01       	movw	r24, r28
    2eba:	0e 94 b9 1b 	call	0x3772	; 0x3772 <vPortFree>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    2ebe:	80 91 2b 03 	lds	r24, 0x032B
    2ec2:	82 30       	cpi	r24, 0x02	; 2
    2ec4:	30 f2       	brcs	.-116    	; 0x2e52 <prvIdleTask+0x6>
			{
				taskYIELD();
    2ec6:	0e 94 96 19 	call	0x332c	; 0x332c <vPortYield>
    2eca:	c3 cf       	rjmp	.-122    	; 0x2e52 <prvIdleTask+0x6>

00002ecc <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    2ecc:	2f 92       	push	r2
    2ece:	3f 92       	push	r3
    2ed0:	5f 92       	push	r5
    2ed2:	6f 92       	push	r6
    2ed4:	7f 92       	push	r7
    2ed6:	8f 92       	push	r8
    2ed8:	9f 92       	push	r9
    2eda:	af 92       	push	r10
    2edc:	bf 92       	push	r11
    2ede:	cf 92       	push	r12
    2ee0:	df 92       	push	r13
    2ee2:	ef 92       	push	r14
    2ee4:	ff 92       	push	r15
    2ee6:	0f 93       	push	r16
    2ee8:	1f 93       	push	r17
    2eea:	df 93       	push	r29
    2eec:	cf 93       	push	r28
    2eee:	00 d0       	rcall	.+0      	; 0x2ef0 <xTaskGenericCreate+0x24>
    2ef0:	00 d0       	rcall	.+0      	; 0x2ef2 <xTaskGenericCreate+0x26>
    2ef2:	cd b7       	in	r28, 0x3d	; 61
    2ef4:	de b7       	in	r29, 0x3e	; 62
    2ef6:	9a 83       	std	Y+2, r25	; 0x02
    2ef8:	89 83       	std	Y+1, r24	; 0x01
    2efa:	4b 01       	movw	r8, r22
    2efc:	5a 01       	movw	r10, r20
    2efe:	19 01       	movw	r2, r18
    2f00:	50 2e       	mov	r5, r16
    2f02:	37 01       	movw	r6, r14
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    2f04:	81 e2       	ldi	r24, 0x21	; 33
    2f06:	90 e0       	ldi	r25, 0x00	; 0
    2f08:	0e 94 c9 1b 	call	0x3792	; 0x3792 <pvPortMalloc>
    2f0c:	8b 83       	std	Y+3, r24	; 0x03
    2f0e:	9c 83       	std	Y+4, r25	; 0x04

	if( pxNewTCB != NULL )
    2f10:	8b 81       	ldd	r24, Y+3	; 0x03
    2f12:	9c 81       	ldd	r25, Y+4	; 0x04
    2f14:	89 2b       	or	r24, r25
    2f16:	89 f0       	breq	.+34     	; 0x2f3a <xTaskGenericCreate+0x6e>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    2f18:	c1 14       	cp	r12, r1
    2f1a:	d1 04       	cpc	r13, r1
    2f1c:	21 f4       	brne	.+8      	; 0x2f26 <xTaskGenericCreate+0x5a>
    2f1e:	c5 01       	movw	r24, r10
    2f20:	0e 94 c9 1b 	call	0x3792	; 0x3792 <pvPortMalloc>
    2f24:	6c 01       	movw	r12, r24
    2f26:	eb 81       	ldd	r30, Y+3	; 0x03
    2f28:	fc 81       	ldd	r31, Y+4	; 0x04
    2f2a:	d0 8e       	std	Z+24, r13	; 0x18
    2f2c:	c7 8a       	std	Z+23, r12	; 0x17

		if( pxNewTCB->pxStack == NULL )
    2f2e:	c1 14       	cp	r12, r1
    2f30:	d1 04       	cpc	r13, r1
    2f32:	29 f4       	brne	.+10     	; 0x2f3e <xTaskGenericCreate+0x72>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    2f34:	cf 01       	movw	r24, r30
    2f36:	0e 94 b9 1b 	call	0x3772	; 0x3772 <vPortFree>
    2f3a:	8f ef       	ldi	r24, 0xFF	; 255
    2f3c:	d5 c0       	rjmp	.+426    	; 0x30e8 <xTaskGenericCreate+0x21c>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
    2f3e:	c6 01       	movw	r24, r12
    2f40:	65 ea       	ldi	r22, 0xA5	; 165
    2f42:	70 e0       	ldi	r23, 0x00	; 0
    2f44:	a5 01       	movw	r20, r10
    2f46:	0e 94 a9 2d 	call	0x5b52	; 0x5b52 <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
    2f4a:	08 94       	sec
    2f4c:	a1 08       	sbc	r10, r1
    2f4e:	b1 08       	sbc	r11, r1
    2f50:	eb 81       	ldd	r30, Y+3	; 0x03
    2f52:	fc 81       	ldd	r31, Y+4	; 0x04
    2f54:	e7 88       	ldd	r14, Z+23	; 0x17
    2f56:	f0 8c       	ldd	r15, Z+24	; 0x18
    2f58:	ea 0c       	add	r14, r10
    2f5a:	fb 1c       	adc	r15, r11
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    2f5c:	cf 01       	movw	r24, r30
    2f5e:	49 96       	adiw	r24, 0x19	; 25
    2f60:	b4 01       	movw	r22, r8
    2f62:	48 e0       	ldi	r20, 0x08	; 8
    2f64:	50 e0       	ldi	r21, 0x00	; 0
    2f66:	0e 94 b0 2d 	call	0x5b60	; 0x5b60 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
    2f6a:	eb 81       	ldd	r30, Y+3	; 0x03
    2f6c:	fc 81       	ldd	r31, Y+4	; 0x04
    2f6e:	10 a2       	std	Z+32, r1	; 0x20
    2f70:	05 2d       	mov	r16, r5
    2f72:	f3 e0       	ldi	r31, 0x03	; 3
    2f74:	f5 15       	cp	r31, r5
    2f76:	08 f4       	brcc	.+2      	; 0x2f7a <xTaskGenericCreate+0xae>
    2f78:	03 e0       	ldi	r16, 0x03	; 3
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - 1;
	}

	pxTCB->uxPriority = uxPriority;
    2f7a:	eb 81       	ldd	r30, Y+3	; 0x03
    2f7c:	fc 81       	ldd	r31, Y+4	; 0x04
    2f7e:	06 8b       	std	Z+22, r16	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    2f80:	42 e0       	ldi	r20, 0x02	; 2
    2f82:	c4 2e       	mov	r12, r20
    2f84:	d1 2c       	mov	r13, r1
    2f86:	ce 0e       	add	r12, r30
    2f88:	df 1e       	adc	r13, r31
    2f8a:	c6 01       	movw	r24, r12
    2f8c:	0e 94 ba 10 	call	0x2174	; 0x2174 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    2f90:	8b 81       	ldd	r24, Y+3	; 0x03
    2f92:	9c 81       	ldd	r25, Y+4	; 0x04
    2f94:	0c 96       	adiw	r24, 0x0c	; 12
    2f96:	0e 94 ba 10 	call	0x2174	; 0x2174 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    2f9a:	8b 81       	ldd	r24, Y+3	; 0x03
    2f9c:	9c 81       	ldd	r25, Y+4	; 0x04
    2f9e:	fc 01       	movw	r30, r24
    2fa0:	91 87       	std	Z+9, r25	; 0x09
    2fa2:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    2fa4:	84 e0       	ldi	r24, 0x04	; 4
    2fa6:	90 e0       	ldi	r25, 0x00	; 0
    2fa8:	80 1b       	sub	r24, r16
    2faa:	91 09       	sbc	r25, r1
    2fac:	95 87       	std	Z+13, r25	; 0x0d
    2fae:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    2fb0:	f3 8b       	std	Z+19, r31	; 0x13
    2fb2:	e2 8b       	std	Z+18, r30	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    2fb4:	c7 01       	movw	r24, r14
    2fb6:	69 81       	ldd	r22, Y+1	; 0x01
    2fb8:	7a 81       	ldd	r23, Y+2	; 0x02
    2fba:	a1 01       	movw	r20, r2
    2fbc:	0e 94 b5 18 	call	0x316a	; 0x316a <pxPortInitialiseStack>
    2fc0:	eb 81       	ldd	r30, Y+3	; 0x03
    2fc2:	fc 81       	ldd	r31, Y+4	; 0x04
    2fc4:	91 83       	std	Z+1, r25	; 0x01
    2fc6:	80 83       	st	Z, r24
		}
		#endif

		if( ( void * ) pxCreatedTask != NULL )
    2fc8:	61 14       	cp	r6, r1
    2fca:	71 04       	cpc	r7, r1
    2fcc:	21 f0       	breq	.+8      	; 0x2fd6 <xTaskGenericCreate+0x10a>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    2fce:	cf 01       	movw	r24, r30
    2fd0:	f3 01       	movw	r30, r6
    2fd2:	91 83       	std	Z+1, r25	; 0x01
    2fd4:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		portENTER_CRITICAL();
    2fd6:	0f b6       	in	r0, 0x3f	; 63
    2fd8:	f8 94       	cli
    2fda:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    2fdc:	80 91 26 03 	lds	r24, 0x0326
    2fe0:	8f 5f       	subi	r24, 0xFF	; 255
    2fe2:	80 93 26 03 	sts	0x0326, r24
			if( pxCurrentTCB == NULL )
    2fe6:	80 91 1d 03 	lds	r24, 0x031D
    2fea:	90 91 1e 03 	lds	r25, 0x031E
    2fee:	89 2b       	or	r24, r25
    2ff0:	b9 f5       	brne	.+110    	; 0x3060 <xTaskGenericCreate+0x194>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    2ff2:	eb 81       	ldd	r30, Y+3	; 0x03
    2ff4:	fc 81       	ldd	r31, Y+4	; 0x04
    2ff6:	f0 93 1e 03 	sts	0x031E, r31
    2ffa:	e0 93 1d 03 	sts	0x031D, r30

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    2ffe:	80 91 26 03 	lds	r24, 0x0326
    3002:	81 30       	cpi	r24, 0x01	; 1
    3004:	f1 f5       	brne	.+124    	; 0x3082 <xTaskGenericCreate+0x1b6>
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    3006:	8b e2       	ldi	r24, 0x2B	; 43
    3008:	93 e0       	ldi	r25, 0x03	; 3
    300a:	0e 94 aa 10 	call	0x2154	; 0x2154 <vListInitialise>
    300e:	84 e3       	ldi	r24, 0x34	; 52
    3010:	93 e0       	ldi	r25, 0x03	; 3
    3012:	0e 94 aa 10 	call	0x2154	; 0x2154 <vListInitialise>
    3016:	8d e3       	ldi	r24, 0x3D	; 61
    3018:	93 e0       	ldi	r25, 0x03	; 3
    301a:	0e 94 aa 10 	call	0x2154	; 0x2154 <vListInitialise>
    301e:	86 e4       	ldi	r24, 0x46	; 70
    3020:	93 e0       	ldi	r25, 0x03	; 3
    3022:	0e 94 aa 10 	call	0x2154	; 0x2154 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    3026:	3f e4       	ldi	r19, 0x4F	; 79
    3028:	e3 2e       	mov	r14, r19
    302a:	33 e0       	ldi	r19, 0x03	; 3
    302c:	f3 2e       	mov	r15, r19
    302e:	c7 01       	movw	r24, r14
    3030:	0e 94 aa 10 	call	0x2154	; 0x2154 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    3034:	08 e5       	ldi	r16, 0x58	; 88
    3036:	13 e0       	ldi	r17, 0x03	; 3
    3038:	c8 01       	movw	r24, r16
    303a:	0e 94 aa 10 	call	0x2154	; 0x2154 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    303e:	85 e6       	ldi	r24, 0x65	; 101
    3040:	93 e0       	ldi	r25, 0x03	; 3
    3042:	0e 94 aa 10 	call	0x2154	; 0x2154 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    3046:	8e e6       	ldi	r24, 0x6E	; 110
    3048:	93 e0       	ldi	r25, 0x03	; 3
    304a:	0e 94 aa 10 	call	0x2154	; 0x2154 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    304e:	f0 92 62 03 	sts	0x0362, r15
    3052:	e0 92 61 03 	sts	0x0361, r14
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    3056:	10 93 64 03 	sts	0x0364, r17
    305a:	00 93 63 03 	sts	0x0363, r16
    305e:	11 c0       	rjmp	.+34     	; 0x3082 <xTaskGenericCreate+0x1b6>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    3060:	80 91 27 03 	lds	r24, 0x0327
    3064:	88 23       	and	r24, r24
    3066:	69 f4       	brne	.+26     	; 0x3082 <xTaskGenericCreate+0x1b6>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    3068:	e0 91 1d 03 	lds	r30, 0x031D
    306c:	f0 91 1e 03 	lds	r31, 0x031E
    3070:	86 89       	ldd	r24, Z+22	; 0x16
    3072:	58 16       	cp	r5, r24
    3074:	30 f0       	brcs	.+12     	; 0x3082 <xTaskGenericCreate+0x1b6>
					{
						pxCurrentTCB = pxNewTCB;
    3076:	8b 81       	ldd	r24, Y+3	; 0x03
    3078:	9c 81       	ldd	r25, Y+4	; 0x04
    307a:	90 93 1e 03 	sts	0x031E, r25
    307e:	80 93 1d 03 	sts	0x031D, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    3082:	eb 81       	ldd	r30, Y+3	; 0x03
    3084:	fc 81       	ldd	r31, Y+4	; 0x04
    3086:	96 89       	ldd	r25, Z+22	; 0x16
    3088:	80 91 2a 03 	lds	r24, 0x032A
    308c:	89 17       	cp	r24, r25
    308e:	10 f4       	brcc	.+4      	; 0x3094 <xTaskGenericCreate+0x1c8>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    3090:	90 93 2a 03 	sts	0x032A, r25
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    3094:	80 91 29 03 	lds	r24, 0x0329
    3098:	8f 5f       	subi	r24, 0xFF	; 255
    309a:	80 93 29 03 	sts	0x0329, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    309e:	eb 81       	ldd	r30, Y+3	; 0x03
    30a0:	fc 81       	ldd	r31, Y+4	; 0x04
    30a2:	96 89       	ldd	r25, Z+22	; 0x16
    30a4:	80 91 24 03 	lds	r24, 0x0324
    30a8:	89 17       	cp	r24, r25
    30aa:	10 f4       	brcc	.+4      	; 0x30b0 <xTaskGenericCreate+0x1e4>
    30ac:	90 93 24 03 	sts	0x0324, r25
    30b0:	eb 81       	ldd	r30, Y+3	; 0x03
    30b2:	fc 81       	ldd	r31, Y+4	; 0x04
    30b4:	86 89       	ldd	r24, Z+22	; 0x16
    30b6:	29 e0       	ldi	r18, 0x09	; 9
    30b8:	82 9f       	mul	r24, r18
    30ba:	c0 01       	movw	r24, r0
    30bc:	11 24       	eor	r1, r1
    30be:	85 5d       	subi	r24, 0xD5	; 213
    30c0:	9c 4f       	sbci	r25, 0xFC	; 252
    30c2:	b6 01       	movw	r22, r12
    30c4:	0e 94 be 10 	call	0x217c	; 0x217c <vListInsertEnd>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		portEXIT_CRITICAL();
    30c8:	0f 90       	pop	r0
    30ca:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED( pxNewTCB );
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    30cc:	80 91 27 03 	lds	r24, 0x0327
    30d0:	88 23       	and	r24, r24
    30d2:	49 f0       	breq	.+18     	; 0x30e6 <xTaskGenericCreate+0x21a>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    30d4:	e0 91 1d 03 	lds	r30, 0x031D
    30d8:	f0 91 1e 03 	lds	r31, 0x031E
    30dc:	86 89       	ldd	r24, Z+22	; 0x16
    30de:	85 15       	cp	r24, r5
    30e0:	10 f4       	brcc	.+4      	; 0x30e6 <xTaskGenericCreate+0x21a>
			{
				portYIELD_WITHIN_API();
    30e2:	0e 94 96 19 	call	0x332c	; 0x332c <vPortYield>
    30e6:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    30e8:	0f 90       	pop	r0
    30ea:	0f 90       	pop	r0
    30ec:	0f 90       	pop	r0
    30ee:	0f 90       	pop	r0
    30f0:	cf 91       	pop	r28
    30f2:	df 91       	pop	r29
    30f4:	1f 91       	pop	r17
    30f6:	0f 91       	pop	r16
    30f8:	ff 90       	pop	r15
    30fa:	ef 90       	pop	r14
    30fc:	df 90       	pop	r13
    30fe:	cf 90       	pop	r12
    3100:	bf 90       	pop	r11
    3102:	af 90       	pop	r10
    3104:	9f 90       	pop	r9
    3106:	8f 90       	pop	r8
    3108:	7f 90       	pop	r7
    310a:	6f 90       	pop	r6
    310c:	5f 90       	pop	r5
    310e:	3f 90       	pop	r3
    3110:	2f 90       	pop	r2
    3112:	08 95       	ret

00003114 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    3114:	af 92       	push	r10
    3116:	bf 92       	push	r11
    3118:	cf 92       	push	r12
    311a:	df 92       	push	r13
    311c:	ef 92       	push	r14
    311e:	ff 92       	push	r15
    3120:	0f 93       	push	r16
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
    3122:	86 e2       	ldi	r24, 0x26	; 38
    3124:	97 e1       	ldi	r25, 0x17	; 23
    3126:	67 ea       	ldi	r22, 0xA7	; 167
    3128:	72 e0       	ldi	r23, 0x02	; 2
    312a:	45 e5       	ldi	r20, 0x55	; 85
    312c:	50 e0       	ldi	r21, 0x00	; 0
    312e:	20 e0       	ldi	r18, 0x00	; 0
    3130:	30 e0       	ldi	r19, 0x00	; 0
    3132:	00 e0       	ldi	r16, 0x00	; 0
    3134:	ee 24       	eor	r14, r14
    3136:	ff 24       	eor	r15, r15
    3138:	cc 24       	eor	r12, r12
    313a:	dd 24       	eor	r13, r13
    313c:	aa 24       	eor	r10, r10
    313e:	bb 24       	eor	r11, r11
    3140:	0e 94 66 17 	call	0x2ecc	; 0x2ecc <xTaskGenericCreate>

	if( xReturn == pdPASS )
    3144:	81 30       	cpi	r24, 0x01	; 1
    3146:	49 f4       	brne	.+18     	; 0x315a <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    3148:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    314a:	80 93 27 03 	sts	0x0327, r24
		xTickCount = ( portTickType ) 0;
    314e:	10 92 22 03 	sts	0x0322, r1
    3152:	10 92 21 03 	sts	0x0321, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
    3156:	0e 94 fd 18 	call	0x31fa	; 0x31fa <xPortStartScheduler>
		else
		{
			/* Should only reach here if a task calls xTaskEndScheduler(). */
		}
	}
}
    315a:	0f 91       	pop	r16
    315c:	ff 90       	pop	r15
    315e:	ef 90       	pop	r14
    3160:	df 90       	pop	r13
    3162:	cf 90       	pop	r12
    3164:	bf 90       	pop	r11
    3166:	af 90       	pop	r10
    3168:	08 95       	ret

0000316a <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    316a:	fc 01       	movw	r30, r24
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    316c:	91 e1       	ldi	r25, 0x11	; 17
    316e:	90 83       	st	Z, r25
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    3170:	22 e2       	ldi	r18, 0x22	; 34
    3172:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    3174:	83 e3       	ldi	r24, 0x33	; 51
    3176:	82 93       	st	-Z, r24
	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	

	usAddress = ( unsigned short ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    3178:	62 93       	st	-Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    317a:	72 93       	st	-Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    317c:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    317e:	80 e8       	ldi	r24, 0x80	; 128
    3180:	82 93       	st	-Z, r24
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    3182:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    3184:	82 e0       	ldi	r24, 0x02	; 2
    3186:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    3188:	83 e0       	ldi	r24, 0x03	; 3
    318a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    318c:	84 e0       	ldi	r24, 0x04	; 4
    318e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    3190:	85 e0       	ldi	r24, 0x05	; 5
    3192:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    3194:	86 e0       	ldi	r24, 0x06	; 6
    3196:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    3198:	87 e0       	ldi	r24, 0x07	; 7
    319a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    319c:	88 e0       	ldi	r24, 0x08	; 8
    319e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    31a0:	89 e0       	ldi	r24, 0x09	; 9
    31a2:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    31a4:	80 e1       	ldi	r24, 0x10	; 16
    31a6:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    31a8:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    31aa:	82 e1       	ldi	r24, 0x12	; 18
    31ac:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    31ae:	83 e1       	ldi	r24, 0x13	; 19
    31b0:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    31b2:	84 e1       	ldi	r24, 0x14	; 20
    31b4:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    31b6:	85 e1       	ldi	r24, 0x15	; 21
    31b8:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    31ba:	86 e1       	ldi	r24, 0x16	; 22
    31bc:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    31be:	87 e1       	ldi	r24, 0x17	; 23
    31c0:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    31c2:	88 e1       	ldi	r24, 0x18	; 24
    31c4:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    31c6:	89 e1       	ldi	r24, 0x19	; 25
    31c8:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    31ca:	80 e2       	ldi	r24, 0x20	; 32
    31cc:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    31ce:	81 e2       	ldi	r24, 0x21	; 33
    31d0:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    31d2:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    31d4:	83 e2       	ldi	r24, 0x23	; 35
    31d6:	82 93       	st	-Z, r24
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */

	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    31d8:	42 93       	st	-Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    31da:	52 93       	st	-Z, r21
	pxTopOfStack--;


	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    31dc:	86 e2       	ldi	r24, 0x26	; 38
    31de:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    31e0:	87 e2       	ldi	r24, 0x27	; 39
    31e2:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    31e4:	88 e2       	ldi	r24, 0x28	; 40
    31e6:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    31e8:	89 e2       	ldi	r24, 0x29	; 41
    31ea:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    31ec:	80 e3       	ldi	r24, 0x30	; 48
    31ee:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    31f0:	81 e3       	ldi	r24, 0x31	; 49
    31f2:	82 93       	st	-Z, r24
    31f4:	31 97       	sbiw	r30, 0x01	; 1
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    31f6:	cf 01       	movw	r24, r30
    31f8:	08 95       	ret

000031fa <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	OCR1AH = ucHighByte;
    31fa:	10 92 89 00 	sts	0x0089, r1
	OCR1AL = ucLowByte;
    31fe:	89 ef       	ldi	r24, 0xF9	; 249
    3200:	80 93 88 00 	sts	0x0088, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    3204:	8b e0       	ldi	r24, 0x0B	; 11
    3206:	80 93 81 00 	sts	0x0081, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
    320a:	ef e6       	ldi	r30, 0x6F	; 111
    320c:	f0 e0       	ldi	r31, 0x00	; 0
    320e:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    3210:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
    3212:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    3214:	a0 91 1d 03 	lds	r26, 0x031D
    3218:	b0 91 1e 03 	lds	r27, 0x031E
    321c:	cd 91       	ld	r28, X+
    321e:	cd bf       	out	0x3d, r28	; 61
    3220:	dd 91       	ld	r29, X+
    3222:	de bf       	out	0x3e, r29	; 62
    3224:	ff 91       	pop	r31
    3226:	ef 91       	pop	r30
    3228:	df 91       	pop	r29
    322a:	cf 91       	pop	r28
    322c:	bf 91       	pop	r27
    322e:	af 91       	pop	r26
    3230:	9f 91       	pop	r25
    3232:	8f 91       	pop	r24
    3234:	7f 91       	pop	r23
    3236:	6f 91       	pop	r22
    3238:	5f 91       	pop	r21
    323a:	4f 91       	pop	r20
    323c:	3f 91       	pop	r19
    323e:	2f 91       	pop	r18
    3240:	1f 91       	pop	r17
    3242:	0f 91       	pop	r16
    3244:	ff 90       	pop	r15
    3246:	ef 90       	pop	r14
    3248:	df 90       	pop	r13
    324a:	cf 90       	pop	r12
    324c:	bf 90       	pop	r11
    324e:	af 90       	pop	r10
    3250:	9f 90       	pop	r9
    3252:	8f 90       	pop	r8
    3254:	7f 90       	pop	r7
    3256:	6f 90       	pop	r6
    3258:	5f 90       	pop	r5
    325a:	4f 90       	pop	r4
    325c:	3f 90       	pop	r3
    325e:	2f 90       	pop	r2
    3260:	1f 90       	pop	r1
    3262:	0f 90       	pop	r0
    3264:	0f be       	out	0x3f, r0	; 63
    3266:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    3268:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    326a:	81 e0       	ldi	r24, 0x01	; 1
    326c:	08 95       	ret

0000326e <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    326e:	08 95       	ret

00003270 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    3270:	0f 92       	push	r0
    3272:	0f b6       	in	r0, 0x3f	; 63
    3274:	f8 94       	cli
    3276:	0f 92       	push	r0
    3278:	1f 92       	push	r1
    327a:	11 24       	eor	r1, r1
    327c:	2f 92       	push	r2
    327e:	3f 92       	push	r3
    3280:	4f 92       	push	r4
    3282:	5f 92       	push	r5
    3284:	6f 92       	push	r6
    3286:	7f 92       	push	r7
    3288:	8f 92       	push	r8
    328a:	9f 92       	push	r9
    328c:	af 92       	push	r10
    328e:	bf 92       	push	r11
    3290:	cf 92       	push	r12
    3292:	df 92       	push	r13
    3294:	ef 92       	push	r14
    3296:	ff 92       	push	r15
    3298:	0f 93       	push	r16
    329a:	1f 93       	push	r17
    329c:	2f 93       	push	r18
    329e:	3f 93       	push	r19
    32a0:	4f 93       	push	r20
    32a2:	5f 93       	push	r21
    32a4:	6f 93       	push	r22
    32a6:	7f 93       	push	r23
    32a8:	8f 93       	push	r24
    32aa:	9f 93       	push	r25
    32ac:	af 93       	push	r26
    32ae:	bf 93       	push	r27
    32b0:	cf 93       	push	r28
    32b2:	df 93       	push	r29
    32b4:	ef 93       	push	r30
    32b6:	ff 93       	push	r31
    32b8:	a0 91 1d 03 	lds	r26, 0x031D
    32bc:	b0 91 1e 03 	lds	r27, 0x031E
    32c0:	0d b6       	in	r0, 0x3d	; 61
    32c2:	0d 92       	st	X+, r0
    32c4:	0e b6       	in	r0, 0x3e	; 62
    32c6:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    32c8:	0e 94 11 15 	call	0x2a22	; 0x2a22 <vTaskIncrementTick>
	vTaskSwitchContext();
    32cc:	0e 94 43 14 	call	0x2886	; 0x2886 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    32d0:	a0 91 1d 03 	lds	r26, 0x031D
    32d4:	b0 91 1e 03 	lds	r27, 0x031E
    32d8:	cd 91       	ld	r28, X+
    32da:	cd bf       	out	0x3d, r28	; 61
    32dc:	dd 91       	ld	r29, X+
    32de:	de bf       	out	0x3e, r29	; 62
    32e0:	ff 91       	pop	r31
    32e2:	ef 91       	pop	r30
    32e4:	df 91       	pop	r29
    32e6:	cf 91       	pop	r28
    32e8:	bf 91       	pop	r27
    32ea:	af 91       	pop	r26
    32ec:	9f 91       	pop	r25
    32ee:	8f 91       	pop	r24
    32f0:	7f 91       	pop	r23
    32f2:	6f 91       	pop	r22
    32f4:	5f 91       	pop	r21
    32f6:	4f 91       	pop	r20
    32f8:	3f 91       	pop	r19
    32fa:	2f 91       	pop	r18
    32fc:	1f 91       	pop	r17
    32fe:	0f 91       	pop	r16
    3300:	ff 90       	pop	r15
    3302:	ef 90       	pop	r14
    3304:	df 90       	pop	r13
    3306:	cf 90       	pop	r12
    3308:	bf 90       	pop	r11
    330a:	af 90       	pop	r10
    330c:	9f 90       	pop	r9
    330e:	8f 90       	pop	r8
    3310:	7f 90       	pop	r7
    3312:	6f 90       	pop	r6
    3314:	5f 90       	pop	r5
    3316:	4f 90       	pop	r4
    3318:	3f 90       	pop	r3
    331a:	2f 90       	pop	r2
    331c:	1f 90       	pop	r1
    331e:	0f 90       	pop	r0
    3320:	0f be       	out	0x3f, r0	; 63
    3322:	0f 90       	pop	r0

	asm volatile ( "ret" );
    3324:	08 95       	ret

00003326 <__vector_17>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    3326:	0e 94 38 19 	call	0x3270	; 0x3270 <vPortYieldFromTick>
		asm volatile ( "reti" );
    332a:	18 95       	reti

0000332c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    332c:	0f 92       	push	r0
    332e:	0f b6       	in	r0, 0x3f	; 63
    3330:	f8 94       	cli
    3332:	0f 92       	push	r0
    3334:	1f 92       	push	r1
    3336:	11 24       	eor	r1, r1
    3338:	2f 92       	push	r2
    333a:	3f 92       	push	r3
    333c:	4f 92       	push	r4
    333e:	5f 92       	push	r5
    3340:	6f 92       	push	r6
    3342:	7f 92       	push	r7
    3344:	8f 92       	push	r8
    3346:	9f 92       	push	r9
    3348:	af 92       	push	r10
    334a:	bf 92       	push	r11
    334c:	cf 92       	push	r12
    334e:	df 92       	push	r13
    3350:	ef 92       	push	r14
    3352:	ff 92       	push	r15
    3354:	0f 93       	push	r16
    3356:	1f 93       	push	r17
    3358:	2f 93       	push	r18
    335a:	3f 93       	push	r19
    335c:	4f 93       	push	r20
    335e:	5f 93       	push	r21
    3360:	6f 93       	push	r22
    3362:	7f 93       	push	r23
    3364:	8f 93       	push	r24
    3366:	9f 93       	push	r25
    3368:	af 93       	push	r26
    336a:	bf 93       	push	r27
    336c:	cf 93       	push	r28
    336e:	df 93       	push	r29
    3370:	ef 93       	push	r30
    3372:	ff 93       	push	r31
    3374:	a0 91 1d 03 	lds	r26, 0x031D
    3378:	b0 91 1e 03 	lds	r27, 0x031E
    337c:	0d b6       	in	r0, 0x3d	; 61
    337e:	0d 92       	st	X+, r0
    3380:	0e b6       	in	r0, 0x3e	; 62
    3382:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    3384:	0e 94 43 14 	call	0x2886	; 0x2886 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    3388:	a0 91 1d 03 	lds	r26, 0x031D
    338c:	b0 91 1e 03 	lds	r27, 0x031E
    3390:	cd 91       	ld	r28, X+
    3392:	cd bf       	out	0x3d, r28	; 61
    3394:	dd 91       	ld	r29, X+
    3396:	de bf       	out	0x3e, r29	; 62
    3398:	ff 91       	pop	r31
    339a:	ef 91       	pop	r30
    339c:	df 91       	pop	r29
    339e:	cf 91       	pop	r28
    33a0:	bf 91       	pop	r27
    33a2:	af 91       	pop	r26
    33a4:	9f 91       	pop	r25
    33a6:	8f 91       	pop	r24
    33a8:	7f 91       	pop	r23
    33aa:	6f 91       	pop	r22
    33ac:	5f 91       	pop	r21
    33ae:	4f 91       	pop	r20
    33b0:	3f 91       	pop	r19
    33b2:	2f 91       	pop	r18
    33b4:	1f 91       	pop	r17
    33b6:	0f 91       	pop	r16
    33b8:	ff 90       	pop	r15
    33ba:	ef 90       	pop	r14
    33bc:	df 90       	pop	r13
    33be:	cf 90       	pop	r12
    33c0:	bf 90       	pop	r11
    33c2:	af 90       	pop	r10
    33c4:	9f 90       	pop	r9
    33c6:	8f 90       	pop	r8
    33c8:	7f 90       	pop	r7
    33ca:	6f 90       	pop	r6
    33cc:	5f 90       	pop	r5
    33ce:	4f 90       	pop	r4
    33d0:	3f 90       	pop	r3
    33d2:	2f 90       	pop	r2
    33d4:	1f 90       	pop	r1
    33d6:	0f 90       	pop	r0
    33d8:	0f be       	out	0x3f, r0	; 63
    33da:	0f 90       	pop	r0

	asm volatile ( "ret" );
    33dc:	08 95       	ret

000033de <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    33de:	0f 93       	push	r16
    33e0:	1f 93       	push	r17
    33e2:	cf 93       	push	r28
    33e4:	df 93       	push	r29
    33e6:	fc 01       	movw	r30, r24
corCRCB *pxUnblockedCRCB;
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    33e8:	80 81       	ld	r24, Z
    33ea:	88 23       	and	r24, r24
    33ec:	19 f4       	brne	.+6      	; 0x33f4 <xCoRoutineRemoveFromEventList+0x16>
    33ee:	c0 e0       	ldi	r28, 0x00	; 0
    33f0:	d0 e0       	ldi	r29, 0x00	; 0
    33f2:	05 c0       	rjmp	.+10     	; 0x33fe <xCoRoutineRemoveFromEventList+0x20>
    33f4:	05 80       	ldd	r0, Z+5	; 0x05
    33f6:	f6 81       	ldd	r31, Z+6	; 0x06
    33f8:	e0 2d       	mov	r30, r0
    33fa:	c6 81       	ldd	r28, Z+6	; 0x06
    33fc:	d7 81       	ldd	r29, Z+7	; 0x07
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    33fe:	8e 01       	movw	r16, r28
    3400:	04 5f       	subi	r16, 0xF4	; 244
    3402:	1f 4f       	sbci	r17, 0xFF	; 255
    3404:	c8 01       	movw	r24, r16
    3406:	0e 94 1c 11 	call	0x2238	; 0x2238 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    340a:	88 ea       	ldi	r24, 0xA8	; 168
    340c:	93 e0       	ldi	r25, 0x03	; 3
    340e:	b8 01       	movw	r22, r16
    3410:	0e 94 be 10 	call	0x217c	; 0x217c <vListInsertEnd>
    3414:	20 e0       	ldi	r18, 0x00	; 0
    3416:	e0 91 77 03 	lds	r30, 0x0377
    341a:	f0 91 78 03 	lds	r31, 0x0378
    341e:	9e 89       	ldd	r25, Y+22	; 0x16
    3420:	86 89       	ldd	r24, Z+22	; 0x16
    3422:	98 17       	cp	r25, r24
    3424:	08 f0       	brcs	.+2      	; 0x3428 <xCoRoutineRemoveFromEventList+0x4a>
    3426:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    3428:	82 2f       	mov	r24, r18
    342a:	df 91       	pop	r29
    342c:	cf 91       	pop	r28
    342e:	1f 91       	pop	r17
    3430:	0f 91       	pop	r16
    3432:	08 95       	ret

00003434 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    3434:	ff 92       	push	r15
    3436:	0f 93       	push	r16
    3438:	1f 93       	push	r17
    343a:	cf 93       	push	r28
    343c:	df 93       	push	r29
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    343e:	99 e0       	ldi	r25, 0x09	; 9
    3440:	f9 2e       	mov	r15, r25
    3442:	28 c0       	rjmp	.+80     	; 0x3494 <vCoRoutineSchedule+0x60>
	while( !listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    3444:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    3446:	80 91 a8 03 	lds	r24, 0x03A8
    344a:	88 23       	and	r24, r24
    344c:	19 f4       	brne	.+6      	; 0x3454 <vCoRoutineSchedule+0x20>
    344e:	c0 e0       	ldi	r28, 0x00	; 0
    3450:	d0 e0       	ldi	r29, 0x00	; 0
    3452:	06 c0       	rjmp	.+12     	; 0x3460 <vCoRoutineSchedule+0x2c>
    3454:	e0 91 ad 03 	lds	r30, 0x03AD
    3458:	f0 91 ae 03 	lds	r31, 0x03AE
    345c:	c6 81       	ldd	r28, Z+6	; 0x06
    345e:	d7 81       	ldd	r29, Z+7	; 0x07
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    3460:	ce 01       	movw	r24, r28
    3462:	0c 96       	adiw	r24, 0x0c	; 12
    3464:	0e 94 1c 11 	call	0x2238	; 0x2238 <vListRemove>
		}
		portENABLE_INTERRUPTS();
    3468:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    346a:	8e 01       	movw	r16, r28
    346c:	0e 5f       	subi	r16, 0xFE	; 254
    346e:	1f 4f       	sbci	r17, 0xFF	; 255
    3470:	c8 01       	movw	r24, r16
    3472:	0e 94 1c 11 	call	0x2238	; 0x2238 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    3476:	9e 89       	ldd	r25, Y+22	; 0x16
    3478:	80 91 79 03 	lds	r24, 0x0379
    347c:	89 17       	cp	r24, r25
    347e:	10 f4       	brcc	.+4      	; 0x3484 <vCoRoutineSchedule+0x50>
    3480:	90 93 79 03 	sts	0x0379, r25
    3484:	9f 9d       	mul	r25, r15
    3486:	c0 01       	movw	r24, r0
    3488:	11 24       	eor	r1, r1
    348a:	80 58       	subi	r24, 0x80	; 128
    348c:	9c 4f       	sbci	r25, 0xFC	; 252
    348e:	b8 01       	movw	r22, r16
    3490:	0e 94 be 10 	call	0x217c	; 0x217c <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( !listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) )
    3494:	80 91 a8 03 	lds	r24, 0x03A8
    3498:	88 23       	and	r24, r24
    349a:	a1 f6       	brne	.-88     	; 0x3444 <vCoRoutineSchedule+0x10>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    349c:	0e 94 2f 14 	call	0x285e	; 0x285e <xTaskGetTickCount>
    34a0:	20 91 7a 03 	lds	r18, 0x037A
    34a4:	30 91 7b 03 	lds	r19, 0x037B
    34a8:	82 1b       	sub	r24, r18
    34aa:	93 0b       	sbc	r25, r19
    34ac:	90 93 7d 03 	sts	0x037D, r25
    34b0:	80 93 7c 03 	sts	0x037C, r24
					vListRemove( &( pxCRCB->xEventListItem ) );											
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    34b4:	89 e0       	ldi	r24, 0x09	; 9
    34b6:	f8 2e       	mov	r15, r24
    34b8:	54 c0       	rjmp	.+168    	; 0x3562 <vCoRoutineSchedule+0x12e>
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    34ba:	01 96       	adiw	r24, 0x01	; 1
    34bc:	90 93 7f 03 	sts	0x037F, r25
    34c0:	80 93 7e 03 	sts	0x037E, r24
		xPassedTicks--;
    34c4:	21 50       	subi	r18, 0x01	; 1
    34c6:	30 40       	sbci	r19, 0x00	; 0
    34c8:	30 93 7d 03 	sts	0x037D, r19
    34cc:	20 93 7c 03 	sts	0x037C, r18

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    34d0:	89 2b       	or	r24, r25
    34d2:	c9 f5       	brne	.+114    	; 0x3546 <vCoRoutineSchedule+0x112>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    34d4:	20 91 a4 03 	lds	r18, 0x03A4
    34d8:	30 91 a5 03 	lds	r19, 0x03A5
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    34dc:	80 91 a6 03 	lds	r24, 0x03A6
    34e0:	90 91 a7 03 	lds	r25, 0x03A7
    34e4:	90 93 a5 03 	sts	0x03A5, r25
    34e8:	80 93 a4 03 	sts	0x03A4, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    34ec:	30 93 a7 03 	sts	0x03A7, r19
    34f0:	20 93 a6 03 	sts	0x03A6, r18
    34f4:	28 c0       	rjmp	.+80     	; 0x3546 <vCoRoutineSchedule+0x112>
		}

		/* See if this tick has made a timeout expire. */
		while( ( pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList ) ) != NULL )
		{	
			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    34f6:	20 91 7e 03 	lds	r18, 0x037E
    34fa:	30 91 7f 03 	lds	r19, 0x037F
    34fe:	8a 81       	ldd	r24, Y+2	; 0x02
    3500:	9b 81       	ldd	r25, Y+3	; 0x03
    3502:	28 17       	cp	r18, r24
    3504:	39 07       	cpc	r19, r25
    3506:	68 f1       	brcs	.+90     	; 0x3562 <vCoRoutineSchedule+0x12e>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    3508:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    350a:	8e 01       	movw	r16, r28
    350c:	0e 5f       	subi	r16, 0xFE	; 254
    350e:	1f 4f       	sbci	r17, 0xFF	; 255
    3510:	c8 01       	movw	r24, r16
    3512:	0e 94 1c 11 	call	0x2238	; 0x2238 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    3516:	8c 89       	ldd	r24, Y+20	; 0x14
    3518:	9d 89       	ldd	r25, Y+21	; 0x15
    351a:	89 2b       	or	r24, r25
    351c:	21 f0       	breq	.+8      	; 0x3526 <vCoRoutineSchedule+0xf2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    351e:	ce 01       	movw	r24, r28
    3520:	0c 96       	adiw	r24, 0x0c	; 12
    3522:	0e 94 1c 11 	call	0x2238	; 0x2238 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    3526:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    3528:	9e 89       	ldd	r25, Y+22	; 0x16
    352a:	80 91 79 03 	lds	r24, 0x0379
    352e:	89 17       	cp	r24, r25
    3530:	10 f4       	brcc	.+4      	; 0x3536 <vCoRoutineSchedule+0x102>
    3532:	90 93 79 03 	sts	0x0379, r25
    3536:	9f 9d       	mul	r25, r15
    3538:	c0 01       	movw	r24, r0
    353a:	11 24       	eor	r1, r1
    353c:	80 58       	subi	r24, 0x80	; 128
    353e:	9c 4f       	sbci	r25, 0xFC	; 252
    3540:	b8 01       	movw	r22, r16
    3542:	0e 94 be 10 	call	0x217c	; 0x217c <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( ( pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList ) ) != NULL )
    3546:	e0 91 a4 03 	lds	r30, 0x03A4
    354a:	f0 91 a5 03 	lds	r31, 0x03A5
    354e:	80 81       	ld	r24, Z
    3550:	88 23       	and	r24, r24
    3552:	39 f0       	breq	.+14     	; 0x3562 <vCoRoutineSchedule+0x12e>
    3554:	05 80       	ldd	r0, Z+5	; 0x05
    3556:	f6 81       	ldd	r31, Z+6	; 0x06
    3558:	e0 2d       	mov	r30, r0
    355a:	c6 81       	ldd	r28, Z+6	; 0x06
    355c:	d7 81       	ldd	r29, Z+7	; 0x07
    355e:	20 97       	sbiw	r28, 0x00	; 0
    3560:	51 f6       	brne	.-108    	; 0x34f6 <vCoRoutineSchedule+0xc2>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    3562:	20 91 7c 03 	lds	r18, 0x037C
    3566:	30 91 7d 03 	lds	r19, 0x037D
    356a:	80 91 7e 03 	lds	r24, 0x037E
    356e:	90 91 7f 03 	lds	r25, 0x037F
    3572:	21 15       	cp	r18, r1
    3574:	31 05       	cpc	r19, r1
    3576:	09 f0       	breq	.+2      	; 0x357a <vCoRoutineSchedule+0x146>
    3578:	a0 cf       	rjmp	.-192    	; 0x34ba <vCoRoutineSchedule+0x86>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    357a:	90 93 7b 03 	sts	0x037B, r25
    357e:	80 93 7a 03 	sts	0x037A, r24
    3582:	90 91 79 03 	lds	r25, 0x0379

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    3586:	29 e0       	ldi	r18, 0x09	; 9
    3588:	06 c0       	rjmp	.+12     	; 0x3596 <vCoRoutineSchedule+0x162>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    358a:	99 23       	and	r25, r25
    358c:	19 f4       	brne	.+6      	; 0x3594 <vCoRoutineSchedule+0x160>
    358e:	10 92 79 03 	sts	0x0379, r1
    3592:	32 c0       	rjmp	.+100    	; 0x35f8 <vCoRoutineSchedule+0x1c4>
    3594:	91 50       	subi	r25, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    3596:	92 9f       	mul	r25, r18
    3598:	d0 01       	movw	r26, r0
    359a:	11 24       	eor	r1, r1
    359c:	a0 58       	subi	r26, 0x80	; 128
    359e:	bc 4f       	sbci	r27, 0xFC	; 252
    35a0:	8c 91       	ld	r24, X
    35a2:	88 23       	and	r24, r24
    35a4:	91 f3       	breq	.-28     	; 0x358a <vCoRoutineSchedule+0x156>
    35a6:	90 93 79 03 	sts	0x0379, r25
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    35aa:	11 96       	adiw	r26, 0x01	; 1
    35ac:	ed 91       	ld	r30, X+
    35ae:	fc 91       	ld	r31, X
    35b0:	12 97       	sbiw	r26, 0x02	; 2
    35b2:	02 80       	ldd	r0, Z+2	; 0x02
    35b4:	f3 81       	ldd	r31, Z+3	; 0x03
    35b6:	e0 2d       	mov	r30, r0
    35b8:	12 96       	adiw	r26, 0x02	; 2
    35ba:	fc 93       	st	X, r31
    35bc:	ee 93       	st	-X, r30
    35be:	11 97       	sbiw	r26, 0x01	; 1
    35c0:	cd 01       	movw	r24, r26
    35c2:	03 96       	adiw	r24, 0x03	; 3
    35c4:	e8 17       	cp	r30, r24
    35c6:	f9 07       	cpc	r31, r25
    35c8:	31 f4       	brne	.+12     	; 0x35d6 <vCoRoutineSchedule+0x1a2>
    35ca:	82 81       	ldd	r24, Z+2	; 0x02
    35cc:	93 81       	ldd	r25, Z+3	; 0x03
    35ce:	12 96       	adiw	r26, 0x02	; 2
    35d0:	9c 93       	st	X, r25
    35d2:	8e 93       	st	-X, r24
    35d4:	11 97       	sbiw	r26, 0x01	; 1
    35d6:	11 96       	adiw	r26, 0x01	; 1
    35d8:	ed 91       	ld	r30, X+
    35da:	fc 91       	ld	r31, X
    35dc:	12 97       	sbiw	r26, 0x02	; 2
    35de:	06 80       	ldd	r0, Z+6	; 0x06
    35e0:	f7 81       	ldd	r31, Z+7	; 0x07
    35e2:	e0 2d       	mov	r30, r0
    35e4:	f0 93 78 03 	sts	0x0378, r31
    35e8:	e0 93 77 03 	sts	0x0377, r30

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    35ec:	20 81       	ld	r18, Z
    35ee:	31 81       	ldd	r19, Z+1	; 0x01
    35f0:	cf 01       	movw	r24, r30
    35f2:	67 89       	ldd	r22, Z+23	; 0x17
    35f4:	f9 01       	movw	r30, r18
    35f6:	09 95       	icall

	return;
}
    35f8:	df 91       	pop	r29
    35fa:	cf 91       	pop	r28
    35fc:	1f 91       	pop	r17
    35fe:	0f 91       	pop	r16
    3600:	ff 90       	pop	r15
    3602:	08 95       	ret

00003604 <vCoRoutineAddToDelayedList>:
	return xReturn;	
}
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    3604:	0f 93       	push	r16
    3606:	1f 93       	push	r17
    3608:	cf 93       	push	r28
    360a:	df 93       	push	r29
    360c:	eb 01       	movw	r28, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    360e:	00 91 7e 03 	lds	r16, 0x037E
    3612:	10 91 7f 03 	lds	r17, 0x037F
    3616:	08 0f       	add	r16, r24
    3618:	19 1f       	adc	r17, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    361a:	80 91 77 03 	lds	r24, 0x0377
    361e:	90 91 78 03 	lds	r25, 0x0378
    3622:	02 96       	adiw	r24, 0x02	; 2
    3624:	0e 94 1c 11 	call	0x2238	; 0x2238 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    3628:	e0 91 77 03 	lds	r30, 0x0377
    362c:	f0 91 78 03 	lds	r31, 0x0378
    3630:	13 83       	std	Z+3, r17	; 0x03
    3632:	02 83       	std	Z+2, r16	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    3634:	80 91 7e 03 	lds	r24, 0x037E
    3638:	90 91 7f 03 	lds	r25, 0x037F
    363c:	bf 01       	movw	r22, r30
    363e:	6e 5f       	subi	r22, 0xFE	; 254
    3640:	7f 4f       	sbci	r23, 0xFF	; 255
    3642:	08 17       	cp	r16, r24
    3644:	19 07       	cpc	r17, r25
    3646:	28 f4       	brcc	.+10     	; 0x3652 <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    3648:	80 91 a6 03 	lds	r24, 0x03A6
    364c:	90 91 a7 03 	lds	r25, 0x03A7
    3650:	04 c0       	rjmp	.+8      	; 0x365a <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    3652:	80 91 a4 03 	lds	r24, 0x03A4
    3656:	90 91 a5 03 	lds	r25, 0x03A5
    365a:	0e 94 e7 10 	call	0x21ce	; 0x21ce <vListInsert>
	}

	if( pxEventList )
    365e:	20 97       	sbiw	r28, 0x00	; 0
    3660:	49 f0       	breq	.+18     	; 0x3674 <vCoRoutineAddToDelayedList+0x70>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    3662:	60 91 77 03 	lds	r22, 0x0377
    3666:	70 91 78 03 	lds	r23, 0x0378
    366a:	64 5f       	subi	r22, 0xF4	; 244
    366c:	7f 4f       	sbci	r23, 0xFF	; 255
    366e:	ce 01       	movw	r24, r28
    3670:	0e 94 e7 10 	call	0x21ce	; 0x21ce <vListInsert>
	}
}
    3674:	df 91       	pop	r29
    3676:	cf 91       	pop	r28
    3678:	1f 91       	pop	r17
    367a:	0f 91       	pop	r16
    367c:	08 95       	ret

0000367e <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    367e:	af 92       	push	r10
    3680:	bf 92       	push	r11
    3682:	cf 92       	push	r12
    3684:	df 92       	push	r13
    3686:	ef 92       	push	r14
    3688:	ff 92       	push	r15
    368a:	0f 93       	push	r16
    368c:	1f 93       	push	r17
    368e:	cf 93       	push	r28
    3690:	df 93       	push	r29
    3692:	6c 01       	movw	r12, r24
    3694:	b6 2e       	mov	r11, r22
    3696:	a4 2e       	mov	r10, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    3698:	8a e1       	ldi	r24, 0x1A	; 26
    369a:	90 e0       	ldi	r25, 0x00	; 0
    369c:	0e 94 c9 1b 	call	0x3792	; 0x3792 <pvPortMalloc>
    36a0:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
    36a2:	00 97       	sbiw	r24, 0x00	; 0
    36a4:	11 f4       	brne	.+4      	; 0x36aa <xCoRoutineCreate+0x2c>
    36a6:	8f ef       	ldi	r24, 0xFF	; 255
    36a8:	59 c0       	rjmp	.+178    	; 0x375c <xCoRoutineCreate+0xde>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    36aa:	80 91 77 03 	lds	r24, 0x0377
    36ae:	90 91 78 03 	lds	r25, 0x0378
    36b2:	89 2b       	or	r24, r25
    36b4:	21 f5       	brne	.+72     	; 0x36fe <xCoRoutineCreate+0x80>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    36b6:	d0 93 78 03 	sts	0x0378, r29
    36ba:	c0 93 77 03 	sts	0x0377, r28
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    36be:	80 e8       	ldi	r24, 0x80	; 128
    36c0:	93 e0       	ldi	r25, 0x03	; 3
    36c2:	0e 94 aa 10 	call	0x2154	; 0x2154 <vListInitialise>
    36c6:	89 e8       	ldi	r24, 0x89	; 137
    36c8:	93 e0       	ldi	r25, 0x03	; 3
    36ca:	0e 94 aa 10 	call	0x2154	; 0x2154 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    36ce:	22 e9       	ldi	r18, 0x92	; 146
    36d0:	e2 2e       	mov	r14, r18
    36d2:	23 e0       	ldi	r18, 0x03	; 3
    36d4:	f2 2e       	mov	r15, r18
    36d6:	c7 01       	movw	r24, r14
    36d8:	0e 94 aa 10 	call	0x2154	; 0x2154 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    36dc:	0b e9       	ldi	r16, 0x9B	; 155
    36de:	13 e0       	ldi	r17, 0x03	; 3
    36e0:	c8 01       	movw	r24, r16
    36e2:	0e 94 aa 10 	call	0x2154	; 0x2154 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    36e6:	88 ea       	ldi	r24, 0xA8	; 168
    36e8:	93 e0       	ldi	r25, 0x03	; 3
    36ea:	0e 94 aa 10 	call	0x2154	; 0x2154 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    36ee:	f0 92 a5 03 	sts	0x03A5, r15
    36f2:	e0 92 a4 03 	sts	0x03A4, r14
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    36f6:	10 93 a7 03 	sts	0x03A7, r17
    36fa:	00 93 a6 03 	sts	0x03A6, r16
    36fe:	eb 2c       	mov	r14, r11
    3700:	bb 20       	and	r11, r11
    3702:	11 f0       	breq	.+4      	; 0x3708 <xCoRoutineCreate+0x8a>
    3704:	ee 24       	eor	r14, r14
    3706:	e3 94       	inc	r14
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    3708:	19 8e       	std	Y+25, r1	; 0x19
    370a:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    370c:	ee 8a       	std	Y+22, r14	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    370e:	af 8a       	std	Y+23, r10	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    3710:	fe 01       	movw	r30, r28
    3712:	c1 92       	st	Z+, r12
    3714:	d1 92       	st	Z+, r13
    3716:	8f 01       	movw	r16, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    3718:	cf 01       	movw	r24, r30
    371a:	0e 94 ba 10 	call	0x2174	; 0x2174 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    371e:	ce 01       	movw	r24, r28
    3720:	0c 96       	adiw	r24, 0x0c	; 12
    3722:	0e 94 ba 10 	call	0x2174	; 0x2174 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    3726:	d9 87       	std	Y+9, r29	; 0x09
    3728:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    372a:	db 8b       	std	Y+19, r29	; 0x13
    372c:	ca 8b       	std	Y+18, r28	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    372e:	84 e0       	ldi	r24, 0x04	; 4
    3730:	90 e0       	ldi	r25, 0x00	; 0
    3732:	8e 19       	sub	r24, r14
    3734:	91 09       	sbc	r25, r1
    3736:	9d 87       	std	Y+13, r25	; 0x0d
    3738:	8c 87       	std	Y+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    373a:	9e 89       	ldd	r25, Y+22	; 0x16
    373c:	80 91 79 03 	lds	r24, 0x0379
    3740:	89 17       	cp	r24, r25
    3742:	10 f4       	brcc	.+4      	; 0x3748 <xCoRoutineCreate+0xca>
    3744:	90 93 79 03 	sts	0x0379, r25
    3748:	89 e0       	ldi	r24, 0x09	; 9
    374a:	98 9f       	mul	r25, r24
    374c:	c0 01       	movw	r24, r0
    374e:	11 24       	eor	r1, r1
    3750:	80 58       	subi	r24, 0x80	; 128
    3752:	9c 4f       	sbci	r25, 0xFC	; 252
    3754:	b8 01       	movw	r22, r16
    3756:	0e 94 be 10 	call	0x217c	; 0x217c <vListInsertEnd>
    375a:	81 e0       	ldi	r24, 0x01	; 1
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
	}
	
	return xReturn;	
}
    375c:	df 91       	pop	r29
    375e:	cf 91       	pop	r28
    3760:	1f 91       	pop	r17
    3762:	0f 91       	pop	r16
    3764:	ff 90       	pop	r15
    3766:	ef 90       	pop	r14
    3768:	df 90       	pop	r13
    376a:	cf 90       	pop	r12
    376c:	bf 90       	pop	r11
    376e:	af 90       	pop	r10
    3770:	08 95       	ret

00003772 <vPortFree>:
{
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    3772:	08 95       	ret

00003774 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    3774:	10 92 b2 03 	sts	0x03B2, r1
    3778:	10 92 b1 03 	sts	0x03B1, r1
}
    377c:	08 95       	ret

0000377e <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    377e:	28 eb       	ldi	r18, 0xB8	; 184
    3780:	3b e0       	ldi	r19, 0x0B	; 11
    3782:	80 91 b1 03 	lds	r24, 0x03B1
    3786:	90 91 b2 03 	lds	r25, 0x03B2
    378a:	28 1b       	sub	r18, r24
    378c:	39 0b       	sbc	r19, r25
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
}
    378e:	c9 01       	movw	r24, r18
    3790:	08 95       	ret

00003792 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    3792:	0f 93       	push	r16
    3794:	1f 93       	push	r17
    3796:	cf 93       	push	r28
    3798:	df 93       	push	r29
    379a:	8c 01       	movw	r16, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    379c:	0e 94 29 14 	call	0x2852	; 0x2852 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    37a0:	80 91 b1 03 	lds	r24, 0x03B1
    37a4:	90 91 b2 03 	lds	r25, 0x03B2
    37a8:	98 01       	movw	r18, r16
    37aa:	28 0f       	add	r18, r24
    37ac:	39 1f       	adc	r19, r25
    37ae:	4b e0       	ldi	r20, 0x0B	; 11
    37b0:	28 3b       	cpi	r18, 0xB8	; 184
    37b2:	34 07       	cpc	r19, r20
    37b4:	58 f4       	brcc	.+22     	; 0x37cc <pvPortMalloc+0x3a>
    37b6:	82 17       	cp	r24, r18
    37b8:	93 07       	cpc	r25, r19
    37ba:	40 f4       	brcc	.+16     	; 0x37cc <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    37bc:	ec 01       	movw	r28, r24
    37be:	cd 54       	subi	r28, 0x4D	; 77
    37c0:	dc 4f       	sbci	r29, 0xFC	; 252
			xNextFreeByte += xWantedSize;			
    37c2:	30 93 b2 03 	sts	0x03B2, r19
    37c6:	20 93 b1 03 	sts	0x03B1, r18
    37ca:	02 c0       	rjmp	.+4      	; 0x37d0 <pvPortMalloc+0x3e>
    37cc:	c0 e0       	ldi	r28, 0x00	; 0
    37ce:	d0 e0       	ldi	r29, 0x00	; 0
		}	
	}
	xTaskResumeAll();
    37d0:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
    37d4:	ce 01       	movw	r24, r28
    37d6:	df 91       	pop	r29
    37d8:	cf 91       	pop	r28
    37da:	1f 91       	pop	r17
    37dc:	0f 91       	pop	r16
    37de:	08 95       	ret

000037e0 <prescaler_hex_to_value>:
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    37e0:	e8 2f       	mov	r30, r24
    37e2:	f0 e0       	ldi	r31, 0x00	; 0
    37e4:	e7 70       	andi	r30, 0x07	; 7
    37e6:	f0 70       	andi	r31, 0x00	; 0
    37e8:	ee 0f       	add	r30, r30
    37ea:	ff 1f       	adc	r31, r31
    37ec:	e2 56       	subi	r30, 0x62	; 98
    37ee:	fe 4f       	sbci	r31, 0xFE	; 254
    37f0:	25 91       	lpm	r18, Z+
    37f2:	34 91       	lpm	r19, Z+
}
    37f4:	c9 01       	movw	r24, r18
    37f6:	08 95       	ret

000037f8 <prescaler_hex_to_value_for_timer2>:
uint16_t prescaler_hex_to_value_for_timer2(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to Timer2PrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(Timer2PrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    37f8:	e8 2f       	mov	r30, r24
    37fa:	f0 e0       	ldi	r31, 0x00	; 0
    37fc:	e7 70       	andi	r30, 0x07	; 7
    37fe:	f0 70       	andi	r31, 0x00	; 0
    3800:	ee 0f       	add	r30, r30
    3802:	ff 1f       	adc	r31, r31
    3804:	e6 55       	subi	r30, 0x56	; 86
    3806:	fe 4f       	sbci	r31, 0xFE	; 254
    3808:	25 91       	lpm	r18, Z+
    380a:	34 91       	lpm	r19, Z+
}
    380c:	c9 01       	movw	r24, r18
    380e:	08 95       	ret

00003810 <get_timer0_prescaler>:

uint16_t get_timer0_prescaler(void)
{
  return prescaler_hex_to_value(TCCR0B);
    3810:	85 b5       	in	r24, 0x25	; 37
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    3812:	e8 2f       	mov	r30, r24
    3814:	f0 e0       	ldi	r31, 0x00	; 0
    3816:	e7 70       	andi	r30, 0x07	; 7
    3818:	f0 70       	andi	r31, 0x00	; 0
    381a:	ee 0f       	add	r30, r30
    381c:	ff 1f       	adc	r31, r31
    381e:	e2 56       	subi	r30, 0x62	; 98
    3820:	fe 4f       	sbci	r31, 0xFE	; 254
    3822:	25 91       	lpm	r18, Z+
    3824:	34 91       	lpm	r19, Z+
}

uint16_t get_timer0_prescaler(void)
{
  return prescaler_hex_to_value(TCCR0B);
}
    3826:	c9 01       	movw	r24, r18
    3828:	08 95       	ret

0000382a <get_timer1_prescaler>:
uint16_t get_timer1_prescaler(void)
{
  return prescaler_hex_to_value(TCCR1B);
    382a:	80 91 81 00 	lds	r24, 0x0081
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    382e:	e8 2f       	mov	r30, r24
    3830:	f0 e0       	ldi	r31, 0x00	; 0
    3832:	e7 70       	andi	r30, 0x07	; 7
    3834:	f0 70       	andi	r31, 0x00	; 0
    3836:	ee 0f       	add	r30, r30
    3838:	ff 1f       	adc	r31, r31
    383a:	e2 56       	subi	r30, 0x62	; 98
    383c:	fe 4f       	sbci	r31, 0xFE	; 254
    383e:	25 91       	lpm	r18, Z+
    3840:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR0B);
}
uint16_t get_timer1_prescaler(void)
{
  return prescaler_hex_to_value(TCCR1B);
}
    3842:	c9 01       	movw	r24, r18
    3844:	08 95       	ret

00003846 <get_timer2_prescaler>:
uint16_t get_timer2_prescaler(void)
{
  return prescaler_hex_to_value_for_timer2(TCCR2B);
    3846:	80 91 b1 00 	lds	r24, 0x00B1
uint16_t prescaler_hex_to_value_for_timer2(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to Timer2PrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(Timer2PrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    384a:	e8 2f       	mov	r30, r24
    384c:	f0 e0       	ldi	r31, 0x00	; 0
    384e:	e7 70       	andi	r30, 0x07	; 7
    3850:	f0 70       	andi	r31, 0x00	; 0
    3852:	ee 0f       	add	r30, r30
    3854:	ff 1f       	adc	r31, r31
    3856:	e6 55       	subi	r30, 0x56	; 86
    3858:	fe 4f       	sbci	r31, 0xFE	; 254
    385a:	25 91       	lpm	r18, Z+
    385c:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR1B);
}
uint16_t get_timer2_prescaler(void)
{
  return prescaler_hex_to_value_for_timer2(TCCR2B);
}
    385e:	c9 01       	movw	r24, r18
    3860:	08 95       	ret

00003862 <get_timer3_prescaler>:
uint16_t get_timer3_prescaler(void)
{
  return prescaler_hex_to_value(TCCR3B);
    3862:	80 91 91 00 	lds	r24, 0x0091
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    3866:	e8 2f       	mov	r30, r24
    3868:	f0 e0       	ldi	r31, 0x00	; 0
    386a:	e7 70       	andi	r30, 0x07	; 7
    386c:	f0 70       	andi	r31, 0x00	; 0
    386e:	ee 0f       	add	r30, r30
    3870:	ff 1f       	adc	r31, r31
    3872:	e2 56       	subi	r30, 0x62	; 98
    3874:	fe 4f       	sbci	r31, 0xFE	; 254
    3876:	25 91       	lpm	r18, Z+
    3878:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value_for_timer2(TCCR2B);
}
uint16_t get_timer3_prescaler(void)
{
  return prescaler_hex_to_value(TCCR3B);
}
    387a:	c9 01       	movw	r24, r18
    387c:	08 95       	ret

0000387e <get_timer4_prescaler>:
uint16_t get_timer4_prescaler(void)
{
  return prescaler_hex_to_value(TCCR4B);
    387e:	80 91 a1 00 	lds	r24, 0x00A1
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    3882:	e8 2f       	mov	r30, r24
    3884:	f0 e0       	ldi	r31, 0x00	; 0
    3886:	e7 70       	andi	r30, 0x07	; 7
    3888:	f0 70       	andi	r31, 0x00	; 0
    388a:	ee 0f       	add	r30, r30
    388c:	ff 1f       	adc	r31, r31
    388e:	e2 56       	subi	r30, 0x62	; 98
    3890:	fe 4f       	sbci	r31, 0xFE	; 254
    3892:	25 91       	lpm	r18, Z+
    3894:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR3B);
}
uint16_t get_timer4_prescaler(void)
{
  return prescaler_hex_to_value(TCCR4B);
}
    3896:	c9 01       	movw	r24, r18
    3898:	08 95       	ret

0000389a <get_timer5_prescaler>:
uint16_t get_timer5_prescaler(void)
{
  return prescaler_hex_to_value(TCCR5B);
    389a:	80 91 21 01 	lds	r24, 0x0121
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    389e:	e8 2f       	mov	r30, r24
    38a0:	f0 e0       	ldi	r31, 0x00	; 0
    38a2:	e7 70       	andi	r30, 0x07	; 7
    38a4:	f0 70       	andi	r31, 0x00	; 0
    38a6:	ee 0f       	add	r30, r30
    38a8:	ff 1f       	adc	r31, r31
    38aa:	e2 56       	subi	r30, 0x62	; 98
    38ac:	fe 4f       	sbci	r31, 0xFE	; 254
    38ae:	25 91       	lpm	r18, Z+
    38b0:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR4B);
}
uint16_t get_timer5_prescaler(void)
{
  return prescaler_hex_to_value(TCCR5B);
}
    38b2:	c9 01       	movw	r24, r18
    38b4:	08 95       	ret

000038b6 <get_timer0_overflow>:

const uint32_t get_timer0_overflow(void)
{
    return timer0_ovrflow_cnt;
    38b6:	20 91 52 12 	lds	r18, 0x1252
    38ba:	30 91 53 12 	lds	r19, 0x1253
    38be:	40 91 54 12 	lds	r20, 0x1254
    38c2:	50 91 55 12 	lds	r21, 0x1255
}
    38c6:	b9 01       	movw	r22, r18
    38c8:	ca 01       	movw	r24, r20
    38ca:	08 95       	ret

000038cc <get_timer1_overflow>:
const uint32_t get_timer1_overflow(void)
{
    return timer1_ovrflow_cnt;
    38cc:	20 91 4e 12 	lds	r18, 0x124E
    38d0:	30 91 4f 12 	lds	r19, 0x124F
    38d4:	40 91 50 12 	lds	r20, 0x1250
    38d8:	50 91 51 12 	lds	r21, 0x1251
}
    38dc:	b9 01       	movw	r22, r18
    38de:	ca 01       	movw	r24, r20
    38e0:	08 95       	ret

000038e2 <get_timer2_overflow>:
const uint32_t get_timer2_overflow(void)
{
    return timer2_ovrflow_cnt;
    38e2:	20 91 56 12 	lds	r18, 0x1256
    38e6:	30 91 57 12 	lds	r19, 0x1257
    38ea:	40 91 58 12 	lds	r20, 0x1258
    38ee:	50 91 59 12 	lds	r21, 0x1259
}
    38f2:	b9 01       	movw	r22, r18
    38f4:	ca 01       	movw	r24, r20
    38f6:	08 95       	ret

000038f8 <get_timer3_overflow>:
const uint32_t get_timer3_overflow(void)
{
    return timer3_ovrflow_cnt;
    38f8:	20 91 5e 12 	lds	r18, 0x125E
    38fc:	30 91 5f 12 	lds	r19, 0x125F
    3900:	40 91 60 12 	lds	r20, 0x1260
    3904:	50 91 61 12 	lds	r21, 0x1261
}
    3908:	b9 01       	movw	r22, r18
    390a:	ca 01       	movw	r24, r20
    390c:	08 95       	ret

0000390e <get_timer4_overflow>:
const uint32_t get_timer4_overflow(void)
{
    return timer4_ovrflow_cnt;
    390e:	20 91 4a 12 	lds	r18, 0x124A
    3912:	30 91 4b 12 	lds	r19, 0x124B
    3916:	40 91 4c 12 	lds	r20, 0x124C
    391a:	50 91 4d 12 	lds	r21, 0x124D
}
    391e:	b9 01       	movw	r22, r18
    3920:	ca 01       	movw	r24, r20
    3922:	08 95       	ret

00003924 <get_timer5_overflow>:
const uint32_t get_timer5_overflow(void)
{
    return timer5_ovrflow_cnt;
    3924:	20 91 62 12 	lds	r18, 0x1262
    3928:	30 91 63 12 	lds	r19, 0x1263
    392c:	40 91 64 12 	lds	r20, 0x1264
    3930:	50 91 65 12 	lds	r21, 0x1265
}
    3934:	b9 01       	movw	r22, r18
    3936:	ca 01       	movw	r24, r20
    3938:	08 95       	ret

0000393a <get_timer0_counter>:

const uint8_t get_timer0_counter(void)
{
    return TCNT0;
    393a:	86 b5       	in	r24, 0x26	; 38
}
    393c:	08 95       	ret

0000393e <get_timer1_counter>:
const uint16_t get_timer1_counter(void)
{
    return TCNT1;
    393e:	20 91 84 00 	lds	r18, 0x0084
    3942:	30 91 85 00 	lds	r19, 0x0085
}
    3946:	c9 01       	movw	r24, r18
    3948:	08 95       	ret

0000394a <get_timer2_counter>:
const uint8_t get_timer2_counter(void)
{
    return TCNT2;
    394a:	80 91 b2 00 	lds	r24, 0x00B2
}
    394e:	08 95       	ret

00003950 <get_timer3_counter>:
const uint16_t get_timer3_counter(void)
{
    return TCNT3;
    3950:	20 91 94 00 	lds	r18, 0x0094
    3954:	30 91 95 00 	lds	r19, 0x0095
}
    3958:	c9 01       	movw	r24, r18
    395a:	08 95       	ret

0000395c <get_timer4_counter>:
const uint16_t get_timer4_counter(void)
{
    return TCNT4;
    395c:	20 91 a4 00 	lds	r18, 0x00A4
    3960:	30 91 a5 00 	lds	r19, 0x00A5
}
    3964:	c9 01       	movw	r24, r18
    3966:	08 95       	ret

00003968 <get_timer5_counter>:
const uint16_t get_timer5_counter(void)
{
    return TCNT5;
    3968:	20 91 24 01 	lds	r18, 0x0124
    396c:	30 91 25 01 	lds	r19, 0x0125
}
    3970:	c9 01       	movw	r24, r18
    3972:	08 95       	ret

00003974 <reset_timer0>:

void reset_timer0(void)
{
    TCNT0 = timer0_ovrflow_cnt = 0;
    3974:	10 92 52 12 	sts	0x1252, r1
    3978:	10 92 53 12 	sts	0x1253, r1
    397c:	10 92 54 12 	sts	0x1254, r1
    3980:	10 92 55 12 	sts	0x1255, r1
    3984:	16 bc       	out	0x26, r1	; 38
}
    3986:	08 95       	ret

00003988 <reset_timer1>:
void reset_timer1(void)
{
    TCNT1 = timer1_ovrflow_cnt = 0;
    3988:	10 92 4e 12 	sts	0x124E, r1
    398c:	10 92 4f 12 	sts	0x124F, r1
    3990:	10 92 50 12 	sts	0x1250, r1
    3994:	10 92 51 12 	sts	0x1251, r1
    3998:	10 92 85 00 	sts	0x0085, r1
    399c:	10 92 84 00 	sts	0x0084, r1
}
    39a0:	08 95       	ret

000039a2 <reset_timer2>:
void reset_timer2(void)
{
    TCNT2 = timer2_ovrflow_cnt = 0;
    39a2:	10 92 56 12 	sts	0x1256, r1
    39a6:	10 92 57 12 	sts	0x1257, r1
    39aa:	10 92 58 12 	sts	0x1258, r1
    39ae:	10 92 59 12 	sts	0x1259, r1
    39b2:	10 92 b2 00 	sts	0x00B2, r1
}
    39b6:	08 95       	ret

000039b8 <reset_timer3>:
void reset_timer3(void)
{
    TCNT3 = timer3_ovrflow_cnt = 0;
    39b8:	10 92 5e 12 	sts	0x125E, r1
    39bc:	10 92 5f 12 	sts	0x125F, r1
    39c0:	10 92 60 12 	sts	0x1260, r1
    39c4:	10 92 61 12 	sts	0x1261, r1
    39c8:	10 92 95 00 	sts	0x0095, r1
    39cc:	10 92 94 00 	sts	0x0094, r1
}
    39d0:	08 95       	ret

000039d2 <reset_timer4>:
void reset_timer4(void)
{
    TCNT4 = timer4_ovrflow_cnt = 0;
    39d2:	10 92 4a 12 	sts	0x124A, r1
    39d6:	10 92 4b 12 	sts	0x124B, r1
    39da:	10 92 4c 12 	sts	0x124C, r1
    39de:	10 92 4d 12 	sts	0x124D, r1
    39e2:	10 92 a5 00 	sts	0x00A5, r1
    39e6:	10 92 a4 00 	sts	0x00A4, r1
}
    39ea:	08 95       	ret

000039ec <reset_timer5>:
void reset_timer5(void)
{
    TCNT5 = timer5_ovrflow_cnt = 0;
    39ec:	10 92 62 12 	sts	0x1262, r1
    39f0:	10 92 63 12 	sts	0x1263, r1
    39f4:	10 92 64 12 	sts	0x1264, r1
    39f8:	10 92 65 12 	sts	0x1265, r1
    39fc:	10 92 25 01 	sts	0x0125, r1
    3a00:	10 92 24 01 	sts	0x0124, r1
}
    3a04:	08 95       	ret

00003a06 <delay_us>:

	delay_loops = ((time_us * CYCLES_PER_US)+3) / 5; // +3 for rounding up (dirty) 

	// one loop takes 5 cpu cycles 
	for (i=0; i < delay_loops; i++) {};
}
    3a06:	08 95       	ret

00003a08 <init_timer0>:

void init_timer0(const uint8_t prescaler)
{
  TCCR0B = prescaler;
    3a08:	85 bd       	out	0x25, r24	; 37
  TIMSK0 = _BV(TOIE0); // enable interrupts
    3a0a:	81 e0       	ldi	r24, 0x01	; 1
    3a0c:	80 93 6e 00 	sts	0x006E, r24
    return TCNT5;
}

void reset_timer0(void)
{
    TCNT0 = timer0_ovrflow_cnt = 0;
    3a10:	10 92 52 12 	sts	0x1252, r1
    3a14:	10 92 53 12 	sts	0x1253, r1
    3a18:	10 92 54 12 	sts	0x1254, r1
    3a1c:	10 92 55 12 	sts	0x1255, r1
    3a20:	16 bc       	out	0x26, r1	; 38
void init_timer0(const uint8_t prescaler)
{
  TCCR0B = prescaler;
  TIMSK0 = _BV(TOIE0); // enable interrupts
  reset_timer0(); // reset counter
}
    3a22:	08 95       	ret

00003a24 <init_timer1>:
void init_timer1(const uint8_t prescaler)
{
  TCCR1B = prescaler;
    3a24:	80 93 81 00 	sts	0x0081, r24
  TIMSK1 = _BV(TOIE1); // enable interrupts
    3a28:	81 e0       	ldi	r24, 0x01	; 1
    3a2a:	80 93 6f 00 	sts	0x006F, r24
{
    TCNT0 = timer0_ovrflow_cnt = 0;
}
void reset_timer1(void)
{
    TCNT1 = timer1_ovrflow_cnt = 0;
    3a2e:	10 92 4e 12 	sts	0x124E, r1
    3a32:	10 92 4f 12 	sts	0x124F, r1
    3a36:	10 92 50 12 	sts	0x1250, r1
    3a3a:	10 92 51 12 	sts	0x1251, r1
    3a3e:	10 92 85 00 	sts	0x0085, r1
    3a42:	10 92 84 00 	sts	0x0084, r1
void init_timer1(const uint8_t prescaler)
{
  TCCR1B = prescaler;
  TIMSK1 = _BV(TOIE1); // enable interrupts
  reset_timer1(); // reset counter
}
    3a46:	08 95       	ret

00003a48 <init_timer2>:
void init_timer2(const uint8_t prescaler)
{
  TCCR2B = prescaler;
    3a48:	80 93 b1 00 	sts	0x00B1, r24
  TIMSK2 = _BV(TOIE2); // enable interrupts
    3a4c:	81 e0       	ldi	r24, 0x01	; 1
    3a4e:	80 93 70 00 	sts	0x0070, r24
{
    TCNT1 = timer1_ovrflow_cnt = 0;
}
void reset_timer2(void)
{
    TCNT2 = timer2_ovrflow_cnt = 0;
    3a52:	10 92 56 12 	sts	0x1256, r1
    3a56:	10 92 57 12 	sts	0x1257, r1
    3a5a:	10 92 58 12 	sts	0x1258, r1
    3a5e:	10 92 59 12 	sts	0x1259, r1
    3a62:	10 92 b2 00 	sts	0x00B2, r1
void init_timer2(const uint8_t prescaler)
{
  TCCR2B = prescaler;
  TIMSK2 = _BV(TOIE2); // enable interrupts
  reset_timer2(); // reset counter
}
    3a66:	08 95       	ret

00003a68 <init_timer3>:
void init_timer3(const uint8_t prescaler)
{
  TCCR3B = prescaler;
    3a68:	80 93 91 00 	sts	0x0091, r24
  TIMSK3 = _BV(TOIE3); // enable interrupts
    3a6c:	81 e0       	ldi	r24, 0x01	; 1
    3a6e:	80 93 71 00 	sts	0x0071, r24
{
    TCNT2 = timer2_ovrflow_cnt = 0;
}
void reset_timer3(void)
{
    TCNT3 = timer3_ovrflow_cnt = 0;
    3a72:	10 92 5e 12 	sts	0x125E, r1
    3a76:	10 92 5f 12 	sts	0x125F, r1
    3a7a:	10 92 60 12 	sts	0x1260, r1
    3a7e:	10 92 61 12 	sts	0x1261, r1
    3a82:	10 92 95 00 	sts	0x0095, r1
    3a86:	10 92 94 00 	sts	0x0094, r1
void init_timer3(const uint8_t prescaler)
{
  TCCR3B = prescaler;
  TIMSK3 = _BV(TOIE3); // enable interrupts
  reset_timer3(); // reset counter
}
    3a8a:	08 95       	ret

00003a8c <init_timer4>:
void init_timer4(const uint8_t prescaler)
{
  TCCR4B = prescaler;
    3a8c:	80 93 a1 00 	sts	0x00A1, r24
  TIMSK4 = _BV(TOIE4); // enable interrupts
    3a90:	81 e0       	ldi	r24, 0x01	; 1
    3a92:	80 93 72 00 	sts	0x0072, r24
{
    TCNT3 = timer3_ovrflow_cnt = 0;
}
void reset_timer4(void)
{
    TCNT4 = timer4_ovrflow_cnt = 0;
    3a96:	10 92 4a 12 	sts	0x124A, r1
    3a9a:	10 92 4b 12 	sts	0x124B, r1
    3a9e:	10 92 4c 12 	sts	0x124C, r1
    3aa2:	10 92 4d 12 	sts	0x124D, r1
    3aa6:	10 92 a5 00 	sts	0x00A5, r1
    3aaa:	10 92 a4 00 	sts	0x00A4, r1
void init_timer4(const uint8_t prescaler)
{
  TCCR4B = prescaler;
  TIMSK4 = _BV(TOIE4); // enable interrupts
  reset_timer4(); // reset counter
}
    3aae:	08 95       	ret

00003ab0 <init_timer5>:
void init_timer5(const uint8_t prescaler)
{
  TCCR5B = prescaler;
    3ab0:	80 93 21 01 	sts	0x0121, r24
  TIMSK5 = _BV(TOIE5); // enable interrupts
    3ab4:	81 e0       	ldi	r24, 0x01	; 1
    3ab6:	80 93 73 00 	sts	0x0073, r24
{
    TCNT4 = timer4_ovrflow_cnt = 0;
}
void reset_timer5(void)
{
    TCNT5 = timer5_ovrflow_cnt = 0;
    3aba:	10 92 62 12 	sts	0x1262, r1
    3abe:	10 92 63 12 	sts	0x1263, r1
    3ac2:	10 92 64 12 	sts	0x1264, r1
    3ac6:	10 92 65 12 	sts	0x1265, r1
    3aca:	10 92 25 01 	sts	0x0125, r1
    3ace:	10 92 24 01 	sts	0x0124, r1
void init_timer5(const uint8_t prescaler)
{
  TCCR5B = prescaler;
  TIMSK5 = _BV(TOIE5); // enable interrupts
  reset_timer5(); // reset counter
}
    3ad2:	08 95       	ret

00003ad4 <timer_attach>:

void timer_attach(TimerInterrupt_t interrupt, void (*user_func)(void) )
{
  // set the interrupt function to run
  // the supplied user's function
  TimerIntFunc[interrupt] = user_func;
    3ad4:	e8 2f       	mov	r30, r24
    3ad6:	f0 e0       	ldi	r31, 0x00	; 0
    3ad8:	ee 0f       	add	r30, r30
    3ada:	ff 1f       	adc	r31, r31
    3adc:	e5 59       	subi	r30, 0x95	; 149
    3ade:	f0 4f       	sbci	r31, 0xF0	; 240
    3ae0:	71 83       	std	Z+1, r23	; 0x01
    3ae2:	60 83       	st	Z, r22
}
    3ae4:	08 95       	ret

00003ae6 <timer_detach>:

void timer_detach(TimerInterrupt_t interrupt)
{
  // clear the user defined interrupt function
  TimerIntFunc[interrupt] = NULL;
    3ae6:	e8 2f       	mov	r30, r24
    3ae8:	f0 e0       	ldi	r31, 0x00	; 0
    3aea:	ee 0f       	add	r30, r30
    3aec:	ff 1f       	adc	r31, r31
    3aee:	e5 59       	subi	r30, 0x95	; 149
    3af0:	f0 4f       	sbci	r31, 0xF0	; 240
    3af2:	11 82       	std	Z+1, r1	; 0x01
    3af4:	10 82       	st	Z, r1
}
    3af6:	08 95       	ret

00003af8 <_delay_loop_2>:

void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3af8:	01 97       	sbiw	r24, 0x01	; 1
    3afa:	f1 f7       	brne	.-4      	; 0x3af8 <_delay_loop_2>
		"1: sbiw %0,1" "\n\t"
		"brne 1b"
		: "=w" (__count)
		: "0" (__count)
	);
}
    3afc:	08 95       	ret

00003afe <sleep>:

void sleep(uint16_t time_ms)
{
    3afe:	af 92       	push	r10
    3b00:	bf 92       	push	r11
    3b02:	cf 92       	push	r12
    3b04:	df 92       	push	r13
    3b06:	ef 92       	push	r14
    3b08:	ff 92       	push	r15
    3b0a:	0f 93       	push	r16
    3b0c:	1f 93       	push	r17
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * time_ms;
    3b0e:	a0 e0       	ldi	r26, 0x00	; 0
    3b10:	b0 e0       	ldi	r27, 0x00	; 0
    3b12:	bc 01       	movw	r22, r24
    3b14:	cd 01       	movw	r24, r26
    3b16:	0e 94 c1 2e 	call	0x5d82	; 0x5d82 <__floatunsisf>
    3b1a:	5b 01       	movw	r10, r22
    3b1c:	6c 01       	movw	r12, r24
    3b1e:	20 e0       	ldi	r18, 0x00	; 0
    3b20:	30 e0       	ldi	r19, 0x00	; 0
    3b22:	4a e7       	ldi	r20, 0x7A	; 122
    3b24:	55 e4       	ldi	r21, 0x45	; 69
    3b26:	0e 94 77 2f 	call	0x5eee	; 0x5eee <__mulsf3>
    3b2a:	7b 01       	movw	r14, r22
    3b2c:	8c 01       	movw	r16, r24
	if (__tmp < 1.0)
    3b2e:	20 e0       	ldi	r18, 0x00	; 0
    3b30:	30 e0       	ldi	r19, 0x00	; 0
    3b32:	40 e8       	ldi	r20, 0x80	; 128
    3b34:	5f e3       	ldi	r21, 0x3F	; 63
    3b36:	0e 94 24 2e 	call	0x5c48	; 0x5c48 <__cmpsf2>
    3b3a:	88 23       	and	r24, r24
    3b3c:	1c f4       	brge	.+6      	; 0x3b44 <sleep+0x46>
    3b3e:	61 e0       	ldi	r22, 0x01	; 1
    3b40:	70 e0       	ldi	r23, 0x00	; 0
    3b42:	24 c0       	rjmp	.+72     	; 0x3b8c <sleep+0x8e>
		__ticks = 1;
	else if (__tmp > 65535)
    3b44:	c8 01       	movw	r24, r16
    3b46:	b7 01       	movw	r22, r14
    3b48:	20 e0       	ldi	r18, 0x00	; 0
    3b4a:	3f ef       	ldi	r19, 0xFF	; 255
    3b4c:	4f e7       	ldi	r20, 0x7F	; 127
    3b4e:	57 e4       	ldi	r21, 0x47	; 71
    3b50:	0e 94 73 2f 	call	0x5ee6	; 0x5ee6 <__gesf2>
    3b54:	18 16       	cp	r1, r24
    3b56:	b4 f4       	brge	.+44     	; 0x3b84 <sleep+0x86>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (time_ms * 10.0);
    3b58:	c6 01       	movw	r24, r12
    3b5a:	b5 01       	movw	r22, r10
    3b5c:	20 e0       	ldi	r18, 0x00	; 0
    3b5e:	30 e0       	ldi	r19, 0x00	; 0
    3b60:	40 e2       	ldi	r20, 0x20	; 32
    3b62:	51 e4       	ldi	r21, 0x41	; 65
    3b64:	0e 94 77 2f 	call	0x5eee	; 0x5eee <__mulsf3>
    3b68:	0e 94 95 2e 	call	0x5d2a	; 0x5d2a <__fixunssfsi>
}

void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3b6c:	80 e9       	ldi	r24, 0x90	; 144
    3b6e:	91 e0       	ldi	r25, 0x01	; 1
    3b70:	05 c0       	rjmp	.+10     	; 0x3b7c <sleep+0x7e>
    3b72:	fc 01       	movw	r30, r24
    3b74:	31 97       	sbiw	r30, 0x01	; 1
    3b76:	f1 f7       	brne	.-4      	; 0x3b74 <sleep+0x76>
		__ticks = (uint16_t) (time_ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3b78:	61 50       	subi	r22, 0x01	; 1
    3b7a:	70 40       	sbci	r23, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (time_ms * 10.0);
		while(__ticks)
    3b7c:	61 15       	cp	r22, r1
    3b7e:	71 05       	cpc	r23, r1
    3b80:	c1 f7       	brne	.-16     	; 0x3b72 <sleep+0x74>
    3b82:	07 c0       	rjmp	.+14     	; 0x3b92 <sleep+0x94>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3b84:	c8 01       	movw	r24, r16
    3b86:	b7 01       	movw	r22, r14
    3b88:	0e 94 95 2e 	call	0x5d2a	; 0x5d2a <__fixunssfsi>
}

void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3b8c:	cb 01       	movw	r24, r22
    3b8e:	01 97       	sbiw	r24, 0x01	; 1
    3b90:	f1 f7       	brne	.-4      	; 0x3b8e <sleep+0x90>
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
	_delay_loop_2(__ticks);
}
    3b92:	1f 91       	pop	r17
    3b94:	0f 91       	pop	r16
    3b96:	ff 90       	pop	r15
    3b98:	ef 90       	pop	r14
    3b9a:	df 90       	pop	r13
    3b9c:	cf 90       	pop	r12
    3b9e:	bf 90       	pop	r11
    3ba0:	af 90       	pop	r10
    3ba2:	08 95       	ret

00003ba4 <__vector_23>:
    }
  }
}*/

ISR(TIMER0_OVF_vect) 
{
    3ba4:	1f 92       	push	r1
    3ba6:	0f 92       	push	r0
    3ba8:	0f b6       	in	r0, 0x3f	; 63
    3baa:	0f 92       	push	r0
    3bac:	11 24       	eor	r1, r1
    3bae:	2f 93       	push	r18
    3bb0:	3f 93       	push	r19
    3bb2:	4f 93       	push	r20
    3bb4:	5f 93       	push	r21
    3bb6:	6f 93       	push	r22
    3bb8:	7f 93       	push	r23
    3bba:	8f 93       	push	r24
    3bbc:	9f 93       	push	r25
    3bbe:	af 93       	push	r26
    3bc0:	bf 93       	push	r27
    3bc2:	ef 93       	push	r30
    3bc4:	ff 93       	push	r31
  timer0_ovrflow_cnt++;
    3bc6:	80 91 52 12 	lds	r24, 0x1252
    3bca:	90 91 53 12 	lds	r25, 0x1253
    3bce:	a0 91 54 12 	lds	r26, 0x1254
    3bd2:	b0 91 55 12 	lds	r27, 0x1255
    3bd6:	01 96       	adiw	r24, 0x01	; 1
    3bd8:	a1 1d       	adc	r26, r1
    3bda:	b1 1d       	adc	r27, r1
    3bdc:	80 93 52 12 	sts	0x1252, r24
    3be0:	90 93 53 12 	sts	0x1253, r25
    3be4:	a0 93 54 12 	sts	0x1254, r26
    3be8:	b0 93 55 12 	sts	0x1255, r27
  timer_sleep_cnt++;
    3bec:	80 91 5a 12 	lds	r24, 0x125A
    3bf0:	90 91 5b 12 	lds	r25, 0x125B
    3bf4:	a0 91 5c 12 	lds	r26, 0x125C
    3bf8:	b0 91 5d 12 	lds	r27, 0x125D
    3bfc:	01 96       	adiw	r24, 0x01	; 1
    3bfe:	a1 1d       	adc	r26, r1
    3c00:	b1 1d       	adc	r27, r1
    3c02:	80 93 5a 12 	sts	0x125A, r24
    3c06:	90 93 5b 12 	sts	0x125B, r25
    3c0a:	a0 93 5c 12 	sts	0x125C, r26
    3c0e:	b0 93 5d 12 	sts	0x125D, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER0_OVF_interrupt);
    3c12:	80 91 6f 0f 	lds	r24, 0x0F6F
    3c16:	90 91 70 0f 	lds	r25, 0x0F70
    3c1a:	89 2b       	or	r24, r25
    3c1c:	29 f0       	breq	.+10     	; 0x3c28 <__vector_23+0x84>
    3c1e:	e0 91 6f 0f 	lds	r30, 0x0F6F
    3c22:	f0 91 70 0f 	lds	r31, 0x0F70
    3c26:	09 95       	icall
}
    3c28:	ff 91       	pop	r31
    3c2a:	ef 91       	pop	r30
    3c2c:	bf 91       	pop	r27
    3c2e:	af 91       	pop	r26
    3c30:	9f 91       	pop	r25
    3c32:	8f 91       	pop	r24
    3c34:	7f 91       	pop	r23
    3c36:	6f 91       	pop	r22
    3c38:	5f 91       	pop	r21
    3c3a:	4f 91       	pop	r20
    3c3c:	3f 91       	pop	r19
    3c3e:	2f 91       	pop	r18
    3c40:	0f 90       	pop	r0
    3c42:	0f be       	out	0x3f, r0	; 63
    3c44:	0f 90       	pop	r0
    3c46:	1f 90       	pop	r1
    3c48:	18 95       	reti

00003c4a <__vector_20>:
ISR(TIMER1_OVF_vect) 
{
    3c4a:	1f 92       	push	r1
    3c4c:	0f 92       	push	r0
    3c4e:	0f b6       	in	r0, 0x3f	; 63
    3c50:	0f 92       	push	r0
    3c52:	11 24       	eor	r1, r1
    3c54:	2f 93       	push	r18
    3c56:	3f 93       	push	r19
    3c58:	4f 93       	push	r20
    3c5a:	5f 93       	push	r21
    3c5c:	6f 93       	push	r22
    3c5e:	7f 93       	push	r23
    3c60:	8f 93       	push	r24
    3c62:	9f 93       	push	r25
    3c64:	af 93       	push	r26
    3c66:	bf 93       	push	r27
    3c68:	ef 93       	push	r30
    3c6a:	ff 93       	push	r31
  timer1_ovrflow_cnt++;
    3c6c:	80 91 4e 12 	lds	r24, 0x124E
    3c70:	90 91 4f 12 	lds	r25, 0x124F
    3c74:	a0 91 50 12 	lds	r26, 0x1250
    3c78:	b0 91 51 12 	lds	r27, 0x1251
    3c7c:	01 96       	adiw	r24, 0x01	; 1
    3c7e:	a1 1d       	adc	r26, r1
    3c80:	b1 1d       	adc	r27, r1
    3c82:	80 93 4e 12 	sts	0x124E, r24
    3c86:	90 93 4f 12 	sts	0x124F, r25
    3c8a:	a0 93 50 12 	sts	0x1250, r26
    3c8e:	b0 93 51 12 	sts	0x1251, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER1_OVF_interrupt);
    3c92:	80 91 79 0f 	lds	r24, 0x0F79
    3c96:	90 91 7a 0f 	lds	r25, 0x0F7A
    3c9a:	89 2b       	or	r24, r25
    3c9c:	29 f0       	breq	.+10     	; 0x3ca8 <__vector_20+0x5e>
    3c9e:	e0 91 79 0f 	lds	r30, 0x0F79
    3ca2:	f0 91 7a 0f 	lds	r31, 0x0F7A
    3ca6:	09 95       	icall
}
    3ca8:	ff 91       	pop	r31
    3caa:	ef 91       	pop	r30
    3cac:	bf 91       	pop	r27
    3cae:	af 91       	pop	r26
    3cb0:	9f 91       	pop	r25
    3cb2:	8f 91       	pop	r24
    3cb4:	7f 91       	pop	r23
    3cb6:	6f 91       	pop	r22
    3cb8:	5f 91       	pop	r21
    3cba:	4f 91       	pop	r20
    3cbc:	3f 91       	pop	r19
    3cbe:	2f 91       	pop	r18
    3cc0:	0f 90       	pop	r0
    3cc2:	0f be       	out	0x3f, r0	; 63
    3cc4:	0f 90       	pop	r0
    3cc6:	1f 90       	pop	r1
    3cc8:	18 95       	reti

00003cca <__vector_15>:
ISR(TIMER2_OVF_vect) 
{
    3cca:	1f 92       	push	r1
    3ccc:	0f 92       	push	r0
    3cce:	0f b6       	in	r0, 0x3f	; 63
    3cd0:	0f 92       	push	r0
    3cd2:	11 24       	eor	r1, r1
    3cd4:	2f 93       	push	r18
    3cd6:	3f 93       	push	r19
    3cd8:	4f 93       	push	r20
    3cda:	5f 93       	push	r21
    3cdc:	6f 93       	push	r22
    3cde:	7f 93       	push	r23
    3ce0:	8f 93       	push	r24
    3ce2:	9f 93       	push	r25
    3ce4:	af 93       	push	r26
    3ce6:	bf 93       	push	r27
    3ce8:	ef 93       	push	r30
    3cea:	ff 93       	push	r31
  timer2_ovrflow_cnt++;
    3cec:	80 91 56 12 	lds	r24, 0x1256
    3cf0:	90 91 57 12 	lds	r25, 0x1257
    3cf4:	a0 91 58 12 	lds	r26, 0x1258
    3cf8:	b0 91 59 12 	lds	r27, 0x1259
    3cfc:	01 96       	adiw	r24, 0x01	; 1
    3cfe:	a1 1d       	adc	r26, r1
    3d00:	b1 1d       	adc	r27, r1
    3d02:	80 93 56 12 	sts	0x1256, r24
    3d06:	90 93 57 12 	sts	0x1257, r25
    3d0a:	a0 93 58 12 	sts	0x1258, r26
    3d0e:	b0 93 59 12 	sts	0x1259, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER2_OVF_interrupt);
    3d12:	80 91 7f 0f 	lds	r24, 0x0F7F
    3d16:	90 91 80 0f 	lds	r25, 0x0F80
    3d1a:	89 2b       	or	r24, r25
    3d1c:	29 f0       	breq	.+10     	; 0x3d28 <__vector_15+0x5e>
    3d1e:	e0 91 7f 0f 	lds	r30, 0x0F7F
    3d22:	f0 91 80 0f 	lds	r31, 0x0F80
    3d26:	09 95       	icall
}
    3d28:	ff 91       	pop	r31
    3d2a:	ef 91       	pop	r30
    3d2c:	bf 91       	pop	r27
    3d2e:	af 91       	pop	r26
    3d30:	9f 91       	pop	r25
    3d32:	8f 91       	pop	r24
    3d34:	7f 91       	pop	r23
    3d36:	6f 91       	pop	r22
    3d38:	5f 91       	pop	r21
    3d3a:	4f 91       	pop	r20
    3d3c:	3f 91       	pop	r19
    3d3e:	2f 91       	pop	r18
    3d40:	0f 90       	pop	r0
    3d42:	0f be       	out	0x3f, r0	; 63
    3d44:	0f 90       	pop	r0
    3d46:	1f 90       	pop	r1
    3d48:	18 95       	reti

00003d4a <__vector_35>:
ISR(TIMER3_OVF_vect) 
{
    3d4a:	1f 92       	push	r1
    3d4c:	0f 92       	push	r0
    3d4e:	0f b6       	in	r0, 0x3f	; 63
    3d50:	0f 92       	push	r0
    3d52:	11 24       	eor	r1, r1
    3d54:	2f 93       	push	r18
    3d56:	3f 93       	push	r19
    3d58:	4f 93       	push	r20
    3d5a:	5f 93       	push	r21
    3d5c:	6f 93       	push	r22
    3d5e:	7f 93       	push	r23
    3d60:	8f 93       	push	r24
    3d62:	9f 93       	push	r25
    3d64:	af 93       	push	r26
    3d66:	bf 93       	push	r27
    3d68:	ef 93       	push	r30
    3d6a:	ff 93       	push	r31
  timer3_ovrflow_cnt++;
    3d6c:	80 91 5e 12 	lds	r24, 0x125E
    3d70:	90 91 5f 12 	lds	r25, 0x125F
    3d74:	a0 91 60 12 	lds	r26, 0x1260
    3d78:	b0 91 61 12 	lds	r27, 0x1261
    3d7c:	01 96       	adiw	r24, 0x01	; 1
    3d7e:	a1 1d       	adc	r26, r1
    3d80:	b1 1d       	adc	r27, r1
    3d82:	80 93 5e 12 	sts	0x125E, r24
    3d86:	90 93 5f 12 	sts	0x125F, r25
    3d8a:	a0 93 60 12 	sts	0x1260, r26
    3d8e:	b0 93 61 12 	sts	0x1261, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER3_OVF_interrupt);
    3d92:	80 91 89 0f 	lds	r24, 0x0F89
    3d96:	90 91 8a 0f 	lds	r25, 0x0F8A
    3d9a:	89 2b       	or	r24, r25
    3d9c:	29 f0       	breq	.+10     	; 0x3da8 <__vector_35+0x5e>
    3d9e:	e0 91 89 0f 	lds	r30, 0x0F89
    3da2:	f0 91 8a 0f 	lds	r31, 0x0F8A
    3da6:	09 95       	icall
}
    3da8:	ff 91       	pop	r31
    3daa:	ef 91       	pop	r30
    3dac:	bf 91       	pop	r27
    3dae:	af 91       	pop	r26
    3db0:	9f 91       	pop	r25
    3db2:	8f 91       	pop	r24
    3db4:	7f 91       	pop	r23
    3db6:	6f 91       	pop	r22
    3db8:	5f 91       	pop	r21
    3dba:	4f 91       	pop	r20
    3dbc:	3f 91       	pop	r19
    3dbe:	2f 91       	pop	r18
    3dc0:	0f 90       	pop	r0
    3dc2:	0f be       	out	0x3f, r0	; 63
    3dc4:	0f 90       	pop	r0
    3dc6:	1f 90       	pop	r1
    3dc8:	18 95       	reti

00003dca <__vector_45>:
ISR(TIMER4_OVF_vect) 
{
    3dca:	1f 92       	push	r1
    3dcc:	0f 92       	push	r0
    3dce:	0f b6       	in	r0, 0x3f	; 63
    3dd0:	0f 92       	push	r0
    3dd2:	11 24       	eor	r1, r1
    3dd4:	2f 93       	push	r18
    3dd6:	3f 93       	push	r19
    3dd8:	4f 93       	push	r20
    3dda:	5f 93       	push	r21
    3ddc:	6f 93       	push	r22
    3dde:	7f 93       	push	r23
    3de0:	8f 93       	push	r24
    3de2:	9f 93       	push	r25
    3de4:	af 93       	push	r26
    3de6:	bf 93       	push	r27
    3de8:	ef 93       	push	r30
    3dea:	ff 93       	push	r31
  timer4_ovrflow_cnt++;
    3dec:	80 91 4a 12 	lds	r24, 0x124A
    3df0:	90 91 4b 12 	lds	r25, 0x124B
    3df4:	a0 91 4c 12 	lds	r26, 0x124C
    3df8:	b0 91 4d 12 	lds	r27, 0x124D
    3dfc:	01 96       	adiw	r24, 0x01	; 1
    3dfe:	a1 1d       	adc	r26, r1
    3e00:	b1 1d       	adc	r27, r1
    3e02:	80 93 4a 12 	sts	0x124A, r24
    3e06:	90 93 4b 12 	sts	0x124B, r25
    3e0a:	a0 93 4c 12 	sts	0x124C, r26
    3e0e:	b0 93 4d 12 	sts	0x124D, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER4_OVF_interrupt);
    3e12:	80 91 93 0f 	lds	r24, 0x0F93
    3e16:	90 91 94 0f 	lds	r25, 0x0F94
    3e1a:	89 2b       	or	r24, r25
    3e1c:	29 f0       	breq	.+10     	; 0x3e28 <__vector_45+0x5e>
    3e1e:	e0 91 93 0f 	lds	r30, 0x0F93
    3e22:	f0 91 94 0f 	lds	r31, 0x0F94
    3e26:	09 95       	icall
}
    3e28:	ff 91       	pop	r31
    3e2a:	ef 91       	pop	r30
    3e2c:	bf 91       	pop	r27
    3e2e:	af 91       	pop	r26
    3e30:	9f 91       	pop	r25
    3e32:	8f 91       	pop	r24
    3e34:	7f 91       	pop	r23
    3e36:	6f 91       	pop	r22
    3e38:	5f 91       	pop	r21
    3e3a:	4f 91       	pop	r20
    3e3c:	3f 91       	pop	r19
    3e3e:	2f 91       	pop	r18
    3e40:	0f 90       	pop	r0
    3e42:	0f be       	out	0x3f, r0	; 63
    3e44:	0f 90       	pop	r0
    3e46:	1f 90       	pop	r1
    3e48:	18 95       	reti

00003e4a <__vector_50>:
ISR(TIMER5_OVF_vect) 
{
    3e4a:	1f 92       	push	r1
    3e4c:	0f 92       	push	r0
    3e4e:	0f b6       	in	r0, 0x3f	; 63
    3e50:	0f 92       	push	r0
    3e52:	11 24       	eor	r1, r1
    3e54:	2f 93       	push	r18
    3e56:	3f 93       	push	r19
    3e58:	4f 93       	push	r20
    3e5a:	5f 93       	push	r21
    3e5c:	6f 93       	push	r22
    3e5e:	7f 93       	push	r23
    3e60:	8f 93       	push	r24
    3e62:	9f 93       	push	r25
    3e64:	af 93       	push	r26
    3e66:	bf 93       	push	r27
    3e68:	ef 93       	push	r30
    3e6a:	ff 93       	push	r31
  timer5_ovrflow_cnt++;
    3e6c:	80 91 62 12 	lds	r24, 0x1262
    3e70:	90 91 63 12 	lds	r25, 0x1263
    3e74:	a0 91 64 12 	lds	r26, 0x1264
    3e78:	b0 91 65 12 	lds	r27, 0x1265
    3e7c:	01 96       	adiw	r24, 0x01	; 1
    3e7e:	a1 1d       	adc	r26, r1
    3e80:	b1 1d       	adc	r27, r1
    3e82:	80 93 62 12 	sts	0x1262, r24
    3e86:	90 93 63 12 	sts	0x1263, r25
    3e8a:	a0 93 64 12 	sts	0x1264, r26
    3e8e:	b0 93 65 12 	sts	0x1265, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER5_OVF_interrupt);
    3e92:	80 91 9d 0f 	lds	r24, 0x0F9D
    3e96:	90 91 9e 0f 	lds	r25, 0x0F9E
    3e9a:	89 2b       	or	r24, r25
    3e9c:	29 f0       	breq	.+10     	; 0x3ea8 <__vector_50+0x5e>
    3e9e:	e0 91 9d 0f 	lds	r30, 0x0F9D
    3ea2:	f0 91 9e 0f 	lds	r31, 0x0F9E
    3ea6:	09 95       	icall
}
    3ea8:	ff 91       	pop	r31
    3eaa:	ef 91       	pop	r30
    3eac:	bf 91       	pop	r27
    3eae:	af 91       	pop	r26
    3eb0:	9f 91       	pop	r25
    3eb2:	8f 91       	pop	r24
    3eb4:	7f 91       	pop	r23
    3eb6:	6f 91       	pop	r22
    3eb8:	5f 91       	pop	r21
    3eba:	4f 91       	pop	r20
    3ebc:	3f 91       	pop	r19
    3ebe:	2f 91       	pop	r18
    3ec0:	0f 90       	pop	r0
    3ec2:	0f be       	out	0x3f, r0	; 63
    3ec4:	0f 90       	pop	r0
    3ec6:	1f 90       	pop	r1
    3ec8:	18 95       	reti

00003eca <__vector_21>:
ISR(TIMER0_COMPA_vect)
{
    3eca:	1f 92       	push	r1
    3ecc:	0f 92       	push	r0
    3ece:	0f b6       	in	r0, 0x3f	; 63
    3ed0:	0f 92       	push	r0
    3ed2:	11 24       	eor	r1, r1
    3ed4:	2f 93       	push	r18
    3ed6:	3f 93       	push	r19
    3ed8:	4f 93       	push	r20
    3eda:	5f 93       	push	r21
    3edc:	6f 93       	push	r22
    3ede:	7f 93       	push	r23
    3ee0:	8f 93       	push	r24
    3ee2:	9f 93       	push	r25
    3ee4:	af 93       	push	r26
    3ee6:	bf 93       	push	r27
    3ee8:	ef 93       	push	r30
    3eea:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER0_COMPA_interrupt);
    3eec:	80 91 6b 0f 	lds	r24, 0x0F6B
    3ef0:	90 91 6c 0f 	lds	r25, 0x0F6C
    3ef4:	89 2b       	or	r24, r25
    3ef6:	29 f0       	breq	.+10     	; 0x3f02 <__vector_21+0x38>
    3ef8:	e0 91 6b 0f 	lds	r30, 0x0F6B
    3efc:	f0 91 6c 0f 	lds	r31, 0x0F6C
    3f00:	09 95       	icall
}
    3f02:	ff 91       	pop	r31
    3f04:	ef 91       	pop	r30
    3f06:	bf 91       	pop	r27
    3f08:	af 91       	pop	r26
    3f0a:	9f 91       	pop	r25
    3f0c:	8f 91       	pop	r24
    3f0e:	7f 91       	pop	r23
    3f10:	6f 91       	pop	r22
    3f12:	5f 91       	pop	r21
    3f14:	4f 91       	pop	r20
    3f16:	3f 91       	pop	r19
    3f18:	2f 91       	pop	r18
    3f1a:	0f 90       	pop	r0
    3f1c:	0f be       	out	0x3f, r0	; 63
    3f1e:	0f 90       	pop	r0
    3f20:	1f 90       	pop	r1
    3f22:	18 95       	reti

00003f24 <__vector_22>:
ISR(TIMER0_COMPB_vect)
{
    3f24:	1f 92       	push	r1
    3f26:	0f 92       	push	r0
    3f28:	0f b6       	in	r0, 0x3f	; 63
    3f2a:	0f 92       	push	r0
    3f2c:	11 24       	eor	r1, r1
    3f2e:	2f 93       	push	r18
    3f30:	3f 93       	push	r19
    3f32:	4f 93       	push	r20
    3f34:	5f 93       	push	r21
    3f36:	6f 93       	push	r22
    3f38:	7f 93       	push	r23
    3f3a:	8f 93       	push	r24
    3f3c:	9f 93       	push	r25
    3f3e:	af 93       	push	r26
    3f40:	bf 93       	push	r27
    3f42:	ef 93       	push	r30
    3f44:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER0_COMPB_interrupt);
    3f46:	80 91 6d 0f 	lds	r24, 0x0F6D
    3f4a:	90 91 6e 0f 	lds	r25, 0x0F6E
    3f4e:	89 2b       	or	r24, r25
    3f50:	29 f0       	breq	.+10     	; 0x3f5c <__vector_22+0x38>
    3f52:	e0 91 6d 0f 	lds	r30, 0x0F6D
    3f56:	f0 91 6e 0f 	lds	r31, 0x0F6E
    3f5a:	09 95       	icall
}
    3f5c:	ff 91       	pop	r31
    3f5e:	ef 91       	pop	r30
    3f60:	bf 91       	pop	r27
    3f62:	af 91       	pop	r26
    3f64:	9f 91       	pop	r25
    3f66:	8f 91       	pop	r24
    3f68:	7f 91       	pop	r23
    3f6a:	6f 91       	pop	r22
    3f6c:	5f 91       	pop	r21
    3f6e:	4f 91       	pop	r20
    3f70:	3f 91       	pop	r19
    3f72:	2f 91       	pop	r18
    3f74:	0f 90       	pop	r0
    3f76:	0f be       	out	0x3f, r0	; 63
    3f78:	0f 90       	pop	r0
    3f7a:	1f 90       	pop	r1
    3f7c:	18 95       	reti

00003f7e <__vector_16>:
ISR(TIMER1_CAPT_vect)
{
    3f7e:	1f 92       	push	r1
    3f80:	0f 92       	push	r0
    3f82:	0f b6       	in	r0, 0x3f	; 63
    3f84:	0f 92       	push	r0
    3f86:	11 24       	eor	r1, r1
    3f88:	2f 93       	push	r18
    3f8a:	3f 93       	push	r19
    3f8c:	4f 93       	push	r20
    3f8e:	5f 93       	push	r21
    3f90:	6f 93       	push	r22
    3f92:	7f 93       	push	r23
    3f94:	8f 93       	push	r24
    3f96:	9f 93       	push	r25
    3f98:	af 93       	push	r26
    3f9a:	bf 93       	push	r27
    3f9c:	ef 93       	push	r30
    3f9e:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER1_CAPT_interrupt);
    3fa0:	80 91 71 0f 	lds	r24, 0x0F71
    3fa4:	90 91 72 0f 	lds	r25, 0x0F72
    3fa8:	89 2b       	or	r24, r25
    3faa:	29 f0       	breq	.+10     	; 0x3fb6 <__vector_16+0x38>
    3fac:	e0 91 71 0f 	lds	r30, 0x0F71
    3fb0:	f0 91 72 0f 	lds	r31, 0x0F72
    3fb4:	09 95       	icall
}
    3fb6:	ff 91       	pop	r31
    3fb8:	ef 91       	pop	r30
    3fba:	bf 91       	pop	r27
    3fbc:	af 91       	pop	r26
    3fbe:	9f 91       	pop	r25
    3fc0:	8f 91       	pop	r24
    3fc2:	7f 91       	pop	r23
    3fc4:	6f 91       	pop	r22
    3fc6:	5f 91       	pop	r21
    3fc8:	4f 91       	pop	r20
    3fca:	3f 91       	pop	r19
    3fcc:	2f 91       	pop	r18
    3fce:	0f 90       	pop	r0
    3fd0:	0f be       	out	0x3f, r0	; 63
    3fd2:	0f 90       	pop	r0
    3fd4:	1f 90       	pop	r1
    3fd6:	18 95       	reti

00003fd8 <__vector_18>:
{
  RUN_USER_DEFINE_INTERRUPT(TIMER1_COMPA_interrupt);
}
*/
ISR(TIMER1_COMPB_vect)
{
    3fd8:	1f 92       	push	r1
    3fda:	0f 92       	push	r0
    3fdc:	0f b6       	in	r0, 0x3f	; 63
    3fde:	0f 92       	push	r0
    3fe0:	11 24       	eor	r1, r1
    3fe2:	2f 93       	push	r18
    3fe4:	3f 93       	push	r19
    3fe6:	4f 93       	push	r20
    3fe8:	5f 93       	push	r21
    3fea:	6f 93       	push	r22
    3fec:	7f 93       	push	r23
    3fee:	8f 93       	push	r24
    3ff0:	9f 93       	push	r25
    3ff2:	af 93       	push	r26
    3ff4:	bf 93       	push	r27
    3ff6:	ef 93       	push	r30
    3ff8:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER1_COMPB_interrupt);
    3ffa:	80 91 75 0f 	lds	r24, 0x0F75
    3ffe:	90 91 76 0f 	lds	r25, 0x0F76
    4002:	89 2b       	or	r24, r25
    4004:	29 f0       	breq	.+10     	; 0x4010 <__vector_18+0x38>
    4006:	e0 91 75 0f 	lds	r30, 0x0F75
    400a:	f0 91 76 0f 	lds	r31, 0x0F76
    400e:	09 95       	icall
}
    4010:	ff 91       	pop	r31
    4012:	ef 91       	pop	r30
    4014:	bf 91       	pop	r27
    4016:	af 91       	pop	r26
    4018:	9f 91       	pop	r25
    401a:	8f 91       	pop	r24
    401c:	7f 91       	pop	r23
    401e:	6f 91       	pop	r22
    4020:	5f 91       	pop	r21
    4022:	4f 91       	pop	r20
    4024:	3f 91       	pop	r19
    4026:	2f 91       	pop	r18
    4028:	0f 90       	pop	r0
    402a:	0f be       	out	0x3f, r0	; 63
    402c:	0f 90       	pop	r0
    402e:	1f 90       	pop	r1
    4030:	18 95       	reti

00004032 <__vector_19>:
ISR(TIMER1_COMPC_vect)
{
    4032:	1f 92       	push	r1
    4034:	0f 92       	push	r0
    4036:	0f b6       	in	r0, 0x3f	; 63
    4038:	0f 92       	push	r0
    403a:	11 24       	eor	r1, r1
    403c:	2f 93       	push	r18
    403e:	3f 93       	push	r19
    4040:	4f 93       	push	r20
    4042:	5f 93       	push	r21
    4044:	6f 93       	push	r22
    4046:	7f 93       	push	r23
    4048:	8f 93       	push	r24
    404a:	9f 93       	push	r25
    404c:	af 93       	push	r26
    404e:	bf 93       	push	r27
    4050:	ef 93       	push	r30
    4052:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER1_COMPC_interrupt);
    4054:	80 91 77 0f 	lds	r24, 0x0F77
    4058:	90 91 78 0f 	lds	r25, 0x0F78
    405c:	89 2b       	or	r24, r25
    405e:	29 f0       	breq	.+10     	; 0x406a <__vector_19+0x38>
    4060:	e0 91 77 0f 	lds	r30, 0x0F77
    4064:	f0 91 78 0f 	lds	r31, 0x0F78
    4068:	09 95       	icall
}
    406a:	ff 91       	pop	r31
    406c:	ef 91       	pop	r30
    406e:	bf 91       	pop	r27
    4070:	af 91       	pop	r26
    4072:	9f 91       	pop	r25
    4074:	8f 91       	pop	r24
    4076:	7f 91       	pop	r23
    4078:	6f 91       	pop	r22
    407a:	5f 91       	pop	r21
    407c:	4f 91       	pop	r20
    407e:	3f 91       	pop	r19
    4080:	2f 91       	pop	r18
    4082:	0f 90       	pop	r0
    4084:	0f be       	out	0x3f, r0	; 63
    4086:	0f 90       	pop	r0
    4088:	1f 90       	pop	r1
    408a:	18 95       	reti

0000408c <__vector_13>:
ISR(TIMER2_COMPA_vect)
{
    408c:	1f 92       	push	r1
    408e:	0f 92       	push	r0
    4090:	0f b6       	in	r0, 0x3f	; 63
    4092:	0f 92       	push	r0
    4094:	11 24       	eor	r1, r1
    4096:	2f 93       	push	r18
    4098:	3f 93       	push	r19
    409a:	4f 93       	push	r20
    409c:	5f 93       	push	r21
    409e:	6f 93       	push	r22
    40a0:	7f 93       	push	r23
    40a2:	8f 93       	push	r24
    40a4:	9f 93       	push	r25
    40a6:	af 93       	push	r26
    40a8:	bf 93       	push	r27
    40aa:	ef 93       	push	r30
    40ac:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER2_COMPA_interrupt);
    40ae:	80 91 7b 0f 	lds	r24, 0x0F7B
    40b2:	90 91 7c 0f 	lds	r25, 0x0F7C
    40b6:	89 2b       	or	r24, r25
    40b8:	29 f0       	breq	.+10     	; 0x40c4 <__vector_13+0x38>
    40ba:	e0 91 7b 0f 	lds	r30, 0x0F7B
    40be:	f0 91 7c 0f 	lds	r31, 0x0F7C
    40c2:	09 95       	icall
}
    40c4:	ff 91       	pop	r31
    40c6:	ef 91       	pop	r30
    40c8:	bf 91       	pop	r27
    40ca:	af 91       	pop	r26
    40cc:	9f 91       	pop	r25
    40ce:	8f 91       	pop	r24
    40d0:	7f 91       	pop	r23
    40d2:	6f 91       	pop	r22
    40d4:	5f 91       	pop	r21
    40d6:	4f 91       	pop	r20
    40d8:	3f 91       	pop	r19
    40da:	2f 91       	pop	r18
    40dc:	0f 90       	pop	r0
    40de:	0f be       	out	0x3f, r0	; 63
    40e0:	0f 90       	pop	r0
    40e2:	1f 90       	pop	r1
    40e4:	18 95       	reti

000040e6 <__vector_14>:
ISR(TIMER2_COMPB_vect)
{
    40e6:	1f 92       	push	r1
    40e8:	0f 92       	push	r0
    40ea:	0f b6       	in	r0, 0x3f	; 63
    40ec:	0f 92       	push	r0
    40ee:	11 24       	eor	r1, r1
    40f0:	2f 93       	push	r18
    40f2:	3f 93       	push	r19
    40f4:	4f 93       	push	r20
    40f6:	5f 93       	push	r21
    40f8:	6f 93       	push	r22
    40fa:	7f 93       	push	r23
    40fc:	8f 93       	push	r24
    40fe:	9f 93       	push	r25
    4100:	af 93       	push	r26
    4102:	bf 93       	push	r27
    4104:	ef 93       	push	r30
    4106:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER2_COMPB_interrupt);
    4108:	80 91 7d 0f 	lds	r24, 0x0F7D
    410c:	90 91 7e 0f 	lds	r25, 0x0F7E
    4110:	89 2b       	or	r24, r25
    4112:	29 f0       	breq	.+10     	; 0x411e <__vector_14+0x38>
    4114:	e0 91 7d 0f 	lds	r30, 0x0F7D
    4118:	f0 91 7e 0f 	lds	r31, 0x0F7E
    411c:	09 95       	icall
}
    411e:	ff 91       	pop	r31
    4120:	ef 91       	pop	r30
    4122:	bf 91       	pop	r27
    4124:	af 91       	pop	r26
    4126:	9f 91       	pop	r25
    4128:	8f 91       	pop	r24
    412a:	7f 91       	pop	r23
    412c:	6f 91       	pop	r22
    412e:	5f 91       	pop	r21
    4130:	4f 91       	pop	r20
    4132:	3f 91       	pop	r19
    4134:	2f 91       	pop	r18
    4136:	0f 90       	pop	r0
    4138:	0f be       	out	0x3f, r0	; 63
    413a:	0f 90       	pop	r0
    413c:	1f 90       	pop	r1
    413e:	18 95       	reti

00004140 <__vector_31>:
ISR(TIMER3_CAPT_vect)
{
    4140:	1f 92       	push	r1
    4142:	0f 92       	push	r0
    4144:	0f b6       	in	r0, 0x3f	; 63
    4146:	0f 92       	push	r0
    4148:	11 24       	eor	r1, r1
    414a:	2f 93       	push	r18
    414c:	3f 93       	push	r19
    414e:	4f 93       	push	r20
    4150:	5f 93       	push	r21
    4152:	6f 93       	push	r22
    4154:	7f 93       	push	r23
    4156:	8f 93       	push	r24
    4158:	9f 93       	push	r25
    415a:	af 93       	push	r26
    415c:	bf 93       	push	r27
    415e:	ef 93       	push	r30
    4160:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_CAPT_interrupt);
    4162:	80 91 81 0f 	lds	r24, 0x0F81
    4166:	90 91 82 0f 	lds	r25, 0x0F82
    416a:	89 2b       	or	r24, r25
    416c:	29 f0       	breq	.+10     	; 0x4178 <__vector_31+0x38>
    416e:	e0 91 81 0f 	lds	r30, 0x0F81
    4172:	f0 91 82 0f 	lds	r31, 0x0F82
    4176:	09 95       	icall
}
    4178:	ff 91       	pop	r31
    417a:	ef 91       	pop	r30
    417c:	bf 91       	pop	r27
    417e:	af 91       	pop	r26
    4180:	9f 91       	pop	r25
    4182:	8f 91       	pop	r24
    4184:	7f 91       	pop	r23
    4186:	6f 91       	pop	r22
    4188:	5f 91       	pop	r21
    418a:	4f 91       	pop	r20
    418c:	3f 91       	pop	r19
    418e:	2f 91       	pop	r18
    4190:	0f 90       	pop	r0
    4192:	0f be       	out	0x3f, r0	; 63
    4194:	0f 90       	pop	r0
    4196:	1f 90       	pop	r1
    4198:	18 95       	reti

0000419a <__vector_32>:
ISR(TIMER3_COMPA_vect)
{
    419a:	1f 92       	push	r1
    419c:	0f 92       	push	r0
    419e:	0f b6       	in	r0, 0x3f	; 63
    41a0:	0f 92       	push	r0
    41a2:	11 24       	eor	r1, r1
    41a4:	2f 93       	push	r18
    41a6:	3f 93       	push	r19
    41a8:	4f 93       	push	r20
    41aa:	5f 93       	push	r21
    41ac:	6f 93       	push	r22
    41ae:	7f 93       	push	r23
    41b0:	8f 93       	push	r24
    41b2:	9f 93       	push	r25
    41b4:	af 93       	push	r26
    41b6:	bf 93       	push	r27
    41b8:	ef 93       	push	r30
    41ba:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_COMPA_interrupt);
    41bc:	80 91 83 0f 	lds	r24, 0x0F83
    41c0:	90 91 84 0f 	lds	r25, 0x0F84
    41c4:	89 2b       	or	r24, r25
    41c6:	29 f0       	breq	.+10     	; 0x41d2 <__vector_32+0x38>
    41c8:	e0 91 83 0f 	lds	r30, 0x0F83
    41cc:	f0 91 84 0f 	lds	r31, 0x0F84
    41d0:	09 95       	icall
}
    41d2:	ff 91       	pop	r31
    41d4:	ef 91       	pop	r30
    41d6:	bf 91       	pop	r27
    41d8:	af 91       	pop	r26
    41da:	9f 91       	pop	r25
    41dc:	8f 91       	pop	r24
    41de:	7f 91       	pop	r23
    41e0:	6f 91       	pop	r22
    41e2:	5f 91       	pop	r21
    41e4:	4f 91       	pop	r20
    41e6:	3f 91       	pop	r19
    41e8:	2f 91       	pop	r18
    41ea:	0f 90       	pop	r0
    41ec:	0f be       	out	0x3f, r0	; 63
    41ee:	0f 90       	pop	r0
    41f0:	1f 90       	pop	r1
    41f2:	18 95       	reti

000041f4 <__vector_33>:
ISR(TIMER3_COMPB_vect)
{
    41f4:	1f 92       	push	r1
    41f6:	0f 92       	push	r0
    41f8:	0f b6       	in	r0, 0x3f	; 63
    41fa:	0f 92       	push	r0
    41fc:	11 24       	eor	r1, r1
    41fe:	2f 93       	push	r18
    4200:	3f 93       	push	r19
    4202:	4f 93       	push	r20
    4204:	5f 93       	push	r21
    4206:	6f 93       	push	r22
    4208:	7f 93       	push	r23
    420a:	8f 93       	push	r24
    420c:	9f 93       	push	r25
    420e:	af 93       	push	r26
    4210:	bf 93       	push	r27
    4212:	ef 93       	push	r30
    4214:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_COMPB_interrupt);
    4216:	80 91 85 0f 	lds	r24, 0x0F85
    421a:	90 91 86 0f 	lds	r25, 0x0F86
    421e:	89 2b       	or	r24, r25
    4220:	29 f0       	breq	.+10     	; 0x422c <__vector_33+0x38>
    4222:	e0 91 85 0f 	lds	r30, 0x0F85
    4226:	f0 91 86 0f 	lds	r31, 0x0F86
    422a:	09 95       	icall
}
    422c:	ff 91       	pop	r31
    422e:	ef 91       	pop	r30
    4230:	bf 91       	pop	r27
    4232:	af 91       	pop	r26
    4234:	9f 91       	pop	r25
    4236:	8f 91       	pop	r24
    4238:	7f 91       	pop	r23
    423a:	6f 91       	pop	r22
    423c:	5f 91       	pop	r21
    423e:	4f 91       	pop	r20
    4240:	3f 91       	pop	r19
    4242:	2f 91       	pop	r18
    4244:	0f 90       	pop	r0
    4246:	0f be       	out	0x3f, r0	; 63
    4248:	0f 90       	pop	r0
    424a:	1f 90       	pop	r1
    424c:	18 95       	reti

0000424e <__vector_34>:
ISR(TIMER3_COMPC_vect)
{
    424e:	1f 92       	push	r1
    4250:	0f 92       	push	r0
    4252:	0f b6       	in	r0, 0x3f	; 63
    4254:	0f 92       	push	r0
    4256:	11 24       	eor	r1, r1
    4258:	2f 93       	push	r18
    425a:	3f 93       	push	r19
    425c:	4f 93       	push	r20
    425e:	5f 93       	push	r21
    4260:	6f 93       	push	r22
    4262:	7f 93       	push	r23
    4264:	8f 93       	push	r24
    4266:	9f 93       	push	r25
    4268:	af 93       	push	r26
    426a:	bf 93       	push	r27
    426c:	ef 93       	push	r30
    426e:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_COMPC_interrupt);
    4270:	80 91 87 0f 	lds	r24, 0x0F87
    4274:	90 91 88 0f 	lds	r25, 0x0F88
    4278:	89 2b       	or	r24, r25
    427a:	29 f0       	breq	.+10     	; 0x4286 <__vector_34+0x38>
    427c:	e0 91 87 0f 	lds	r30, 0x0F87
    4280:	f0 91 88 0f 	lds	r31, 0x0F88
    4284:	09 95       	icall
}
    4286:	ff 91       	pop	r31
    4288:	ef 91       	pop	r30
    428a:	bf 91       	pop	r27
    428c:	af 91       	pop	r26
    428e:	9f 91       	pop	r25
    4290:	8f 91       	pop	r24
    4292:	7f 91       	pop	r23
    4294:	6f 91       	pop	r22
    4296:	5f 91       	pop	r21
    4298:	4f 91       	pop	r20
    429a:	3f 91       	pop	r19
    429c:	2f 91       	pop	r18
    429e:	0f 90       	pop	r0
    42a0:	0f be       	out	0x3f, r0	; 63
    42a2:	0f 90       	pop	r0
    42a4:	1f 90       	pop	r1
    42a6:	18 95       	reti

000042a8 <__vector_41>:
ISR(TIMER4_CAPT_vect)
{
    42a8:	1f 92       	push	r1
    42aa:	0f 92       	push	r0
    42ac:	0f b6       	in	r0, 0x3f	; 63
    42ae:	0f 92       	push	r0
    42b0:	11 24       	eor	r1, r1
    42b2:	2f 93       	push	r18
    42b4:	3f 93       	push	r19
    42b6:	4f 93       	push	r20
    42b8:	5f 93       	push	r21
    42ba:	6f 93       	push	r22
    42bc:	7f 93       	push	r23
    42be:	8f 93       	push	r24
    42c0:	9f 93       	push	r25
    42c2:	af 93       	push	r26
    42c4:	bf 93       	push	r27
    42c6:	ef 93       	push	r30
    42c8:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_CAPT_interrupt);
    42ca:	80 91 8b 0f 	lds	r24, 0x0F8B
    42ce:	90 91 8c 0f 	lds	r25, 0x0F8C
    42d2:	89 2b       	or	r24, r25
    42d4:	29 f0       	breq	.+10     	; 0x42e0 <__vector_41+0x38>
    42d6:	e0 91 8b 0f 	lds	r30, 0x0F8B
    42da:	f0 91 8c 0f 	lds	r31, 0x0F8C
    42de:	09 95       	icall
}
    42e0:	ff 91       	pop	r31
    42e2:	ef 91       	pop	r30
    42e4:	bf 91       	pop	r27
    42e6:	af 91       	pop	r26
    42e8:	9f 91       	pop	r25
    42ea:	8f 91       	pop	r24
    42ec:	7f 91       	pop	r23
    42ee:	6f 91       	pop	r22
    42f0:	5f 91       	pop	r21
    42f2:	4f 91       	pop	r20
    42f4:	3f 91       	pop	r19
    42f6:	2f 91       	pop	r18
    42f8:	0f 90       	pop	r0
    42fa:	0f be       	out	0x3f, r0	; 63
    42fc:	0f 90       	pop	r0
    42fe:	1f 90       	pop	r1
    4300:	18 95       	reti

00004302 <__vector_42>:
ISR(TIMER4_COMPA_vect)
{
    4302:	1f 92       	push	r1
    4304:	0f 92       	push	r0
    4306:	0f b6       	in	r0, 0x3f	; 63
    4308:	0f 92       	push	r0
    430a:	11 24       	eor	r1, r1
    430c:	2f 93       	push	r18
    430e:	3f 93       	push	r19
    4310:	4f 93       	push	r20
    4312:	5f 93       	push	r21
    4314:	6f 93       	push	r22
    4316:	7f 93       	push	r23
    4318:	8f 93       	push	r24
    431a:	9f 93       	push	r25
    431c:	af 93       	push	r26
    431e:	bf 93       	push	r27
    4320:	ef 93       	push	r30
    4322:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_COMPA_interrupt);
    4324:	80 91 8d 0f 	lds	r24, 0x0F8D
    4328:	90 91 8e 0f 	lds	r25, 0x0F8E
    432c:	89 2b       	or	r24, r25
    432e:	29 f0       	breq	.+10     	; 0x433a <__vector_42+0x38>
    4330:	e0 91 8d 0f 	lds	r30, 0x0F8D
    4334:	f0 91 8e 0f 	lds	r31, 0x0F8E
    4338:	09 95       	icall
}
    433a:	ff 91       	pop	r31
    433c:	ef 91       	pop	r30
    433e:	bf 91       	pop	r27
    4340:	af 91       	pop	r26
    4342:	9f 91       	pop	r25
    4344:	8f 91       	pop	r24
    4346:	7f 91       	pop	r23
    4348:	6f 91       	pop	r22
    434a:	5f 91       	pop	r21
    434c:	4f 91       	pop	r20
    434e:	3f 91       	pop	r19
    4350:	2f 91       	pop	r18
    4352:	0f 90       	pop	r0
    4354:	0f be       	out	0x3f, r0	; 63
    4356:	0f 90       	pop	r0
    4358:	1f 90       	pop	r1
    435a:	18 95       	reti

0000435c <__vector_43>:
ISR(TIMER4_COMPB_vect)
{
    435c:	1f 92       	push	r1
    435e:	0f 92       	push	r0
    4360:	0f b6       	in	r0, 0x3f	; 63
    4362:	0f 92       	push	r0
    4364:	11 24       	eor	r1, r1
    4366:	2f 93       	push	r18
    4368:	3f 93       	push	r19
    436a:	4f 93       	push	r20
    436c:	5f 93       	push	r21
    436e:	6f 93       	push	r22
    4370:	7f 93       	push	r23
    4372:	8f 93       	push	r24
    4374:	9f 93       	push	r25
    4376:	af 93       	push	r26
    4378:	bf 93       	push	r27
    437a:	ef 93       	push	r30
    437c:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_COMPB_interrupt);
    437e:	80 91 8f 0f 	lds	r24, 0x0F8F
    4382:	90 91 90 0f 	lds	r25, 0x0F90
    4386:	89 2b       	or	r24, r25
    4388:	29 f0       	breq	.+10     	; 0x4394 <__vector_43+0x38>
    438a:	e0 91 8f 0f 	lds	r30, 0x0F8F
    438e:	f0 91 90 0f 	lds	r31, 0x0F90
    4392:	09 95       	icall
}
    4394:	ff 91       	pop	r31
    4396:	ef 91       	pop	r30
    4398:	bf 91       	pop	r27
    439a:	af 91       	pop	r26
    439c:	9f 91       	pop	r25
    439e:	8f 91       	pop	r24
    43a0:	7f 91       	pop	r23
    43a2:	6f 91       	pop	r22
    43a4:	5f 91       	pop	r21
    43a6:	4f 91       	pop	r20
    43a8:	3f 91       	pop	r19
    43aa:	2f 91       	pop	r18
    43ac:	0f 90       	pop	r0
    43ae:	0f be       	out	0x3f, r0	; 63
    43b0:	0f 90       	pop	r0
    43b2:	1f 90       	pop	r1
    43b4:	18 95       	reti

000043b6 <__vector_44>:
ISR(TIMER4_COMPC_vect)
{
    43b6:	1f 92       	push	r1
    43b8:	0f 92       	push	r0
    43ba:	0f b6       	in	r0, 0x3f	; 63
    43bc:	0f 92       	push	r0
    43be:	11 24       	eor	r1, r1
    43c0:	2f 93       	push	r18
    43c2:	3f 93       	push	r19
    43c4:	4f 93       	push	r20
    43c6:	5f 93       	push	r21
    43c8:	6f 93       	push	r22
    43ca:	7f 93       	push	r23
    43cc:	8f 93       	push	r24
    43ce:	9f 93       	push	r25
    43d0:	af 93       	push	r26
    43d2:	bf 93       	push	r27
    43d4:	ef 93       	push	r30
    43d6:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_COMPC_interrupt);
    43d8:	80 91 91 0f 	lds	r24, 0x0F91
    43dc:	90 91 92 0f 	lds	r25, 0x0F92
    43e0:	89 2b       	or	r24, r25
    43e2:	29 f0       	breq	.+10     	; 0x43ee <__vector_44+0x38>
    43e4:	e0 91 91 0f 	lds	r30, 0x0F91
    43e8:	f0 91 92 0f 	lds	r31, 0x0F92
    43ec:	09 95       	icall
}
    43ee:	ff 91       	pop	r31
    43f0:	ef 91       	pop	r30
    43f2:	bf 91       	pop	r27
    43f4:	af 91       	pop	r26
    43f6:	9f 91       	pop	r25
    43f8:	8f 91       	pop	r24
    43fa:	7f 91       	pop	r23
    43fc:	6f 91       	pop	r22
    43fe:	5f 91       	pop	r21
    4400:	4f 91       	pop	r20
    4402:	3f 91       	pop	r19
    4404:	2f 91       	pop	r18
    4406:	0f 90       	pop	r0
    4408:	0f be       	out	0x3f, r0	; 63
    440a:	0f 90       	pop	r0
    440c:	1f 90       	pop	r1
    440e:	18 95       	reti

00004410 <__vector_46>:
ISR(TIMER5_CAPT_vect)
{
    4410:	1f 92       	push	r1
    4412:	0f 92       	push	r0
    4414:	0f b6       	in	r0, 0x3f	; 63
    4416:	0f 92       	push	r0
    4418:	11 24       	eor	r1, r1
    441a:	2f 93       	push	r18
    441c:	3f 93       	push	r19
    441e:	4f 93       	push	r20
    4420:	5f 93       	push	r21
    4422:	6f 93       	push	r22
    4424:	7f 93       	push	r23
    4426:	8f 93       	push	r24
    4428:	9f 93       	push	r25
    442a:	af 93       	push	r26
    442c:	bf 93       	push	r27
    442e:	ef 93       	push	r30
    4430:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_CAPT_interrupt);
    4432:	80 91 95 0f 	lds	r24, 0x0F95
    4436:	90 91 96 0f 	lds	r25, 0x0F96
    443a:	89 2b       	or	r24, r25
    443c:	29 f0       	breq	.+10     	; 0x4448 <__vector_46+0x38>
    443e:	e0 91 95 0f 	lds	r30, 0x0F95
    4442:	f0 91 96 0f 	lds	r31, 0x0F96
    4446:	09 95       	icall
}
    4448:	ff 91       	pop	r31
    444a:	ef 91       	pop	r30
    444c:	bf 91       	pop	r27
    444e:	af 91       	pop	r26
    4450:	9f 91       	pop	r25
    4452:	8f 91       	pop	r24
    4454:	7f 91       	pop	r23
    4456:	6f 91       	pop	r22
    4458:	5f 91       	pop	r21
    445a:	4f 91       	pop	r20
    445c:	3f 91       	pop	r19
    445e:	2f 91       	pop	r18
    4460:	0f 90       	pop	r0
    4462:	0f be       	out	0x3f, r0	; 63
    4464:	0f 90       	pop	r0
    4466:	1f 90       	pop	r1
    4468:	18 95       	reti

0000446a <__vector_47>:
ISR(TIMER5_COMPA_vect)
{
    446a:	1f 92       	push	r1
    446c:	0f 92       	push	r0
    446e:	0f b6       	in	r0, 0x3f	; 63
    4470:	0f 92       	push	r0
    4472:	11 24       	eor	r1, r1
    4474:	2f 93       	push	r18
    4476:	3f 93       	push	r19
    4478:	4f 93       	push	r20
    447a:	5f 93       	push	r21
    447c:	6f 93       	push	r22
    447e:	7f 93       	push	r23
    4480:	8f 93       	push	r24
    4482:	9f 93       	push	r25
    4484:	af 93       	push	r26
    4486:	bf 93       	push	r27
    4488:	ef 93       	push	r30
    448a:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_COMPA_interrupt);
    448c:	80 91 97 0f 	lds	r24, 0x0F97
    4490:	90 91 98 0f 	lds	r25, 0x0F98
    4494:	89 2b       	or	r24, r25
    4496:	29 f0       	breq	.+10     	; 0x44a2 <__vector_47+0x38>
    4498:	e0 91 97 0f 	lds	r30, 0x0F97
    449c:	f0 91 98 0f 	lds	r31, 0x0F98
    44a0:	09 95       	icall
}
    44a2:	ff 91       	pop	r31
    44a4:	ef 91       	pop	r30
    44a6:	bf 91       	pop	r27
    44a8:	af 91       	pop	r26
    44aa:	9f 91       	pop	r25
    44ac:	8f 91       	pop	r24
    44ae:	7f 91       	pop	r23
    44b0:	6f 91       	pop	r22
    44b2:	5f 91       	pop	r21
    44b4:	4f 91       	pop	r20
    44b6:	3f 91       	pop	r19
    44b8:	2f 91       	pop	r18
    44ba:	0f 90       	pop	r0
    44bc:	0f be       	out	0x3f, r0	; 63
    44be:	0f 90       	pop	r0
    44c0:	1f 90       	pop	r1
    44c2:	18 95       	reti

000044c4 <__vector_48>:
ISR(TIMER5_COMPB_vect)
{
    44c4:	1f 92       	push	r1
    44c6:	0f 92       	push	r0
    44c8:	0f b6       	in	r0, 0x3f	; 63
    44ca:	0f 92       	push	r0
    44cc:	11 24       	eor	r1, r1
    44ce:	2f 93       	push	r18
    44d0:	3f 93       	push	r19
    44d2:	4f 93       	push	r20
    44d4:	5f 93       	push	r21
    44d6:	6f 93       	push	r22
    44d8:	7f 93       	push	r23
    44da:	8f 93       	push	r24
    44dc:	9f 93       	push	r25
    44de:	af 93       	push	r26
    44e0:	bf 93       	push	r27
    44e2:	ef 93       	push	r30
    44e4:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_COMPB_interrupt);
    44e6:	80 91 99 0f 	lds	r24, 0x0F99
    44ea:	90 91 9a 0f 	lds	r25, 0x0F9A
    44ee:	89 2b       	or	r24, r25
    44f0:	29 f0       	breq	.+10     	; 0x44fc <__vector_48+0x38>
    44f2:	e0 91 99 0f 	lds	r30, 0x0F99
    44f6:	f0 91 9a 0f 	lds	r31, 0x0F9A
    44fa:	09 95       	icall
}
    44fc:	ff 91       	pop	r31
    44fe:	ef 91       	pop	r30
    4500:	bf 91       	pop	r27
    4502:	af 91       	pop	r26
    4504:	9f 91       	pop	r25
    4506:	8f 91       	pop	r24
    4508:	7f 91       	pop	r23
    450a:	6f 91       	pop	r22
    450c:	5f 91       	pop	r21
    450e:	4f 91       	pop	r20
    4510:	3f 91       	pop	r19
    4512:	2f 91       	pop	r18
    4514:	0f 90       	pop	r0
    4516:	0f be       	out	0x3f, r0	; 63
    4518:	0f 90       	pop	r0
    451a:	1f 90       	pop	r1
    451c:	18 95       	reti

0000451e <__vector_49>:
ISR(TIMER5_COMPC_vect)
{
    451e:	1f 92       	push	r1
    4520:	0f 92       	push	r0
    4522:	0f b6       	in	r0, 0x3f	; 63
    4524:	0f 92       	push	r0
    4526:	11 24       	eor	r1, r1
    4528:	2f 93       	push	r18
    452a:	3f 93       	push	r19
    452c:	4f 93       	push	r20
    452e:	5f 93       	push	r21
    4530:	6f 93       	push	r22
    4532:	7f 93       	push	r23
    4534:	8f 93       	push	r24
    4536:	9f 93       	push	r25
    4538:	af 93       	push	r26
    453a:	bf 93       	push	r27
    453c:	ef 93       	push	r30
    453e:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_COMPC_interrupt);
    4540:	80 91 9b 0f 	lds	r24, 0x0F9B
    4544:	90 91 9c 0f 	lds	r25, 0x0F9C
    4548:	89 2b       	or	r24, r25
    454a:	29 f0       	breq	.+10     	; 0x4556 <__vector_49+0x38>
    454c:	e0 91 9b 0f 	lds	r30, 0x0F9B
    4550:	f0 91 9c 0f 	lds	r31, 0x0F9C
    4554:	09 95       	icall
}
    4556:	ff 91       	pop	r31
    4558:	ef 91       	pop	r30
    455a:	bf 91       	pop	r27
    455c:	af 91       	pop	r26
    455e:	9f 91       	pop	r25
    4560:	8f 91       	pop	r24
    4562:	7f 91       	pop	r23
    4564:	6f 91       	pop	r22
    4566:	5f 91       	pop	r21
    4568:	4f 91       	pop	r20
    456a:	3f 91       	pop	r19
    456c:	2f 91       	pop	r18
    456e:	0f 90       	pop	r0
    4570:	0f be       	out	0x3f, r0	; 63
    4572:	0f 90       	pop	r0
    4574:	1f 90       	pop	r1
    4576:	18 95       	reti

00004578 <__vector_default>:

ISR(BADISR_vect)
{
    4578:	1f 92       	push	r1
    457a:	0f 92       	push	r0
    457c:	0f b6       	in	r0, 0x3f	; 63
    457e:	0f 92       	push	r0
    4580:	11 24       	eor	r1, r1
    4582:	2f 93       	push	r18
    4584:	3f 93       	push	r19
    4586:	4f 93       	push	r20
    4588:	5f 93       	push	r21
    458a:	6f 93       	push	r22
    458c:	7f 93       	push	r23
    458e:	8f 93       	push	r24
    4590:	9f 93       	push	r25
    4592:	af 93       	push	r26
    4594:	bf 93       	push	r27
    4596:	ef 93       	push	r30
    4598:	ff 93       	push	r31
  rprintf("BAD_vect called!");
    459a:	00 d0       	rcall	.+0      	; 0x459c <__vector_default+0x24>
    459c:	0f 92       	push	r0
    459e:	81 e0       	ldi	r24, 0x01	; 1
    45a0:	ed b7       	in	r30, 0x3d	; 61
    45a2:	fe b7       	in	r31, 0x3e	; 62
    45a4:	81 83       	std	Z+1, r24	; 0x01
    45a6:	8a eb       	ldi	r24, 0xBA	; 186
    45a8:	91 e0       	ldi	r25, 0x01	; 1
    45aa:	93 83       	std	Z+3, r25	; 0x03
    45ac:	82 83       	std	Z+2, r24	; 0x02
    45ae:	0e 94 86 2a 	call	0x550c	; 0x550c <rprintf1RamRom>
    45b2:	0f 90       	pop	r0
    45b4:	0f 90       	pop	r0
    45b6:	0f 90       	pop	r0
}
    45b8:	ff 91       	pop	r31
    45ba:	ef 91       	pop	r30
    45bc:	bf 91       	pop	r27
    45be:	af 91       	pop	r26
    45c0:	9f 91       	pop	r25
    45c2:	8f 91       	pop	r24
    45c4:	7f 91       	pop	r23
    45c6:	6f 91       	pop	r22
    45c8:	5f 91       	pop	r21
    45ca:	4f 91       	pop	r20
    45cc:	3f 91       	pop	r19
    45ce:	2f 91       	pop	r18
    45d0:	0f 90       	pop	r0
    45d2:	0f be       	out	0x3f, r0	; 63
    45d4:	0f 90       	pop	r0
    45d6:	1f 90       	pop	r1
    45d8:	18 95       	reti

000045da <uartSetRxHandler>:
}

void uartSetRxHandler(u08 nUart, void (*rx_func)(unsigned char c))
{
	// make sure the uart number is within bounds
	if(nUart < 4)
    45da:	84 30       	cpi	r24, 0x04	; 4
    45dc:	40 f4       	brcc	.+16     	; 0x45ee <uartSetRxHandler+0x14>
	{
		// set the receive interrupt to run the supplied user function
		UartRxFunc[nUart] = rx_func;
    45de:	e8 2f       	mov	r30, r24
    45e0:	f0 e0       	ldi	r31, 0x00	; 0
    45e2:	ee 0f       	add	r30, r30
    45e4:	ff 1f       	adc	r31, r31
    45e6:	e1 52       	subi	r30, 0x21	; 33
    45e8:	fe 4e       	sbci	r31, 0xEE	; 238
    45ea:	71 83       	std	Z+1, r23	; 0x01
    45ec:	60 83       	st	Z, r22
    45ee:	08 95       	ret

000045f0 <uartSetBaudRate>:
	}
}

void uartSetBaudRate(u08 nUart, u32 baudrate)
{
    45f0:	1f 93       	push	r17
    45f2:	18 2f       	mov	r17, r24
    45f4:	9a 01       	movw	r18, r20
    45f6:	ab 01       	movw	r20, r22
	// calculate division factor for requested baud rate, and set it
	u16 bauddiv = ((F_CPU+(baudrate*8L))/(baudrate*16L)-1);
    45f8:	ca 01       	movw	r24, r20
    45fa:	b9 01       	movw	r22, r18
    45fc:	60 58       	subi	r22, 0x80	; 128
    45fe:	7b 47       	sbci	r23, 0x7B	; 123
    4600:	81 4e       	sbci	r24, 0xE1	; 225
    4602:	9f 4f       	sbci	r25, 0xFF	; 255
    4604:	f3 e0       	ldi	r31, 0x03	; 3
    4606:	66 0f       	add	r22, r22
    4608:	77 1f       	adc	r23, r23
    460a:	88 1f       	adc	r24, r24
    460c:	99 1f       	adc	r25, r25
    460e:	fa 95       	dec	r31
    4610:	d1 f7       	brne	.-12     	; 0x4606 <uartSetBaudRate+0x16>
    4612:	e4 e0       	ldi	r30, 0x04	; 4
    4614:	22 0f       	add	r18, r18
    4616:	33 1f       	adc	r19, r19
    4618:	44 1f       	adc	r20, r20
    461a:	55 1f       	adc	r21, r21
    461c:	ea 95       	dec	r30
    461e:	d1 f7       	brne	.-12     	; 0x4614 <uartSetBaudRate+0x24>
    4620:	0e 94 20 30 	call	0x6040	; 0x6040 <__udivmodsi4>
    4624:	21 50       	subi	r18, 0x01	; 1
    4626:	30 40       	sbci	r19, 0x00	; 0
	if(nUart==3)
    4628:	13 30       	cpi	r17, 0x03	; 3
    462a:	29 f4       	brne	.+10     	; 0x4636 <uartSetBaudRate+0x46>
	{
		outb(UBRR3L, bauddiv);
    462c:	20 93 34 01 	sts	0x0134, r18
		#ifdef UBRR3H
		outb(UBRR3H, bauddiv>>8);
    4630:	30 93 35 01 	sts	0x0135, r19
    4634:	12 c0       	rjmp	.+36     	; 0x465a <uartSetBaudRate+0x6a>
		#endif
	}
	else if(nUart==2)
    4636:	12 30       	cpi	r17, 0x02	; 2
    4638:	29 f4       	brne	.+10     	; 0x4644 <uartSetBaudRate+0x54>
	{
		outb(UBRR2L, bauddiv);
    463a:	20 93 d4 00 	sts	0x00D4, r18
		#ifdef UBRR2H
		outb(UBRR2H, bauddiv>>8);
    463e:	30 93 d5 00 	sts	0x00D5, r19
    4642:	0b c0       	rjmp	.+22     	; 0x465a <uartSetBaudRate+0x6a>
		#endif
	}
	else if(nUart==1)
    4644:	11 30       	cpi	r17, 0x01	; 1
    4646:	29 f4       	brne	.+10     	; 0x4652 <uartSetBaudRate+0x62>
	{
		outb(UBRR1L, bauddiv);
    4648:	20 93 cc 00 	sts	0x00CC, r18
		#ifdef UBRR1H
		outb(UBRR1H, bauddiv>>8);
    464c:	30 93 cd 00 	sts	0x00CD, r19
    4650:	04 c0       	rjmp	.+8      	; 0x465a <uartSetBaudRate+0x6a>
		#endif
	}
	else
	{
		outb(UBRR0L, bauddiv);
    4652:	20 93 c4 00 	sts	0x00C4, r18
		#ifdef UBRR0H
		outb(UBRR0H, bauddiv>>8);
    4656:	30 93 c5 00 	sts	0x00C5, r19
		#endif
	}
}
    465a:	1f 91       	pop	r17
    465c:	08 95       	ret

0000465e <uartGetRxBuffer>:

cBuffer* uartGetRxBuffer(u08 nUart)
{
    465e:	28 2f       	mov	r18, r24
    4660:	30 e0       	ldi	r19, 0x00	; 0
    4662:	a3 e0       	ldi	r26, 0x03	; 3
    4664:	22 0f       	add	r18, r18
    4666:	33 1f       	adc	r19, r19
    4668:	aa 95       	dec	r26
    466a:	e1 f7       	brne	.-8      	; 0x4664 <uartGetRxBuffer+0x6>
    466c:	26 59       	subi	r18, 0x96	; 150
    466e:	3d 4e       	sbci	r19, 0xED	; 237
	// return rx buffer pointer
	return &uartRxBuffer[nUart];
}
    4670:	c9 01       	movw	r24, r18
    4672:	08 95       	ret

00004674 <uartGetTxBuffer>:

cBuffer* uartGetTxBuffer(u08 nUart)
{
    4674:	28 2f       	mov	r18, r24
    4676:	30 e0       	ldi	r19, 0x00	; 0
    4678:	b3 e0       	ldi	r27, 0x03	; 3
    467a:	22 0f       	add	r18, r18
    467c:	33 1f       	adc	r19, r19
    467e:	ba 95       	dec	r27
    4680:	e1 f7       	brne	.-8      	; 0x467a <uartGetTxBuffer+0x6>
    4682:	22 57       	subi	r18, 0x72	; 114
    4684:	3d 4e       	sbci	r19, 0xED	; 237
	// return tx buffer pointer
	return &uartTxBuffer[nUart];
}
    4686:	c9 01       	movw	r24, r18
    4688:	08 95       	ret

0000468a <uartSendByte>:

void uartSendByte(u08 nUart, u08 txData)
{
    468a:	e8 2f       	mov	r30, r24
	// wait for the transmitter to be ready
//	while(!uartReadyTx[nUart]);
	// send byte
	if(nUart==3)
    468c:	83 30       	cpi	r24, 0x03	; 3
    468e:	39 f4       	brne	.+14     	; 0x469e <uartSendByte+0x14>
	{
		while(!(UCSR3A & (1<<UDRE3)));
    4690:	80 91 30 01 	lds	r24, 0x0130
    4694:	85 ff       	sbrs	r24, 5
    4696:	fc cf       	rjmp	.-8      	; 0x4690 <uartSendByte+0x6>
		outb(UDR3, txData);
    4698:	60 93 36 01 	sts	0x0136, r22
    469c:	18 c0       	rjmp	.+48     	; 0x46ce <uartSendByte+0x44>
	}
	else if(nUart==2)
    469e:	82 30       	cpi	r24, 0x02	; 2
    46a0:	39 f4       	brne	.+14     	; 0x46b0 <uartSendByte+0x26>
	{
		while(!(UCSR2A & (1<<UDRE2)));
    46a2:	80 91 d0 00 	lds	r24, 0x00D0
    46a6:	85 ff       	sbrs	r24, 5
    46a8:	fc cf       	rjmp	.-8      	; 0x46a2 <uartSendByte+0x18>
		outb(UDR2, txData);
    46aa:	60 93 d6 00 	sts	0x00D6, r22
    46ae:	0f c0       	rjmp	.+30     	; 0x46ce <uartSendByte+0x44>
	}
	else if(nUart==1)
    46b0:	81 30       	cpi	r24, 0x01	; 1
    46b2:	39 f4       	brne	.+14     	; 0x46c2 <uartSendByte+0x38>
	{
		while(!(UCSR1A & (1<<UDRE1)));
    46b4:	80 91 c8 00 	lds	r24, 0x00C8
    46b8:	85 ff       	sbrs	r24, 5
    46ba:	fc cf       	rjmp	.-8      	; 0x46b4 <uartSendByte+0x2a>
		outb(UDR1, txData);
    46bc:	60 93 ce 00 	sts	0x00CE, r22
    46c0:	06 c0       	rjmp	.+12     	; 0x46ce <uartSendByte+0x44>
	}
	else
	{
		while(!(UCSR0A & (1<<UDRE0)));
    46c2:	80 91 c0 00 	lds	r24, 0x00C0
    46c6:	85 ff       	sbrs	r24, 5
    46c8:	fc cf       	rjmp	.-8      	; 0x46c2 <uartSendByte+0x38>
		outb(UDR0, txData);
    46ca:	60 93 c6 00 	sts	0x00C6, r22
	}
	// set ready state to FALSE
	uartReadyTx[nUart] = FALSE;
    46ce:	f0 e0       	ldi	r31, 0x00	; 0
    46d0:	ea 59       	subi	r30, 0x9A	; 154
    46d2:	fd 4e       	sbci	r31, 0xED	; 237
    46d4:	10 82       	st	Z, r1
}
    46d6:	08 95       	ret

000046d8 <uart0SendByte>:

void uart0SendByte(u08 data)
{
    46d8:	68 2f       	mov	r22, r24
	// send byte on UART0
	uartSendByte(0, data);
    46da:	80 e0       	ldi	r24, 0x00	; 0
    46dc:	0e 94 45 23 	call	0x468a	; 0x468a <uartSendByte>
}
    46e0:	08 95       	ret

000046e2 <uart1SendByte>:

void uart1SendByte(u08 data)
{
    46e2:	68 2f       	mov	r22, r24
	// send byte on UART1
	uartSendByte(1, data);
    46e4:	81 e0       	ldi	r24, 0x01	; 1
    46e6:	0e 94 45 23 	call	0x468a	; 0x468a <uartSendByte>
}
    46ea:	08 95       	ret

000046ec <uart2SendByte>:

void uart2SendByte(u08 data)
{
    46ec:	68 2f       	mov	r22, r24
	// send byte on UART2
	uartSendByte(2, data);
    46ee:	82 e0       	ldi	r24, 0x02	; 2
    46f0:	0e 94 45 23 	call	0x468a	; 0x468a <uartSendByte>
}
    46f4:	08 95       	ret

000046f6 <uart3SendByte>:

void uart3SendByte(u08 data)
{
    46f6:	68 2f       	mov	r22, r24
	// send byte on UART3
	uartSendByte(3, data);
    46f8:	83 e0       	ldi	r24, 0x03	; 3
    46fa:	0e 94 45 23 	call	0x468a	; 0x468a <uartSendByte>
}
    46fe:	08 95       	ret

00004700 <uartReceiveBufferIsEmpty>:
	// flush all data from receive buffer
	bufferFlush(&uartRxBuffer[nUart]);
}

u08 uartReceiveBufferIsEmpty(u08 nUart)
{
    4700:	20 e0       	ldi	r18, 0x00	; 0
    4702:	e8 2f       	mov	r30, r24
    4704:	f0 e0       	ldi	r31, 0x00	; 0
    4706:	83 e0       	ldi	r24, 0x03	; 3
    4708:	ee 0f       	add	r30, r30
    470a:	ff 1f       	adc	r31, r31
    470c:	8a 95       	dec	r24
    470e:	e1 f7       	brne	.-8      	; 0x4708 <uartReceiveBufferIsEmpty+0x8>
    4710:	e2 59       	subi	r30, 0x92	; 146
    4712:	fd 4e       	sbci	r31, 0xED	; 237
    4714:	80 81       	ld	r24, Z
    4716:	91 81       	ldd	r25, Z+1	; 0x01
    4718:	89 2b       	or	r24, r25
    471a:	09 f4       	brne	.+2      	; 0x471e <uartReceiveBufferIsEmpty+0x1e>
    471c:	21 e0       	ldi	r18, 0x01	; 1
	return (uartRxBuffer[nUart].datalength == 0);
}
    471e:	82 2f       	mov	r24, r18
    4720:	08 95       	ret

00004722 <uartReceiveService>:
	}
}

// UART Receive Complete Interrupt Function
void uartReceiveService(u08 nUart)
{
    4722:	cf 93       	push	r28
    4724:	df 93       	push	r29
	u08 c;
	// get received char
	if(nUart==3)
    4726:	83 30       	cpi	r24, 0x03	; 3
    4728:	19 f4       	brne	.+6      	; 0x4730 <uartReceiveService+0xe>
		c = inb(UDR3);
    472a:	60 91 36 01 	lds	r22, 0x0136
    472e:	0c c0       	rjmp	.+24     	; 0x4748 <uartReceiveService+0x26>
	else if(nUart==2)
    4730:	82 30       	cpi	r24, 0x02	; 2
    4732:	19 f4       	brne	.+6      	; 0x473a <uartReceiveService+0x18>
		c = inb(UDR2);
    4734:	60 91 d6 00 	lds	r22, 0x00D6
    4738:	07 c0       	rjmp	.+14     	; 0x4748 <uartReceiveService+0x26>
	else if(nUart==1)
    473a:	81 30       	cpi	r24, 0x01	; 1
    473c:	19 f4       	brne	.+6      	; 0x4744 <uartReceiveService+0x22>
		c = inb(UDR1);
    473e:	60 91 ce 00 	lds	r22, 0x00CE
    4742:	02 c0       	rjmp	.+4      	; 0x4748 <uartReceiveService+0x26>
	else
		c = inb(UDR0);
    4744:	60 91 c6 00 	lds	r22, 0x00C6

	// if there's a user function to handle this receive event
	if(UartRxFunc[nUart])
    4748:	28 2f       	mov	r18, r24
    474a:	30 e0       	ldi	r19, 0x00	; 0
    474c:	e9 01       	movw	r28, r18
    474e:	cc 0f       	add	r28, r28
    4750:	dd 1f       	adc	r29, r29
    4752:	fe 01       	movw	r30, r28
    4754:	e1 52       	subi	r30, 0x21	; 33
    4756:	fe 4e       	sbci	r31, 0xEE	; 238
    4758:	80 81       	ld	r24, Z
    475a:	91 81       	ldd	r25, Z+1	; 0x01
    475c:	89 2b       	or	r24, r25
    475e:	31 f0       	breq	.+12     	; 0x476c <uartReceiveService+0x4a>
	{
		// call it and pass the received data
		UartRxFunc[nUart](c);
    4760:	01 90       	ld	r0, Z+
    4762:	f0 81       	ld	r31, Z
    4764:	e0 2d       	mov	r30, r0
    4766:	86 2f       	mov	r24, r22
    4768:	09 95       	icall
    476a:	14 c0       	rjmp	.+40     	; 0x4794 <uartReceiveService+0x72>
	else
	{
		// otherwise do default processing
		// put received char in buffer
		// check if there's space
		if( !bufferAddToEnd(&uartRxBuffer[nUart], c) )
    476c:	93 e0       	ldi	r25, 0x03	; 3
    476e:	22 0f       	add	r18, r18
    4770:	33 1f       	adc	r19, r19
    4772:	9a 95       	dec	r25
    4774:	e1 f7       	brne	.-8      	; 0x476e <uartReceiveService+0x4c>
    4776:	c9 01       	movw	r24, r18
    4778:	86 59       	subi	r24, 0x96	; 150
    477a:	9d 4e       	sbci	r25, 0xED	; 237
    477c:	0e 94 9d 27 	call	0x4f3a	; 0x4f3a <bufferAddToEnd>
    4780:	88 23       	and	r24, r24
    4782:	41 f4       	brne	.+16     	; 0x4794 <uartReceiveService+0x72>
		{
			// no space in buffer
			// count overflow
			uartRxOverflow[nUart]++;
    4784:	fe 01       	movw	r30, r28
    4786:	e2 55       	subi	r30, 0x52	; 82
    4788:	fd 4e       	sbci	r31, 0xED	; 237
    478a:	80 81       	ld	r24, Z
    478c:	91 81       	ldd	r25, Z+1	; 0x01
    478e:	01 96       	adiw	r24, 0x01	; 1
    4790:	91 83       	std	Z+1, r25	; 0x01
    4792:	80 83       	st	Z, r24
		}
	}
}
    4794:	df 91       	pop	r29
    4796:	cf 91       	pop	r28
    4798:	08 95       	ret

0000479a <__vector_54>:
{
	uartReceiveService(2);
}

UART_INTERRUPT_HANDLER(SIG_USART3_RECV)      
{
    479a:	1f 92       	push	r1
    479c:	0f 92       	push	r0
    479e:	0f b6       	in	r0, 0x3f	; 63
    47a0:	0f 92       	push	r0
    47a2:	11 24       	eor	r1, r1
    47a4:	2f 93       	push	r18
    47a6:	3f 93       	push	r19
    47a8:	4f 93       	push	r20
    47aa:	5f 93       	push	r21
    47ac:	6f 93       	push	r22
    47ae:	7f 93       	push	r23
    47b0:	8f 93       	push	r24
    47b2:	9f 93       	push	r25
    47b4:	af 93       	push	r26
    47b6:	bf 93       	push	r27
    47b8:	ef 93       	push	r30
    47ba:	ff 93       	push	r31
	uartReceiveService(3);
    47bc:	83 e0       	ldi	r24, 0x03	; 3
    47be:	0e 94 91 23 	call	0x4722	; 0x4722 <uartReceiveService>
}
    47c2:	ff 91       	pop	r31
    47c4:	ef 91       	pop	r30
    47c6:	bf 91       	pop	r27
    47c8:	af 91       	pop	r26
    47ca:	9f 91       	pop	r25
    47cc:	8f 91       	pop	r24
    47ce:	7f 91       	pop	r23
    47d0:	6f 91       	pop	r22
    47d2:	5f 91       	pop	r21
    47d4:	4f 91       	pop	r20
    47d6:	3f 91       	pop	r19
    47d8:	2f 91       	pop	r18
    47da:	0f 90       	pop	r0
    47dc:	0f be       	out	0x3f, r0	; 63
    47de:	0f 90       	pop	r0
    47e0:	1f 90       	pop	r1
    47e2:	18 95       	reti

000047e4 <__vector_51>:
{
	uartReceiveService(1);
}

UART_INTERRUPT_HANDLER(SIG_USART2_RECV)      
{
    47e4:	1f 92       	push	r1
    47e6:	0f 92       	push	r0
    47e8:	0f b6       	in	r0, 0x3f	; 63
    47ea:	0f 92       	push	r0
    47ec:	11 24       	eor	r1, r1
    47ee:	2f 93       	push	r18
    47f0:	3f 93       	push	r19
    47f2:	4f 93       	push	r20
    47f4:	5f 93       	push	r21
    47f6:	6f 93       	push	r22
    47f8:	7f 93       	push	r23
    47fa:	8f 93       	push	r24
    47fc:	9f 93       	push	r25
    47fe:	af 93       	push	r26
    4800:	bf 93       	push	r27
    4802:	ef 93       	push	r30
    4804:	ff 93       	push	r31
	uartReceiveService(2);
    4806:	82 e0       	ldi	r24, 0x02	; 2
    4808:	0e 94 91 23 	call	0x4722	; 0x4722 <uartReceiveService>
}
    480c:	ff 91       	pop	r31
    480e:	ef 91       	pop	r30
    4810:	bf 91       	pop	r27
    4812:	af 91       	pop	r26
    4814:	9f 91       	pop	r25
    4816:	8f 91       	pop	r24
    4818:	7f 91       	pop	r23
    481a:	6f 91       	pop	r22
    481c:	5f 91       	pop	r21
    481e:	4f 91       	pop	r20
    4820:	3f 91       	pop	r19
    4822:	2f 91       	pop	r18
    4824:	0f 90       	pop	r0
    4826:	0f be       	out	0x3f, r0	; 63
    4828:	0f 90       	pop	r0
    482a:	1f 90       	pop	r1
    482c:	18 95       	reti

0000482e <__vector_36>:
{
	uartReceiveService(0);
}

UART_INTERRUPT_HANDLER(SIG_USART1_RECV)      
{
    482e:	1f 92       	push	r1
    4830:	0f 92       	push	r0
    4832:	0f b6       	in	r0, 0x3f	; 63
    4834:	0f 92       	push	r0
    4836:	11 24       	eor	r1, r1
    4838:	2f 93       	push	r18
    483a:	3f 93       	push	r19
    483c:	4f 93       	push	r20
    483e:	5f 93       	push	r21
    4840:	6f 93       	push	r22
    4842:	7f 93       	push	r23
    4844:	8f 93       	push	r24
    4846:	9f 93       	push	r25
    4848:	af 93       	push	r26
    484a:	bf 93       	push	r27
    484c:	ef 93       	push	r30
    484e:	ff 93       	push	r31
	uartReceiveService(1);
    4850:	81 e0       	ldi	r24, 0x01	; 1
    4852:	0e 94 91 23 	call	0x4722	; 0x4722 <uartReceiveService>
}
    4856:	ff 91       	pop	r31
    4858:	ef 91       	pop	r30
    485a:	bf 91       	pop	r27
    485c:	af 91       	pop	r26
    485e:	9f 91       	pop	r25
    4860:	8f 91       	pop	r24
    4862:	7f 91       	pop	r23
    4864:	6f 91       	pop	r22
    4866:	5f 91       	pop	r21
    4868:	4f 91       	pop	r20
    486a:	3f 91       	pop	r19
    486c:	2f 91       	pop	r18
    486e:	0f 90       	pop	r0
    4870:	0f be       	out	0x3f, r0	; 63
    4872:	0f 90       	pop	r0
    4874:	1f 90       	pop	r1
    4876:	18 95       	reti

00004878 <__vector_25>:
	uartTransmitService(3);
}

	// service UART receive interrupt
UART_INTERRUPT_HANDLER(SIG_USART0_RECV)      
{
    4878:	1f 92       	push	r1
    487a:	0f 92       	push	r0
    487c:	0f b6       	in	r0, 0x3f	; 63
    487e:	0f 92       	push	r0
    4880:	11 24       	eor	r1, r1
    4882:	2f 93       	push	r18
    4884:	3f 93       	push	r19
    4886:	4f 93       	push	r20
    4888:	5f 93       	push	r21
    488a:	6f 93       	push	r22
    488c:	7f 93       	push	r23
    488e:	8f 93       	push	r24
    4890:	9f 93       	push	r25
    4892:	af 93       	push	r26
    4894:	bf 93       	push	r27
    4896:	ef 93       	push	r30
    4898:	ff 93       	push	r31
	uartReceiveService(0);
    489a:	80 e0       	ldi	r24, 0x00	; 0
    489c:	0e 94 91 23 	call	0x4722	; 0x4722 <uartReceiveService>
}
    48a0:	ff 91       	pop	r31
    48a2:	ef 91       	pop	r30
    48a4:	bf 91       	pop	r27
    48a6:	af 91       	pop	r26
    48a8:	9f 91       	pop	r25
    48aa:	8f 91       	pop	r24
    48ac:	7f 91       	pop	r23
    48ae:	6f 91       	pop	r22
    48b0:	5f 91       	pop	r21
    48b2:	4f 91       	pop	r20
    48b4:	3f 91       	pop	r19
    48b6:	2f 91       	pop	r18
    48b8:	0f 90       	pop	r0
    48ba:	0f be       	out	0x3f, r0	; 63
    48bc:	0f 90       	pop	r0
    48be:	1f 90       	pop	r1
    48c0:	18 95       	reti

000048c2 <uartSendBuffer>:
	// send the first byte to get things going by interrupts
	uartSendByte(nUart, bufferGetFromFront(&uartTxBuffer[nUart]));
}

u08 uartSendBuffer(u08 nUart, char *buffer, u16 nBytes)
{
    48c2:	8f 92       	push	r8
    48c4:	9f 92       	push	r9
    48c6:	af 92       	push	r10
    48c8:	bf 92       	push	r11
    48ca:	cf 92       	push	r12
    48cc:	df 92       	push	r13
    48ce:	ef 92       	push	r14
    48d0:	ff 92       	push	r15
    48d2:	0f 93       	push	r16
    48d4:	1f 93       	push	r17
    48d6:	cf 93       	push	r28
    48d8:	df 93       	push	r29
    48da:	88 2e       	mov	r8, r24
    48dc:	db 01       	movw	r26, r22
	register u08 first;
	register u16 i;

	// check if there's space (and that we have any bytes to send at all)
	if((uartTxBuffer[nUart].datalength + nBytes < uartTxBuffer[nUart].size) && nBytes)
    48de:	c8 2e       	mov	r12, r24
    48e0:	dd 24       	eor	r13, r13
    48e2:	f6 01       	movw	r30, r12
    48e4:	13 e0       	ldi	r17, 0x03	; 3
    48e6:	ee 0f       	add	r30, r30
    48e8:	ff 1f       	adc	r31, r31
    48ea:	1a 95       	dec	r17
    48ec:	e1 f7       	brne	.-8      	; 0x48e6 <uartSendBuffer+0x24>
    48ee:	ee 56       	subi	r30, 0x6E	; 110
    48f0:	fd 4e       	sbci	r31, 0xED	; 237
    48f2:	20 81       	ld	r18, Z
    48f4:	31 81       	ldd	r19, Z+1	; 0x01
    48f6:	24 0f       	add	r18, r20
    48f8:	35 1f       	adc	r19, r21
    48fa:	f6 01       	movw	r30, r12
    48fc:	73 e0       	ldi	r23, 0x03	; 3
    48fe:	ee 0f       	add	r30, r30
    4900:	ff 1f       	adc	r31, r31
    4902:	7a 95       	dec	r23
    4904:	e1 f7       	brne	.-8      	; 0x48fe <uartSendBuffer+0x3c>
    4906:	e0 57       	subi	r30, 0x70	; 112
    4908:	fd 4e       	sbci	r31, 0xED	; 237
    490a:	80 81       	ld	r24, Z
    490c:	91 81       	ldd	r25, Z+1	; 0x01
    490e:	28 17       	cp	r18, r24
    4910:	39 07       	cpc	r19, r25
    4912:	70 f5       	brcc	.+92     	; 0x4970 <uartSendBuffer+0xae>
    4914:	41 15       	cp	r20, r1
    4916:	51 05       	cpc	r21, r1
    4918:	59 f1       	breq	.+86     	; 0x4970 <uartSendBuffer+0xae>
	{
		// grab first character
		first = *buffer++;
    491a:	9c 90       	ld	r9, X
		// copy user buffer to uart transmit buffer
		for(i = 0; i < nBytes-1; i++)
		{
			// put data bytes at end of buffer
			bufferAddToEnd(&uartTxBuffer[nUart], *buffer++);
    491c:	76 01       	movw	r14, r12
    491e:	63 e0       	ldi	r22, 0x03	; 3
    4920:	ee 0c       	add	r14, r14
    4922:	ff 1c       	adc	r15, r15
    4924:	6a 95       	dec	r22
    4926:	e1 f7       	brne	.-8      	; 0x4920 <uartSendBuffer+0x5e>
    4928:	8e e8       	ldi	r24, 0x8E	; 142
    492a:	92 e1       	ldi	r25, 0x12	; 18
    492c:	e8 0e       	add	r14, r24
    492e:	f9 1e       	adc	r15, r25
    4930:	8d 01       	movw	r16, r26
    4932:	c0 e0       	ldi	r28, 0x00	; 0
    4934:	d0 e0       	ldi	r29, 0x00	; 0
	if((uartTxBuffer[nUart].datalength + nBytes < uartTxBuffer[nUart].size) && nBytes)
	{
		// grab first character
		first = *buffer++;
		// copy user buffer to uart transmit buffer
		for(i = 0; i < nBytes-1; i++)
    4936:	5a 01       	movw	r10, r20
    4938:	08 94       	sec
    493a:	a1 08       	sbc	r10, r1
    493c:	b1 08       	sbc	r11, r1
    493e:	06 c0       	rjmp	.+12     	; 0x494c <uartSendBuffer+0x8a>
    4940:	c7 01       	movw	r24, r14
    4942:	f8 01       	movw	r30, r16
    4944:	60 81       	ld	r22, Z
    4946:	0e 94 9d 27 	call	0x4f3a	; 0x4f3a <bufferAddToEnd>
    494a:	21 96       	adiw	r28, 0x01	; 1
    494c:	0f 5f       	subi	r16, 0xFF	; 255
    494e:	1f 4f       	sbci	r17, 0xFF	; 255
    4950:	ca 15       	cp	r28, r10
    4952:	db 05       	cpc	r29, r11
    4954:	a8 f3       	brcs	.-22     	; 0x4940 <uartSendBuffer+0x7e>
			// put data bytes at end of buffer
			bufferAddToEnd(&uartTxBuffer[nUart], *buffer++);
		}

		// send the first byte to get things going by interrupts
		uartBufferedTx[nUart] = TRUE;
    4956:	8a e8       	ldi	r24, 0x8A	; 138
    4958:	92 e1       	ldi	r25, 0x12	; 18
    495a:	c8 0e       	add	r12, r24
    495c:	d9 1e       	adc	r13, r25
    495e:	8f ef       	ldi	r24, 0xFF	; 255
    4960:	f6 01       	movw	r30, r12
    4962:	80 83       	st	Z, r24
		uartSendByte(nUart, first);
    4964:	88 2d       	mov	r24, r8
    4966:	69 2d       	mov	r22, r9
    4968:	0e 94 45 23 	call	0x468a	; 0x468a <uartSendByte>
    496c:	8f ef       	ldi	r24, 0xFF	; 255
    496e:	01 c0       	rjmp	.+2      	; 0x4972 <uartSendBuffer+0xb0>
		// return success
		return TRUE;
    4970:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		// return failure
		return FALSE;
	}
}
    4972:	df 91       	pop	r29
    4974:	cf 91       	pop	r28
    4976:	1f 91       	pop	r17
    4978:	0f 91       	pop	r16
    497a:	ff 90       	pop	r15
    497c:	ef 90       	pop	r14
    497e:	df 90       	pop	r13
    4980:	cf 90       	pop	r12
    4982:	bf 90       	pop	r11
    4984:	af 90       	pop	r10
    4986:	9f 90       	pop	r9
    4988:	8f 90       	pop	r8
    498a:	08 95       	ret

0000498c <uartAddToTxBuffer>:
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    498c:	90 e0       	ldi	r25, 0x00	; 0
    498e:	23 e0       	ldi	r18, 0x03	; 3
    4990:	88 0f       	add	r24, r24
    4992:	99 1f       	adc	r25, r25
    4994:	2a 95       	dec	r18
    4996:	e1 f7       	brne	.-8      	; 0x4990 <uartAddToTxBuffer+0x4>
    4998:	82 57       	subi	r24, 0x72	; 114
    499a:	9d 4e       	sbci	r25, 0xED	; 237
    499c:	0e 94 9d 27 	call	0x4f3a	; 0x4f3a <bufferAddToEnd>
}
    49a0:	08 95       	ret

000049a2 <uart3AddToTxBuffer>:
{
	uartAddToTxBuffer(2,data);
}

void uart3AddToTxBuffer(u08 data)
{
    49a2:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    49a4:	86 ea       	ldi	r24, 0xA6	; 166
    49a6:	92 e1       	ldi	r25, 0x12	; 18
    49a8:	0e 94 9d 27 	call	0x4f3a	; 0x4f3a <bufferAddToEnd>
}

void uart3AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(3,data);
}
    49ac:	08 95       	ret

000049ae <uart2AddToTxBuffer>:
{
	uartAddToTxBuffer(1,data);
}

void uart2AddToTxBuffer(u08 data)
{
    49ae:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    49b0:	8e e9       	ldi	r24, 0x9E	; 158
    49b2:	92 e1       	ldi	r25, 0x12	; 18
    49b4:	0e 94 9d 27 	call	0x4f3a	; 0x4f3a <bufferAddToEnd>
}

void uart2AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(2,data);
}
    49b8:	08 95       	ret

000049ba <uart1AddToTxBuffer>:
{
	uartAddToTxBuffer(0,data);
}

void uart1AddToTxBuffer(u08 data)
{
    49ba:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    49bc:	86 e9       	ldi	r24, 0x96	; 150
    49be:	92 e1       	ldi	r25, 0x12	; 18
    49c0:	0e 94 9d 27 	call	0x4f3a	; 0x4f3a <bufferAddToEnd>
}

void uart1AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(1,data);
}
    49c4:	08 95       	ret

000049c6 <uart0AddToTxBuffer>:
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
}

void uart0AddToTxBuffer(u08 data)
{
    49c6:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    49c8:	8e e8       	ldi	r24, 0x8E	; 142
    49ca:	92 e1       	ldi	r25, 0x12	; 18
    49cc:	0e 94 9d 27 	call	0x4f3a	; 0x4f3a <bufferAddToEnd>
}

void uart0AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(0,data);
}
    49d0:	08 95       	ret

000049d2 <uartTransmitService>:
	}
}

// UART Transmit Complete Interrupt Function
void uartTransmitService(u08 nUart)
{
    49d2:	cf 93       	push	r28
    49d4:	df 93       	push	r29
    49d6:	28 2f       	mov	r18, r24
	// check if buffered tx is enabled
	if(uartBufferedTx[nUart])
    49d8:	a8 2f       	mov	r26, r24
    49da:	b0 e0       	ldi	r27, 0x00	; 0
    49dc:	ed 01       	movw	r28, r26
    49de:	c6 57       	subi	r28, 0x76	; 118
    49e0:	dd 4e       	sbci	r29, 0xED	; 237
    49e2:	88 81       	ld	r24, Y
    49e4:	88 23       	and	r24, r24
    49e6:	79 f1       	breq	.+94     	; 0x4a46 <uartTransmitService+0x74>
	{
		// check if there's data left in the buffer
		if(uartTxBuffer[nUart].datalength)
    49e8:	fd 01       	movw	r30, r26
    49ea:	33 e0       	ldi	r19, 0x03	; 3
    49ec:	ee 0f       	add	r30, r30
    49ee:	ff 1f       	adc	r31, r31
    49f0:	3a 95       	dec	r19
    49f2:	e1 f7       	brne	.-8      	; 0x49ec <uartTransmitService+0x1a>
    49f4:	ee 56       	subi	r30, 0x6E	; 110
    49f6:	fd 4e       	sbci	r31, 0xED	; 237
    49f8:	80 81       	ld	r24, Z
    49fa:	91 81       	ldd	r25, Z+1	; 0x01
    49fc:	89 2b       	or	r24, r25
    49fe:	11 f1       	breq	.+68     	; 0x4a44 <uartTransmitService+0x72>
		{
			// send byte from top of buffer
			if(nUart==3)
    4a00:	23 30       	cpi	r18, 0x03	; 3
    4a02:	39 f4       	brne	.+14     	; 0x4a12 <uartTransmitService+0x40>
				outb(UDR3,  bufferGetFromFront(&uartTxBuffer[3]) );
    4a04:	86 ea       	ldi	r24, 0xA6	; 166
    4a06:	92 e1       	ldi	r25, 0x12	; 18
    4a08:	0e 94 34 27 	call	0x4e68	; 0x4e68 <bufferGetFromFront>
    4a0c:	80 93 36 01 	sts	0x0136, r24
    4a10:	1e c0       	rjmp	.+60     	; 0x4a4e <uartTransmitService+0x7c>
			else if(nUart==2)
    4a12:	22 30       	cpi	r18, 0x02	; 2
    4a14:	39 f4       	brne	.+14     	; 0x4a24 <uartTransmitService+0x52>
				outb(UDR2,  bufferGetFromFront(&uartTxBuffer[2]) );
    4a16:	8e e9       	ldi	r24, 0x9E	; 158
    4a18:	92 e1       	ldi	r25, 0x12	; 18
    4a1a:	0e 94 34 27 	call	0x4e68	; 0x4e68 <bufferGetFromFront>
    4a1e:	80 93 d6 00 	sts	0x00D6, r24
    4a22:	15 c0       	rjmp	.+42     	; 0x4a4e <uartTransmitService+0x7c>
			else if(nUart==1)
    4a24:	21 30       	cpi	r18, 0x01	; 1
    4a26:	39 f4       	brne	.+14     	; 0x4a36 <uartTransmitService+0x64>
				outb(UDR1,  bufferGetFromFront(&uartTxBuffer[1]) );
    4a28:	86 e9       	ldi	r24, 0x96	; 150
    4a2a:	92 e1       	ldi	r25, 0x12	; 18
    4a2c:	0e 94 34 27 	call	0x4e68	; 0x4e68 <bufferGetFromFront>
    4a30:	80 93 ce 00 	sts	0x00CE, r24
    4a34:	0c c0       	rjmp	.+24     	; 0x4a4e <uartTransmitService+0x7c>
			else
				outb(UDR0,  bufferGetFromFront(&uartTxBuffer[0]) );
    4a36:	8e e8       	ldi	r24, 0x8E	; 142
    4a38:	92 e1       	ldi	r25, 0x12	; 18
    4a3a:	0e 94 34 27 	call	0x4e68	; 0x4e68 <bufferGetFromFront>
    4a3e:	80 93 c6 00 	sts	0x00C6, r24
    4a42:	05 c0       	rjmp	.+10     	; 0x4a4e <uartTransmitService+0x7c>
		}
		else
		{
			// no data left
			uartBufferedTx[nUart] = FALSE;
    4a44:	18 82       	st	Y, r1
	}
	else
	{
		// we're using single-byte tx mode
		// indicate transmit complete, back to ready
		uartReadyTx[nUart] = TRUE;
    4a46:	aa 59       	subi	r26, 0x9A	; 154
    4a48:	bd 4e       	sbci	r27, 0xED	; 237
    4a4a:	8f ef       	ldi	r24, 0xFF	; 255
    4a4c:	8c 93       	st	X, r24
	}
}
    4a4e:	df 91       	pop	r29
    4a50:	cf 91       	pop	r28
    4a52:	08 95       	ret

00004a54 <__vector_56>:
{
	uartTransmitService(2);
}

UART_INTERRUPT_HANDLER(SIG_USART3_TRANS)      
{
    4a54:	1f 92       	push	r1
    4a56:	0f 92       	push	r0
    4a58:	0f b6       	in	r0, 0x3f	; 63
    4a5a:	0f 92       	push	r0
    4a5c:	11 24       	eor	r1, r1
    4a5e:	2f 93       	push	r18
    4a60:	3f 93       	push	r19
    4a62:	4f 93       	push	r20
    4a64:	5f 93       	push	r21
    4a66:	6f 93       	push	r22
    4a68:	7f 93       	push	r23
    4a6a:	8f 93       	push	r24
    4a6c:	9f 93       	push	r25
    4a6e:	af 93       	push	r26
    4a70:	bf 93       	push	r27
    4a72:	ef 93       	push	r30
    4a74:	ff 93       	push	r31
	uartTransmitService(3);
    4a76:	83 e0       	ldi	r24, 0x03	; 3
    4a78:	0e 94 e9 24 	call	0x49d2	; 0x49d2 <uartTransmitService>
}
    4a7c:	ff 91       	pop	r31
    4a7e:	ef 91       	pop	r30
    4a80:	bf 91       	pop	r27
    4a82:	af 91       	pop	r26
    4a84:	9f 91       	pop	r25
    4a86:	8f 91       	pop	r24
    4a88:	7f 91       	pop	r23
    4a8a:	6f 91       	pop	r22
    4a8c:	5f 91       	pop	r21
    4a8e:	4f 91       	pop	r20
    4a90:	3f 91       	pop	r19
    4a92:	2f 91       	pop	r18
    4a94:	0f 90       	pop	r0
    4a96:	0f be       	out	0x3f, r0	; 63
    4a98:	0f 90       	pop	r0
    4a9a:	1f 90       	pop	r1
    4a9c:	18 95       	reti

00004a9e <__vector_53>:
{
	uartTransmitService(1);
}

UART_INTERRUPT_HANDLER(SIG_USART2_TRANS)      
{
    4a9e:	1f 92       	push	r1
    4aa0:	0f 92       	push	r0
    4aa2:	0f b6       	in	r0, 0x3f	; 63
    4aa4:	0f 92       	push	r0
    4aa6:	11 24       	eor	r1, r1
    4aa8:	2f 93       	push	r18
    4aaa:	3f 93       	push	r19
    4aac:	4f 93       	push	r20
    4aae:	5f 93       	push	r21
    4ab0:	6f 93       	push	r22
    4ab2:	7f 93       	push	r23
    4ab4:	8f 93       	push	r24
    4ab6:	9f 93       	push	r25
    4ab8:	af 93       	push	r26
    4aba:	bf 93       	push	r27
    4abc:	ef 93       	push	r30
    4abe:	ff 93       	push	r31
	uartTransmitService(2);
    4ac0:	82 e0       	ldi	r24, 0x02	; 2
    4ac2:	0e 94 e9 24 	call	0x49d2	; 0x49d2 <uartTransmitService>
}
    4ac6:	ff 91       	pop	r31
    4ac8:	ef 91       	pop	r30
    4aca:	bf 91       	pop	r27
    4acc:	af 91       	pop	r26
    4ace:	9f 91       	pop	r25
    4ad0:	8f 91       	pop	r24
    4ad2:	7f 91       	pop	r23
    4ad4:	6f 91       	pop	r22
    4ad6:	5f 91       	pop	r21
    4ad8:	4f 91       	pop	r20
    4ada:	3f 91       	pop	r19
    4adc:	2f 91       	pop	r18
    4ade:	0f 90       	pop	r0
    4ae0:	0f be       	out	0x3f, r0	; 63
    4ae2:	0f 90       	pop	r0
    4ae4:	1f 90       	pop	r1
    4ae6:	18 95       	reti

00004ae8 <__vector_38>:
{
	uartTransmitService(0);
}

UART_INTERRUPT_HANDLER(SIG_USART1_TRANS)      
{
    4ae8:	1f 92       	push	r1
    4aea:	0f 92       	push	r0
    4aec:	0f b6       	in	r0, 0x3f	; 63
    4aee:	0f 92       	push	r0
    4af0:	11 24       	eor	r1, r1
    4af2:	2f 93       	push	r18
    4af4:	3f 93       	push	r19
    4af6:	4f 93       	push	r20
    4af8:	5f 93       	push	r21
    4afa:	6f 93       	push	r22
    4afc:	7f 93       	push	r23
    4afe:	8f 93       	push	r24
    4b00:	9f 93       	push	r25
    4b02:	af 93       	push	r26
    4b04:	bf 93       	push	r27
    4b06:	ef 93       	push	r30
    4b08:	ff 93       	push	r31
	uartTransmitService(1);
    4b0a:	81 e0       	ldi	r24, 0x01	; 1
    4b0c:	0e 94 e9 24 	call	0x49d2	; 0x49d2 <uartTransmitService>
}
    4b10:	ff 91       	pop	r31
    4b12:	ef 91       	pop	r30
    4b14:	bf 91       	pop	r27
    4b16:	af 91       	pop	r26
    4b18:	9f 91       	pop	r25
    4b1a:	8f 91       	pop	r24
    4b1c:	7f 91       	pop	r23
    4b1e:	6f 91       	pop	r22
    4b20:	5f 91       	pop	r21
    4b22:	4f 91       	pop	r20
    4b24:	3f 91       	pop	r19
    4b26:	2f 91       	pop	r18
    4b28:	0f 90       	pop	r0
    4b2a:	0f be       	out	0x3f, r0	; 63
    4b2c:	0f 90       	pop	r0
    4b2e:	1f 90       	pop	r1
    4b30:	18 95       	reti

00004b32 <__vector_27>:
	}
}

	// service UART transmit interrupt
UART_INTERRUPT_HANDLER(SIG_USART0_TRANS)      
{
    4b32:	1f 92       	push	r1
    4b34:	0f 92       	push	r0
    4b36:	0f b6       	in	r0, 0x3f	; 63
    4b38:	0f 92       	push	r0
    4b3a:	11 24       	eor	r1, r1
    4b3c:	2f 93       	push	r18
    4b3e:	3f 93       	push	r19
    4b40:	4f 93       	push	r20
    4b42:	5f 93       	push	r21
    4b44:	6f 93       	push	r22
    4b46:	7f 93       	push	r23
    4b48:	8f 93       	push	r24
    4b4a:	9f 93       	push	r25
    4b4c:	af 93       	push	r26
    4b4e:	bf 93       	push	r27
    4b50:	ef 93       	push	r30
    4b52:	ff 93       	push	r31
	uartTransmitService(0);
    4b54:	80 e0       	ldi	r24, 0x00	; 0
    4b56:	0e 94 e9 24 	call	0x49d2	; 0x49d2 <uartTransmitService>
}
    4b5a:	ff 91       	pop	r31
    4b5c:	ef 91       	pop	r30
    4b5e:	bf 91       	pop	r27
    4b60:	af 91       	pop	r26
    4b62:	9f 91       	pop	r25
    4b64:	8f 91       	pop	r24
    4b66:	7f 91       	pop	r23
    4b68:	6f 91       	pop	r22
    4b6a:	5f 91       	pop	r21
    4b6c:	4f 91       	pop	r20
    4b6e:	3f 91       	pop	r19
    4b70:	2f 91       	pop	r18
    4b72:	0f 90       	pop	r0
    4b74:	0f be       	out	0x3f, r0	; 63
    4b76:	0f 90       	pop	r0
    4b78:	1f 90       	pop	r1
    4b7a:	18 95       	reti

00004b7c <uartSendTxBuffer>:
{
	uartAddToTxBuffer(3,data);
}

void uartSendTxBuffer(u08 nUart)
{
    4b7c:	1f 93       	push	r17
    4b7e:	18 2f       	mov	r17, r24
	// turn on buffered transmit
	uartBufferedTx[nUart] = TRUE;
    4b80:	90 e0       	ldi	r25, 0x00	; 0
    4b82:	fc 01       	movw	r30, r24
    4b84:	e6 57       	subi	r30, 0x76	; 118
    4b86:	fd 4e       	sbci	r31, 0xED	; 237
    4b88:	2f ef       	ldi	r18, 0xFF	; 255
    4b8a:	20 83       	st	Z, r18
	// send the first byte to get things going by interrupts
	uartSendByte(nUart, bufferGetFromFront(&uartTxBuffer[nUart]));
    4b8c:	43 e0       	ldi	r20, 0x03	; 3
    4b8e:	88 0f       	add	r24, r24
    4b90:	99 1f       	adc	r25, r25
    4b92:	4a 95       	dec	r20
    4b94:	e1 f7       	brne	.-8      	; 0x4b8e <uartSendTxBuffer+0x12>
    4b96:	82 57       	subi	r24, 0x72	; 114
    4b98:	9d 4e       	sbci	r25, 0xED	; 237
    4b9a:	0e 94 34 27 	call	0x4e68	; 0x4e68 <bufferGetFromFront>
    4b9e:	68 2f       	mov	r22, r24
    4ba0:	81 2f       	mov	r24, r17
    4ba2:	0e 94 45 23 	call	0x468a	; 0x468a <uartSendByte>
}
    4ba6:	1f 91       	pop	r17
    4ba8:	08 95       	ret

00004baa <uartReceiveByte>:
		return -1;
}


u08 uartReceiveByte(u08 nUart, u08* rxData)
{
    4baa:	cf 93       	push	r28
    4bac:	df 93       	push	r29
    4bae:	eb 01       	movw	r28, r22
	// make sure we have a receive buffer
	if(uartRxBuffer[nUart].size)
    4bb0:	28 2f       	mov	r18, r24
    4bb2:	30 e0       	ldi	r19, 0x00	; 0
    4bb4:	f9 01       	movw	r30, r18
    4bb6:	73 e0       	ldi	r23, 0x03	; 3
    4bb8:	ee 0f       	add	r30, r30
    4bba:	ff 1f       	adc	r31, r31
    4bbc:	7a 95       	dec	r23
    4bbe:	e1 f7       	brne	.-8      	; 0x4bb8 <uartReceiveByte+0xe>
    4bc0:	e4 59       	subi	r30, 0x94	; 148
    4bc2:	fd 4e       	sbci	r31, 0xED	; 237
    4bc4:	80 81       	ld	r24, Z
    4bc6:	91 81       	ldd	r25, Z+1	; 0x01
    4bc8:	89 2b       	or	r24, r25
    4bca:	c9 f0       	breq	.+50     	; 0x4bfe <uartReceiveByte+0x54>
	{
		// make sure we have data
		if(uartRxBuffer[nUart].datalength)
    4bcc:	f9 01       	movw	r30, r18
    4bce:	63 e0       	ldi	r22, 0x03	; 3
    4bd0:	ee 0f       	add	r30, r30
    4bd2:	ff 1f       	adc	r31, r31
    4bd4:	6a 95       	dec	r22
    4bd6:	e1 f7       	brne	.-8      	; 0x4bd0 <uartReceiveByte+0x26>
    4bd8:	e2 59       	subi	r30, 0x92	; 146
    4bda:	fd 4e       	sbci	r31, 0xED	; 237
    4bdc:	80 81       	ld	r24, Z
    4bde:	91 81       	ldd	r25, Z+1	; 0x01
    4be0:	89 2b       	or	r24, r25
    4be2:	69 f0       	breq	.+26     	; 0x4bfe <uartReceiveByte+0x54>
		{
			// get byte from beginning of buffer
			*rxData = bufferGetFromFront(&uartRxBuffer[nUart]);
    4be4:	53 e0       	ldi	r21, 0x03	; 3
    4be6:	22 0f       	add	r18, r18
    4be8:	33 1f       	adc	r19, r19
    4bea:	5a 95       	dec	r21
    4bec:	e1 f7       	brne	.-8      	; 0x4be6 <uartReceiveByte+0x3c>
    4bee:	c9 01       	movw	r24, r18
    4bf0:	86 59       	subi	r24, 0x96	; 150
    4bf2:	9d 4e       	sbci	r25, 0xED	; 237
    4bf4:	0e 94 34 27 	call	0x4e68	; 0x4e68 <bufferGetFromFront>
    4bf8:	88 83       	st	Y, r24
    4bfa:	8f ef       	ldi	r24, 0xFF	; 255
    4bfc:	01 c0       	rjmp	.+2      	; 0x4c00 <uartReceiveByte+0x56>
			return TRUE;
    4bfe:	80 e0       	ldi	r24, 0x00	; 0
		else
			return FALSE;			// no data
	}
	else
		return FALSE;				// no buffer
}
    4c00:	df 91       	pop	r29
    4c02:	cf 91       	pop	r28
    4c04:	08 95       	ret

00004c06 <uart3GetByte>:
	else
		return -1;
}

int uart3GetByte(void)
{
    4c06:	df 93       	push	r29
    4c08:	cf 93       	push	r28
    4c0a:	0f 92       	push	r0
    4c0c:	cd b7       	in	r28, 0x3d	; 61
    4c0e:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(3,&c))
    4c10:	83 e0       	ldi	r24, 0x03	; 3
    4c12:	be 01       	movw	r22, r28
    4c14:	6f 5f       	subi	r22, 0xFF	; 255
    4c16:	7f 4f       	sbci	r23, 0xFF	; 255
    4c18:	0e 94 d5 25 	call	0x4baa	; 0x4baa <uartReceiveByte>
    4c1c:	88 23       	and	r24, r24
    4c1e:	19 f4       	brne	.+6      	; 0x4c26 <uart3GetByte+0x20>
    4c20:	2f ef       	ldi	r18, 0xFF	; 255
    4c22:	3f ef       	ldi	r19, 0xFF	; 255
    4c24:	03 c0       	rjmp	.+6      	; 0x4c2c <uart3GetByte+0x26>
		return c;
    4c26:	89 81       	ldd	r24, Y+1	; 0x01
    4c28:	28 2f       	mov	r18, r24
    4c2a:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    4c2c:	c9 01       	movw	r24, r18
    4c2e:	0f 90       	pop	r0
    4c30:	cf 91       	pop	r28
    4c32:	df 91       	pop	r29
    4c34:	08 95       	ret

00004c36 <uart2GetByte>:
	else
		return -1;
}

int uart2GetByte(void)
{
    4c36:	df 93       	push	r29
    4c38:	cf 93       	push	r28
    4c3a:	0f 92       	push	r0
    4c3c:	cd b7       	in	r28, 0x3d	; 61
    4c3e:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(2,&c))
    4c40:	82 e0       	ldi	r24, 0x02	; 2
    4c42:	be 01       	movw	r22, r28
    4c44:	6f 5f       	subi	r22, 0xFF	; 255
    4c46:	7f 4f       	sbci	r23, 0xFF	; 255
    4c48:	0e 94 d5 25 	call	0x4baa	; 0x4baa <uartReceiveByte>
    4c4c:	88 23       	and	r24, r24
    4c4e:	19 f4       	brne	.+6      	; 0x4c56 <uart2GetByte+0x20>
    4c50:	2f ef       	ldi	r18, 0xFF	; 255
    4c52:	3f ef       	ldi	r19, 0xFF	; 255
    4c54:	03 c0       	rjmp	.+6      	; 0x4c5c <uart2GetByte+0x26>
		return c;
    4c56:	89 81       	ldd	r24, Y+1	; 0x01
    4c58:	28 2f       	mov	r18, r24
    4c5a:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    4c5c:	c9 01       	movw	r24, r18
    4c5e:	0f 90       	pop	r0
    4c60:	cf 91       	pop	r28
    4c62:	df 91       	pop	r29
    4c64:	08 95       	ret

00004c66 <uart1GetByte>:
	else
		return -1;
}

int uart1GetByte(void)
{
    4c66:	df 93       	push	r29
    4c68:	cf 93       	push	r28
    4c6a:	0f 92       	push	r0
    4c6c:	cd b7       	in	r28, 0x3d	; 61
    4c6e:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(1,&c))
    4c70:	81 e0       	ldi	r24, 0x01	; 1
    4c72:	be 01       	movw	r22, r28
    4c74:	6f 5f       	subi	r22, 0xFF	; 255
    4c76:	7f 4f       	sbci	r23, 0xFF	; 255
    4c78:	0e 94 d5 25 	call	0x4baa	; 0x4baa <uartReceiveByte>
    4c7c:	88 23       	and	r24, r24
    4c7e:	19 f4       	brne	.+6      	; 0x4c86 <uart1GetByte+0x20>
    4c80:	2f ef       	ldi	r18, 0xFF	; 255
    4c82:	3f ef       	ldi	r19, 0xFF	; 255
    4c84:	03 c0       	rjmp	.+6      	; 0x4c8c <uart1GetByte+0x26>
		return c;
    4c86:	89 81       	ldd	r24, Y+1	; 0x01
    4c88:	28 2f       	mov	r18, r24
    4c8a:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    4c8c:	c9 01       	movw	r24, r18
    4c8e:	0f 90       	pop	r0
    4c90:	cf 91       	pop	r28
    4c92:	df 91       	pop	r29
    4c94:	08 95       	ret

00004c96 <uart0GetByte>:
	// send byte on UART3
	uartSendByte(3, data);
}

int uart0GetByte(void)
{
    4c96:	df 93       	push	r29
    4c98:	cf 93       	push	r28
    4c9a:	0f 92       	push	r0
    4c9c:	cd b7       	in	r28, 0x3d	; 61
    4c9e:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(0,&c))
    4ca0:	80 e0       	ldi	r24, 0x00	; 0
    4ca2:	be 01       	movw	r22, r28
    4ca4:	6f 5f       	subi	r22, 0xFF	; 255
    4ca6:	7f 4f       	sbci	r23, 0xFF	; 255
    4ca8:	0e 94 d5 25 	call	0x4baa	; 0x4baa <uartReceiveByte>
    4cac:	88 23       	and	r24, r24
    4cae:	19 f4       	brne	.+6      	; 0x4cb6 <uart0GetByte+0x20>
    4cb0:	2f ef       	ldi	r18, 0xFF	; 255
    4cb2:	3f ef       	ldi	r19, 0xFF	; 255
    4cb4:	03 c0       	rjmp	.+6      	; 0x4cbc <uart0GetByte+0x26>
		return c;
    4cb6:	89 81       	ldd	r24, Y+1	; 0x01
    4cb8:	28 2f       	mov	r18, r24
    4cba:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    4cbc:	c9 01       	movw	r24, r18
    4cbe:	0f 90       	pop	r0
    4cc0:	cf 91       	pop	r28
    4cc2:	df 91       	pop	r29
    4cc4:	08 95       	ret

00004cc6 <uartFlushReceiveBuffer>:
}

void uartFlushReceiveBuffer(u08 nUart)
{
	// flush all data from receive buffer
	bufferFlush(&uartRxBuffer[nUart]);
    4cc6:	90 e0       	ldi	r25, 0x00	; 0
    4cc8:	e3 e0       	ldi	r30, 0x03	; 3
    4cca:	88 0f       	add	r24, r24
    4ccc:	99 1f       	adc	r25, r25
    4cce:	ea 95       	dec	r30
    4cd0:	e1 f7       	brne	.-8      	; 0x4cca <uartFlushReceiveBuffer+0x4>
    4cd2:	86 59       	subi	r24, 0x96	; 150
    4cd4:	9d 4e       	sbci	r25, 0xED	; 237
    4cd6:	0e 94 d0 27 	call	0x4fa0	; 0x4fa0 <bufferFlush>
}
    4cda:	08 95       	ret

00004cdc <uart3InitBuffers>:

void uart3InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART3 buffers
		bufferInit(&uartRxBuffer[3], (u08*) uart3RxData, UART3_RX_BUFFER_SIZE);
    4cdc:	82 e8       	ldi	r24, 0x82	; 130
    4cde:	92 e1       	ldi	r25, 0x12	; 18
    4ce0:	6f e4       	ldi	r22, 0x4F	; 79
    4ce2:	71 e1       	ldi	r23, 0x11	; 17
    4ce4:	40 e8       	ldi	r20, 0x80	; 128
    4ce6:	50 e0       	ldi	r21, 0x00	; 0
    4ce8:	0e 94 27 27 	call	0x4e4e	; 0x4e4e <bufferInit>
		bufferInit(&uartTxBuffer[3], (u08*) uart3TxData, UART3_TX_BUFFER_SIZE);
    4cec:	86 ea       	ldi	r24, 0xA6	; 166
    4cee:	92 e1       	ldi	r25, 0x12	; 18
    4cf0:	6f ec       	ldi	r22, 0xCF	; 207
    4cf2:	71 e1       	ldi	r23, 0x11	; 17
    4cf4:	40 e1       	ldi	r20, 0x10	; 16
    4cf6:	50 e0       	ldi	r21, 0x00	; 0
    4cf8:	0e 94 27 27 	call	0x4e4e	; 0x4e4e <bufferInit>
	#else
		// initialize the UART3 buffers
		bufferInit(&uartRxBuffer[3], (u08*) UART3_RX_BUFFER_ADDR, UART3_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[3], (u08*) UART3_TX_BUFFER_ADDR, UART3_TX_BUFFER_SIZE);
	#endif
}
    4cfc:	08 95       	ret

00004cfe <uart3Init>:
}

void uart3Init(void)
{
	// initialize the buffers
	uart3InitBuffers();
    4cfe:	0e 94 6e 26 	call	0x4cdc	; 0x4cdc <uart3InitBuffers>
	// initialize user receive handlers
	UartRxFunc[3] = 0;
    4d02:	10 92 e6 11 	sts	0x11E6, r1
    4d06:	10 92 e5 11 	sts	0x11E5, r1
	// enable RxD/TxD and interrupts
	outb(UCSR3B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    4d0a:	88 ed       	ldi	r24, 0xD8	; 216
    4d0c:	80 93 31 01 	sts	0x0131, r24
	// set default baud rate
	uartSetBaudRate(3, UART3_DEFAULT_BAUD_RATE);
    4d10:	83 e0       	ldi	r24, 0x03	; 3
    4d12:	40 e8       	ldi	r20, 0x80	; 128
    4d14:	55 e2       	ldi	r21, 0x25	; 37
    4d16:	60 e0       	ldi	r22, 0x00	; 0
    4d18:	70 e0       	ldi	r23, 0x00	; 0
    4d1a:	0e 94 f8 22 	call	0x45f0	; 0x45f0 <uartSetBaudRate>
	// initialize states
	uartReadyTx[3] = TRUE;
    4d1e:	8f ef       	ldi	r24, 0xFF	; 255
    4d20:	80 93 69 12 	sts	0x1269, r24
	uartBufferedTx[3] = FALSE;
    4d24:	10 92 8d 12 	sts	0x128D, r1
	// clear overflow count
	uartRxOverflow[3] = 0;
    4d28:	10 92 b5 12 	sts	0x12B5, r1
    4d2c:	10 92 b4 12 	sts	0x12B4, r1
	// enable interrupts
	sei();
    4d30:	78 94       	sei
}
    4d32:	08 95       	ret

00004d34 <uart2InitBuffers>:

void uart2InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART2 buffers
		bufferInit(&uartRxBuffer[2], (u08*) uart2RxData, UART2_RX_BUFFER_SIZE);
    4d34:	8a e7       	ldi	r24, 0x7A	; 122
    4d36:	92 e1       	ldi	r25, 0x12	; 18
    4d38:	6f eb       	ldi	r22, 0xBF	; 191
    4d3a:	70 e1       	ldi	r23, 0x10	; 16
    4d3c:	40 e8       	ldi	r20, 0x80	; 128
    4d3e:	50 e0       	ldi	r21, 0x00	; 0
    4d40:	0e 94 27 27 	call	0x4e4e	; 0x4e4e <bufferInit>
		bufferInit(&uartTxBuffer[2], (u08*) uart2TxData, UART2_TX_BUFFER_SIZE);
    4d44:	8e e9       	ldi	r24, 0x9E	; 158
    4d46:	92 e1       	ldi	r25, 0x12	; 18
    4d48:	6f e3       	ldi	r22, 0x3F	; 63
    4d4a:	71 e1       	ldi	r23, 0x11	; 17
    4d4c:	40 e1       	ldi	r20, 0x10	; 16
    4d4e:	50 e0       	ldi	r21, 0x00	; 0
    4d50:	0e 94 27 27 	call	0x4e4e	; 0x4e4e <bufferInit>
	#else
		// initialize the UART2 buffers
		bufferInit(&uartRxBuffer[2], (u08*) UART2_RX_BUFFER_ADDR, UART2_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[2], (u08*) UART2_TX_BUFFER_ADDR, UART2_TX_BUFFER_SIZE);
	#endif
}
    4d54:	08 95       	ret

00004d56 <uart2Init>:
}

void uart2Init(void)
{
	// initialize the buffers
	uart2InitBuffers();
    4d56:	0e 94 9a 26 	call	0x4d34	; 0x4d34 <uart2InitBuffers>
	// initialize user receive handlers
	UartRxFunc[2] = 0;
    4d5a:	10 92 e4 11 	sts	0x11E4, r1
    4d5e:	10 92 e3 11 	sts	0x11E3, r1
	// enable RxD/TxD and interrupts
	outb(UCSR2B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    4d62:	88 ed       	ldi	r24, 0xD8	; 216
    4d64:	80 93 d1 00 	sts	0x00D1, r24
	// set default baud rate
	uartSetBaudRate(2, UART2_DEFAULT_BAUD_RATE);
    4d68:	82 e0       	ldi	r24, 0x02	; 2
    4d6a:	40 e8       	ldi	r20, 0x80	; 128
    4d6c:	55 e2       	ldi	r21, 0x25	; 37
    4d6e:	60 e0       	ldi	r22, 0x00	; 0
    4d70:	70 e0       	ldi	r23, 0x00	; 0
    4d72:	0e 94 f8 22 	call	0x45f0	; 0x45f0 <uartSetBaudRate>
	// initialize states
	uartReadyTx[2] = TRUE;
    4d76:	8f ef       	ldi	r24, 0xFF	; 255
    4d78:	80 93 68 12 	sts	0x1268, r24
	uartBufferedTx[2] = FALSE;
    4d7c:	10 92 8c 12 	sts	0x128C, r1
	// clear overflow count
	uartRxOverflow[2] = 0;
    4d80:	10 92 b3 12 	sts	0x12B3, r1
    4d84:	10 92 b2 12 	sts	0x12B2, r1
	// enable interrupts
	sei();
    4d88:	78 94       	sei
}
    4d8a:	08 95       	ret

00004d8c <uart1InitBuffers>:

void uart1InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART1 buffers
		bufferInit(&uartRxBuffer[1], (u08*) uart1RxData, UART1_RX_BUFFER_SIZE);
    4d8c:	82 e7       	ldi	r24, 0x72	; 114
    4d8e:	92 e1       	ldi	r25, 0x12	; 18
    4d90:	6f e2       	ldi	r22, 0x2F	; 47
    4d92:	70 e1       	ldi	r23, 0x10	; 16
    4d94:	40 e8       	ldi	r20, 0x80	; 128
    4d96:	50 e0       	ldi	r21, 0x00	; 0
    4d98:	0e 94 27 27 	call	0x4e4e	; 0x4e4e <bufferInit>
		bufferInit(&uartTxBuffer[1], (u08*) uart1TxData, UART1_TX_BUFFER_SIZE);
    4d9c:	86 e9       	ldi	r24, 0x96	; 150
    4d9e:	92 e1       	ldi	r25, 0x12	; 18
    4da0:	6f ea       	ldi	r22, 0xAF	; 175
    4da2:	70 e1       	ldi	r23, 0x10	; 16
    4da4:	40 e1       	ldi	r20, 0x10	; 16
    4da6:	50 e0       	ldi	r21, 0x00	; 0
    4da8:	0e 94 27 27 	call	0x4e4e	; 0x4e4e <bufferInit>
	#else
		// initialize the UART1 buffers
		bufferInit(&uartRxBuffer[1], (u08*) UART1_RX_BUFFER_ADDR, UART1_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[1], (u08*) UART1_TX_BUFFER_ADDR, UART1_TX_BUFFER_SIZE);
	#endif
}
    4dac:	08 95       	ret

00004dae <uart1Init>:
}

void uart1Init(void)
{
	// initialize the buffers
	uart1InitBuffers();
    4dae:	0e 94 c6 26 	call	0x4d8c	; 0x4d8c <uart1InitBuffers>
	// initialize user receive handlers
	UartRxFunc[1] = 0;
    4db2:	10 92 e2 11 	sts	0x11E2, r1
    4db6:	10 92 e1 11 	sts	0x11E1, r1
	// enable RxD/TxD and interrupts
	outb(UCSR1B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    4dba:	88 ed       	ldi	r24, 0xD8	; 216
    4dbc:	80 93 c9 00 	sts	0x00C9, r24
	// set default baud rate
	uartSetBaudRate(1, UART1_DEFAULT_BAUD_RATE);
    4dc0:	81 e0       	ldi	r24, 0x01	; 1
    4dc2:	40 e8       	ldi	r20, 0x80	; 128
    4dc4:	55 e2       	ldi	r21, 0x25	; 37
    4dc6:	60 e0       	ldi	r22, 0x00	; 0
    4dc8:	70 e0       	ldi	r23, 0x00	; 0
    4dca:	0e 94 f8 22 	call	0x45f0	; 0x45f0 <uartSetBaudRate>
	// initialize states
	uartReadyTx[1] = TRUE;
    4dce:	8f ef       	ldi	r24, 0xFF	; 255
    4dd0:	80 93 67 12 	sts	0x1267, r24
	uartBufferedTx[1] = FALSE;
    4dd4:	10 92 8b 12 	sts	0x128B, r1
	// clear overflow count
	uartRxOverflow[1] = 0;
    4dd8:	10 92 b1 12 	sts	0x12B1, r1
    4ddc:	10 92 b0 12 	sts	0x12B0, r1
	// enable interrupts
	sei();
    4de0:	78 94       	sei
}
    4de2:	08 95       	ret

00004de4 <uart0InitBuffers>:

void uart0InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART0 buffers
		bufferInit(&uartRxBuffer[0], (u08*) uart0RxData, UART0_RX_BUFFER_SIZE);
    4de4:	8a e6       	ldi	r24, 0x6A	; 106
    4de6:	92 e1       	ldi	r25, 0x12	; 18
    4de8:	6f e9       	ldi	r22, 0x9F	; 159
    4dea:	7f e0       	ldi	r23, 0x0F	; 15
    4dec:	40 e8       	ldi	r20, 0x80	; 128
    4dee:	50 e0       	ldi	r21, 0x00	; 0
    4df0:	0e 94 27 27 	call	0x4e4e	; 0x4e4e <bufferInit>
		bufferInit(&uartTxBuffer[0], (u08*) uart0TxData, UART0_TX_BUFFER_SIZE);
    4df4:	8e e8       	ldi	r24, 0x8E	; 142
    4df6:	92 e1       	ldi	r25, 0x12	; 18
    4df8:	6f e1       	ldi	r22, 0x1F	; 31
    4dfa:	70 e1       	ldi	r23, 0x10	; 16
    4dfc:	40 e1       	ldi	r20, 0x10	; 16
    4dfe:	50 e0       	ldi	r21, 0x00	; 0
    4e00:	0e 94 27 27 	call	0x4e4e	; 0x4e4e <bufferInit>
	#else
		// initialize the UART0 buffers
		bufferInit(&uartRxBuffer[0], (u08*) UART0_RX_BUFFER_ADDR, UART0_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[0], (u08*) UART0_TX_BUFFER_ADDR, UART0_TX_BUFFER_SIZE);
	#endif
}
    4e04:	08 95       	ret

00004e06 <uart0Init>:
}

void uart0Init(void)
{
	// initialize the buffers
	uart0InitBuffers();
    4e06:	0e 94 f2 26 	call	0x4de4	; 0x4de4 <uart0InitBuffers>
	// initialize user receive handlers
	UartRxFunc[0] = 0;
    4e0a:	10 92 e0 11 	sts	0x11E0, r1
    4e0e:	10 92 df 11 	sts	0x11DF, r1
	// enable RxD/TxD and interrupts
	outb(UCSR0B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    4e12:	88 ed       	ldi	r24, 0xD8	; 216
    4e14:	80 93 c1 00 	sts	0x00C1, r24
	// set default baud rate
	uartSetBaudRate(0, UART0_DEFAULT_BAUD_RATE); 
    4e18:	80 e0       	ldi	r24, 0x00	; 0
    4e1a:	40 e8       	ldi	r20, 0x80	; 128
    4e1c:	55 e2       	ldi	r21, 0x25	; 37
    4e1e:	60 e0       	ldi	r22, 0x00	; 0
    4e20:	70 e0       	ldi	r23, 0x00	; 0
    4e22:	0e 94 f8 22 	call	0x45f0	; 0x45f0 <uartSetBaudRate>
	// initialize states
	uartReadyTx[0] = TRUE;
    4e26:	8f ef       	ldi	r24, 0xFF	; 255
    4e28:	80 93 66 12 	sts	0x1266, r24
	uartBufferedTx[0] = FALSE;
    4e2c:	10 92 8a 12 	sts	0x128A, r1
	// clear overflow count
	uartRxOverflow[0] = 0;
    4e30:	10 92 af 12 	sts	0x12AF, r1
    4e34:	10 92 ae 12 	sts	0x12AE, r1
	// enable interrupts
	sei();
    4e38:	78 94       	sei
}
    4e3a:	08 95       	ret

00004e3c <uartInit>:
volatile static voidFuncPtru08 UartRxFunc[4];

void uartInit(void)
{
	// initialize all uarts
	uart0Init();
    4e3c:	0e 94 03 27 	call	0x4e06	; 0x4e06 <uart0Init>
	uart1Init();
    4e40:	0e 94 d7 26 	call	0x4dae	; 0x4dae <uart1Init>
	uart2Init();
    4e44:	0e 94 ab 26 	call	0x4d56	; 0x4d56 <uart2Init>
	uart3Init();
    4e48:	0e 94 7f 26 	call	0x4cfe	; 0x4cfe <uart3Init>
}
    4e4c:	08 95       	ret

00004e4e <bufferInit>:
// global variables

// initialization

void bufferInit(cBuffer* buffer, unsigned char *start, unsigned short size)
{
    4e4e:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    4e50:	8f b7       	in	r24, 0x3f	; 63
    4e52:	f8 94       	cli
	// set start pointer of the buffer
	buffer->dataptr = start;
    4e54:	71 83       	std	Z+1, r23	; 0x01
    4e56:	60 83       	st	Z, r22
	buffer->size = size;
    4e58:	53 83       	std	Z+3, r21	; 0x03
    4e5a:	42 83       	std	Z+2, r20	; 0x02
	// initialize index and length
	buffer->dataindex = 0;
    4e5c:	17 82       	std	Z+7, r1	; 0x07
    4e5e:	16 82       	std	Z+6, r1	; 0x06
	buffer->datalength = 0;
    4e60:	15 82       	std	Z+5, r1	; 0x05
    4e62:	14 82       	std	Z+4, r1	; 0x04
	// end critical section
	CRITICAL_SECTION_END;
    4e64:	8f bf       	out	0x3f, r24	; 63
}
    4e66:	08 95       	ret

00004e68 <bufferGetFromFront>:

// access routines
unsigned char  bufferGetFromFront(cBuffer* buffer)
{
    4e68:	dc 01       	movw	r26, r24
	unsigned char data = 0;
	// begin critical section
	CRITICAL_SECTION_START;
    4e6a:	4f b7       	in	r20, 0x3f	; 63
    4e6c:	f8 94       	cli
	// check to see if there's data in the buffer
	if(buffer->datalength)
    4e6e:	14 96       	adiw	r26, 0x04	; 4
    4e70:	8d 91       	ld	r24, X+
    4e72:	9c 91       	ld	r25, X
    4e74:	15 97       	sbiw	r26, 0x05	; 5
    4e76:	89 2b       	or	r24, r25
    4e78:	11 f4       	brne	.+4      	; 0x4e7e <bufferGetFromFront+0x16>
    4e7a:	e0 e0       	ldi	r30, 0x00	; 0
    4e7c:	25 c0       	rjmp	.+74     	; 0x4ec8 <bufferGetFromFront+0x60>
	{
		// get the first character from buffer
		data = buffer->dataptr[buffer->dataindex];
    4e7e:	16 96       	adiw	r26, 0x06	; 6
    4e80:	8d 91       	ld	r24, X+
    4e82:	9c 91       	ld	r25, X
    4e84:	17 97       	sbiw	r26, 0x07	; 7
    4e86:	ed 91       	ld	r30, X+
    4e88:	fc 91       	ld	r31, X
    4e8a:	11 97       	sbiw	r26, 0x01	; 1
    4e8c:	e8 0f       	add	r30, r24
    4e8e:	f9 1f       	adc	r31, r25
    4e90:	e0 81       	ld	r30, Z
		// move index down and decrement length
		buffer->dataindex++;
    4e92:	01 96       	adiw	r24, 0x01	; 1
    4e94:	17 96       	adiw	r26, 0x07	; 7
    4e96:	9c 93       	st	X, r25
    4e98:	8e 93       	st	-X, r24
    4e9a:	16 97       	sbiw	r26, 0x06	; 6
		if(buffer->dataindex >= buffer->size)
    4e9c:	12 96       	adiw	r26, 0x02	; 2
    4e9e:	2d 91       	ld	r18, X+
    4ea0:	3c 91       	ld	r19, X
    4ea2:	13 97       	sbiw	r26, 0x03	; 3
    4ea4:	82 17       	cp	r24, r18
    4ea6:	93 07       	cpc	r25, r19
    4ea8:	30 f0       	brcs	.+12     	; 0x4eb6 <bufferGetFromFront+0x4e>
		{
			buffer->dataindex -= buffer->size;
    4eaa:	82 1b       	sub	r24, r18
    4eac:	93 0b       	sbc	r25, r19
    4eae:	17 96       	adiw	r26, 0x07	; 7
    4eb0:	9c 93       	st	X, r25
    4eb2:	8e 93       	st	-X, r24
    4eb4:	16 97       	sbiw	r26, 0x06	; 6
		}
		buffer->datalength--;
    4eb6:	14 96       	adiw	r26, 0x04	; 4
    4eb8:	8d 91       	ld	r24, X+
    4eba:	9c 91       	ld	r25, X
    4ebc:	15 97       	sbiw	r26, 0x05	; 5
    4ebe:	01 97       	sbiw	r24, 0x01	; 1
    4ec0:	15 96       	adiw	r26, 0x05	; 5
    4ec2:	9c 93       	st	X, r25
    4ec4:	8e 93       	st	-X, r24
    4ec6:	14 97       	sbiw	r26, 0x04	; 4
	}
	// end critical section
	CRITICAL_SECTION_END;
    4ec8:	4f bf       	out	0x3f, r20	; 63
	// return
	return data;
}
    4eca:	8e 2f       	mov	r24, r30
    4ecc:	08 95       	ret

00004ece <bufferDumpFromFront>:

void bufferDumpFromFront(cBuffer* buffer, unsigned short numbytes)
{
    4ece:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    4ed0:	4f b7       	in	r20, 0x3f	; 63
    4ed2:	f8 94       	cli
	// dump numbytes from the front of the buffer
	// are we dumping less than the entire buffer?
	if(numbytes < buffer->datalength)
    4ed4:	84 81       	ldd	r24, Z+4	; 0x04
    4ed6:	95 81       	ldd	r25, Z+5	; 0x05
    4ed8:	68 17       	cp	r22, r24
    4eda:	79 07       	cpc	r23, r25
    4edc:	b0 f4       	brcc	.+44     	; 0x4f0a <bufferDumpFromFront+0x3c>
	{
		// move index down by numbytes and decrement length by numbytes
		buffer->dataindex += numbytes;
    4ede:	86 81       	ldd	r24, Z+6	; 0x06
    4ee0:	97 81       	ldd	r25, Z+7	; 0x07
    4ee2:	86 0f       	add	r24, r22
    4ee4:	97 1f       	adc	r25, r23
    4ee6:	97 83       	std	Z+7, r25	; 0x07
    4ee8:	86 83       	std	Z+6, r24	; 0x06
		if(buffer->dataindex >= buffer->size)
    4eea:	22 81       	ldd	r18, Z+2	; 0x02
    4eec:	33 81       	ldd	r19, Z+3	; 0x03
    4eee:	82 17       	cp	r24, r18
    4ef0:	93 07       	cpc	r25, r19
    4ef2:	20 f0       	brcs	.+8      	; 0x4efc <bufferDumpFromFront+0x2e>
		{
			buffer->dataindex -= buffer->size;
    4ef4:	82 1b       	sub	r24, r18
    4ef6:	93 0b       	sbc	r25, r19
    4ef8:	97 83       	std	Z+7, r25	; 0x07
    4efa:	86 83       	std	Z+6, r24	; 0x06
		}
		buffer->datalength -= numbytes;
    4efc:	84 81       	ldd	r24, Z+4	; 0x04
    4efe:	95 81       	ldd	r25, Z+5	; 0x05
    4f00:	86 1b       	sub	r24, r22
    4f02:	97 0b       	sbc	r25, r23
    4f04:	95 83       	std	Z+5, r25	; 0x05
    4f06:	84 83       	std	Z+4, r24	; 0x04
    4f08:	02 c0       	rjmp	.+4      	; 0x4f0e <bufferDumpFromFront+0x40>
	}
	else
	{
		// flush the whole buffer
		buffer->datalength = 0;
    4f0a:	15 82       	std	Z+5, r1	; 0x05
    4f0c:	14 82       	std	Z+4, r1	; 0x04
	}
	// end critical section
	CRITICAL_SECTION_END;
    4f0e:	4f bf       	out	0x3f, r20	; 63
}
    4f10:	08 95       	ret

00004f12 <bufferGetAtIndex>:

unsigned char bufferGetAtIndex(cBuffer* buffer, unsigned short index)
{
    4f12:	fc 01       	movw	r30, r24
    4f14:	cb 01       	movw	r24, r22
	// begin critical section
	CRITICAL_SECTION_START;
    4f16:	2f b7       	in	r18, 0x3f	; 63
    4f18:	f8 94       	cli
	// return character at index in buffer
	unsigned char data = buffer->dataptr[(buffer->dataindex+index)%(buffer->size)];
	// end critical section
	CRITICAL_SECTION_END;
    4f1a:	2f bf       	out	0x3f, r18	; 63
    4f1c:	26 81       	ldd	r18, Z+6	; 0x06
    4f1e:	37 81       	ldd	r19, Z+7	; 0x07
    4f20:	62 81       	ldd	r22, Z+2	; 0x02
    4f22:	73 81       	ldd	r23, Z+3	; 0x03
    4f24:	82 0f       	add	r24, r18
    4f26:	93 1f       	adc	r25, r19
    4f28:	0e 94 f9 2f 	call	0x5ff2	; 0x5ff2 <__udivmodhi4>
    4f2c:	01 90       	ld	r0, Z+
    4f2e:	f0 81       	ld	r31, Z
    4f30:	e0 2d       	mov	r30, r0
    4f32:	e8 0f       	add	r30, r24
    4f34:	f9 1f       	adc	r31, r25
	return data;
}
    4f36:	80 81       	ld	r24, Z
    4f38:	08 95       	ret

00004f3a <bufferAddToEnd>:

unsigned char bufferAddToEnd(cBuffer* buffer, unsigned char data)
{
    4f3a:	1f 93       	push	r17
    4f3c:	cf 93       	push	r28
    4f3e:	df 93       	push	r29
    4f40:	ec 01       	movw	r28, r24
    4f42:	16 2f       	mov	r17, r22
	// begin critical section
	CRITICAL_SECTION_START;
    4f44:	4f b7       	in	r20, 0x3f	; 63
    4f46:	f8 94       	cli
	// make sure the buffer has room
	if(buffer->datalength < buffer->size)
    4f48:	2c 81       	ldd	r18, Y+4	; 0x04
    4f4a:	3d 81       	ldd	r19, Y+5	; 0x05
    4f4c:	6a 81       	ldd	r22, Y+2	; 0x02
    4f4e:	7b 81       	ldd	r23, Y+3	; 0x03
    4f50:	26 17       	cp	r18, r22
    4f52:	37 07       	cpc	r19, r23
    4f54:	98 f4       	brcc	.+38     	; 0x4f7c <bufferAddToEnd+0x42>
	{
		// save data byte at end of buffer
		buffer->dataptr[(buffer->dataindex + buffer->datalength) % buffer->size] = data;
    4f56:	8e 81       	ldd	r24, Y+6	; 0x06
    4f58:	9f 81       	ldd	r25, Y+7	; 0x07
    4f5a:	82 0f       	add	r24, r18
    4f5c:	93 1f       	adc	r25, r19
    4f5e:	0e 94 f9 2f 	call	0x5ff2	; 0x5ff2 <__udivmodhi4>
    4f62:	e8 81       	ld	r30, Y
    4f64:	f9 81       	ldd	r31, Y+1	; 0x01
    4f66:	e8 0f       	add	r30, r24
    4f68:	f9 1f       	adc	r31, r25
    4f6a:	10 83       	st	Z, r17
		// increment the length
		buffer->datalength++;
    4f6c:	8c 81       	ldd	r24, Y+4	; 0x04
    4f6e:	9d 81       	ldd	r25, Y+5	; 0x05
    4f70:	01 96       	adiw	r24, 0x01	; 1
    4f72:	9d 83       	std	Y+5, r25	; 0x05
    4f74:	8c 83       	std	Y+4, r24	; 0x04
		// end critical section
		CRITICAL_SECTION_END;
    4f76:	4f bf       	out	0x3f, r20	; 63
    4f78:	8f ef       	ldi	r24, 0xFF	; 255
    4f7a:	02 c0       	rjmp	.+4      	; 0x4f80 <bufferAddToEnd+0x46>
		// return success
		return -1;
	}
	// end critical section
	CRITICAL_SECTION_END;
    4f7c:	4f bf       	out	0x3f, r20	; 63
    4f7e:	80 e0       	ldi	r24, 0x00	; 0
	// return failure
	return 0;
}
    4f80:	df 91       	pop	r29
    4f82:	cf 91       	pop	r28
    4f84:	1f 91       	pop	r17
    4f86:	08 95       	ret

00004f88 <bufferIsNotFull>:

unsigned short bufferIsNotFull(cBuffer* buffer)
{
    4f88:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    4f8a:	8f b7       	in	r24, 0x3f	; 63
    4f8c:	f8 94       	cli
	// check to see if the buffer has room
	// return true if there is room
	unsigned short bytesleft = (buffer->size - buffer->datalength);
	// end critical section
	CRITICAL_SECTION_END;
    4f8e:	8f bf       	out	0x3f, r24	; 63
    4f90:	22 81       	ldd	r18, Z+2	; 0x02
    4f92:	33 81       	ldd	r19, Z+3	; 0x03
    4f94:	84 81       	ldd	r24, Z+4	; 0x04
    4f96:	95 81       	ldd	r25, Z+5	; 0x05
    4f98:	28 1b       	sub	r18, r24
    4f9a:	39 0b       	sbc	r19, r25
	return bytesleft;
}
    4f9c:	c9 01       	movw	r24, r18
    4f9e:	08 95       	ret

00004fa0 <bufferFlush>:

void bufferFlush(cBuffer* buffer)
{
    4fa0:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    4fa2:	8f b7       	in	r24, 0x3f	; 63
    4fa4:	f8 94       	cli
	// flush contents of the buffer
	buffer->datalength = 0;
    4fa6:	15 82       	std	Z+5, r1	; 0x05
    4fa8:	14 82       	std	Z+4, r1	; 0x04
	// end critical section
	CRITICAL_SECTION_END;
    4faa:	8f bf       	out	0x3f, r24	; 63
}
    4fac:	08 95       	ret

00004fae <a2dInit>:
// functions

// initialize a2d converter
void a2dInit(void)
{
	sbi(ADCSR, ADEN);				// enable ADC (turn on ADC power)
    4fae:	aa e7       	ldi	r26, 0x7A	; 122
    4fb0:	b0 e0       	ldi	r27, 0x00	; 0
    4fb2:	8c 91       	ld	r24, X
    4fb4:	80 68       	ori	r24, 0x80	; 128
    4fb6:	8c 93       	st	X, r24
	cbi(ADCSR, ADFR);				// default to single sample convert mode
    4fb8:	8c 91       	ld	r24, X
    4fba:	8f 7d       	andi	r24, 0xDF	; 223
    4fbc:	8c 93       	st	X, r24
}

// configure A2D converter clock division (prescaling)
void a2dSetPrescaler(unsigned char prescale)
{
	outb(ADCSR, ((inb(ADCSR) & ~ADC_PRESCALE_MASK) | prescale));
    4fbe:	8c 91       	ld	r24, X
    4fc0:	88 7f       	andi	r24, 0xF8	; 248
    4fc2:	86 60       	ori	r24, 0x06	; 6
    4fc4:	8c 93       	st	X, r24
}

// configure A2D converter voltage reference
void a2dSetReference(unsigned char ref)
{
	outb(ADMUX, ((inb(ADMUX) & ~ADC_REFERENCE_MASK) | (ref<<6)));
    4fc6:	ec e7       	ldi	r30, 0x7C	; 124
    4fc8:	f0 e0       	ldi	r31, 0x00	; 0
    4fca:	80 81       	ld	r24, Z
    4fcc:	8f 73       	andi	r24, 0x3F	; 63
    4fce:	80 64       	ori	r24, 0x40	; 64
    4fd0:	80 83       	st	Z, r24
{
	sbi(ADCSR, ADEN);				// enable ADC (turn on ADC power)
	cbi(ADCSR, ADFR);				// default to single sample convert mode
	a2dSetPrescaler(ADC_PRESCALE);	// set default prescaler
	a2dSetReference(ADC_REFERENCE);	// set default reference
	cbi(ADMUX, ADLAR);				// set to right-adjusted result
    4fd2:	80 81       	ld	r24, Z
    4fd4:	8f 7d       	andi	r24, 0xDF	; 223
    4fd6:	80 83       	st	Z, r24

	sbi(ADCSR, ADIE);				// enable ADC interrupts
    4fd8:	8c 91       	ld	r24, X
    4fda:	88 60       	ori	r24, 0x08	; 8
    4fdc:	8c 93       	st	X, r24

	a2dCompleteFlag = FALSE;		// clear conversion complete flag
    4fde:	10 92 b6 12 	sts	0x12B6, r1
	sei();							// turn on interrupts (if not already on)
    4fe2:	78 94       	sei
}
    4fe4:	08 95       	ret

00004fe6 <a2dOff>:

// turn off a2d converter
void a2dOff(void)
{
	cbi(ADCSR, ADIE);				// disable ADC interrupts
    4fe6:	ea e7       	ldi	r30, 0x7A	; 122
    4fe8:	f0 e0       	ldi	r31, 0x00	; 0
    4fea:	80 81       	ld	r24, Z
    4fec:	87 7f       	andi	r24, 0xF7	; 247
    4fee:	80 83       	st	Z, r24
	cbi(ADCSR, ADEN);				// disable ADC (turn off ADC power)
    4ff0:	80 81       	ld	r24, Z
    4ff2:	8f 77       	andi	r24, 0x7F	; 127
    4ff4:	80 83       	st	Z, r24
}
    4ff6:	08 95       	ret

00004ff8 <a2dSetPrescaler>:

// configure A2D converter clock division (prescaling)
void a2dSetPrescaler(unsigned char prescale)
{
	outb(ADCSR, ((inb(ADCSR) & ~ADC_PRESCALE_MASK) | prescale));
    4ff8:	ea e7       	ldi	r30, 0x7A	; 122
    4ffa:	f0 e0       	ldi	r31, 0x00	; 0
    4ffc:	90 81       	ld	r25, Z
    4ffe:	98 7f       	andi	r25, 0xF8	; 248
    5000:	98 2b       	or	r25, r24
    5002:	90 83       	st	Z, r25
}
    5004:	08 95       	ret

00005006 <a2dSetReference>:

// configure A2D converter voltage reference
void a2dSetReference(unsigned char ref)
{
	outb(ADMUX, ((inb(ADMUX) & ~ADC_REFERENCE_MASK) | (ref<<6)));
    5006:	ec e7       	ldi	r30, 0x7C	; 124
    5008:	f0 e0       	ldi	r31, 0x00	; 0
    500a:	90 81       	ld	r25, Z
    500c:	82 95       	swap	r24
    500e:	88 0f       	add	r24, r24
    5010:	88 0f       	add	r24, r24
    5012:	80 7c       	andi	r24, 0xC0	; 192
    5014:	9f 73       	andi	r25, 0x3F	; 63
    5016:	98 2b       	or	r25, r24
    5018:	90 83       	st	Z, r25
}
    501a:	08 95       	ret

0000501c <a2dSetChannel>:

// sets the a2d input channel
void a2dSetChannel(unsigned char ch)
{
	outb(ADMUX, (inb(ADMUX) & ~ADC_MUX_MASK) | (ch & ADC_MUX_MASK));	// set channel
    501c:	ec e7       	ldi	r30, 0x7C	; 124
    501e:	f0 e0       	ldi	r31, 0x00	; 0
    5020:	90 81       	ld	r25, Z
    5022:	8f 71       	andi	r24, 0x1F	; 31
    5024:	90 7e       	andi	r25, 0xE0	; 224
    5026:	89 2b       	or	r24, r25
    5028:	80 83       	st	Z, r24
}
    502a:	08 95       	ret

0000502c <a2dStartConvert>:

// start a conversion on the current a2d input channel
void a2dStartConvert(void)
{
	sbi(ADCSR, ADIF);	// clear hardware "conversion complete" flag 
    502c:	ea e7       	ldi	r30, 0x7A	; 122
    502e:	f0 e0       	ldi	r31, 0x00	; 0
    5030:	80 81       	ld	r24, Z
    5032:	80 61       	ori	r24, 0x10	; 16
    5034:	80 83       	st	Z, r24
	sbi(ADCSR, ADSC);	// start conversion
    5036:	80 81       	ld	r24, Z
    5038:	80 64       	ori	r24, 0x40	; 64
    503a:	80 83       	st	Z, r24
}
    503c:	08 95       	ret

0000503e <a2dIsComplete>:

// return TRUE if conversion is complete
u08 a2dIsComplete(void)
{
	return bit_is_set(ADCSR, ADSC);
    503e:	80 91 7a 00 	lds	r24, 0x007A
}
    5042:	80 74       	andi	r24, 0x40	; 64
    5044:	08 95       	ret

00005046 <a2dConvert10bit>:

// Perform a 10-bit conversion
// starts conversion, waits until conversion is done, and returns result
unsigned short a2dConvert10bit(unsigned char ch)
{
    5046:	98 2f       	mov	r25, r24
	a2dCompleteFlag = FALSE;				// clear conversion complete flag
    5048:	10 92 b6 12 	sts	0x12B6, r1

if (ch >= 8)
    504c:	88 30       	cpi	r24, 0x08	; 8
    504e:	20 f0       	brcs	.+8      	; 0x5058 <a2dConvert10bit+0x12>
    ADCSRB |= _BV(MUX5);
    5050:	80 91 7b 00 	lds	r24, 0x007B
    5054:	88 60       	ori	r24, 0x08	; 8
    5056:	03 c0       	rjmp	.+6      	; 0x505e <a2dConvert10bit+0x18>
else
    ADCSRB &= ~_BV(MUX5);
    5058:	80 91 7b 00 	lds	r24, 0x007B
    505c:	87 7f       	andi	r24, 0xF7	; 247
    505e:	80 93 7b 00 	sts	0x007B, r24

   outb(ADMUX, (inb(ADMUX) & ~7) | (ch & 7));   // set channel
    5062:	80 91 7c 00 	lds	r24, 0x007C
    5066:	97 70       	andi	r25, 0x07	; 7
    5068:	88 7f       	andi	r24, 0xF8	; 248
    506a:	89 2b       	or	r24, r25
    506c:	80 93 7c 00 	sts	0x007C, r24

	//outb(ADMUX, (inb(ADMUX) & ~ADC_MUX_MASK) | (ch & ADC_MUX_MASK));	// set channel
	sbi(ADCSR, ADIF);						// clear hardware "conversion complete" flag 
    5070:	80 91 7a 00 	lds	r24, 0x007A
    5074:	80 61       	ori	r24, 0x10	; 16
    5076:	80 93 7a 00 	sts	0x007A, r24
	sbi(ADCSR, ADSC);						// start conversion
    507a:	80 91 7a 00 	lds	r24, 0x007A
    507e:	80 64       	ori	r24, 0x40	; 64
    5080:	80 93 7a 00 	sts	0x007A, r24
	//while(!a2dCompleteFlag);				// wait until conversion complete
	//while( bit_is_clear(ADCSR, ADIF) );		// wait until conversion complete
	while( bit_is_set(ADCSR, ADSC) );		// wait until conversion complete
    5084:	80 91 7a 00 	lds	r24, 0x007A
    5088:	86 fd       	sbrc	r24, 6
    508a:	fc cf       	rjmp	.-8      	; 0x5084 <a2dConvert10bit+0x3e>

	// CAUTION: MUST READ ADCL BEFORE ADCH!!!
	//return (inb(ADCL) | (inb(ADCH)<<8));	// read ADC (full 10 bits) //old version
	return ADC;//new version code
    508c:	20 91 78 00 	lds	r18, 0x0078
    5090:	30 91 79 00 	lds	r19, 0x0079
}
    5094:	c9 01       	movw	r24, r18
    5096:	08 95       	ret

00005098 <a2dConvert8bit>:
// Perform a 8-bit conversion.
// starts conversion, waits until conversion is done, and returns result
unsigned char a2dConvert8bit(unsigned char ch)
{
	// do 10-bit conversion and return highest 8 bits
	return a2dConvert10bit(ch)>>2;			// return ADC MSB byte
    5098:	0e 94 23 28 	call	0x5046	; 0x5046 <a2dConvert10bit>
    509c:	96 95       	lsr	r25
    509e:	87 95       	ror	r24
    50a0:	96 95       	lsr	r25
    50a2:	87 95       	ror	r24
}
    50a4:	08 95       	ret

000050a6 <__vector_29>:

//! Interrupt handler for ADC complete interrupt.
SIGNAL(SIG_ADC)
{
    50a6:	1f 92       	push	r1
    50a8:	0f 92       	push	r0
    50aa:	0f b6       	in	r0, 0x3f	; 63
    50ac:	0f 92       	push	r0
    50ae:	11 24       	eor	r1, r1
    50b0:	8f 93       	push	r24
	// set the a2d conversion flag to indicate "complete"
	a2dCompleteFlag = TRUE;
    50b2:	8f ef       	ldi	r24, 0xFF	; 255
    50b4:	80 93 b6 12 	sts	0x12B6, r24
}
    50b8:	8f 91       	pop	r24
    50ba:	0f 90       	pop	r0
    50bc:	0f be       	out	0x3f, r0	; 63
    50be:	0f 90       	pop	r0
    50c0:	1f 90       	pop	r1
    50c2:	18 95       	reti

000050c4 <rprintfInit>:
// *** rprintf initialization ***
// you must call this function once and supply the character output
// routine before using other functions in this library
void rprintfInit(void (*putchar_func)(unsigned char c))
{
	rputchar = putchar_func;
    50c4:	90 93 e8 11 	sts	0x11E8, r25
    50c8:	80 93 e7 11 	sts	0x11E7, r24
}
    50cc:	08 95       	ret

000050ce <rprintfChar>:

// *** rprintfChar ***
// send a character/byte to the current output device
void rprintfChar(unsigned char c)
{
    50ce:	1f 93       	push	r17
    50d0:	18 2f       	mov	r17, r24
	// do LF -> CR/LF translation
	if(c == '\n')
    50d2:	8a 30       	cpi	r24, 0x0A	; 10
    50d4:	31 f4       	brne	.+12     	; 0x50e2 <rprintfChar+0x14>
		rputchar('\r');
    50d6:	e0 91 e7 11 	lds	r30, 0x11E7
    50da:	f0 91 e8 11 	lds	r31, 0x11E8
    50de:	8d e0       	ldi	r24, 0x0D	; 13
    50e0:	09 95       	icall
	// send character
	rputchar(c);
    50e2:	e0 91 e7 11 	lds	r30, 0x11E7
    50e6:	f0 91 e8 11 	lds	r31, 0x11E8
    50ea:	81 2f       	mov	r24, r17
    50ec:	09 95       	icall
}
    50ee:	1f 91       	pop	r17
    50f0:	08 95       	ret

000050f2 <rprintfStr>:

// *** rprintfStr ***
// prints a null-terminated string stored in RAM
void rprintfStr(char str[])
{
    50f2:	cf 93       	push	r28
    50f4:	df 93       	push	r29
    50f6:	ec 01       	movw	r28, r24
	// send a string stored in RAM
	// check to make sure we have a good pointer
	if (!str) return;
    50f8:	00 97       	sbiw	r24, 0x00	; 0
    50fa:	21 f4       	brne	.+8      	; 0x5104 <rprintfStr+0x12>
    50fc:	06 c0       	rjmp	.+12     	; 0x510a <rprintfStr+0x18>

	// print the string until a null-terminator
	while (*str)
		rprintfChar(*str++);
    50fe:	21 96       	adiw	r28, 0x01	; 1
    5100:	0e 94 67 28 	call	0x50ce	; 0x50ce <rprintfChar>
	// send a string stored in RAM
	// check to make sure we have a good pointer
	if (!str) return;

	// print the string until a null-terminator
	while (*str)
    5104:	88 81       	ld	r24, Y
    5106:	88 23       	and	r24, r24
    5108:	d1 f7       	brne	.-12     	; 0x50fe <rprintfStr+0xc>
		rprintfChar(*str++);
}
    510a:	df 91       	pop	r29
    510c:	cf 91       	pop	r28
    510e:	08 95       	ret

00005110 <rprintfStrLen>:
// *** rprintfStrLen ***
// prints a section of a string stored in RAM
// begins printing at position indicated by <start>
// prints number of characters indicated by <len>
void rprintfStrLen(char str[], unsigned int start, unsigned int len)
{
    5110:	ef 92       	push	r14
    5112:	ff 92       	push	r15
    5114:	0f 93       	push	r16
    5116:	1f 93       	push	r17
    5118:	cf 93       	push	r28
    511a:	df 93       	push	r29
    511c:	8c 01       	movw	r16, r24
    511e:	7a 01       	movw	r14, r20
	register int i=0;

	// check to make sure we have a good pointer
	if (!str) return;
    5120:	00 97       	sbiw	r24, 0x00	; 0
    5122:	e9 f0       	breq	.+58     	; 0x515e <rprintfStrLen+0x4e>
    5124:	20 e0       	ldi	r18, 0x00	; 0
    5126:	30 e0       	ldi	r19, 0x00	; 0
	// spin through characters up to requested start
	// keep going as long as there's no null
	while((i++<start) && (*str++));
    5128:	26 17       	cp	r18, r22
    512a:	37 07       	cpc	r19, r23
    512c:	38 f4       	brcc	.+14     	; 0x513c <rprintfStrLen+0x2c>
    512e:	f8 01       	movw	r30, r16
    5130:	81 91       	ld	r24, Z+
    5132:	8f 01       	movw	r16, r30
    5134:	2f 5f       	subi	r18, 0xFF	; 255
    5136:	3f 4f       	sbci	r19, 0xFF	; 255
    5138:	88 23       	and	r24, r24
    513a:	b1 f7       	brne	.-20     	; 0x5128 <rprintfStrLen+0x18>
    513c:	c0 e0       	ldi	r28, 0x00	; 0
    513e:	d0 e0       	ldi	r29, 0x00	; 0
    5140:	0b c0       	rjmp	.+22     	; 0x5158 <rprintfStrLen+0x48>
	// then print exactly len characters
	for(i=0; i<len; i++)
	{
		// print data out of the string as long as we haven't reached a null yet
		// at the null, start printing spaces
		if(*str)
    5142:	f8 01       	movw	r30, r16
    5144:	80 81       	ld	r24, Z
    5146:	88 23       	and	r24, r24
    5148:	19 f0       	breq	.+6      	; 0x5150 <rprintfStrLen+0x40>
			rprintfChar(*str++);
    514a:	0f 5f       	subi	r16, 0xFF	; 255
    514c:	1f 4f       	sbci	r17, 0xFF	; 255
    514e:	01 c0       	rjmp	.+2      	; 0x5152 <rprintfStrLen+0x42>
		else
			rprintfChar(' ');
    5150:	80 e2       	ldi	r24, 0x20	; 32
    5152:	0e 94 67 28 	call	0x50ce	; 0x50ce <rprintfChar>
//		// keep steping through string as long as there's no null
//		if(*str) str++;
//	}

	// then print exactly len characters
	for(i=0; i<len; i++)
    5156:	21 96       	adiw	r28, 0x01	; 1
    5158:	ce 15       	cp	r28, r14
    515a:	df 05       	cpc	r29, r15
    515c:	90 f3       	brcs	.-28     	; 0x5142 <rprintfStrLen+0x32>
			rprintfChar(*str++);
		else
			rprintfChar(' ');
	}

}
    515e:	df 91       	pop	r29
    5160:	cf 91       	pop	r28
    5162:	1f 91       	pop	r17
    5164:	0f 91       	pop	r16
    5166:	ff 90       	pop	r15
    5168:	ef 90       	pop	r14
    516a:	08 95       	ret

0000516c <rprintfProgStr>:

// *** rprintfProgStr ***
// prints a null-terminated string stored in program ROM
void rprintfProgStr(const prog_char str[])
{
    516c:	cf 93       	push	r28
    516e:	df 93       	push	r29
    5170:	ec 01       	movw	r28, r24
	// print a string stored in program memory
	register char c;

	// check to make sure we have a good pointer
	if (!str) return;
    5172:	00 97       	sbiw	r24, 0x00	; 0
    5174:	19 f4       	brne	.+6      	; 0x517c <rprintfProgStr+0x10>
    5176:	07 c0       	rjmp	.+14     	; 0x5186 <rprintfProgStr+0x1a>
	
	// print the string until the null-terminator
	while((c = pgm_read_byte(str++)))
		rprintfChar(c);
    5178:	0e 94 67 28 	call	0x50ce	; 0x50ce <rprintfChar>
    517c:	fe 01       	movw	r30, r28

	// check to make sure we have a good pointer
	if (!str) return;
	
	// print the string until the null-terminator
	while((c = pgm_read_byte(str++)))
    517e:	21 96       	adiw	r28, 0x01	; 1
    5180:	84 91       	lpm	r24, Z+
    5182:	88 23       	and	r24, r24
    5184:	c9 f7       	brne	.-14     	; 0x5178 <rprintfProgStr+0xc>
		rprintfChar(c);
}
    5186:	df 91       	pop	r29
    5188:	cf 91       	pop	r28
    518a:	08 95       	ret

0000518c <rprintfCRLF>:
void rprintfCRLF(void)
{
	// print CR/LF
	//rprintfChar('\r');
	// LF -> CR/LF translation built-in to rprintfChar()
	rprintfChar('\n');
    518c:	8a e0       	ldi	r24, 0x0A	; 10
    518e:	0e 94 67 28 	call	0x50ce	; 0x50ce <rprintfChar>
}
    5192:	08 95       	ret

00005194 <rprintfu04>:
//	char Character = data&0x0f;
//	if (Character>9)
//		Character+='A'-10;
//	else
//		Character+='0';
	rprintfChar(hexchar(data));
    5194:	e8 2f       	mov	r30, r24
    5196:	f0 e0       	ldi	r31, 0x00	; 0
    5198:	ef 70       	andi	r30, 0x0F	; 15
    519a:	f0 70       	andi	r31, 0x00	; 0
    519c:	e5 53       	subi	r30, 0x35	; 53
    519e:	fe 4f       	sbci	r31, 0xFE	; 254
    51a0:	e4 91       	lpm	r30, Z+
    51a2:	8e 2f       	mov	r24, r30
    51a4:	0e 94 67 28 	call	0x50ce	; 0x50ce <rprintfChar>
}
    51a8:	08 95       	ret

000051aa <rprintfu08>:

// *** rprintfu08 ***
// prints an unsigned 8-bit number in hex (2 digits)
void rprintfu08(unsigned char data)
{
    51aa:	1f 93       	push	r17
    51ac:	18 2f       	mov	r17, r24
	// print 8-bit hex value
	rprintfu04(data>>4);
    51ae:	82 95       	swap	r24
    51b0:	8f 70       	andi	r24, 0x0F	; 15
    51b2:	0e 94 ca 28 	call	0x5194	; 0x5194 <rprintfu04>
	rprintfu04(data);
    51b6:	81 2f       	mov	r24, r17
    51b8:	0e 94 ca 28 	call	0x5194	; 0x5194 <rprintfu04>
}
    51bc:	1f 91       	pop	r17
    51be:	08 95       	ret

000051c0 <rprintfu16>:

// *** rprintfu16 ***
// prints an unsigned 16-bit number in hex (4 digits)
void rprintfu16(unsigned short data)
{
    51c0:	1f 93       	push	r17
    51c2:	18 2f       	mov	r17, r24
	// print 16-bit hex value
	rprintfu08(data>>8);
    51c4:	89 2f       	mov	r24, r25
    51c6:	0e 94 d5 28 	call	0x51aa	; 0x51aa <rprintfu08>
	rprintfu08(data);
    51ca:	81 2f       	mov	r24, r17
    51cc:	0e 94 d5 28 	call	0x51aa	; 0x51aa <rprintfu08>
}
    51d0:	1f 91       	pop	r17
    51d2:	08 95       	ret

000051d4 <rprintfu32>:

// *** rprintfu32 ***
// prints an unsigned 32-bit number in hex (8 digits)
void rprintfu32(unsigned long data)
{
    51d4:	ef 92       	push	r14
    51d6:	ff 92       	push	r15
    51d8:	0f 93       	push	r16
    51da:	1f 93       	push	r17
    51dc:	7b 01       	movw	r14, r22
    51de:	8c 01       	movw	r16, r24
	// print 32-bit hex value
	rprintfu16(data>>16);
    51e0:	c8 01       	movw	r24, r16
    51e2:	aa 27       	eor	r26, r26
    51e4:	bb 27       	eor	r27, r27
    51e6:	0e 94 e0 28 	call	0x51c0	; 0x51c0 <rprintfu16>
	rprintfu16(data);
    51ea:	c7 01       	movw	r24, r14
    51ec:	0e 94 e0 28 	call	0x51c0	; 0x51c0 <rprintfu16>
}
    51f0:	1f 91       	pop	r17
    51f2:	0f 91       	pop	r16
    51f4:	ff 90       	pop	r15
    51f6:	ef 90       	pop	r14
    51f8:	08 95       	ret

000051fa <rprintfNum>:
//	Examples:
//	uartPrintfNum(10, 6,  TRUE, ' ',   1234);  -->  " +1234"
//	uartPrintfNum(10, 6, FALSE, '0',   1234);  -->  "001234"
//	uartPrintfNum(16, 6, FALSE, '.', 0x5AA5);  -->  "..5AA5"
void rprintfNum(char base, char numDigits, char isSigned, char padchar, long n)
{
    51fa:	2f 92       	push	r2
    51fc:	3f 92       	push	r3
    51fe:	4f 92       	push	r4
    5200:	5f 92       	push	r5
    5202:	6f 92       	push	r6
    5204:	7f 92       	push	r7
    5206:	8f 92       	push	r8
    5208:	9f 92       	push	r9
    520a:	af 92       	push	r10
    520c:	bf 92       	push	r11
    520e:	cf 92       	push	r12
    5210:	df 92       	push	r13
    5212:	ef 92       	push	r14
    5214:	ff 92       	push	r15
    5216:	0f 93       	push	r16
    5218:	1f 93       	push	r17
    521a:	df 93       	push	r29
    521c:	cf 93       	push	r28
    521e:	cd b7       	in	r28, 0x3d	; 61
    5220:	de b7       	in	r29, 0x3e	; 62
    5222:	a3 97       	sbiw	r28, 0x23	; 35
    5224:	0f b6       	in	r0, 0x3f	; 63
    5226:	f8 94       	cli
    5228:	de bf       	out	0x3e, r29	; 62
    522a:	0f be       	out	0x3f, r0	; 63
    522c:	cd bf       	out	0x3d, r28	; 61
    522e:	6a a3       	std	Y+34, r22	; 0x22
    5230:	24 2e       	mov	r2, r20
    5232:	2b a3       	std	Y+35, r18	; 0x23
    5234:	37 01       	movw	r6, r14
    5236:	48 01       	movw	r8, r16
	char *p, buf[32];
	unsigned long x;
	unsigned char count;

	// prepare negative number
	if( isSigned && (n < 0) )
    5238:	44 23       	and	r20, r20
    523a:	51 f0       	breq	.+20     	; 0x5250 <rprintfNum+0x56>
    523c:	17 ff       	sbrs	r17, 7
    523e:	08 c0       	rjmp	.+16     	; 0x5250 <rprintfNum+0x56>
	{
		x = -n;
    5240:	ee 24       	eor	r14, r14
    5242:	ff 24       	eor	r15, r15
    5244:	87 01       	movw	r16, r14
    5246:	e6 18       	sub	r14, r6
    5248:	f7 08       	sbc	r15, r7
    524a:	08 09       	sbc	r16, r8
    524c:	19 09       	sbc	r17, r9
    524e:	02 c0       	rjmp	.+4      	; 0x5254 <rprintfNum+0x5a>
	}
	else
	{
	 	x = n;
    5250:	84 01       	movw	r16, r8
    5252:	73 01       	movw	r14, r6
	}

	// setup little string buffer
	count = (numDigits-1)-(isSigned?1:0);
    5254:	2a a1       	ldd	r18, Y+34	; 0x22
    5256:	21 50       	subi	r18, 0x01	; 1
    5258:	90 e0       	ldi	r25, 0x00	; 0
    525a:	21 10       	cpse	r2, r1
    525c:	91 e0       	ldi	r25, 0x01	; 1
    525e:	29 1b       	sub	r18, r25
    5260:	29 a3       	std	Y+33, r18	; 0x21
  	p = buf + sizeof (buf);
  	*--p = '\0';
    5262:	18 a2       	std	Y+32, r1	; 0x20
	
	// force calculation of first digit
	// (to prevent zero from not printing at all!!!)
	*--p = hexchar(x%base); x /= base;
    5264:	a8 2e       	mov	r10, r24
    5266:	bb 24       	eor	r11, r11
    5268:	cc 24       	eor	r12, r12
    526a:	dd 24       	eor	r13, r13
    526c:	c8 01       	movw	r24, r16
    526e:	b7 01       	movw	r22, r14
    5270:	a6 01       	movw	r20, r12
    5272:	95 01       	movw	r18, r10
    5274:	0e 94 20 30 	call	0x6040	; 0x6040 <__udivmodsi4>
    5278:	fb 01       	movw	r30, r22
    527a:	ef 70       	andi	r30, 0x0F	; 15
    527c:	f0 70       	andi	r31, 0x00	; 0
    527e:	e5 53       	subi	r30, 0x35	; 53
    5280:	fe 4f       	sbci	r31, 0xFE	; 254
    5282:	64 91       	lpm	r22, Z+
    5284:	6f 8f       	std	Y+31, r22	; 0x1f
    5286:	c8 01       	movw	r24, r16
    5288:	b7 01       	movw	r22, r14
    528a:	a6 01       	movw	r20, r12
    528c:	95 01       	movw	r18, r10
    528e:	0e 94 20 30 	call	0x6040	; 0x6040 <__udivmodsi4>
    5292:	c9 01       	movw	r24, r18
    5294:	da 01       	movw	r26, r20
    5296:	7c 01       	movw	r14, r24
    5298:	8d 01       	movw	r16, r26
    529a:	9e e1       	ldi	r25, 0x1E	; 30
    529c:	49 2e       	mov	r4, r25
    529e:	51 2c       	mov	r5, r1
    52a0:	4c 0e       	add	r4, r28
    52a2:	5d 1e       	adc	r5, r29
    52a4:	39 a0       	ldd	r3, Y+33	; 0x21
    52a6:	25 c0       	rjmp	.+74     	; 0x52f2 <rprintfNum+0xf8>
	// calculate remaining digits
	while(count--)
	{
		if(x != 0)
    52a8:	e1 14       	cp	r14, r1
    52aa:	f1 04       	cpc	r15, r1
    52ac:	01 05       	cpc	r16, r1
    52ae:	11 05       	cpc	r17, r1
    52b0:	c9 f0       	breq	.+50     	; 0x52e4 <rprintfNum+0xea>
		{
			// calculate next digit
			*--p = hexchar(x%base); x /= base;
    52b2:	c8 01       	movw	r24, r16
    52b4:	b7 01       	movw	r22, r14
    52b6:	a6 01       	movw	r20, r12
    52b8:	95 01       	movw	r18, r10
    52ba:	0e 94 20 30 	call	0x6040	; 0x6040 <__udivmodsi4>
    52be:	fb 01       	movw	r30, r22
    52c0:	ef 70       	andi	r30, 0x0F	; 15
    52c2:	f0 70       	andi	r31, 0x00	; 0
    52c4:	e5 53       	subi	r30, 0x35	; 53
    52c6:	fe 4f       	sbci	r31, 0xFE	; 254
    52c8:	64 91       	lpm	r22, Z+
    52ca:	f2 01       	movw	r30, r4
    52cc:	60 83       	st	Z, r22
    52ce:	c8 01       	movw	r24, r16
    52d0:	b7 01       	movw	r22, r14
    52d2:	a6 01       	movw	r20, r12
    52d4:	95 01       	movw	r18, r10
    52d6:	0e 94 20 30 	call	0x6040	; 0x6040 <__udivmodsi4>
    52da:	c9 01       	movw	r24, r18
    52dc:	da 01       	movw	r26, r20
    52de:	7c 01       	movw	r14, r24
    52e0:	8d 01       	movw	r16, r26
    52e2:	03 c0       	rjmp	.+6      	; 0x52ea <rprintfNum+0xf0>
		}
		else
		{
			// no more digits left, pad out to desired length
			*--p = padchar;
    52e4:	2b a1       	ldd	r18, Y+35	; 0x23
    52e6:	f2 01       	movw	r30, r4
    52e8:	20 83       	st	Z, r18
    52ea:	3a 94       	dec	r3
    52ec:	08 94       	sec
    52ee:	41 08       	sbc	r4, r1
    52f0:	51 08       	sbc	r5, r1
	
	// force calculation of first digit
	// (to prevent zero from not printing at all!!!)
	*--p = hexchar(x%base); x /= base;
	// calculate remaining digits
	while(count--)
    52f2:	33 20       	and	r3, r3
    52f4:	c9 f6       	brne	.-78     	; 0x52a8 <rprintfNum+0xae>
    52f6:	ce 01       	movw	r24, r28
    52f8:	4f 96       	adiw	r24, 0x1f	; 31
    52fa:	8c 01       	movw	r16, r24
    52fc:	e9 a1       	ldd	r30, Y+33	; 0x21
    52fe:	0e 1b       	sub	r16, r30
    5300:	11 09       	sbc	r17, r1
			*--p = padchar;
		}
	}

	// apply signed notation if requested
	if( isSigned )
    5302:	22 20       	and	r2, r2
    5304:	f1 f0       	breq	.+60     	; 0x5342 <rprintfNum+0x148>
	{
		if(n < 0)
    5306:	97 fe       	sbrs	r9, 7
    5308:	05 c0       	rjmp	.+10     	; 0x5314 <rprintfNum+0x11a>
		{
   			*--p = '-';
    530a:	8d e2       	ldi	r24, 0x2D	; 45
    530c:	f8 01       	movw	r30, r16
    530e:	82 93       	st	-Z, r24
    5310:	8f 01       	movw	r16, r30
    5312:	17 c0       	rjmp	.+46     	; 0x5342 <rprintfNum+0x148>
    5314:	c8 01       	movw	r24, r16
    5316:	01 97       	sbiw	r24, 0x01	; 1
		}
		else if(n > 0)
    5318:	61 14       	cp	r6, r1
    531a:	71 04       	cpc	r7, r1
    531c:	81 04       	cpc	r8, r1
    531e:	91 04       	cpc	r9, r1
    5320:	19 f0       	breq	.+6      	; 0x5328 <rprintfNum+0x12e>
		{
	   		*--p = '+';
    5322:	8c 01       	movw	r16, r24
    5324:	8b e2       	ldi	r24, 0x2B	; 43
    5326:	02 c0       	rjmp	.+4      	; 0x532c <rprintfNum+0x132>
		}
		else
		{
	   		*--p = ' ';
    5328:	8c 01       	movw	r16, r24
    532a:	80 e2       	ldi	r24, 0x20	; 32
    532c:	f8 01       	movw	r30, r16
    532e:	80 83       	st	Z, r24
    5330:	08 c0       	rjmp	.+16     	; 0x5342 <rprintfNum+0x148>

	// print the string right-justified
	count = numDigits;
	while(count--)
	{
		rprintfChar(*p++);
    5332:	f8 01       	movw	r30, r16
    5334:	81 91       	ld	r24, Z+
    5336:	8f 01       	movw	r16, r30
    5338:	0e 94 67 28 	call	0x50ce	; 0x50ce <rprintfChar>
    533c:	fa a1       	ldd	r31, Y+34	; 0x22
    533e:	f1 50       	subi	r31, 0x01	; 1
    5340:	fa a3       	std	Y+34, r31	; 0x22
		}
	}

	// print the string right-justified
	count = numDigits;
	while(count--)
    5342:	2a a1       	ldd	r18, Y+34	; 0x22
    5344:	22 23       	and	r18, r18
    5346:	a9 f7       	brne	.-22     	; 0x5332 <rprintfNum+0x138>
	{
		rprintfChar(*p++);
	}
}
    5348:	a3 96       	adiw	r28, 0x23	; 35
    534a:	0f b6       	in	r0, 0x3f	; 63
    534c:	f8 94       	cli
    534e:	de bf       	out	0x3e, r29	; 62
    5350:	0f be       	out	0x3f, r0	; 63
    5352:	cd bf       	out	0x3d, r28	; 61
    5354:	cf 91       	pop	r28
    5356:	df 91       	pop	r29
    5358:	1f 91       	pop	r17
    535a:	0f 91       	pop	r16
    535c:	ff 90       	pop	r15
    535e:	ef 90       	pop	r14
    5360:	df 90       	pop	r13
    5362:	cf 90       	pop	r12
    5364:	bf 90       	pop	r11
    5366:	af 90       	pop	r10
    5368:	9f 90       	pop	r9
    536a:	8f 90       	pop	r8
    536c:	7f 90       	pop	r7
    536e:	6f 90       	pop	r6
    5370:	5f 90       	pop	r5
    5372:	4f 90       	pop	r4
    5374:	3f 90       	pop	r3
    5376:	2f 90       	pop	r2
    5378:	08 95       	ret

0000537a <rprintfFloat>:

#ifdef RPRINTF_FLOAT
// *** rprintfFloat ***
// floating-point print
void rprintfFloat(char numDigits, double x)
{
    537a:	4f 92       	push	r4
    537c:	5f 92       	push	r5
    537e:	6f 92       	push	r6
    5380:	7f 92       	push	r7
    5382:	8f 92       	push	r8
    5384:	9f 92       	push	r9
    5386:	af 92       	push	r10
    5388:	bf 92       	push	r11
    538a:	cf 92       	push	r12
    538c:	df 92       	push	r13
    538e:	ef 92       	push	r14
    5390:	ff 92       	push	r15
    5392:	0f 93       	push	r16
    5394:	1f 93       	push	r17
    5396:	cf 93       	push	r28
    5398:	df 93       	push	r29
    539a:	48 2e       	mov	r4, r24
    539c:	5a 01       	movw	r10, r20
    539e:	6b 01       	movw	r12, r22
	double place = 1.0;
	
	// save sign
	negative = (x<0);
	// convert to absolute value
	x = (x>0)?(x):(-x);
    53a0:	cb 01       	movw	r24, r22
    53a2:	ba 01       	movw	r22, r20
    53a4:	20 e0       	ldi	r18, 0x00	; 0
    53a6:	30 e0       	ldi	r19, 0x00	; 0
    53a8:	40 e0       	ldi	r20, 0x00	; 0
    53aa:	50 e0       	ldi	r21, 0x00	; 0
    53ac:	0e 94 73 2f 	call	0x5ee6	; 0x5ee6 <__gesf2>
    53b0:	18 16       	cp	r1, r24
    53b2:	1c f4       	brge	.+6      	; 0x53ba <rprintfFloat+0x40>
    53b4:	35 01       	movw	r6, r10
    53b6:	46 01       	movw	r8, r12
    53b8:	06 c0       	rjmp	.+12     	; 0x53c6 <rprintfFloat+0x4c>
    53ba:	35 01       	movw	r6, r10
    53bc:	46 01       	movw	r8, r12
    53be:	97 fa       	bst	r9, 7
    53c0:	90 94       	com	r9
    53c2:	97 f8       	bld	r9, 7
    53c4:	90 94       	com	r9
    53c6:	0f 2e       	mov	r0, r31
    53c8:	f0 e0       	ldi	r31, 0x00	; 0
    53ca:	ef 2e       	mov	r14, r31
    53cc:	f0 e0       	ldi	r31, 0x00	; 0
    53ce:	ff 2e       	mov	r15, r31
    53d0:	f0 e8       	ldi	r31, 0x80	; 128
    53d2:	0f 2f       	mov	r16, r31
    53d4:	ff e3       	ldi	r31, 0x3F	; 63
    53d6:	1f 2f       	mov	r17, r31
    53d8:	f0 2d       	mov	r31, r0
    53da:	55 24       	eor	r5, r5
	
	// find starting digit place
	for(i=0; i<15; i++)
	{
		if((x/place) < 10.0)
    53dc:	c4 01       	movw	r24, r8
    53de:	b3 01       	movw	r22, r6
    53e0:	a8 01       	movw	r20, r16
    53e2:	97 01       	movw	r18, r14
    53e4:	0e 94 28 2e 	call	0x5c50	; 0x5c50 <__divsf3>
    53e8:	20 e0       	ldi	r18, 0x00	; 0
    53ea:	30 e0       	ldi	r19, 0x00	; 0
    53ec:	40 e2       	ldi	r20, 0x20	; 32
    53ee:	51 e4       	ldi	r21, 0x41	; 65
    53f0:	0e 94 24 2e 	call	0x5c48	; 0x5c48 <__cmpsf2>
    53f4:	87 fd       	sbrc	r24, 7
    53f6:	0e c0       	rjmp	.+28     	; 0x5414 <rprintfFloat+0x9a>
			break;
		else
			place *= 10.0;
    53f8:	c8 01       	movw	r24, r16
    53fa:	b7 01       	movw	r22, r14
    53fc:	20 e0       	ldi	r18, 0x00	; 0
    53fe:	30 e0       	ldi	r19, 0x00	; 0
    5400:	40 e2       	ldi	r20, 0x20	; 32
    5402:	51 e4       	ldi	r21, 0x41	; 65
    5404:	0e 94 77 2f 	call	0x5eee	; 0x5eee <__mulsf3>
    5408:	7b 01       	movw	r14, r22
    540a:	8c 01       	movw	r16, r24
	negative = (x<0);
	// convert to absolute value
	x = (x>0)?(x):(-x);
	
	// find starting digit place
	for(i=0; i<15; i++)
    540c:	53 94       	inc	r5
    540e:	8f e0       	ldi	r24, 0x0F	; 15
    5410:	58 16       	cp	r5, r24
    5412:	21 f7       	brne	.-56     	; 0x53dc <rprintfFloat+0x62>
			break;
		else
			place *= 10.0;
	}
	// print polarity character
	if(negative)
    5414:	c6 01       	movw	r24, r12
    5416:	b5 01       	movw	r22, r10
    5418:	20 e0       	ldi	r18, 0x00	; 0
    541a:	30 e0       	ldi	r19, 0x00	; 0
    541c:	40 e0       	ldi	r20, 0x00	; 0
    541e:	50 e0       	ldi	r21, 0x00	; 0
    5420:	0e 94 24 2e 	call	0x5c48	; 0x5c48 <__cmpsf2>
    5424:	88 23       	and	r24, r24
    5426:	14 f4       	brge	.+4      	; 0x542c <rprintfFloat+0xb2>
		rprintfChar('-');
    5428:	8d e2       	ldi	r24, 0x2D	; 45
    542a:	01 c0       	rjmp	.+2      	; 0x542e <rprintfFloat+0xb4>
	else
		rprintfChar('+');
    542c:	8b e2       	ldi	r24, 0x2B	; 43
    542e:	0e 94 67 28 	call	0x50ce	; 0x50ce <rprintfChar>
    5432:	dd 24       	eor	r13, r13
    5434:	aa 24       	eor	r10, r10
    5436:	56 c0       	rjmp	.+172    	; 0x54e4 <rprintfFloat+0x16a>

	// print digits
	for(i=0; i<numDigits; i++)
	{
		digit = (x/place);
    5438:	c4 01       	movw	r24, r8
    543a:	b3 01       	movw	r22, r6
    543c:	a8 01       	movw	r20, r16
    543e:	97 01       	movw	r18, r14
    5440:	0e 94 28 2e 	call	0x5c50	; 0x5c50 <__divsf3>
    5444:	0e 94 95 2e 	call	0x5d2a	; 0x5d2a <__fixunssfsi>
    5448:	b6 2e       	mov	r11, r22

		if(digit | firstplace | (place == 1.0))
    544a:	d6 2a       	or	r13, r22
    544c:	cd 2d       	mov	r28, r13
    544e:	d0 e0       	ldi	r29, 0x00	; 0
    5450:	cc 24       	eor	r12, r12
    5452:	dd 24       	eor	r13, r13
    5454:	c8 01       	movw	r24, r16
    5456:	b7 01       	movw	r22, r14
    5458:	20 e0       	ldi	r18, 0x00	; 0
    545a:	30 e0       	ldi	r19, 0x00	; 0
    545c:	40 e8       	ldi	r20, 0x80	; 128
    545e:	5f e3       	ldi	r21, 0x3F	; 63
    5460:	0e 94 24 2e 	call	0x5c48	; 0x5c48 <__cmpsf2>
    5464:	88 23       	and	r24, r24
    5466:	19 f4       	brne	.+6      	; 0x546e <rprintfFloat+0xf4>
    5468:	21 e0       	ldi	r18, 0x01	; 1
    546a:	c2 2e       	mov	r12, r18
    546c:	d1 2c       	mov	r13, r1
    546e:	cc 29       	or	r28, r12
    5470:	dd 29       	or	r29, r13
    5472:	cd 2b       	or	r28, r29
    5474:	39 f0       	breq	.+14     	; 0x5484 <rprintfFloat+0x10a>
		{
			firstplace = TRUE;
			rprintfChar(digit+0x30);
    5476:	8b 2d       	mov	r24, r11
    5478:	80 5d       	subi	r24, 0xD0	; 208
    547a:	0e 94 67 28 	call	0x50ce	; 0x50ce <rprintfChar>
    547e:	dd 24       	eor	r13, r13
    5480:	da 94       	dec	r13
    5482:	04 c0       	rjmp	.+8      	; 0x548c <rprintfFloat+0x112>
		}
		else
			rprintfChar(' ');
    5484:	80 e2       	ldi	r24, 0x20	; 32
    5486:	0e 94 67 28 	call	0x50ce	; 0x50ce <rprintfChar>
    548a:	dd 24       	eor	r13, r13
		
		if(place == 1.0)
    548c:	c8 01       	movw	r24, r16
    548e:	b7 01       	movw	r22, r14
    5490:	20 e0       	ldi	r18, 0x00	; 0
    5492:	30 e0       	ldi	r19, 0x00	; 0
    5494:	40 e8       	ldi	r20, 0x80	; 128
    5496:	5f e3       	ldi	r21, 0x3F	; 63
    5498:	0e 94 24 2e 	call	0x5c48	; 0x5c48 <__cmpsf2>
    549c:	88 23       	and	r24, r24
    549e:	19 f4       	brne	.+6      	; 0x54a6 <rprintfFloat+0x12c>
		{
			rprintfChar('.');
    54a0:	8e e2       	ldi	r24, 0x2E	; 46
    54a2:	0e 94 67 28 	call	0x50ce	; 0x50ce <rprintfChar>
		}
		
		x -= (digit*place);
    54a6:	6b 2d       	mov	r22, r11
    54a8:	70 e0       	ldi	r23, 0x00	; 0
    54aa:	88 27       	eor	r24, r24
    54ac:	77 fd       	sbrc	r23, 7
    54ae:	80 95       	com	r24
    54b0:	98 2f       	mov	r25, r24
    54b2:	0e 94 c3 2e 	call	0x5d86	; 0x5d86 <__floatsisf>
    54b6:	a8 01       	movw	r20, r16
    54b8:	97 01       	movw	r18, r14
    54ba:	0e 94 77 2f 	call	0x5eee	; 0x5eee <__mulsf3>
    54be:	9b 01       	movw	r18, r22
    54c0:	ac 01       	movw	r20, r24
    54c2:	c4 01       	movw	r24, r8
    54c4:	b3 01       	movw	r22, r6
    54c6:	0e 94 bf 2d 	call	0x5b7e	; 0x5b7e <__subsf3>
    54ca:	3b 01       	movw	r6, r22
    54cc:	4c 01       	movw	r8, r24
		place /= 10.0;
    54ce:	c8 01       	movw	r24, r16
    54d0:	b7 01       	movw	r22, r14
    54d2:	20 e0       	ldi	r18, 0x00	; 0
    54d4:	30 e0       	ldi	r19, 0x00	; 0
    54d6:	40 e2       	ldi	r20, 0x20	; 32
    54d8:	51 e4       	ldi	r21, 0x41	; 65
    54da:	0e 94 28 2e 	call	0x5c50	; 0x5c50 <__divsf3>
    54de:	7b 01       	movw	r14, r22
    54e0:	8c 01       	movw	r16, r24
		rprintfChar('-');
	else
		rprintfChar('+');

	// print digits
	for(i=0; i<numDigits; i++)
    54e2:	a3 94       	inc	r10
    54e4:	a4 14       	cp	r10, r4
    54e6:	08 f4       	brcc	.+2      	; 0x54ea <rprintfFloat+0x170>
    54e8:	a7 cf       	rjmp	.-178    	; 0x5438 <rprintfFloat+0xbe>
		}
		
		x -= (digit*place);
		place /= 10.0;
	}
}
    54ea:	df 91       	pop	r29
    54ec:	cf 91       	pop	r28
    54ee:	1f 91       	pop	r17
    54f0:	0f 91       	pop	r16
    54f2:	ff 90       	pop	r15
    54f4:	ef 90       	pop	r14
    54f6:	df 90       	pop	r13
    54f8:	cf 90       	pop	r12
    54fa:	bf 90       	pop	r11
    54fc:	af 90       	pop	r10
    54fe:	9f 90       	pop	r9
    5500:	8f 90       	pop	r8
    5502:	7f 90       	pop	r7
    5504:	6f 90       	pop	r6
    5506:	5f 90       	pop	r5
    5508:	4f 90       	pop	r4
    550a:	08 95       	ret

0000550c <rprintf1RamRom>:
// Supports:
// %d - decimal
// %x - hex
// %c - character
int rprintf1RamRom(unsigned char stringInRom, const char *format, ...)
{
    550c:	7f 92       	push	r7
    550e:	8f 92       	push	r8
    5510:	9f 92       	push	r9
    5512:	af 92       	push	r10
    5514:	bf 92       	push	r11
    5516:	cf 92       	push	r12
    5518:	df 92       	push	r13
    551a:	ef 92       	push	r14
    551c:	ff 92       	push	r15
    551e:	0f 93       	push	r16
    5520:	1f 93       	push	r17
    5522:	df 93       	push	r29
    5524:	cf 93       	push	r28
    5526:	cd b7       	in	r28, 0x3d	; 61
    5528:	de b7       	in	r29, 0x3e	; 62
    552a:	78 88       	ldd	r7, Y+16	; 0x10
    552c:	c9 88       	ldd	r12, Y+17	; 0x11
    552e:	da 88       	ldd	r13, Y+18	; 0x12
    5530:	63 e1       	ldi	r22, 0x13	; 19
    5532:	e6 2e       	mov	r14, r22
    5534:	f1 2c       	mov	r15, r1
    5536:	ec 0e       	add	r14, r28
    5538:	fd 1e       	adc	r15, r29
    553a:	14 c0       	rjmp	.+40     	; 0x5564 <rprintf1RamRom+0x58>
	va_start(ap, format);
	for (;;)
	{
		while ((format_flag = READMEMBYTE(stringInRom,format++) ) != '%')
		{	// Until '%' or '\0'
			if (!format_flag)
    553c:	88 23       	and	r24, r24
    553e:	81 f4       	brne	.+32     	; 0x5560 <rprintf1RamRom+0x54>
				div_val /= base;
			} while (div_val);
		}
	}
	va_end(ap);
}
    5540:	80 e0       	ldi	r24, 0x00	; 0
    5542:	90 e0       	ldi	r25, 0x00	; 0
    5544:	cf 91       	pop	r28
    5546:	df 91       	pop	r29
    5548:	1f 91       	pop	r17
    554a:	0f 91       	pop	r16
    554c:	ff 90       	pop	r15
    554e:	ef 90       	pop	r14
    5550:	df 90       	pop	r13
    5552:	cf 90       	pop	r12
    5554:	bf 90       	pop	r11
    5556:	af 90       	pop	r10
    5558:	9f 90       	pop	r9
    555a:	8f 90       	pop	r8
    555c:	7f 90       	pop	r7
    555e:	08 95       	ret
			if (!format_flag)
			{
				va_end(ap);
				return(0);
			}
			rprintfChar(format_flag);
    5560:	0e 94 67 28 	call	0x50ce	; 0x50ce <rprintfChar>
    5564:	96 01       	movw	r18, r12
    5566:	2f 5f       	subi	r18, 0xFF	; 255
    5568:	3f 4f       	sbci	r19, 0xFF	; 255
	va_list ap;

	va_start(ap, format);
	for (;;)
	{
		while ((format_flag = READMEMBYTE(stringInRom,format++) ) != '%')
    556a:	77 20       	and	r7, r7
    556c:	21 f0       	breq	.+8      	; 0x5576 <rprintf1RamRom+0x6a>
    556e:	f6 01       	movw	r30, r12
    5570:	69 01       	movw	r12, r18
    5572:	84 91       	lpm	r24, Z+
    5574:	03 c0       	rjmp	.+6      	; 0x557c <rprintf1RamRom+0x70>
    5576:	f6 01       	movw	r30, r12
    5578:	80 81       	ld	r24, Z
    557a:	69 01       	movw	r12, r18
    557c:	85 32       	cpi	r24, 0x25	; 37
    557e:	f1 f6       	brne	.-68     	; 0x553c <rprintf1RamRom+0x30>
    5580:	2f 5f       	subi	r18, 0xFF	; 255
    5582:	3f 4f       	sbci	r19, 0xFF	; 255
				return(0);
			}
			rprintfChar(format_flag);
		}

		switch (format_flag = READMEMBYTE(stringInRom,format++) )
    5584:	77 20       	and	r7, r7
    5586:	21 f0       	breq	.+8      	; 0x5590 <rprintf1RamRom+0x84>
    5588:	f6 01       	movw	r30, r12
    558a:	69 01       	movw	r12, r18
    558c:	84 91       	lpm	r24, Z+
    558e:	03 c0       	rjmp	.+6      	; 0x5596 <rprintf1RamRom+0x8a>
    5590:	f6 01       	movw	r30, r12
    5592:	80 81       	ld	r24, Z
    5594:	69 01       	movw	r12, r18
    5596:	84 36       	cpi	r24, 0x64	; 100
    5598:	29 f0       	breq	.+10     	; 0x55a4 <rprintf1RamRom+0x98>
    559a:	88 37       	cpi	r24, 0x78	; 120
    559c:	81 f0       	breq	.+32     	; 0x55be <rprintf1RamRom+0xb2>
    559e:	83 36       	cpi	r24, 0x63	; 99
    55a0:	f9 f6       	brne	.-66     	; 0x5560 <rprintf1RamRom+0x54>
    55a2:	06 c0       	rjmp	.+12     	; 0x55b0 <rprintf1RamRom+0xa4>
    55a4:	00 e1       	ldi	r16, 0x10	; 16
    55a6:	17 e2       	ldi	r17, 0x27	; 39
    55a8:	5a e0       	ldi	r21, 0x0A	; 10
    55aa:	a5 2e       	mov	r10, r21
    55ac:	b1 2c       	mov	r11, r1
    55ae:	0c c0       	rjmp	.+24     	; 0x55c8 <rprintf1RamRom+0xbc>
		{
			case 'c': format_flag = va_arg(ap,int);
    55b0:	f7 01       	movw	r30, r14
    55b2:	80 81       	ld	r24, Z
    55b4:	22 e0       	ldi	r18, 0x02	; 2
    55b6:	30 e0       	ldi	r19, 0x00	; 0
    55b8:	e2 0e       	add	r14, r18
    55ba:	f3 1e       	adc	r15, r19
    55bc:	d1 cf       	rjmp	.-94     	; 0x5560 <rprintf1RamRom+0x54>
			default:  rprintfChar(format_flag); continue;
    55be:	00 e0       	ldi	r16, 0x00	; 0
    55c0:	10 e1       	ldi	r17, 0x10	; 16
    55c2:	40 e1       	ldi	r20, 0x10	; 16
    55c4:	a4 2e       	mov	r10, r20
    55c6:	b1 2c       	mov	r11, r1
			case 'd': base = 10; div_val = 10000; goto CONVERSION_LOOP;
//			case 'x': base = 16; div_val = 0x10;
			case 'x': base = 16; div_val = 0x1000;

			CONVERSION_LOOP:
			u_val = va_arg(ap,int);
    55c8:	32 e0       	ldi	r19, 0x02	; 2
    55ca:	83 2e       	mov	r8, r19
    55cc:	91 2c       	mov	r9, r1
    55ce:	8e 0c       	add	r8, r14
    55d0:	9f 1c       	adc	r9, r15
    55d2:	f7 01       	movw	r30, r14
    55d4:	e0 80       	ld	r14, Z
    55d6:	f1 80       	ldd	r15, Z+1	; 0x01
			if (format_flag == 'd')
    55d8:	84 36       	cpi	r24, 0x64	; 100
    55da:	b1 f4       	brne	.+44     	; 0x5608 <rprintf1RamRom+0xfc>
			{
				if (((int)u_val) < 0)
    55dc:	f7 fe       	sbrs	r15, 7
    55de:	11 c0       	rjmp	.+34     	; 0x5602 <rprintf1RamRom+0xf6>
				{
					u_val = - u_val;
    55e0:	f0 94       	com	r15
    55e2:	e1 94       	neg	r14
    55e4:	f1 08       	sbc	r15, r1
    55e6:	f3 94       	inc	r15
					rprintfChar('-');
    55e8:	8d e2       	ldi	r24, 0x2D	; 45
    55ea:	0e 94 67 28 	call	0x50ce	; 0x50ce <rprintfChar>
    55ee:	09 c0       	rjmp	.+18     	; 0x5602 <rprintf1RamRom+0xf6>
				}
				while (div_val > 1 && div_val > u_val) div_val /= 10;
    55f0:	c8 01       	movw	r24, r16
    55f2:	6a e0       	ldi	r22, 0x0A	; 10
    55f4:	70 e0       	ldi	r23, 0x00	; 0
    55f6:	0e 94 f9 2f 	call	0x5ff2	; 0x5ff2 <__udivmodhi4>
    55fa:	8b 01       	movw	r16, r22
    55fc:	62 30       	cpi	r22, 0x02	; 2
    55fe:	71 05       	cpc	r23, r1
    5600:	18 f0       	brcs	.+6      	; 0x5608 <rprintf1RamRom+0xfc>
    5602:	e0 16       	cp	r14, r16
    5604:	f1 06       	cpc	r15, r17
    5606:	a0 f3       	brcs	.-24     	; 0x55f0 <rprintf1RamRom+0xe4>
			}
			do
			{
				//rprintfChar(pgm_read_byte(HexChars+(u_val/div_val)));
				rprintfu04(u_val/div_val);
    5608:	c7 01       	movw	r24, r14
    560a:	b8 01       	movw	r22, r16
    560c:	0e 94 f9 2f 	call	0x5ff2	; 0x5ff2 <__udivmodhi4>
    5610:	86 2f       	mov	r24, r22
    5612:	0e 94 ca 28 	call	0x5194	; 0x5194 <rprintfu04>
				u_val %= div_val;
    5616:	c7 01       	movw	r24, r14
    5618:	b8 01       	movw	r22, r16
    561a:	0e 94 f9 2f 	call	0x5ff2	; 0x5ff2 <__udivmodhi4>
    561e:	7c 01       	movw	r14, r24
				div_val /= base;
    5620:	c8 01       	movw	r24, r16
    5622:	b5 01       	movw	r22, r10
    5624:	0e 94 f9 2f 	call	0x5ff2	; 0x5ff2 <__udivmodhi4>
    5628:	8b 01       	movw	r16, r22
			} while (div_val);
    562a:	61 15       	cp	r22, r1
    562c:	71 05       	cpc	r23, r1
    562e:	61 f7       	brne	.-40     	; 0x5608 <rprintf1RamRom+0xfc>
    5630:	74 01       	movw	r14, r8
    5632:	98 cf       	rjmp	.-208    	; 0x5564 <rprintf1RamRom+0x58>

00005634 <i2cSetBitrate>:
	// SCL freq = F_CPU/(16+2*TWBR))
	#ifdef TWPS0
		// for processors with additional bitrate division (mega128)
		// SCL freq = F_CPU/(16+2*TWBR*4^TWPS)
		// set TWPS to zero
		cbi(TWSR, TWPS0);
    5634:	20 91 b9 00 	lds	r18, 0x00B9
    5638:	2e 7f       	andi	r18, 0xFE	; 254
    563a:	20 93 b9 00 	sts	0x00B9, r18
		cbi(TWSR, TWPS1);
    563e:	20 91 b9 00 	lds	r18, 0x00B9
    5642:	2d 7f       	andi	r18, 0xFD	; 253
    5644:	20 93 b9 00 	sts	0x00B9, r18
	#endif
	// calculate bitrate division	
	bitrate_div = ((F_CPU/1000l)/bitrateKHz);
    5648:	9c 01       	movw	r18, r24
    564a:	40 e0       	ldi	r20, 0x00	; 0
    564c:	50 e0       	ldi	r21, 0x00	; 0
    564e:	60 e8       	ldi	r22, 0x80	; 128
    5650:	7e e3       	ldi	r23, 0x3E	; 62
    5652:	80 e0       	ldi	r24, 0x00	; 0
    5654:	90 e0       	ldi	r25, 0x00	; 0
    5656:	0e 94 42 30 	call	0x6084	; 0x6084 <__divmodsi4>
	if(bitrate_div >= 16)
    565a:	20 31       	cpi	r18, 0x10	; 16
    565c:	30 f0       	brcs	.+12     	; 0x566a <i2cSetBitrate+0x36>
		bitrate_div = (bitrate_div-16)/2;
    565e:	82 2f       	mov	r24, r18
    5660:	90 e0       	ldi	r25, 0x00	; 0
    5662:	40 97       	sbiw	r24, 0x10	; 16
    5664:	95 95       	asr	r25
    5666:	87 95       	ror	r24
    5668:	28 2f       	mov	r18, r24
	outb(TWBR, bitrate_div);
    566a:	20 93 b8 00 	sts	0x00B8, r18
}
    566e:	08 95       	ret

00005670 <i2cInit>:

// functions
void i2cInit(void)
{
	// set pull-up resistors on I2C bus pins
	sbi(PORTD, 0);	// i2c SCL on 640
    5670:	58 9a       	sbi	0x0b, 0	; 11
	sbi(PORTD, 1);	// i2c SDA on 640
    5672:	59 9a       	sbi	0x0b, 1	; 11

	// clear SlaveReceive and SlaveTransmit handler to null
	i2cSlaveReceive = 0;
    5674:	10 92 30 12 	sts	0x1230, r1
    5678:	10 92 2f 12 	sts	0x122F, r1
	i2cSlaveTransmit = 0;
    567c:	10 92 32 12 	sts	0x1232, r1
    5680:	10 92 31 12 	sts	0x1231, r1
	// set i2c bit rate to 100KHz
	i2cSetBitrate(100);
    5684:	84 e6       	ldi	r24, 0x64	; 100
    5686:	90 e0       	ldi	r25, 0x00	; 0
    5688:	0e 94 1a 2b 	call	0x5634	; 0x5634 <i2cSetBitrate>
	// enable TWI (two-wire interface)
	sbi(TWCR, TWEN);
    568c:	ec eb       	ldi	r30, 0xBC	; 188
    568e:	f0 e0       	ldi	r31, 0x00	; 0
    5690:	80 81       	ld	r24, Z
    5692:	84 60       	ori	r24, 0x04	; 4
    5694:	80 83       	st	Z, r24
	// set state
	I2cState = I2C_IDLE;
    5696:	10 92 e9 11 	sts	0x11E9, r1
	// enable TWI interrupt and slave address ACK
	sbi(TWCR, TWIE);
    569a:	80 81       	ld	r24, Z
    569c:	81 60       	ori	r24, 0x01	; 1
    569e:	80 83       	st	Z, r24
	sbi(TWCR, TWEA);
    56a0:	80 81       	ld	r24, Z
    56a2:	80 64       	ori	r24, 0x40	; 64
    56a4:	80 83       	st	Z, r24
	//outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
	// enable interrupts
	sei();
    56a6:	78 94       	sei
}
    56a8:	08 95       	ret

000056aa <i2cSetLocalDeviceAddr>:
}

void i2cSetLocalDeviceAddr(u08 deviceAddr, u08 genCallEn)
{
	// set local device address (used in slave mode only)
	outb(TWAR, ((deviceAddr&0xFE) | (genCallEn?1:0)) );
    56aa:	90 e0       	ldi	r25, 0x00	; 0
    56ac:	61 11       	cpse	r22, r1
    56ae:	91 e0       	ldi	r25, 0x01	; 1
    56b0:	8e 7f       	andi	r24, 0xFE	; 254
    56b2:	98 2b       	or	r25, r24
    56b4:	90 93 ba 00 	sts	0x00BA, r25
}
    56b8:	08 95       	ret

000056ba <i2cSetSlaveReceiveHandler>:

void i2cSetSlaveReceiveHandler(void (*i2cSlaveRx_func)(u08 receiveDataLength, u08* recieveData))
{
	i2cSlaveReceive = i2cSlaveRx_func;
    56ba:	90 93 30 12 	sts	0x1230, r25
    56be:	80 93 2f 12 	sts	0x122F, r24
}
    56c2:	08 95       	ret

000056c4 <i2cSetSlaveTransmitHandler>:

void i2cSetSlaveTransmitHandler(u08 (*i2cSlaveTx_func)(u08 transmitDataLengthMax, u08* transmitData))
{
	i2cSlaveTransmit = i2cSlaveTx_func;
    56c4:	90 93 32 12 	sts	0x1232, r25
    56c8:	80 93 31 12 	sts	0x1231, r24
}
    56cc:	08 95       	ret

000056ce <i2cSendStart>:

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    56ce:	ec eb       	ldi	r30, 0xBC	; 188
    56d0:	f0 e0       	ldi	r31, 0x00	; 0
    56d2:	80 81       	ld	r24, Z
    56d4:	8f 70       	andi	r24, 0x0F	; 15
    56d6:	80 6a       	ori	r24, 0xA0	; 160
    56d8:	80 83       	st	Z, r24
}
    56da:	08 95       	ret

000056dc <i2cSendStop>:

inline void i2cSendStop(void)
{
	// transmit stop condition
	// leave with TWEA on for slave receiving
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA)|BV(TWSTO));
    56dc:	ec eb       	ldi	r30, 0xBC	; 188
    56de:	f0 e0       	ldi	r31, 0x00	; 0
    56e0:	80 81       	ld	r24, Z
    56e2:	8f 70       	andi	r24, 0x0F	; 15
    56e4:	80 6d       	ori	r24, 0xD0	; 208
    56e6:	80 83       	st	Z, r24
}
    56e8:	08 95       	ret

000056ea <i2cWaitForComplete>:

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    56ea:	80 91 bc 00 	lds	r24, 0x00BC
    56ee:	87 ff       	sbrs	r24, 7
    56f0:	fc cf       	rjmp	.-8      	; 0x56ea <i2cWaitForComplete>
}
    56f2:	08 95       	ret

000056f4 <i2cSendByte>:

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    56f4:	80 93 bb 00 	sts	0x00BB, r24
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    56f8:	ec eb       	ldi	r30, 0xBC	; 188
    56fa:	f0 e0       	ldi	r31, 0x00	; 0
    56fc:	80 81       	ld	r24, Z
    56fe:	8f 70       	andi	r24, 0x0F	; 15
    5700:	80 68       	ori	r24, 0x80	; 128
    5702:	80 83       	st	Z, r24
}
    5704:	08 95       	ret

00005706 <i2cReceiveByte>:

inline void i2cReceiveByte(u08 ackFlag)
{
	// begin receive over i2c
	if( ackFlag )
    5706:	88 23       	and	r24, r24
    5708:	29 f0       	breq	.+10     	; 0x5714 <i2cReceiveByte+0xe>
	{
		// ackFlag = TRUE: ACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    570a:	80 91 bc 00 	lds	r24, 0x00BC
    570e:	8f 70       	andi	r24, 0x0F	; 15
    5710:	80 6c       	ori	r24, 0xC0	; 192
    5712:	04 c0       	rjmp	.+8      	; 0x571c <i2cReceiveByte+0x16>
	}
	else
	{
		// ackFlag = FALSE: NACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    5714:	80 91 bc 00 	lds	r24, 0x00BC
    5718:	8f 70       	andi	r24, 0x0F	; 15
    571a:	80 68       	ori	r24, 0x80	; 128
    571c:	80 93 bc 00 	sts	0x00BC, r24
    5720:	08 95       	ret

00005722 <i2cGetReceivedByte>:
}

inline u08 i2cGetReceivedByte(void)
{
	// retieve received data byte from i2c TWDR
	return( inb(TWDR) );
    5722:	80 91 bb 00 	lds	r24, 0x00BB
}
    5726:	08 95       	ret

00005728 <i2cGetStatus>:

inline u08 i2cGetStatus(void)
{
	// retieve current i2c status from i2c TWSR
	return( inb(TWSR) );
    5728:	80 91 b9 00 	lds	r24, 0x00B9
}
    572c:	08 95       	ret

0000572e <i2cMasterSend>:

void i2cMasterSend(u08 deviceAddr, u08 length, u08* data)
{
    572e:	98 2f       	mov	r25, r24
	u08 i;
	// wait for interface to be ready
	while(I2cState);
    5730:	80 91 e9 11 	lds	r24, 0x11E9
    5734:	88 23       	and	r24, r24
    5736:	e1 f7       	brne	.-8      	; 0x5730 <i2cMasterSend+0x2>
	// set state
	I2cState = I2C_MASTER_TX;
    5738:	82 e0       	ldi	r24, 0x02	; 2
    573a:	80 93 e9 11 	sts	0x11E9, r24
	// save data
	I2cDeviceAddrRW = (deviceAddr & 0xFE);	// RW cleared: write operation
    573e:	9e 7f       	andi	r25, 0xFE	; 254
    5740:	90 93 ea 11 	sts	0x11EA, r25
    5744:	ab ee       	ldi	r26, 0xEB	; 235
    5746:	b1 e1       	ldi	r27, 0x11	; 17
    5748:	fa 01       	movw	r30, r20
    574a:	02 c0       	rjmp	.+4      	; 0x5750 <i2cMasterSend+0x22>
	for(i=0; i<length; i++)
		I2cSendData[i] = *data++;
    574c:	81 91       	ld	r24, Z+
    574e:	8d 93       	st	X+, r24
	while(I2cState);
	// set state
	I2cState = I2C_MASTER_TX;
	// save data
	I2cDeviceAddrRW = (deviceAddr & 0xFE);	// RW cleared: write operation
	for(i=0; i<length; i++)
    5750:	8e 2f       	mov	r24, r30
    5752:	84 1b       	sub	r24, r20
    5754:	86 17       	cp	r24, r22
    5756:	d0 f3       	brcs	.-12     	; 0x574c <i2cMasterSend+0x1e>
		I2cSendData[i] = *data++;
	I2cSendDataIndex = 0;
    5758:	10 92 0b 12 	sts	0x120B, r1
	I2cSendDataLength = length;
    575c:	60 93 0c 12 	sts	0x120C, r22
}

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    5760:	80 91 bc 00 	lds	r24, 0x00BC
    5764:	8f 70       	andi	r24, 0x0F	; 15
    5766:	80 6a       	ori	r24, 0xA0	; 160
    5768:	80 93 bc 00 	sts	0x00BC, r24
		I2cSendData[i] = *data++;
	I2cSendDataIndex = 0;
	I2cSendDataLength = length;
	// send start condition
	i2cSendStart();
}
    576c:	08 95       	ret

0000576e <i2cMasterReceive>:

void i2cMasterReceive(u08 deviceAddr, u08 length, u08* data)
{
    576e:	98 2f       	mov	r25, r24
	u08 i;
	// wait for interface to be ready
	while(I2cState);
    5770:	80 91 e9 11 	lds	r24, 0x11E9
    5774:	88 23       	and	r24, r24
    5776:	e1 f7       	brne	.-8      	; 0x5770 <i2cMasterReceive+0x2>
	// set state
	I2cState = I2C_MASTER_RX;
    5778:	83 e0       	ldi	r24, 0x03	; 3
    577a:	80 93 e9 11 	sts	0x11E9, r24
	// save data
	I2cDeviceAddrRW = (deviceAddr|0x01);	// RW set: read operation
    577e:	91 60       	ori	r25, 0x01	; 1
    5780:	90 93 ea 11 	sts	0x11EA, r25
	I2cReceiveDataIndex = 0;
    5784:	10 92 2d 12 	sts	0x122D, r1
	I2cReceiveDataLength = length;
    5788:	60 93 2e 12 	sts	0x122E, r22
}

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    578c:	80 91 bc 00 	lds	r24, 0x00BC
    5790:	8f 70       	andi	r24, 0x0F	; 15
    5792:	80 6a       	ori	r24, 0xA0	; 160
    5794:	80 93 bc 00 	sts	0x00BC, r24
	I2cReceiveDataIndex = 0;
	I2cReceiveDataLength = length;
	// send start condition
	i2cSendStart();
	// wait for data
	while(I2cState);
    5798:	80 91 e9 11 	lds	r24, 0x11E9
    579c:	88 23       	and	r24, r24
    579e:	e1 f7       	brne	.-8      	; 0x5798 <i2cMasterReceive+0x2a>
    57a0:	ad e0       	ldi	r26, 0x0D	; 13
    57a2:	b2 e1       	ldi	r27, 0x12	; 18
    57a4:	fa 01       	movw	r30, r20
    57a6:	02 c0       	rjmp	.+4      	; 0x57ac <i2cMasterReceive+0x3e>
	// return data
	for(i=0; i<length; i++)
		*data++ = I2cReceiveData[i];
    57a8:	8d 91       	ld	r24, X+
    57aa:	81 93       	st	Z+, r24
	// send start condition
	i2cSendStart();
	// wait for data
	while(I2cState);
	// return data
	for(i=0; i<length; i++)
    57ac:	8e 2f       	mov	r24, r30
    57ae:	84 1b       	sub	r24, r20
    57b0:	86 17       	cp	r24, r22
    57b2:	d0 f3       	brcs	.-12     	; 0x57a8 <i2cMasterReceive+0x3a>
		*data++ = I2cReceiveData[i];
}
    57b4:	08 95       	ret

000057b6 <i2cMasterSendNI>:

u08 i2cMasterSendNI(u08 deviceAddr, u08 length, u08* data)
{
    57b6:	98 2f       	mov	r25, r24
    57b8:	fa 01       	movw	r30, r20
	u08 retval = I2C_OK;

	// disable TWI interrupt
	cbi(TWCR, TWIE);
    57ba:	80 91 bc 00 	lds	r24, 0x00BC
    57be:	8e 7f       	andi	r24, 0xFE	; 254
    57c0:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    57c4:	80 91 bc 00 	lds	r24, 0x00BC
    57c8:	8f 70       	andi	r24, 0x0F	; 15
    57ca:	80 6a       	ori	r24, 0xA0	; 160
    57cc:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    57d0:	80 91 bc 00 	lds	r24, 0x00BC
    57d4:	87 ff       	sbrs	r24, 7
    57d6:	fc cf       	rjmp	.-8      	; 0x57d0 <i2cMasterSendNI+0x1a>
	// send start condition
	i2cSendStart();
	i2cWaitForComplete();

	// send device address with write
	i2cSendByte( deviceAddr & 0xFE );
    57d8:	9e 7f       	andi	r25, 0xFE	; 254
}

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    57da:	90 93 bb 00 	sts	0x00BB, r25
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    57de:	80 91 bc 00 	lds	r24, 0x00BC
    57e2:	8f 70       	andi	r24, 0x0F	; 15
    57e4:	80 68       	ori	r24, 0x80	; 128
    57e6:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    57ea:	80 91 bc 00 	lds	r24, 0x00BC
    57ee:	87 ff       	sbrs	r24, 7
    57f0:	fc cf       	rjmp	.-8      	; 0x57ea <i2cMasterSendNI+0x34>
	// send device address with write
	i2cSendByte( deviceAddr & 0xFE );
	i2cWaitForComplete();

	// check if device is present and live
	if( inb(TWSR) == TW_MT_SLA_ACK)
    57f2:	80 91 b9 00 	lds	r24, 0x00B9
    57f6:	88 31       	cpi	r24, 0x18	; 24
    57f8:	89 f0       	breq	.+34     	; 0x581c <i2cMasterSendNI+0x66>
    57fa:	91 e0       	ldi	r25, 0x01	; 1
    57fc:	12 c0       	rjmp	.+36     	; 0x5822 <i2cMasterSendNI+0x6c>
	{
		// send data
		while(length)
		{
			i2cSendByte( *data++ );
    57fe:	80 81       	ld	r24, Z
}

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    5800:	80 93 bb 00 	sts	0x00BB, r24
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    5804:	80 91 bc 00 	lds	r24, 0x00BC
    5808:	8f 70       	andi	r24, 0x0F	; 15
    580a:	80 68       	ori	r24, 0x80	; 128
    580c:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    5810:	80 91 bc 00 	lds	r24, 0x00BC
    5814:	87 ff       	sbrs	r24, 7
    5816:	fc cf       	rjmp	.-8      	; 0x5810 <i2cMasterSendNI+0x5a>
	if( inb(TWSR) == TW_MT_SLA_ACK)
	{
		// send data
		while(length)
		{
			i2cSendByte( *data++ );
    5818:	31 96       	adiw	r30, 0x01	; 1
			i2cWaitForComplete();
			length--;
    581a:	61 50       	subi	r22, 0x01	; 1

	// check if device is present and live
	if( inb(TWSR) == TW_MT_SLA_ACK)
	{
		// send data
		while(length)
    581c:	66 23       	and	r22, r22
    581e:	79 f7       	brne	.-34     	; 0x57fe <i2cMasterSendNI+0x48>
    5820:	90 e0       	ldi	r25, 0x00	; 0

inline void i2cSendStop(void)
{
	// transmit stop condition
	// leave with TWEA on for slave receiving
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA)|BV(TWSTO));
    5822:	80 91 bc 00 	lds	r24, 0x00BC
    5826:	8f 70       	andi	r24, 0x0F	; 15
    5828:	80 6d       	ori	r24, 0xD0	; 208
    582a:	80 93 bc 00 	sts	0x00BC, r24
	}

	// transmit stop condition
	// leave with TWEA on for slave receiving
	i2cSendStop();
	while( !(inb(TWCR) & BV(TWSTO)) );
    582e:	80 91 bc 00 	lds	r24, 0x00BC
    5832:	84 ff       	sbrs	r24, 4
    5834:	fc cf       	rjmp	.-8      	; 0x582e <i2cMasterSendNI+0x78>

	// enable TWI interrupt
	sbi(TWCR, TWIE);
    5836:	80 91 bc 00 	lds	r24, 0x00BC
    583a:	81 60       	ori	r24, 0x01	; 1
    583c:	80 93 bc 00 	sts	0x00BC, r24

	return retval;
}
    5840:	89 2f       	mov	r24, r25
    5842:	08 95       	ret

00005844 <i2cMasterReceiveNI>:

u08 i2cMasterReceiveNI(u08 deviceAddr, u08 length, u08 *data)
{
    5844:	98 2f       	mov	r25, r24
    5846:	fa 01       	movw	r30, r20
	u08 retval = I2C_OK;

	// disable TWI interrupt
	cbi(TWCR, TWIE);
    5848:	80 91 bc 00 	lds	r24, 0x00BC
    584c:	8e 7f       	andi	r24, 0xFE	; 254
    584e:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    5852:	80 91 bc 00 	lds	r24, 0x00BC
    5856:	8f 70       	andi	r24, 0x0F	; 15
    5858:	80 6a       	ori	r24, 0xA0	; 160
    585a:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    585e:	80 91 bc 00 	lds	r24, 0x00BC
    5862:	87 ff       	sbrs	r24, 7
    5864:	fc cf       	rjmp	.-8      	; 0x585e <i2cMasterReceiveNI+0x1a>
	// send start condition
	i2cSendStart();
	i2cWaitForComplete();

	// send device address with read
	i2cSendByte( deviceAddr | 0x01 );
    5866:	91 60       	ori	r25, 0x01	; 1
}

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    5868:	90 93 bb 00 	sts	0x00BB, r25
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    586c:	80 91 bc 00 	lds	r24, 0x00BC
    5870:	8f 70       	andi	r24, 0x0F	; 15
    5872:	80 68       	ori	r24, 0x80	; 128
    5874:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    5878:	80 91 bc 00 	lds	r24, 0x00BC
    587c:	87 ff       	sbrs	r24, 7
    587e:	fc cf       	rjmp	.-8      	; 0x5878 <i2cMasterReceiveNI+0x34>
	// send device address with read
	i2cSendByte( deviceAddr | 0x01 );
	i2cWaitForComplete();

	// check if device is present and live
	if( inb(TWSR) == TW_MR_SLA_ACK)
    5880:	80 91 b9 00 	lds	r24, 0x00B9
    5884:	80 34       	cpi	r24, 0x40	; 64
    5886:	81 f0       	breq	.+32     	; 0x58a8 <i2cMasterReceiveNI+0x64>
    5888:	91 e0       	ldi	r25, 0x01	; 1
    588a:	1e c0       	rjmp	.+60     	; 0x58c8 <i2cMasterReceiveNI+0x84>
{
	// begin receive over i2c
	if( ackFlag )
	{
		// ackFlag = TRUE: ACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    588c:	80 91 bc 00 	lds	r24, 0x00BC
    5890:	8f 70       	andi	r24, 0x0F	; 15
    5892:	80 6c       	ori	r24, 0xC0	; 192
    5894:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    5898:	80 91 bc 00 	lds	r24, 0x00BC
    589c:	87 ff       	sbrs	r24, 7
    589e:	fc cf       	rjmp	.-8      	; 0x5898 <i2cMasterReceiveNI+0x54>
}

inline u08 i2cGetReceivedByte(void)
{
	// retieve received data byte from i2c TWDR
	return( inb(TWDR) );
    58a0:	80 91 bb 00 	lds	r24, 0x00BB
		// accept receive data and ack it
		while(length > 1)
		{
			i2cReceiveByte(TRUE);
			i2cWaitForComplete();
			*data++ = i2cGetReceivedByte();
    58a4:	81 93       	st	Z+, r24
			// decrement length
			length--;
    58a6:	61 50       	subi	r22, 0x01	; 1

	// check if device is present and live
	if( inb(TWSR) == TW_MR_SLA_ACK)
	{
		// accept receive data and ack it
		while(length > 1)
    58a8:	62 30       	cpi	r22, 0x02	; 2
    58aa:	80 f7       	brcc	.-32     	; 0x588c <i2cMasterReceiveNI+0x48>
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
	}
	else
	{
		// ackFlag = FALSE: NACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    58ac:	80 91 bc 00 	lds	r24, 0x00BC
    58b0:	8f 70       	andi	r24, 0x0F	; 15
    58b2:	80 68       	ori	r24, 0x80	; 128
    58b4:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    58b8:	80 91 bc 00 	lds	r24, 0x00BC
    58bc:	87 ff       	sbrs	r24, 7
    58be:	fc cf       	rjmp	.-8      	; 0x58b8 <i2cMasterReceiveNI+0x74>
}

inline u08 i2cGetReceivedByte(void)
{
	// retieve received data byte from i2c TWDR
	return( inb(TWDR) );
    58c0:	80 91 bb 00 	lds	r24, 0x00BB
		}

		// accept receive data and nack it (last-byte signal)
		i2cReceiveByte(FALSE);
		i2cWaitForComplete();
		*data++ = i2cGetReceivedByte();
    58c4:	80 83       	st	Z, r24
    58c6:	90 e0       	ldi	r25, 0x00	; 0

inline void i2cSendStop(void)
{
	// transmit stop condition
	// leave with TWEA on for slave receiving
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA)|BV(TWSTO));
    58c8:	80 91 bc 00 	lds	r24, 0x00BC
    58cc:	8f 70       	andi	r24, 0x0F	; 15
    58ce:	80 6d       	ori	r24, 0xD0	; 208
    58d0:	80 93 bc 00 	sts	0x00BC, r24
	// transmit stop condition
	// leave with TWEA on for slave receiving
	i2cSendStop();

	// enable TWI interrupt
	sbi(TWCR, TWIE);
    58d4:	80 91 bc 00 	lds	r24, 0x00BC
    58d8:	81 60       	ori	r24, 0x01	; 1
    58da:	80 93 bc 00 	sts	0x00BC, r24

	return retval;
}
    58de:	89 2f       	mov	r24, r25
    58e0:	08 95       	ret

000058e2 <__vector_39>:
}
*/

//! I2C (TWI) interrupt service routine
SIGNAL(SIG_2WIRE_SERIAL)
{
    58e2:	1f 92       	push	r1
    58e4:	0f 92       	push	r0
    58e6:	0f b6       	in	r0, 0x3f	; 63
    58e8:	0f 92       	push	r0
    58ea:	11 24       	eor	r1, r1
    58ec:	2f 93       	push	r18
    58ee:	3f 93       	push	r19
    58f0:	4f 93       	push	r20
    58f2:	5f 93       	push	r21
    58f4:	6f 93       	push	r22
    58f6:	7f 93       	push	r23
    58f8:	8f 93       	push	r24
    58fa:	9f 93       	push	r25
    58fc:	af 93       	push	r26
    58fe:	bf 93       	push	r27
    5900:	ef 93       	push	r30
    5902:	ff 93       	push	r31
	// read status bits
	u08 status = inb(TWSR) & TWSR_STATUS_MASK;
    5904:	80 91 b9 00 	lds	r24, 0x00B9

	switch(status)
    5908:	88 7f       	andi	r24, 0xF8	; 248
    590a:	80 36       	cpi	r24, 0x60	; 96
    590c:	09 f4       	brne	.+2      	; 0x5910 <__vector_39+0x2e>
    590e:	a0 c0       	rjmp	.+320    	; 0x5a50 <__vector_39+0x16e>
    5910:	81 36       	cpi	r24, 0x61	; 97
    5912:	70 f5       	brcc	.+92     	; 0x5970 <__vector_39+0x8e>
    5914:	88 32       	cpi	r24, 0x28	; 40
    5916:	09 f4       	brne	.+2      	; 0x591a <__vector_39+0x38>
    5918:	5f c0       	rjmp	.+190    	; 0x59d8 <__vector_39+0xf6>
    591a:	89 32       	cpi	r24, 0x29	; 41
    591c:	98 f4       	brcc	.+38     	; 0x5944 <__vector_39+0x62>
    591e:	80 31       	cpi	r24, 0x10	; 16
    5920:	09 f4       	brne	.+2      	; 0x5924 <__vector_39+0x42>
    5922:	57 c0       	rjmp	.+174    	; 0x59d2 <__vector_39+0xf0>
    5924:	81 31       	cpi	r24, 0x11	; 17
    5926:	38 f4       	brcc	.+14     	; 0x5936 <__vector_39+0x54>
    5928:	88 23       	and	r24, r24
    592a:	09 f4       	brne	.+2      	; 0x592e <__vector_39+0x4c>
    592c:	ea c0       	rjmp	.+468    	; 0x5b02 <__vector_39+0x220>
    592e:	88 30       	cpi	r24, 0x08	; 8
    5930:	09 f0       	breq	.+2      	; 0x5934 <__vector_39+0x52>
    5932:	ef c0       	rjmp	.+478    	; 0x5b12 <__vector_39+0x230>
    5934:	4e c0       	rjmp	.+156    	; 0x59d2 <__vector_39+0xf0>
    5936:	88 31       	cpi	r24, 0x18	; 24
    5938:	09 f4       	brne	.+2      	; 0x593c <__vector_39+0x5a>
    593a:	4e c0       	rjmp	.+156    	; 0x59d8 <__vector_39+0xf6>
    593c:	80 32       	cpi	r24, 0x20	; 32
    593e:	09 f0       	breq	.+2      	; 0x5942 <__vector_39+0x60>
    5940:	e8 c0       	rjmp	.+464    	; 0x5b12 <__vector_39+0x230>
    5942:	df c0       	rjmp	.+446    	; 0x5b02 <__vector_39+0x220>
    5944:	80 34       	cpi	r24, 0x40	; 64
    5946:	09 f4       	brne	.+2      	; 0x594a <__vector_39+0x68>
    5948:	77 c0       	rjmp	.+238    	; 0x5a38 <__vector_39+0x156>
    594a:	81 34       	cpi	r24, 0x41	; 65
    594c:	38 f4       	brcc	.+14     	; 0x595c <__vector_39+0x7a>
    594e:	80 33       	cpi	r24, 0x30	; 48
    5950:	09 f4       	brne	.+2      	; 0x5954 <__vector_39+0x72>
    5952:	d7 c0       	rjmp	.+430    	; 0x5b02 <__vector_39+0x220>
    5954:	88 33       	cpi	r24, 0x38	; 56
    5956:	09 f0       	breq	.+2      	; 0x595a <__vector_39+0x78>
    5958:	dc c0       	rjmp	.+440    	; 0x5b12 <__vector_39+0x230>
    595a:	5d c0       	rjmp	.+186    	; 0x5a16 <__vector_39+0x134>
    595c:	80 35       	cpi	r24, 0x50	; 80
    595e:	09 f4       	brne	.+2      	; 0x5962 <__vector_39+0x80>
    5960:	5f c0       	rjmp	.+190    	; 0x5a20 <__vector_39+0x13e>
    5962:	88 35       	cpi	r24, 0x58	; 88
    5964:	09 f4       	brne	.+2      	; 0x5968 <__vector_39+0x86>
    5966:	4a c0       	rjmp	.+148    	; 0x59fc <__vector_39+0x11a>
    5968:	88 34       	cpi	r24, 0x48	; 72
    596a:	09 f0       	breq	.+2      	; 0x596e <__vector_39+0x8c>
    596c:	d2 c0       	rjmp	.+420    	; 0x5b12 <__vector_39+0x230>
    596e:	c9 c0       	rjmp	.+402    	; 0x5b02 <__vector_39+0x220>
    5970:	88 39       	cpi	r24, 0x98	; 152
    5972:	09 f4       	brne	.+2      	; 0x5976 <__vector_39+0x94>
    5974:	ba c0       	rjmp	.+372    	; 0x5aea <__vector_39+0x208>
    5976:	89 39       	cpi	r24, 0x99	; 153
    5978:	b0 f4       	brcc	.+44     	; 0x59a6 <__vector_39+0xc4>
    597a:	88 37       	cpi	r24, 0x78	; 120
    597c:	09 f4       	brne	.+2      	; 0x5980 <__vector_39+0x9e>
    597e:	68 c0       	rjmp	.+208    	; 0x5a50 <__vector_39+0x16e>
    5980:	89 37       	cpi	r24, 0x79	; 121
    5982:	38 f4       	brcc	.+14     	; 0x5992 <__vector_39+0xb0>
    5984:	88 36       	cpi	r24, 0x68	; 104
    5986:	09 f4       	brne	.+2      	; 0x598a <__vector_39+0xa8>
    5988:	63 c0       	rjmp	.+198    	; 0x5a50 <__vector_39+0x16e>
    598a:	80 37       	cpi	r24, 0x70	; 112
    598c:	09 f0       	breq	.+2      	; 0x5990 <__vector_39+0xae>
    598e:	c1 c0       	rjmp	.+386    	; 0x5b12 <__vector_39+0x230>
    5990:	5f c0       	rjmp	.+190    	; 0x5a50 <__vector_39+0x16e>
    5992:	88 38       	cpi	r24, 0x88	; 136
    5994:	09 f4       	brne	.+2      	; 0x5998 <__vector_39+0xb6>
    5996:	a9 c0       	rjmp	.+338    	; 0x5aea <__vector_39+0x208>
    5998:	80 39       	cpi	r24, 0x90	; 144
    599a:	09 f4       	brne	.+2      	; 0x599e <__vector_39+0xbc>
    599c:	5f c0       	rjmp	.+190    	; 0x5a5c <__vector_39+0x17a>
    599e:	80 38       	cpi	r24, 0x80	; 128
    59a0:	09 f0       	breq	.+2      	; 0x59a4 <__vector_39+0xc2>
    59a2:	b7 c0       	rjmp	.+366    	; 0x5b12 <__vector_39+0x230>
    59a4:	5b c0       	rjmp	.+182    	; 0x5a5c <__vector_39+0x17a>
    59a6:	80 3b       	cpi	r24, 0xB0	; 176
    59a8:	09 f4       	brne	.+2      	; 0x59ac <__vector_39+0xca>
    59aa:	79 c0       	rjmp	.+242    	; 0x5a9e <__vector_39+0x1bc>
    59ac:	81 3b       	cpi	r24, 0xB1	; 177
    59ae:	38 f4       	brcc	.+14     	; 0x59be <__vector_39+0xdc>
    59b0:	80 3a       	cpi	r24, 0xA0	; 160
    59b2:	09 f4       	brne	.+2      	; 0x59b6 <__vector_39+0xd4>
    59b4:	62 c0       	rjmp	.+196    	; 0x5a7a <__vector_39+0x198>
    59b6:	88 3a       	cpi	r24, 0xA8	; 168
    59b8:	09 f0       	breq	.+2      	; 0x59bc <__vector_39+0xda>
    59ba:	ab c0       	rjmp	.+342    	; 0x5b12 <__vector_39+0x230>
    59bc:	70 c0       	rjmp	.+224    	; 0x5a9e <__vector_39+0x1bc>
    59be:	80 3c       	cpi	r24, 0xC0	; 192
    59c0:	09 f4       	brne	.+2      	; 0x59c4 <__vector_39+0xe2>
    59c2:	9a c0       	rjmp	.+308    	; 0x5af8 <__vector_39+0x216>
    59c4:	88 3c       	cpi	r24, 0xC8	; 200
    59c6:	09 f4       	brne	.+2      	; 0x59ca <__vector_39+0xe8>
    59c8:	97 c0       	rjmp	.+302    	; 0x5af8 <__vector_39+0x216>
    59ca:	88 3b       	cpi	r24, 0xB8	; 184
    59cc:	09 f0       	breq	.+2      	; 0x59d0 <__vector_39+0xee>
    59ce:	a1 c0       	rjmp	.+322    	; 0x5b12 <__vector_39+0x230>
    59d0:	77 c0       	rjmp	.+238    	; 0x5ac0 <__vector_39+0x1de>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: M->START\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// send device address
		i2cSendByte(I2cDeviceAddrRW);
    59d2:	80 91 ea 11 	lds	r24, 0x11EA
    59d6:	0f c0       	rjmp	.+30     	; 0x59f6 <__vector_39+0x114>
		#ifdef I2C_DEBUG
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MT->SLA_ACK or DATA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		if(I2cSendDataIndex < I2cSendDataLength)
    59d8:	90 91 0b 12 	lds	r25, 0x120B
    59dc:	80 91 0c 12 	lds	r24, 0x120C
    59e0:	98 17       	cp	r25, r24
    59e2:	08 f0       	brcs	.+2      	; 0x59e6 <__vector_39+0x104>
    59e4:	8e c0       	rjmp	.+284    	; 0x5b02 <__vector_39+0x220>
		{
			// send data
			i2cSendByte( I2cSendData[I2cSendDataIndex++] );
    59e6:	e9 2f       	mov	r30, r25
    59e8:	f0 e0       	ldi	r31, 0x00	; 0
    59ea:	e5 51       	subi	r30, 0x15	; 21
    59ec:	fe 4e       	sbci	r31, 0xEE	; 238
    59ee:	80 81       	ld	r24, Z
    59f0:	9f 5f       	subi	r25, 0xFF	; 255
    59f2:	90 93 0b 12 	sts	0x120B, r25
}

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    59f6:	80 93 bb 00 	sts	0x00BB, r24
    59fa:	77 c0       	rjmp	.+238    	; 0x5aea <__vector_39+0x208>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MR->DATA_NACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// store final received data byte
		I2cReceiveData[I2cReceiveDataIndex++] = inb(TWDR);
    59fc:	80 91 2d 12 	lds	r24, 0x122D
    5a00:	90 91 bb 00 	lds	r25, 0x00BB
    5a04:	e8 2f       	mov	r30, r24
    5a06:	f0 e0       	ldi	r31, 0x00	; 0
    5a08:	e3 5f       	subi	r30, 0xF3	; 243
    5a0a:	fd 4e       	sbci	r31, 0xED	; 237
    5a0c:	90 83       	st	Z, r25
    5a0e:	8f 5f       	subi	r24, 0xFF	; 255
    5a10:	80 93 2d 12 	sts	0x122D, r24
    5a14:	76 c0       	rjmp	.+236    	; 0x5b02 <__vector_39+0x220>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MT->ARB_LOST\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// release bus
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    5a16:	80 91 bc 00 	lds	r24, 0x00BC
    5a1a:	8f 70       	andi	r24, 0x0F	; 15
    5a1c:	80 68       	ori	r24, 0x80	; 128
    5a1e:	75 c0       	rjmp	.+234    	; 0x5b0a <__vector_39+0x228>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MR->DATA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// store received data byte
		I2cReceiveData[I2cReceiveDataIndex++] = inb(TWDR);
    5a20:	80 91 2d 12 	lds	r24, 0x122D
    5a24:	90 91 bb 00 	lds	r25, 0x00BB
    5a28:	e8 2f       	mov	r30, r24
    5a2a:	f0 e0       	ldi	r31, 0x00	; 0
    5a2c:	e3 5f       	subi	r30, 0xF3	; 243
    5a2e:	fd 4e       	sbci	r31, 0xED	; 237
    5a30:	90 83       	st	Z, r25
    5a32:	8f 5f       	subi	r24, 0xFF	; 255
    5a34:	80 93 2d 12 	sts	0x122D, r24
		#ifdef I2C_DEBUG
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MR->SLA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		if(I2cReceiveDataIndex < (I2cReceiveDataLength-1))
    5a38:	20 91 2d 12 	lds	r18, 0x122D
    5a3c:	30 e0       	ldi	r19, 0x00	; 0
    5a3e:	80 91 2e 12 	lds	r24, 0x122E
    5a42:	90 e0       	ldi	r25, 0x00	; 0
    5a44:	01 97       	sbiw	r24, 0x01	; 1
    5a46:	28 17       	cp	r18, r24
    5a48:	39 07       	cpc	r19, r25
    5a4a:	0c f0       	brlt	.+2      	; 0x5a4e <__vector_39+0x16c>
    5a4c:	4e c0       	rjmp	.+156    	; 0x5aea <__vector_39+0x208>
    5a4e:	48 c0       	rjmp	.+144    	; 0x5ae0 <__vector_39+0x1fe>
		rprintf("I2C: SR->SLA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// we are being addressed as slave for writing (data will be received from master)
		// set state
		I2cState = I2C_SLAVE_RX;
    5a50:	85 e0       	ldi	r24, 0x05	; 5
    5a52:	80 93 e9 11 	sts	0x11E9, r24
		// prepare buffer
		I2cReceiveDataIndex = 0;
    5a56:	10 92 2d 12 	sts	0x122D, r1
    5a5a:	42 c0       	rjmp	.+132    	; 0x5ae0 <__vector_39+0x1fe>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: SR->DATA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// get previously received data byte
		I2cReceiveData[I2cReceiveDataIndex++] = inb(TWDR);
    5a5c:	80 91 2d 12 	lds	r24, 0x122D
    5a60:	90 91 bb 00 	lds	r25, 0x00BB
    5a64:	e8 2f       	mov	r30, r24
    5a66:	f0 e0       	ldi	r31, 0x00	; 0
    5a68:	e3 5f       	subi	r30, 0xF3	; 243
    5a6a:	fd 4e       	sbci	r31, 0xED	; 237
    5a6c:	90 83       	st	Z, r25
    5a6e:	8f 5f       	subi	r24, 0xFF	; 255
    5a70:	80 93 2d 12 	sts	0x122D, r24
		// check receive buffer status
		if(I2cReceiveDataIndex < I2C_RECEIVE_DATA_BUFFER_SIZE)
    5a74:	80 32       	cpi	r24, 0x20	; 32
    5a76:	c8 f5       	brcc	.+114    	; 0x5aea <__vector_39+0x208>
    5a78:	33 c0       	rjmp	.+102    	; 0x5ae0 <__vector_39+0x1fe>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: SR->SR_STOP\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// switch to SR mode with SLA ACK
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    5a7a:	80 91 bc 00 	lds	r24, 0x00BC
    5a7e:	8f 70       	andi	r24, 0x0F	; 15
    5a80:	80 6c       	ori	r24, 0xC0	; 192
    5a82:	80 93 bc 00 	sts	0x00BC, r24
		// i2c receive is complete, call i2cSlaveReceive
		if(i2cSlaveReceive) i2cSlaveReceive(I2cReceiveDataIndex, I2cReceiveData);
    5a86:	e0 91 2f 12 	lds	r30, 0x122F
    5a8a:	f0 91 30 12 	lds	r31, 0x1230
    5a8e:	30 97       	sbiw	r30, 0x00	; 0
    5a90:	f1 f1       	breq	.+124    	; 0x5b0e <__vector_39+0x22c>
    5a92:	80 91 2d 12 	lds	r24, 0x122D
    5a96:	6d e0       	ldi	r22, 0x0D	; 13
    5a98:	72 e1       	ldi	r23, 0x12	; 18
    5a9a:	09 95       	icall
    5a9c:	38 c0       	rjmp	.+112    	; 0x5b0e <__vector_39+0x22c>
		rprintf("I2C: ST->SLA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// we are being addressed as slave for reading (data must be transmitted back to master)
		// set state
		I2cState = I2C_SLAVE_TX;
    5a9e:	84 e0       	ldi	r24, 0x04	; 4
    5aa0:	80 93 e9 11 	sts	0x11E9, r24
		// request data from application
		if(i2cSlaveTransmit) I2cSendDataLength = i2cSlaveTransmit(I2C_SEND_DATA_BUFFER_SIZE, I2cSendData);
    5aa4:	e0 91 31 12 	lds	r30, 0x1231
    5aa8:	f0 91 32 12 	lds	r31, 0x1232
    5aac:	30 97       	sbiw	r30, 0x00	; 0
    5aae:	31 f0       	breq	.+12     	; 0x5abc <__vector_39+0x1da>
    5ab0:	80 e2       	ldi	r24, 0x20	; 32
    5ab2:	6b ee       	ldi	r22, 0xEB	; 235
    5ab4:	71 e1       	ldi	r23, 0x11	; 17
    5ab6:	09 95       	icall
    5ab8:	80 93 0c 12 	sts	0x120C, r24
		// reset data index
		I2cSendDataIndex = 0;
    5abc:	10 92 0b 12 	sts	0x120B, r1
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: ST->DATA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// transmit data byte
		outb(TWDR, I2cSendData[I2cSendDataIndex++]);
    5ac0:	90 91 0b 12 	lds	r25, 0x120B
    5ac4:	e9 2f       	mov	r30, r25
    5ac6:	f0 e0       	ldi	r31, 0x00	; 0
    5ac8:	e5 51       	subi	r30, 0x15	; 21
    5aca:	fe 4e       	sbci	r31, 0xEE	; 238
    5acc:	80 81       	ld	r24, Z
    5ace:	80 93 bb 00 	sts	0x00BB, r24
    5ad2:	9f 5f       	subi	r25, 0xFF	; 255
    5ad4:	90 93 0b 12 	sts	0x120B, r25
		if(I2cSendDataIndex < I2cSendDataLength)
    5ad8:	80 91 0c 12 	lds	r24, 0x120C
    5adc:	98 17       	cp	r25, r24
    5ade:	28 f4       	brcc	.+10     	; 0x5aea <__vector_39+0x208>
			// expect ACK to data byte
			outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    5ae0:	80 91 bc 00 	lds	r24, 0x00BC
    5ae4:	8f 70       	andi	r24, 0x0F	; 15
    5ae6:	80 6c       	ori	r24, 0xC0	; 192
    5ae8:	04 c0       	rjmp	.+8      	; 0x5af2 <__vector_39+0x210>
		else
			// expect NACK to data byte
			outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    5aea:	80 91 bc 00 	lds	r24, 0x00BC
    5aee:	8f 70       	andi	r24, 0x0F	; 15
    5af0:	80 68       	ori	r24, 0x80	; 128
    5af2:	80 93 bc 00 	sts	0x00BC, r24
    5af6:	0d c0       	rjmp	.+26     	; 0x5b12 <__vector_39+0x230>
		rprintf("I2C: ST->DATA_NACK or LAST_DATA\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// all done
		// switch to open slave
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    5af8:	80 91 bc 00 	lds	r24, 0x00BC
    5afc:	8f 70       	andi	r24, 0x0F	; 15
    5afe:	80 6c       	ori	r24, 0xC0	; 192
    5b00:	04 c0       	rjmp	.+8      	; 0x5b0a <__vector_39+0x228>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: BUS_ERROR\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// reset internal hardware and release bus
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTO)|BV(TWEA));
    5b02:	80 91 bc 00 	lds	r24, 0x00BC
    5b06:	8f 70       	andi	r24, 0x0F	; 15
    5b08:	80 6d       	ori	r24, 0xD0	; 208
    5b0a:	80 93 bc 00 	sts	0x00BC, r24
		// set state
		I2cState = I2C_IDLE;
    5b0e:	10 92 e9 11 	sts	0x11E9, r1
		break;
	}
}
    5b12:	ff 91       	pop	r31
    5b14:	ef 91       	pop	r30
    5b16:	bf 91       	pop	r27
    5b18:	af 91       	pop	r26
    5b1a:	9f 91       	pop	r25
    5b1c:	8f 91       	pop	r24
    5b1e:	7f 91       	pop	r23
    5b20:	6f 91       	pop	r22
    5b22:	5f 91       	pop	r21
    5b24:	4f 91       	pop	r20
    5b26:	3f 91       	pop	r19
    5b28:	2f 91       	pop	r18
    5b2a:	0f 90       	pop	r0
    5b2c:	0f be       	out	0x3f, r0	; 63
    5b2e:	0f 90       	pop	r0
    5b30:	1f 90       	pop	r1
    5b32:	18 95       	reti

00005b34 <i2cGetState>:

eI2cStateType i2cGetState(void)
{
	return I2cState;
    5b34:	80 91 e9 11 	lds	r24, 0x11E9
}
    5b38:	08 95       	ret

00005b3a <exit>:
    5b3a:	f8 94       	cli
    5b3c:	0c 94 5d 30 	jmp	0x60ba	; 0x60ba <_exit>

00005b40 <memcpy>:
    5b40:	fb 01       	movw	r30, r22
    5b42:	dc 01       	movw	r26, r24
    5b44:	02 c0       	rjmp	.+4      	; 0x5b4a <memcpy+0xa>
    5b46:	01 90       	ld	r0, Z+
    5b48:	0d 92       	st	X+, r0
    5b4a:	41 50       	subi	r20, 0x01	; 1
    5b4c:	50 40       	sbci	r21, 0x00	; 0
    5b4e:	d8 f7       	brcc	.-10     	; 0x5b46 <memcpy+0x6>
    5b50:	08 95       	ret

00005b52 <memset>:
    5b52:	dc 01       	movw	r26, r24
    5b54:	01 c0       	rjmp	.+2      	; 0x5b58 <memset+0x6>
    5b56:	6d 93       	st	X+, r22
    5b58:	41 50       	subi	r20, 0x01	; 1
    5b5a:	50 40       	sbci	r21, 0x00	; 0
    5b5c:	e0 f7       	brcc	.-8      	; 0x5b56 <memset+0x4>
    5b5e:	08 95       	ret

00005b60 <strncpy>:
    5b60:	fb 01       	movw	r30, r22
    5b62:	dc 01       	movw	r26, r24
    5b64:	41 50       	subi	r20, 0x01	; 1
    5b66:	50 40       	sbci	r21, 0x00	; 0
    5b68:	48 f0       	brcs	.+18     	; 0x5b7c <strncpy+0x1c>
    5b6a:	01 90       	ld	r0, Z+
    5b6c:	0d 92       	st	X+, r0
    5b6e:	00 20       	and	r0, r0
    5b70:	c9 f7       	brne	.-14     	; 0x5b64 <strncpy+0x4>
    5b72:	01 c0       	rjmp	.+2      	; 0x5b76 <strncpy+0x16>
    5b74:	1d 92       	st	X+, r1
    5b76:	41 50       	subi	r20, 0x01	; 1
    5b78:	50 40       	sbci	r21, 0x00	; 0
    5b7a:	e0 f7       	brcc	.-8      	; 0x5b74 <strncpy+0x14>
    5b7c:	08 95       	ret

00005b7e <__subsf3>:
    5b7e:	50 58       	subi	r21, 0x80	; 128

00005b80 <__addsf3>:
    5b80:	bb 27       	eor	r27, r27
    5b82:	aa 27       	eor	r26, r26
    5b84:	0e d0       	rcall	.+28     	; 0x5ba2 <__addsf3x>
    5b86:	75 c1       	rjmp	.+746    	; 0x5e72 <__fp_round>
    5b88:	66 d1       	rcall	.+716    	; 0x5e56 <__fp_pscA>
    5b8a:	30 f0       	brcs	.+12     	; 0x5b98 <__addsf3+0x18>
    5b8c:	6b d1       	rcall	.+726    	; 0x5e64 <__fp_pscB>
    5b8e:	20 f0       	brcs	.+8      	; 0x5b98 <__addsf3+0x18>
    5b90:	31 f4       	brne	.+12     	; 0x5b9e <__addsf3+0x1e>
    5b92:	9f 3f       	cpi	r25, 0xFF	; 255
    5b94:	11 f4       	brne	.+4      	; 0x5b9a <__addsf3+0x1a>
    5b96:	1e f4       	brtc	.+6      	; 0x5b9e <__addsf3+0x1e>
    5b98:	5b c1       	rjmp	.+694    	; 0x5e50 <__fp_nan>
    5b9a:	0e f4       	brtc	.+2      	; 0x5b9e <__addsf3+0x1e>
    5b9c:	e0 95       	com	r30
    5b9e:	e7 fb       	bst	r30, 7
    5ba0:	51 c1       	rjmp	.+674    	; 0x5e44 <__fp_inf>

00005ba2 <__addsf3x>:
    5ba2:	e9 2f       	mov	r30, r25
    5ba4:	77 d1       	rcall	.+750    	; 0x5e94 <__fp_split3>
    5ba6:	80 f3       	brcs	.-32     	; 0x5b88 <__addsf3+0x8>
    5ba8:	ba 17       	cp	r27, r26
    5baa:	62 07       	cpc	r22, r18
    5bac:	73 07       	cpc	r23, r19
    5bae:	84 07       	cpc	r24, r20
    5bb0:	95 07       	cpc	r25, r21
    5bb2:	18 f0       	brcs	.+6      	; 0x5bba <__addsf3x+0x18>
    5bb4:	71 f4       	brne	.+28     	; 0x5bd2 <__addsf3x+0x30>
    5bb6:	9e f5       	brtc	.+102    	; 0x5c1e <__addsf3x+0x7c>
    5bb8:	8f c1       	rjmp	.+798    	; 0x5ed8 <__fp_zero>
    5bba:	0e f4       	brtc	.+2      	; 0x5bbe <__addsf3x+0x1c>
    5bbc:	e0 95       	com	r30
    5bbe:	0b 2e       	mov	r0, r27
    5bc0:	ba 2f       	mov	r27, r26
    5bc2:	a0 2d       	mov	r26, r0
    5bc4:	0b 01       	movw	r0, r22
    5bc6:	b9 01       	movw	r22, r18
    5bc8:	90 01       	movw	r18, r0
    5bca:	0c 01       	movw	r0, r24
    5bcc:	ca 01       	movw	r24, r20
    5bce:	a0 01       	movw	r20, r0
    5bd0:	11 24       	eor	r1, r1
    5bd2:	ff 27       	eor	r31, r31
    5bd4:	59 1b       	sub	r21, r25
    5bd6:	99 f0       	breq	.+38     	; 0x5bfe <__addsf3x+0x5c>
    5bd8:	59 3f       	cpi	r21, 0xF9	; 249
    5bda:	50 f4       	brcc	.+20     	; 0x5bf0 <__addsf3x+0x4e>
    5bdc:	50 3e       	cpi	r21, 0xE0	; 224
    5bde:	68 f1       	brcs	.+90     	; 0x5c3a <__addsf3x+0x98>
    5be0:	1a 16       	cp	r1, r26
    5be2:	f0 40       	sbci	r31, 0x00	; 0
    5be4:	a2 2f       	mov	r26, r18
    5be6:	23 2f       	mov	r18, r19
    5be8:	34 2f       	mov	r19, r20
    5bea:	44 27       	eor	r20, r20
    5bec:	58 5f       	subi	r21, 0xF8	; 248
    5bee:	f3 cf       	rjmp	.-26     	; 0x5bd6 <__addsf3x+0x34>
    5bf0:	46 95       	lsr	r20
    5bf2:	37 95       	ror	r19
    5bf4:	27 95       	ror	r18
    5bf6:	a7 95       	ror	r26
    5bf8:	f0 40       	sbci	r31, 0x00	; 0
    5bfa:	53 95       	inc	r21
    5bfc:	c9 f7       	brne	.-14     	; 0x5bf0 <__addsf3x+0x4e>
    5bfe:	7e f4       	brtc	.+30     	; 0x5c1e <__addsf3x+0x7c>
    5c00:	1f 16       	cp	r1, r31
    5c02:	ba 0b       	sbc	r27, r26
    5c04:	62 0b       	sbc	r22, r18
    5c06:	73 0b       	sbc	r23, r19
    5c08:	84 0b       	sbc	r24, r20
    5c0a:	ba f0       	brmi	.+46     	; 0x5c3a <__addsf3x+0x98>
    5c0c:	91 50       	subi	r25, 0x01	; 1
    5c0e:	a1 f0       	breq	.+40     	; 0x5c38 <__addsf3x+0x96>
    5c10:	ff 0f       	add	r31, r31
    5c12:	bb 1f       	adc	r27, r27
    5c14:	66 1f       	adc	r22, r22
    5c16:	77 1f       	adc	r23, r23
    5c18:	88 1f       	adc	r24, r24
    5c1a:	c2 f7       	brpl	.-16     	; 0x5c0c <__addsf3x+0x6a>
    5c1c:	0e c0       	rjmp	.+28     	; 0x5c3a <__addsf3x+0x98>
    5c1e:	ba 0f       	add	r27, r26
    5c20:	62 1f       	adc	r22, r18
    5c22:	73 1f       	adc	r23, r19
    5c24:	84 1f       	adc	r24, r20
    5c26:	48 f4       	brcc	.+18     	; 0x5c3a <__addsf3x+0x98>
    5c28:	87 95       	ror	r24
    5c2a:	77 95       	ror	r23
    5c2c:	67 95       	ror	r22
    5c2e:	b7 95       	ror	r27
    5c30:	f7 95       	ror	r31
    5c32:	9e 3f       	cpi	r25, 0xFE	; 254
    5c34:	08 f0       	brcs	.+2      	; 0x5c38 <__addsf3x+0x96>
    5c36:	b3 cf       	rjmp	.-154    	; 0x5b9e <__addsf3+0x1e>
    5c38:	93 95       	inc	r25
    5c3a:	88 0f       	add	r24, r24
    5c3c:	08 f0       	brcs	.+2      	; 0x5c40 <__addsf3x+0x9e>
    5c3e:	99 27       	eor	r25, r25
    5c40:	ee 0f       	add	r30, r30
    5c42:	97 95       	ror	r25
    5c44:	87 95       	ror	r24
    5c46:	08 95       	ret

00005c48 <__cmpsf2>:
    5c48:	d9 d0       	rcall	.+434    	; 0x5dfc <__fp_cmp>
    5c4a:	08 f4       	brcc	.+2      	; 0x5c4e <__cmpsf2+0x6>
    5c4c:	81 e0       	ldi	r24, 0x01	; 1
    5c4e:	08 95       	ret

00005c50 <__divsf3>:
    5c50:	0c d0       	rcall	.+24     	; 0x5c6a <__divsf3x>
    5c52:	0f c1       	rjmp	.+542    	; 0x5e72 <__fp_round>
    5c54:	07 d1       	rcall	.+526    	; 0x5e64 <__fp_pscB>
    5c56:	40 f0       	brcs	.+16     	; 0x5c68 <__divsf3+0x18>
    5c58:	fe d0       	rcall	.+508    	; 0x5e56 <__fp_pscA>
    5c5a:	30 f0       	brcs	.+12     	; 0x5c68 <__divsf3+0x18>
    5c5c:	21 f4       	brne	.+8      	; 0x5c66 <__divsf3+0x16>
    5c5e:	5f 3f       	cpi	r21, 0xFF	; 255
    5c60:	19 f0       	breq	.+6      	; 0x5c68 <__divsf3+0x18>
    5c62:	f0 c0       	rjmp	.+480    	; 0x5e44 <__fp_inf>
    5c64:	51 11       	cpse	r21, r1
    5c66:	39 c1       	rjmp	.+626    	; 0x5eda <__fp_szero>
    5c68:	f3 c0       	rjmp	.+486    	; 0x5e50 <__fp_nan>

00005c6a <__divsf3x>:
    5c6a:	14 d1       	rcall	.+552    	; 0x5e94 <__fp_split3>
    5c6c:	98 f3       	brcs	.-26     	; 0x5c54 <__divsf3+0x4>

00005c6e <__divsf3_pse>:
    5c6e:	99 23       	and	r25, r25
    5c70:	c9 f3       	breq	.-14     	; 0x5c64 <__divsf3+0x14>
    5c72:	55 23       	and	r21, r21
    5c74:	b1 f3       	breq	.-20     	; 0x5c62 <__divsf3+0x12>
    5c76:	95 1b       	sub	r25, r21
    5c78:	55 0b       	sbc	r21, r21
    5c7a:	bb 27       	eor	r27, r27
    5c7c:	aa 27       	eor	r26, r26
    5c7e:	62 17       	cp	r22, r18
    5c80:	73 07       	cpc	r23, r19
    5c82:	84 07       	cpc	r24, r20
    5c84:	38 f0       	brcs	.+14     	; 0x5c94 <__divsf3_pse+0x26>
    5c86:	9f 5f       	subi	r25, 0xFF	; 255
    5c88:	5f 4f       	sbci	r21, 0xFF	; 255
    5c8a:	22 0f       	add	r18, r18
    5c8c:	33 1f       	adc	r19, r19
    5c8e:	44 1f       	adc	r20, r20
    5c90:	aa 1f       	adc	r26, r26
    5c92:	a9 f3       	breq	.-22     	; 0x5c7e <__divsf3_pse+0x10>
    5c94:	33 d0       	rcall	.+102    	; 0x5cfc <__divsf3_pse+0x8e>
    5c96:	0e 2e       	mov	r0, r30
    5c98:	3a f0       	brmi	.+14     	; 0x5ca8 <__divsf3_pse+0x3a>
    5c9a:	e0 e8       	ldi	r30, 0x80	; 128
    5c9c:	30 d0       	rcall	.+96     	; 0x5cfe <__divsf3_pse+0x90>
    5c9e:	91 50       	subi	r25, 0x01	; 1
    5ca0:	50 40       	sbci	r21, 0x00	; 0
    5ca2:	e6 95       	lsr	r30
    5ca4:	00 1c       	adc	r0, r0
    5ca6:	ca f7       	brpl	.-14     	; 0x5c9a <__divsf3_pse+0x2c>
    5ca8:	29 d0       	rcall	.+82     	; 0x5cfc <__divsf3_pse+0x8e>
    5caa:	fe 2f       	mov	r31, r30
    5cac:	27 d0       	rcall	.+78     	; 0x5cfc <__divsf3_pse+0x8e>
    5cae:	66 0f       	add	r22, r22
    5cb0:	77 1f       	adc	r23, r23
    5cb2:	88 1f       	adc	r24, r24
    5cb4:	bb 1f       	adc	r27, r27
    5cb6:	26 17       	cp	r18, r22
    5cb8:	37 07       	cpc	r19, r23
    5cba:	48 07       	cpc	r20, r24
    5cbc:	ab 07       	cpc	r26, r27
    5cbe:	b0 e8       	ldi	r27, 0x80	; 128
    5cc0:	09 f0       	breq	.+2      	; 0x5cc4 <__divsf3_pse+0x56>
    5cc2:	bb 0b       	sbc	r27, r27
    5cc4:	80 2d       	mov	r24, r0
    5cc6:	bf 01       	movw	r22, r30
    5cc8:	ff 27       	eor	r31, r31
    5cca:	93 58       	subi	r25, 0x83	; 131
    5ccc:	5f 4f       	sbci	r21, 0xFF	; 255
    5cce:	2a f0       	brmi	.+10     	; 0x5cda <__divsf3_pse+0x6c>
    5cd0:	9e 3f       	cpi	r25, 0xFE	; 254
    5cd2:	51 05       	cpc	r21, r1
    5cd4:	68 f0       	brcs	.+26     	; 0x5cf0 <__divsf3_pse+0x82>
    5cd6:	b6 c0       	rjmp	.+364    	; 0x5e44 <__fp_inf>
    5cd8:	00 c1       	rjmp	.+512    	; 0x5eda <__fp_szero>
    5cda:	5f 3f       	cpi	r21, 0xFF	; 255
    5cdc:	ec f3       	brlt	.-6      	; 0x5cd8 <__divsf3_pse+0x6a>
    5cde:	98 3e       	cpi	r25, 0xE8	; 232
    5ce0:	dc f3       	brlt	.-10     	; 0x5cd8 <__divsf3_pse+0x6a>
    5ce2:	86 95       	lsr	r24
    5ce4:	77 95       	ror	r23
    5ce6:	67 95       	ror	r22
    5ce8:	b7 95       	ror	r27
    5cea:	f7 95       	ror	r31
    5cec:	9f 5f       	subi	r25, 0xFF	; 255
    5cee:	c9 f7       	brne	.-14     	; 0x5ce2 <__divsf3_pse+0x74>
    5cf0:	88 0f       	add	r24, r24
    5cf2:	91 1d       	adc	r25, r1
    5cf4:	96 95       	lsr	r25
    5cf6:	87 95       	ror	r24
    5cf8:	97 f9       	bld	r25, 7
    5cfa:	08 95       	ret
    5cfc:	e1 e0       	ldi	r30, 0x01	; 1
    5cfe:	66 0f       	add	r22, r22
    5d00:	77 1f       	adc	r23, r23
    5d02:	88 1f       	adc	r24, r24
    5d04:	bb 1f       	adc	r27, r27
    5d06:	62 17       	cp	r22, r18
    5d08:	73 07       	cpc	r23, r19
    5d0a:	84 07       	cpc	r24, r20
    5d0c:	ba 07       	cpc	r27, r26
    5d0e:	20 f0       	brcs	.+8      	; 0x5d18 <__divsf3_pse+0xaa>
    5d10:	62 1b       	sub	r22, r18
    5d12:	73 0b       	sbc	r23, r19
    5d14:	84 0b       	sbc	r24, r20
    5d16:	ba 0b       	sbc	r27, r26
    5d18:	ee 1f       	adc	r30, r30
    5d1a:	88 f7       	brcc	.-30     	; 0x5cfe <__divsf3_pse+0x90>
    5d1c:	e0 95       	com	r30
    5d1e:	08 95       	ret

00005d20 <__fixsfsi>:
    5d20:	04 d0       	rcall	.+8      	; 0x5d2a <__fixunssfsi>
    5d22:	68 94       	set
    5d24:	b1 11       	cpse	r27, r1
    5d26:	d9 c0       	rjmp	.+434    	; 0x5eda <__fp_szero>
    5d28:	08 95       	ret

00005d2a <__fixunssfsi>:
    5d2a:	bc d0       	rcall	.+376    	; 0x5ea4 <__fp_splitA>
    5d2c:	88 f0       	brcs	.+34     	; 0x5d50 <__fixunssfsi+0x26>
    5d2e:	9f 57       	subi	r25, 0x7F	; 127
    5d30:	90 f0       	brcs	.+36     	; 0x5d56 <__fixunssfsi+0x2c>
    5d32:	b9 2f       	mov	r27, r25
    5d34:	99 27       	eor	r25, r25
    5d36:	b7 51       	subi	r27, 0x17	; 23
    5d38:	a0 f0       	brcs	.+40     	; 0x5d62 <__fixunssfsi+0x38>
    5d3a:	d1 f0       	breq	.+52     	; 0x5d70 <__fixunssfsi+0x46>
    5d3c:	66 0f       	add	r22, r22
    5d3e:	77 1f       	adc	r23, r23
    5d40:	88 1f       	adc	r24, r24
    5d42:	99 1f       	adc	r25, r25
    5d44:	1a f0       	brmi	.+6      	; 0x5d4c <__fixunssfsi+0x22>
    5d46:	ba 95       	dec	r27
    5d48:	c9 f7       	brne	.-14     	; 0x5d3c <__fixunssfsi+0x12>
    5d4a:	12 c0       	rjmp	.+36     	; 0x5d70 <__fixunssfsi+0x46>
    5d4c:	b1 30       	cpi	r27, 0x01	; 1
    5d4e:	81 f0       	breq	.+32     	; 0x5d70 <__fixunssfsi+0x46>
    5d50:	c3 d0       	rcall	.+390    	; 0x5ed8 <__fp_zero>
    5d52:	b1 e0       	ldi	r27, 0x01	; 1
    5d54:	08 95       	ret
    5d56:	c0 c0       	rjmp	.+384    	; 0x5ed8 <__fp_zero>
    5d58:	67 2f       	mov	r22, r23
    5d5a:	78 2f       	mov	r23, r24
    5d5c:	88 27       	eor	r24, r24
    5d5e:	b8 5f       	subi	r27, 0xF8	; 248
    5d60:	39 f0       	breq	.+14     	; 0x5d70 <__fixunssfsi+0x46>
    5d62:	b9 3f       	cpi	r27, 0xF9	; 249
    5d64:	cc f3       	brlt	.-14     	; 0x5d58 <__fixunssfsi+0x2e>
    5d66:	86 95       	lsr	r24
    5d68:	77 95       	ror	r23
    5d6a:	67 95       	ror	r22
    5d6c:	b3 95       	inc	r27
    5d6e:	d9 f7       	brne	.-10     	; 0x5d66 <__fixunssfsi+0x3c>
    5d70:	3e f4       	brtc	.+14     	; 0x5d80 <__fixunssfsi+0x56>
    5d72:	90 95       	com	r25
    5d74:	80 95       	com	r24
    5d76:	70 95       	com	r23
    5d78:	61 95       	neg	r22
    5d7a:	7f 4f       	sbci	r23, 0xFF	; 255
    5d7c:	8f 4f       	sbci	r24, 0xFF	; 255
    5d7e:	9f 4f       	sbci	r25, 0xFF	; 255
    5d80:	08 95       	ret

00005d82 <__floatunsisf>:
    5d82:	e8 94       	clt
    5d84:	09 c0       	rjmp	.+18     	; 0x5d98 <__floatsisf+0x12>

00005d86 <__floatsisf>:
    5d86:	97 fb       	bst	r25, 7
    5d88:	3e f4       	brtc	.+14     	; 0x5d98 <__floatsisf+0x12>
    5d8a:	90 95       	com	r25
    5d8c:	80 95       	com	r24
    5d8e:	70 95       	com	r23
    5d90:	61 95       	neg	r22
    5d92:	7f 4f       	sbci	r23, 0xFF	; 255
    5d94:	8f 4f       	sbci	r24, 0xFF	; 255
    5d96:	9f 4f       	sbci	r25, 0xFF	; 255
    5d98:	99 23       	and	r25, r25
    5d9a:	a9 f0       	breq	.+42     	; 0x5dc6 <__floatsisf+0x40>
    5d9c:	f9 2f       	mov	r31, r25
    5d9e:	96 e9       	ldi	r25, 0x96	; 150
    5da0:	bb 27       	eor	r27, r27
    5da2:	93 95       	inc	r25
    5da4:	f6 95       	lsr	r31
    5da6:	87 95       	ror	r24
    5da8:	77 95       	ror	r23
    5daa:	67 95       	ror	r22
    5dac:	b7 95       	ror	r27
    5dae:	f1 11       	cpse	r31, r1
    5db0:	f8 cf       	rjmp	.-16     	; 0x5da2 <__floatsisf+0x1c>
    5db2:	fa f4       	brpl	.+62     	; 0x5df2 <__floatsisf+0x6c>
    5db4:	bb 0f       	add	r27, r27
    5db6:	11 f4       	brne	.+4      	; 0x5dbc <__floatsisf+0x36>
    5db8:	60 ff       	sbrs	r22, 0
    5dba:	1b c0       	rjmp	.+54     	; 0x5df2 <__floatsisf+0x6c>
    5dbc:	6f 5f       	subi	r22, 0xFF	; 255
    5dbe:	7f 4f       	sbci	r23, 0xFF	; 255
    5dc0:	8f 4f       	sbci	r24, 0xFF	; 255
    5dc2:	9f 4f       	sbci	r25, 0xFF	; 255
    5dc4:	16 c0       	rjmp	.+44     	; 0x5df2 <__floatsisf+0x6c>
    5dc6:	88 23       	and	r24, r24
    5dc8:	11 f0       	breq	.+4      	; 0x5dce <__floatsisf+0x48>
    5dca:	96 e9       	ldi	r25, 0x96	; 150
    5dcc:	11 c0       	rjmp	.+34     	; 0x5df0 <__floatsisf+0x6a>
    5dce:	77 23       	and	r23, r23
    5dd0:	21 f0       	breq	.+8      	; 0x5dda <__floatsisf+0x54>
    5dd2:	9e e8       	ldi	r25, 0x8E	; 142
    5dd4:	87 2f       	mov	r24, r23
    5dd6:	76 2f       	mov	r23, r22
    5dd8:	05 c0       	rjmp	.+10     	; 0x5de4 <__floatsisf+0x5e>
    5dda:	66 23       	and	r22, r22
    5ddc:	71 f0       	breq	.+28     	; 0x5dfa <__floatsisf+0x74>
    5dde:	96 e8       	ldi	r25, 0x86	; 134
    5de0:	86 2f       	mov	r24, r22
    5de2:	70 e0       	ldi	r23, 0x00	; 0
    5de4:	60 e0       	ldi	r22, 0x00	; 0
    5de6:	2a f0       	brmi	.+10     	; 0x5df2 <__floatsisf+0x6c>
    5de8:	9a 95       	dec	r25
    5dea:	66 0f       	add	r22, r22
    5dec:	77 1f       	adc	r23, r23
    5dee:	88 1f       	adc	r24, r24
    5df0:	da f7       	brpl	.-10     	; 0x5de8 <__floatsisf+0x62>
    5df2:	88 0f       	add	r24, r24
    5df4:	96 95       	lsr	r25
    5df6:	87 95       	ror	r24
    5df8:	97 f9       	bld	r25, 7
    5dfa:	08 95       	ret

00005dfc <__fp_cmp>:
    5dfc:	99 0f       	add	r25, r25
    5dfe:	00 08       	sbc	r0, r0
    5e00:	55 0f       	add	r21, r21
    5e02:	aa 0b       	sbc	r26, r26
    5e04:	e0 e8       	ldi	r30, 0x80	; 128
    5e06:	fe ef       	ldi	r31, 0xFE	; 254
    5e08:	16 16       	cp	r1, r22
    5e0a:	17 06       	cpc	r1, r23
    5e0c:	e8 07       	cpc	r30, r24
    5e0e:	f9 07       	cpc	r31, r25
    5e10:	c0 f0       	brcs	.+48     	; 0x5e42 <__fp_cmp+0x46>
    5e12:	12 16       	cp	r1, r18
    5e14:	13 06       	cpc	r1, r19
    5e16:	e4 07       	cpc	r30, r20
    5e18:	f5 07       	cpc	r31, r21
    5e1a:	98 f0       	brcs	.+38     	; 0x5e42 <__fp_cmp+0x46>
    5e1c:	62 1b       	sub	r22, r18
    5e1e:	73 0b       	sbc	r23, r19
    5e20:	84 0b       	sbc	r24, r20
    5e22:	95 0b       	sbc	r25, r21
    5e24:	39 f4       	brne	.+14     	; 0x5e34 <__fp_cmp+0x38>
    5e26:	0a 26       	eor	r0, r26
    5e28:	61 f0       	breq	.+24     	; 0x5e42 <__fp_cmp+0x46>
    5e2a:	23 2b       	or	r18, r19
    5e2c:	24 2b       	or	r18, r20
    5e2e:	25 2b       	or	r18, r21
    5e30:	21 f4       	brne	.+8      	; 0x5e3a <__fp_cmp+0x3e>
    5e32:	08 95       	ret
    5e34:	0a 26       	eor	r0, r26
    5e36:	09 f4       	brne	.+2      	; 0x5e3a <__fp_cmp+0x3e>
    5e38:	a1 40       	sbci	r26, 0x01	; 1
    5e3a:	a6 95       	lsr	r26
    5e3c:	8f ef       	ldi	r24, 0xFF	; 255
    5e3e:	81 1d       	adc	r24, r1
    5e40:	81 1d       	adc	r24, r1
    5e42:	08 95       	ret

00005e44 <__fp_inf>:
    5e44:	97 f9       	bld	r25, 7
    5e46:	9f 67       	ori	r25, 0x7F	; 127
    5e48:	80 e8       	ldi	r24, 0x80	; 128
    5e4a:	70 e0       	ldi	r23, 0x00	; 0
    5e4c:	60 e0       	ldi	r22, 0x00	; 0
    5e4e:	08 95       	ret

00005e50 <__fp_nan>:
    5e50:	9f ef       	ldi	r25, 0xFF	; 255
    5e52:	80 ec       	ldi	r24, 0xC0	; 192
    5e54:	08 95       	ret

00005e56 <__fp_pscA>:
    5e56:	00 24       	eor	r0, r0
    5e58:	0a 94       	dec	r0
    5e5a:	16 16       	cp	r1, r22
    5e5c:	17 06       	cpc	r1, r23
    5e5e:	18 06       	cpc	r1, r24
    5e60:	09 06       	cpc	r0, r25
    5e62:	08 95       	ret

00005e64 <__fp_pscB>:
    5e64:	00 24       	eor	r0, r0
    5e66:	0a 94       	dec	r0
    5e68:	12 16       	cp	r1, r18
    5e6a:	13 06       	cpc	r1, r19
    5e6c:	14 06       	cpc	r1, r20
    5e6e:	05 06       	cpc	r0, r21
    5e70:	08 95       	ret

00005e72 <__fp_round>:
    5e72:	09 2e       	mov	r0, r25
    5e74:	03 94       	inc	r0
    5e76:	00 0c       	add	r0, r0
    5e78:	11 f4       	brne	.+4      	; 0x5e7e <__fp_round+0xc>
    5e7a:	88 23       	and	r24, r24
    5e7c:	52 f0       	brmi	.+20     	; 0x5e92 <__fp_round+0x20>
    5e7e:	bb 0f       	add	r27, r27
    5e80:	40 f4       	brcc	.+16     	; 0x5e92 <__fp_round+0x20>
    5e82:	bf 2b       	or	r27, r31
    5e84:	11 f4       	brne	.+4      	; 0x5e8a <__fp_round+0x18>
    5e86:	60 ff       	sbrs	r22, 0
    5e88:	04 c0       	rjmp	.+8      	; 0x5e92 <__fp_round+0x20>
    5e8a:	6f 5f       	subi	r22, 0xFF	; 255
    5e8c:	7f 4f       	sbci	r23, 0xFF	; 255
    5e8e:	8f 4f       	sbci	r24, 0xFF	; 255
    5e90:	9f 4f       	sbci	r25, 0xFF	; 255
    5e92:	08 95       	ret

00005e94 <__fp_split3>:
    5e94:	57 fd       	sbrc	r21, 7
    5e96:	90 58       	subi	r25, 0x80	; 128
    5e98:	44 0f       	add	r20, r20
    5e9a:	55 1f       	adc	r21, r21
    5e9c:	59 f0       	breq	.+22     	; 0x5eb4 <__fp_splitA+0x10>
    5e9e:	5f 3f       	cpi	r21, 0xFF	; 255
    5ea0:	71 f0       	breq	.+28     	; 0x5ebe <__fp_splitA+0x1a>
    5ea2:	47 95       	ror	r20

00005ea4 <__fp_splitA>:
    5ea4:	88 0f       	add	r24, r24
    5ea6:	97 fb       	bst	r25, 7
    5ea8:	99 1f       	adc	r25, r25
    5eaa:	61 f0       	breq	.+24     	; 0x5ec4 <__fp_splitA+0x20>
    5eac:	9f 3f       	cpi	r25, 0xFF	; 255
    5eae:	79 f0       	breq	.+30     	; 0x5ece <__fp_splitA+0x2a>
    5eb0:	87 95       	ror	r24
    5eb2:	08 95       	ret
    5eb4:	12 16       	cp	r1, r18
    5eb6:	13 06       	cpc	r1, r19
    5eb8:	14 06       	cpc	r1, r20
    5eba:	55 1f       	adc	r21, r21
    5ebc:	f2 cf       	rjmp	.-28     	; 0x5ea2 <__fp_split3+0xe>
    5ebe:	46 95       	lsr	r20
    5ec0:	f1 df       	rcall	.-30     	; 0x5ea4 <__fp_splitA>
    5ec2:	08 c0       	rjmp	.+16     	; 0x5ed4 <__fp_splitA+0x30>
    5ec4:	16 16       	cp	r1, r22
    5ec6:	17 06       	cpc	r1, r23
    5ec8:	18 06       	cpc	r1, r24
    5eca:	99 1f       	adc	r25, r25
    5ecc:	f1 cf       	rjmp	.-30     	; 0x5eb0 <__fp_splitA+0xc>
    5ece:	86 95       	lsr	r24
    5ed0:	71 05       	cpc	r23, r1
    5ed2:	61 05       	cpc	r22, r1
    5ed4:	08 94       	sec
    5ed6:	08 95       	ret

00005ed8 <__fp_zero>:
    5ed8:	e8 94       	clt

00005eda <__fp_szero>:
    5eda:	bb 27       	eor	r27, r27
    5edc:	66 27       	eor	r22, r22
    5ede:	77 27       	eor	r23, r23
    5ee0:	cb 01       	movw	r24, r22
    5ee2:	97 f9       	bld	r25, 7
    5ee4:	08 95       	ret

00005ee6 <__gesf2>:
    5ee6:	8a df       	rcall	.-236    	; 0x5dfc <__fp_cmp>
    5ee8:	08 f4       	brcc	.+2      	; 0x5eec <__gesf2+0x6>
    5eea:	8f ef       	ldi	r24, 0xFF	; 255
    5eec:	08 95       	ret

00005eee <__mulsf3>:
    5eee:	0b d0       	rcall	.+22     	; 0x5f06 <__mulsf3x>
    5ef0:	c0 cf       	rjmp	.-128    	; 0x5e72 <__fp_round>
    5ef2:	b1 df       	rcall	.-158    	; 0x5e56 <__fp_pscA>
    5ef4:	28 f0       	brcs	.+10     	; 0x5f00 <__mulsf3+0x12>
    5ef6:	b6 df       	rcall	.-148    	; 0x5e64 <__fp_pscB>
    5ef8:	18 f0       	brcs	.+6      	; 0x5f00 <__mulsf3+0x12>
    5efa:	95 23       	and	r25, r21
    5efc:	09 f0       	breq	.+2      	; 0x5f00 <__mulsf3+0x12>
    5efe:	a2 cf       	rjmp	.-188    	; 0x5e44 <__fp_inf>
    5f00:	a7 cf       	rjmp	.-178    	; 0x5e50 <__fp_nan>
    5f02:	11 24       	eor	r1, r1
    5f04:	ea cf       	rjmp	.-44     	; 0x5eda <__fp_szero>

00005f06 <__mulsf3x>:
    5f06:	c6 df       	rcall	.-116    	; 0x5e94 <__fp_split3>
    5f08:	a0 f3       	brcs	.-24     	; 0x5ef2 <__mulsf3+0x4>

00005f0a <__mulsf3_pse>:
    5f0a:	95 9f       	mul	r25, r21
    5f0c:	d1 f3       	breq	.-12     	; 0x5f02 <__mulsf3+0x14>
    5f0e:	95 0f       	add	r25, r21
    5f10:	50 e0       	ldi	r21, 0x00	; 0
    5f12:	55 1f       	adc	r21, r21
    5f14:	62 9f       	mul	r22, r18
    5f16:	f0 01       	movw	r30, r0
    5f18:	72 9f       	mul	r23, r18
    5f1a:	bb 27       	eor	r27, r27
    5f1c:	f0 0d       	add	r31, r0
    5f1e:	b1 1d       	adc	r27, r1
    5f20:	63 9f       	mul	r22, r19
    5f22:	aa 27       	eor	r26, r26
    5f24:	f0 0d       	add	r31, r0
    5f26:	b1 1d       	adc	r27, r1
    5f28:	aa 1f       	adc	r26, r26
    5f2a:	64 9f       	mul	r22, r20
    5f2c:	66 27       	eor	r22, r22
    5f2e:	b0 0d       	add	r27, r0
    5f30:	a1 1d       	adc	r26, r1
    5f32:	66 1f       	adc	r22, r22
    5f34:	82 9f       	mul	r24, r18
    5f36:	22 27       	eor	r18, r18
    5f38:	b0 0d       	add	r27, r0
    5f3a:	a1 1d       	adc	r26, r1
    5f3c:	62 1f       	adc	r22, r18
    5f3e:	73 9f       	mul	r23, r19
    5f40:	b0 0d       	add	r27, r0
    5f42:	a1 1d       	adc	r26, r1
    5f44:	62 1f       	adc	r22, r18
    5f46:	83 9f       	mul	r24, r19
    5f48:	a0 0d       	add	r26, r0
    5f4a:	61 1d       	adc	r22, r1
    5f4c:	22 1f       	adc	r18, r18
    5f4e:	74 9f       	mul	r23, r20
    5f50:	33 27       	eor	r19, r19
    5f52:	a0 0d       	add	r26, r0
    5f54:	61 1d       	adc	r22, r1
    5f56:	23 1f       	adc	r18, r19
    5f58:	84 9f       	mul	r24, r20
    5f5a:	60 0d       	add	r22, r0
    5f5c:	21 1d       	adc	r18, r1
    5f5e:	82 2f       	mov	r24, r18
    5f60:	76 2f       	mov	r23, r22
    5f62:	6a 2f       	mov	r22, r26
    5f64:	11 24       	eor	r1, r1
    5f66:	9f 57       	subi	r25, 0x7F	; 127
    5f68:	50 40       	sbci	r21, 0x00	; 0
    5f6a:	8a f0       	brmi	.+34     	; 0x5f8e <__mulsf3_pse+0x84>
    5f6c:	e1 f0       	breq	.+56     	; 0x5fa6 <__mulsf3_pse+0x9c>
    5f6e:	88 23       	and	r24, r24
    5f70:	4a f0       	brmi	.+18     	; 0x5f84 <__mulsf3_pse+0x7a>
    5f72:	ee 0f       	add	r30, r30
    5f74:	ff 1f       	adc	r31, r31
    5f76:	bb 1f       	adc	r27, r27
    5f78:	66 1f       	adc	r22, r22
    5f7a:	77 1f       	adc	r23, r23
    5f7c:	88 1f       	adc	r24, r24
    5f7e:	91 50       	subi	r25, 0x01	; 1
    5f80:	50 40       	sbci	r21, 0x00	; 0
    5f82:	a9 f7       	brne	.-22     	; 0x5f6e <__mulsf3_pse+0x64>
    5f84:	9e 3f       	cpi	r25, 0xFE	; 254
    5f86:	51 05       	cpc	r21, r1
    5f88:	70 f0       	brcs	.+28     	; 0x5fa6 <__mulsf3_pse+0x9c>
    5f8a:	5c cf       	rjmp	.-328    	; 0x5e44 <__fp_inf>
    5f8c:	a6 cf       	rjmp	.-180    	; 0x5eda <__fp_szero>
    5f8e:	5f 3f       	cpi	r21, 0xFF	; 255
    5f90:	ec f3       	brlt	.-6      	; 0x5f8c <__mulsf3_pse+0x82>
    5f92:	98 3e       	cpi	r25, 0xE8	; 232
    5f94:	dc f3       	brlt	.-10     	; 0x5f8c <__mulsf3_pse+0x82>
    5f96:	86 95       	lsr	r24
    5f98:	77 95       	ror	r23
    5f9a:	67 95       	ror	r22
    5f9c:	b7 95       	ror	r27
    5f9e:	f7 95       	ror	r31
    5fa0:	e7 95       	ror	r30
    5fa2:	9f 5f       	subi	r25, 0xFF	; 255
    5fa4:	c1 f7       	brne	.-16     	; 0x5f96 <__mulsf3_pse+0x8c>
    5fa6:	fe 2b       	or	r31, r30
    5fa8:	88 0f       	add	r24, r24
    5faa:	91 1d       	adc	r25, r1
    5fac:	96 95       	lsr	r25
    5fae:	87 95       	ror	r24
    5fb0:	97 f9       	bld	r25, 7
    5fb2:	08 95       	ret

00005fb4 <__mulsi3>:
    5fb4:	62 9f       	mul	r22, r18
    5fb6:	d0 01       	movw	r26, r0
    5fb8:	73 9f       	mul	r23, r19
    5fba:	f0 01       	movw	r30, r0
    5fbc:	82 9f       	mul	r24, r18
    5fbe:	e0 0d       	add	r30, r0
    5fc0:	f1 1d       	adc	r31, r1
    5fc2:	64 9f       	mul	r22, r20
    5fc4:	e0 0d       	add	r30, r0
    5fc6:	f1 1d       	adc	r31, r1
    5fc8:	92 9f       	mul	r25, r18
    5fca:	f0 0d       	add	r31, r0
    5fcc:	83 9f       	mul	r24, r19
    5fce:	f0 0d       	add	r31, r0
    5fd0:	74 9f       	mul	r23, r20
    5fd2:	f0 0d       	add	r31, r0
    5fd4:	65 9f       	mul	r22, r21
    5fd6:	f0 0d       	add	r31, r0
    5fd8:	99 27       	eor	r25, r25
    5fda:	72 9f       	mul	r23, r18
    5fdc:	b0 0d       	add	r27, r0
    5fde:	e1 1d       	adc	r30, r1
    5fe0:	f9 1f       	adc	r31, r25
    5fe2:	63 9f       	mul	r22, r19
    5fe4:	b0 0d       	add	r27, r0
    5fe6:	e1 1d       	adc	r30, r1
    5fe8:	f9 1f       	adc	r31, r25
    5fea:	bd 01       	movw	r22, r26
    5fec:	cf 01       	movw	r24, r30
    5fee:	11 24       	eor	r1, r1
    5ff0:	08 95       	ret

00005ff2 <__udivmodhi4>:
    5ff2:	aa 1b       	sub	r26, r26
    5ff4:	bb 1b       	sub	r27, r27
    5ff6:	51 e1       	ldi	r21, 0x11	; 17
    5ff8:	07 c0       	rjmp	.+14     	; 0x6008 <__udivmodhi4_ep>

00005ffa <__udivmodhi4_loop>:
    5ffa:	aa 1f       	adc	r26, r26
    5ffc:	bb 1f       	adc	r27, r27
    5ffe:	a6 17       	cp	r26, r22
    6000:	b7 07       	cpc	r27, r23
    6002:	10 f0       	brcs	.+4      	; 0x6008 <__udivmodhi4_ep>
    6004:	a6 1b       	sub	r26, r22
    6006:	b7 0b       	sbc	r27, r23

00006008 <__udivmodhi4_ep>:
    6008:	88 1f       	adc	r24, r24
    600a:	99 1f       	adc	r25, r25
    600c:	5a 95       	dec	r21
    600e:	a9 f7       	brne	.-22     	; 0x5ffa <__udivmodhi4_loop>
    6010:	80 95       	com	r24
    6012:	90 95       	com	r25
    6014:	bc 01       	movw	r22, r24
    6016:	cd 01       	movw	r24, r26
    6018:	08 95       	ret

0000601a <__divmodhi4>:
    601a:	97 fb       	bst	r25, 7
    601c:	09 2e       	mov	r0, r25
    601e:	07 26       	eor	r0, r23
    6020:	0a d0       	rcall	.+20     	; 0x6036 <__divmodhi4_neg1>
    6022:	77 fd       	sbrc	r23, 7
    6024:	04 d0       	rcall	.+8      	; 0x602e <__divmodhi4_neg2>
    6026:	e5 df       	rcall	.-54     	; 0x5ff2 <__udivmodhi4>
    6028:	06 d0       	rcall	.+12     	; 0x6036 <__divmodhi4_neg1>
    602a:	00 20       	and	r0, r0
    602c:	1a f4       	brpl	.+6      	; 0x6034 <__divmodhi4_exit>

0000602e <__divmodhi4_neg2>:
    602e:	70 95       	com	r23
    6030:	61 95       	neg	r22
    6032:	7f 4f       	sbci	r23, 0xFF	; 255

00006034 <__divmodhi4_exit>:
    6034:	08 95       	ret

00006036 <__divmodhi4_neg1>:
    6036:	f6 f7       	brtc	.-4      	; 0x6034 <__divmodhi4_exit>
    6038:	90 95       	com	r25
    603a:	81 95       	neg	r24
    603c:	9f 4f       	sbci	r25, 0xFF	; 255
    603e:	08 95       	ret

00006040 <__udivmodsi4>:
    6040:	a1 e2       	ldi	r26, 0x21	; 33
    6042:	1a 2e       	mov	r1, r26
    6044:	aa 1b       	sub	r26, r26
    6046:	bb 1b       	sub	r27, r27
    6048:	fd 01       	movw	r30, r26
    604a:	0d c0       	rjmp	.+26     	; 0x6066 <__udivmodsi4_ep>

0000604c <__udivmodsi4_loop>:
    604c:	aa 1f       	adc	r26, r26
    604e:	bb 1f       	adc	r27, r27
    6050:	ee 1f       	adc	r30, r30
    6052:	ff 1f       	adc	r31, r31
    6054:	a2 17       	cp	r26, r18
    6056:	b3 07       	cpc	r27, r19
    6058:	e4 07       	cpc	r30, r20
    605a:	f5 07       	cpc	r31, r21
    605c:	20 f0       	brcs	.+8      	; 0x6066 <__udivmodsi4_ep>
    605e:	a2 1b       	sub	r26, r18
    6060:	b3 0b       	sbc	r27, r19
    6062:	e4 0b       	sbc	r30, r20
    6064:	f5 0b       	sbc	r31, r21

00006066 <__udivmodsi4_ep>:
    6066:	66 1f       	adc	r22, r22
    6068:	77 1f       	adc	r23, r23
    606a:	88 1f       	adc	r24, r24
    606c:	99 1f       	adc	r25, r25
    606e:	1a 94       	dec	r1
    6070:	69 f7       	brne	.-38     	; 0x604c <__udivmodsi4_loop>
    6072:	60 95       	com	r22
    6074:	70 95       	com	r23
    6076:	80 95       	com	r24
    6078:	90 95       	com	r25
    607a:	9b 01       	movw	r18, r22
    607c:	ac 01       	movw	r20, r24
    607e:	bd 01       	movw	r22, r26
    6080:	cf 01       	movw	r24, r30
    6082:	08 95       	ret

00006084 <__divmodsi4>:
    6084:	97 fb       	bst	r25, 7
    6086:	09 2e       	mov	r0, r25
    6088:	05 26       	eor	r0, r21
    608a:	0e d0       	rcall	.+28     	; 0x60a8 <__divmodsi4_neg1>
    608c:	57 fd       	sbrc	r21, 7
    608e:	04 d0       	rcall	.+8      	; 0x6098 <__divmodsi4_neg2>
    6090:	d7 df       	rcall	.-82     	; 0x6040 <__udivmodsi4>
    6092:	0a d0       	rcall	.+20     	; 0x60a8 <__divmodsi4_neg1>
    6094:	00 1c       	adc	r0, r0
    6096:	38 f4       	brcc	.+14     	; 0x60a6 <__divmodsi4_exit>

00006098 <__divmodsi4_neg2>:
    6098:	50 95       	com	r21
    609a:	40 95       	com	r20
    609c:	30 95       	com	r19
    609e:	21 95       	neg	r18
    60a0:	3f 4f       	sbci	r19, 0xFF	; 255
    60a2:	4f 4f       	sbci	r20, 0xFF	; 255
    60a4:	5f 4f       	sbci	r21, 0xFF	; 255

000060a6 <__divmodsi4_exit>:
    60a6:	08 95       	ret

000060a8 <__divmodsi4_neg1>:
    60a8:	f6 f7       	brtc	.-4      	; 0x60a6 <__divmodsi4_exit>
    60aa:	90 95       	com	r25
    60ac:	80 95       	com	r24
    60ae:	70 95       	com	r23
    60b0:	61 95       	neg	r22
    60b2:	7f 4f       	sbci	r23, 0xFF	; 255
    60b4:	8f 4f       	sbci	r24, 0xFF	; 255
    60b6:	9f 4f       	sbci	r25, 0xFF	; 255
    60b8:	08 95       	ret

000060ba <_exit>:
    60ba:	f8 94       	cli

000060bc <__stop_program>:
    60bc:	ff cf       	rjmp	.-2      	; 0x60bc <__stop_program>

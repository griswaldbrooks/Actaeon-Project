
lbRTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000b6  00800200  0000604e  000060e2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000604e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00001013  008002b6  008002b6  00006198  2**0
                  ALLOC
  3 .debug_aranges 000001a0  00000000  00000000  00006198  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00001891  00000000  00000000  00006338  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00005c1e  00000000  00000000  00007bc9  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 0000172f  00000000  00000000  0000d7e7  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00004b84  00000000  00000000  0000ef16  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000011e0  00000000  00000000  00013a9c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00002423  00000000  00000000  00014c7c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00002b91  00000000  00000000  0001709f  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000030  00000000  00000000  00019c30  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 f9 00 	jmp	0x1f2	; 0x1f2 <__ctors_end>
       4:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
       8:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
       c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      10:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      14:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      18:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      1c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      20:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      24:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      28:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      2c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      30:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      34:	0c 94 0e 20 	jmp	0x401c	; 0x401c <__vector_13>
      38:	0c 94 3b 20 	jmp	0x4076	; 0x4076 <__vector_14>
      3c:	0c 94 2d 1e 	jmp	0x3c5a	; 0x3c5a <__vector_15>
      40:	0c 94 87 1f 	jmp	0x3f0e	; 0x3f0e <__vector_16>
      44:	0c 94 5b 19 	jmp	0x32b6	; 0x32b6 <__vector_17>
      48:	0c 94 b4 1f 	jmp	0x3f68	; 0x3f68 <__vector_18>
      4c:	0c 94 e1 1f 	jmp	0x3fc2	; 0x3fc2 <__vector_19>
      50:	0c 94 ed 1d 	jmp	0x3bda	; 0x3bda <__vector_20>
      54:	0c 94 2d 1f 	jmp	0x3e5a	; 0x3e5a <__vector_21>
      58:	0c 94 5a 1f 	jmp	0x3eb4	; 0x3eb4 <__vector_22>
      5c:	0c 94 9a 1d 	jmp	0x3b34	; 0x3b34 <__vector_23>
      60:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      64:	0c 94 04 24 	jmp	0x4808	; 0x4808 <__vector_25>
      68:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      6c:	0c 94 61 25 	jmp	0x4ac2	; 0x4ac2 <__vector_27>
      70:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      74:	0c 94 1b 28 	jmp	0x5036	; 0x5036 <__vector_29>
      78:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      7c:	0c 94 68 20 	jmp	0x40d0	; 0x40d0 <__vector_31>
      80:	0c 94 95 20 	jmp	0x412a	; 0x412a <__vector_32>
      84:	0c 94 c2 20 	jmp	0x4184	; 0x4184 <__vector_33>
      88:	0c 94 ef 20 	jmp	0x41de	; 0x41de <__vector_34>
      8c:	0c 94 6d 1e 	jmp	0x3cda	; 0x3cda <__vector_35>
      90:	0c 94 df 23 	jmp	0x47be	; 0x47be <__vector_36>
      94:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      98:	0c 94 3c 25 	jmp	0x4a78	; 0x4a78 <__vector_38>
      9c:	0c 94 39 2c 	jmp	0x5872	; 0x5872 <__vector_39>
      a0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      a4:	0c 94 1c 21 	jmp	0x4238	; 0x4238 <__vector_41>
      a8:	0c 94 49 21 	jmp	0x4292	; 0x4292 <__vector_42>
      ac:	0c 94 76 21 	jmp	0x42ec	; 0x42ec <__vector_43>
      b0:	0c 94 a3 21 	jmp	0x4346	; 0x4346 <__vector_44>
      b4:	0c 94 ad 1e 	jmp	0x3d5a	; 0x3d5a <__vector_45>
      b8:	0c 94 d0 21 	jmp	0x43a0	; 0x43a0 <__vector_46>
      bc:	0c 94 fd 21 	jmp	0x43fa	; 0x43fa <__vector_47>
      c0:	0c 94 2a 22 	jmp	0x4454	; 0x4454 <__vector_48>
      c4:	0c 94 57 22 	jmp	0x44ae	; 0x44ae <__vector_49>
      c8:	0c 94 ed 1e 	jmp	0x3dda	; 0x3dda <__vector_50>
      cc:	0c 94 ba 23 	jmp	0x4774	; 0x4774 <__vector_51>
      d0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      d4:	0c 94 17 25 	jmp	0x4a2e	; 0x4a2e <__vector_53>
      d8:	0c 94 95 23 	jmp	0x472a	; 0x472a <__vector_54>
      dc:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      e0:	0c 94 f2 24 	jmp	0x49e4	; 0x49e4 <__vector_56>

000000e4 <__c.3409>:
      e4:	44 45 41 54 48 0a 00                                DEATH..

000000eb <__c.3398>:
      eb:	63 6d 64 5f 61 6e 67 6c 65 3a 20 00                 cmd_angle: .

000000f7 <__c.3396>:
      f7:	63 6d 64 5f 61 6e 67 6c 65 3a 20 00                 cmd_angle: .

00000103 <__c.3280>:
     103:	0a 00                                               ..

00000105 <__c.3278>:
     105:	25 64 00                                            %d.

00000108 <__c.3266>:
     108:	25 64 0a 00                                         %d..

0000010c <__c.3232>:
     10c:	09 25 64 0a 00                                      .%d..

00000111 <__c.3206>:
     111:	09 61 63 63 5f 65 72 72 6f 72 3a 20 00              .acc_error: .

0000011e <__c.3204>:
     11e:	09 65 72 72 6f 72 3a 20 00                          .error: .

00000127 <__c.3202>:
     127:	09 4b 49 3a 20 00                                   .KI: .

0000012d <__c.3200>:
     12d:	09 4b 50 3a 20 00                                   .KP: .

00000133 <__c.3198>:
     133:	09 61 63 63 5f 65 72 72 6f 72 3a 20 00              .acc_error: .

00000140 <__c.3196>:
     140:	09 65 72 72 6f 72 3a 20 00                          .error: .

00000149 <__c.3194>:
     149:	09 4b 49 3a 20 00                                   .KI: .

0000014f <__c.3192>:
     14f:	09 4b 50 3a 20 00                                   .KP: .

00000155 <__c.3190>:
     155:	09 4b 49 3a 20 00                                   .KI: .

0000015b <__c.3188>:
     15b:	09 4b 49 3a 20 00                                   .KI: .

00000161 <__c.3186>:
     161:	09 4b 50 3a 20 00                                   .KP: .

00000167 <__c.3184>:
     167:	09 4b 50 3a 20 00                                   .KP: .

0000016d <__c.3182>:
     16d:	25 64 2c 20 00                                      %d, .

00000172 <__c.3151>:
     172:	49 6e 69 74 69 61 6c 69 7a 61 74 69 6f 6e 20 43     Initialization C
     182:	6f 6d 70 6c 65 74 65 20 0d 0a 00                    omplete ...

0000018d <__c.3146>:
     18d:	2e 00                                               ..

0000018f <__c.3144>:
     18f:	0d 0a 53 79 73 74 65 6d 20 57 61 72 6d 65 64 20     ..System Warmed 
     19f:	55 70 00                                            Up.

000001a2 <__c.3073>:
     1a2:	57 52 0a 00                                         WR..

000001a6 <__c.3071>:
     1a6:	25 64 2c 20 00                                      %d, .

000001ab <__c.3018>:
     1ab:	57 52 0a 00                                         WR..

000001af <__c.3016>:
     1af:	09 25 64 0a 00                                      .%d..

000001b4 <TimerPrescaleFactor>:
     1b4:	00 00 01 00 08 00 40 00 00 01 00 04                 ......@.....

000001c0 <Timer2PrescaleFactor>:
     1c0:	00 00 01 00 08 00 20 00 40 00 80 00 00 01 00 04     ...... .@.......

000001d0 <__c.1991>:
     1d0:	42 41 44 5f 76 65 63 74 20 63 61 6c 6c 65 64 21     BAD_vect called!
	...

000001e1 <HexChars>:
     1e1:	30 31 32 33 34 35 36 37 38 39 41 42 43 44 45 46     0123456789ABCDEF
	...

000001f2 <__ctors_end>:
     1f2:	11 24       	eor	r1, r1
     1f4:	1f be       	out	0x3f, r1	; 63
     1f6:	cf ef       	ldi	r28, 0xFF	; 255
     1f8:	d1 e2       	ldi	r29, 0x21	; 33
     1fa:	de bf       	out	0x3e, r29	; 62
     1fc:	cd bf       	out	0x3d, r28	; 61

000001fe <__do_copy_data>:
     1fe:	12 e0       	ldi	r17, 0x02	; 2
     200:	a0 e0       	ldi	r26, 0x00	; 0
     202:	b2 e0       	ldi	r27, 0x02	; 2
     204:	ee e4       	ldi	r30, 0x4E	; 78
     206:	f0 e6       	ldi	r31, 0x60	; 96
     208:	02 c0       	rjmp	.+4      	; 0x20e <.do_copy_data_start>

0000020a <.do_copy_data_loop>:
     20a:	05 90       	lpm	r0, Z+
     20c:	0d 92       	st	X+, r0

0000020e <.do_copy_data_start>:
     20e:	a6 3b       	cpi	r26, 0xB6	; 182
     210:	b1 07       	cpc	r27, r17
     212:	d9 f7       	brne	.-10     	; 0x20a <.do_copy_data_loop>

00000214 <__do_clear_bss>:
     214:	12 e1       	ldi	r17, 0x12	; 18
     216:	a6 eb       	ldi	r26, 0xB6	; 182
     218:	b2 e0       	ldi	r27, 0x02	; 2
     21a:	01 c0       	rjmp	.+2      	; 0x21e <.do_clear_bss_start>

0000021c <.do_clear_bss_loop>:
     21c:	1d 92       	st	X+, r1

0000021e <.do_clear_bss_start>:
     21e:	a9 3c       	cpi	r26, 0xC9	; 201
     220:	b1 07       	cpc	r27, r17
     222:	e1 f7       	brne	.-8      	; 0x21c <.do_clear_bss_loop>
     224:	0e 94 13 10 	call	0x2026	; 0x2026 <main>
     228:	0c 94 65 2d 	jmp	0x5aca	; 0x5aca <exit>

0000022c <__bad_interrupt>:
     22c:	0c 94 84 22 	jmp	0x4508	; 0x4508 <__vector_default>

00000230 <PWM_Init_timer1_LED>:

//OC1B  pin B6 (attached to green LED)
void PWM_Init_timer1_LED(u08 bitRes)
{
	// enable timer2 as 8,9,10bit PWM
	if(bitRes == 9)
     230:	89 30       	cpi	r24, 0x09	; 9
     232:	49 f4       	brne	.+18     	; 0x246 <PWM_Init_timer1_LED+0x16>
	{	// 9bit mode
		sbi(TCCR1A,PWM11);
     234:	80 91 80 00 	lds	r24, 0x0080
     238:	82 60       	ori	r24, 0x02	; 2
     23a:	80 93 80 00 	sts	0x0080, r24
		cbi(TCCR1A,PWM10);
     23e:	80 91 80 00 	lds	r24, 0x0080
     242:	8e 7f       	andi	r24, 0xFE	; 254
     244:	0e c0       	rjmp	.+28     	; 0x262 <PWM_Init_timer1_LED+0x32>
	}
	else if( bitRes == 10 )
     246:	8a 30       	cpi	r24, 0x0A	; 10
     248:	21 f4       	brne	.+8      	; 0x252 <PWM_Init_timer1_LED+0x22>
	{	// 10bit mode
		sbi(TCCR1A,PWM11);
     24a:	80 91 80 00 	lds	r24, 0x0080
     24e:	82 60       	ori	r24, 0x02	; 2
     250:	03 c0       	rjmp	.+6      	; 0x258 <PWM_Init_timer1_LED+0x28>
		sbi(TCCR1A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR1A,PWM11);
     252:	80 91 80 00 	lds	r24, 0x0080
     256:	8d 7f       	andi	r24, 0xFD	; 253
     258:	80 93 80 00 	sts	0x0080, r24
		sbi(TCCR1A,PWM10);
     25c:	80 91 80 00 	lds	r24, 0x0080
     260:	81 60       	ori	r24, 0x01	; 1
     262:	80 93 80 00 	sts	0x0080, r24
	}
	// clear output compare values
	OCR1B = 0;
     266:	10 92 8b 00 	sts	0x008B, r1
     26a:	10 92 8a 00 	sts	0x008A, r1
}
     26e:	08 95       	ret

00000270 <PWM_Init_timer2_H6>:
//pin H6, timer2
void PWM_Init_timer2_H6(u08 bitRes)
{
	// enable timer2 as 8,9,10bit PWM
	if(bitRes == 9)
     270:	89 30       	cpi	r24, 0x09	; 9
     272:	49 f4       	brne	.+18     	; 0x286 <PWM_Init_timer2_H6+0x16>
	{	// 9bit mode
		sbi(TCCR2A,PWM11);
     274:	80 91 b0 00 	lds	r24, 0x00B0
     278:	82 60       	ori	r24, 0x02	; 2
     27a:	80 93 b0 00 	sts	0x00B0, r24
		cbi(TCCR2A,PWM10);
     27e:	80 91 b0 00 	lds	r24, 0x00B0
     282:	8e 7f       	andi	r24, 0xFE	; 254
     284:	0e c0       	rjmp	.+28     	; 0x2a2 <PWM_Init_timer2_H6+0x32>
	}
	else if( bitRes == 10 )
     286:	8a 30       	cpi	r24, 0x0A	; 10
     288:	21 f4       	brne	.+8      	; 0x292 <PWM_Init_timer2_H6+0x22>
	{	// 10bit mode
		sbi(TCCR2A,PWM11);
     28a:	80 91 b0 00 	lds	r24, 0x00B0
     28e:	82 60       	ori	r24, 0x02	; 2
     290:	03 c0       	rjmp	.+6      	; 0x298 <PWM_Init_timer2_H6+0x28>
		sbi(TCCR2A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR2A,PWM11);
     292:	80 91 b0 00 	lds	r24, 0x00B0
     296:	8d 7f       	andi	r24, 0xFD	; 253
     298:	80 93 b0 00 	sts	0x00B0, r24
		sbi(TCCR2A,PWM10);
     29c:	80 91 b0 00 	lds	r24, 0x00B0
     2a0:	81 60       	ori	r24, 0x01	; 1
     2a2:	80 93 b0 00 	sts	0x00B0, r24
	}
	// clear output compare values
	OCR2B = 0;
     2a6:	10 92 b4 00 	sts	0x00B4, r1
}
     2aa:	08 95       	ret

000002ac <PWM_Init_timer3_E3>:
//pin E3
void PWM_Init_timer3_E3(u08 bitRes)
{
	// enable timer3 as 8,9,10bit PWM
	if(bitRes == 9)
     2ac:	89 30       	cpi	r24, 0x09	; 9
     2ae:	49 f4       	brne	.+18     	; 0x2c2 <PWM_Init_timer3_E3+0x16>
	{	// 9bit mode
		sbi(TCCR3A,PWM11);
     2b0:	80 91 90 00 	lds	r24, 0x0090
     2b4:	82 60       	ori	r24, 0x02	; 2
     2b6:	80 93 90 00 	sts	0x0090, r24
		cbi(TCCR3A,PWM10);
     2ba:	80 91 90 00 	lds	r24, 0x0090
     2be:	8e 7f       	andi	r24, 0xFE	; 254
     2c0:	0e c0       	rjmp	.+28     	; 0x2de <PWM_Init_timer3_E3+0x32>
	}
	else if( bitRes == 10 )
     2c2:	8a 30       	cpi	r24, 0x0A	; 10
     2c4:	21 f4       	brne	.+8      	; 0x2ce <PWM_Init_timer3_E3+0x22>
	{	// 10bit mode
		sbi(TCCR3A,PWM11);
     2c6:	80 91 90 00 	lds	r24, 0x0090
     2ca:	82 60       	ori	r24, 0x02	; 2
     2cc:	03 c0       	rjmp	.+6      	; 0x2d4 <PWM_Init_timer3_E3+0x28>
		sbi(TCCR3A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR3A,PWM11);
     2ce:	80 91 90 00 	lds	r24, 0x0090
     2d2:	8d 7f       	andi	r24, 0xFD	; 253
     2d4:	80 93 90 00 	sts	0x0090, r24
		sbi(TCCR3A,PWM10);
     2d8:	80 91 90 00 	lds	r24, 0x0090
     2dc:	81 60       	ori	r24, 0x01	; 1
     2de:	80 93 90 00 	sts	0x0090, r24
	}
	// clear output compare values
	OCR3A = 0;
     2e2:	10 92 99 00 	sts	0x0099, r1
     2e6:	10 92 98 00 	sts	0x0098, r1
	//timer3PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     2ea:	08 95       	ret

000002ec <PWM_Init_timer3_E4>:
//pin E4
void PWM_Init_timer3_E4(u08 bitRes)
{
	// enable timer3 as 8,9,10bit PWM
	if(bitRes == 9)
     2ec:	89 30       	cpi	r24, 0x09	; 9
     2ee:	49 f4       	brne	.+18     	; 0x302 <PWM_Init_timer3_E4+0x16>
	{	// 9bit mode
		sbi(TCCR3B,PWM11);
     2f0:	80 91 91 00 	lds	r24, 0x0091
     2f4:	82 60       	ori	r24, 0x02	; 2
     2f6:	80 93 91 00 	sts	0x0091, r24
		cbi(TCCR3B,PWM10);
     2fa:	80 91 91 00 	lds	r24, 0x0091
     2fe:	8e 7f       	andi	r24, 0xFE	; 254
     300:	0e c0       	rjmp	.+28     	; 0x31e <PWM_Init_timer3_E4+0x32>
	}
	else if( bitRes == 10 )
     302:	8a 30       	cpi	r24, 0x0A	; 10
     304:	21 f4       	brne	.+8      	; 0x30e <PWM_Init_timer3_E4+0x22>
	{	// 10bit mode
		sbi(TCCR3B,PWM11);
     306:	80 91 91 00 	lds	r24, 0x0091
     30a:	82 60       	ori	r24, 0x02	; 2
     30c:	03 c0       	rjmp	.+6      	; 0x314 <PWM_Init_timer3_E4+0x28>
		sbi(TCCR3B,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR3B,PWM11);
     30e:	80 91 91 00 	lds	r24, 0x0091
     312:	8d 7f       	andi	r24, 0xFD	; 253
     314:	80 93 91 00 	sts	0x0091, r24
		sbi(TCCR3B,PWM10);
     318:	80 91 91 00 	lds	r24, 0x0091
     31c:	81 60       	ori	r24, 0x01	; 1
     31e:	80 93 91 00 	sts	0x0091, r24
	}
	// clear output compare values
	OCR3B = 0;
     322:	10 92 9b 00 	sts	0x009B, r1
     326:	10 92 9a 00 	sts	0x009A, r1
	//timer3PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     32a:	08 95       	ret

0000032c <PWM_Init_timer3_E5>:
//pin E5
void PWM_Init_timer3_E5(u08 bitRes)
{
	// enable timer3 as 8,9,10bit PWM
	if(bitRes == 9)
     32c:	89 30       	cpi	r24, 0x09	; 9
     32e:	49 f4       	brne	.+18     	; 0x342 <PWM_Init_timer3_E5+0x16>
	{	// 9bit mode
		sbi(TCCR3C,PWM11);
     330:	80 91 92 00 	lds	r24, 0x0092
     334:	82 60       	ori	r24, 0x02	; 2
     336:	80 93 92 00 	sts	0x0092, r24
		cbi(TCCR3C,PWM10);
     33a:	80 91 92 00 	lds	r24, 0x0092
     33e:	8e 7f       	andi	r24, 0xFE	; 254
     340:	0e c0       	rjmp	.+28     	; 0x35e <PWM_Init_timer3_E5+0x32>
	}
	else if( bitRes == 10 )
     342:	8a 30       	cpi	r24, 0x0A	; 10
     344:	21 f4       	brne	.+8      	; 0x34e <PWM_Init_timer3_E5+0x22>
	{	// 10bit mode
		sbi(TCCR3C,PWM11);
     346:	80 91 92 00 	lds	r24, 0x0092
     34a:	82 60       	ori	r24, 0x02	; 2
     34c:	03 c0       	rjmp	.+6      	; 0x354 <PWM_Init_timer3_E5+0x28>
		sbi(TCCR3C,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR3C,PWM11);
     34e:	80 91 92 00 	lds	r24, 0x0092
     352:	8d 7f       	andi	r24, 0xFD	; 253
     354:	80 93 92 00 	sts	0x0092, r24
		sbi(TCCR3C,PWM10);
     358:	80 91 92 00 	lds	r24, 0x0092
     35c:	81 60       	ori	r24, 0x01	; 1
     35e:	80 93 92 00 	sts	0x0092, r24
	}
	// clear output compare values
	OCR3C = 0;
     362:	10 92 9d 00 	sts	0x009D, r1
     366:	10 92 9c 00 	sts	0x009C, r1
	//timer3PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     36a:	08 95       	ret

0000036c <PWM_Init_timer4_H3>:
//pin H3, timer4
void PWM_Init_timer4_H3(u08 bitRes)
{
	// enable timer4 as 8,9,10bit PWM
	if(bitRes == 9)
     36c:	89 30       	cpi	r24, 0x09	; 9
     36e:	49 f4       	brne	.+18     	; 0x382 <PWM_Init_timer4_H3+0x16>
	{	// 9bit mode
		sbi(TCCR4A,PWM11);
     370:	80 91 a0 00 	lds	r24, 0x00A0
     374:	82 60       	ori	r24, 0x02	; 2
     376:	80 93 a0 00 	sts	0x00A0, r24
		cbi(TCCR4A,PWM10);
     37a:	80 91 a0 00 	lds	r24, 0x00A0
     37e:	8e 7f       	andi	r24, 0xFE	; 254
     380:	0e c0       	rjmp	.+28     	; 0x39e <PWM_Init_timer4_H3+0x32>
	}
	else if( bitRes == 10 )
     382:	8a 30       	cpi	r24, 0x0A	; 10
     384:	21 f4       	brne	.+8      	; 0x38e <PWM_Init_timer4_H3+0x22>
	{	// 10bit mode
		sbi(TCCR4A,PWM11);
     386:	80 91 a0 00 	lds	r24, 0x00A0
     38a:	82 60       	ori	r24, 0x02	; 2
     38c:	03 c0       	rjmp	.+6      	; 0x394 <PWM_Init_timer4_H3+0x28>
		sbi(TCCR4A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR4A,PWM11);
     38e:	80 91 a0 00 	lds	r24, 0x00A0
     392:	8d 7f       	andi	r24, 0xFD	; 253
     394:	80 93 a0 00 	sts	0x00A0, r24
		sbi(TCCR4A,PWM10);
     398:	80 91 a0 00 	lds	r24, 0x00A0
     39c:	81 60       	ori	r24, 0x01	; 1
     39e:	80 93 a0 00 	sts	0x00A0, r24
	}
	// clear output compare values
	OCR4A = 0;
     3a2:	10 92 a9 00 	sts	0x00A9, r1
     3a6:	10 92 a8 00 	sts	0x00A8, r1
	//timer4PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     3aa:	08 95       	ret

000003ac <PWM_Init_timer4_H4>:
//pin H4, timer4
void PWM_Init_timer4_H4(u08 bitRes)
{
	// enable timer4 as 8,9,10bit PWM
	if(bitRes == 9)
     3ac:	89 30       	cpi	r24, 0x09	; 9
     3ae:	49 f4       	brne	.+18     	; 0x3c2 <PWM_Init_timer4_H4+0x16>
	{	// 9bit mode
		sbi(TCCR4B,PWM11);
     3b0:	80 91 a1 00 	lds	r24, 0x00A1
     3b4:	82 60       	ori	r24, 0x02	; 2
     3b6:	80 93 a1 00 	sts	0x00A1, r24
		cbi(TCCR4B,PWM10);
     3ba:	80 91 a1 00 	lds	r24, 0x00A1
     3be:	8e 7f       	andi	r24, 0xFE	; 254
     3c0:	0e c0       	rjmp	.+28     	; 0x3de <PWM_Init_timer4_H4+0x32>
	}
	else if( bitRes == 10 )
     3c2:	8a 30       	cpi	r24, 0x0A	; 10
     3c4:	21 f4       	brne	.+8      	; 0x3ce <PWM_Init_timer4_H4+0x22>
	{	// 10bit mode
		sbi(TCCR4B,PWM11);
     3c6:	80 91 a1 00 	lds	r24, 0x00A1
     3ca:	82 60       	ori	r24, 0x02	; 2
     3cc:	03 c0       	rjmp	.+6      	; 0x3d4 <PWM_Init_timer4_H4+0x28>
		sbi(TCCR4B,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR4B,PWM11);
     3ce:	80 91 a1 00 	lds	r24, 0x00A1
     3d2:	8d 7f       	andi	r24, 0xFD	; 253
     3d4:	80 93 a1 00 	sts	0x00A1, r24
		sbi(TCCR4B,PWM10);
     3d8:	80 91 a1 00 	lds	r24, 0x00A1
     3dc:	81 60       	ori	r24, 0x01	; 1
     3de:	80 93 a1 00 	sts	0x00A1, r24
	}
	// clear output compare values
	OCR4B = 0;
     3e2:	10 92 ab 00 	sts	0x00AB, r1
     3e6:	10 92 aa 00 	sts	0x00AA, r1
	//timer4PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     3ea:	08 95       	ret

000003ec <PWM_Init_timer4_H5>:
//pin H5, timer4
void PWM_Init_timer4_H5(u08 bitRes)
{
	// enable timer4 as 8,9,10bit PWM
	if(bitRes == 9)
     3ec:	89 30       	cpi	r24, 0x09	; 9
     3ee:	49 f4       	brne	.+18     	; 0x402 <PWM_Init_timer4_H5+0x16>
	{	// 9bit mode
		sbi(TCCR4A,PWM11);
     3f0:	80 91 a0 00 	lds	r24, 0x00A0
     3f4:	82 60       	ori	r24, 0x02	; 2
     3f6:	80 93 a0 00 	sts	0x00A0, r24
		cbi(TCCR4A,PWM10);
     3fa:	80 91 a0 00 	lds	r24, 0x00A0
     3fe:	8e 7f       	andi	r24, 0xFE	; 254
     400:	0e c0       	rjmp	.+28     	; 0x41e <PWM_Init_timer4_H5+0x32>
	}
	else if( bitRes == 10 )
     402:	8a 30       	cpi	r24, 0x0A	; 10
     404:	21 f4       	brne	.+8      	; 0x40e <PWM_Init_timer4_H5+0x22>
	{	// 10bit mode
		sbi(TCCR4A,PWM11);
     406:	80 91 a0 00 	lds	r24, 0x00A0
     40a:	82 60       	ori	r24, 0x02	; 2
     40c:	03 c0       	rjmp	.+6      	; 0x414 <PWM_Init_timer4_H5+0x28>
		sbi(TCCR4A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR4A,PWM11);
     40e:	80 91 a0 00 	lds	r24, 0x00A0
     412:	8d 7f       	andi	r24, 0xFD	; 253
     414:	80 93 a0 00 	sts	0x00A0, r24
		sbi(TCCR4A,PWM10);
     418:	80 91 a0 00 	lds	r24, 0x00A0
     41c:	81 60       	ori	r24, 0x01	; 1
     41e:	80 93 a0 00 	sts	0x00A0, r24
	}
	// clear output compare values
	OCR4C = 0;
     422:	10 92 ad 00 	sts	0x00AD, r1
     426:	10 92 ac 00 	sts	0x00AC, r1
	//timer4PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     42a:	08 95       	ret

0000042c <timer1PWMInitICR>:
// include support for arbitrary top-count PWM
// on new AVR processors that support it
void timer1PWMInitICR(u16 topcount)
{
	// set PWM mode with ICR top-count
	cbi(TCCR1A,WGM10);
     42c:	e0 e8       	ldi	r30, 0x80	; 128
     42e:	f0 e0       	ldi	r31, 0x00	; 0
     430:	20 81       	ld	r18, Z
     432:	2e 7f       	andi	r18, 0xFE	; 254
     434:	20 83       	st	Z, r18
	sbi(TCCR1A,WGM11);
     436:	20 81       	ld	r18, Z
     438:	22 60       	ori	r18, 0x02	; 2
     43a:	20 83       	st	Z, r18
	sbi(TCCR1B,WGM12);
     43c:	e1 e8       	ldi	r30, 0x81	; 129
     43e:	f0 e0       	ldi	r31, 0x00	; 0
     440:	20 81       	ld	r18, Z
     442:	28 60       	ori	r18, 0x08	; 8
     444:	20 83       	st	Z, r18
	sbi(TCCR1B,WGM13);
     446:	20 81       	ld	r18, Z
     448:	20 61       	ori	r18, 0x10	; 16
     44a:	20 83       	st	Z, r18
	
	// set top count value
	ICR1 = topcount;
     44c:	90 93 87 00 	sts	0x0087, r25
     450:	80 93 86 00 	sts	0x0086, r24
	
	// clear output compare values
	OCR1A = 0;
     454:	10 92 89 00 	sts	0x0089, r1
     458:	10 92 88 00 	sts	0x0088, r1
	OCR1B = 0;
     45c:	10 92 8b 00 	sts	0x008B, r1
     460:	10 92 8a 00 	sts	0x008A, r1
	OCR1C = 0;
     464:	10 92 8d 00 	sts	0x008D, r1
     468:	10 92 8c 00 	sts	0x008C, r1
}
     46c:	08 95       	ret

0000046e <timer3PWMInitICR>:
void timer3PWMInitICR(u16 topcount)
{
	// set PWM mode with ICR top-count
	cbi(TCCR3A,WGM10);
     46e:	e0 e9       	ldi	r30, 0x90	; 144
     470:	f0 e0       	ldi	r31, 0x00	; 0
     472:	20 81       	ld	r18, Z
     474:	2e 7f       	andi	r18, 0xFE	; 254
     476:	20 83       	st	Z, r18
	sbi(TCCR3A,WGM11);
     478:	20 81       	ld	r18, Z
     47a:	22 60       	ori	r18, 0x02	; 2
     47c:	20 83       	st	Z, r18
	sbi(TCCR3B,WGM12);
     47e:	e1 e9       	ldi	r30, 0x91	; 145
     480:	f0 e0       	ldi	r31, 0x00	; 0
     482:	20 81       	ld	r18, Z
     484:	28 60       	ori	r18, 0x08	; 8
     486:	20 83       	st	Z, r18
	sbi(TCCR3B,WGM13);
     488:	20 81       	ld	r18, Z
     48a:	20 61       	ori	r18, 0x10	; 16
     48c:	20 83       	st	Z, r18
	
	// set top count value
	ICR3 = topcount;
     48e:	90 93 97 00 	sts	0x0097, r25
     492:	80 93 96 00 	sts	0x0096, r24
	
	// clear output compare values
	OCR3A = 0;
     496:	10 92 99 00 	sts	0x0099, r1
     49a:	10 92 98 00 	sts	0x0098, r1
	OCR3B = 0;
     49e:	10 92 9b 00 	sts	0x009B, r1
     4a2:	10 92 9a 00 	sts	0x009A, r1
	OCR3C = 0;
     4a6:	10 92 9d 00 	sts	0x009D, r1
     4aa:	10 92 9c 00 	sts	0x009C, r1
}
     4ae:	08 95       	ret

000004b0 <timer4PWMInitICR>:
void timer4PWMInitICR(u16 topcount)
{
	// set PWM mode with ICR top-count
	cbi(TCCR4A,WGM10);
     4b0:	e0 ea       	ldi	r30, 0xA0	; 160
     4b2:	f0 e0       	ldi	r31, 0x00	; 0
     4b4:	20 81       	ld	r18, Z
     4b6:	2e 7f       	andi	r18, 0xFE	; 254
     4b8:	20 83       	st	Z, r18
	sbi(TCCR4A,WGM11);
     4ba:	20 81       	ld	r18, Z
     4bc:	22 60       	ori	r18, 0x02	; 2
     4be:	20 83       	st	Z, r18
	sbi(TCCR4B,WGM12);
     4c0:	e1 ea       	ldi	r30, 0xA1	; 161
     4c2:	f0 e0       	ldi	r31, 0x00	; 0
     4c4:	20 81       	ld	r18, Z
     4c6:	28 60       	ori	r18, 0x08	; 8
     4c8:	20 83       	st	Z, r18
	sbi(TCCR4B,WGM13);
     4ca:	20 81       	ld	r18, Z
     4cc:	20 61       	ori	r18, 0x10	; 16
     4ce:	20 83       	st	Z, r18
	
	// set top count value
	ICR4 = topcount;
     4d0:	90 93 a7 00 	sts	0x00A7, r25
     4d4:	80 93 a6 00 	sts	0x00A6, r24
	
	// clear output compare values
	OCR4A = 0;
     4d8:	10 92 a9 00 	sts	0x00A9, r1
     4dc:	10 92 a8 00 	sts	0x00A8, r1
	OCR4B = 0;
     4e0:	10 92 ab 00 	sts	0x00AB, r1
     4e4:	10 92 aa 00 	sts	0x00AA, r1
	OCR4C = 0;
     4e8:	10 92 ad 00 	sts	0x00AD, r1
     4ec:	10 92 ac 00 	sts	0x00AC, r1
}
     4f0:	08 95       	ret

000004f2 <PWM_timer1_On_LED>:
#endif

//on commands
void PWM_timer1_On_LED(void)
{
	sbi(TCCR1A,COM1B1);
     4f2:	e0 e8       	ldi	r30, 0x80	; 128
     4f4:	f0 e0       	ldi	r31, 0x00	; 0
     4f6:	80 81       	ld	r24, Z
     4f8:	80 62       	ori	r24, 0x20	; 32
     4fa:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B0);
     4fc:	80 81       	ld	r24, Z
     4fe:	8f 7e       	andi	r24, 0xEF	; 239
     500:	80 83       	st	Z, r24
}
     502:	08 95       	ret

00000504 <PWM_timer2_On_H6>:
void PWM_timer2_On_H6(void)
{
	sbi(TCCR2A,COM2B1);
     504:	e0 eb       	ldi	r30, 0xB0	; 176
     506:	f0 e0       	ldi	r31, 0x00	; 0
     508:	80 81       	ld	r24, Z
     50a:	80 62       	ori	r24, 0x20	; 32
     50c:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B0);
     50e:	80 81       	ld	r24, Z
     510:	8f 7e       	andi	r24, 0xEF	; 239
     512:	80 83       	st	Z, r24
}
     514:	08 95       	ret

00000516 <PWM_timer3_On_E3>:
void PWM_timer3_On_E3(void)
{
	sbi(TCCR3A,COM3A1);
     516:	e0 e9       	ldi	r30, 0x90	; 144
     518:	f0 e0       	ldi	r31, 0x00	; 0
     51a:	80 81       	ld	r24, Z
     51c:	80 68       	ori	r24, 0x80	; 128
     51e:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3A0);
     520:	80 81       	ld	r24, Z
     522:	8f 7b       	andi	r24, 0xBF	; 191
     524:	80 83       	st	Z, r24
}
     526:	08 95       	ret

00000528 <PWM_timer3_On_E4>:
void PWM_timer3_On_E4(void)
{
	sbi(TCCR3A,COM3B1);
     528:	e0 e9       	ldi	r30, 0x90	; 144
     52a:	f0 e0       	ldi	r31, 0x00	; 0
     52c:	80 81       	ld	r24, Z
     52e:	80 62       	ori	r24, 0x20	; 32
     530:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3B0);
     532:	80 81       	ld	r24, Z
     534:	8f 7e       	andi	r24, 0xEF	; 239
     536:	80 83       	st	Z, r24
}
     538:	08 95       	ret

0000053a <PWM_timer3_On_E5>:
void PWM_timer3_On_E5(void)
{
	sbi(TCCR3A,COM3C1);
     53a:	e0 e9       	ldi	r30, 0x90	; 144
     53c:	f0 e0       	ldi	r31, 0x00	; 0
     53e:	80 81       	ld	r24, Z
     540:	88 60       	ori	r24, 0x08	; 8
     542:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C0);
     544:	80 81       	ld	r24, Z
     546:	8b 7f       	andi	r24, 0xFB	; 251
     548:	80 83       	st	Z, r24
}
     54a:	08 95       	ret

0000054c <PWM_timer4_On_H3>:
void PWM_timer4_On_H3(void)
{
	sbi(TCCR4A,COM4A1);
     54c:	e0 ea       	ldi	r30, 0xA0	; 160
     54e:	f0 e0       	ldi	r31, 0x00	; 0
     550:	80 81       	ld	r24, Z
     552:	80 68       	ori	r24, 0x80	; 128
     554:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4A0);
     556:	80 81       	ld	r24, Z
     558:	8f 7b       	andi	r24, 0xBF	; 191
     55a:	80 83       	st	Z, r24
}
     55c:	08 95       	ret

0000055e <PWM_timer4_On_H4>:
void PWM_timer4_On_H4(void)
{
	sbi(TCCR4A,COM4B1);
     55e:	e0 ea       	ldi	r30, 0xA0	; 160
     560:	f0 e0       	ldi	r31, 0x00	; 0
     562:	80 81       	ld	r24, Z
     564:	80 62       	ori	r24, 0x20	; 32
     566:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4B0);
     568:	80 81       	ld	r24, Z
     56a:	8f 7e       	andi	r24, 0xEF	; 239
     56c:	80 83       	st	Z, r24
}
     56e:	08 95       	ret

00000570 <PWM_timer4_On_H5>:
void PWM_timer4_On_H5(void)
{
	sbi(TCCR4A,COM4C1);
     570:	e0 ea       	ldi	r30, 0xA0	; 160
     572:	f0 e0       	ldi	r31, 0x00	; 0
     574:	80 81       	ld	r24, Z
     576:	88 60       	ori	r24, 0x08	; 8
     578:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4C0);
     57a:	80 81       	ld	r24, Z
     57c:	8b 7f       	andi	r24, 0xFB	; 251
     57e:	80 83       	st	Z, r24
}
     580:	08 95       	ret

00000582 <PWM_timer1_Off_LED>:

//off commands
void PWM_timer1_Off_LED(void)
{
	cbi(TCCR1A,COM1B1);
     582:	e0 e8       	ldi	r30, 0x80	; 128
     584:	f0 e0       	ldi	r31, 0x00	; 0
     586:	80 81       	ld	r24, Z
     588:	8f 7d       	andi	r24, 0xDF	; 223
     58a:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B0);
     58c:	80 81       	ld	r24, Z
     58e:	8f 7e       	andi	r24, 0xEF	; 239
     590:	80 83       	st	Z, r24
}
     592:	08 95       	ret

00000594 <PWM_timer2_Off_H6>:
void PWM_timer2_Off_H6(void)
{
	cbi(TCCR2A,COM2B1);
     594:	e0 eb       	ldi	r30, 0xB0	; 176
     596:	f0 e0       	ldi	r31, 0x00	; 0
     598:	80 81       	ld	r24, Z
     59a:	8f 7d       	andi	r24, 0xDF	; 223
     59c:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B0);
     59e:	80 81       	ld	r24, Z
     5a0:	8f 7e       	andi	r24, 0xEF	; 239
     5a2:	80 83       	st	Z, r24
}
     5a4:	08 95       	ret

000005a6 <PWM_timer3_Off_E3>:
void PWM_timer3_Off_E3(void)
{
	cbi(TCCR3A,COM3A1);
     5a6:	e0 e9       	ldi	r30, 0x90	; 144
     5a8:	f0 e0       	ldi	r31, 0x00	; 0
     5aa:	80 81       	ld	r24, Z
     5ac:	8f 77       	andi	r24, 0x7F	; 127
     5ae:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3A0);
     5b0:	80 81       	ld	r24, Z
     5b2:	8f 7b       	andi	r24, 0xBF	; 191
     5b4:	80 83       	st	Z, r24
}
     5b6:	08 95       	ret

000005b8 <PWM_timer3_Off_E4>:
void PWM_timer3_Off_E4(void)
{
	cbi(TCCR3A,COM3B1);
     5b8:	e0 e9       	ldi	r30, 0x90	; 144
     5ba:	f0 e0       	ldi	r31, 0x00	; 0
     5bc:	80 81       	ld	r24, Z
     5be:	8f 7d       	andi	r24, 0xDF	; 223
     5c0:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3B0);
     5c2:	80 81       	ld	r24, Z
     5c4:	8f 7e       	andi	r24, 0xEF	; 239
     5c6:	80 83       	st	Z, r24
}
     5c8:	08 95       	ret

000005ca <PWM_timer3_Off_E5>:
void PWM_timer3_Off_E5(void)
{
	cbi(TCCR3A,COM3C1);
     5ca:	e0 e9       	ldi	r30, 0x90	; 144
     5cc:	f0 e0       	ldi	r31, 0x00	; 0
     5ce:	80 81       	ld	r24, Z
     5d0:	87 7f       	andi	r24, 0xF7	; 247
     5d2:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C0);
     5d4:	80 81       	ld	r24, Z
     5d6:	8b 7f       	andi	r24, 0xFB	; 251
     5d8:	80 83       	st	Z, r24
}
     5da:	08 95       	ret

000005dc <PWM_timer4_Off_H3>:
void PWM_timer4_Off_H3(void)
{
	cbi(TCCR4A,COM4A1);
     5dc:	e0 ea       	ldi	r30, 0xA0	; 160
     5de:	f0 e0       	ldi	r31, 0x00	; 0
     5e0:	80 81       	ld	r24, Z
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4A0);
     5e6:	80 81       	ld	r24, Z
     5e8:	8f 7b       	andi	r24, 0xBF	; 191
     5ea:	80 83       	st	Z, r24
}
     5ec:	08 95       	ret

000005ee <PWM_timer4_Off_H4>:
void PWM_timer4_Off_H4(void)
{
	cbi(TCCR4A,COM4B1);
     5ee:	e0 ea       	ldi	r30, 0xA0	; 160
     5f0:	f0 e0       	ldi	r31, 0x00	; 0
     5f2:	80 81       	ld	r24, Z
     5f4:	8f 7d       	andi	r24, 0xDF	; 223
     5f6:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4B0);
     5f8:	80 81       	ld	r24, Z
     5fa:	8f 7e       	andi	r24, 0xEF	; 239
     5fc:	80 83       	st	Z, r24
}
     5fe:	08 95       	ret

00000600 <PWM_timer4_Off_H5>:
void PWM_timer4_Off_H5(void)
{
	cbi(TCCR4A,COM4C1);
     600:	e0 ea       	ldi	r30, 0xA0	; 160
     602:	f0 e0       	ldi	r31, 0x00	; 0
     604:	80 81       	ld	r24, Z
     606:	87 7f       	andi	r24, 0xF7	; 247
     608:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4C0);
     60a:	80 81       	ld	r24, Z
     60c:	8b 7f       	andi	r24, 0xFB	; 251
     60e:	80 83       	st	Z, r24
}
     610:	08 95       	ret

00000612 <PWM_timer1_Off_All>:


void PWM_timer1_Off_All(void)
{
	cbi(TCCR1A,PWM11);
     612:	e0 e8       	ldi	r30, 0x80	; 128
     614:	f0 e0       	ldi	r31, 0x00	; 0
     616:	80 81       	ld	r24, Z
     618:	8d 7f       	andi	r24, 0xFD	; 253
     61a:	80 83       	st	Z, r24
	cbi(TCCR1A,PWM10);
     61c:	80 81       	ld	r24, Z
     61e:	8e 7f       	andi	r24, 0xFE	; 254
     620:	80 83       	st	Z, r24
}

//off commands
void PWM_timer1_Off_LED(void)
{
	cbi(TCCR1A,COM1B1);
     622:	80 81       	ld	r24, Z
     624:	8f 7d       	andi	r24, 0xDF	; 223
     626:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B0);
     628:	80 81       	ld	r24, Z
     62a:	8f 7e       	andi	r24, 0xEF	; 239
     62c:	80 83       	st	Z, r24
	cbi(TCCR1A,PWM11);
	cbi(TCCR1A,PWM10);
	//timer2PWMAOff();
	PWM_timer1_Off_LED();
	//timer2PWMCOff();
}
     62e:	08 95       	ret

00000630 <PWM_timer2_Off_All>:
void PWM_timer2_Off_All(void)
{
	cbi(TCCR2A,PWM11);
     630:	e0 eb       	ldi	r30, 0xB0	; 176
     632:	f0 e0       	ldi	r31, 0x00	; 0
     634:	80 81       	ld	r24, Z
     636:	8d 7f       	andi	r24, 0xFD	; 253
     638:	80 83       	st	Z, r24
	cbi(TCCR2A,PWM10);
     63a:	80 81       	ld	r24, Z
     63c:	8e 7f       	andi	r24, 0xFE	; 254
     63e:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B1);
	cbi(TCCR1A,COM1B0);
}
void PWM_timer2_Off_H6(void)
{
	cbi(TCCR2A,COM2B1);
     640:	80 81       	ld	r24, Z
     642:	8f 7d       	andi	r24, 0xDF	; 223
     644:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B0);
     646:	80 81       	ld	r24, Z
     648:	8f 7e       	andi	r24, 0xEF	; 239
     64a:	80 83       	st	Z, r24
	cbi(TCCR2A,PWM11);
	cbi(TCCR2A,PWM10);
	//timer2PWMAOff();
	PWM_timer2_Off_H6();
	//timer2PWMCOff();
}
     64c:	08 95       	ret

0000064e <PWM_timer3_Off_All>:
void PWM_timer3_Off_All(void)
{
	cbi(TCCR3A,PWM11);
     64e:	e0 e9       	ldi	r30, 0x90	; 144
     650:	f0 e0       	ldi	r31, 0x00	; 0
     652:	80 81       	ld	r24, Z
     654:	8d 7f       	andi	r24, 0xFD	; 253
     656:	80 83       	st	Z, r24
	cbi(TCCR3A,PWM10);
     658:	80 81       	ld	r24, Z
     65a:	8e 7f       	andi	r24, 0xFE	; 254
     65c:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B1);
	cbi(TCCR2A,COM2B0);
}
void PWM_timer3_Off_E3(void)
{
	cbi(TCCR3A,COM3A1);
     65e:	80 81       	ld	r24, Z
     660:	8f 77       	andi	r24, 0x7F	; 127
     662:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3A0);
     664:	80 81       	ld	r24, Z
     666:	8f 7b       	andi	r24, 0xBF	; 191
     668:	80 83       	st	Z, r24
}
void PWM_timer3_Off_E4(void)
{
	cbi(TCCR3A,COM3B1);
     66a:	80 81       	ld	r24, Z
     66c:	8f 7d       	andi	r24, 0xDF	; 223
     66e:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3B0);
     670:	80 81       	ld	r24, Z
     672:	8f 7e       	andi	r24, 0xEF	; 239
     674:	80 83       	st	Z, r24
}
void PWM_timer3_Off_E5(void)
{
	cbi(TCCR3A,COM3C1);
     676:	80 81       	ld	r24, Z
     678:	87 7f       	andi	r24, 0xF7	; 247
     67a:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C0);
     67c:	80 81       	ld	r24, Z
     67e:	8b 7f       	andi	r24, 0xFB	; 251
     680:	80 83       	st	Z, r24
	//timer2PWMAOff();
	PWM_timer3_Off_E3();
	PWM_timer3_Off_E4();
	PWM_timer3_Off_E5();
	//timer2PWMCOff();
}
     682:	08 95       	ret

00000684 <PWM_timer4_Off_All>:
void PWM_timer4_Off_All(void)
{
	cbi(TCCR4A,PWM11);
     684:	e0 ea       	ldi	r30, 0xA0	; 160
     686:	f0 e0       	ldi	r31, 0x00	; 0
     688:	80 81       	ld	r24, Z
     68a:	8d 7f       	andi	r24, 0xFD	; 253
     68c:	80 83       	st	Z, r24
	cbi(TCCR4A,PWM10);
     68e:	80 81       	ld	r24, Z
     690:	8e 7f       	andi	r24, 0xFE	; 254
     692:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C1);
	cbi(TCCR3A,COM3C0);
}
void PWM_timer4_Off_H3(void)
{
	cbi(TCCR4A,COM4A1);
     694:	80 81       	ld	r24, Z
     696:	8f 77       	andi	r24, 0x7F	; 127
     698:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4A0);
     69a:	80 81       	ld	r24, Z
     69c:	8f 7b       	andi	r24, 0xBF	; 191
     69e:	80 83       	st	Z, r24
}
void PWM_timer4_Off_H4(void)
{
	cbi(TCCR4A,COM4B1);
     6a0:	80 81       	ld	r24, Z
     6a2:	8f 7d       	andi	r24, 0xDF	; 223
     6a4:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4B0);
     6a6:	80 81       	ld	r24, Z
     6a8:	8f 7e       	andi	r24, 0xEF	; 239
     6aa:	80 83       	st	Z, r24
}
void PWM_timer4_Off_H5(void)
{
	cbi(TCCR4A,COM4C1);
     6ac:	80 81       	ld	r24, Z
     6ae:	87 7f       	andi	r24, 0xF7	; 247
     6b0:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4C0);
     6b2:	80 81       	ld	r24, Z
     6b4:	8b 7f       	andi	r24, 0xFB	; 251
     6b6:	80 83       	st	Z, r24
	//timer2PWMAOff();
	PWM_timer4_Off_H3();
	PWM_timer4_Off_H4();
	PWM_timer4_Off_H5();
	//timer2PWMCOff();
}
     6b8:	08 95       	ret

000006ba <PWM_timer1_Set_LED>:
// this PWM output is generated on OC2B pin
// NOTE:	pwmDuty should be in the range 0-255 for 8bit PWM
//			pwmDuty should be in the range 0-511 for 9bit PWM
//			pwmDuty should be in the range 0-1023 for 10bit PWM
void PWM_timer1_Set_LED(u16 pwmDuty)
	{OCR1B = pwmDuty;}
     6ba:	90 93 8b 00 	sts	0x008B, r25
     6be:	80 93 8a 00 	sts	0x008A, r24
     6c2:	08 95       	ret

000006c4 <PWM_timer2_Set_H6>:
void PWM_timer2_Set_H6(u16 pwmDuty)
	{OCR2B = pwmDuty;}
     6c4:	80 93 b4 00 	sts	0x00B4, r24
     6c8:	08 95       	ret

000006ca <PWM_timer3_Set_E3>:
void PWM_timer3_Set_E3(u16 pwmDuty)
	{OCR3A = pwmDuty;}
     6ca:	90 93 99 00 	sts	0x0099, r25
     6ce:	80 93 98 00 	sts	0x0098, r24
     6d2:	08 95       	ret

000006d4 <PWM_timer3_Set_E4>:
void PWM_timer3_Set_E4(u16 pwmDuty)
	{OCR3B = pwmDuty;}
     6d4:	90 93 9b 00 	sts	0x009B, r25
     6d8:	80 93 9a 00 	sts	0x009A, r24
     6dc:	08 95       	ret

000006de <PWM_timer3_Set_E5>:
void PWM_timer3_Set_E5(u16 pwmDuty)
	{OCR3C = pwmDuty;}
     6de:	90 93 9d 00 	sts	0x009D, r25
     6e2:	80 93 9c 00 	sts	0x009C, r24
     6e6:	08 95       	ret

000006e8 <PWM_timer4_Set_H3>:
void PWM_timer4_Set_H3(u16 pwmDuty)
	{OCR4A = pwmDuty;}
     6e8:	90 93 a9 00 	sts	0x00A9, r25
     6ec:	80 93 a8 00 	sts	0x00A8, r24
     6f0:	08 95       	ret

000006f2 <PWM_timer4_Set_H4>:
void PWM_timer4_Set_H4(u16 pwmDuty)
	{OCR4B = pwmDuty;}
     6f2:	90 93 ab 00 	sts	0x00AB, r25
     6f6:	80 93 aa 00 	sts	0x00AA, r24
     6fa:	08 95       	ret

000006fc <PWM_timer4_Set_H5>:
void PWM_timer4_Set_H5(u16 pwmDuty)
	{OCR4C = pwmDuty;}
     6fc:	90 93 ad 00 	sts	0x00AD, r25
     700:	80 93 ac 00 	sts	0x00AC, r24
     704:	08 95       	ret

00000706 <configure_ports>:
	//cbi(DDRG, PG5);  //set G5 as input pin

	//ANALOG PORTS
	//useful for sensors, SharpIR, photoresistors, etc.
	//analog ports can be configured as digital ports if desired
	DDRF = 0b00000000;  //configure all F ports for input				0x00
     706:	10 ba       	out	0x10, r1	; 16
	PORTF = 0b00000000; //make sure pull-up resistors are turned off	0x00
     708:	11 ba       	out	0x11, r1	; 17
	DDRK = 0b00000000;  //configure all K ports for input				0x00
     70a:	10 92 07 01 	sts	0x0107, r1
	PORTK = 0b00000000; //make sure pull-up resistors are turned off	0x00
     70e:	10 92 08 01 	sts	0x0108, r1

	//DIGITAL PORTS
	//useful for servos, PWM, LED's, UART, interrupts, timers
	DDRA = 0b11111111;  //configure ports for output
     712:	9f ef       	ldi	r25, 0xFF	; 255
     714:	91 b9       	out	0x01, r25	; 1
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	//PORTB reserved for programmer (use programmer pins if you know what you are doing)
	DDRB = _BV (PB6);	//PB6 is LED, hold low to turn it on
     716:	80 e4       	ldi	r24, 0x40	; 64
     718:	84 b9       	out	0x04, r24	; 4
	DDRC = 0b11111111;  //configure ports for output
     71a:	97 b9       	out	0x07, r25	; 7
	//       ||||\______3: 
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 	
	sbi(PORTD, PD0); // SCL pull-up
     71c:	58 9a       	sbi	0x0b, 0	; 11
	sbi(PORTD, PD1); // SDA pull-up
     71e:	59 9a       	sbi	0x0b, 1	; 11
	DDRD = 0b11110011;  //configure ports for output
     720:	83 ef       	ldi	r24, 0xF3	; 243
     722:	8a b9       	out	0x0a, r24	; 10
	//       ||||\______3: serial TXD1, output -> 1
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: timer0
	DDRE = 0b11111110;  //configure ports for output
     724:	8e ef       	ldi	r24, 0xFE	; 254
     726:	8d b9       	out	0x0d, r24	; 13
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	//cbi(PORTG, PG5);  // disable pull-up resistor for Axon v1e and earlier
	sbi(PORTG, PG5);  // enable pull-up resistor for v1f and later
     728:	a5 9a       	sbi	0x14, 5	; 20
	cbi(DDRG, PG5);	//PG5 is for the button, make a digital input
     72a:	9d 98       	cbi	0x13, 5	; 19
	//note that button actions are inverted between both versions!!!
	DDRH = 0b11111110;  //configure ports for output
     72c:	80 93 01 01 	sts	0x0101, r24
	//       ||||\______3: 
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	DDRJ = 0b11111110;  //configure ports for output
     730:	80 93 04 01 	sts	0x0104, r24
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	//PORTL has no headers
	};
     734:	08 95       	ret

00000736 <delay_cycles>:
void delay_cycles(unsigned long int cycles)
	{
	cycles=cycles;//doubled frequency but too lazy to change times
	while(cycles > 0)
		cycles--;
	}
     736:	08 95       	ret

00000738 <LED_off>:


//***************STATUS LED**************
//tank test
void LED_off(void)
	{PORT_ON(PORTB,6);}
     738:	2e 9a       	sbi	0x05, 6	; 5
     73a:	08 95       	ret

0000073c <LED_on>:
void LED_on(void)
	{PORT_OFF(PORTB,6);}
     73c:	2e 98       	cbi	0x05, 6	; 5
     73e:	08 95       	ret

00000740 <button_pressed>:


//*****************BUTTON****************
int button_pressed(void)
	{
	return (bit_is_clear(PING, 5));
     740:	22 b3       	in	r18, 0x12	; 18
     742:	30 e0       	ldi	r19, 0x00	; 0
     744:	85 e0       	ldi	r24, 0x05	; 5
     746:	36 95       	lsr	r19
     748:	27 95       	ror	r18
     74a:	8a 95       	dec	r24
     74c:	e1 f7       	brne	.-8      	; 0x746 <button_pressed+0x6>
     74e:	20 95       	com	r18
     750:	30 95       	com	r19
     752:	21 70       	andi	r18, 0x01	; 1
     754:	30 70       	andi	r19, 0x00	; 0
	//return ((PING) & (1<<PG5));//old version, went high when button pushed
	}
     756:	c9 01       	movw	r24, r18
     758:	08 95       	ret

0000075a <cos_SoR>:
signed int angtable[73]={100,100,98,97,94,91,87,82,77,71,64,57,50,42,34,26,17,9,0,-9,-17,-26,-34,-42,-50,-57,-64,-71,-77,-82,-87,-91,-94,-97,-98,-100,
						 -100,-100,-98,-97,-94,-91,-87,-82,-77,-71,-64,-57,-50,-42,-34,-26,-17,-9,0,9,17,26,34,42,50,57,64,71,77,82,87,91,94,97,98,100,100};

signed int cos_SoR(long signed int degrees)//returns cos*100
	{
	if (degrees >= 0)//positive angles
     75a:	97 fd       	sbrc	r25, 7
     75c:	10 c0       	rjmp	.+32     	; 0x77e <cos_SoR+0x24>
		return angtable[degrees/5];
     75e:	25 e0       	ldi	r18, 0x05	; 5
     760:	30 e0       	ldi	r19, 0x00	; 0
     762:	40 e0       	ldi	r20, 0x00	; 0
     764:	50 e0       	ldi	r21, 0x00	; 0
     766:	0e 94 0a 30 	call	0x6014	; 0x6014 <__divmodsi4>
     76a:	da 01       	movw	r26, r20
     76c:	c9 01       	movw	r24, r18
     76e:	88 0f       	add	r24, r24
     770:	99 1f       	adc	r25, r25
     772:	84 5e       	subi	r24, 0xE4	; 228
     774:	9d 4f       	sbci	r25, 0xFD	; 253
     776:	fc 01       	movw	r30, r24
     778:	20 81       	ld	r18, Z
     77a:	31 81       	ldd	r19, Z+1	; 0x01
     77c:	17 c0       	rjmp	.+46     	; 0x7ac <cos_SoR+0x52>
	else
		return -angtable[72-(-degrees)/5];
     77e:	25 e0       	ldi	r18, 0x05	; 5
     780:	30 e0       	ldi	r19, 0x00	; 0
     782:	40 e0       	ldi	r20, 0x00	; 0
     784:	50 e0       	ldi	r21, 0x00	; 0
     786:	0e 94 0a 30 	call	0x6014	; 0x6014 <__divmodsi4>
     78a:	da 01       	movw	r26, r20
     78c:	c9 01       	movw	r24, r18
     78e:	88 5b       	subi	r24, 0xB8	; 184
     790:	9f 4f       	sbci	r25, 0xFF	; 255
     792:	af 4f       	sbci	r26, 0xFF	; 255
     794:	bf 4f       	sbci	r27, 0xFF	; 255
     796:	88 0f       	add	r24, r24
     798:	99 1f       	adc	r25, r25
     79a:	84 5e       	subi	r24, 0xE4	; 228
     79c:	9d 4f       	sbci	r25, 0xFD	; 253
     79e:	fc 01       	movw	r30, r24
     7a0:	80 81       	ld	r24, Z
     7a2:	91 81       	ldd	r25, Z+1	; 0x01
     7a4:	22 27       	eor	r18, r18
     7a6:	33 27       	eor	r19, r19
     7a8:	28 1b       	sub	r18, r24
     7aa:	39 0b       	sbc	r19, r25
	}
     7ac:	c9 01       	movw	r24, r18
     7ae:	08 95       	ret

000007b0 <sin_SoR>:

signed int sin_SoR(long signed int degrees)//returns sin*100
	{
	degrees=degrees - 90;//phase shift 90 degrees
     7b0:	6a 55       	subi	r22, 0x5A	; 90
     7b2:	70 40       	sbci	r23, 0x00	; 0
     7b4:	80 40       	sbci	r24, 0x00	; 0
     7b6:	90 40       	sbci	r25, 0x00	; 0

	if (degrees >= 0)//positive angles
     7b8:	97 fd       	sbrc	r25, 7
     7ba:	10 c0       	rjmp	.+32     	; 0x7dc <sin_SoR+0x2c>
		return angtable[degrees/5];
     7bc:	25 e0       	ldi	r18, 0x05	; 5
     7be:	30 e0       	ldi	r19, 0x00	; 0
     7c0:	40 e0       	ldi	r20, 0x00	; 0
     7c2:	50 e0       	ldi	r21, 0x00	; 0
     7c4:	0e 94 0a 30 	call	0x6014	; 0x6014 <__divmodsi4>
     7c8:	da 01       	movw	r26, r20
     7ca:	c9 01       	movw	r24, r18
     7cc:	88 0f       	add	r24, r24
     7ce:	99 1f       	adc	r25, r25
     7d0:	84 5e       	subi	r24, 0xE4	; 228
     7d2:	9d 4f       	sbci	r25, 0xFD	; 253
     7d4:	fc 01       	movw	r30, r24
     7d6:	20 81       	ld	r18, Z
     7d8:	31 81       	ldd	r19, Z+1	; 0x01
     7da:	17 c0       	rjmp	.+46     	; 0x80a <sin_SoR+0x5a>
	else
		return -angtable[72-(-degrees)/5];
     7dc:	25 e0       	ldi	r18, 0x05	; 5
     7de:	30 e0       	ldi	r19, 0x00	; 0
     7e0:	40 e0       	ldi	r20, 0x00	; 0
     7e2:	50 e0       	ldi	r21, 0x00	; 0
     7e4:	0e 94 0a 30 	call	0x6014	; 0x6014 <__divmodsi4>
     7e8:	da 01       	movw	r26, r20
     7ea:	c9 01       	movw	r24, r18
     7ec:	88 5b       	subi	r24, 0xB8	; 184
     7ee:	9f 4f       	sbci	r25, 0xFF	; 255
     7f0:	af 4f       	sbci	r26, 0xFF	; 255
     7f2:	bf 4f       	sbci	r27, 0xFF	; 255
     7f4:	88 0f       	add	r24, r24
     7f6:	99 1f       	adc	r25, r25
     7f8:	84 5e       	subi	r24, 0xE4	; 228
     7fa:	9d 4f       	sbci	r25, 0xFD	; 253
     7fc:	fc 01       	movw	r30, r24
     7fe:	80 81       	ld	r24, Z
     800:	91 81       	ldd	r25, Z+1	; 0x01
     802:	22 27       	eor	r18, r18
     804:	33 27       	eor	r19, r19
     806:	28 1b       	sub	r18, r24
     808:	39 0b       	sbc	r19, r25
	}
     80a:	c9 01       	movw	r24, r18
     80c:	08 95       	ret

0000080e <tan_SoR>:

signed int tan_SoR(long signed int degrees)//returns tan * 10
	{
     80e:	cf 92       	push	r12
     810:	df 92       	push	r13
     812:	ef 92       	push	r14
     814:	ff 92       	push	r15
     816:	0f 93       	push	r16
     818:	1f 93       	push	r17
     81a:	6b 01       	movw	r12, r22
     81c:	7c 01       	movw	r14, r24
	//tan(x) = sin(x)/cos(x)
	if (degrees == 90 || degrees == -90 || degrees == 270 || degrees == -270)//blows up
     81e:	8a e5       	ldi	r24, 0x5A	; 90
     820:	c8 16       	cp	r12, r24
     822:	d1 04       	cpc	r13, r1
     824:	e1 04       	cpc	r14, r1
     826:	f1 04       	cpc	r15, r1
     828:	a1 f1       	breq	.+104    	; 0x892 <tan_SoR+0x84>
     82a:	86 ea       	ldi	r24, 0xA6	; 166
     82c:	c8 16       	cp	r12, r24
     82e:	8f ef       	ldi	r24, 0xFF	; 255
     830:	d8 06       	cpc	r13, r24
     832:	8f ef       	ldi	r24, 0xFF	; 255
     834:	e8 06       	cpc	r14, r24
     836:	8f ef       	ldi	r24, 0xFF	; 255
     838:	f8 06       	cpc	r15, r24
     83a:	59 f1       	breq	.+86     	; 0x892 <tan_SoR+0x84>
     83c:	8e e0       	ldi	r24, 0x0E	; 14
     83e:	c8 16       	cp	r12, r24
     840:	81 e0       	ldi	r24, 0x01	; 1
     842:	d8 06       	cpc	r13, r24
     844:	80 e0       	ldi	r24, 0x00	; 0
     846:	e8 06       	cpc	r14, r24
     848:	80 e0       	ldi	r24, 0x00	; 0
     84a:	f8 06       	cpc	r15, r24
     84c:	11 f1       	breq	.+68     	; 0x892 <tan_SoR+0x84>
     84e:	82 ef       	ldi	r24, 0xF2	; 242
     850:	c8 16       	cp	r12, r24
     852:	8e ef       	ldi	r24, 0xFE	; 254
     854:	d8 06       	cpc	r13, r24
     856:	8f ef       	ldi	r24, 0xFF	; 255
     858:	e8 06       	cpc	r14, r24
     85a:	8f ef       	ldi	r24, 0xFF	; 255
     85c:	f8 06       	cpc	r15, r24
     85e:	c9 f0       	breq	.+50     	; 0x892 <tan_SoR+0x84>
		return 0;//what else should I return?!?!?
	return sin_SoR(degrees)/cos_SoR(degrees)*10;
     860:	c7 01       	movw	r24, r14
     862:	b6 01       	movw	r22, r12
     864:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <sin_SoR>
     868:	8c 01       	movw	r16, r24
     86a:	c7 01       	movw	r24, r14
     86c:	b6 01       	movw	r22, r12
     86e:	0e 94 ad 03 	call	0x75a	; 0x75a <cos_SoR>
     872:	bc 01       	movw	r22, r24
     874:	c8 01       	movw	r24, r16
     876:	0e 94 d5 2f 	call	0x5faa	; 0x5faa <__divmodhi4>
     87a:	cb 01       	movw	r24, r22
     87c:	9b 01       	movw	r18, r22
     87e:	73 e0       	ldi	r23, 0x03	; 3
     880:	22 0f       	add	r18, r18
     882:	33 1f       	adc	r19, r19
     884:	7a 95       	dec	r23
     886:	e1 f7       	brne	.-8      	; 0x880 <tan_SoR+0x72>
     888:	88 0f       	add	r24, r24
     88a:	99 1f       	adc	r25, r25
     88c:	28 0f       	add	r18, r24
     88e:	39 1f       	adc	r19, r25
     890:	02 c0       	rjmp	.+4      	; 0x896 <tan_SoR+0x88>
     892:	20 e0       	ldi	r18, 0x00	; 0
     894:	30 e0       	ldi	r19, 0x00	; 0
	}
     896:	c9 01       	movw	r24, r18
     898:	1f 91       	pop	r17
     89a:	0f 91       	pop	r16
     89c:	ff 90       	pop	r15
     89e:	ef 90       	pop	r14
     8a0:	df 90       	pop	r13
     8a2:	cf 90       	pop	r12
     8a4:	08 95       	ret

000008a6 <prvPWMSetup>:
//-----------------------------**&&**


void prvPWMSetup(){

	PWM_Init_timer3_E4(10); // Left wheel
     8a6:	8a e0       	ldi	r24, 0x0A	; 10
     8a8:	0e 94 76 01 	call	0x2ec	; 0x2ec <PWM_Init_timer3_E4>
	PWM_Init_timer3_E3(10); // Right wheel
     8ac:	8a e0       	ldi	r24, 0x0A	; 10
     8ae:	0e 94 56 01 	call	0x2ac	; 0x2ac <PWM_Init_timer3_E3>
	PWM_Init_timer4_H3(10);	// Left sprayer
     8b2:	8a e0       	ldi	r24, 0x0A	; 10
     8b4:	0e 94 b6 01 	call	0x36c	; 0x36c <PWM_Init_timer4_H3>
	PWM_Init_timer4_H4(10);	// Right sprayer
     8b8:	8a e0       	ldi	r24, 0x0A	; 10
     8ba:	0e 94 d6 01 	call	0x3ac	; 0x3ac <PWM_Init_timer4_H4>

}
     8be:	08 95       	ret

000008c0 <char2hex>:

char char2hex(char c){
     8c0:	98 2f       	mov	r25, r24
	
	if((c > 47) && (c <58)){
     8c2:	80 53       	subi	r24, 0x30	; 48
     8c4:	8a 30       	cpi	r24, 0x0A	; 10
     8c6:	38 f0       	brcs	.+14     	; 0x8d6 <char2hex+0x16>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     8c8:	81 51       	subi	r24, 0x11	; 17
     8ca:	86 30       	cpi	r24, 0x06	; 6
     8cc:	10 f0       	brcs	.+4      	; 0x8d2 <char2hex+0x12>
     8ce:	89 2f       	mov	r24, r25
     8d0:	08 95       	ret
		c -= 55;
     8d2:	89 2f       	mov	r24, r25
     8d4:	87 53       	subi	r24, 0x37	; 55
	}
	return c;
}
     8d6:	08 95       	ret

000008d8 <retConv_s16>:

s16 retConv_s16(char* ch_head){
     8d8:	fc 01       	movw	r30, r24

	s16 int_val = 0x0000;
	char iv1 = *(ch_head);
     8da:	90 81       	ld	r25, Z
	char iv2 = *(ch_head + 1);
     8dc:	21 81       	ldd	r18, Z+1	; 0x01
	char iv3 = *(ch_head + 2);
     8de:	42 81       	ldd	r20, Z+2	; 0x02
	char iv4 = *(ch_head + 3);
     8e0:	53 81       	ldd	r21, Z+3	; 0x03

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     8e2:	89 2f       	mov	r24, r25
     8e4:	80 53       	subi	r24, 0x30	; 48
     8e6:	8a 30       	cpi	r24, 0x0A	; 10
     8e8:	10 f4       	brcc	.+4      	; 0x8ee <retConv_s16+0x16>
     8ea:	98 2f       	mov	r25, r24
     8ec:	05 c0       	rjmp	.+10     	; 0x8f8 <retConv_s16+0x20>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     8ee:	89 2f       	mov	r24, r25
     8f0:	81 54       	subi	r24, 0x41	; 65
     8f2:	86 30       	cpi	r24, 0x06	; 6
     8f4:	08 f4       	brcc	.+2      	; 0x8f8 <retConv_s16+0x20>
		c -= 55;
     8f6:	97 53       	subi	r25, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     8f8:	82 2f       	mov	r24, r18
     8fa:	80 53       	subi	r24, 0x30	; 48
     8fc:	8a 30       	cpi	r24, 0x0A	; 10
     8fe:	10 f4       	brcc	.+4      	; 0x904 <retConv_s16+0x2c>
     900:	28 2f       	mov	r18, r24
     902:	05 c0       	rjmp	.+10     	; 0x90e <retConv_s16+0x36>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     904:	82 2f       	mov	r24, r18
     906:	81 54       	subi	r24, 0x41	; 65
     908:	86 30       	cpi	r24, 0x06	; 6
     90a:	08 f4       	brcc	.+2      	; 0x90e <retConv_s16+0x36>
		c -= 55;
     90c:	27 53       	subi	r18, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     90e:	84 2f       	mov	r24, r20
     910:	80 53       	subi	r24, 0x30	; 48
     912:	8a 30       	cpi	r24, 0x0A	; 10
     914:	10 f4       	brcc	.+4      	; 0x91a <retConv_s16+0x42>
     916:	48 2f       	mov	r20, r24
     918:	05 c0       	rjmp	.+10     	; 0x924 <retConv_s16+0x4c>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     91a:	84 2f       	mov	r24, r20
     91c:	81 54       	subi	r24, 0x41	; 65
     91e:	86 30       	cpi	r24, 0x06	; 6
     920:	08 f4       	brcc	.+2      	; 0x924 <retConv_s16+0x4c>
		c -= 55;
     922:	47 53       	subi	r20, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     924:	85 2f       	mov	r24, r21
     926:	80 53       	subi	r24, 0x30	; 48
     928:	8a 30       	cpi	r24, 0x0A	; 10
     92a:	10 f4       	brcc	.+4      	; 0x930 <retConv_s16+0x58>
     92c:	58 2f       	mov	r21, r24
     92e:	05 c0       	rjmp	.+10     	; 0x93a <retConv_s16+0x62>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     930:	85 2f       	mov	r24, r21
     932:	81 54       	subi	r24, 0x41	; 65
     934:	86 30       	cpi	r24, 0x06	; 6
     936:	08 f4       	brcc	.+2      	; 0x93a <retConv_s16+0x62>
		c -= 55;
     938:	57 53       	subi	r21, 0x37	; 55
	iv2 = char2hex(iv2);
	iv3 = char2hex(iv3);
	iv4 = char2hex(iv4);

	int_val = (int_val | iv1);
	int_val = ((int_val<<4) | iv2);
     93a:	30 e0       	ldi	r19, 0x00	; 0
     93c:	89 2f       	mov	r24, r25
     93e:	90 e0       	ldi	r25, 0x00	; 0
     940:	a4 e0       	ldi	r26, 0x04	; 4
     942:	88 0f       	add	r24, r24
     944:	99 1f       	adc	r25, r25
     946:	aa 95       	dec	r26
     948:	e1 f7       	brne	.-8      	; 0x942 <retConv_s16+0x6a>
     94a:	28 2b       	or	r18, r24
     94c:	39 2b       	or	r19, r25
	int_val = ((int_val<<4) | iv3);
     94e:	f4 e0       	ldi	r31, 0x04	; 4
     950:	22 0f       	add	r18, r18
     952:	33 1f       	adc	r19, r19
     954:	fa 95       	dec	r31
     956:	e1 f7       	brne	.-8      	; 0x950 <retConv_s16+0x78>
     958:	84 2f       	mov	r24, r20
     95a:	90 e0       	ldi	r25, 0x00	; 0
     95c:	82 2b       	or	r24, r18
     95e:	93 2b       	or	r25, r19
	int_val = ((int_val<<4) | iv4);
     960:	e4 e0       	ldi	r30, 0x04	; 4
     962:	88 0f       	add	r24, r24
     964:	99 1f       	adc	r25, r25
     966:	ea 95       	dec	r30
     968:	e1 f7       	brne	.-8      	; 0x962 <retConv_s16+0x8a>
     96a:	25 2f       	mov	r18, r21
     96c:	30 e0       	ldi	r19, 0x00	; 0
     96e:	28 2b       	or	r18, r24
     970:	39 2b       	or	r19, r25
	return int_val;
}
     972:	c9 01       	movw	r24, r18
     974:	08 95       	ret

00000976 <retConv_s32>:

s32 retConv_s32(char* ch_head){
     976:	ff 92       	push	r15
     978:	0f 93       	push	r16
     97a:	1f 93       	push	r17
     97c:	fc 01       	movw	r30, r24

	s32 int_val = 0x00000000;
	char iv1 = *(ch_head);
     97e:	90 81       	ld	r25, Z
	char iv2 = *(ch_head + 1);
     980:	21 81       	ldd	r18, Z+1	; 0x01
	char iv3 = *(ch_head + 2);
     982:	62 81       	ldd	r22, Z+2	; 0x02
	char iv4 = *(ch_head + 3);
     984:	73 81       	ldd	r23, Z+3	; 0x03
	char iv5 = *(ch_head + 4);
     986:	14 81       	ldd	r17, Z+4	; 0x04
	char iv6 = *(ch_head + 5);
     988:	05 81       	ldd	r16, Z+5	; 0x05
	char iv7 = *(ch_head + 6);
     98a:	f6 80       	ldd	r15, Z+6	; 0x06
	char iv8 = *(ch_head + 7);
     98c:	e7 81       	ldd	r30, Z+7	; 0x07

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     98e:	89 2f       	mov	r24, r25
     990:	80 53       	subi	r24, 0x30	; 48
     992:	8a 30       	cpi	r24, 0x0A	; 10
     994:	10 f4       	brcc	.+4      	; 0x99a <retConv_s32+0x24>
     996:	98 2f       	mov	r25, r24
     998:	05 c0       	rjmp	.+10     	; 0x9a4 <retConv_s32+0x2e>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     99a:	89 2f       	mov	r24, r25
     99c:	81 54       	subi	r24, 0x41	; 65
     99e:	86 30       	cpi	r24, 0x06	; 6
     9a0:	08 f4       	brcc	.+2      	; 0x9a4 <retConv_s32+0x2e>
		c -= 55;
     9a2:	97 53       	subi	r25, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     9a4:	82 2f       	mov	r24, r18
     9a6:	80 53       	subi	r24, 0x30	; 48
     9a8:	8a 30       	cpi	r24, 0x0A	; 10
     9aa:	10 f4       	brcc	.+4      	; 0x9b0 <retConv_s32+0x3a>
     9ac:	28 2f       	mov	r18, r24
     9ae:	05 c0       	rjmp	.+10     	; 0x9ba <retConv_s32+0x44>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     9b0:	82 2f       	mov	r24, r18
     9b2:	81 54       	subi	r24, 0x41	; 65
     9b4:	86 30       	cpi	r24, 0x06	; 6
     9b6:	08 f4       	brcc	.+2      	; 0x9ba <retConv_s32+0x44>
		c -= 55;
     9b8:	27 53       	subi	r18, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     9ba:	86 2f       	mov	r24, r22
     9bc:	80 53       	subi	r24, 0x30	; 48
     9be:	8a 30       	cpi	r24, 0x0A	; 10
     9c0:	10 f4       	brcc	.+4      	; 0x9c6 <retConv_s32+0x50>
     9c2:	68 2f       	mov	r22, r24
     9c4:	05 c0       	rjmp	.+10     	; 0x9d0 <retConv_s32+0x5a>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     9c6:	86 2f       	mov	r24, r22
     9c8:	81 54       	subi	r24, 0x41	; 65
     9ca:	86 30       	cpi	r24, 0x06	; 6
     9cc:	08 f4       	brcc	.+2      	; 0x9d0 <retConv_s32+0x5a>
		c -= 55;
     9ce:	67 53       	subi	r22, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     9d0:	87 2f       	mov	r24, r23
     9d2:	80 53       	subi	r24, 0x30	; 48
     9d4:	8a 30       	cpi	r24, 0x0A	; 10
     9d6:	10 f4       	brcc	.+4      	; 0x9dc <retConv_s32+0x66>
     9d8:	78 2f       	mov	r23, r24
     9da:	05 c0       	rjmp	.+10     	; 0x9e6 <retConv_s32+0x70>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     9dc:	87 2f       	mov	r24, r23
     9de:	81 54       	subi	r24, 0x41	; 65
     9e0:	86 30       	cpi	r24, 0x06	; 6
     9e2:	08 f4       	brcc	.+2      	; 0x9e6 <retConv_s32+0x70>
		c -= 55;
     9e4:	77 53       	subi	r23, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     9e6:	81 2f       	mov	r24, r17
     9e8:	80 53       	subi	r24, 0x30	; 48
     9ea:	8a 30       	cpi	r24, 0x0A	; 10
     9ec:	10 f4       	brcc	.+4      	; 0x9f2 <retConv_s32+0x7c>
     9ee:	18 2f       	mov	r17, r24
     9f0:	05 c0       	rjmp	.+10     	; 0x9fc <retConv_s32+0x86>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     9f2:	81 2f       	mov	r24, r17
     9f4:	81 54       	subi	r24, 0x41	; 65
     9f6:	86 30       	cpi	r24, 0x06	; 6
     9f8:	08 f4       	brcc	.+2      	; 0x9fc <retConv_s32+0x86>
		c -= 55;
     9fa:	17 53       	subi	r17, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     9fc:	80 2f       	mov	r24, r16
     9fe:	80 53       	subi	r24, 0x30	; 48
     a00:	8a 30       	cpi	r24, 0x0A	; 10
     a02:	10 f4       	brcc	.+4      	; 0xa08 <retConv_s32+0x92>
     a04:	08 2f       	mov	r16, r24
     a06:	05 c0       	rjmp	.+10     	; 0xa12 <retConv_s32+0x9c>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     a08:	80 2f       	mov	r24, r16
     a0a:	81 54       	subi	r24, 0x41	; 65
     a0c:	86 30       	cpi	r24, 0x06	; 6
     a0e:	08 f4       	brcc	.+2      	; 0xa12 <retConv_s32+0x9c>
		c -= 55;
     a10:	07 53       	subi	r16, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     a12:	8f 2d       	mov	r24, r15
     a14:	80 53       	subi	r24, 0x30	; 48
     a16:	8a 30       	cpi	r24, 0x0A	; 10
     a18:	10 f4       	brcc	.+4      	; 0xa1e <retConv_s32+0xa8>
     a1a:	f8 2e       	mov	r15, r24
     a1c:	06 c0       	rjmp	.+12     	; 0xa2a <retConv_s32+0xb4>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     a1e:	8f 2d       	mov	r24, r15
     a20:	81 54       	subi	r24, 0x41	; 65
     a22:	86 30       	cpi	r24, 0x06	; 6
     a24:	10 f4       	brcc	.+4      	; 0xa2a <retConv_s32+0xb4>
		c -= 55;
     a26:	89 ec       	ldi	r24, 0xC9	; 201
     a28:	f8 0e       	add	r15, r24

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     a2a:	8e 2f       	mov	r24, r30
     a2c:	80 53       	subi	r24, 0x30	; 48
     a2e:	8a 30       	cpi	r24, 0x0A	; 10
     a30:	10 f4       	brcc	.+4      	; 0xa36 <retConv_s32+0xc0>
     a32:	e8 2f       	mov	r30, r24
     a34:	05 c0       	rjmp	.+10     	; 0xa40 <retConv_s32+0xca>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     a36:	8e 2f       	mov	r24, r30
     a38:	81 54       	subi	r24, 0x41	; 65
     a3a:	86 30       	cpi	r24, 0x06	; 6
     a3c:	08 f4       	brcc	.+2      	; 0xa40 <retConv_s32+0xca>
		c -= 55;
     a3e:	e7 53       	subi	r30, 0x37	; 55
	iv6 = char2hex(iv6);
	iv7 = char2hex(iv7);
	iv8 = char2hex(iv8);

	int_val = (int_val | iv1);
	int_val = ((int_val<<4) | iv2);
     a40:	30 e0       	ldi	r19, 0x00	; 0
     a42:	40 e0       	ldi	r20, 0x00	; 0
     a44:	50 e0       	ldi	r21, 0x00	; 0
     a46:	89 2f       	mov	r24, r25
     a48:	90 e0       	ldi	r25, 0x00	; 0
     a4a:	a0 e0       	ldi	r26, 0x00	; 0
     a4c:	b0 e0       	ldi	r27, 0x00	; 0
     a4e:	f4 e0       	ldi	r31, 0x04	; 4
     a50:	88 0f       	add	r24, r24
     a52:	99 1f       	adc	r25, r25
     a54:	aa 1f       	adc	r26, r26
     a56:	bb 1f       	adc	r27, r27
     a58:	fa 95       	dec	r31
     a5a:	d1 f7       	brne	.-12     	; 0xa50 <retConv_s32+0xda>
     a5c:	28 2b       	or	r18, r24
     a5e:	39 2b       	or	r19, r25
     a60:	4a 2b       	or	r20, r26
     a62:	5b 2b       	or	r21, r27
	int_val = ((int_val<<4) | iv3);
     a64:	a4 e0       	ldi	r26, 0x04	; 4
     a66:	22 0f       	add	r18, r18
     a68:	33 1f       	adc	r19, r19
     a6a:	44 1f       	adc	r20, r20
     a6c:	55 1f       	adc	r21, r21
     a6e:	aa 95       	dec	r26
     a70:	d1 f7       	brne	.-12     	; 0xa66 <retConv_s32+0xf0>
     a72:	86 2f       	mov	r24, r22
     a74:	90 e0       	ldi	r25, 0x00	; 0
     a76:	a0 e0       	ldi	r26, 0x00	; 0
     a78:	b0 e0       	ldi	r27, 0x00	; 0
     a7a:	82 2b       	or	r24, r18
     a7c:	93 2b       	or	r25, r19
     a7e:	a4 2b       	or	r26, r20
     a80:	b5 2b       	or	r27, r21
	int_val = ((int_val<<4) | iv4);
     a82:	f4 e0       	ldi	r31, 0x04	; 4
     a84:	88 0f       	add	r24, r24
     a86:	99 1f       	adc	r25, r25
     a88:	aa 1f       	adc	r26, r26
     a8a:	bb 1f       	adc	r27, r27
     a8c:	fa 95       	dec	r31
     a8e:	d1 f7       	brne	.-12     	; 0xa84 <retConv_s32+0x10e>
     a90:	27 2f       	mov	r18, r23
     a92:	30 e0       	ldi	r19, 0x00	; 0
     a94:	40 e0       	ldi	r20, 0x00	; 0
     a96:	50 e0       	ldi	r21, 0x00	; 0
     a98:	28 2b       	or	r18, r24
     a9a:	39 2b       	or	r19, r25
     a9c:	4a 2b       	or	r20, r26
     a9e:	5b 2b       	or	r21, r27
	int_val = ((int_val<<4) | iv5);
     aa0:	64 e0       	ldi	r22, 0x04	; 4
     aa2:	22 0f       	add	r18, r18
     aa4:	33 1f       	adc	r19, r19
     aa6:	44 1f       	adc	r20, r20
     aa8:	55 1f       	adc	r21, r21
     aaa:	6a 95       	dec	r22
     aac:	d1 f7       	brne	.-12     	; 0xaa2 <retConv_s32+0x12c>
     aae:	81 2f       	mov	r24, r17
     ab0:	90 e0       	ldi	r25, 0x00	; 0
     ab2:	a0 e0       	ldi	r26, 0x00	; 0
     ab4:	b0 e0       	ldi	r27, 0x00	; 0
     ab6:	82 2b       	or	r24, r18
     ab8:	93 2b       	or	r25, r19
     aba:	a4 2b       	or	r26, r20
     abc:	b5 2b       	or	r27, r21
	int_val = ((int_val<<4) | iv6);
     abe:	24 e0       	ldi	r18, 0x04	; 4
     ac0:	88 0f       	add	r24, r24
     ac2:	99 1f       	adc	r25, r25
     ac4:	aa 1f       	adc	r26, r26
     ac6:	bb 1f       	adc	r27, r27
     ac8:	2a 95       	dec	r18
     aca:	d1 f7       	brne	.-12     	; 0xac0 <retConv_s32+0x14a>
     acc:	20 2f       	mov	r18, r16
     ace:	30 e0       	ldi	r19, 0x00	; 0
     ad0:	40 e0       	ldi	r20, 0x00	; 0
     ad2:	50 e0       	ldi	r21, 0x00	; 0
     ad4:	28 2b       	or	r18, r24
     ad6:	39 2b       	or	r19, r25
     ad8:	4a 2b       	or	r20, r26
     ada:	5b 2b       	or	r21, r27
	int_val = ((int_val<<4) | iv7);
     adc:	04 e0       	ldi	r16, 0x04	; 4
     ade:	22 0f       	add	r18, r18
     ae0:	33 1f       	adc	r19, r19
     ae2:	44 1f       	adc	r20, r20
     ae4:	55 1f       	adc	r21, r21
     ae6:	0a 95       	dec	r16
     ae8:	d1 f7       	brne	.-12     	; 0xade <retConv_s32+0x168>
     aea:	8f 2d       	mov	r24, r15
     aec:	90 e0       	ldi	r25, 0x00	; 0
     aee:	a0 e0       	ldi	r26, 0x00	; 0
     af0:	b0 e0       	ldi	r27, 0x00	; 0
     af2:	82 2b       	or	r24, r18
     af4:	93 2b       	or	r25, r19
     af6:	a4 2b       	or	r26, r20
     af8:	b5 2b       	or	r27, r21
	int_val = ((int_val<<4) | iv8);
     afa:	14 e0       	ldi	r17, 0x04	; 4
     afc:	88 0f       	add	r24, r24
     afe:	99 1f       	adc	r25, r25
     b00:	aa 1f       	adc	r26, r26
     b02:	bb 1f       	adc	r27, r27
     b04:	1a 95       	dec	r17
     b06:	d1 f7       	brne	.-12     	; 0xafc <retConv_s32+0x186>
     b08:	2e 2f       	mov	r18, r30
     b0a:	30 e0       	ldi	r19, 0x00	; 0
     b0c:	40 e0       	ldi	r20, 0x00	; 0
     b0e:	50 e0       	ldi	r21, 0x00	; 0
     b10:	28 2b       	or	r18, r24
     b12:	39 2b       	or	r19, r25
     b14:	4a 2b       	or	r20, r26
     b16:	5b 2b       	or	r21, r27
	return int_val;
}
     b18:	b9 01       	movw	r22, r18
     b1a:	ca 01       	movw	r24, r20
     b1c:	1f 91       	pop	r17
     b1e:	0f 91       	pop	r16
     b20:	ff 90       	pop	r15
     b22:	08 95       	ret

00000b24 <wheel_L>:
}

/*************************************************/


void wheel_L(signed int cmd_vel){
     b24:	9c 01       	movw	r18, r24
		if(cmd_vel > 36){cmd_vel = 36;}
     b26:	85 32       	cpi	r24, 0x25	; 37
     b28:	91 05       	cpc	r25, r1
     b2a:	1c f0       	brlt	.+6      	; 0xb32 <wheel_L+0xe>
     b2c:	24 e2       	ldi	r18, 0x24	; 36
     b2e:	30 e0       	ldi	r19, 0x00	; 0
     b30:	06 c0       	rjmp	.+12     	; 0xb3e <wheel_L+0x1a>
		if(cmd_vel < -36){cmd_vel = -36;}
     b32:	8f ef       	ldi	r24, 0xFF	; 255
     b34:	2c 3d       	cpi	r18, 0xDC	; 220
     b36:	38 07       	cpc	r19, r24
     b38:	14 f4       	brge	.+4      	; 0xb3e <wheel_L+0x1a>
     b3a:	2c ed       	ldi	r18, 0xDC	; 220
     b3c:	3f ef       	ldi	r19, 0xFF	; 255
		
		float s_out = -0.4928 * (cmd_vel) + 185.27;
		
		taskENTER_CRITICAL();
     b3e:	0f b6       	in	r0, 0x3f	; 63
     b40:	f8 94       	cli
     b42:	0f 92       	push	r0
		PWM_timer3_Set_E4((int)s_out);
     b44:	b9 01       	movw	r22, r18
     b46:	88 27       	eor	r24, r24
     b48:	77 fd       	sbrc	r23, 7
     b4a:	80 95       	com	r24
     b4c:	98 2f       	mov	r25, r24
     b4e:	0e 94 8b 2e 	call	0x5d16	; 0x5d16 <__floatsisf>
     b52:	28 e4       	ldi	r18, 0x48	; 72
     b54:	30 e5       	ldi	r19, 0x50	; 80
     b56:	4c ef       	ldi	r20, 0xFC	; 252
     b58:	5e eb       	ldi	r21, 0xBE	; 190
     b5a:	0e 94 3f 2f 	call	0x5e7e	; 0x5e7e <__mulsf3>
     b5e:	2f e1       	ldi	r18, 0x1F	; 31
     b60:	35 e4       	ldi	r19, 0x45	; 69
     b62:	49 e3       	ldi	r20, 0x39	; 57
     b64:	53 e4       	ldi	r21, 0x43	; 67
     b66:	0e 94 88 2d 	call	0x5b10	; 0x5b10 <__addsf3>
     b6a:	0e 94 58 2e 	call	0x5cb0	; 0x5cb0 <__fixsfsi>
void PWM_timer2_Set_H6(u16 pwmDuty)
	{OCR2B = pwmDuty;}
void PWM_timer3_Set_E3(u16 pwmDuty)
	{OCR3A = pwmDuty;}
void PWM_timer3_Set_E4(u16 pwmDuty)
	{OCR3B = pwmDuty;}
     b6e:	70 93 9b 00 	sts	0x009B, r23
     b72:	60 93 9a 00 	sts	0x009A, r22
		taskEXIT_CRITICAL();
     b76:	0f 90       	pop	r0
     b78:	0f be       	out	0x3f, r0	; 63


}
     b7a:	08 95       	ret

00000b7c <wheel_R>:

void wheel_R(signed int cmd_vel){
     b7c:	9c 01       	movw	r18, r24
		if(cmd_vel > 36){cmd_vel = 36;}
     b7e:	85 32       	cpi	r24, 0x25	; 37
     b80:	91 05       	cpc	r25, r1
     b82:	1c f0       	brlt	.+6      	; 0xb8a <wheel_R+0xe>
     b84:	24 e2       	ldi	r18, 0x24	; 36
     b86:	30 e0       	ldi	r19, 0x00	; 0
     b88:	06 c0       	rjmp	.+12     	; 0xb96 <wheel_R+0x1a>
		if(cmd_vel < -36){cmd_vel = -36;}
     b8a:	8f ef       	ldi	r24, 0xFF	; 255
     b8c:	2c 3d       	cpi	r18, 0xDC	; 220
     b8e:	38 07       	cpc	r19, r24
     b90:	14 f4       	brge	.+4      	; 0xb96 <wheel_R+0x1a>
     b92:	2c ed       	ldi	r18, 0xDC	; 220
     b94:	3f ef       	ldi	r19, 0xFF	; 255
				
		float s_out = -0.5421 * (cmd_vel) + 188.41;

		taskENTER_CRITICAL();
     b96:	0f b6       	in	r0, 0x3f	; 63
     b98:	f8 94       	cli
     b9a:	0f 92       	push	r0
		PWM_timer3_Set_E3((int)s_out);
     b9c:	b9 01       	movw	r22, r18
     b9e:	88 27       	eor	r24, r24
     ba0:	77 fd       	sbrc	r23, 7
     ba2:	80 95       	com	r24
     ba4:	98 2f       	mov	r25, r24
     ba6:	0e 94 8b 2e 	call	0x5d16	; 0x5d16 <__floatsisf>
     baa:	21 e1       	ldi	r18, 0x11	; 17
     bac:	37 ec       	ldi	r19, 0xC7	; 199
     bae:	4a e0       	ldi	r20, 0x0A	; 10
     bb0:	5f eb       	ldi	r21, 0xBF	; 191
     bb2:	0e 94 3f 2f 	call	0x5e7e	; 0x5e7e <__mulsf3>
     bb6:	26 ef       	ldi	r18, 0xF6	; 246
     bb8:	38 e6       	ldi	r19, 0x68	; 104
     bba:	4c e3       	ldi	r20, 0x3C	; 60
     bbc:	53 e4       	ldi	r21, 0x43	; 67
     bbe:	0e 94 88 2d 	call	0x5b10	; 0x5b10 <__addsf3>
     bc2:	0e 94 58 2e 	call	0x5cb0	; 0x5cb0 <__fixsfsi>
void PWM_timer1_Set_LED(u16 pwmDuty)
	{OCR1B = pwmDuty;}
void PWM_timer2_Set_H6(u16 pwmDuty)
	{OCR2B = pwmDuty;}
void PWM_timer3_Set_E3(u16 pwmDuty)
	{OCR3A = pwmDuty;}
     bc6:	70 93 99 00 	sts	0x0099, r23
     bca:	60 93 98 00 	sts	0x0098, r22
		taskEXIT_CRITICAL();
     bce:	0f 90       	pop	r0
     bd0:	0f be       	out	0x3f, r0	; 63


}
     bd2:	08 95       	ret

00000bd4 <num2char>:
	}
}



char num2char(char c){
     bd4:	98 2f       	mov	r25, r24
	
	if(c <10){
     bd6:	8a 30       	cpi	r24, 0x0A	; 10
     bd8:	10 f4       	brcc	.+4      	; 0xbde <num2char+0xa>
		c += 48;
     bda:	90 5d       	subi	r25, 0xD0	; 208
     bdc:	04 c0       	rjmp	.+8      	; 0xbe6 <num2char+0x12>
	}
	else if((c >= 10) && (c <= 16)){
     bde:	8a 50       	subi	r24, 0x0A	; 10
     be0:	87 30       	cpi	r24, 0x07	; 7
     be2:	08 f4       	brcc	.+2      	; 0xbe6 <num2char+0x12>
		c += 55;
     be4:	99 5c       	subi	r25, 0xC9	; 201
	}
	return c;
}
     be6:	89 2f       	mov	r24, r25
     be8:	08 95       	ret

00000bea <vServoTm>:
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
		LED_off();
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));	}
}

void vServoTm(){
     bea:	1f 93       	push	r17
     bec:	cf 93       	push	r28
     bee:	df 93       	push	r29
	char adj;
	for(;;){
		adj = uart1GetByte();
		if(adj == 'p'){ spray_time++;}
		else if(adj == 'l'){ spray_time--;}
		rprintf("%d\n", spray_time);
     bf0:	11 e0       	ldi	r17, 0x01	; 1
     bf2:	c8 e0       	ldi	r28, 0x08	; 8
     bf4:	d1 e0       	ldi	r29, 0x01	; 1
}

void vServoTm(){
	char adj;
	for(;;){
		adj = uart1GetByte();
     bf6:	0e 94 fb 25 	call	0x4bf6	; 0x4bf6 <uart1GetByte>
		if(adj == 'p'){ spray_time++;}
     bfa:	80 37       	cpi	r24, 0x70	; 112
     bfc:	31 f4       	brne	.+12     	; 0xc0a <vServoTm+0x20>
     bfe:	80 91 ae 02 	lds	r24, 0x02AE
     c02:	90 91 af 02 	lds	r25, 0x02AF
     c06:	01 96       	adiw	r24, 0x01	; 1
     c08:	07 c0       	rjmp	.+14     	; 0xc18 <vServoTm+0x2e>
		else if(adj == 'l'){ spray_time--;}
     c0a:	8c 36       	cpi	r24, 0x6C	; 108
     c0c:	49 f4       	brne	.+18     	; 0xc20 <vServoTm+0x36>
     c0e:	80 91 ae 02 	lds	r24, 0x02AE
     c12:	90 91 af 02 	lds	r25, 0x02AF
     c16:	01 97       	sbiw	r24, 0x01	; 1
     c18:	90 93 af 02 	sts	0x02AF, r25
     c1c:	80 93 ae 02 	sts	0x02AE, r24
		rprintf("%d\n", spray_time);
     c20:	00 d0       	rcall	.+0      	; 0xc22 <vServoTm+0x38>
     c22:	00 d0       	rcall	.+0      	; 0xc24 <vServoTm+0x3a>
     c24:	0f 92       	push	r0
     c26:	ed b7       	in	r30, 0x3d	; 61
     c28:	fe b7       	in	r31, 0x3e	; 62
     c2a:	31 96       	adiw	r30, 0x01	; 1
     c2c:	ad b7       	in	r26, 0x3d	; 61
     c2e:	be b7       	in	r27, 0x3e	; 62
     c30:	11 96       	adiw	r26, 0x01	; 1
     c32:	1c 93       	st	X, r17
     c34:	d2 83       	std	Z+2, r29	; 0x02
     c36:	c1 83       	std	Z+1, r28	; 0x01
     c38:	80 91 ae 02 	lds	r24, 0x02AE
     c3c:	90 91 af 02 	lds	r25, 0x02AF
     c40:	94 83       	std	Z+4, r25	; 0x04
     c42:	83 83       	std	Z+3, r24	; 0x03
     c44:	0e 94 4e 2a 	call	0x549c	; 0x549c <rprintf1RamRom>
     c48:	0f 90       	pop	r0
     c4a:	0f 90       	pop	r0
     c4c:	0f 90       	pop	r0
     c4e:	0f 90       	pop	r0
     c50:	0f 90       	pop	r0
     c52:	d1 cf       	rjmp	.-94     	; 0xbf6 <vServoTm+0xc>

00000c54 <fwdSer_L>:
		
			//taskYIELD();
	//	}
		
}
void fwdSer_L(unsigned char c){
     c54:	6f 92       	push	r6
     c56:	7f 92       	push	r7
     c58:	8f 92       	push	r8
     c5a:	9f 92       	push	r9
     c5c:	af 92       	push	r10
     c5e:	bf 92       	push	r11
     c60:	cf 92       	push	r12
     c62:	df 92       	push	r13
     c64:	ef 92       	push	r14
     c66:	ff 92       	push	r15
     c68:	0f 93       	push	r16
     c6a:	1f 93       	push	r17
     c6c:	cf 93       	push	r28
     c6e:	df 93       	push	r29
     c70:	98 2f       	mov	r25, r24
	sbi(TCCR3A,COM3A1);
	cbi(TCCR3A,COM3A0);
}
void PWM_timer3_On_E4(void)
{
	sbi(TCCR3A,COM3B1);
     c72:	80 91 90 00 	lds	r24, 0x0090
     c76:	80 62       	ori	r24, 0x20	; 32
     c78:	80 93 90 00 	sts	0x0090, r24
	cbi(TCCR3A,COM3B0);
     c7c:	80 91 90 00 	lds	r24, 0x0090
     c80:	8f 7e       	andi	r24, 0xEF	; 239
     c82:	80 93 90 00 	sts	0x0090, r24
	const float KI = KP/TI;
	signed int v_out = 0;
	wheel_L_on();

		//rprintf("%c",c);
		if(c != 0xff){
     c86:	9f 3f       	cpi	r25, 0xFF	; 255
     c88:	09 f4       	brne	.+2      	; 0xc8c <fwdSer_L+0x38>
     c8a:	06 c1       	rjmp	.+524    	; 0xe98 <fwdSer_L+0x244>
		//if the data isn't whitespace (0xff), post it
		//	rprintf("%c",c);

			if(c == 0x0A){lf_flag = SET;} //line feed detected, the character will be a 'D' or a 'V'
     c8c:	9a 30       	cpi	r25, 0x0A	; 10
     c8e:	21 f4       	brne	.+8      	; 0xc98 <fwdSer_L+0x44>
     c90:	81 e0       	ldi	r24, 0x01	; 1
     c92:	80 93 19 03 	sts	0x0319, r24
     c96:	33 c0       	rjmp	.+102    	; 0xcfe <fwdSer_L+0xaa>
	
			else if((lf_flag) && (c == 'V')){ //set velocity flag
     c98:	80 91 19 03 	lds	r24, 0x0319
     c9c:	88 23       	and	r24, r24
     c9e:	91 f0       	breq	.+36     	; 0xcc4 <fwdSer_L+0x70>
     ca0:	96 35       	cpi	r25, 0x56	; 86
     ca2:	31 f4       	brne	.+12     	; 0xcb0 <fwdSer_L+0x5c>
				v_flag = SET;
     ca4:	81 e0       	ldi	r24, 0x01	; 1
     ca6:	80 93 16 03 	sts	0x0316, r24
				v_iter = 0;
     caa:	10 92 18 03 	sts	0x0318, r1
     cae:	07 c0       	rjmp	.+14     	; 0xcbe <fwdSer_L+0x6a>
				lf_flag = UNSET;
				return;
			} 
			else if((lf_flag) && (c == 'D')){ //set distance flag
     cb0:	94 34       	cpi	r25, 0x44	; 68
     cb2:	41 f4       	brne	.+16     	; 0xcc4 <fwdSer_L+0x70>
				d_flag = SET;
     cb4:	81 e0       	ldi	r24, 0x01	; 1
     cb6:	80 93 15 03 	sts	0x0315, r24
				d_iter = 0;
     cba:	10 92 17 03 	sts	0x0317, r1
				lf_flag = UNSET;
     cbe:	10 92 19 03 	sts	0x0319, r1
     cc2:	f9 c0       	rjmp	.+498    	; 0xeb6 <fwdSer_L+0x262>
			//	rprintf("%c",c);
				return;
			}
			else if(v_flag){
     cc4:	80 91 16 03 	lds	r24, 0x0316
     cc8:	88 23       	and	r24, r24
     cca:	59 f0       	breq	.+22     	; 0xce2 <fwdSer_L+0x8e>
				vel_rough[v_iter++] = c;	//store then increment	
     ccc:	80 91 18 03 	lds	r24, 0x0318
     cd0:	e8 2f       	mov	r30, r24
     cd2:	f0 e0       	ldi	r31, 0x00	; 0
     cd4:	ef 5e       	subi	r30, 0xEF	; 239
     cd6:	fc 4f       	sbci	r31, 0xFC	; 252
     cd8:	90 83       	st	Z, r25
     cda:	8f 5f       	subi	r24, 0xFF	; 255
     cdc:	80 93 18 03 	sts	0x0318, r24
     ce0:	0e c0       	rjmp	.+28     	; 0xcfe <fwdSer_L+0xaa>
				//rprintf("%c",c);
			}	
			else if(d_flag){
     ce2:	80 91 15 03 	lds	r24, 0x0315
     ce6:	88 23       	and	r24, r24
     ce8:	51 f0       	breq	.+20     	; 0xcfe <fwdSer_L+0xaa>
				dis_rough[d_iter++] = c;	//store then increment	
     cea:	80 91 17 03 	lds	r24, 0x0317
     cee:	e8 2f       	mov	r30, r24
     cf0:	f0 e0       	ldi	r31, 0x00	; 0
     cf2:	e7 5f       	subi	r30, 0xF7	; 247
     cf4:	fc 4f       	sbci	r31, 0xFC	; 252
     cf6:	90 83       	st	Z, r25
     cf8:	8f 5f       	subi	r24, 0xFF	; 255
     cfa:	80 93 17 03 	sts	0x0317, r24
			//	rprintf("%c",c);
			}

			if(v_iter == 4){
     cfe:	80 91 18 03 	lds	r24, 0x0318
     d02:	84 30       	cpi	r24, 0x04	; 4
     d04:	09 f0       	breq	.+2      	; 0xd08 <fwdSer_L+0xb4>
     d06:	a9 c0       	rjmp	.+338    	; 0xe5a <fwdSer_L+0x206>
				LEFTVel_current = CM_TICK * retConv_s16(&vel_rough);
     d08:	81 e1       	ldi	r24, 0x11	; 17
     d0a:	93 e0       	ldi	r25, 0x03	; 3
     d0c:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <retConv_s16>
     d10:	aa 27       	eor	r26, r26
     d12:	97 fd       	sbrc	r25, 7
     d14:	a0 95       	com	r26
     d16:	ba 2f       	mov	r27, r26
     d18:	bc 01       	movw	r22, r24
     d1a:	cd 01       	movw	r24, r26
     d1c:	0e 94 8b 2e 	call	0x5d16	; 0x5d16 <__floatsisf>
     d20:	20 e0       	ldi	r18, 0x00	; 0
     d22:	30 e0       	ldi	r19, 0x00	; 0
     d24:	40 e8       	ldi	r20, 0x80	; 128
     d26:	5e e3       	ldi	r21, 0x3E	; 62
     d28:	0e 94 3f 2f 	call	0x5e7e	; 0x5e7e <__mulsf3>
     d2c:	0e 94 58 2e 	call	0x5cb0	; 0x5cb0 <__fixsfsi>
     d30:	9b 01       	movw	r18, r22
     d32:	ac 01       	movw	r20, r24
     d34:	70 93 c3 02 	sts	0x02C3, r23
     d38:	60 93 c2 02 	sts	0x02C2, r22
				v_flag = UNSET;
     d3c:	10 92 16 03 	sts	0x0316, r1
				v_iter = 0;
     d40:	10 92 18 03 	sts	0x0318, r1
				LEFTVel_ready = SET;
     d44:	81 e0       	ldi	r24, 0x01	; 1
     d46:	80 93 c4 02 	sts	0x02C4, r24
// PID correction
			error = v_left - LEFTVel_current;
			v_out = (signed int)(KP*error + KI*acc_error);
     d4a:	60 91 be 02 	lds	r22, 0x02BE
     d4e:	70 91 bf 02 	lds	r23, 0x02BF
     d52:	62 1b       	sub	r22, r18
     d54:	73 0b       	sbc	r23, r19
     d56:	88 27       	eor	r24, r24
     d58:	77 fd       	sbrc	r23, 7
     d5a:	80 95       	com	r24
     d5c:	98 2f       	mov	r25, r24
     d5e:	0e 94 8b 2e 	call	0x5d16	; 0x5d16 <__floatsisf>
     d62:	3b 01       	movw	r6, r22
     d64:	4c 01       	movw	r8, r24
     d66:	a0 90 05 03 	lds	r10, 0x0305
     d6a:	b0 90 06 03 	lds	r11, 0x0306
     d6e:	c0 90 07 03 	lds	r12, 0x0307
     d72:	d0 90 08 03 	lds	r13, 0x0308
     d76:	2c e4       	ldi	r18, 0x4C	; 76
     d78:	33 e9       	ldi	r19, 0x93	; 147
     d7a:	49 e1       	ldi	r20, 0x19	; 25
     d7c:	5c e3       	ldi	r21, 0x3C	; 60
     d7e:	0e 94 3f 2f 	call	0x5e7e	; 0x5e7e <__mulsf3>
     d82:	7b 01       	movw	r14, r22
     d84:	8c 01       	movw	r16, r24
     d86:	c6 01       	movw	r24, r12
     d88:	b5 01       	movw	r22, r10
     d8a:	20 ea       	ldi	r18, 0xA0	; 160
     d8c:	33 e0       	ldi	r19, 0x03	; 3
     d8e:	4f eb       	ldi	r20, 0xBF	; 191
     d90:	5c e3       	ldi	r21, 0x3C	; 60
     d92:	0e 94 3f 2f 	call	0x5e7e	; 0x5e7e <__mulsf3>
     d96:	9b 01       	movw	r18, r22
     d98:	ac 01       	movw	r20, r24
     d9a:	c8 01       	movw	r24, r16
     d9c:	b7 01       	movw	r22, r14
     d9e:	0e 94 88 2d 	call	0x5b10	; 0x5b10 <__addsf3>
     da2:	0e 94 58 2e 	call	0x5cb0	; 0x5cb0 <__fixsfsi>
     da6:	eb 01       	movw	r28, r22
			
			// Anti windup
			if((v_out >= 36) || (v_out <= -36)){
     da8:	cb 01       	movw	r24, r22
     daa:	83 96       	adiw	r24, 0x23	; 35
     dac:	87 34       	cpi	r24, 0x47	; 71
     dae:	91 05       	cpc	r25, r1
     db0:	d0 f0       	brcs	.+52     	; 0xde6 <fwdSer_L+0x192>
				v_out -= KI*acc_error;
     db2:	be 01       	movw	r22, r28
     db4:	88 27       	eor	r24, r24
     db6:	77 fd       	sbrc	r23, 7
     db8:	80 95       	com	r24
     dba:	98 2f       	mov	r25, r24
     dbc:	0e 94 8b 2e 	call	0x5d16	; 0x5d16 <__floatsisf>
     dc0:	7b 01       	movw	r14, r22
     dc2:	8c 01       	movw	r16, r24
     dc4:	c6 01       	movw	r24, r12
     dc6:	b5 01       	movw	r22, r10
     dc8:	20 ea       	ldi	r18, 0xA0	; 160
     dca:	33 e0       	ldi	r19, 0x03	; 3
     dcc:	4f eb       	ldi	r20, 0xBF	; 191
     dce:	5c eb       	ldi	r21, 0xBC	; 188
     dd0:	0e 94 3f 2f 	call	0x5e7e	; 0x5e7e <__mulsf3>
     dd4:	9b 01       	movw	r18, r22
     dd6:	ac 01       	movw	r20, r24
     dd8:	c8 01       	movw	r24, r16
     dda:	b7 01       	movw	r22, r14
     ddc:	0e 94 88 2d 	call	0x5b10	; 0x5b10 <__addsf3>
     de0:	0e 94 58 2e 	call	0x5cb0	; 0x5cb0 <__fixsfsi>
     de4:	eb 01       	movw	r28, r22
			}
			
			acc_error += error;
     de6:	c6 01       	movw	r24, r12
     de8:	b5 01       	movw	r22, r10
     dea:	a4 01       	movw	r20, r8
     dec:	93 01       	movw	r18, r6
     dee:	0e 94 88 2d 	call	0x5b10	; 0x5b10 <__addsf3>
     df2:	60 93 05 03 	sts	0x0305, r22
     df6:	70 93 06 03 	sts	0x0306, r23
     dfa:	80 93 07 03 	sts	0x0307, r24
     dfe:	90 93 08 03 	sts	0x0308, r25

			if(v_out > 36){v_out = 36;}
     e02:	c5 32       	cpi	r28, 0x25	; 37
     e04:	d1 05       	cpc	r29, r1
     e06:	1c f0       	brlt	.+6      	; 0xe0e <fwdSer_L+0x1ba>
     e08:	c4 e2       	ldi	r28, 0x24	; 36
     e0a:	d0 e0       	ldi	r29, 0x00	; 0
     e0c:	06 c0       	rjmp	.+12     	; 0xe1a <fwdSer_L+0x1c6>
			if(v_out < -36){v_out = -36;}
     e0e:	8f ef       	ldi	r24, 0xFF	; 255
     e10:	cc 3d       	cpi	r28, 0xDC	; 220
     e12:	d8 07       	cpc	r29, r24
     e14:	14 f4       	brge	.+4      	; 0xe1a <fwdSer_L+0x1c6>
     e16:	cc ed       	ldi	r28, 0xDC	; 220
     e18:	df ef       	ldi	r29, 0xFF	; 255
			
			wheel_L(v_out);
     e1a:	ce 01       	movw	r24, r28
     e1c:	0e 94 92 05 	call	0xb24	; 0xb24 <wheel_L>
			
			rprintf("%d, ",LEFTVel_current);
     e20:	00 d0       	rcall	.+0      	; 0xe22 <fwdSer_L+0x1ce>
     e22:	00 d0       	rcall	.+0      	; 0xe24 <fwdSer_L+0x1d0>
     e24:	0f 92       	push	r0
     e26:	ed b7       	in	r30, 0x3d	; 61
     e28:	fe b7       	in	r31, 0x3e	; 62
     e2a:	31 96       	adiw	r30, 0x01	; 1
     e2c:	81 e0       	ldi	r24, 0x01	; 1
     e2e:	ad b7       	in	r26, 0x3d	; 61
     e30:	be b7       	in	r27, 0x3e	; 62
     e32:	11 96       	adiw	r26, 0x01	; 1
     e34:	8c 93       	st	X, r24
     e36:	86 ea       	ldi	r24, 0xA6	; 166
     e38:	91 e0       	ldi	r25, 0x01	; 1
     e3a:	92 83       	std	Z+2, r25	; 0x02
     e3c:	81 83       	std	Z+1, r24	; 0x01
     e3e:	80 91 c2 02 	lds	r24, 0x02C2
     e42:	90 91 c3 02 	lds	r25, 0x02C3
     e46:	94 83       	std	Z+4, r25	; 0x04
     e48:	83 83       	std	Z+3, r24	; 0x03
     e4a:	0e 94 4e 2a 	call	0x549c	; 0x549c <rprintf1RamRom>
     e4e:	0f 90       	pop	r0
     e50:	0f 90       	pop	r0
     e52:	0f 90       	pop	r0
     e54:	0f 90       	pop	r0
     e56:	0f 90       	pop	r0
     e58:	2e c0       	rjmp	.+92     	; 0xeb6 <fwdSer_L+0x262>
			//	rprintf("LEFTVel_ready: %d\n", LEFTVel_ready);
			//	rprintf("LLL VVV: ");
			//	rprintfu16(RIGHTVel_current);
			//	rprintf("\n");
			}
			else if(d_iter == 8){
     e5a:	80 91 17 03 	lds	r24, 0x0317
     e5e:	88 30       	cpi	r24, 0x08	; 8
     e60:	51 f5       	brne	.+84     	; 0xeb6 <fwdSer_L+0x262>
				LEFTDis_current = CM_TICK * retConv_s32(&dis_rough);
     e62:	89 e0       	ldi	r24, 0x09	; 9
     e64:	93 e0       	ldi	r25, 0x03	; 3
     e66:	0e 94 bb 04 	call	0x976	; 0x976 <retConv_s32>
     e6a:	0e 94 8b 2e 	call	0x5d16	; 0x5d16 <__floatsisf>
     e6e:	20 e0       	ldi	r18, 0x00	; 0
     e70:	30 e0       	ldi	r19, 0x00	; 0
     e72:	40 e8       	ldi	r20, 0x80	; 128
     e74:	5e e3       	ldi	r21, 0x3E	; 62
     e76:	0e 94 3f 2f 	call	0x5e7e	; 0x5e7e <__mulsf3>
     e7a:	0e 94 58 2e 	call	0x5cb0	; 0x5cb0 <__fixsfsi>
     e7e:	60 93 c5 02 	sts	0x02C5, r22
     e82:	70 93 c6 02 	sts	0x02C6, r23
     e86:	80 93 c7 02 	sts	0x02C7, r24
     e8a:	90 93 c8 02 	sts	0x02C8, r25
			//	rprintf("dL: %d\n",dLEFTDis);
				d_flag = UNSET;
     e8e:	10 92 15 03 	sts	0x0315, r1
				d_iter = 0;
     e92:	10 92 17 03 	sts	0x0317, r1
     e96:	0f c0       	rjmp	.+30     	; 0xeb6 <fwdSer_L+0x262>
			//	rprintf("\n");
			}
		
		}

		else{rprintf("WR\n");}
     e98:	00 d0       	rcall	.+0      	; 0xe9a <fwdSer_L+0x246>
     e9a:	0f 92       	push	r0
     e9c:	81 e0       	ldi	r24, 0x01	; 1
     e9e:	ed b7       	in	r30, 0x3d	; 61
     ea0:	fe b7       	in	r31, 0x3e	; 62
     ea2:	81 83       	std	Z+1, r24	; 0x01
     ea4:	82 ea       	ldi	r24, 0xA2	; 162
     ea6:	91 e0       	ldi	r25, 0x01	; 1
     ea8:	93 83       	std	Z+3, r25	; 0x03
     eaa:	82 83       	std	Z+2, r24	; 0x02
     eac:	0e 94 4e 2a 	call	0x549c	; 0x549c <rprintf1RamRom>
     eb0:	0f 90       	pop	r0
     eb2:	0f 90       	pop	r0
     eb4:	0f 90       	pop	r0
	//	if(xHigherPriorityTaskWoken == pdTRUE){
		//if data couldn't be posted, rprintf a message
		
			//taskYIELD();
	//	}
}
     eb6:	df 91       	pop	r29
     eb8:	cf 91       	pop	r28
     eba:	1f 91       	pop	r17
     ebc:	0f 91       	pop	r16
     ebe:	ff 90       	pop	r15
     ec0:	ef 90       	pop	r14
     ec2:	df 90       	pop	r13
     ec4:	cf 90       	pop	r12
     ec6:	bf 90       	pop	r11
     ec8:	af 90       	pop	r10
     eca:	9f 90       	pop	r9
     ecc:	8f 90       	pop	r8
     ece:	7f 90       	pop	r7
     ed0:	6f 90       	pop	r6
     ed2:	08 95       	ret

00000ed4 <fwdSer_R>:
	int_val = ((int_val<<4) | iv8);
	return int_val;
}


void fwdSer_R(unsigned char c){
     ed4:	6f 92       	push	r6
     ed6:	7f 92       	push	r7
     ed8:	8f 92       	push	r8
     eda:	9f 92       	push	r9
     edc:	af 92       	push	r10
     ede:	bf 92       	push	r11
     ee0:	cf 92       	push	r12
     ee2:	df 92       	push	r13
     ee4:	ef 92       	push	r14
     ee6:	ff 92       	push	r15
     ee8:	0f 93       	push	r16
     eea:	1f 93       	push	r17
     eec:	98 2f       	mov	r25, r24
	sbi(TCCR2A,COM2B1);
	cbi(TCCR2A,COM2B0);
}
void PWM_timer3_On_E3(void)
{
	sbi(TCCR3A,COM3A1);
     eee:	80 91 90 00 	lds	r24, 0x0090
     ef2:	80 68       	ori	r24, 0x80	; 128
     ef4:	80 93 90 00 	sts	0x0090, r24
	cbi(TCCR3A,COM3A0);
     ef8:	80 91 90 00 	lds	r24, 0x0090
     efc:	8f 7b       	andi	r24, 0xBF	; 191
     efe:	80 93 90 00 	sts	0x0090, r24
	signed int v_out = 0;
	
	wheel_R_on();

		//rprintf("%c",c);
		if(c != 0xff){
     f02:	9f 3f       	cpi	r25, 0xFF	; 255
     f04:	09 f4       	brne	.+2      	; 0xf08 <fwdSer_R+0x34>
     f06:	12 c1       	rjmp	.+548    	; 0x112c <fwdSer_R+0x258>
		//if the data isn't whitespace (0xff), post it
		//	rprintf("%c",c);

			if(c == 0x0A){lf_flag = SET;} //line feed detected, the character will be a 'D' or a 'V'
     f08:	9a 30       	cpi	r25, 0x0A	; 10
     f0a:	21 f4       	brne	.+8      	; 0xf14 <fwdSer_R+0x40>
     f0c:	81 e0       	ldi	r24, 0x01	; 1
     f0e:	80 93 2e 03 	sts	0x032E, r24
     f12:	33 c0       	rjmp	.+102    	; 0xf7a <fwdSer_R+0xa6>
	
			else if((lf_flag) && (c == 'V')){ //set velocity flag
     f14:	80 91 2e 03 	lds	r24, 0x032E
     f18:	88 23       	and	r24, r24
     f1a:	91 f0       	breq	.+36     	; 0xf40 <fwdSer_R+0x6c>
     f1c:	96 35       	cpi	r25, 0x56	; 86
     f1e:	31 f4       	brne	.+12     	; 0xf2c <fwdSer_R+0x58>
				v_flag = SET;
     f20:	81 e0       	ldi	r24, 0x01	; 1
     f22:	80 93 2b 03 	sts	0x032B, r24
				v_iter = 0;
     f26:	10 92 2d 03 	sts	0x032D, r1
     f2a:	07 c0       	rjmp	.+14     	; 0xf3a <fwdSer_R+0x66>
				lf_flag = UNSET;
				return;
			} 
			else if((lf_flag) && (c == 'D')){ //set distance flag
     f2c:	94 34       	cpi	r25, 0x44	; 68
     f2e:	41 f4       	brne	.+16     	; 0xf40 <fwdSer_R+0x6c>
				d_flag = SET;
     f30:	81 e0       	ldi	r24, 0x01	; 1
     f32:	80 93 2a 03 	sts	0x032A, r24
				d_iter = 0;
     f36:	10 92 2c 03 	sts	0x032C, r1
				lf_flag = UNSET;
     f3a:	10 92 2e 03 	sts	0x032E, r1
     f3e:	05 c1       	rjmp	.+522    	; 0x114a <fwdSer_R+0x276>
			//	rprintf("%c",c);
				return;
			}
			else if(v_flag){
     f40:	80 91 2b 03 	lds	r24, 0x032B
     f44:	88 23       	and	r24, r24
     f46:	59 f0       	breq	.+22     	; 0xf5e <fwdSer_R+0x8a>
				vel_rough[v_iter++] = c;	//store then increment	
     f48:	80 91 2d 03 	lds	r24, 0x032D
     f4c:	e8 2f       	mov	r30, r24
     f4e:	f0 e0       	ldi	r31, 0x00	; 0
     f50:	ea 5d       	subi	r30, 0xDA	; 218
     f52:	fc 4f       	sbci	r31, 0xFC	; 252
     f54:	90 83       	st	Z, r25
     f56:	8f 5f       	subi	r24, 0xFF	; 255
     f58:	80 93 2d 03 	sts	0x032D, r24
     f5c:	0e c0       	rjmp	.+28     	; 0xf7a <fwdSer_R+0xa6>
				//rprintf("%c",c);
			}	
			else if(d_flag){
     f5e:	80 91 2a 03 	lds	r24, 0x032A
     f62:	88 23       	and	r24, r24
     f64:	51 f0       	breq	.+20     	; 0xf7a <fwdSer_R+0xa6>
				dis_rough[d_iter++] = c;	//store then increment	
     f66:	80 91 2c 03 	lds	r24, 0x032C
     f6a:	e8 2f       	mov	r30, r24
     f6c:	f0 e0       	ldi	r31, 0x00	; 0
     f6e:	e2 5e       	subi	r30, 0xE2	; 226
     f70:	fc 4f       	sbci	r31, 0xFC	; 252
     f72:	90 83       	st	Z, r25
     f74:	8f 5f       	subi	r24, 0xFF	; 255
     f76:	80 93 2c 03 	sts	0x032C, r24
			//	rprintf("%c",c);
			}

			if(v_iter == 4){
     f7a:	80 91 2d 03 	lds	r24, 0x032D
     f7e:	84 30       	cpi	r24, 0x04	; 4
     f80:	09 f0       	breq	.+2      	; 0xf84 <fwdSer_R+0xb0>
     f82:	b5 c0       	rjmp	.+362    	; 0x10ee <fwdSer_R+0x21a>
				RIGHTVel_current = CM_TICK * retConv_s16(&vel_rough);
     f84:	86 e2       	ldi	r24, 0x26	; 38
     f86:	93 e0       	ldi	r25, 0x03	; 3
     f88:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <retConv_s16>
     f8c:	aa 27       	eor	r26, r26
     f8e:	97 fd       	sbrc	r25, 7
     f90:	a0 95       	com	r26
     f92:	ba 2f       	mov	r27, r26
     f94:	bc 01       	movw	r22, r24
     f96:	cd 01       	movw	r24, r26
     f98:	0e 94 8b 2e 	call	0x5d16	; 0x5d16 <__floatsisf>
     f9c:	20 e0       	ldi	r18, 0x00	; 0
     f9e:	30 e0       	ldi	r19, 0x00	; 0
     fa0:	40 e8       	ldi	r20, 0x80	; 128
     fa2:	5e e3       	ldi	r21, 0x3E	; 62
     fa4:	0e 94 3f 2f 	call	0x5e7e	; 0x5e7e <__mulsf3>
     fa8:	0e 94 58 2e 	call	0x5cb0	; 0x5cb0 <__fixsfsi>
     fac:	9b 01       	movw	r18, r22
     fae:	ac 01       	movw	r20, r24
     fb0:	70 93 d0 02 	sts	0x02D0, r23
     fb4:	60 93 cf 02 	sts	0x02CF, r22
				v_flag = UNSET;
     fb8:	10 92 2b 03 	sts	0x032B, r1
				v_iter = 0;
     fbc:	10 92 2d 03 	sts	0x032D, r1
				RIGHTVel_ready = SET;
     fc0:	81 e0       	ldi	r24, 0x01	; 1
     fc2:	80 93 d1 02 	sts	0x02D1, r24

// PID correction
			error = v_right - (-RIGHTVel_current);
			v_out = (signed int)(KP*error + KI*acc_error);
     fc6:	60 91 c0 02 	lds	r22, 0x02C0
     fca:	70 91 c1 02 	lds	r23, 0x02C1
     fce:	62 0f       	add	r22, r18
     fd0:	73 1f       	adc	r23, r19
     fd2:	88 27       	eor	r24, r24
     fd4:	77 fd       	sbrc	r23, 7
     fd6:	80 95       	com	r24
     fd8:	98 2f       	mov	r25, r24
     fda:	0e 94 8b 2e 	call	0x5d16	; 0x5d16 <__floatsisf>
     fde:	3b 01       	movw	r6, r22
     fe0:	4c 01       	movw	r8, r24
     fe2:	a0 90 1a 03 	lds	r10, 0x031A
     fe6:	b0 90 1b 03 	lds	r11, 0x031B
     fea:	c0 90 1c 03 	lds	r12, 0x031C
     fee:	d0 90 1d 03 	lds	r13, 0x031D
     ff2:	2d e8       	ldi	r18, 0x8D	; 141
     ff4:	30 e9       	ldi	r19, 0x90	; 144
     ff6:	48 e0       	ldi	r20, 0x08	; 8
     ff8:	5c e3       	ldi	r21, 0x3C	; 60
     ffa:	0e 94 3f 2f 	call	0x5e7e	; 0x5e7e <__mulsf3>
     ffe:	7b 01       	movw	r14, r22
    1000:	8c 01       	movw	r16, r24
    1002:	c6 01       	movw	r24, r12
    1004:	b5 01       	movw	r22, r10
    1006:	26 e1       	ldi	r18, 0x16	; 22
    1008:	35 e4       	ldi	r19, 0x45	; 69
    100a:	40 e8       	ldi	r20, 0x80	; 128
    100c:	5c e3       	ldi	r21, 0x3C	; 60
    100e:	0e 94 3f 2f 	call	0x5e7e	; 0x5e7e <__mulsf3>
    1012:	9b 01       	movw	r18, r22
    1014:	ac 01       	movw	r20, r24
    1016:	c8 01       	movw	r24, r16
    1018:	b7 01       	movw	r22, r14
    101a:	0e 94 88 2d 	call	0x5b10	; 0x5b10 <__addsf3>
    101e:	0e 94 58 2e 	call	0x5cb0	; 0x5cb0 <__fixsfsi>
    1022:	9b 01       	movw	r18, r22
			
			// Anti windup
			if((v_out >= 36) || (v_out <= -36)){
    1024:	cb 01       	movw	r24, r22
    1026:	83 96       	adiw	r24, 0x23	; 35
    1028:	87 34       	cpi	r24, 0x47	; 71
    102a:	91 05       	cpc	r25, r1
    102c:	d0 f0       	brcs	.+52     	; 0x1062 <fwdSer_R+0x18e>
				v_out -= KI*acc_error;
    102e:	b9 01       	movw	r22, r18
    1030:	88 27       	eor	r24, r24
    1032:	77 fd       	sbrc	r23, 7
    1034:	80 95       	com	r24
    1036:	98 2f       	mov	r25, r24
    1038:	0e 94 8b 2e 	call	0x5d16	; 0x5d16 <__floatsisf>
    103c:	7b 01       	movw	r14, r22
    103e:	8c 01       	movw	r16, r24
    1040:	c6 01       	movw	r24, r12
    1042:	b5 01       	movw	r22, r10
    1044:	26 e1       	ldi	r18, 0x16	; 22
    1046:	35 e4       	ldi	r19, 0x45	; 69
    1048:	40 e8       	ldi	r20, 0x80	; 128
    104a:	5c eb       	ldi	r21, 0xBC	; 188
    104c:	0e 94 3f 2f 	call	0x5e7e	; 0x5e7e <__mulsf3>
    1050:	9b 01       	movw	r18, r22
    1052:	ac 01       	movw	r20, r24
    1054:	c8 01       	movw	r24, r16
    1056:	b7 01       	movw	r22, r14
    1058:	0e 94 88 2d 	call	0x5b10	; 0x5b10 <__addsf3>
    105c:	0e 94 58 2e 	call	0x5cb0	; 0x5cb0 <__fixsfsi>
    1060:	9b 01       	movw	r18, r22
			}

			if(v_out > 36){v_out = 36;}
    1062:	25 32       	cpi	r18, 0x25	; 37
    1064:	31 05       	cpc	r19, r1
    1066:	1c f0       	brlt	.+6      	; 0x106e <fwdSer_R+0x19a>
    1068:	24 e2       	ldi	r18, 0x24	; 36
    106a:	30 e0       	ldi	r19, 0x00	; 0
    106c:	06 c0       	rjmp	.+12     	; 0x107a <fwdSer_R+0x1a6>
			if(v_out < -36){v_out = -36;}			
    106e:	8f ef       	ldi	r24, 0xFF	; 255
    1070:	2c 3d       	cpi	r18, 0xDC	; 220
    1072:	38 07       	cpc	r19, r24
    1074:	14 f4       	brge	.+4      	; 0x107a <fwdSer_R+0x1a6>
    1076:	2c ed       	ldi	r18, 0xDC	; 220
    1078:	3f ef       	ldi	r19, 0xFF	; 255

			wheel_R(-v_out);
    107a:	88 27       	eor	r24, r24
    107c:	99 27       	eor	r25, r25
    107e:	82 1b       	sub	r24, r18
    1080:	93 0b       	sbc	r25, r19
    1082:	0e 94 be 05 	call	0xb7c	; 0xb7c <wheel_R>

			rprintf("\t%d\n",-RIGHTVel_current);
    1086:	00 d0       	rcall	.+0      	; 0x1088 <fwdSer_R+0x1b4>
    1088:	00 d0       	rcall	.+0      	; 0x108a <fwdSer_R+0x1b6>
    108a:	0f 92       	push	r0
    108c:	ed b7       	in	r30, 0x3d	; 61
    108e:	fe b7       	in	r31, 0x3e	; 62
    1090:	31 96       	adiw	r30, 0x01	; 1
    1092:	81 e0       	ldi	r24, 0x01	; 1
    1094:	ad b7       	in	r26, 0x3d	; 61
    1096:	be b7       	in	r27, 0x3e	; 62
    1098:	11 96       	adiw	r26, 0x01	; 1
    109a:	8c 93       	st	X, r24
    109c:	8f ea       	ldi	r24, 0xAF	; 175
    109e:	91 e0       	ldi	r25, 0x01	; 1
    10a0:	92 83       	std	Z+2, r25	; 0x02
    10a2:	81 83       	std	Z+1, r24	; 0x01
    10a4:	80 91 cf 02 	lds	r24, 0x02CF
    10a8:	90 91 d0 02 	lds	r25, 0x02D0
    10ac:	90 95       	com	r25
    10ae:	81 95       	neg	r24
    10b0:	9f 4f       	sbci	r25, 0xFF	; 255
    10b2:	94 83       	std	Z+4, r25	; 0x04
    10b4:	83 83       	std	Z+3, r24	; 0x03
    10b6:	0e 94 4e 2a 	call	0x549c	; 0x549c <rprintf1RamRom>
			acc_error += error;
    10ba:	60 91 1a 03 	lds	r22, 0x031A
    10be:	70 91 1b 03 	lds	r23, 0x031B
    10c2:	80 91 1c 03 	lds	r24, 0x031C
    10c6:	90 91 1d 03 	lds	r25, 0x031D
    10ca:	a4 01       	movw	r20, r8
    10cc:	93 01       	movw	r18, r6
    10ce:	0e 94 88 2d 	call	0x5b10	; 0x5b10 <__addsf3>
    10d2:	60 93 1a 03 	sts	0x031A, r22
    10d6:	70 93 1b 03 	sts	0x031B, r23
    10da:	80 93 1c 03 	sts	0x031C, r24
    10de:	90 93 1d 03 	sts	0x031D, r25
    10e2:	0f 90       	pop	r0
    10e4:	0f 90       	pop	r0
    10e6:	0f 90       	pop	r0
    10e8:	0f 90       	pop	r0
    10ea:	0f 90       	pop	r0
    10ec:	2e c0       	rjmp	.+92     	; 0x114a <fwdSer_R+0x276>

			//	rprintf("RRR VVV: ");
			//	rprintfu16(RIGHTVel_current);
			//	rprintf("\n");
			}
			else if(d_iter == 8){
    10ee:	80 91 2c 03 	lds	r24, 0x032C
    10f2:	88 30       	cpi	r24, 0x08	; 8
    10f4:	51 f5       	brne	.+84     	; 0x114a <fwdSer_R+0x276>
				RIGHTDis_current = CM_TICK * retConv_s32(&dis_rough);
    10f6:	8e e1       	ldi	r24, 0x1E	; 30
    10f8:	93 e0       	ldi	r25, 0x03	; 3
    10fa:	0e 94 bb 04 	call	0x976	; 0x976 <retConv_s32>
    10fe:	0e 94 8b 2e 	call	0x5d16	; 0x5d16 <__floatsisf>
    1102:	20 e0       	ldi	r18, 0x00	; 0
    1104:	30 e0       	ldi	r19, 0x00	; 0
    1106:	40 e8       	ldi	r20, 0x80	; 128
    1108:	5e e3       	ldi	r21, 0x3E	; 62
    110a:	0e 94 3f 2f 	call	0x5e7e	; 0x5e7e <__mulsf3>
    110e:	0e 94 58 2e 	call	0x5cb0	; 0x5cb0 <__fixsfsi>
    1112:	60 93 d2 02 	sts	0x02D2, r22
    1116:	70 93 d3 02 	sts	0x02D3, r23
    111a:	80 93 d4 02 	sts	0x02D4, r24
    111e:	90 93 d5 02 	sts	0x02D5, r25
				//rprintf("dR: %d\n",dRIGHTDis);
				d_flag = UNSET;
    1122:	10 92 2a 03 	sts	0x032A, r1
				d_iter = 0;
    1126:	10 92 2c 03 	sts	0x032C, r1
    112a:	0f c0       	rjmp	.+30     	; 0x114a <fwdSer_R+0x276>
				//rprintf("\n");
			}
		
		}

		else{rprintf("WR\n");}
    112c:	00 d0       	rcall	.+0      	; 0x112e <fwdSer_R+0x25a>
    112e:	0f 92       	push	r0
    1130:	81 e0       	ldi	r24, 0x01	; 1
    1132:	ed b7       	in	r30, 0x3d	; 61
    1134:	fe b7       	in	r31, 0x3e	; 62
    1136:	81 83       	std	Z+1, r24	; 0x01
    1138:	8b ea       	ldi	r24, 0xAB	; 171
    113a:	91 e0       	ldi	r25, 0x01	; 1
    113c:	93 83       	std	Z+3, r25	; 0x03
    113e:	82 83       	std	Z+2, r24	; 0x02
    1140:	0e 94 4e 2a 	call	0x549c	; 0x549c <rprintf1RamRom>
    1144:	0f 90       	pop	r0
    1146:	0f 90       	pop	r0
    1148:	0f 90       	pop	r0
		//if data couldn't be posted, rprintf a message
		
			//taskYIELD();
	//	}
		
}
    114a:	1f 91       	pop	r17
    114c:	0f 91       	pop	r16
    114e:	ff 90       	pop	r15
    1150:	ef 90       	pop	r14
    1152:	df 90       	pop	r13
    1154:	cf 90       	pop	r12
    1156:	bf 90       	pop	r11
    1158:	af 90       	pop	r10
    115a:	9f 90       	pop	r9
    115c:	8f 90       	pop	r8
    115e:	7f 90       	pop	r7
    1160:	6f 90       	pop	r6
    1162:	08 95       	ret

00001164 <vScript>:
		
	}

}

void vScript(){
    1164:	3f 92       	push	r3
    1166:	4f 92       	push	r4
    1168:	5f 92       	push	r5
    116a:	6f 92       	push	r6
    116c:	7f 92       	push	r7
    116e:	8f 92       	push	r8
    1170:	9f 92       	push	r9
    1172:	af 92       	push	r10
    1174:	bf 92       	push	r11
    1176:	cf 92       	push	r12
    1178:	df 92       	push	r13
    117a:	ef 92       	push	r14
    117c:	ff 92       	push	r15
    117e:	0f 93       	push	r16
    1180:	1f 93       	push	r17
    1182:	df 93       	push	r29
    1184:	cf 93       	push	r28
    1186:	00 d0       	rcall	.+0      	; 0x1188 <vScript+0x24>
    1188:	cd b7       	in	r28, 0x3d	; 61
    118a:	de b7       	in	r29, 0x3e	; 62
	const portTickType xTicksToWait = 10000 / portTICK_RATE_MS;
	portTickType xLastWakeTime;

	for(;;){
		cmd_angle = 0;
    118c:	0f 2e       	mov	r0, r31
    118e:	f0 e0       	ldi	r31, 0x00	; 0
    1190:	af 2e       	mov	r10, r31
    1192:	f0 e0       	ldi	r31, 0x00	; 0
    1194:	bf 2e       	mov	r11, r31
    1196:	f0 e0       	ldi	r31, 0x00	; 0
    1198:	cf 2e       	mov	r12, r31
    119a:	f0 e0       	ldi	r31, 0x00	; 0
    119c:	df 2e       	mov	r13, r31
    119e:	f0 2d       	mov	r31, r0
		rprintf("cmd_angle: ");
    11a0:	33 24       	eor	r3, r3
    11a2:	33 94       	inc	r3
    11a4:	b7 ef       	ldi	r27, 0xF7	; 247
    11a6:	4b 2e       	mov	r4, r27
    11a8:	b0 e0       	ldi	r27, 0x00	; 0
    11aa:	5b 2e       	mov	r5, r27
		rprintfFloat(5, cmd_angle);
		rprintfCRLF();
		vTaskDelayUntil(&xLastWakeTime, xTicksToWait);
    11ac:	4e 01       	movw	r8, r28
    11ae:	08 94       	sec
    11b0:	81 1c       	adc	r8, r1
    11b2:	91 1c       	adc	r9, r1
		cmd_angle = 90*(M_PI/180);
    11b4:	0f 2e       	mov	r0, r31
    11b6:	fb ed       	ldi	r31, 0xDB	; 219
    11b8:	ef 2e       	mov	r14, r31
    11ba:	ff e0       	ldi	r31, 0x0F	; 15
    11bc:	ff 2e       	mov	r15, r31
    11be:	f9 ec       	ldi	r31, 0xC9	; 201
    11c0:	0f 2f       	mov	r16, r31
    11c2:	ff e3       	ldi	r31, 0x3F	; 63
    11c4:	1f 2f       	mov	r17, r31
    11c6:	f0 2d       	mov	r31, r0
		rprintf("cmd_angle: ");
    11c8:	ab ee       	ldi	r26, 0xEB	; 235
    11ca:	6a 2e       	mov	r6, r26
    11cc:	a0 e0       	ldi	r26, 0x00	; 0
    11ce:	7a 2e       	mov	r7, r26
void vScript(){
	const portTickType xTicksToWait = 10000 / portTICK_RATE_MS;
	portTickType xLastWakeTime;

	for(;;){
		cmd_angle = 0;
    11d0:	a0 92 e4 02 	sts	0x02E4, r10
    11d4:	b0 92 e5 02 	sts	0x02E5, r11
    11d8:	c0 92 e6 02 	sts	0x02E6, r12
    11dc:	d0 92 e7 02 	sts	0x02E7, r13
		rprintf("cmd_angle: ");
    11e0:	00 d0       	rcall	.+0      	; 0x11e2 <vScript+0x7e>
    11e2:	0f 92       	push	r0
    11e4:	ed b7       	in	r30, 0x3d	; 61
    11e6:	fe b7       	in	r31, 0x3e	; 62
    11e8:	31 82       	std	Z+1, r3	; 0x01
    11ea:	53 82       	std	Z+3, r5	; 0x03
    11ec:	42 82       	std	Z+2, r4	; 0x02
    11ee:	0e 94 4e 2a 	call	0x549c	; 0x549c <rprintf1RamRom>
		rprintfFloat(5, cmd_angle);
    11f2:	0f 90       	pop	r0
    11f4:	0f 90       	pop	r0
    11f6:	0f 90       	pop	r0
    11f8:	40 91 e4 02 	lds	r20, 0x02E4
    11fc:	50 91 e5 02 	lds	r21, 0x02E5
    1200:	60 91 e6 02 	lds	r22, 0x02E6
    1204:	70 91 e7 02 	lds	r23, 0x02E7
    1208:	85 e0       	ldi	r24, 0x05	; 5
    120a:	0e 94 85 29 	call	0x530a	; 0x530a <rprintfFloat>
		rprintfCRLF();
    120e:	0e 94 8e 28 	call	0x511c	; 0x511c <rprintfCRLF>
		vTaskDelayUntil(&xLastWakeTime, xTicksToWait);
    1212:	c4 01       	movw	r24, r8
    1214:	60 e1       	ldi	r22, 0x10	; 16
    1216:	77 e2       	ldi	r23, 0x27	; 39
    1218:	0e 94 44 16 	call	0x2c88	; 0x2c88 <vTaskDelayUntil>
		cmd_angle = 90*(M_PI/180);
    121c:	e0 92 e4 02 	sts	0x02E4, r14
    1220:	f0 92 e5 02 	sts	0x02E5, r15
    1224:	00 93 e6 02 	sts	0x02E6, r16
    1228:	10 93 e7 02 	sts	0x02E7, r17
		rprintf("cmd_angle: ");
    122c:	00 d0       	rcall	.+0      	; 0x122e <vScript+0xca>
    122e:	0f 92       	push	r0
    1230:	ed b7       	in	r30, 0x3d	; 61
    1232:	fe b7       	in	r31, 0x3e	; 62
    1234:	31 82       	std	Z+1, r3	; 0x01
    1236:	73 82       	std	Z+3, r7	; 0x03
    1238:	62 82       	std	Z+2, r6	; 0x02
    123a:	0e 94 4e 2a 	call	0x549c	; 0x549c <rprintf1RamRom>
		rprintfFloat(5, cmd_angle);
    123e:	0f 90       	pop	r0
    1240:	0f 90       	pop	r0
    1242:	0f 90       	pop	r0
    1244:	40 91 e4 02 	lds	r20, 0x02E4
    1248:	50 91 e5 02 	lds	r21, 0x02E5
    124c:	60 91 e6 02 	lds	r22, 0x02E6
    1250:	70 91 e7 02 	lds	r23, 0x02E7
    1254:	85 e0       	ldi	r24, 0x05	; 5
    1256:	0e 94 85 29 	call	0x530a	; 0x530a <rprintfFloat>
		rprintfCRLF();
    125a:	0e 94 8e 28 	call	0x511c	; 0x511c <rprintfCRLF>
		vTaskDelayUntil(&xLastWakeTime, xTicksToWait);
    125e:	c4 01       	movw	r24, r8
    1260:	60 e1       	ldi	r22, 0x10	; 16
    1262:	77 e2       	ldi	r23, 0x27	; 39
    1264:	0e 94 44 16 	call	0x2c88	; 0x2c88 <vTaskDelayUntil>
    1268:	b3 cf       	rjmp	.-154    	; 0x11d0 <vScript+0x6c>

0000126a <vRampVel>:
	uart3SendByte(r2);
	uart3SendByte(r1);
	uart3SendByte('\n'); //line feed
}

void vRampVel(){
    126a:	af 92       	push	r10
    126c:	bf 92       	push	r11
    126e:	cf 92       	push	r12
    1270:	df 92       	push	r13
    1272:	ef 92       	push	r14
    1274:	ff 92       	push	r15
    1276:	0f 93       	push	r16
    1278:	1f 93       	push	r17
    127a:	df 93       	push	r29
    127c:	cf 93       	push	r28
    127e:	00 d0       	rcall	.+0      	; 0x1280 <vRampVel+0x16>
    1280:	cd b7       	in	r28, 0x3d	; 61
    1282:	de b7       	in	r29, 0x3e	; 62
	const portTickType xTicksToWait = 1000 / portTICK_RATE_MS;
	portTickType xLastWakeTime;
	v_command = 0;
    1284:	80 e0       	ldi	r24, 0x00	; 0
    1286:	90 e0       	ldi	r25, 0x00	; 0
    1288:	a0 e0       	ldi	r26, 0x00	; 0
    128a:	b0 e0       	ldi	r27, 0x00	; 0
    128c:	80 93 b6 02 	sts	0x02B6, r24
    1290:	90 93 b7 02 	sts	0x02B7, r25
    1294:	a0 93 b8 02 	sts	0x02B8, r26
    1298:	b0 93 b9 02 	sts	0x02B9, r27
	inst_cmd_vel = 25;
    129c:	80 e0       	ldi	r24, 0x00	; 0
    129e:	90 e0       	ldi	r25, 0x00	; 0
    12a0:	a8 ec       	ldi	r26, 0xC8	; 200
    12a2:	b1 e4       	ldi	r27, 0x41	; 65
    12a4:	80 93 ba 02 	sts	0x02BA, r24
    12a8:	90 93 bb 02 	sts	0x02BB, r25
    12ac:	a0 93 bc 02 	sts	0x02BC, r26
    12b0:	b0 93 bd 02 	sts	0x02BD, r27
	vTaskDelayUntil(&xLastWakeTime, 10000 / portTICK_RATE_MS);	//leave velocity at zero briefly
    12b4:	8e 01       	movw	r16, r28
    12b6:	0f 5f       	subi	r16, 0xFF	; 255
    12b8:	1f 4f       	sbci	r17, 0xFF	; 255
    12ba:	c8 01       	movw	r24, r16
    12bc:	60 e1       	ldi	r22, 0x10	; 16
    12be:	77 e2       	ldi	r23, 0x27	; 39
    12c0:	0e 94 44 16 	call	0x2c88	; 0x2c88 <vTaskDelayUntil>
}
void PWM_timer3_On_E4(void)
{
	sbi(TCCR3A,COM3B1);
    12c4:	80 91 90 00 	lds	r24, 0x0090
    12c8:	80 62       	ori	r24, 0x20	; 32
    12ca:	80 93 90 00 	sts	0x0090, r24
	cbi(TCCR3A,COM3B0);
    12ce:	80 91 90 00 	lds	r24, 0x0090
    12d2:	8f 7e       	andi	r24, 0xEF	; 239
    12d4:	80 93 90 00 	sts	0x0090, r24
	sbi(TCCR2A,COM2B1);
	cbi(TCCR2A,COM2B0);
}
void PWM_timer3_On_E3(void)
{
	sbi(TCCR3A,COM3A1);
    12d8:	80 91 90 00 	lds	r24, 0x0090
    12dc:	80 68       	ori	r24, 0x80	; 128
    12de:	80 93 90 00 	sts	0x0090, r24
	cbi(TCCR3A,COM3A0);
    12e2:	80 91 90 00 	lds	r24, 0x0090
    12e6:	8f 7b       	andi	r24, 0xBF	; 191
    12e8:	80 93 90 00 	sts	0x0090, r24
	wheel_L_on();
	wheel_R_on();
	wheel_L(25);
    12ec:	89 e1       	ldi	r24, 0x19	; 25
    12ee:	90 e0       	ldi	r25, 0x00	; 0
    12f0:	0e 94 92 05 	call	0xb24	; 0xb24 <wheel_L>
	wheel_R(-25);
    12f4:	87 ee       	ldi	r24, 0xE7	; 231
    12f6:	9f ef       	ldi	r25, 0xFF	; 255
    12f8:	0e 94 be 05 	call	0xb7c	; 0xb7c <wheel_R>
	v_left = v_right = 25;
    12fc:	89 e1       	ldi	r24, 0x19	; 25
    12fe:	90 e0       	ldi	r25, 0x00	; 0
    1300:	90 93 c1 02 	sts	0x02C1, r25
    1304:	80 93 c0 02 	sts	0x02C0, r24
    1308:	90 93 bf 02 	sts	0x02BF, r25
    130c:	80 93 be 02 	sts	0x02BE, r24

	for(;;){
		
		vTaskDelayUntil(&xLastWakeTime, xTicksToWait);
    1310:	58 01       	movw	r10, r16
		//if(v_command != inst_cmd_vel){v_command++;}
		v_command = 25;
    1312:	0f 2e       	mov	r0, r31
    1314:	f0 e0       	ldi	r31, 0x00	; 0
    1316:	ef 2e       	mov	r14, r31
    1318:	f0 e0       	ldi	r31, 0x00	; 0
    131a:	ff 2e       	mov	r15, r31
    131c:	f8 ec       	ldi	r31, 0xC8	; 200
    131e:	0f 2f       	mov	r16, r31
    1320:	f1 e4       	ldi	r31, 0x41	; 65
    1322:	1f 2f       	mov	r17, r31
    1324:	f0 2d       	mov	r31, r0
		v_left = v_right = v_command;
    1326:	89 e1       	ldi	r24, 0x19	; 25
    1328:	c8 2e       	mov	r12, r24
    132a:	d1 2c       	mov	r13, r1
	wheel_R(-25);
	v_left = v_right = 25;

	for(;;){
		
		vTaskDelayUntil(&xLastWakeTime, xTicksToWait);
    132c:	c5 01       	movw	r24, r10
    132e:	68 ee       	ldi	r22, 0xE8	; 232
    1330:	73 e0       	ldi	r23, 0x03	; 3
    1332:	0e 94 44 16 	call	0x2c88	; 0x2c88 <vTaskDelayUntil>
		//if(v_command != inst_cmd_vel){v_command++;}
		v_command = 25;
    1336:	e0 92 b6 02 	sts	0x02B6, r14
    133a:	f0 92 b7 02 	sts	0x02B7, r15
    133e:	00 93 b8 02 	sts	0x02B8, r16
    1342:	10 93 b9 02 	sts	0x02B9, r17
		v_left = v_right = v_command;
    1346:	d0 92 c1 02 	sts	0x02C1, r13
    134a:	c0 92 c0 02 	sts	0x02C0, r12
    134e:	d0 92 bf 02 	sts	0x02BF, r13
    1352:	c0 92 be 02 	sts	0x02BE, r12
		wheel_L(v_left);
    1356:	89 e1       	ldi	r24, 0x19	; 25
    1358:	90 e0       	ldi	r25, 0x00	; 0
    135a:	0e 94 92 05 	call	0xb24	; 0xb24 <wheel_L>
		wheel_R(-v_right);
    135e:	80 91 c0 02 	lds	r24, 0x02C0
    1362:	90 91 c1 02 	lds	r25, 0x02C1
    1366:	90 95       	com	r25
    1368:	81 95       	neg	r24
    136a:	9f 4f       	sbci	r25, 0xFF	; 255
    136c:	0e 94 be 05 	call	0xb7c	; 0xb7c <wheel_R>
    1370:	dd cf       	rjmp	.-70     	; 0x132c <vRampVel+0xc2>

00001372 <vServoOsc>:
	}

}


void vServoOsc(){
    1372:	7f 92       	push	r7
    1374:	8f 92       	push	r8
    1376:	9f 92       	push	r9
    1378:	af 92       	push	r10
    137a:	bf 92       	push	r11
    137c:	cf 92       	push	r12
    137e:	df 92       	push	r13
    1380:	ef 92       	push	r14
    1382:	ff 92       	push	r15
    1384:	0f 93       	push	r16
    1386:	1f 93       	push	r17
    1388:	df 93       	push	r29
    138a:	cf 93       	push	r28
    138c:	00 d0       	rcall	.+0      	; 0x138e <vServoOsc+0x1c>
    138e:	cd b7       	in	r28, 0x3d	; 61
    1390:	de b7       	in	r29, 0x3e	; 62
	sbi(TCCR4A,COM4A1);
	cbi(TCCR4A,COM4A0);
}
void PWM_timer4_On_H4(void)
{
	sbi(TCCR4A,COM4B1);
    1392:	80 91 a0 00 	lds	r24, 0x00A0
    1396:	80 62       	ori	r24, 0x20	; 32
    1398:	80 93 a0 00 	sts	0x00A0, r24
	cbi(TCCR4A,COM4B0);
    139c:	80 91 a0 00 	lds	r24, 0x00A0
    13a0:	8f 7e       	andi	r24, 0xEF	; 239
    13a2:	80 93 a0 00 	sts	0x00A0, r24
	sbi(TCCR3A,COM3C1);
	cbi(TCCR3A,COM3C0);
}
void PWM_timer4_On_H3(void)
{
	sbi(TCCR4A,COM4A1);
    13a6:	80 91 a0 00 	lds	r24, 0x00A0
    13aa:	80 68       	ori	r24, 0x80	; 128
    13ac:	80 93 a0 00 	sts	0x00A0, r24
	cbi(TCCR4A,COM4A0);
    13b0:	80 91 a0 00 	lds	r24, 0x00A0
    13b4:	8f 7b       	andi	r24, 0xBF	; 191
    13b6:	80 93 a0 00 	sts	0x00A0, r24
    13ba:	0a e7       	ldi	r16, 0x7A	; 122
    13bc:	10 e0       	ldi	r17, 0x00	; 0
void PWM_timer3_Set_E5(u16 pwmDuty)
	{OCR3C = pwmDuty;}
void PWM_timer4_Set_H3(u16 pwmDuty)
	{OCR4A = pwmDuty;}
void PWM_timer4_Set_H4(u16 pwmDuty)
	{OCR4B = pwmDuty;}
    13be:	3c ec       	ldi	r19, 0xCC	; 204
    13c0:	83 2e       	mov	r8, r19
    13c2:	91 2c       	mov	r9, r1
		taskENTER_CRITICAL();
	//	PWM_timer3_Set_E3(i);	//right
		PWM_timer4_Set_H3(h3duty);	//left sprayer //originally 204
		PWM_timer4_Set_H4(204);	//right sprayer
		taskEXIT_CRITICAL();
		vTaskDelayUntil(&xLastWakeTime, (spray_time / portTICK_RATE_MS));
    13c4:	5e 01       	movw	r10, r28
    13c6:	08 94       	sec
    13c8:	a1 1c       	adc	r10, r1
    13ca:	b1 1c       	adc	r11, r1
		PWM_timer4_Set_H4(135);	
		taskEXIT_CRITICAL();
		vTaskDelayUntil(&xLastWakeTime, (spray_time / portTICK_RATE_MS));
		*/

		rprintf("%d", h3duty);
    13cc:	77 24       	eor	r7, r7
    13ce:	73 94       	inc	r7
    13d0:	25 e0       	ldi	r18, 0x05	; 5
    13d2:	c2 2e       	mov	r12, r18
    13d4:	21 e0       	ldi	r18, 0x01	; 1
    13d6:	d2 2e       	mov	r13, r18
		//rprintf(",");
		//rprintfNum(10, 5, 1, ' ', LEFTVel_current);
		rprintf("\n");
    13d8:	93 e0       	ldi	r25, 0x03	; 3
    13da:	e9 2e       	mov	r14, r25
    13dc:	91 e0       	ldi	r25, 0x01	; 1
    13de:	f9 2e       	mov	r15, r25
	spray_R_on();
	spray_L_on();
	uint16_t h3duty = 122;

	for(;;){
		if(h3duty > 1023){ h3duty = 0;}
    13e0:	84 e0       	ldi	r24, 0x04	; 4
    13e2:	00 30       	cpi	r16, 0x00	; 0
    13e4:	18 07       	cpc	r17, r24
    13e6:	10 f0       	brcs	.+4      	; 0x13ec <vServoOsc+0x7a>
    13e8:	00 e0       	ldi	r16, 0x00	; 0
    13ea:	10 e0       	ldi	r17, 0x00	; 0
		taskENTER_CRITICAL();
    13ec:	0f b6       	in	r0, 0x3f	; 63
    13ee:	f8 94       	cli
    13f0:	0f 92       	push	r0
void PWM_timer3_Set_E4(u16 pwmDuty)
	{OCR3B = pwmDuty;}
void PWM_timer3_Set_E5(u16 pwmDuty)
	{OCR3C = pwmDuty;}
void PWM_timer4_Set_H3(u16 pwmDuty)
	{OCR4A = pwmDuty;}
    13f2:	10 93 a9 00 	sts	0x00A9, r17
    13f6:	00 93 a8 00 	sts	0x00A8, r16
void PWM_timer4_Set_H4(u16 pwmDuty)
	{OCR4B = pwmDuty;}
    13fa:	90 92 ab 00 	sts	0x00AB, r9
    13fe:	80 92 aa 00 	sts	0x00AA, r8
	//	PWM_timer3_Set_E3(i);	//right
		PWM_timer4_Set_H3(h3duty);	//left sprayer //originally 204
		PWM_timer4_Set_H4(204);	//right sprayer
		taskEXIT_CRITICAL();
    1402:	0f 90       	pop	r0
    1404:	0f be       	out	0x3f, r0	; 63
		vTaskDelayUntil(&xLastWakeTime, (spray_time / portTICK_RATE_MS));
    1406:	60 91 ae 02 	lds	r22, 0x02AE
    140a:	70 91 af 02 	lds	r23, 0x02AF
    140e:	c5 01       	movw	r24, r10
    1410:	0e 94 44 16 	call	0x2c88	; 0x2c88 <vTaskDelayUntil>
		adj = uart1GetByte();
    1414:	0e 94 fb 25 	call	0x4bf6	; 0x4bf6 <uart1GetByte>
		if(adj == 'p'){ h3duty++;;}
    1418:	80 37       	cpi	r24, 0x70	; 112
    141a:	19 f4       	brne	.+6      	; 0x1422 <vServoOsc+0xb0>
    141c:	0f 5f       	subi	r16, 0xFF	; 255
    141e:	1f 4f       	sbci	r17, 0xFF	; 255
    1420:	04 c0       	rjmp	.+8      	; 0x142a <vServoOsc+0xb8>
		else if(adj == 'l'){ h3duty--;}
    1422:	8c 36       	cpi	r24, 0x6C	; 108
    1424:	11 f4       	brne	.+4      	; 0x142a <vServoOsc+0xb8>
    1426:	01 50       	subi	r16, 0x01	; 1
    1428:	10 40       	sbci	r17, 0x00	; 0
		PWM_timer4_Set_H4(135);	
		taskEXIT_CRITICAL();
		vTaskDelayUntil(&xLastWakeTime, (spray_time / portTICK_RATE_MS));
		*/

		rprintf("%d", h3duty);
    142a:	00 d0       	rcall	.+0      	; 0x142c <vServoOsc+0xba>
    142c:	00 d0       	rcall	.+0      	; 0x142e <vServoOsc+0xbc>
    142e:	0f 92       	push	r0
    1430:	ed b7       	in	r30, 0x3d	; 61
    1432:	fe b7       	in	r31, 0x3e	; 62
    1434:	31 96       	adiw	r30, 0x01	; 1
    1436:	ad b7       	in	r26, 0x3d	; 61
    1438:	be b7       	in	r27, 0x3e	; 62
    143a:	11 96       	adiw	r26, 0x01	; 1
    143c:	7c 92       	st	X, r7
    143e:	d2 82       	std	Z+2, r13	; 0x02
    1440:	c1 82       	std	Z+1, r12	; 0x01
    1442:	14 83       	std	Z+4, r17	; 0x04
    1444:	03 83       	std	Z+3, r16	; 0x03
    1446:	0e 94 4e 2a 	call	0x549c	; 0x549c <rprintf1RamRom>
		//rprintf(",");
		//rprintfNum(10, 5, 1, ' ', LEFTVel_current);
		rprintf("\n");
    144a:	0f 90       	pop	r0
    144c:	0f 90       	pop	r0
    144e:	ed b7       	in	r30, 0x3d	; 61
    1450:	fe b7       	in	r31, 0x3e	; 62
    1452:	71 82       	std	Z+1, r7	; 0x01
    1454:	f3 82       	std	Z+3, r15	; 0x03
    1456:	e2 82       	std	Z+2, r14	; 0x02
    1458:	0e 94 4e 2a 	call	0x549c	; 0x549c <rprintf1RamRom>
	
		h3duty++;
    145c:	0f 5f       	subi	r16, 0xFF	; 255
    145e:	1f 4f       	sbci	r17, 0xFF	; 255
    1460:	0f 90       	pop	r0
    1462:	0f 90       	pop	r0
    1464:	0f 90       	pop	r0
    1466:	bc cf       	rjmp	.-136    	; 0x13e0 <vServoOsc+0x6e>

00001468 <vLight1On>:
		PORT_OFF(PORTA, 0);
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
		
	}
}
void vLight1On(void *pvParameters){
    1468:	0f 93       	push	r16
    146a:	1f 93       	push	r17
    146c:	df 93       	push	r29
    146e:	cf 93       	push	r28
    1470:	00 d0       	rcall	.+0      	; 0x1472 <vLight1On+0xa>
    1472:	cd b7       	in	r28, 0x3d	; 61
    1474:	de b7       	in	r29, 0x3e	; 62
	portTickType xLastWakeTime;
	for(;;){
		LED_on();
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
    1476:	8e 01       	movw	r16, r28
    1478:	0f 5f       	subi	r16, 0xFF	; 255
    147a:	1f 4f       	sbci	r17, 0xFF	; 255
//***************STATUS LED**************
//tank test
void LED_off(void)
	{PORT_ON(PORTB,6);}
void LED_on(void)
	{PORT_OFF(PORTB,6);}
    147c:	2e 98       	cbi	0x05, 6	; 5
    147e:	c8 01       	movw	r24, r16
    1480:	62 e3       	ldi	r22, 0x32	; 50
    1482:	70 e0       	ldi	r23, 0x00	; 0
    1484:	0e 94 44 16 	call	0x2c88	; 0x2c88 <vTaskDelayUntil>


//***************STATUS LED**************
//tank test
void LED_off(void)
	{PORT_ON(PORTB,6);}
    1488:	2e 9a       	sbi	0x05, 6	; 5
		LED_off();
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));	}
    148a:	c8 01       	movw	r24, r16
    148c:	62 e3       	ldi	r22, 0x32	; 50
    148e:	70 e0       	ldi	r23, 0x00	; 0
    1490:	0e 94 44 16 	call	0x2c88	; 0x2c88 <vTaskDelayUntil>
    1494:	f3 cf       	rjmp	.-26     	; 0x147c <vLight1On+0x14>

00001496 <vLight0On>:
	}
}



void vLight0On(void *pvParameters){
    1496:	0f 93       	push	r16
    1498:	1f 93       	push	r17
    149a:	df 93       	push	r29
    149c:	cf 93       	push	r28
    149e:	00 d0       	rcall	.+0      	; 0x14a0 <vLight0On+0xa>
    14a0:	cd b7       	in	r28, 0x3d	; 61
    14a2:	de b7       	in	r29, 0x3e	; 62
	portTickType xLastWakeTime;
	for(;;){
		PORT_ON(PORTA, 0);
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
    14a4:	8e 01       	movw	r16, r28
    14a6:	0f 5f       	subi	r16, 0xFF	; 255
    14a8:	1f 4f       	sbci	r17, 0xFF	; 255


void vLight0On(void *pvParameters){
	portTickType xLastWakeTime;
	for(;;){
		PORT_ON(PORTA, 0);
    14aa:	10 9a       	sbi	0x02, 0	; 2
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
    14ac:	c8 01       	movw	r24, r16
    14ae:	62 e3       	ldi	r22, 0x32	; 50
    14b0:	70 e0       	ldi	r23, 0x00	; 0
    14b2:	0e 94 44 16 	call	0x2c88	; 0x2c88 <vTaskDelayUntil>
		//taskYIELD();	
		PORT_OFF(PORTA, 0);
    14b6:	10 98       	cbi	0x02, 0	; 2
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
    14b8:	c8 01       	movw	r24, r16
    14ba:	62 e3       	ldi	r22, 0x32	; 50
    14bc:	70 e0       	ldi	r23, 0x00	; 0
    14be:	0e 94 44 16 	call	0x2c88	; 0x2c88 <vTaskDelayUntil>
    14c2:	f3 cf       	rjmp	.-26     	; 0x14aa <vLight0On+0x14>

000014c4 <vPID_R>:
		vTaskDelayUntil(&xLastWakeTime, (40 / portTICK_RATE_MS));
	}

}

void vPID_R(void* pvParameters){
    14c4:	5f 92       	push	r5
    14c6:	6f 92       	push	r6
    14c8:	7f 92       	push	r7
    14ca:	8f 92       	push	r8
    14cc:	9f 92       	push	r9
    14ce:	af 92       	push	r10
    14d0:	bf 92       	push	r11
    14d2:	cf 92       	push	r12
    14d4:	df 92       	push	r13
    14d6:	ef 92       	push	r14
    14d8:	ff 92       	push	r15
    14da:	0f 93       	push	r16
    14dc:	1f 93       	push	r17
    14de:	df 93       	push	r29
    14e0:	cf 93       	push	r28
    14e2:	00 d0       	rcall	.+0      	; 0x14e4 <vPID_R+0x20>
    14e4:	cd b7       	in	r28, 0x3d	; 61
    14e6:	de b7       	in	r29, 0x3e	; 62
	sbi(TCCR2A,COM2B1);
	cbi(TCCR2A,COM2B0);
}
void PWM_timer3_On_E3(void)
{
	sbi(TCCR3A,COM3A1);
    14e8:	80 91 90 00 	lds	r24, 0x0090
    14ec:	80 68       	ori	r24, 0x80	; 128
    14ee:	80 93 90 00 	sts	0x0090, r24
	cbi(TCCR3A,COM3A0);
    14f2:	80 91 90 00 	lds	r24, 0x0090
    14f6:	8f 7b       	andi	r24, 0xBF	; 191
    14f8:	80 93 90 00 	sts	0x0090, r24
    14fc:	aa 24       	eor	r10, r10
    14fe:	bb 24       	eor	r11, r11
			if(v_out < -36){v_out = -36;}
			
			taskENTER_CRITICAL();
			wheel_R(-v_out);
			taskEXIT_CRITICAL();
			rprintf("\t%d\n",-RIGHTVel_current);
    1500:	55 24       	eor	r5, r5
    1502:	53 94       	inc	r5
    1504:	4c e0       	ldi	r20, 0x0C	; 12
    1506:	64 2e       	mov	r6, r20
    1508:	41 e0       	ldi	r20, 0x01	; 1
    150a:	74 2e       	mov	r7, r20
			acc_error += error;
			
		vTaskDelayUntil(&xLastWakeTime, (40 / portTICK_RATE_MS));
    150c:	4e 01       	movw	r8, r28
    150e:	08 94       	sec
    1510:	81 1c       	adc	r8, r1
    1512:	91 1c       	adc	r9, r1

	char adj;
	for(;;){
			
			
			error = v_right - (-RIGHTVel_current);
    1514:	c0 90 cf 02 	lds	r12, 0x02CF
    1518:	d0 90 d0 02 	lds	r13, 0x02D0
    151c:	80 91 c0 02 	lds	r24, 0x02C0
    1520:	90 91 c1 02 	lds	r25, 0x02C1
    1524:	c8 0e       	add	r12, r24
    1526:	d9 1e       	adc	r13, r25
			v_out = (signed int)(KP*error + KI*acc_error);
    1528:	b5 01       	movw	r22, r10
    152a:	88 27       	eor	r24, r24
    152c:	77 fd       	sbrc	r23, 7
    152e:	80 95       	com	r24
    1530:	98 2f       	mov	r25, r24
    1532:	0e 94 8b 2e 	call	0x5d16	; 0x5d16 <__floatsisf>
    1536:	26 e1       	ldi	r18, 0x16	; 22
    1538:	35 e4       	ldi	r19, 0x45	; 69
    153a:	40 e8       	ldi	r20, 0x80	; 128
    153c:	5c e3       	ldi	r21, 0x3C	; 60
    153e:	0e 94 3f 2f 	call	0x5e7e	; 0x5e7e <__mulsf3>
    1542:	7b 01       	movw	r14, r22
    1544:	8c 01       	movw	r16, r24
    1546:	b6 01       	movw	r22, r12
    1548:	88 27       	eor	r24, r24
    154a:	77 fd       	sbrc	r23, 7
    154c:	80 95       	com	r24
    154e:	98 2f       	mov	r25, r24
    1550:	0e 94 8b 2e 	call	0x5d16	; 0x5d16 <__floatsisf>
    1554:	2d e8       	ldi	r18, 0x8D	; 141
    1556:	30 e9       	ldi	r19, 0x90	; 144
    1558:	48 e0       	ldi	r20, 0x08	; 8
    155a:	5c e3       	ldi	r21, 0x3C	; 60
    155c:	0e 94 3f 2f 	call	0x5e7e	; 0x5e7e <__mulsf3>
    1560:	a8 01       	movw	r20, r16
    1562:	97 01       	movw	r18, r14
    1564:	0e 94 88 2d 	call	0x5b10	; 0x5b10 <__addsf3>
    1568:	0e 94 58 2e 	call	0x5cb0	; 0x5cb0 <__fixsfsi>
    156c:	9b 01       	movw	r18, r22
			//v_out += (signed int)((KP * error) + (KI * acc_error));
			// Anti windup
			if((v_out >= 36) || (v_out <= -36)){
    156e:	cb 01       	movw	r24, r22
    1570:	83 96       	adiw	r24, 0x23	; 35
    1572:	87 34       	cpi	r24, 0x47	; 71
    1574:	91 05       	cpc	r25, r1
    1576:	70 f0       	brcs	.+28     	; 0x1594 <vPID_R+0xd0>
				v_out -= KI*acc_error;
    1578:	b9 01       	movw	r22, r18
    157a:	88 27       	eor	r24, r24
    157c:	77 fd       	sbrc	r23, 7
    157e:	80 95       	com	r24
    1580:	98 2f       	mov	r25, r24
    1582:	0e 94 8b 2e 	call	0x5d16	; 0x5d16 <__floatsisf>
    1586:	a8 01       	movw	r20, r16
    1588:	97 01       	movw	r18, r14
    158a:	0e 94 87 2d 	call	0x5b0e	; 0x5b0e <__subsf3>
    158e:	0e 94 58 2e 	call	0x5cb0	; 0x5cb0 <__fixsfsi>
    1592:	9b 01       	movw	r18, r22
			}
			if(v_out > 36){v_out = 36;}
    1594:	25 32       	cpi	r18, 0x25	; 37
    1596:	31 05       	cpc	r19, r1
    1598:	1c f0       	brlt	.+6      	; 0x15a0 <vPID_R+0xdc>
    159a:	24 e2       	ldi	r18, 0x24	; 36
    159c:	30 e0       	ldi	r19, 0x00	; 0
    159e:	06 c0       	rjmp	.+12     	; 0x15ac <vPID_R+0xe8>
			if(v_out < -36){v_out = -36;}
    15a0:	8f ef       	ldi	r24, 0xFF	; 255
    15a2:	2c 3d       	cpi	r18, 0xDC	; 220
    15a4:	38 07       	cpc	r19, r24
    15a6:	14 f4       	brge	.+4      	; 0x15ac <vPID_R+0xe8>
    15a8:	2c ed       	ldi	r18, 0xDC	; 220
    15aa:	3f ef       	ldi	r19, 0xFF	; 255
			
			taskENTER_CRITICAL();
    15ac:	0f b6       	in	r0, 0x3f	; 63
    15ae:	f8 94       	cli
    15b0:	0f 92       	push	r0
			wheel_R(-v_out);
    15b2:	88 27       	eor	r24, r24
    15b4:	99 27       	eor	r25, r25
    15b6:	82 1b       	sub	r24, r18
    15b8:	93 0b       	sbc	r25, r19
    15ba:	0e 94 be 05 	call	0xb7c	; 0xb7c <wheel_R>
			taskEXIT_CRITICAL();
    15be:	0f 90       	pop	r0
    15c0:	0f be       	out	0x3f, r0	; 63
			rprintf("\t%d\n",-RIGHTVel_current);
    15c2:	00 d0       	rcall	.+0      	; 0x15c4 <vPID_R+0x100>
    15c4:	00 d0       	rcall	.+0      	; 0x15c6 <vPID_R+0x102>
    15c6:	0f 92       	push	r0
    15c8:	ed b7       	in	r30, 0x3d	; 61
    15ca:	fe b7       	in	r31, 0x3e	; 62
    15cc:	31 96       	adiw	r30, 0x01	; 1
    15ce:	ad b7       	in	r26, 0x3d	; 61
    15d0:	be b7       	in	r27, 0x3e	; 62
    15d2:	11 96       	adiw	r26, 0x01	; 1
    15d4:	5c 92       	st	X, r5
    15d6:	72 82       	std	Z+2, r7	; 0x02
    15d8:	61 82       	std	Z+1, r6	; 0x01
    15da:	80 91 cf 02 	lds	r24, 0x02CF
    15de:	90 91 d0 02 	lds	r25, 0x02D0
    15e2:	90 95       	com	r25
    15e4:	81 95       	neg	r24
    15e6:	9f 4f       	sbci	r25, 0xFF	; 255
    15e8:	94 83       	std	Z+4, r25	; 0x04
    15ea:	83 83       	std	Z+3, r24	; 0x03
    15ec:	0e 94 4e 2a 	call	0x549c	; 0x549c <rprintf1RamRom>
			acc_error += error;
    15f0:	ac 0c       	add	r10, r12
    15f2:	bd 1c       	adc	r11, r13
			
		vTaskDelayUntil(&xLastWakeTime, (40 / portTICK_RATE_MS));
    15f4:	0f 90       	pop	r0
    15f6:	0f 90       	pop	r0
    15f8:	0f 90       	pop	r0
    15fa:	0f 90       	pop	r0
    15fc:	0f 90       	pop	r0
    15fe:	c4 01       	movw	r24, r8
    1600:	68 e2       	ldi	r22, 0x28	; 40
    1602:	70 e0       	ldi	r23, 0x00	; 0
    1604:	0e 94 44 16 	call	0x2c88	; 0x2c88 <vTaskDelayUntil>
    1608:	85 cf       	rjmp	.-246    	; 0x1514 <vPID_R+0x50>

0000160a <vPID_L>:
		taskEXIT_CRITICAL();


}

void vPID_L(void* pvParameters){
    160a:	3f 92       	push	r3
    160c:	4f 92       	push	r4
    160e:	5f 92       	push	r5
    1610:	6f 92       	push	r6
    1612:	7f 92       	push	r7
    1614:	8f 92       	push	r8
    1616:	9f 92       	push	r9
    1618:	af 92       	push	r10
    161a:	bf 92       	push	r11
    161c:	cf 92       	push	r12
    161e:	df 92       	push	r13
    1620:	ef 92       	push	r14
    1622:	ff 92       	push	r15
    1624:	0f 93       	push	r16
    1626:	1f 93       	push	r17
    1628:	df 93       	push	r29
    162a:	cf 93       	push	r28
    162c:	cd b7       	in	r28, 0x3d	; 61
    162e:	de b7       	in	r29, 0x3e	; 62
    1630:	2a 97       	sbiw	r28, 0x0a	; 10
    1632:	0f b6       	in	r0, 0x3f	; 63
    1634:	f8 94       	cli
    1636:	de bf       	out	0x3e, r29	; 62
    1638:	0f be       	out	0x3f, r0	; 63
    163a:	cd bf       	out	0x3d, r28	; 61
}
void PWM_timer3_On_E4(void)
{
	sbi(TCCR3A,COM3B1);
    163c:	80 91 90 00 	lds	r24, 0x0090
    1640:	80 62       	ori	r24, 0x20	; 32
    1642:	80 93 90 00 	sts	0x0090, r24
	cbi(TCCR3A,COM3B0);
    1646:	80 91 90 00 	lds	r24, 0x0090
    164a:	8f 7e       	andi	r24, 0xEF	; 239
    164c:	80 93 90 00 	sts	0x0090, r24
    1650:	80 e0       	ldi	r24, 0x00	; 0
    1652:	90 e0       	ldi	r25, 0x00	; 0
    1654:	a0 e0       	ldi	r26, 0x00	; 0
    1656:	b0 e0       	ldi	r27, 0x00	; 0
    1658:	8b 83       	std	Y+3, r24	; 0x03
    165a:	9c 83       	std	Y+4, r25	; 0x04
    165c:	ad 83       	std	Y+5, r26	; 0x05
    165e:	be 83       	std	Y+6, r27	; 0x06
    1660:	0f 2e       	mov	r0, r31
    1662:	fc e4       	ldi	r31, 0x4C	; 76
    1664:	4f 2e       	mov	r4, r31
    1666:	f3 e9       	ldi	r31, 0x93	; 147
    1668:	5f 2e       	mov	r5, r31
    166a:	f9 e1       	ldi	r31, 0x19	; 25
    166c:	6f 2e       	mov	r6, r31
    166e:	fc e3       	ldi	r31, 0x3C	; 60
    1670:	7f 2e       	mov	r7, r31
    1672:	f0 2d       	mov	r31, r0
    1674:	0f 2e       	mov	r0, r31
    1676:	f0 ea       	ldi	r31, 0xA0	; 160
    1678:	8f 2e       	mov	r8, r31
    167a:	f3 e0       	ldi	r31, 0x03	; 3
    167c:	9f 2e       	mov	r9, r31
    167e:	ff eb       	ldi	r31, 0xBF	; 191
    1680:	af 2e       	mov	r10, r31
    1682:	fc e3       	ldi	r31, 0x3C	; 60
    1684:	bf 2e       	mov	r11, r31
    1686:	f0 2d       	mov	r31, r0
			
			
			taskENTER_CRITICAL();
			wheel_L(v_out);
			taskEXIT_CRITICAL();
			rprintf("%d, ",LEFTVel_current);
    1688:	33 24       	eor	r3, r3
    168a:	33 94       	inc	r3

	for(;;){
			
			error = v_left - LEFTVel_current;
			
			v_out = (signed int)(KP*error + KI*acc_error);
    168c:	60 91 be 02 	lds	r22, 0x02BE
    1690:	70 91 bf 02 	lds	r23, 0x02BF
    1694:	20 91 c2 02 	lds	r18, 0x02C2
    1698:	30 91 c3 02 	lds	r19, 0x02C3
    169c:	62 1b       	sub	r22, r18
    169e:	73 0b       	sbc	r23, r19
    16a0:	88 27       	eor	r24, r24
    16a2:	77 fd       	sbrc	r23, 7
    16a4:	80 95       	com	r24
    16a6:	98 2f       	mov	r25, r24
    16a8:	0e 94 8b 2e 	call	0x5d16	; 0x5d16 <__floatsisf>
    16ac:	6f 83       	std	Y+7, r22	; 0x07
    16ae:	78 87       	std	Y+8, r23	; 0x08
    16b0:	89 87       	std	Y+9, r24	; 0x09
    16b2:	9a 87       	std	Y+10, r25	; 0x0a
    16b4:	c5 01       	movw	r24, r10
    16b6:	b4 01       	movw	r22, r8
    16b8:	2b 81       	ldd	r18, Y+3	; 0x03
    16ba:	3c 81       	ldd	r19, Y+4	; 0x04
    16bc:	4d 81       	ldd	r20, Y+5	; 0x05
    16be:	5e 81       	ldd	r21, Y+6	; 0x06
    16c0:	0e 94 3f 2f 	call	0x5e7e	; 0x5e7e <__mulsf3>
    16c4:	6b 01       	movw	r12, r22
    16c6:	7c 01       	movw	r14, r24
    16c8:	c3 01       	movw	r24, r6
    16ca:	b2 01       	movw	r22, r4
    16cc:	2f 81       	ldd	r18, Y+7	; 0x07
    16ce:	38 85       	ldd	r19, Y+8	; 0x08
    16d0:	49 85       	ldd	r20, Y+9	; 0x09
    16d2:	5a 85       	ldd	r21, Y+10	; 0x0a
    16d4:	0e 94 3f 2f 	call	0x5e7e	; 0x5e7e <__mulsf3>
    16d8:	a7 01       	movw	r20, r14
    16da:	96 01       	movw	r18, r12
    16dc:	0e 94 88 2d 	call	0x5b10	; 0x5b10 <__addsf3>
    16e0:	0e 94 58 2e 	call	0x5cb0	; 0x5cb0 <__fixsfsi>
    16e4:	8b 01       	movw	r16, r22
			//v_out += (signed int)((KP * error) + (KI * acc_error));
			// Anti windup
			if((v_out >= 36) || (v_out <= -36)){
    16e6:	cb 01       	movw	r24, r22
    16e8:	83 96       	adiw	r24, 0x23	; 35
    16ea:	87 34       	cpi	r24, 0x47	; 71
    16ec:	91 05       	cpc	r25, r1
    16ee:	70 f0       	brcs	.+28     	; 0x170c <vPID_L+0x102>
				v_out -= KI*acc_error;
    16f0:	b8 01       	movw	r22, r16
    16f2:	88 27       	eor	r24, r24
    16f4:	77 fd       	sbrc	r23, 7
    16f6:	80 95       	com	r24
    16f8:	98 2f       	mov	r25, r24
    16fa:	0e 94 8b 2e 	call	0x5d16	; 0x5d16 <__floatsisf>
    16fe:	a7 01       	movw	r20, r14
    1700:	96 01       	movw	r18, r12
    1702:	0e 94 87 2d 	call	0x5b0e	; 0x5b0e <__subsf3>
    1706:	0e 94 58 2e 	call	0x5cb0	; 0x5cb0 <__fixsfsi>
    170a:	8b 01       	movw	r16, r22
			}
			
			acc_error += error;
    170c:	6b 81       	ldd	r22, Y+3	; 0x03
    170e:	7c 81       	ldd	r23, Y+4	; 0x04
    1710:	8d 81       	ldd	r24, Y+5	; 0x05
    1712:	9e 81       	ldd	r25, Y+6	; 0x06
    1714:	2f 81       	ldd	r18, Y+7	; 0x07
    1716:	38 85       	ldd	r19, Y+8	; 0x08
    1718:	49 85       	ldd	r20, Y+9	; 0x09
    171a:	5a 85       	ldd	r21, Y+10	; 0x0a
    171c:	0e 94 88 2d 	call	0x5b10	; 0x5b10 <__addsf3>
    1720:	6b 83       	std	Y+3, r22	; 0x03
    1722:	7c 83       	std	Y+4, r23	; 0x04
    1724:	8d 83       	std	Y+5, r24	; 0x05
    1726:	9e 83       	std	Y+6, r25	; 0x06

			if(v_out > 36){v_out = 36;}
    1728:	05 32       	cpi	r16, 0x25	; 37
    172a:	11 05       	cpc	r17, r1
    172c:	1c f0       	brlt	.+6      	; 0x1734 <vPID_L+0x12a>
    172e:	04 e2       	ldi	r16, 0x24	; 36
    1730:	10 e0       	ldi	r17, 0x00	; 0
    1732:	06 c0       	rjmp	.+12     	; 0x1740 <vPID_L+0x136>
			if(v_out < -36){v_out = -36;}
    1734:	9f ef       	ldi	r25, 0xFF	; 255
    1736:	0c 3d       	cpi	r16, 0xDC	; 220
    1738:	19 07       	cpc	r17, r25
    173a:	14 f4       	brge	.+4      	; 0x1740 <vPID_L+0x136>
    173c:	0c ed       	ldi	r16, 0xDC	; 220
    173e:	1f ef       	ldi	r17, 0xFF	; 255
			
			
			taskENTER_CRITICAL();
    1740:	0f b6       	in	r0, 0x3f	; 63
    1742:	f8 94       	cli
    1744:	0f 92       	push	r0
			wheel_L(v_out);
    1746:	c8 01       	movw	r24, r16
    1748:	0e 94 92 05 	call	0xb24	; 0xb24 <wheel_L>
			taskEXIT_CRITICAL();
    174c:	0f 90       	pop	r0
    174e:	0f be       	out	0x3f, r0	; 63
			rprintf("%d, ",LEFTVel_current);
    1750:	00 d0       	rcall	.+0      	; 0x1752 <vPID_L+0x148>
    1752:	00 d0       	rcall	.+0      	; 0x1754 <vPID_L+0x14a>
    1754:	0f 92       	push	r0
    1756:	ed b7       	in	r30, 0x3d	; 61
    1758:	fe b7       	in	r31, 0x3e	; 62
    175a:	31 96       	adiw	r30, 0x01	; 1
    175c:	ad b7       	in	r26, 0x3d	; 61
    175e:	be b7       	in	r27, 0x3e	; 62
    1760:	11 96       	adiw	r26, 0x01	; 1
    1762:	3c 92       	st	X, r3
    1764:	8d e6       	ldi	r24, 0x6D	; 109
    1766:	91 e0       	ldi	r25, 0x01	; 1
    1768:	92 83       	std	Z+2, r25	; 0x02
    176a:	81 83       	std	Z+1, r24	; 0x01
    176c:	80 91 c2 02 	lds	r24, 0x02C2
    1770:	90 91 c3 02 	lds	r25, 0x02C3
    1774:	94 83       	std	Z+4, r25	; 0x04
    1776:	83 83       	std	Z+3, r24	; 0x03
    1778:	0e 94 4e 2a 	call	0x549c	; 0x549c <rprintf1RamRom>

			key = uart1GetByte();
    177c:	0f 90       	pop	r0
    177e:	0f 90       	pop	r0
    1780:	0f 90       	pop	r0
    1782:	0f 90       	pop	r0
    1784:	0f 90       	pop	r0
    1786:	0e 94 fb 25 	call	0x4bf6	; 0x4bf6 <uart1GetByte>
			if(key == 'q'){
    178a:	81 37       	cpi	r24, 0x71	; 113
    178c:	a1 f4       	brne	.+40     	; 0x17b6 <vPID_L+0x1ac>
				KP += 0.001;
    178e:	c3 01       	movw	r24, r6
    1790:	b2 01       	movw	r22, r4
    1792:	2f e6       	ldi	r18, 0x6F	; 111
    1794:	32 e1       	ldi	r19, 0x12	; 18
    1796:	43 e8       	ldi	r20, 0x83	; 131
    1798:	5a e3       	ldi	r21, 0x3A	; 58
    179a:	0e 94 88 2d 	call	0x5b10	; 0x5b10 <__addsf3>
    179e:	2b 01       	movw	r4, r22
    17a0:	3c 01       	movw	r6, r24
				rprintf("\tKP: ");
    17a2:	00 d0       	rcall	.+0      	; 0x17a4 <vPID_L+0x19a>
    17a4:	0f 92       	push	r0
    17a6:	ad b7       	in	r26, 0x3d	; 61
    17a8:	be b7       	in	r27, 0x3e	; 62
    17aa:	11 96       	adiw	r26, 0x01	; 1
    17ac:	3c 92       	st	X, r3
    17ae:	11 97       	sbiw	r26, 0x01	; 1
    17b0:	e7 e6       	ldi	r30, 0x67	; 103
    17b2:	f1 e0       	ldi	r31, 0x01	; 1
    17b4:	15 c0       	rjmp	.+42     	; 0x17e0 <vPID_L+0x1d6>
				rprintfFloat(5,KP);
				rprintfCRLF();
			}
			else if (key == 'a'){
    17b6:	81 36       	cpi	r24, 0x61	; 97
    17b8:	21 f5       	brne	.+72     	; 0x1802 <vPID_L+0x1f8>
				KP -= 0.001;
    17ba:	c3 01       	movw	r24, r6
    17bc:	b2 01       	movw	r22, r4
    17be:	2f e6       	ldi	r18, 0x6F	; 111
    17c0:	32 e1       	ldi	r19, 0x12	; 18
    17c2:	43 e8       	ldi	r20, 0x83	; 131
    17c4:	5a e3       	ldi	r21, 0x3A	; 58
    17c6:	0e 94 87 2d 	call	0x5b0e	; 0x5b0e <__subsf3>
    17ca:	2b 01       	movw	r4, r22
    17cc:	3c 01       	movw	r6, r24
				rprintf("\tKP: ");
    17ce:	00 d0       	rcall	.+0      	; 0x17d0 <vPID_L+0x1c6>
    17d0:	0f 92       	push	r0
    17d2:	ad b7       	in	r26, 0x3d	; 61
    17d4:	be b7       	in	r27, 0x3e	; 62
    17d6:	11 96       	adiw	r26, 0x01	; 1
    17d8:	3c 92       	st	X, r3
    17da:	11 97       	sbiw	r26, 0x01	; 1
    17dc:	e1 e6       	ldi	r30, 0x61	; 97
    17de:	f1 e0       	ldi	r31, 0x01	; 1
    17e0:	13 96       	adiw	r26, 0x03	; 3
    17e2:	fc 93       	st	X, r31
    17e4:	ee 93       	st	-X, r30
    17e6:	12 97       	sbiw	r26, 0x02	; 2
    17e8:	0e 94 4e 2a 	call	0x549c	; 0x549c <rprintf1RamRom>
				rprintfFloat(5,KP);
    17ec:	0f 90       	pop	r0
    17ee:	0f 90       	pop	r0
    17f0:	0f 90       	pop	r0
    17f2:	85 e0       	ldi	r24, 0x05	; 5
    17f4:	b3 01       	movw	r22, r6
    17f6:	a2 01       	movw	r20, r4
    17f8:	0e 94 85 29 	call	0x530a	; 0x530a <rprintfFloat>
				rprintfCRLF();
    17fc:	0e 94 8e 28 	call	0x511c	; 0x511c <rprintfCRLF>
    1800:	13 c1       	rjmp	.+550    	; 0x1a28 <vPID_L+0x41e>
			}
			else if (key == 'w'){
    1802:	87 37       	cpi	r24, 0x77	; 119
    1804:	a1 f4       	brne	.+40     	; 0x182e <vPID_L+0x224>
				KI += 0.001;
    1806:	c5 01       	movw	r24, r10
    1808:	b4 01       	movw	r22, r8
    180a:	2f e6       	ldi	r18, 0x6F	; 111
    180c:	32 e1       	ldi	r19, 0x12	; 18
    180e:	43 e8       	ldi	r20, 0x83	; 131
    1810:	5a e3       	ldi	r21, 0x3A	; 58
    1812:	0e 94 88 2d 	call	0x5b10	; 0x5b10 <__addsf3>
    1816:	4b 01       	movw	r8, r22
    1818:	5c 01       	movw	r10, r24
				rprintf("\tKI: ");
    181a:	00 d0       	rcall	.+0      	; 0x181c <vPID_L+0x212>
    181c:	0f 92       	push	r0
    181e:	ad b7       	in	r26, 0x3d	; 61
    1820:	be b7       	in	r27, 0x3e	; 62
    1822:	11 96       	adiw	r26, 0x01	; 1
    1824:	3c 92       	st	X, r3
    1826:	11 97       	sbiw	r26, 0x01	; 1
    1828:	eb e5       	ldi	r30, 0x5B	; 91
    182a:	f1 e0       	ldi	r31, 0x01	; 1
    182c:	15 c0       	rjmp	.+42     	; 0x1858 <vPID_L+0x24e>
				rprintfFloat(5,KI);
				rprintfCRLF();
			}
			else if (key == 's'){
    182e:	83 37       	cpi	r24, 0x73	; 115
    1830:	01 f5       	brne	.+64     	; 0x1872 <vPID_L+0x268>
				KI -= 0.001;
    1832:	c5 01       	movw	r24, r10
    1834:	b4 01       	movw	r22, r8
    1836:	2f e6       	ldi	r18, 0x6F	; 111
    1838:	32 e1       	ldi	r19, 0x12	; 18
    183a:	43 e8       	ldi	r20, 0x83	; 131
    183c:	5a e3       	ldi	r21, 0x3A	; 58
    183e:	0e 94 87 2d 	call	0x5b0e	; 0x5b0e <__subsf3>
    1842:	4b 01       	movw	r8, r22
    1844:	5c 01       	movw	r10, r24
				rprintf("\tKI: ");
    1846:	00 d0       	rcall	.+0      	; 0x1848 <vPID_L+0x23e>
    1848:	0f 92       	push	r0
    184a:	ad b7       	in	r26, 0x3d	; 61
    184c:	be b7       	in	r27, 0x3e	; 62
    184e:	11 96       	adiw	r26, 0x01	; 1
    1850:	3c 92       	st	X, r3
    1852:	11 97       	sbiw	r26, 0x01	; 1
    1854:	e5 e5       	ldi	r30, 0x55	; 85
    1856:	f1 e0       	ldi	r31, 0x01	; 1
    1858:	13 96       	adiw	r26, 0x03	; 3
    185a:	fc 93       	st	X, r31
    185c:	ee 93       	st	-X, r30
    185e:	12 97       	sbiw	r26, 0x02	; 2
    1860:	0e 94 4e 2a 	call	0x549c	; 0x549c <rprintf1RamRom>
				rprintfFloat(5,KI);
    1864:	0f 90       	pop	r0
    1866:	0f 90       	pop	r0
    1868:	0f 90       	pop	r0
    186a:	85 e0       	ldi	r24, 0x05	; 5
    186c:	b5 01       	movw	r22, r10
    186e:	a4 01       	movw	r20, r8
    1870:	c3 cf       	rjmp	.-122    	; 0x17f8 <vPID_L+0x1ee>
				rprintfCRLF();
			}
			else if (key == 'p'){
    1872:	80 37       	cpi	r24, 0x70	; 112
    1874:	09 f0       	breq	.+2      	; 0x1878 <vPID_L+0x26e>
    1876:	65 c0       	rjmp	.+202    	; 0x1942 <vPID_L+0x338>
				rprintf("\tKP: ");
    1878:	00 d0       	rcall	.+0      	; 0x187a <vPID_L+0x270>
    187a:	0f 92       	push	r0
    187c:	ad b7       	in	r26, 0x3d	; 61
    187e:	be b7       	in	r27, 0x3e	; 62
    1880:	11 96       	adiw	r26, 0x01	; 1
    1882:	3c 92       	st	X, r3
    1884:	11 97       	sbiw	r26, 0x01	; 1
    1886:	ef e4       	ldi	r30, 0x4F	; 79
    1888:	f1 e0       	ldi	r31, 0x01	; 1
    188a:	13 96       	adiw	r26, 0x03	; 3
    188c:	fc 93       	st	X, r31
    188e:	ee 93       	st	-X, r30
    1890:	12 97       	sbiw	r26, 0x02	; 2
    1892:	0e 94 4e 2a 	call	0x549c	; 0x549c <rprintf1RamRom>
				rprintfFloat(5,KP);
    1896:	0f 90       	pop	r0
    1898:	0f 90       	pop	r0
    189a:	0f 90       	pop	r0
    189c:	85 e0       	ldi	r24, 0x05	; 5
    189e:	b3 01       	movw	r22, r6
    18a0:	a2 01       	movw	r20, r4
    18a2:	0e 94 85 29 	call	0x530a	; 0x530a <rprintfFloat>
				rprintfCRLF();
    18a6:	0e 94 8e 28 	call	0x511c	; 0x511c <rprintfCRLF>
				rprintf("\tKI: ");
    18aa:	00 d0       	rcall	.+0      	; 0x18ac <vPID_L+0x2a2>
    18ac:	0f 92       	push	r0
    18ae:	ad b7       	in	r26, 0x3d	; 61
    18b0:	be b7       	in	r27, 0x3e	; 62
    18b2:	11 96       	adiw	r26, 0x01	; 1
    18b4:	3c 92       	st	X, r3
    18b6:	11 97       	sbiw	r26, 0x01	; 1
    18b8:	e9 e4       	ldi	r30, 0x49	; 73
    18ba:	f1 e0       	ldi	r31, 0x01	; 1
    18bc:	13 96       	adiw	r26, 0x03	; 3
    18be:	fc 93       	st	X, r31
    18c0:	ee 93       	st	-X, r30
    18c2:	12 97       	sbiw	r26, 0x02	; 2
    18c4:	0e 94 4e 2a 	call	0x549c	; 0x549c <rprintf1RamRom>
				rprintfFloat(5,KI);
    18c8:	0f 90       	pop	r0
    18ca:	0f 90       	pop	r0
    18cc:	0f 90       	pop	r0
    18ce:	85 e0       	ldi	r24, 0x05	; 5
    18d0:	b5 01       	movw	r22, r10
    18d2:	a4 01       	movw	r20, r8
    18d4:	0e 94 85 29 	call	0x530a	; 0x530a <rprintfFloat>
				rprintfCRLF();
    18d8:	0e 94 8e 28 	call	0x511c	; 0x511c <rprintfCRLF>
				rprintf("\terror: ");
    18dc:	00 d0       	rcall	.+0      	; 0x18de <vPID_L+0x2d4>
    18de:	0f 92       	push	r0
    18e0:	ad b7       	in	r26, 0x3d	; 61
    18e2:	be b7       	in	r27, 0x3e	; 62
    18e4:	11 96       	adiw	r26, 0x01	; 1
    18e6:	3c 92       	st	X, r3
    18e8:	11 97       	sbiw	r26, 0x01	; 1
    18ea:	e0 e4       	ldi	r30, 0x40	; 64
    18ec:	f1 e0       	ldi	r31, 0x01	; 1
    18ee:	13 96       	adiw	r26, 0x03	; 3
    18f0:	fc 93       	st	X, r31
    18f2:	ee 93       	st	-X, r30
    18f4:	12 97       	sbiw	r26, 0x02	; 2
    18f6:	0e 94 4e 2a 	call	0x549c	; 0x549c <rprintf1RamRom>
				rprintfFloat(5,error);
    18fa:	0f 90       	pop	r0
    18fc:	0f 90       	pop	r0
    18fe:	0f 90       	pop	r0
    1900:	85 e0       	ldi	r24, 0x05	; 5
    1902:	4f 81       	ldd	r20, Y+7	; 0x07
    1904:	58 85       	ldd	r21, Y+8	; 0x08
    1906:	69 85       	ldd	r22, Y+9	; 0x09
    1908:	7a 85       	ldd	r23, Y+10	; 0x0a
    190a:	0e 94 85 29 	call	0x530a	; 0x530a <rprintfFloat>
				rprintfCRLF();
    190e:	0e 94 8e 28 	call	0x511c	; 0x511c <rprintfCRLF>
				rprintf("\tacc_error: ");
    1912:	00 d0       	rcall	.+0      	; 0x1914 <vPID_L+0x30a>
    1914:	0f 92       	push	r0
    1916:	ad b7       	in	r26, 0x3d	; 61
    1918:	be b7       	in	r27, 0x3e	; 62
    191a:	11 96       	adiw	r26, 0x01	; 1
    191c:	3c 92       	st	X, r3
    191e:	11 97       	sbiw	r26, 0x01	; 1
    1920:	e3 e3       	ldi	r30, 0x33	; 51
    1922:	f1 e0       	ldi	r31, 0x01	; 1
    1924:	13 96       	adiw	r26, 0x03	; 3
    1926:	fc 93       	st	X, r31
    1928:	ee 93       	st	-X, r30
    192a:	12 97       	sbiw	r26, 0x02	; 2
    192c:	0e 94 4e 2a 	call	0x549c	; 0x549c <rprintf1RamRom>
				rprintfFloat(5,acc_error);
    1930:	0f 90       	pop	r0
    1932:	0f 90       	pop	r0
    1934:	0f 90       	pop	r0
    1936:	85 e0       	ldi	r24, 0x05	; 5
    1938:	4b 81       	ldd	r20, Y+3	; 0x03
    193a:	5c 81       	ldd	r21, Y+4	; 0x04
    193c:	6d 81       	ldd	r22, Y+5	; 0x05
    193e:	7e 81       	ldd	r23, Y+6	; 0x06
    1940:	5b cf       	rjmp	.-330    	; 0x17f8 <vPID_L+0x1ee>
				rprintfCRLF();
			}
			else if(key == 'r'){
    1942:	82 37       	cpi	r24, 0x72	; 114
    1944:	09 f0       	breq	.+2      	; 0x1948 <vPID_L+0x33e>
    1946:	70 c0       	rjmp	.+224    	; 0x1a28 <vPID_L+0x41e>
				acc_error = 0;
				rprintf("\tKP: ");
    1948:	00 d0       	rcall	.+0      	; 0x194a <vPID_L+0x340>
    194a:	0f 92       	push	r0
    194c:	ad b7       	in	r26, 0x3d	; 61
    194e:	be b7       	in	r27, 0x3e	; 62
    1950:	11 96       	adiw	r26, 0x01	; 1
    1952:	3c 92       	st	X, r3
    1954:	11 97       	sbiw	r26, 0x01	; 1
    1956:	ed e2       	ldi	r30, 0x2D	; 45
    1958:	f1 e0       	ldi	r31, 0x01	; 1
    195a:	13 96       	adiw	r26, 0x03	; 3
    195c:	fc 93       	st	X, r31
    195e:	ee 93       	st	-X, r30
    1960:	12 97       	sbiw	r26, 0x02	; 2
    1962:	0e 94 4e 2a 	call	0x549c	; 0x549c <rprintf1RamRom>
				rprintfFloat(5,KP);
    1966:	0f 90       	pop	r0
    1968:	0f 90       	pop	r0
    196a:	0f 90       	pop	r0
    196c:	85 e0       	ldi	r24, 0x05	; 5
    196e:	b3 01       	movw	r22, r6
    1970:	a2 01       	movw	r20, r4
    1972:	0e 94 85 29 	call	0x530a	; 0x530a <rprintfFloat>
				rprintfCRLF();
    1976:	0e 94 8e 28 	call	0x511c	; 0x511c <rprintfCRLF>
				rprintf("\tKI: ");
    197a:	00 d0       	rcall	.+0      	; 0x197c <vPID_L+0x372>
    197c:	0f 92       	push	r0
    197e:	ad b7       	in	r26, 0x3d	; 61
    1980:	be b7       	in	r27, 0x3e	; 62
    1982:	11 96       	adiw	r26, 0x01	; 1
    1984:	3c 92       	st	X, r3
    1986:	11 97       	sbiw	r26, 0x01	; 1
    1988:	e7 e2       	ldi	r30, 0x27	; 39
    198a:	f1 e0       	ldi	r31, 0x01	; 1
    198c:	13 96       	adiw	r26, 0x03	; 3
    198e:	fc 93       	st	X, r31
    1990:	ee 93       	st	-X, r30
    1992:	12 97       	sbiw	r26, 0x02	; 2
    1994:	0e 94 4e 2a 	call	0x549c	; 0x549c <rprintf1RamRom>
				rprintfFloat(5,KI);
    1998:	0f 90       	pop	r0
    199a:	0f 90       	pop	r0
    199c:	0f 90       	pop	r0
    199e:	85 e0       	ldi	r24, 0x05	; 5
    19a0:	b5 01       	movw	r22, r10
    19a2:	a4 01       	movw	r20, r8
    19a4:	0e 94 85 29 	call	0x530a	; 0x530a <rprintfFloat>
				rprintfCRLF();
    19a8:	0e 94 8e 28 	call	0x511c	; 0x511c <rprintfCRLF>
				rprintf("\terror: ");
    19ac:	00 d0       	rcall	.+0      	; 0x19ae <vPID_L+0x3a4>
    19ae:	0f 92       	push	r0
    19b0:	ad b7       	in	r26, 0x3d	; 61
    19b2:	be b7       	in	r27, 0x3e	; 62
    19b4:	11 96       	adiw	r26, 0x01	; 1
    19b6:	3c 92       	st	X, r3
    19b8:	11 97       	sbiw	r26, 0x01	; 1
    19ba:	ee e1       	ldi	r30, 0x1E	; 30
    19bc:	f1 e0       	ldi	r31, 0x01	; 1
    19be:	13 96       	adiw	r26, 0x03	; 3
    19c0:	fc 93       	st	X, r31
    19c2:	ee 93       	st	-X, r30
    19c4:	12 97       	sbiw	r26, 0x02	; 2
    19c6:	0e 94 4e 2a 	call	0x549c	; 0x549c <rprintf1RamRom>
				rprintfFloat(5,error);
    19ca:	0f 90       	pop	r0
    19cc:	0f 90       	pop	r0
    19ce:	0f 90       	pop	r0
    19d0:	85 e0       	ldi	r24, 0x05	; 5
    19d2:	4f 81       	ldd	r20, Y+7	; 0x07
    19d4:	58 85       	ldd	r21, Y+8	; 0x08
    19d6:	69 85       	ldd	r22, Y+9	; 0x09
    19d8:	7a 85       	ldd	r23, Y+10	; 0x0a
    19da:	0e 94 85 29 	call	0x530a	; 0x530a <rprintfFloat>
				rprintfCRLF();
    19de:	0e 94 8e 28 	call	0x511c	; 0x511c <rprintfCRLF>
				rprintf("\tacc_error: ");
    19e2:	00 d0       	rcall	.+0      	; 0x19e4 <vPID_L+0x3da>
    19e4:	0f 92       	push	r0
    19e6:	ad b7       	in	r26, 0x3d	; 61
    19e8:	be b7       	in	r27, 0x3e	; 62
    19ea:	11 96       	adiw	r26, 0x01	; 1
    19ec:	3c 92       	st	X, r3
    19ee:	11 97       	sbiw	r26, 0x01	; 1
    19f0:	e1 e1       	ldi	r30, 0x11	; 17
    19f2:	f1 e0       	ldi	r31, 0x01	; 1
    19f4:	13 96       	adiw	r26, 0x03	; 3
    19f6:	fc 93       	st	X, r31
    19f8:	ee 93       	st	-X, r30
    19fa:	12 97       	sbiw	r26, 0x02	; 2
    19fc:	0e 94 4e 2a 	call	0x549c	; 0x549c <rprintf1RamRom>
				rprintfFloat(5,acc_error);
    1a00:	0f 90       	pop	r0
    1a02:	0f 90       	pop	r0
    1a04:	0f 90       	pop	r0
    1a06:	85 e0       	ldi	r24, 0x05	; 5
    1a08:	40 e0       	ldi	r20, 0x00	; 0
    1a0a:	50 e0       	ldi	r21, 0x00	; 0
    1a0c:	60 e0       	ldi	r22, 0x00	; 0
    1a0e:	70 e0       	ldi	r23, 0x00	; 0
    1a10:	0e 94 85 29 	call	0x530a	; 0x530a <rprintfFloat>
				rprintfCRLF();
    1a14:	0e 94 8e 28 	call	0x511c	; 0x511c <rprintfCRLF>
    1a18:	80 e0       	ldi	r24, 0x00	; 0
    1a1a:	90 e0       	ldi	r25, 0x00	; 0
    1a1c:	a0 e0       	ldi	r26, 0x00	; 0
    1a1e:	b0 e0       	ldi	r27, 0x00	; 0
    1a20:	8b 83       	std	Y+3, r24	; 0x03
    1a22:	9c 83       	std	Y+4, r25	; 0x04
    1a24:	ad 83       	std	Y+5, r26	; 0x05
    1a26:	be 83       	std	Y+6, r27	; 0x06
			}
		vTaskDelayUntil(&xLastWakeTime, (40 / portTICK_RATE_MS));
    1a28:	ce 01       	movw	r24, r28
    1a2a:	01 96       	adiw	r24, 0x01	; 1
    1a2c:	68 e2       	ldi	r22, 0x28	; 40
    1a2e:	70 e0       	ldi	r23, 0x00	; 0
    1a30:	0e 94 44 16 	call	0x2c88	; 0x2c88 <vTaskDelayUntil>
    1a34:	2b ce       	rjmp	.-938    	; 0x168c <vPID_L+0x82>

00001a36 <vEnc_UpdatePose>:
		//rprintf("RIGHTVel_current: %d\n",RIGHTVel_current);
	
	}
}

void vEnc_UpdatePose(){
    1a36:	ef 92       	push	r14
    1a38:	ff 92       	push	r15
    1a3a:	0f 93       	push	r16
    1a3c:	1f 93       	push	r17

	for(;;){
		
		//The below formula yields the encoder calculated angular velocity of the robot
		//as it rotates about some ICC(Instantaneous Center of Curvature)
		reset_timer0();
    1a3e:	0e 94 82 1c 	call	0x3904	; 0x3904 <reset_timer0>
		enc_ang_vel = ((-RIGHTVel_current) - LEFTVel_current) / ROBOT_DIAMETER;
    1a42:	60 91 cf 02 	lds	r22, 0x02CF
    1a46:	70 91 d0 02 	lds	r23, 0x02D0
    1a4a:	70 95       	com	r23
    1a4c:	61 95       	neg	r22
    1a4e:	7f 4f       	sbci	r23, 0xFF	; 255
    1a50:	20 91 c2 02 	lds	r18, 0x02C2
    1a54:	30 91 c3 02 	lds	r19, 0x02C3
    1a58:	62 1b       	sub	r22, r18
    1a5a:	73 0b       	sbc	r23, r19
    1a5c:	88 27       	eor	r24, r24
    1a5e:	77 fd       	sbrc	r23, 7
    1a60:	80 95       	com	r24
    1a62:	98 2f       	mov	r25, r24
    1a64:	0e 94 8b 2e 	call	0x5d16	; 0x5d16 <__floatsisf>
    1a68:	26 e6       	ldi	r18, 0x66	; 102
    1a6a:	36 e6       	ldi	r19, 0x66	; 102
    1a6c:	46 e8       	ldi	r20, 0x86	; 134
    1a6e:	51 e4       	ldi	r21, 0x41	; 65
    1a70:	0e 94 f0 2d 	call	0x5be0	; 0x5be0 <__divsf3>
    1a74:	60 93 e0 02 	sts	0x02E0, r22
    1a78:	70 93 e1 02 	sts	0x02E1, r23
    1a7c:	80 93 e2 02 	sts	0x02E2, r24
    1a80:	90 93 e3 02 	sts	0x02E3, r25
		elapsed_time = ((get_timer0_overflow()*255 + TCNT0) * 0.256) / 1000;
    1a84:	0e 94 23 1c 	call	0x3846	; 0x3846 <get_timer0_overflow>
    1a88:	16 b5       	in	r17, 0x26	; 38
		//dRL = dRIGHTDis - dLEFTDis;
		//dis_enc_heading += sin((dRL)/ ROBOT_DIAMETER);
		//dRIGHTDis = dLEFTDis = 0;
		enc_heading += enc_ang_vel * elapsed_time;
    1a8a:	2f ef       	ldi	r18, 0xFF	; 255
    1a8c:	30 e0       	ldi	r19, 0x00	; 0
    1a8e:	40 e0       	ldi	r20, 0x00	; 0
    1a90:	50 e0       	ldi	r21, 0x00	; 0
    1a92:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <__mulsi3>
    1a96:	61 0f       	add	r22, r17
    1a98:	71 1d       	adc	r23, r1
    1a9a:	81 1d       	adc	r24, r1
    1a9c:	91 1d       	adc	r25, r1
    1a9e:	0e 94 89 2e 	call	0x5d12	; 0x5d12 <__floatunsisf>
    1aa2:	2f e6       	ldi	r18, 0x6F	; 111
    1aa4:	32 e1       	ldi	r19, 0x12	; 18
    1aa6:	43 e8       	ldi	r20, 0x83	; 131
    1aa8:	5e e3       	ldi	r21, 0x3E	; 62
    1aaa:	0e 94 3f 2f 	call	0x5e7e	; 0x5e7e <__mulsf3>
    1aae:	20 e0       	ldi	r18, 0x00	; 0
    1ab0:	30 e0       	ldi	r19, 0x00	; 0
    1ab2:	4a e7       	ldi	r20, 0x7A	; 122
    1ab4:	54 e4       	ldi	r21, 0x44	; 68
    1ab6:	0e 94 f0 2d 	call	0x5be0	; 0x5be0 <__divsf3>
    1aba:	20 91 e0 02 	lds	r18, 0x02E0
    1abe:	30 91 e1 02 	lds	r19, 0x02E1
    1ac2:	40 91 e2 02 	lds	r20, 0x02E2
    1ac6:	50 91 e3 02 	lds	r21, 0x02E3
    1aca:	0e 94 3f 2f 	call	0x5e7e	; 0x5e7e <__mulsf3>
    1ace:	20 91 dc 02 	lds	r18, 0x02DC
    1ad2:	30 91 dd 02 	lds	r19, 0x02DD
    1ad6:	40 91 de 02 	lds	r20, 0x02DE
    1ada:	50 91 df 02 	lds	r21, 0x02DF
    1ade:	0e 94 88 2d 	call	0x5b10	; 0x5b10 <__addsf3>
    1ae2:	9b 01       	movw	r18, r22
    1ae4:	ac 01       	movw	r20, r24
    1ae6:	60 93 dc 02 	sts	0x02DC, r22
    1aea:	70 93 dd 02 	sts	0x02DD, r23
    1aee:	80 93 de 02 	sts	0x02DE, r24
    1af2:	90 93 df 02 	sts	0x02DF, r25
		cmd_ang_vel = pow(cmd_angle - enc_heading,2)/(pow(cmd_angle - enc_heading,2) + pow(3,2));
    1af6:	60 91 e4 02 	lds	r22, 0x02E4
    1afa:	70 91 e5 02 	lds	r23, 0x02E5
    1afe:	80 91 e6 02 	lds	r24, 0x02E6
    1b02:	90 91 e7 02 	lds	r25, 0x02E7
    1b06:	0e 94 87 2d 	call	0x5b0e	; 0x5b0e <__subsf3>
    1b0a:	9b 01       	movw	r18, r22
    1b0c:	ac 01       	movw	r20, r24
    1b0e:	0e 94 3f 2f 	call	0x5e7e	; 0x5e7e <__mulsf3>
    1b12:	7b 01       	movw	r14, r22
    1b14:	8c 01       	movw	r16, r24
    1b16:	c8 01       	movw	r24, r16
    1b18:	b7 01       	movw	r22, r14
    1b1a:	20 e0       	ldi	r18, 0x00	; 0
    1b1c:	30 e0       	ldi	r19, 0x00	; 0
    1b1e:	40 e1       	ldi	r20, 0x10	; 16
    1b20:	51 e4       	ldi	r21, 0x41	; 65
    1b22:	0e 94 88 2d 	call	0x5b10	; 0x5b10 <__addsf3>
    1b26:	9b 01       	movw	r18, r22
    1b28:	ac 01       	movw	r20, r24
    1b2a:	c8 01       	movw	r24, r16
    1b2c:	b7 01       	movw	r22, r14
    1b2e:	0e 94 f0 2d 	call	0x5be0	; 0x5be0 <__divsf3>
    1b32:	60 93 e8 02 	sts	0x02E8, r22
    1b36:	70 93 e9 02 	sts	0x02E9, r23
    1b3a:	80 93 ea 02 	sts	0x02EA, r24
    1b3e:	90 93 eb 02 	sts	0x02EB, r25
    1b42:	7d cf       	rjmp	.-262    	; 0x1a3e <vEnc_UpdatePose+0x8>

00001b44 <send_frame>:
	}
	return c;
}


void send_frame(char flag, int16_t data){
    1b44:	ff 92       	push	r15
    1b46:	0f 93       	push	r16
    1b48:	1f 93       	push	r17
    1b4a:	cf 93       	push	r28
    1b4c:	df 93       	push	r29
    1b4e:	eb 01       	movw	r28, r22
	uint8_t r1 = 0;
	uint8_t r2 = 0;
	uint8_t r3 = 0;
	uint8_t r4 = 0;

	uart3SendByte(flag);
    1b50:	0e 94 43 23 	call	0x4686	; 0x4686 <uart3SendByte>

	r1 = num2char(0x0F & (uint8_t)data);
    1b54:	ef e0       	ldi	r30, 0x0F	; 15
    1b56:	fe 2e       	mov	r15, r30
    1b58:	fc 22       	and	r15, r28



char num2char(char c){
	
	if(c <10){
    1b5a:	89 e0       	ldi	r24, 0x09	; 9
    1b5c:	8f 15       	cp	r24, r15
    1b5e:	18 f0       	brcs	.+6      	; 0x1b66 <send_frame+0x22>
		c += 48;
    1b60:	90 e3       	ldi	r25, 0x30	; 48
    1b62:	f9 0e       	add	r15, r25
    1b64:	06 c0       	rjmp	.+12     	; 0x1b72 <send_frame+0x2e>
	}
	else if((c >= 10) && (c <= 16)){
    1b66:	8f 2d       	mov	r24, r15
    1b68:	8a 50       	subi	r24, 0x0A	; 10
    1b6a:	87 30       	cpi	r24, 0x07	; 7
    1b6c:	10 f4       	brcc	.+4      	; 0x1b72 <send_frame+0x2e>
		c += 55;
    1b6e:	87 e3       	ldi	r24, 0x37	; 55
    1b70:	f8 0e       	add	r15, r24
	uint8_t r4 = 0;

	uart3SendByte(flag);

	r1 = num2char(0x0F & (uint8_t)data);
	r2 = num2char(0x0F & ((uint8_t)(data >> 4)) );
    1b72:	ce 01       	movw	r24, r28
    1b74:	74 e0       	ldi	r23, 0x04	; 4
    1b76:	95 95       	asr	r25
    1b78:	87 95       	ror	r24
    1b7a:	7a 95       	dec	r23
    1b7c:	e1 f7       	brne	.-8      	; 0x1b76 <send_frame+0x32>
    1b7e:	08 2f       	mov	r16, r24
    1b80:	0f 70       	andi	r16, 0x0F	; 15



char num2char(char c){
	
	if(c <10){
    1b82:	0a 30       	cpi	r16, 0x0A	; 10
    1b84:	10 f4       	brcc	.+4      	; 0x1b8a <send_frame+0x46>
		c += 48;
    1b86:	00 5d       	subi	r16, 0xD0	; 208
    1b88:	05 c0       	rjmp	.+10     	; 0x1b94 <send_frame+0x50>
	}
	else if((c >= 10) && (c <= 16)){
    1b8a:	80 2f       	mov	r24, r16
    1b8c:	8a 50       	subi	r24, 0x0A	; 10
    1b8e:	87 30       	cpi	r24, 0x07	; 7
    1b90:	08 f4       	brcc	.+2      	; 0x1b94 <send_frame+0x50>
		c += 55;
    1b92:	09 5c       	subi	r16, 0xC9	; 201

	uart3SendByte(flag);

	r1 = num2char(0x0F & (uint8_t)data);
	r2 = num2char(0x0F & ((uint8_t)(data >> 4)) );
	r3 = num2char(0x0F & ((uint8_t)(data >> 8)) );
    1b94:	8d 2f       	mov	r24, r29
    1b96:	99 27       	eor	r25, r25
    1b98:	87 fd       	sbrc	r24, 7
    1b9a:	9a 95       	dec	r25
    1b9c:	18 2f       	mov	r17, r24
    1b9e:	1f 70       	andi	r17, 0x0F	; 15



char num2char(char c){
	
	if(c <10){
    1ba0:	1a 30       	cpi	r17, 0x0A	; 10
    1ba2:	10 f4       	brcc	.+4      	; 0x1ba8 <send_frame+0x64>
		c += 48;
    1ba4:	10 5d       	subi	r17, 0xD0	; 208
    1ba6:	05 c0       	rjmp	.+10     	; 0x1bb2 <send_frame+0x6e>
	}
	else if((c >= 10) && (c <= 16)){
    1ba8:	81 2f       	mov	r24, r17
    1baa:	8a 50       	subi	r24, 0x0A	; 10
    1bac:	87 30       	cpi	r24, 0x07	; 7
    1bae:	08 f4       	brcc	.+2      	; 0x1bb2 <send_frame+0x6e>
		c += 55;
    1bb0:	19 5c       	subi	r17, 0xC9	; 201
	uart3SendByte(flag);

	r1 = num2char(0x0F & (uint8_t)data);
	r2 = num2char(0x0F & ((uint8_t)(data >> 4)) );
	r3 = num2char(0x0F & ((uint8_t)(data >> 8)) );
	r4 = num2char(0x0F & ((uint8_t)(data >> 12)) );
    1bb2:	c0 e1       	ldi	r28, 0x10	; 16
    1bb4:	dc 02       	muls	r29, r28
    1bb6:	c1 2d       	mov	r28, r1
    1bb8:	dd 0b       	sbc	r29, r29
    1bba:	11 24       	eor	r1, r1
    1bbc:	ce 01       	movw	r24, r28
    1bbe:	8f 70       	andi	r24, 0x0F	; 15
    1bc0:	68 2f       	mov	r22, r24



char num2char(char c){
	
	if(c <10){
    1bc2:	8a 30       	cpi	r24, 0x0A	; 10
    1bc4:	10 f4       	brcc	.+4      	; 0x1bca <send_frame+0x86>
		c += 48;
    1bc6:	60 5d       	subi	r22, 0xD0	; 208
    1bc8:	04 c0       	rjmp	.+8      	; 0x1bd2 <send_frame+0x8e>
	}
	else if((c >= 10) && (c <= 16)){
    1bca:	8a 50       	subi	r24, 0x0A	; 10
    1bcc:	87 30       	cpi	r24, 0x07	; 7
    1bce:	08 f4       	brcc	.+2      	; 0x1bd2 <send_frame+0x8e>
		c += 55;
    1bd0:	69 5c       	subi	r22, 0xC9	; 201
	r1 = num2char(0x0F & (uint8_t)data);
	r2 = num2char(0x0F & ((uint8_t)(data >> 4)) );
	r3 = num2char(0x0F & ((uint8_t)(data >> 8)) );
	r4 = num2char(0x0F & ((uint8_t)(data >> 12)) );

	uart3SendByte(r4);
    1bd2:	86 2f       	mov	r24, r22
    1bd4:	0e 94 43 23 	call	0x4686	; 0x4686 <uart3SendByte>
	uart3SendByte(r3);
    1bd8:	81 2f       	mov	r24, r17
    1bda:	0e 94 43 23 	call	0x4686	; 0x4686 <uart3SendByte>
	uart3SendByte(r2);
    1bde:	80 2f       	mov	r24, r16
    1be0:	0e 94 43 23 	call	0x4686	; 0x4686 <uart3SendByte>
	uart3SendByte(r1);
    1be4:	8f 2d       	mov	r24, r15
    1be6:	0e 94 43 23 	call	0x4686	; 0x4686 <uart3SendByte>
	uart3SendByte('\n'); //line feed
    1bea:	8a e0       	ldi	r24, 0x0A	; 10
    1bec:	0e 94 43 23 	call	0x4686	; 0x4686 <uart3SendByte>
}
    1bf0:	df 91       	pop	r29
    1bf2:	cf 91       	pop	r28
    1bf4:	1f 91       	pop	r17
    1bf6:	0f 91       	pop	r16
    1bf8:	ff 90       	pop	r15
    1bfa:	08 95       	ret

00001bfc <vUpdatePose>:
		*/

	}
}

void vUpdatePose(){
    1bfc:	6f 92       	push	r6
    1bfe:	7f 92       	push	r7
    1c00:	8f 92       	push	r8
    1c02:	9f 92       	push	r9
    1c04:	af 92       	push	r10
    1c06:	bf 92       	push	r11
    1c08:	cf 92       	push	r12
    1c0a:	df 92       	push	r13
    1c0c:	ef 92       	push	r14
    1c0e:	ff 92       	push	r15
    1c10:	0f 93       	push	r16
    1c12:	1f 93       	push	r17
	s16 dDis;
	float CMD_K = 0.5;
	float COR_K = 1;

	for(;;){
		robot.heading = (180 * enc_heading) / M_PI; 
    1c14:	60 91 dc 02 	lds	r22, 0x02DC
    1c18:	70 91 dd 02 	lds	r23, 0x02DD
    1c1c:	80 91 de 02 	lds	r24, 0x02DE
    1c20:	90 91 df 02 	lds	r25, 0x02DF
    1c24:	20 e0       	ldi	r18, 0x00	; 0
    1c26:	30 e0       	ldi	r19, 0x00	; 0
    1c28:	44 e3       	ldi	r20, 0x34	; 52
    1c2a:	53 e4       	ldi	r21, 0x43	; 67
    1c2c:	0e 94 3f 2f 	call	0x5e7e	; 0x5e7e <__mulsf3>
    1c30:	2b ed       	ldi	r18, 0xDB	; 219
    1c32:	3f e0       	ldi	r19, 0x0F	; 15
    1c34:	49 e4       	ldi	r20, 0x49	; 73
    1c36:	50 e4       	ldi	r21, 0x40	; 64
    1c38:	0e 94 f0 2d 	call	0x5be0	; 0x5be0 <__divsf3>
    1c3c:	3b 01       	movw	r6, r22
    1c3e:	4c 01       	movw	r8, r24
    1c40:	60 93 49 12 	sts	0x1249, r22
    1c44:	70 93 4a 12 	sts	0x124A, r23
    1c48:	80 93 4b 12 	sts	0x124B, r24
    1c4c:	90 93 4c 12 	sts	0x124C, r25
		//v_offset = (0.5 * robot.heading) + CMD_K*cmd_angle + COR_K*correction_angle;
		v_left = (signed int)(v_command - cmd_ang_vel*ROBOT_RADIUS);
    1c50:	a0 90 b6 02 	lds	r10, 0x02B6
    1c54:	b0 90 b7 02 	lds	r11, 0x02B7
    1c58:	c0 90 b8 02 	lds	r12, 0x02B8
    1c5c:	d0 90 b9 02 	lds	r13, 0x02B9
    1c60:	e0 90 e8 02 	lds	r14, 0x02E8
    1c64:	f0 90 e9 02 	lds	r15, 0x02E9
    1c68:	00 91 ea 02 	lds	r16, 0x02EA
    1c6c:	10 91 eb 02 	lds	r17, 0x02EB
    1c70:	c8 01       	movw	r24, r16
    1c72:	b7 01       	movw	r22, r14
    1c74:	23 e3       	ldi	r18, 0x33	; 51
    1c76:	33 e3       	ldi	r19, 0x33	; 51
    1c78:	43 e0       	ldi	r20, 0x03	; 3
    1c7a:	51 ec       	ldi	r21, 0xC1	; 193
    1c7c:	0e 94 3f 2f 	call	0x5e7e	; 0x5e7e <__mulsf3>
    1c80:	9b 01       	movw	r18, r22
    1c82:	ac 01       	movw	r20, r24
    1c84:	c6 01       	movw	r24, r12
    1c86:	b5 01       	movw	r22, r10
    1c88:	0e 94 88 2d 	call	0x5b10	; 0x5b10 <__addsf3>
    1c8c:	0e 94 58 2e 	call	0x5cb0	; 0x5cb0 <__fixsfsi>
    1c90:	70 93 bf 02 	sts	0x02BF, r23
    1c94:	60 93 be 02 	sts	0x02BE, r22
		//rprintf("v_left: %d\n",v_left);
		v_right = (signed int)(v_command + cmd_ang_vel*ROBOT_RADIUS);
    1c98:	c8 01       	movw	r24, r16
    1c9a:	b7 01       	movw	r22, r14
    1c9c:	23 e3       	ldi	r18, 0x33	; 51
    1c9e:	33 e3       	ldi	r19, 0x33	; 51
    1ca0:	43 e0       	ldi	r20, 0x03	; 3
    1ca2:	51 e4       	ldi	r21, 0x41	; 65
    1ca4:	0e 94 3f 2f 	call	0x5e7e	; 0x5e7e <__mulsf3>
    1ca8:	9b 01       	movw	r18, r22
    1caa:	ac 01       	movw	r20, r24
    1cac:	c6 01       	movw	r24, r12
    1cae:	b5 01       	movw	r22, r10
    1cb0:	0e 94 88 2d 	call	0x5b10	; 0x5b10 <__addsf3>
    1cb4:	0e 94 58 2e 	call	0x5cb0	; 0x5cb0 <__fixsfsi>
    1cb8:	70 93 c1 02 	sts	0x02C1, r23
    1cbc:	60 93 c0 02 	sts	0x02C0, r22
		robot.vel = (LEFTVel_current + (-RIGHTVel_current)) / 2;
    1cc0:	80 91 c2 02 	lds	r24, 0x02C2
    1cc4:	90 91 c3 02 	lds	r25, 0x02C3
    1cc8:	20 91 cf 02 	lds	r18, 0x02CF
    1ccc:	30 91 d0 02 	lds	r19, 0x02D0
    1cd0:	82 1b       	sub	r24, r18
    1cd2:	93 0b       	sbc	r25, r19
    1cd4:	62 e0       	ldi	r22, 0x02	; 2
    1cd6:	70 e0       	ldi	r23, 0x00	; 0
    1cd8:	0e 94 d5 2f 	call	0x5faa	; 0x5faa <__divmodhi4>
    1cdc:	88 27       	eor	r24, r24
    1cde:	77 fd       	sbrc	r23, 7
    1ce0:	80 95       	com	r24
    1ce2:	98 2f       	mov	r25, r24
    1ce4:	0e 94 8b 2e 	call	0x5d16	; 0x5d16 <__floatsisf>
    1ce8:	60 93 4d 12 	sts	0x124D, r22
    1cec:	70 93 4e 12 	sts	0x124E, r23
    1cf0:	80 93 4f 12 	sts	0x124F, r24
    1cf4:	90 93 50 12 	sts	0x1250, r25
		
		dRIGHTDis = (-RIGHTDis_current) - (-RIGHTDis_prev); 
    1cf8:	80 91 d2 02 	lds	r24, 0x02D2
    1cfc:	90 91 d3 02 	lds	r25, 0x02D3
    1d00:	a0 91 d4 02 	lds	r26, 0x02D4
    1d04:	b0 91 d5 02 	lds	r27, 0x02D5
    1d08:	e0 90 d6 02 	lds	r14, 0x02D6
    1d0c:	f0 90 d7 02 	lds	r15, 0x02D7
    1d10:	e8 1a       	sub	r14, r24
    1d12:	f9 0a       	sbc	r15, r25
		RIGHTDis_prev = RIGHTDis_current;
    1d14:	80 93 d6 02 	sts	0x02D6, r24
    1d18:	90 93 d7 02 	sts	0x02D7, r25
    1d1c:	a0 93 d8 02 	sts	0x02D8, r26
    1d20:	b0 93 d9 02 	sts	0x02D9, r27
		dLEFTDis = LEFTDis_current - LEFTDis_prev;
    1d24:	80 91 c5 02 	lds	r24, 0x02C5
    1d28:	90 91 c6 02 	lds	r25, 0x02C6
    1d2c:	a0 91 c7 02 	lds	r26, 0x02C7
    1d30:	b0 91 c8 02 	lds	r27, 0x02C8
    1d34:	20 91 c9 02 	lds	r18, 0x02C9
    1d38:	30 91 ca 02 	lds	r19, 0x02CA
    1d3c:	8c 01       	movw	r16, r24
    1d3e:	02 1b       	sub	r16, r18
    1d40:	13 0b       	sbc	r17, r19
		LEFTDis_prev = LEFTDis_current;
    1d42:	80 93 c9 02 	sts	0x02C9, r24
    1d46:	90 93 ca 02 	sts	0x02CA, r25
    1d4a:	a0 93 cb 02 	sts	0x02CB, r26
    1d4e:	b0 93 cc 02 	sts	0x02CC, r27
		
		dDis = (10*(dRIGHTDis + dLEFTDis))/2;	//Send shifted value to avoid decimals
		dRIGHTDis = dLEFTDis = 0;
    1d52:	10 92 ce 02 	sts	0x02CE, r1
    1d56:	10 92 cd 02 	sts	0x02CD, r1
    1d5a:	10 92 db 02 	sts	0x02DB, r1
    1d5e:	10 92 da 02 	sts	0x02DA, r1
		
		send_frame('H', robot.heading);
    1d62:	c4 01       	movw	r24, r8
    1d64:	b3 01       	movw	r22, r6
    1d66:	0e 94 58 2e 	call	0x5cb0	; 0x5cb0 <__fixsfsi>
    1d6a:	9b 01       	movw	r18, r22
    1d6c:	ac 01       	movw	r20, r24
    1d6e:	88 e4       	ldi	r24, 0x48	; 72
    1d70:	b9 01       	movw	r22, r18
    1d72:	0e 94 a2 0d 	call	0x1b44	; 0x1b44 <send_frame>
		send_frame('V', robot.vel);
    1d76:	60 91 4d 12 	lds	r22, 0x124D
    1d7a:	70 91 4e 12 	lds	r23, 0x124E
    1d7e:	80 91 4f 12 	lds	r24, 0x124F
    1d82:	90 91 50 12 	lds	r25, 0x1250
    1d86:	0e 94 58 2e 	call	0x5cb0	; 0x5cb0 <__fixsfsi>
    1d8a:	9b 01       	movw	r18, r22
    1d8c:	ac 01       	movw	r20, r24
    1d8e:	86 e5       	ldi	r24, 0x56	; 86
    1d90:	b9 01       	movw	r22, r18
    1d92:	0e 94 a2 0d 	call	0x1b44	; 0x1b44 <send_frame>
		send_frame('S', dDis);
    1d96:	0e 0d       	add	r16, r14
    1d98:	1f 1d       	adc	r17, r15
    1d9a:	b8 01       	movw	r22, r16
    1d9c:	66 0f       	add	r22, r22
    1d9e:	77 1f       	adc	r23, r23
    1da0:	66 0f       	add	r22, r22
    1da2:	77 1f       	adc	r23, r23
    1da4:	60 0f       	add	r22, r16
    1da6:	71 1f       	adc	r23, r17
    1da8:	83 e5       	ldi	r24, 0x53	; 83
    1daa:	0e 94 a2 0d 	call	0x1b44	; 0x1b44 <send_frame>
    1dae:	32 cf       	rjmp	.-412    	; 0x1c14 <vUpdatePose+0x18>

00001db0 <ubRcv>:
		
			//taskYIELD();
	//	}
}

void ubRcv(unsigned char c){
    1db0:	1f 93       	push	r17
	static char dis_iter; //count iterator for commanded distance
	static char rot_flag;
	static char dis_flag;
	static s16 rot_rough = 0;  //store ascii chars
	static s16 dis_rough = 0;  //store ascii chars
		c = c & 0b01111111;		//for some reason, every byte has its first bit set to 1
    1db2:	18 2f       	mov	r17, r24
    1db4:	1f 77       	andi	r17, 0x7F	; 127
		uart1SendByte(c);
    1db6:	81 2f       	mov	r24, r17
    1db8:	0e 94 39 23 	call	0x4672	; 0x4672 <uart1SendByte>
		if(c != 0xff){
		//if the data isn't whitespace (0xff), post it
		

			if(c == 0x0a){lf_flag = SET;} //line feed detected, the character will be a 'R' or a 'D'
    1dbc:	1a 30       	cpi	r17, 0x0A	; 10
    1dbe:	21 f4       	brne	.+8      	; 0x1dc8 <ubRcv+0x18>
    1dc0:	81 e0       	ldi	r24, 0x01	; 1
    1dc2:	80 93 04 03 	sts	0x0304, r24
    1dc6:	61 c0       	rjmp	.+194    	; 0x1e8a <ubRcv+0xda>
	
			else if((lf_flag) && (c == 'R')){ //set rotation flag
    1dc8:	80 91 04 03 	lds	r24, 0x0304
    1dcc:	88 23       	and	r24, r24
    1dce:	91 f0       	breq	.+36     	; 0x1df4 <ubRcv+0x44>
    1dd0:	12 35       	cpi	r17, 0x52	; 82
    1dd2:	31 f4       	brne	.+12     	; 0x1de0 <ubRcv+0x30>
				rot_flag = SET;
    1dd4:	81 e0       	ldi	r24, 0x01	; 1
    1dd6:	80 93 01 03 	sts	0x0301, r24
				rot_iter = 0;
    1dda:	10 92 03 03 	sts	0x0303, r1
    1dde:	07 c0       	rjmp	.+14     	; 0x1dee <ubRcv+0x3e>
				lf_flag = UNSET;
				//rprintf("R: char: %c ",c);
				return;
			} 
			else if((lf_flag) && (c == 'M')){ //set distance flag
    1de0:	1d 34       	cpi	r17, 0x4D	; 77
    1de2:	41 f4       	brne	.+16     	; 0x1df4 <ubRcv+0x44>
				dis_flag = SET;
    1de4:	81 e0       	ldi	r24, 0x01	; 1
    1de6:	80 93 00 03 	sts	0x0300, r24
				dis_iter = 0;
    1dea:	10 92 02 03 	sts	0x0302, r1
				lf_flag = UNSET;
    1dee:	10 92 04 03 	sts	0x0304, r1
    1df2:	86 c0       	rjmp	.+268    	; 0x1f00 <ubRcv+0x150>
			//	rprintf("%c",c);
				return;
			}
			else if(rot_flag){
    1df4:	80 91 01 03 	lds	r24, 0x0301
    1df8:	88 23       	and	r24, r24
    1dfa:	11 f1       	breq	.+68     	; 0x1e40 <ubRcv+0x90>

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
    1dfc:	81 2f       	mov	r24, r17
    1dfe:	80 53       	subi	r24, 0x30	; 48
    1e00:	8a 30       	cpi	r24, 0x0A	; 10
    1e02:	10 f4       	brcc	.+4      	; 0x1e08 <ubRcv+0x58>
    1e04:	18 2f       	mov	r17, r24
    1e06:	05 c0       	rjmp	.+10     	; 0x1e12 <ubRcv+0x62>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
    1e08:	81 2f       	mov	r24, r17
    1e0a:	81 54       	subi	r24, 0x41	; 65
    1e0c:	86 30       	cpi	r24, 0x06	; 6
    1e0e:	08 f4       	brcc	.+2      	; 0x1e12 <ubRcv+0x62>
		c -= 55;
    1e10:	17 53       	subi	r17, 0x37	; 55
				lf_flag = UNSET;
			//	rprintf("%c",c);
				return;
			}
			else if(rot_flag){
				rot_rough = (char2hex(c) | (rot_rough << 4));	//store then increment	
    1e12:	81 2f       	mov	r24, r17
    1e14:	90 e0       	ldi	r25, 0x00	; 0
    1e16:	20 91 fe 02 	lds	r18, 0x02FE
    1e1a:	30 91 ff 02 	lds	r19, 0x02FF
    1e1e:	b4 e0       	ldi	r27, 0x04	; 4
    1e20:	22 0f       	add	r18, r18
    1e22:	33 1f       	adc	r19, r19
    1e24:	ba 95       	dec	r27
    1e26:	e1 f7       	brne	.-8      	; 0x1e20 <ubRcv+0x70>
    1e28:	82 2b       	or	r24, r18
    1e2a:	93 2b       	or	r25, r19
    1e2c:	90 93 ff 02 	sts	0x02FF, r25
    1e30:	80 93 fe 02 	sts	0x02FE, r24
				rot_iter++;
    1e34:	80 91 03 03 	lds	r24, 0x0303
    1e38:	8f 5f       	subi	r24, 0xFF	; 255
    1e3a:	80 93 03 03 	sts	0x0303, r24
    1e3e:	25 c0       	rjmp	.+74     	; 0x1e8a <ubRcv+0xda>
				//rprintf(" #%c\t:%d\t",c,rot_iter);
				//rprintfu08(c); rprintf("\t");
				//rprintfu16(rot_rough);
				//rprintfCRLF();
			}	
			else if(dis_flag){
    1e40:	80 91 00 03 	lds	r24, 0x0300
    1e44:	88 23       	and	r24, r24
    1e46:	09 f1       	breq	.+66     	; 0x1e8a <ubRcv+0xda>

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
    1e48:	81 2f       	mov	r24, r17
    1e4a:	80 53       	subi	r24, 0x30	; 48
    1e4c:	8a 30       	cpi	r24, 0x0A	; 10
    1e4e:	10 f4       	brcc	.+4      	; 0x1e54 <ubRcv+0xa4>
    1e50:	18 2f       	mov	r17, r24
    1e52:	05 c0       	rjmp	.+10     	; 0x1e5e <ubRcv+0xae>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
    1e54:	81 2f       	mov	r24, r17
    1e56:	81 54       	subi	r24, 0x41	; 65
    1e58:	86 30       	cpi	r24, 0x06	; 6
    1e5a:	08 f4       	brcc	.+2      	; 0x1e5e <ubRcv+0xae>
		c -= 55;
    1e5c:	17 53       	subi	r17, 0x37	; 55
				//rprintfu08(c); rprintf("\t");
				//rprintfu16(rot_rough);
				//rprintfCRLF();
			}	
			else if(dis_flag){
				dis_rough = (char2hex(c) | (dis_rough << 4));	//store then increment	
    1e5e:	81 2f       	mov	r24, r17
    1e60:	90 e0       	ldi	r25, 0x00	; 0
    1e62:	20 91 fc 02 	lds	r18, 0x02FC
    1e66:	30 91 fd 02 	lds	r19, 0x02FD
    1e6a:	a4 e0       	ldi	r26, 0x04	; 4
    1e6c:	22 0f       	add	r18, r18
    1e6e:	33 1f       	adc	r19, r19
    1e70:	aa 95       	dec	r26
    1e72:	e1 f7       	brne	.-8      	; 0x1e6c <ubRcv+0xbc>
    1e74:	82 2b       	or	r24, r18
    1e76:	93 2b       	or	r25, r19
    1e78:	90 93 fd 02 	sts	0x02FD, r25
    1e7c:	80 93 fc 02 	sts	0x02FC, r24
				dis_iter++;
    1e80:	80 91 02 03 	lds	r24, 0x0302
    1e84:	8f 5f       	subi	r24, 0xFF	; 255
    1e86:	80 93 02 03 	sts	0x0302, r24
			//	rprintf("%c",c);
			}

			if(rot_iter == 4){
    1e8a:	80 91 03 03 	lds	r24, 0x0303
    1e8e:	84 30       	cpi	r24, 0x04	; 4
    1e90:	d9 f4       	brne	.+54     	; 0x1ec8 <ubRcv+0x118>
				//cmd_angle = retConv_s16(&rot_rough);
				cmd_angle = rot_rough;
    1e92:	60 91 fe 02 	lds	r22, 0x02FE
    1e96:	70 91 ff 02 	lds	r23, 0x02FF
    1e9a:	88 27       	eor	r24, r24
    1e9c:	77 fd       	sbrc	r23, 7
    1e9e:	80 95       	com	r24
    1ea0:	98 2f       	mov	r25, r24
    1ea2:	0e 94 8b 2e 	call	0x5d16	; 0x5d16 <__floatsisf>
    1ea6:	60 93 e4 02 	sts	0x02E4, r22
    1eaa:	70 93 e5 02 	sts	0x02E5, r23
    1eae:	80 93 e6 02 	sts	0x02E6, r24
    1eb2:	90 93 e7 02 	sts	0x02E7, r25
				rot_flag = UNSET;
    1eb6:	10 92 01 03 	sts	0x0301, r1
				rot_iter = 0;
    1eba:	10 92 03 03 	sts	0x0303, r1
				//rprintfu16(rot_rough);
				//rprintf("\n\n");
				rot_rough = 0;
    1ebe:	10 92 ff 02 	sts	0x02FF, r1
    1ec2:	10 92 fe 02 	sts	0x02FE, r1
    1ec6:	1c c0       	rjmp	.+56     	; 0x1f00 <ubRcv+0x150>
			}
			else if(dis_iter == 4){
    1ec8:	80 91 02 03 	lds	r24, 0x0302
    1ecc:	84 30       	cpi	r24, 0x04	; 4
    1ece:	c1 f4       	brne	.+48     	; 0x1f00 <ubRcv+0x150>
				cmd_dist = dis_rough;
    1ed0:	80 91 fc 02 	lds	r24, 0x02FC
    1ed4:	90 91 fd 02 	lds	r25, 0x02FD
    1ed8:	aa 27       	eor	r26, r26
    1eda:	97 fd       	sbrc	r25, 7
    1edc:	a0 95       	com	r26
    1ede:	ba 2f       	mov	r27, r26
    1ee0:	80 93 ec 02 	sts	0x02EC, r24
    1ee4:	90 93 ed 02 	sts	0x02ED, r25
    1ee8:	a0 93 ee 02 	sts	0x02EE, r26
    1eec:	b0 93 ef 02 	sts	0x02EF, r27
				dis_flag = UNSET;
    1ef0:	10 92 00 03 	sts	0x0300, r1
				dis_iter = 0;
    1ef4:	10 92 02 03 	sts	0x0302, r1
				dis_rough = 0;
    1ef8:	10 92 fd 02 	sts	0x02FD, r1
    1efc:	10 92 fc 02 	sts	0x02FC, r1
		
		}

		else{rprintf("WR\n");}
		
}
    1f00:	1f 91       	pop	r17
    1f02:	08 95       	ret

00001f04 <prvSetupHardware>:

void prvSetupHardware(){
    1f04:	0f 93       	push	r16
    1f06:	1f 93       	push	r17
    1f08:	cf 93       	push	r28
    1f0a:	df 93       	push	r29
	delay_cycles(65535);
	delay_cycles(65535);
	
	

	uartInit();  // initialize the UART (serial port)
    1f0c:	0e 94 e6 26 	call	0x4dcc	; 0x4dcc <uartInit>
    uartSetBaudRate(0, 38400); // set UARTE speed, for Bluetooth
    1f10:	80 e0       	ldi	r24, 0x00	; 0
    1f12:	40 e0       	ldi	r20, 0x00	; 0
    1f14:	56 e9       	ldi	r21, 0x96	; 150
    1f16:	60 e0       	ldi	r22, 0x00	; 0
    1f18:	70 e0       	ldi	r23, 0x00	; 0
    1f1a:	0e 94 c0 22 	call	0x4580	; 0x4580 <uartSetBaudRate>
    uartSetBaudRate(1, 115200); // set UARTD speed, for USB connection, up to 500k, try 115200 if it doesn't work
    1f1e:	81 e0       	ldi	r24, 0x01	; 1
    1f20:	40 e0       	ldi	r20, 0x00	; 0
    1f22:	52 ec       	ldi	r21, 0xC2	; 194
    1f24:	61 e0       	ldi	r22, 0x01	; 1
    1f26:	70 e0       	ldi	r23, 0x00	; 0
    1f28:	0e 94 c0 22 	call	0x4580	; 0x4580 <uartSetBaudRate>
    uartSetBaudRate(2, 38400); // set UARTH speed
    1f2c:	82 e0       	ldi	r24, 0x02	; 2
    1f2e:	40 e0       	ldi	r20, 0x00	; 0
    1f30:	56 e9       	ldi	r21, 0x96	; 150
    1f32:	60 e0       	ldi	r22, 0x00	; 0
    1f34:	70 e0       	ldi	r23, 0x00	; 0
    1f36:	0e 94 c0 22 	call	0x4580	; 0x4580 <uartSetBaudRate>
    uartSetBaudRate(3, 38400); // set UARTJ speed, for Blackfin
    1f3a:	83 e0       	ldi	r24, 0x03	; 3
    1f3c:	40 e0       	ldi	r20, 0x00	; 0
    1f3e:	56 e9       	ldi	r21, 0x96	; 150
    1f40:	60 e0       	ldi	r22, 0x00	; 0
    1f42:	70 e0       	ldi	r23, 0x00	; 0
    1f44:	0e 94 c0 22 	call	0x4580	; 0x4580 <uartSetBaudRate>
	//G=Ground, T=Tx (connect to external Rx), R=Rx (connect to external Tx)

	rprintfInit(uart1SendByte);// initialize rprintf system and configure uart1 (USB) for rprintf
    1f48:	89 e3       	ldi	r24, 0x39	; 57
    1f4a:	93 e2       	ldi	r25, 0x23	; 35
    1f4c:	0e 94 2a 28 	call	0x5054	; 0x5054 <rprintfInit>

	configure_ports(); // configure which ports are analog, digital, etc.
    1f50:	0e 94 83 03 	call	0x706	; 0x706 <configure_ports>
	*/

	
	//UART ISR *** UART ISR ***
	
	uartSetRxHandler(2, &fwdSer_L);
    1f54:	82 e0       	ldi	r24, 0x02	; 2
    1f56:	6a e2       	ldi	r22, 0x2A	; 42
    1f58:	76 e0       	ldi	r23, 0x06	; 6
    1f5a:	0e 94 b5 22 	call	0x456a	; 0x456a <uartSetRxHandler>
	uartSetRxHandler(0, &fwdSer_R);
    1f5e:	80 e0       	ldi	r24, 0x00	; 0
    1f60:	6a e6       	ldi	r22, 0x6A	; 106
    1f62:	77 e0       	ldi	r23, 0x07	; 7
    1f64:	0e 94 b5 22 	call	0x456a	; 0x456a <uartSetRxHandler>
void LED_on(void)
	{PORT_OFF(PORTB,6);}
    1f68:	2e 98       	cbi	0x05, 6	; 5

	//UART ISR *** UART ISR ***

	LED_on();

	rprintf("\r\nSystem Warmed Up");
    1f6a:	00 d0       	rcall	.+0      	; 0x1f6c <prvSetupHardware+0x68>
    1f6c:	0f 92       	push	r0
    1f6e:	81 e0       	ldi	r24, 0x01	; 1
    1f70:	ed b7       	in	r30, 0x3d	; 61
    1f72:	fe b7       	in	r31, 0x3e	; 62
    1f74:	81 83       	std	Z+1, r24	; 0x01
    1f76:	8f e8       	ldi	r24, 0x8F	; 143
    1f78:	91 e0       	ldi	r25, 0x01	; 1
    1f7a:	93 83       	std	Z+3, r25	; 0x03
    1f7c:	82 83       	std	Z+2, r24	; 0x02
    1f7e:	0e 94 4e 2a 	call	0x549c	; 0x549c <rprintf1RamRom>

	// initialize the timer system
 	init_timer0(TIMER_CLK_1024);
    1f82:	0f 90       	pop	r0
    1f84:	0f 90       	pop	r0
    1f86:	0f 90       	pop	r0
    1f88:	85 e0       	ldi	r24, 0x05	; 5
    1f8a:	0e 94 cc 1c 	call	0x3998	; 0x3998 <init_timer0>
// 	init_timer1(TIMER_CLK_64); // Timer 1 is initialized by FreeRTOS
 	init_timer2(TIMER2_CLK_64);
    1f8e:	84 e0       	ldi	r24, 0x04	; 4
    1f90:	0e 94 ec 1c 	call	0x39d8	; 0x39d8 <init_timer2>
 	init_timer3(TIMER_CLK_64);
    1f94:	83 e0       	ldi	r24, 0x03	; 3
    1f96:	0e 94 fc 1c 	call	0x39f8	; 0x39f8 <init_timer3>
 	init_timer4(TIMER_CLK_64);
    1f9a:	83 e0       	ldi	r24, 0x03	; 3
    1f9c:	0e 94 0e 1d 	call	0x3a1c	; 0x3a1c <init_timer4>
 	init_timer5(TIMER_CLK_64);
    1fa0:	83 e0       	ldi	r24, 0x03	; 3
    1fa2:	0e 94 20 1d 	call	0x3a40	; 0x3a40 <init_timer5>

	a2dInit(); // initialize analog to digital converter (ADC)
    1fa6:	0e 94 9f 27 	call	0x4f3e	; 0x4f3e <a2dInit>
	a2dSetPrescaler(ADC_PRESCALE_DIV32); // configure ADC scaling
    1faa:	85 e0       	ldi	r24, 0x05	; 5
    1fac:	0e 94 c4 27 	call	0x4f88	; 0x4f88 <a2dSetPrescaler>
	a2dSetReference(ADC_REFERENCE_AVCC); // configure ADC reference voltage
    1fb0:	81 e0       	ldi	r24, 0x01	; 1
    1fb2:	0e 94 cb 27 	call	0x4f96	; 0x4f96 <a2dSetReference>
    1fb6:	10 e0       	ldi	r17, 0x00	; 0
	//let system stabelize for X time
	for(i=0;i<16;i++)
		{
		j=a2dConvert8bit(i);//read each ADC once to get it working accurately
		delay_cycles(5000); //keep LED on long enough to see Axon reseting
		rprintf(".");
    1fb8:	01 e0       	ldi	r16, 0x01	; 1
    1fba:	cd e8       	ldi	r28, 0x8D	; 141
    1fbc:	d1 e0       	ldi	r29, 0x01	; 1
	a2dSetReference(ADC_REFERENCE_AVCC); // configure ADC reference voltage

	//let system stabelize for X time
	for(i=0;i<16;i++)
		{
		j=a2dConvert8bit(i);//read each ADC once to get it working accurately
    1fbe:	81 2f       	mov	r24, r17
    1fc0:	0e 94 14 28 	call	0x5028	; 0x5028 <a2dConvert8bit>
		delay_cycles(5000); //keep LED on long enough to see Axon reseting
		rprintf(".");
    1fc4:	00 d0       	rcall	.+0      	; 0x1fc6 <prvSetupHardware+0xc2>
    1fc6:	0f 92       	push	r0
    1fc8:	ed b7       	in	r30, 0x3d	; 61
    1fca:	fe b7       	in	r31, 0x3e	; 62
    1fcc:	01 83       	std	Z+1, r16	; 0x01
    1fce:	d3 83       	std	Z+3, r29	; 0x03
    1fd0:	c2 83       	std	Z+2, r28	; 0x02
    1fd2:	0e 94 4e 2a 	call	0x549c	; 0x549c <rprintf1RamRom>
    1fd6:	1f 5f       	subi	r17, 0xFF	; 255
	a2dInit(); // initialize analog to digital converter (ADC)
	a2dSetPrescaler(ADC_PRESCALE_DIV32); // configure ADC scaling
	a2dSetReference(ADC_REFERENCE_AVCC); // configure ADC reference voltage

	//let system stabelize for X time
	for(i=0;i<16;i++)
    1fd8:	0f 90       	pop	r0
    1fda:	0f 90       	pop	r0
    1fdc:	0f 90       	pop	r0
    1fde:	10 31       	cpi	r17, 0x10	; 16
    1fe0:	71 f7       	brne	.-36     	; 0x1fbe <prvSetupHardware+0xba>


//***************STATUS LED**************
//tank test
void LED_off(void)
	{PORT_ON(PORTB,6);}
    1fe2:	2e 9a       	sbi	0x05, 6	; 5
		rprintf(".");
		}

	LED_off();

	rprintf("Initialization Complete \r\n");
    1fe4:	00 d0       	rcall	.+0      	; 0x1fe6 <prvSetupHardware+0xe2>
    1fe6:	0f 92       	push	r0
    1fe8:	ed b7       	in	r30, 0x3d	; 61
    1fea:	fe b7       	in	r31, 0x3e	; 62
    1fec:	01 83       	std	Z+1, r16	; 0x01
    1fee:	82 e7       	ldi	r24, 0x72	; 114
    1ff0:	91 e0       	ldi	r25, 0x01	; 1
    1ff2:	93 83       	std	Z+3, r25	; 0x03
    1ff4:	82 83       	std	Z+2, r24	; 0x02
    1ff6:	0e 94 4e 2a 	call	0x549c	; 0x549c <rprintf1RamRom>

	//reset all timers to zero
	reset_timer0();
    1ffa:	0f 90       	pop	r0
    1ffc:	0f 90       	pop	r0
    1ffe:	0f 90       	pop	r0
    2000:	0e 94 82 1c 	call	0x3904	; 0x3904 <reset_timer0>
	reset_timer1();
    2004:	0e 94 8c 1c 	call	0x3918	; 0x3918 <reset_timer1>
	reset_timer2();
    2008:	0e 94 99 1c 	call	0x3932	; 0x3932 <reset_timer2>
	reset_timer3();
    200c:	0e 94 a4 1c 	call	0x3948	; 0x3948 <reset_timer3>
	reset_timer4();
    2010:	0e 94 b1 1c 	call	0x3962	; 0x3962 <reset_timer4>
	reset_timer5();
    2014:	0e 94 be 1c 	call	0x397c	; 0x397c <reset_timer5>



	/********PWM Setup***********/
	prvPWMSetup();
    2018:	0e 94 53 04 	call	0x8a6	; 0x8a6 <prvPWMSetup>

}
    201c:	df 91       	pop	r29
    201e:	cf 91       	pop	r28
    2020:	1f 91       	pop	r17
    2022:	0f 91       	pop	r16
    2024:	08 95       	ret

00002026 <main>:
float elapsed_time;
float current_time = 0;
float previous_time = 0;

int main(void)
{
    2026:	af 92       	push	r10
    2028:	bf 92       	push	r11
    202a:	cf 92       	push	r12
    202c:	df 92       	push	r13
    202e:	ef 92       	push	r14
    2030:	ff 92       	push	r15
    2032:	0f 93       	push	r16
    2034:	cf 93       	push	r28
    2036:	df 93       	push	r29
	prvSetupHardware();
    2038:	0e 94 82 0f 	call	0x1f04	; 0x1f04 <prvSetupHardware>

	key = uart1GetByte();
    203c:	0e 94 fb 25 	call	0x4bf6	; 0x4bf6 <uart1GetByte>
    2040:	80 93 55 12 	sts	0x1255, r24
	delay_ms(500);
    2044:	84 ef       	ldi	r24, 0xF4	; 244
    2046:	91 e0       	ldi	r25, 0x01	; 1
    2048:	0e 94 47 1d 	call	0x3a8e	; 0x3a8e <sleep>
	rprintfCRLF();

	for(;;);
*/
	
	v_left = v_right = 25;
    204c:	89 e1       	ldi	r24, 0x19	; 25
    204e:	90 e0       	ldi	r25, 0x00	; 0
    2050:	90 93 c1 02 	sts	0x02C1, r25
    2054:	80 93 c0 02 	sts	0x02C0, r24
    2058:	90 93 bf 02 	sts	0x02BF, r25
    205c:	80 93 be 02 	sts	0x02BE, r24

	xTaskCreate(vLight0On, "Light0", 100, NULL, 1, NULL);
    2060:	8b e4       	ldi	r24, 0x4B	; 75
    2062:	9a e0       	ldi	r25, 0x0A	; 10
    2064:	60 e0       	ldi	r22, 0x00	; 0
    2066:	72 e0       	ldi	r23, 0x02	; 2
    2068:	44 e6       	ldi	r20, 0x64	; 100
    206a:	50 e0       	ldi	r21, 0x00	; 0
    206c:	20 e0       	ldi	r18, 0x00	; 0
    206e:	30 e0       	ldi	r19, 0x00	; 0
    2070:	01 e0       	ldi	r16, 0x01	; 1
    2072:	ee 24       	eor	r14, r14
    2074:	ff 24       	eor	r15, r15
    2076:	cc 24       	eor	r12, r12
    2078:	dd 24       	eor	r13, r13
    207a:	aa 24       	eor	r10, r10
    207c:	bb 24       	eor	r11, r11
    207e:	0e 94 2e 17 	call	0x2e5c	; 0x2e5c <xTaskGenericCreate>
	xTaskCreate(vLight1On, "Light1", 100, NULL, 1, NULL);
    2082:	84 e3       	ldi	r24, 0x34	; 52
    2084:	9a e0       	ldi	r25, 0x0A	; 10
    2086:	67 e0       	ldi	r22, 0x07	; 7
    2088:	72 e0       	ldi	r23, 0x02	; 2
    208a:	44 e6       	ldi	r20, 0x64	; 100
    208c:	50 e0       	ldi	r21, 0x00	; 0
    208e:	20 e0       	ldi	r18, 0x00	; 0
    2090:	30 e0       	ldi	r19, 0x00	; 0
    2092:	0e 94 2e 17 	call	0x2e5c	; 0x2e5c <xTaskGenericCreate>
//	xTaskCreate(vRampVel, "RampVel", 100, NULL, 1, NULL);
//	xTaskCreate(vUpdatePose, "UpdatePs", 500, NULL, 1, NULL);
//	xTaskCreate(vEnc_UpdatePose, "enUpdtPs", 500, NULL, 1, NULL);
//	xTaskCreate(vServoOsc, "ServoGo", 200, NULL, 1, NULL);
//	xTaskCreate(vServoTm, "ServoTm", 200, NULL, 1, NULL);
	xTaskCreate(vPID_L, "vPID_L", 500, NULL, 2, NULL);
    2096:	85 e0       	ldi	r24, 0x05	; 5
    2098:	9b e0       	ldi	r25, 0x0B	; 11
    209a:	6e e0       	ldi	r22, 0x0E	; 14
    209c:	72 e0       	ldi	r23, 0x02	; 2
    209e:	44 ef       	ldi	r20, 0xF4	; 244
    20a0:	51 e0       	ldi	r21, 0x01	; 1
    20a2:	20 e0       	ldi	r18, 0x00	; 0
    20a4:	30 e0       	ldi	r19, 0x00	; 0
    20a6:	02 e0       	ldi	r16, 0x02	; 2
    20a8:	0e 94 2e 17 	call	0x2e5c	; 0x2e5c <xTaskGenericCreate>
	xTaskCreate(vPID_R, "vPID_R", 500, NULL, 2, NULL);
    20ac:	82 e6       	ldi	r24, 0x62	; 98
    20ae:	9a e0       	ldi	r25, 0x0A	; 10
    20b0:	65 e1       	ldi	r22, 0x15	; 21
    20b2:	72 e0       	ldi	r23, 0x02	; 2
    20b4:	44 ef       	ldi	r20, 0xF4	; 244
    20b6:	51 e0       	ldi	r21, 0x01	; 1
    20b8:	20 e0       	ldi	r18, 0x00	; 0
    20ba:	30 e0       	ldi	r19, 0x00	; 0
    20bc:	0e 94 2e 17 	call	0x2e5c	; 0x2e5c <xTaskGenericCreate>
//	xTaskCreate(vScript, "vScript", 100, NULL, 2, NULL);


	vTaskStartScheduler();
    20c0:	0e 94 52 18 	call	0x30a4	; 0x30a4 <vTaskStartScheduler>
	for(;;){rprintf("DEATH\n");}
    20c4:	01 e0       	ldi	r16, 0x01	; 1
    20c6:	c4 ee       	ldi	r28, 0xE4	; 228
    20c8:	d0 e0       	ldi	r29, 0x00	; 0
    20ca:	00 d0       	rcall	.+0      	; 0x20cc <main+0xa6>
    20cc:	0f 92       	push	r0
    20ce:	ed b7       	in	r30, 0x3d	; 61
    20d0:	fe b7       	in	r31, 0x3e	; 62
    20d2:	01 83       	std	Z+1, r16	; 0x01
    20d4:	d3 83       	std	Z+3, r29	; 0x03
    20d6:	c2 83       	std	Z+2, r28	; 0x02
    20d8:	0e 94 4e 2a 	call	0x549c	; 0x549c <rprintf1RamRom>
    20dc:	0f 90       	pop	r0
    20de:	0f 90       	pop	r0
    20e0:	0f 90       	pop	r0
    20e2:	f3 cf       	rjmp	.-26     	; 0x20ca <main+0xa4>

000020e4 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    20e4:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    20e6:	9c 01       	movw	r18, r24
    20e8:	2d 5f       	subi	r18, 0xFD	; 253
    20ea:	3f 4f       	sbci	r19, 0xFF	; 255
    20ec:	32 83       	std	Z+2, r19	; 0x02
    20ee:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    20f0:	8f ef       	ldi	r24, 0xFF	; 255
    20f2:	9f ef       	ldi	r25, 0xFF	; 255
    20f4:	94 83       	std	Z+4, r25	; 0x04
    20f6:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    20f8:	36 83       	std	Z+6, r19	; 0x06
    20fa:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    20fc:	30 87       	std	Z+8, r19	; 0x08
    20fe:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = 0;
    2100:	10 82       	st	Z, r1
}
    2102:	08 95       	ret

00002104 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    2104:	fc 01       	movw	r30, r24
    2106:	11 86       	std	Z+9, r1	; 0x09
    2108:	10 86       	std	Z+8, r1	; 0x08
}
    210a:	08 95       	ret

0000210c <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    210c:	cf 93       	push	r28
    210e:	df 93       	push	r29
    2110:	ac 01       	movw	r20, r24
    2112:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    2114:	ec 01       	movw	r28, r24
    2116:	29 81       	ldd	r18, Y+1	; 0x01
    2118:	3a 81       	ldd	r19, Y+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    211a:	f9 01       	movw	r30, r18
    211c:	82 81       	ldd	r24, Z+2	; 0x02
    211e:	93 81       	ldd	r25, Z+3	; 0x03
    2120:	13 96       	adiw	r26, 0x03	; 3
    2122:	9c 93       	st	X, r25
    2124:	8e 93       	st	-X, r24
    2126:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
    2128:	89 81       	ldd	r24, Y+1	; 0x01
    212a:	9a 81       	ldd	r25, Y+2	; 0x02
    212c:	15 96       	adiw	r26, 0x05	; 5
    212e:	9c 93       	st	X, r25
    2130:	8e 93       	st	-X, r24
    2132:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    2134:	02 80       	ldd	r0, Z+2	; 0x02
    2136:	f3 81       	ldd	r31, Z+3	; 0x03
    2138:	e0 2d       	mov	r30, r0
    213a:	75 83       	std	Z+5, r23	; 0x05
    213c:	64 83       	std	Z+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    213e:	e9 01       	movw	r28, r18
    2140:	7b 83       	std	Y+3, r23	; 0x03
    2142:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    2144:	fa 01       	movw	r30, r20
    2146:	72 83       	std	Z+2, r23	; 0x02
    2148:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    214a:	19 96       	adiw	r26, 0x09	; 9
    214c:	5c 93       	st	X, r21
    214e:	4e 93       	st	-X, r20
    2150:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
    2152:	80 81       	ld	r24, Z
    2154:	8f 5f       	subi	r24, 0xFF	; 255
    2156:	80 83       	st	Z, r24
}
    2158:	df 91       	pop	r29
    215a:	cf 91       	pop	r28
    215c:	08 95       	ret

0000215e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    215e:	cf 93       	push	r28
    2160:	df 93       	push	r29
    2162:	9c 01       	movw	r18, r24
    2164:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    2166:	48 81       	ld	r20, Y
    2168:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as 
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the 
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    216a:	8f ef       	ldi	r24, 0xFF	; 255
    216c:	4f 3f       	cpi	r20, 0xFF	; 255
    216e:	58 07       	cpc	r21, r24
    2170:	21 f4       	brne	.+8      	; 0x217a <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    2172:	f9 01       	movw	r30, r18
    2174:	a7 81       	ldd	r26, Z+7	; 0x07
    2176:	b0 85       	ldd	r27, Z+8	; 0x08
    2178:	10 c0       	rjmp	.+32     	; 0x219a <vListInsert+0x3c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips. 
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    217a:	d9 01       	movw	r26, r18
    217c:	13 96       	adiw	r26, 0x03	; 3
    217e:	04 c0       	rjmp	.+8      	; 0x2188 <vListInsert+0x2a>
    2180:	12 96       	adiw	r26, 0x02	; 2
    2182:	0d 90       	ld	r0, X+
    2184:	bc 91       	ld	r27, X
    2186:	a0 2d       	mov	r26, r0
    2188:	12 96       	adiw	r26, 0x02	; 2
    218a:	ed 91       	ld	r30, X+
    218c:	fc 91       	ld	r31, X
    218e:	13 97       	sbiw	r26, 0x03	; 3
    2190:	80 81       	ld	r24, Z
    2192:	91 81       	ldd	r25, Z+1	; 0x01
    2194:	48 17       	cp	r20, r24
    2196:	59 07       	cpc	r21, r25
    2198:	98 f7       	brcc	.-26     	; 0x2180 <vListInsert+0x22>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    219a:	12 96       	adiw	r26, 0x02	; 2
    219c:	ed 91       	ld	r30, X+
    219e:	fc 91       	ld	r31, X
    21a0:	13 97       	sbiw	r26, 0x03	; 3
    21a2:	fb 83       	std	Y+3, r31	; 0x03
    21a4:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    21a6:	d5 83       	std	Z+5, r29	; 0x05
    21a8:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    21aa:	bd 83       	std	Y+5, r27	; 0x05
    21ac:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    21ae:	13 96       	adiw	r26, 0x03	; 3
    21b0:	dc 93       	st	X, r29
    21b2:	ce 93       	st	-X, r28
    21b4:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    21b6:	39 87       	std	Y+9, r19	; 0x09
    21b8:	28 87       	std	Y+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    21ba:	f9 01       	movw	r30, r18
    21bc:	80 81       	ld	r24, Z
    21be:	8f 5f       	subi	r24, 0xFF	; 255
    21c0:	80 83       	st	Z, r24
}
    21c2:	df 91       	pop	r29
    21c4:	cf 91       	pop	r28
    21c6:	08 95       	ret

000021c8 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    21c8:	cf 93       	push	r28
    21ca:	df 93       	push	r29
    21cc:	dc 01       	movw	r26, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    21ce:	12 96       	adiw	r26, 0x02	; 2
    21d0:	ed 91       	ld	r30, X+
    21d2:	fc 91       	ld	r31, X
    21d4:	13 97       	sbiw	r26, 0x03	; 3
    21d6:	14 96       	adiw	r26, 0x04	; 4
    21d8:	8d 91       	ld	r24, X+
    21da:	9c 91       	ld	r25, X
    21dc:	15 97       	sbiw	r26, 0x05	; 5
    21de:	95 83       	std	Z+5, r25	; 0x05
    21e0:	84 83       	std	Z+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    21e2:	14 96       	adiw	r26, 0x04	; 4
    21e4:	cd 91       	ld	r28, X+
    21e6:	dc 91       	ld	r29, X
    21e8:	15 97       	sbiw	r26, 0x05	; 5
    21ea:	fb 83       	std	Y+3, r31	; 0x03
    21ec:	ea 83       	std	Y+2, r30	; 0x02
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    21ee:	18 96       	adiw	r26, 0x08	; 8
    21f0:	ed 91       	ld	r30, X+
    21f2:	fc 91       	ld	r31, X
    21f4:	19 97       	sbiw	r26, 0x09	; 9

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    21f6:	81 81       	ldd	r24, Z+1	; 0x01
    21f8:	92 81       	ldd	r25, Z+2	; 0x02
    21fa:	8a 17       	cp	r24, r26
    21fc:	9b 07       	cpc	r25, r27
    21fe:	11 f4       	brne	.+4      	; 0x2204 <__stack+0x5>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    2200:	d2 83       	std	Z+2, r29	; 0x02
    2202:	c1 83       	std	Z+1, r28	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    2204:	19 96       	adiw	r26, 0x09	; 9
    2206:	1c 92       	st	X, r1
    2208:	1e 92       	st	-X, r1
    220a:	18 97       	sbiw	r26, 0x08	; 8
	( pxList->uxNumberOfItems )--;
    220c:	80 81       	ld	r24, Z
    220e:	81 50       	subi	r24, 0x01	; 1
    2210:	80 83       	st	Z, r24
}
    2212:	df 91       	pop	r29
    2214:	cf 91       	pop	r28
    2216:	08 95       	ret

00002218 <uxQueueMessagesWaiting>:
	return xReturn;
}
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    2218:	fc 01       	movw	r30, r24
unsigned portBASE_TYPE uxReturn;

	taskENTER_CRITICAL();
    221a:	0f b6       	in	r0, 0x3f	; 63
    221c:	f8 94       	cli
    221e:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    2220:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    2222:	0f 90       	pop	r0
    2224:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    2226:	08 95       	ret

00002228 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    2228:	fc 01       	movw	r30, r24
unsigned portBASE_TYPE uxReturn;

	uxReturn = pxQueue->uxMessagesWaiting;
    222a:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
    222c:	08 95       	ret

0000222e <xQueueIsQueueEmptyFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    222e:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    2230:	82 8d       	ldd	r24, Z+26	; 0x1a
    2232:	90 e0       	ldi	r25, 0x00	; 0
    2234:	88 23       	and	r24, r24
    2236:	09 f4       	brne	.+2      	; 0x223a <xQueueIsQueueEmptyFromISR+0xc>
    2238:	91 e0       	ldi	r25, 0x01	; 1

	return xReturn;
}
    223a:	89 2f       	mov	r24, r25
    223c:	08 95       	ret

0000223e <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    223e:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    2240:	92 8d       	ldd	r25, Z+26	; 0x1a
    2242:	20 e0       	ldi	r18, 0x00	; 0
    2244:	83 8d       	ldd	r24, Z+27	; 0x1b
    2246:	98 17       	cp	r25, r24
    2248:	09 f4       	brne	.+2      	; 0x224c <xQueueIsQueueFullFromISR+0xe>
    224a:	21 e0       	ldi	r18, 0x01	; 1

	return xReturn;
}
    224c:	82 2f       	mov	r24, r18
    224e:	08 95       	ret

00002250 <vQueueDelete>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    2250:	0f 93       	push	r16
    2252:	1f 93       	push	r17
    2254:	8c 01       	movw	r16, r24
	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    2256:	fc 01       	movw	r30, r24
    2258:	80 81       	ld	r24, Z
    225a:	91 81       	ldd	r25, Z+1	; 0x01
    225c:	0e 94 81 1b 	call	0x3702	; 0x3702 <vPortFree>
	vPortFree( pxQueue );
    2260:	c8 01       	movw	r24, r16
    2262:	0e 94 81 1b 	call	0x3702	; 0x3702 <vPortFree>
}
    2266:	1f 91       	pop	r17
    2268:	0f 91       	pop	r16
    226a:	08 95       	ret

0000226c <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    226c:	0f 93       	push	r16
    226e:	1f 93       	push	r17
    2270:	cf 93       	push	r28
    2272:	df 93       	push	r29
    2274:	ec 01       	movw	r28, r24
    2276:	fb 01       	movw	r30, r22
    2278:	8a 01       	movw	r16, r20
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    227a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    227c:	88 23       	and	r24, r24
    227e:	81 f1       	breq	.+96     	; 0x22e0 <xQueueReceiveFromISR+0x74>
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    2280:	48 81       	ld	r20, Y
    2282:	59 81       	ldd	r21, Y+1	; 0x01
    2284:	41 15       	cp	r20, r1
    2286:	51 05       	cpc	r21, r1
    2288:	a9 f0       	breq	.+42     	; 0x22b4 <xQueueReceiveFromISR+0x48>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    228a:	8c 8d       	ldd	r24, Y+28	; 0x1c
    228c:	2e 81       	ldd	r18, Y+6	; 0x06
    228e:	3f 81       	ldd	r19, Y+7	; 0x07
    2290:	28 0f       	add	r18, r24
    2292:	31 1d       	adc	r19, r1
    2294:	3f 83       	std	Y+7, r19	; 0x07
    2296:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    2298:	8a 81       	ldd	r24, Y+2	; 0x02
    229a:	9b 81       	ldd	r25, Y+3	; 0x03
    229c:	28 17       	cp	r18, r24
    229e:	39 07       	cpc	r19, r25
    22a0:	10 f0       	brcs	.+4      	; 0x22a6 <xQueueReceiveFromISR+0x3a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    22a2:	5f 83       	std	Y+7, r21	; 0x07
    22a4:	4e 83       	std	Y+6, r20	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    22a6:	4c 8d       	ldd	r20, Y+28	; 0x1c
    22a8:	6e 81       	ldd	r22, Y+6	; 0x06
    22aa:	7f 81       	ldd	r23, Y+7	; 0x07
    22ac:	cf 01       	movw	r24, r30
    22ae:	50 e0       	ldi	r21, 0x00	; 0
    22b0:	0e 94 68 2d 	call	0x5ad0	; 0x5ad0 <memcpy>
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
			--( pxQueue->uxMessagesWaiting );
    22b4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    22b6:	81 50       	subi	r24, 0x01	; 1
    22b8:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    22ba:	8d 8d       	ldd	r24, Y+29	; 0x1d
    22bc:	8f 3f       	cpi	r24, 0xFF	; 255
    22be:	69 f4       	brne	.+26     	; 0x22da <xQueueReceiveFromISR+0x6e>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
    22c0:	88 85       	ldd	r24, Y+8	; 0x08
    22c2:	88 23       	and	r24, r24
    22c4:	61 f0       	breq	.+24     	; 0x22de <xQueueReceiveFromISR+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    22c6:	ce 01       	movw	r24, r28
    22c8:	08 96       	adiw	r24, 0x08	; 8
    22ca:	0e 94 96 14 	call	0x292c	; 0x292c <xTaskRemoveFromEventList>
    22ce:	88 23       	and	r24, r24
    22d0:	31 f0       	breq	.+12     	; 0x22de <xQueueReceiveFromISR+0x72>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    22d2:	81 e0       	ldi	r24, 0x01	; 1
    22d4:	f8 01       	movw	r30, r16
    22d6:	80 83       	st	Z, r24
    22d8:	03 c0       	rjmp	.+6      	; 0x22e0 <xQueueReceiveFromISR+0x74>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    22da:	8f 5f       	subi	r24, 0xFF	; 255
    22dc:	8d 8f       	std	Y+29, r24	; 0x1d
    22de:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    22e0:	df 91       	pop	r29
    22e2:	cf 91       	pop	r28
    22e4:	1f 91       	pop	r17
    22e6:	0f 91       	pop	r16
    22e8:	08 95       	ret

000022ea <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    22ea:	cf 93       	push	r28
    22ec:	df 93       	push	r29
    22ee:	ec 01       	movw	r28, r24
    22f0:	84 2f       	mov	r24, r20
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    22f2:	4c 8d       	ldd	r20, Y+28	; 0x1c
    22f4:	44 23       	and	r20, r20
    22f6:	a1 f1       	breq	.+104    	; 0x2360 <prvCopyDataToQueue+0x76>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    22f8:	88 23       	and	r24, r24
    22fa:	b1 f4       	brne	.+44     	; 0x2328 <prvCopyDataToQueue+0x3e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    22fc:	8c 81       	ldd	r24, Y+4	; 0x04
    22fe:	9d 81       	ldd	r25, Y+5	; 0x05
    2300:	50 e0       	ldi	r21, 0x00	; 0
    2302:	0e 94 68 2d 	call	0x5ad0	; 0x5ad0 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    2306:	8c 8d       	ldd	r24, Y+28	; 0x1c
    2308:	2c 81       	ldd	r18, Y+4	; 0x04
    230a:	3d 81       	ldd	r19, Y+5	; 0x05
    230c:	28 0f       	add	r18, r24
    230e:	31 1d       	adc	r19, r1
    2310:	3d 83       	std	Y+5, r19	; 0x05
    2312:	2c 83       	std	Y+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    2314:	8a 81       	ldd	r24, Y+2	; 0x02
    2316:	9b 81       	ldd	r25, Y+3	; 0x03
    2318:	28 17       	cp	r18, r24
    231a:	39 07       	cpc	r19, r25
    231c:	08 f1       	brcs	.+66     	; 0x2360 <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    231e:	88 81       	ld	r24, Y
    2320:	99 81       	ldd	r25, Y+1	; 0x01
    2322:	9d 83       	std	Y+5, r25	; 0x05
    2324:	8c 83       	std	Y+4, r24	; 0x04
    2326:	1c c0       	rjmp	.+56     	; 0x2360 <prvCopyDataToQueue+0x76>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    2328:	8e 81       	ldd	r24, Y+6	; 0x06
    232a:	9f 81       	ldd	r25, Y+7	; 0x07
    232c:	50 e0       	ldi	r21, 0x00	; 0
    232e:	0e 94 68 2d 	call	0x5ad0	; 0x5ad0 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    2332:	8c 8d       	ldd	r24, Y+28	; 0x1c
    2334:	90 e0       	ldi	r25, 0x00	; 0
    2336:	44 27       	eor	r20, r20
    2338:	55 27       	eor	r21, r21
    233a:	48 1b       	sub	r20, r24
    233c:	59 0b       	sbc	r21, r25
    233e:	8e 81       	ldd	r24, Y+6	; 0x06
    2340:	9f 81       	ldd	r25, Y+7	; 0x07
    2342:	84 0f       	add	r24, r20
    2344:	95 1f       	adc	r25, r21
    2346:	9f 83       	std	Y+7, r25	; 0x07
    2348:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    234a:	28 81       	ld	r18, Y
    234c:	39 81       	ldd	r19, Y+1	; 0x01
    234e:	82 17       	cp	r24, r18
    2350:	93 07       	cpc	r25, r19
    2352:	30 f4       	brcc	.+12     	; 0x2360 <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    2354:	8a 81       	ldd	r24, Y+2	; 0x02
    2356:	9b 81       	ldd	r25, Y+3	; 0x03
    2358:	84 0f       	add	r24, r20
    235a:	95 1f       	adc	r25, r21
    235c:	9f 83       	std	Y+7, r25	; 0x07
    235e:	8e 83       	std	Y+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    2360:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2362:	8f 5f       	subi	r24, 0xFF	; 255
    2364:	8a 8f       	std	Y+26, r24	; 0x1a
}
    2366:	df 91       	pop	r29
    2368:	cf 91       	pop	r28
    236a:	08 95       	ret

0000236c <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    236c:	0f 93       	push	r16
    236e:	1f 93       	push	r17
    2370:	cf 93       	push	r28
    2372:	df 93       	push	r29
    2374:	ec 01       	movw	r28, r24
    2376:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    2378:	9a 8d       	ldd	r25, Y+26	; 0x1a
    237a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    237c:	98 17       	cp	r25, r24
    237e:	10 f0       	brcs	.+4      	; 0x2384 <xQueueGenericSendFromISR+0x18>
    2380:	80 e0       	ldi	r24, 0x00	; 0
    2382:	17 c0       	rjmp	.+46     	; 0x23b2 <xQueueGenericSendFromISR+0x46>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2384:	ce 01       	movw	r24, r28
    2386:	42 2f       	mov	r20, r18
    2388:	0e 94 75 11 	call	0x22ea	; 0x22ea <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    238c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    238e:	8f 3f       	cpi	r24, 0xFF	; 255
    2390:	69 f4       	brne	.+26     	; 0x23ac <xQueueGenericSendFromISR+0x40>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    2392:	89 89       	ldd	r24, Y+17	; 0x11
    2394:	88 23       	and	r24, r24
    2396:	61 f0       	breq	.+24     	; 0x23b0 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2398:	ce 01       	movw	r24, r28
    239a:	41 96       	adiw	r24, 0x11	; 17
    239c:	0e 94 96 14 	call	0x292c	; 0x292c <xTaskRemoveFromEventList>
    23a0:	88 23       	and	r24, r24
    23a2:	31 f0       	breq	.+12     	; 0x23b0 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    23a4:	81 e0       	ldi	r24, 0x01	; 1
    23a6:	f8 01       	movw	r30, r16
    23a8:	80 83       	st	Z, r24
    23aa:	03 c0       	rjmp	.+6      	; 0x23b2 <xQueueGenericSendFromISR+0x46>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    23ac:	8f 5f       	subi	r24, 0xFF	; 255
    23ae:	8e 8f       	std	Y+30, r24	; 0x1e
    23b0:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    23b2:	df 91       	pop	r29
    23b4:	cf 91       	pop	r28
    23b6:	1f 91       	pop	r17
    23b8:	0f 91       	pop	r16
    23ba:	08 95       	ret

000023bc <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    23bc:	0f 93       	push	r16
    23be:	1f 93       	push	r17
    23c0:	cf 93       	push	r28
    23c2:	df 93       	push	r29
    23c4:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    23c6:	0f b6       	in	r0, 0x3f	; 63
    23c8:	f8 94       	cli
    23ca:	0f 92       	push	r0
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    23cc:	8c 01       	movw	r16, r24
    23ce:	0f 5e       	subi	r16, 0xEF	; 239
    23d0:	1f 4f       	sbci	r17, 0xFF	; 255
    23d2:	0d c0       	rjmp	.+26     	; 0x23ee <prvUnlockQueue+0x32>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    23d4:	89 89       	ldd	r24, Y+17	; 0x11
    23d6:	88 23       	and	r24, r24
    23d8:	69 f0       	breq	.+26     	; 0x23f4 <prvUnlockQueue+0x38>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    23da:	c8 01       	movw	r24, r16
    23dc:	0e 94 96 14 	call	0x292c	; 0x292c <xTaskRemoveFromEventList>
    23e0:	88 23       	and	r24, r24
    23e2:	11 f0       	breq	.+4      	; 0x23e8 <prvUnlockQueue+0x2c>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    23e4:	0e 94 92 14 	call	0x2924	; 0x2924 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    23e8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    23ea:	81 50       	subi	r24, 0x01	; 1
    23ec:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    23ee:	8e 8d       	ldd	r24, Y+30	; 0x1e
    23f0:	18 16       	cp	r1, r24
    23f2:	84 f3       	brlt	.-32     	; 0x23d4 <prvUnlockQueue+0x18>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    23f4:	8f ef       	ldi	r24, 0xFF	; 255
    23f6:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    23f8:	0f 90       	pop	r0
    23fa:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    23fc:	0f b6       	in	r0, 0x3f	; 63
    23fe:	f8 94       	cli
    2400:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2402:	8e 01       	movw	r16, r28
    2404:	08 5f       	subi	r16, 0xF8	; 248
    2406:	1f 4f       	sbci	r17, 0xFF	; 255
    2408:	0d c0       	rjmp	.+26     	; 0x2424 <prvUnlockQueue+0x68>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
    240a:	88 85       	ldd	r24, Y+8	; 0x08
    240c:	88 23       	and	r24, r24
    240e:	69 f0       	breq	.+26     	; 0x242a <prvUnlockQueue+0x6e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2410:	c8 01       	movw	r24, r16
    2412:	0e 94 96 14 	call	0x292c	; 0x292c <xTaskRemoveFromEventList>
    2416:	88 23       	and	r24, r24
    2418:	11 f0       	breq	.+4      	; 0x241e <prvUnlockQueue+0x62>
				{
					vTaskMissedYield();
    241a:	0e 94 92 14 	call	0x2924	; 0x2924 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    241e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2420:	81 50       	subi	r24, 0x01	; 1
    2422:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2424:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2426:	18 16       	cp	r1, r24
    2428:	84 f3       	brlt	.-32     	; 0x240a <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    242a:	8f ef       	ldi	r24, 0xFF	; 255
    242c:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    242e:	0f 90       	pop	r0
    2430:	0f be       	out	0x3f, r0	; 63
}
    2432:	df 91       	pop	r29
    2434:	cf 91       	pop	r28
    2436:	1f 91       	pop	r17
    2438:	0f 91       	pop	r16
    243a:	08 95       	ret

0000243c <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    243c:	7f 92       	push	r7
    243e:	8f 92       	push	r8
    2440:	9f 92       	push	r9
    2442:	af 92       	push	r10
    2444:	bf 92       	push	r11
    2446:	cf 92       	push	r12
    2448:	df 92       	push	r13
    244a:	ef 92       	push	r14
    244c:	ff 92       	push	r15
    244e:	0f 93       	push	r16
    2450:	1f 93       	push	r17
    2452:	df 93       	push	r29
    2454:	cf 93       	push	r28
    2456:	00 d0       	rcall	.+0      	; 0x2458 <xQueueGenericReceive+0x1c>
    2458:	00 d0       	rcall	.+0      	; 0x245a <xQueueGenericReceive+0x1e>
    245a:	0f 92       	push	r0
    245c:	cd b7       	in	r28, 0x3d	; 61
    245e:	de b7       	in	r29, 0x3e	; 62
    2460:	8c 01       	movw	r16, r24
    2462:	96 2e       	mov	r9, r22
    2464:	87 2e       	mov	r8, r23
    2466:	5d 83       	std	Y+5, r21	; 0x05
    2468:	4c 83       	std	Y+4, r20	; 0x04
    246a:	72 2e       	mov	r7, r18
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    246c:	91 e1       	ldi	r25, 0x11	; 17
    246e:	c9 2e       	mov	r12, r25
    2470:	d1 2c       	mov	r13, r1
    2472:	c0 0e       	add	r12, r16
    2474:	d1 1e       	adc	r13, r17
    2476:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2478:	7e 01       	movw	r14, r28
    247a:	08 94       	sec
    247c:	e1 1c       	adc	r14, r1
    247e:	f1 1c       	adc	r15, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2480:	84 e0       	ldi	r24, 0x04	; 4
    2482:	a8 2e       	mov	r10, r24
    2484:	b1 2c       	mov	r11, r1
    2486:	ac 0e       	add	r10, r28
    2488:	bd 1e       	adc	r11, r29
    248a:	01 c0       	rjmp	.+2      	; 0x248e <xQueueGenericReceive+0x52>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    248c:	21 e0       	ldi	r18, 0x01	; 1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    248e:	0f b6       	in	r0, 0x3f	; 63
    2490:	f8 94       	cli
    2492:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    2494:	f8 01       	movw	r30, r16
    2496:	82 8d       	ldd	r24, Z+26	; 0x1a
    2498:	88 23       	and	r24, r24
    249a:	09 f4       	brne	.+2      	; 0x249e <xQueueGenericReceive+0x62>
    249c:	3e c0       	rjmp	.+124    	; 0x251a <xQueueGenericReceive+0xde>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    249e:	e6 80       	ldd	r14, Z+6	; 0x06
    24a0:	f7 80       	ldd	r15, Z+7	; 0x07
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    24a2:	40 81       	ld	r20, Z
    24a4:	51 81       	ldd	r21, Z+1	; 0x01
    24a6:	41 15       	cp	r20, r1
    24a8:	51 05       	cpc	r21, r1
    24aa:	b1 f0       	breq	.+44     	; 0x24d8 <xQueueGenericReceive+0x9c>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    24ac:	84 8d       	ldd	r24, Z+28	; 0x1c
    24ae:	97 01       	movw	r18, r14
    24b0:	28 0f       	add	r18, r24
    24b2:	31 1d       	adc	r19, r1
    24b4:	37 83       	std	Z+7, r19	; 0x07
    24b6:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    24b8:	82 81       	ldd	r24, Z+2	; 0x02
    24ba:	93 81       	ldd	r25, Z+3	; 0x03
    24bc:	28 17       	cp	r18, r24
    24be:	39 07       	cpc	r19, r25
    24c0:	10 f0       	brcs	.+4      	; 0x24c6 <xQueueGenericReceive+0x8a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    24c2:	57 83       	std	Z+7, r21	; 0x07
    24c4:	46 83       	std	Z+6, r20	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    24c6:	f8 01       	movw	r30, r16
    24c8:	44 8d       	ldd	r20, Z+28	; 0x1c
    24ca:	66 81       	ldd	r22, Z+6	; 0x06
    24cc:	77 81       	ldd	r23, Z+7	; 0x07
    24ce:	89 2d       	mov	r24, r9
    24d0:	98 2d       	mov	r25, r8
    24d2:	50 e0       	ldi	r21, 0x00	; 0
    24d4:	0e 94 68 2d 	call	0x5ad0	; 0x5ad0 <memcpy>
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
    24d8:	77 20       	and	r7, r7
    24da:	71 f4       	brne	.+28     	; 0x24f8 <xQueueGenericReceive+0xbc>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    24dc:	f8 01       	movw	r30, r16
    24de:	82 8d       	ldd	r24, Z+26	; 0x1a
    24e0:	81 50       	subi	r24, 0x01	; 1
    24e2:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    24e4:	80 85       	ldd	r24, Z+8	; 0x08
    24e6:	88 23       	and	r24, r24
    24e8:	a1 f0       	breq	.+40     	; 0x2512 <xQueueGenericReceive+0xd6>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    24ea:	c8 01       	movw	r24, r16
    24ec:	08 96       	adiw	r24, 0x08	; 8
    24ee:	0e 94 96 14 	call	0x292c	; 0x292c <xTaskRemoveFromEventList>
    24f2:	81 30       	cpi	r24, 0x01	; 1
    24f4:	71 f4       	brne	.+28     	; 0x2512 <xQueueGenericReceive+0xd6>
    24f6:	0b c0       	rjmp	.+22     	; 0x250e <xQueueGenericReceive+0xd2>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    24f8:	f8 01       	movw	r30, r16
    24fa:	f7 82       	std	Z+7, r15	; 0x07
    24fc:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    24fe:	81 89       	ldd	r24, Z+17	; 0x11
    2500:	88 23       	and	r24, r24
    2502:	39 f0       	breq	.+14     	; 0x2512 <xQueueGenericReceive+0xd6>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2504:	c6 01       	movw	r24, r12
    2506:	0e 94 96 14 	call	0x292c	; 0x292c <xTaskRemoveFromEventList>
    250a:	88 23       	and	r24, r24
    250c:	11 f0       	breq	.+4      	; 0x2512 <xQueueGenericReceive+0xd6>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    250e:	0e 94 5e 19 	call	0x32bc	; 0x32bc <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    2512:	0f 90       	pop	r0
    2514:	0f be       	out	0x3f, r0	; 63
    2516:	81 e0       	ldi	r24, 0x01	; 1
    2518:	4a c0       	rjmp	.+148    	; 0x25ae <xQueueGenericReceive+0x172>
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    251a:	8c 81       	ldd	r24, Y+4	; 0x04
    251c:	9d 81       	ldd	r25, Y+5	; 0x05
    251e:	89 2b       	or	r24, r25
    2520:	19 f4       	brne	.+6      	; 0x2528 <xQueueGenericReceive+0xec>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2522:	0f 90       	pop	r0
    2524:	0f be       	out	0x3f, r0	; 63
    2526:	42 c0       	rjmp	.+132    	; 0x25ac <xQueueGenericReceive+0x170>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    2528:	22 23       	and	r18, r18
    252a:	19 f4       	brne	.+6      	; 0x2532 <xQueueGenericReceive+0xf6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    252c:	c7 01       	movw	r24, r14
    252e:	0e 94 4d 14 	call	0x289a	; 0x289a <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    2532:	0f 90       	pop	r0
    2534:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2536:	0e 94 f1 13 	call	0x27e2	; 0x27e2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    253a:	0f b6       	in	r0, 0x3f	; 63
    253c:	f8 94       	cli
    253e:	0f 92       	push	r0
    2540:	f8 01       	movw	r30, r16
    2542:	85 8d       	ldd	r24, Z+29	; 0x1d
    2544:	8f 3f       	cpi	r24, 0xFF	; 255
    2546:	09 f4       	brne	.+2      	; 0x254a <xQueueGenericReceive+0x10e>
    2548:	15 8e       	std	Z+29, r1	; 0x1d
    254a:	f8 01       	movw	r30, r16
    254c:	86 8d       	ldd	r24, Z+30	; 0x1e
    254e:	8f 3f       	cpi	r24, 0xFF	; 255
    2550:	09 f4       	brne	.+2      	; 0x2554 <xQueueGenericReceive+0x118>
    2552:	16 8e       	std	Z+30, r1	; 0x1e
    2554:	0f 90       	pop	r0
    2556:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2558:	c7 01       	movw	r24, r14
    255a:	b5 01       	movw	r22, r10
    255c:	0e 94 58 14 	call	0x28b0	; 0x28b0 <xTaskCheckForTimeOut>
    2560:	88 23       	and	r24, r24
    2562:	f9 f4       	brne	.+62     	; 0x25a2 <xQueueGenericReceive+0x166>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    2564:	0f b6       	in	r0, 0x3f	; 63
    2566:	f8 94       	cli
    2568:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    256a:	f8 01       	movw	r30, r16
    256c:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    256e:	0f 90       	pop	r0
    2570:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
    2572:	88 23       	and	r24, r24
    2574:	81 f4       	brne	.+32     	; 0x2596 <xQueueGenericReceive+0x15a>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2576:	6c 81       	ldd	r22, Y+4	; 0x04
    2578:	7d 81       	ldd	r23, Y+5	; 0x05
    257a:	c6 01       	movw	r24, r12
    257c:	0e 94 4f 15 	call	0x2a9e	; 0x2a9e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2580:	c8 01       	movw	r24, r16
    2582:	0e 94 de 11 	call	0x23bc	; 0x23bc <prvUnlockQueue>
				if( !xTaskResumeAll() )
    2586:	0e 94 88 15 	call	0x2b10	; 0x2b10 <xTaskResumeAll>
    258a:	88 23       	and	r24, r24
    258c:	09 f0       	breq	.+2      	; 0x2590 <xQueueGenericReceive+0x154>
    258e:	7e cf       	rjmp	.-260    	; 0x248c <xQueueGenericReceive+0x50>
				{
					portYIELD_WITHIN_API();
    2590:	0e 94 5e 19 	call	0x32bc	; 0x32bc <vPortYield>
    2594:	7b cf       	rjmp	.-266    	; 0x248c <xQueueGenericReceive+0x50>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2596:	c8 01       	movw	r24, r16
    2598:	0e 94 de 11 	call	0x23bc	; 0x23bc <prvUnlockQueue>
				( void ) xTaskResumeAll();
    259c:	0e 94 88 15 	call	0x2b10	; 0x2b10 <xTaskResumeAll>
    25a0:	75 cf       	rjmp	.-278    	; 0x248c <xQueueGenericReceive+0x50>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    25a2:	c8 01       	movw	r24, r16
    25a4:	0e 94 de 11 	call	0x23bc	; 0x23bc <prvUnlockQueue>
			( void ) xTaskResumeAll();
    25a8:	0e 94 88 15 	call	0x2b10	; 0x2b10 <xTaskResumeAll>
    25ac:	80 e0       	ldi	r24, 0x00	; 0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
    25ae:	0f 90       	pop	r0
    25b0:	0f 90       	pop	r0
    25b2:	0f 90       	pop	r0
    25b4:	0f 90       	pop	r0
    25b6:	0f 90       	pop	r0
    25b8:	cf 91       	pop	r28
    25ba:	df 91       	pop	r29
    25bc:	1f 91       	pop	r17
    25be:	0f 91       	pop	r16
    25c0:	ff 90       	pop	r15
    25c2:	ef 90       	pop	r14
    25c4:	df 90       	pop	r13
    25c6:	cf 90       	pop	r12
    25c8:	bf 90       	pop	r11
    25ca:	af 90       	pop	r10
    25cc:	9f 90       	pop	r9
    25ce:	8f 90       	pop	r8
    25d0:	7f 90       	pop	r7
    25d2:	08 95       	ret

000025d4 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    25d4:	7f 92       	push	r7
    25d6:	8f 92       	push	r8
    25d8:	9f 92       	push	r9
    25da:	af 92       	push	r10
    25dc:	bf 92       	push	r11
    25de:	cf 92       	push	r12
    25e0:	df 92       	push	r13
    25e2:	ef 92       	push	r14
    25e4:	ff 92       	push	r15
    25e6:	0f 93       	push	r16
    25e8:	1f 93       	push	r17
    25ea:	df 93       	push	r29
    25ec:	cf 93       	push	r28
    25ee:	00 d0       	rcall	.+0      	; 0x25f0 <xQueueGenericSend+0x1c>
    25f0:	00 d0       	rcall	.+0      	; 0x25f2 <xQueueGenericSend+0x1e>
    25f2:	0f 92       	push	r0
    25f4:	cd b7       	in	r28, 0x3d	; 61
    25f6:	de b7       	in	r29, 0x3e	; 62
    25f8:	8c 01       	movw	r16, r24
    25fa:	6b 01       	movw	r12, r22
    25fc:	5d 83       	std	Y+5, r21	; 0x05
    25fe:	4c 83       	std	Y+4, r20	; 0x04
    2600:	72 2e       	mov	r7, r18
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2602:	48 e0       	ldi	r20, 0x08	; 8
    2604:	e4 2e       	mov	r14, r20
    2606:	f1 2c       	mov	r15, r1
    2608:	e8 0e       	add	r14, r24
    260a:	f9 1e       	adc	r15, r25
    260c:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    260e:	5e 01       	movw	r10, r28
    2610:	08 94       	sec
    2612:	a1 1c       	adc	r10, r1
    2614:	b1 1c       	adc	r11, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2616:	34 e0       	ldi	r19, 0x04	; 4
    2618:	83 2e       	mov	r8, r19
    261a:	91 2c       	mov	r9, r1
    261c:	8c 0e       	add	r8, r28
    261e:	9d 1e       	adc	r9, r29
    2620:	01 c0       	rjmp	.+2      	; 0x2624 <xQueueGenericSend+0x50>
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2622:	21 e0       	ldi	r18, 0x01	; 1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2624:	0f b6       	in	r0, 0x3f	; 63
    2626:	f8 94       	cli
    2628:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    262a:	f8 01       	movw	r30, r16
    262c:	92 8d       	ldd	r25, Z+26	; 0x1a
    262e:	83 8d       	ldd	r24, Z+27	; 0x1b
    2630:	98 17       	cp	r25, r24
    2632:	a8 f4       	brcc	.+42     	; 0x265e <xQueueGenericSend+0x8a>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2634:	c8 01       	movw	r24, r16
    2636:	b6 01       	movw	r22, r12
    2638:	47 2d       	mov	r20, r7
    263a:	0e 94 75 11 	call	0x22ea	; 0x22ea <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    263e:	f8 01       	movw	r30, r16
    2640:	81 89       	ldd	r24, Z+17	; 0x11
    2642:	88 23       	and	r24, r24
    2644:	41 f0       	breq	.+16     	; 0x2656 <xQueueGenericSend+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    2646:	c8 01       	movw	r24, r16
    2648:	41 96       	adiw	r24, 0x11	; 17
    264a:	0e 94 96 14 	call	0x292c	; 0x292c <xTaskRemoveFromEventList>
    264e:	81 30       	cpi	r24, 0x01	; 1
    2650:	11 f4       	brne	.+4      	; 0x2656 <xQueueGenericSend+0x82>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    2652:	0e 94 5e 19 	call	0x32bc	; 0x32bc <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    2656:	0f 90       	pop	r0
    2658:	0f be       	out	0x3f, r0	; 63
    265a:	81 e0       	ldi	r24, 0x01	; 1
    265c:	4c c0       	rjmp	.+152    	; 0x26f6 <xQueueGenericSend+0x122>
				function. */
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    265e:	8c 81       	ldd	r24, Y+4	; 0x04
    2660:	9d 81       	ldd	r25, Y+5	; 0x05
    2662:	89 2b       	or	r24, r25
    2664:	19 f4       	brne	.+6      	; 0x266c <xQueueGenericSend+0x98>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2666:	0f 90       	pop	r0
    2668:	0f be       	out	0x3f, r0	; 63
    266a:	44 c0       	rjmp	.+136    	; 0x26f4 <xQueueGenericSend+0x120>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    266c:	22 23       	and	r18, r18
    266e:	19 f4       	brne	.+6      	; 0x2676 <xQueueGenericSend+0xa2>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2670:	c5 01       	movw	r24, r10
    2672:	0e 94 4d 14 	call	0x289a	; 0x289a <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    2676:	0f 90       	pop	r0
    2678:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    267a:	0e 94 f1 13 	call	0x27e2	; 0x27e2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    267e:	0f b6       	in	r0, 0x3f	; 63
    2680:	f8 94       	cli
    2682:	0f 92       	push	r0
    2684:	f8 01       	movw	r30, r16
    2686:	85 8d       	ldd	r24, Z+29	; 0x1d
    2688:	8f 3f       	cpi	r24, 0xFF	; 255
    268a:	09 f4       	brne	.+2      	; 0x268e <xQueueGenericSend+0xba>
    268c:	15 8e       	std	Z+29, r1	; 0x1d
    268e:	f8 01       	movw	r30, r16
    2690:	86 8d       	ldd	r24, Z+30	; 0x1e
    2692:	8f 3f       	cpi	r24, 0xFF	; 255
    2694:	09 f4       	brne	.+2      	; 0x2698 <xQueueGenericSend+0xc4>
    2696:	16 8e       	std	Z+30, r1	; 0x1e
    2698:	0f 90       	pop	r0
    269a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    269c:	c5 01       	movw	r24, r10
    269e:	b4 01       	movw	r22, r8
    26a0:	0e 94 58 14 	call	0x28b0	; 0x28b0 <xTaskCheckForTimeOut>
    26a4:	88 23       	and	r24, r24
    26a6:	09 f5       	brne	.+66     	; 0x26ea <xQueueGenericSend+0x116>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    26a8:	0f b6       	in	r0, 0x3f	; 63
    26aa:	f8 94       	cli
    26ac:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    26ae:	f8 01       	movw	r30, r16
    26b0:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    26b2:	0f 90       	pop	r0
    26b4:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
    26b6:	f8 01       	movw	r30, r16
    26b8:	83 8d       	ldd	r24, Z+27	; 0x1b
    26ba:	98 17       	cp	r25, r24
    26bc:	81 f4       	brne	.+32     	; 0x26de <xQueueGenericSend+0x10a>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    26be:	6c 81       	ldd	r22, Y+4	; 0x04
    26c0:	7d 81       	ldd	r23, Y+5	; 0x05
    26c2:	c7 01       	movw	r24, r14
    26c4:	0e 94 4f 15 	call	0x2a9e	; 0x2a9e <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    26c8:	c8 01       	movw	r24, r16
    26ca:	0e 94 de 11 	call	0x23bc	; 0x23bc <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
    26ce:	0e 94 88 15 	call	0x2b10	; 0x2b10 <xTaskResumeAll>
    26d2:	88 23       	and	r24, r24
    26d4:	09 f0       	breq	.+2      	; 0x26d8 <xQueueGenericSend+0x104>
    26d6:	a5 cf       	rjmp	.-182    	; 0x2622 <xQueueGenericSend+0x4e>
				{
					portYIELD_WITHIN_API();
    26d8:	0e 94 5e 19 	call	0x32bc	; 0x32bc <vPortYield>
    26dc:	a2 cf       	rjmp	.-188    	; 0x2622 <xQueueGenericSend+0x4e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    26de:	c8 01       	movw	r24, r16
    26e0:	0e 94 de 11 	call	0x23bc	; 0x23bc <prvUnlockQueue>
				( void ) xTaskResumeAll();
    26e4:	0e 94 88 15 	call	0x2b10	; 0x2b10 <xTaskResumeAll>
    26e8:	9c cf       	rjmp	.-200    	; 0x2622 <xQueueGenericSend+0x4e>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    26ea:	c8 01       	movw	r24, r16
    26ec:	0e 94 de 11 	call	0x23bc	; 0x23bc <prvUnlockQueue>
			( void ) xTaskResumeAll();
    26f0:	0e 94 88 15 	call	0x2b10	; 0x2b10 <xTaskResumeAll>
    26f4:	80 e0       	ldi	r24, 0x00	; 0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
    26f6:	0f 90       	pop	r0
    26f8:	0f 90       	pop	r0
    26fa:	0f 90       	pop	r0
    26fc:	0f 90       	pop	r0
    26fe:	0f 90       	pop	r0
    2700:	cf 91       	pop	r28
    2702:	df 91       	pop	r29
    2704:	1f 91       	pop	r17
    2706:	0f 91       	pop	r16
    2708:	ff 90       	pop	r15
    270a:	ef 90       	pop	r14
    270c:	df 90       	pop	r13
    270e:	cf 90       	pop	r12
    2710:	bf 90       	pop	r11
    2712:	af 90       	pop	r10
    2714:	9f 90       	pop	r9
    2716:	8f 90       	pop	r8
    2718:	7f 90       	pop	r7
    271a:	08 95       	ret

0000271c <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    271c:	8f 92       	push	r8
    271e:	9f 92       	push	r9
    2720:	af 92       	push	r10
    2722:	bf 92       	push	r11
    2724:	cf 92       	push	r12
    2726:	df 92       	push	r13
    2728:	ef 92       	push	r14
    272a:	ff 92       	push	r15
    272c:	0f 93       	push	r16
    272e:	1f 93       	push	r17
    2730:	cf 93       	push	r28
    2732:	df 93       	push	r29
    2734:	98 2e       	mov	r9, r24
    2736:	86 2e       	mov	r8, r22
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    2738:	88 23       	and	r24, r24
    273a:	09 f4       	brne	.+2      	; 0x273e <xQueueCreate+0x22>
    273c:	42 c0       	rjmp	.+132    	; 0x27c2 <xQueueCreate+0xa6>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    273e:	8f e1       	ldi	r24, 0x1F	; 31
    2740:	90 e0       	ldi	r25, 0x00	; 0
    2742:	0e 94 91 1b 	call	0x3722	; 0x3722 <pvPortMalloc>
    2746:	8c 01       	movw	r16, r24
    2748:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    274a:	00 97       	sbiw	r24, 0x00	; 0
    274c:	e1 f1       	breq	.+120    	; 0x27c6 <xQueueCreate+0xaa>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    274e:	c9 2c       	mov	r12, r9
    2750:	dd 24       	eor	r13, r13
    2752:	a8 2c       	mov	r10, r8
    2754:	bb 24       	eor	r11, r11
    2756:	ac 9c       	mul	r10, r12
    2758:	70 01       	movw	r14, r0
    275a:	ad 9c       	mul	r10, r13
    275c:	f0 0c       	add	r15, r0
    275e:	bc 9c       	mul	r11, r12
    2760:	f0 0c       	add	r15, r0
    2762:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    2764:	c7 01       	movw	r24, r14
    2766:	01 96       	adiw	r24, 0x01	; 1
    2768:	0e 94 91 1b 	call	0x3722	; 0x3722 <pvPortMalloc>
    276c:	9c 01       	movw	r18, r24
    276e:	99 83       	std	Y+1, r25	; 0x01
    2770:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    2772:	00 97       	sbiw	r24, 0x00	; 0
    2774:	19 f1       	breq	.+70     	; 0x27bc <xQueueCreate+0xa0>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    2776:	e8 0e       	add	r14, r24
    2778:	f9 1e       	adc	r15, r25
    277a:	fb 82       	std	Y+3, r15	; 0x03
    277c:	ea 82       	std	Y+2, r14	; 0x02
				pxNewQueue->uxMessagesWaiting = 0;
    277e:	1a 8e       	std	Y+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    2780:	9d 83       	std	Y+5, r25	; 0x05
    2782:	8c 83       	std	Y+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
    2784:	08 94       	sec
    2786:	c1 08       	sbc	r12, r1
    2788:	d1 08       	sbc	r13, r1
    278a:	ca 9c       	mul	r12, r10
    278c:	c0 01       	movw	r24, r0
    278e:	cb 9c       	mul	r12, r11
    2790:	90 0d       	add	r25, r0
    2792:	da 9c       	mul	r13, r10
    2794:	90 0d       	add	r25, r0
    2796:	11 24       	eor	r1, r1
    2798:	28 0f       	add	r18, r24
    279a:	39 1f       	adc	r19, r25
    279c:	3f 83       	std	Y+7, r19	; 0x07
    279e:	2e 83       	std	Y+6, r18	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    27a0:	9b 8e       	std	Y+27, r9	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    27a2:	8c 8e       	std	Y+28, r8	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    27a4:	8f ef       	ldi	r24, 0xFF	; 255
    27a6:	8d 8f       	std	Y+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    27a8:	8e 8f       	std	Y+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    27aa:	c8 01       	movw	r24, r16
    27ac:	08 96       	adiw	r24, 0x08	; 8
    27ae:	0e 94 72 10 	call	0x20e4	; 0x20e4 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    27b2:	c8 01       	movw	r24, r16
    27b4:	41 96       	adiw	r24, 0x11	; 17
    27b6:	0e 94 72 10 	call	0x20e4	; 0x20e4 <vListInitialise>
    27ba:	05 c0       	rjmp	.+10     	; 0x27c6 <xQueueCreate+0xaa>
				return  pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    27bc:	c8 01       	movw	r24, r16
    27be:	0e 94 81 1b 	call	0x3702	; 0x3702 <vPortFree>
    27c2:	c0 e0       	ldi	r28, 0x00	; 0
    27c4:	d0 e0       	ldi	r29, 0x00	; 0
	}

	/* Will only reach here if we could not allocate enough memory or no memory
	was required. */
	return NULL;
}
    27c6:	ce 01       	movw	r24, r28
    27c8:	df 91       	pop	r29
    27ca:	cf 91       	pop	r28
    27cc:	1f 91       	pop	r17
    27ce:	0f 91       	pop	r16
    27d0:	ff 90       	pop	r15
    27d2:	ef 90       	pop	r14
    27d4:	df 90       	pop	r13
    27d6:	cf 90       	pop	r12
    27d8:	bf 90       	pop	r11
    27da:	af 90       	pop	r10
    27dc:	9f 90       	pop	r9
    27de:	8f 90       	pop	r8
    27e0:	08 95       	ret

000027e2 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    27e2:	80 91 35 03 	lds	r24, 0x0335
    27e6:	8f 5f       	subi	r24, 0xFF	; 255
    27e8:	80 93 35 03 	sts	0x0335, r24
}
    27ec:	08 95       	ret

000027ee <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portENTER_CRITICAL();
    27ee:	0f b6       	in	r0, 0x3f	; 63
    27f0:	f8 94       	cli
    27f2:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    27f4:	20 91 33 03 	lds	r18, 0x0333
    27f8:	30 91 34 03 	lds	r19, 0x0334
	}
	portEXIT_CRITICAL();
    27fc:	0f 90       	pop	r0
    27fe:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    2800:	c9 01       	movw	r24, r18
    2802:	08 95       	ret

00002804 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
	return xTickCount;
    2804:	20 91 33 03 	lds	r18, 0x0333
    2808:	30 91 34 03 	lds	r19, 0x0334
}
    280c:	c9 01       	movw	r24, r18
    280e:	08 95       	ret

00002810 <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    2810:	80 91 38 03 	lds	r24, 0x0338
}
    2814:	08 95       	ret

00002816 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2816:	80 91 35 03 	lds	r24, 0x0335
    281a:	88 23       	and	r24, r24
    281c:	51 f0       	breq	.+20     	; 0x2832 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    281e:	81 e0       	ldi	r24, 0x01	; 1
    2820:	80 93 31 03 	sts	0x0331, r24
    2824:	08 95       	ret
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
	{
		--uxTopReadyPriority;
    2826:	80 91 36 03 	lds	r24, 0x0336
    282a:	81 50       	subi	r24, 0x01	; 1
    282c:	80 93 36 03 	sts	0x0336, r24
    2830:	01 c0       	rjmp	.+2      	; 0x2834 <vTaskSwitchContext+0x1e>

	taskFIRST_CHECK_FOR_STACK_OVERFLOW();
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2832:	99 e0       	ldi	r25, 0x09	; 9
    2834:	e0 91 36 03 	lds	r30, 0x0336
    2838:	e9 9f       	mul	r30, r25
    283a:	f0 01       	movw	r30, r0
    283c:	11 24       	eor	r1, r1
    283e:	e3 5c       	subi	r30, 0xC3	; 195
    2840:	fc 4f       	sbci	r31, 0xFC	; 252
    2842:	80 81       	ld	r24, Z
    2844:	88 23       	and	r24, r24
    2846:	79 f3       	breq	.-34     	; 0x2826 <vTaskSwitchContext+0x10>
		--uxTopReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2848:	90 91 36 03 	lds	r25, 0x0336
    284c:	89 e0       	ldi	r24, 0x09	; 9
    284e:	98 9f       	mul	r25, r24
    2850:	d0 01       	movw	r26, r0
    2852:	11 24       	eor	r1, r1
    2854:	a3 5c       	subi	r26, 0xC3	; 195
    2856:	bc 4f       	sbci	r27, 0xFC	; 252
    2858:	11 96       	adiw	r26, 0x01	; 1
    285a:	ed 91       	ld	r30, X+
    285c:	fc 91       	ld	r31, X
    285e:	12 97       	sbiw	r26, 0x02	; 2
    2860:	02 80       	ldd	r0, Z+2	; 0x02
    2862:	f3 81       	ldd	r31, Z+3	; 0x03
    2864:	e0 2d       	mov	r30, r0
    2866:	12 96       	adiw	r26, 0x02	; 2
    2868:	fc 93       	st	X, r31
    286a:	ee 93       	st	-X, r30
    286c:	11 97       	sbiw	r26, 0x01	; 1
    286e:	cd 01       	movw	r24, r26
    2870:	03 96       	adiw	r24, 0x03	; 3
    2872:	e8 17       	cp	r30, r24
    2874:	f9 07       	cpc	r31, r25
    2876:	31 f4       	brne	.+12     	; 0x2884 <vTaskSwitchContext+0x6e>
    2878:	82 81       	ldd	r24, Z+2	; 0x02
    287a:	93 81       	ldd	r25, Z+3	; 0x03
    287c:	12 96       	adiw	r26, 0x02	; 2
    287e:	9c 93       	st	X, r25
    2880:	8e 93       	st	-X, r24
    2882:	11 97       	sbiw	r26, 0x01	; 1
    2884:	11 96       	adiw	r26, 0x01	; 1
    2886:	ed 91       	ld	r30, X+
    2888:	fc 91       	ld	r31, X
    288a:	12 97       	sbiw	r26, 0x02	; 2
    288c:	86 81       	ldd	r24, Z+6	; 0x06
    288e:	97 81       	ldd	r25, Z+7	; 0x07
    2890:	90 93 30 03 	sts	0x0330, r25
    2894:	80 93 2f 03 	sts	0x032F, r24
    2898:	08 95       	ret

0000289a <vTaskSetTimeOutState>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    289a:	fc 01       	movw	r30, r24
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    289c:	80 91 32 03 	lds	r24, 0x0332
    28a0:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    28a2:	80 91 33 03 	lds	r24, 0x0333
    28a6:	90 91 34 03 	lds	r25, 0x0334
    28aa:	92 83       	std	Z+2, r25	; 0x02
    28ac:	81 83       	std	Z+1, r24	; 0x01
}
    28ae:	08 95       	ret

000028b0 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    28b0:	fc 01       	movw	r30, r24
    28b2:	db 01       	movw	r26, r22
portBASE_TYPE xReturn;

	portENTER_CRITICAL();
    28b4:	0f b6       	in	r0, 0x3f	; 63
    28b6:	f8 94       	cli
    28b8:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    28ba:	90 91 32 03 	lds	r25, 0x0332
    28be:	80 81       	ld	r24, Z
    28c0:	98 17       	cp	r25, r24
    28c2:	49 f0       	breq	.+18     	; 0x28d6 <xTaskCheckForTimeOut+0x26>
    28c4:	20 91 33 03 	lds	r18, 0x0333
    28c8:	30 91 34 03 	lds	r19, 0x0334
    28cc:	81 81       	ldd	r24, Z+1	; 0x01
    28ce:	92 81       	ldd	r25, Z+2	; 0x02
    28d0:	28 17       	cp	r18, r24
    28d2:	39 07       	cpc	r19, r25
    28d4:	18 f5       	brcc	.+70     	; 0x291c <xTaskCheckForTimeOut+0x6c>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    28d6:	80 91 33 03 	lds	r24, 0x0333
    28da:	90 91 34 03 	lds	r25, 0x0334
    28de:	21 81       	ldd	r18, Z+1	; 0x01
    28e0:	32 81       	ldd	r19, Z+2	; 0x02
    28e2:	4d 91       	ld	r20, X+
    28e4:	5c 91       	ld	r21, X
    28e6:	11 97       	sbiw	r26, 0x01	; 1
    28e8:	82 1b       	sub	r24, r18
    28ea:	93 0b       	sbc	r25, r19
    28ec:	84 17       	cp	r24, r20
    28ee:	95 07       	cpc	r25, r21
    28f0:	a8 f4       	brcc	.+42     	; 0x291c <xTaskCheckForTimeOut+0x6c>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    28f2:	80 91 33 03 	lds	r24, 0x0333
    28f6:	90 91 34 03 	lds	r25, 0x0334
    28fa:	28 1b       	sub	r18, r24
    28fc:	39 0b       	sbc	r19, r25
    28fe:	24 0f       	add	r18, r20
    2900:	35 1f       	adc	r19, r21
    2902:	2d 93       	st	X+, r18
    2904:	3c 93       	st	X, r19
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2906:	80 91 32 03 	lds	r24, 0x0332
    290a:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    290c:	80 91 33 03 	lds	r24, 0x0333
    2910:	90 91 34 03 	lds	r25, 0x0334
    2914:	92 83       	std	Z+2, r25	; 0x02
    2916:	81 83       	std	Z+1, r24	; 0x01
    2918:	80 e0       	ldi	r24, 0x00	; 0
    291a:	01 c0       	rjmp	.+2      	; 0x291e <xTaskCheckForTimeOut+0x6e>
    291c:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			xReturn = pdTRUE;
		}
	}
	portEXIT_CRITICAL();
    291e:	0f 90       	pop	r0
    2920:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2922:	08 95       	ret

00002924 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    2924:	81 e0       	ldi	r24, 0x01	; 1
    2926:	80 93 31 03 	sts	0x0331, r24
}
    292a:	08 95       	ret

0000292c <xTaskRemoveFromEventList>:
	#endif
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    292c:	0f 93       	push	r16
    292e:	1f 93       	push	r17
    2930:	cf 93       	push	r28
    2932:	df 93       	push	r29
    2934:	fc 01       	movw	r30, r24
	it to the ready list.

	If an event is for a queue that is locked then this function will never
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2936:	80 81       	ld	r24, Z
    2938:	88 23       	and	r24, r24
    293a:	19 f4       	brne	.+6      	; 0x2942 <xTaskRemoveFromEventList+0x16>
    293c:	c0 e0       	ldi	r28, 0x00	; 0
    293e:	d0 e0       	ldi	r29, 0x00	; 0
    2940:	05 c0       	rjmp	.+10     	; 0x294c <xTaskRemoveFromEventList+0x20>
    2942:	05 80       	ldd	r0, Z+5	; 0x05
    2944:	f6 81       	ldd	r31, Z+6	; 0x06
    2946:	e0 2d       	mov	r30, r0
    2948:	c6 81       	ldd	r28, Z+6	; 0x06
    294a:	d7 81       	ldd	r29, Z+7	; 0x07
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    294c:	8e 01       	movw	r16, r28
    294e:	04 5f       	subi	r16, 0xF4	; 244
    2950:	1f 4f       	sbci	r17, 0xFF	; 255
    2952:	c8 01       	movw	r24, r16
    2954:	0e 94 e4 10 	call	0x21c8	; 0x21c8 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2958:	80 91 35 03 	lds	r24, 0x0335
    295c:	88 23       	and	r24, r24
    295e:	a1 f4       	brne	.+40     	; 0x2988 <xTaskRemoveFromEventList+0x5c>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2960:	8e 01       	movw	r16, r28
    2962:	0e 5f       	subi	r16, 0xFE	; 254
    2964:	1f 4f       	sbci	r17, 0xFF	; 255
    2966:	c8 01       	movw	r24, r16
    2968:	0e 94 e4 10 	call	0x21c8	; 0x21c8 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    296c:	9e 89       	ldd	r25, Y+22	; 0x16
    296e:	80 91 36 03 	lds	r24, 0x0336
    2972:	89 17       	cp	r24, r25
    2974:	10 f4       	brcc	.+4      	; 0x297a <xTaskRemoveFromEventList+0x4e>
    2976:	90 93 36 03 	sts	0x0336, r25
    297a:	89 e0       	ldi	r24, 0x09	; 9
    297c:	98 9f       	mul	r25, r24
    297e:	c0 01       	movw	r24, r0
    2980:	11 24       	eor	r1, r1
    2982:	83 5c       	subi	r24, 0xC3	; 195
    2984:	9c 4f       	sbci	r25, 0xFC	; 252
    2986:	02 c0       	rjmp	.+4      	; 0x298c <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2988:	87 e7       	ldi	r24, 0x77	; 119
    298a:	93 e0       	ldi	r25, 0x03	; 3
    298c:	b8 01       	movw	r22, r16
    298e:	0e 94 86 10 	call	0x210c	; 0x210c <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2992:	e0 91 2f 03 	lds	r30, 0x032F
    2996:	f0 91 30 03 	lds	r31, 0x0330
    299a:	20 e0       	ldi	r18, 0x00	; 0
    299c:	9e 89       	ldd	r25, Y+22	; 0x16
    299e:	86 89       	ldd	r24, Z+22	; 0x16
    29a0:	98 17       	cp	r25, r24
    29a2:	08 f0       	brcs	.+2      	; 0x29a6 <xTaskRemoveFromEventList+0x7a>
    29a4:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    29a6:	82 2f       	mov	r24, r18
    29a8:	df 91       	pop	r29
    29aa:	cf 91       	pop	r28
    29ac:	1f 91       	pop	r17
    29ae:	0f 91       	pop	r16
    29b0:	08 95       	ret

000029b2 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
    29b2:	ff 92       	push	r15
    29b4:	0f 93       	push	r16
    29b6:	1f 93       	push	r17
    29b8:	cf 93       	push	r28
    29ba:	df 93       	push	r29
	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    29bc:	80 91 35 03 	lds	r24, 0x0335
    29c0:	88 23       	and	r24, r24
    29c2:	09 f0       	breq	.+2      	; 0x29c6 <vTaskIncrementTick+0x14>
    29c4:	61 c0       	rjmp	.+194    	; 0x2a88 <vTaskIncrementTick+0xd6>
	{
		++xTickCount;
    29c6:	80 91 33 03 	lds	r24, 0x0333
    29ca:	90 91 34 03 	lds	r25, 0x0334
    29ce:	01 96       	adiw	r24, 0x01	; 1
    29d0:	90 93 34 03 	sts	0x0334, r25
    29d4:	80 93 33 03 	sts	0x0333, r24
		if( xTickCount == ( portTickType ) 0 )
    29d8:	80 91 33 03 	lds	r24, 0x0333
    29dc:	90 91 34 03 	lds	r25, 0x0334
    29e0:	89 2b       	or	r24, r25
    29e2:	e9 f5       	brne	.+122    	; 0x2a5e <vTaskIncrementTick+0xac>
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			pxTemp = pxDelayedTaskList;
    29e4:	80 91 73 03 	lds	r24, 0x0373
    29e8:	90 91 74 03 	lds	r25, 0x0374
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    29ec:	20 91 75 03 	lds	r18, 0x0375
    29f0:	30 91 76 03 	lds	r19, 0x0376
    29f4:	30 93 74 03 	sts	0x0374, r19
    29f8:	20 93 73 03 	sts	0x0373, r18
			pxOverflowDelayedTaskList = pxTemp;
    29fc:	90 93 76 03 	sts	0x0376, r25
    2a00:	80 93 75 03 	sts	0x0375, r24
			xNumOfOverflows++;
    2a04:	80 91 32 03 	lds	r24, 0x0332
    2a08:	8f 5f       	subi	r24, 0xFF	; 255
    2a0a:	80 93 32 03 	sts	0x0332, r24
    2a0e:	27 c0       	rjmp	.+78     	; 0x2a5e <vTaskIncrementTick+0xac>
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    2a10:	20 91 33 03 	lds	r18, 0x0333
    2a14:	30 91 34 03 	lds	r19, 0x0334
    2a18:	8a 81       	ldd	r24, Y+2	; 0x02
    2a1a:	9b 81       	ldd	r25, Y+3	; 0x03
    2a1c:	28 17       	cp	r18, r24
    2a1e:	39 07       	cpc	r19, r25
    2a20:	c0 f1       	brcs	.+112    	; 0x2a92 <vTaskIncrementTick+0xe0>
    2a22:	8e 01       	movw	r16, r28
    2a24:	0e 5f       	subi	r16, 0xFE	; 254
    2a26:	1f 4f       	sbci	r17, 0xFF	; 255
    2a28:	c8 01       	movw	r24, r16
    2a2a:	0e 94 e4 10 	call	0x21c8	; 0x21c8 <vListRemove>
    2a2e:	8c 89       	ldd	r24, Y+20	; 0x14
    2a30:	9d 89       	ldd	r25, Y+21	; 0x15
    2a32:	89 2b       	or	r24, r25
    2a34:	21 f0       	breq	.+8      	; 0x2a3e <vTaskIncrementTick+0x8c>
    2a36:	ce 01       	movw	r24, r28
    2a38:	0c 96       	adiw	r24, 0x0c	; 12
    2a3a:	0e 94 e4 10 	call	0x21c8	; 0x21c8 <vListRemove>
    2a3e:	9e 89       	ldd	r25, Y+22	; 0x16
    2a40:	80 91 36 03 	lds	r24, 0x0336
    2a44:	89 17       	cp	r24, r25
    2a46:	10 f4       	brcc	.+4      	; 0x2a4c <vTaskIncrementTick+0x9a>
    2a48:	90 93 36 03 	sts	0x0336, r25
    2a4c:	9f 9d       	mul	r25, r15
    2a4e:	c0 01       	movw	r24, r0
    2a50:	11 24       	eor	r1, r1
    2a52:	83 5c       	subi	r24, 0xC3	; 195
    2a54:	9c 4f       	sbci	r25, 0xFC	; 252
    2a56:	b8 01       	movw	r22, r16
    2a58:	0e 94 86 10 	call	0x210c	; 0x210c <vListInsertEnd>
    2a5c:	02 c0       	rjmp	.+4      	; 0x2a62 <vTaskIncrementTick+0xb0>
    2a5e:	89 e0       	ldi	r24, 0x09	; 9
    2a60:	f8 2e       	mov	r15, r24
    2a62:	e0 91 73 03 	lds	r30, 0x0373
    2a66:	f0 91 74 03 	lds	r31, 0x0374
    2a6a:	80 81       	ld	r24, Z
    2a6c:	88 23       	and	r24, r24
    2a6e:	89 f0       	breq	.+34     	; 0x2a92 <vTaskIncrementTick+0xe0>
    2a70:	e0 91 73 03 	lds	r30, 0x0373
    2a74:	f0 91 74 03 	lds	r31, 0x0374
    2a78:	05 80       	ldd	r0, Z+5	; 0x05
    2a7a:	f6 81       	ldd	r31, Z+6	; 0x06
    2a7c:	e0 2d       	mov	r30, r0
    2a7e:	c6 81       	ldd	r28, Z+6	; 0x06
    2a80:	d7 81       	ldd	r29, Z+7	; 0x07
    2a82:	20 97       	sbiw	r28, 0x00	; 0
    2a84:	29 f6       	brne	.-118    	; 0x2a10 <vTaskIncrementTick+0x5e>
    2a86:	05 c0       	rjmp	.+10     	; 0x2a92 <vTaskIncrementTick+0xe0>
	}
	else
	{
		++uxMissedTicks;
    2a88:	80 91 37 03 	lds	r24, 0x0337
    2a8c:	8f 5f       	subi	r24, 0xFF	; 255
    2a8e:	80 93 37 03 	sts	0x0337, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    2a92:	df 91       	pop	r29
    2a94:	cf 91       	pop	r28
    2a96:	1f 91       	pop	r17
    2a98:	0f 91       	pop	r16
    2a9a:	ff 90       	pop	r15
    2a9c:	08 95       	ret

00002a9e <vTaskPlaceOnEventList>:
	vWriteTraceToBuffer();
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2a9e:	0f 93       	push	r16
    2aa0:	1f 93       	push	r17
    2aa2:	8b 01       	movw	r16, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    2aa4:	60 91 2f 03 	lds	r22, 0x032F
    2aa8:	70 91 30 03 	lds	r23, 0x0330
    2aac:	64 5f       	subi	r22, 0xF4	; 244
    2aae:	7f 4f       	sbci	r23, 0xFF	; 255
    2ab0:	0e 94 af 10 	call	0x215e	; 0x215e <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2ab4:	80 91 2f 03 	lds	r24, 0x032F
    2ab8:	90 91 30 03 	lds	r25, 0x0330
    2abc:	02 96       	adiw	r24, 0x02	; 2
    2abe:	0e 94 e4 10 	call	0x21c8	; 0x21c8 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    2ac2:	80 91 33 03 	lds	r24, 0x0333
    2ac6:	90 91 34 03 	lds	r25, 0x0334
    2aca:	80 0f       	add	r24, r16
    2acc:	91 1f       	adc	r25, r17

			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    2ace:	e0 91 2f 03 	lds	r30, 0x032F
    2ad2:	f0 91 30 03 	lds	r31, 0x0330
    2ad6:	93 83       	std	Z+3, r25	; 0x03
    2ad8:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xTickCount )
    2ada:	20 91 33 03 	lds	r18, 0x0333
    2ade:	30 91 34 03 	lds	r19, 0x0334
    2ae2:	82 17       	cp	r24, r18
    2ae4:	93 07       	cpc	r25, r19
    2ae6:	28 f4       	brcc	.+10     	; 0x2af2 <vTaskPlaceOnEventList+0x54>
			{
				/* Wake time has overflowed.  Place this item in the overflow list. */
				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2ae8:	80 91 75 03 	lds	r24, 0x0375
    2aec:	90 91 76 03 	lds	r25, 0x0376
    2af0:	04 c0       	rjmp	.+8      	; 0x2afa <vTaskPlaceOnEventList+0x5c>
			}
			else
			{
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2af2:	80 91 73 03 	lds	r24, 0x0373
    2af6:	90 91 74 03 	lds	r25, 0x0374
    2afa:	60 91 2f 03 	lds	r22, 0x032F
    2afe:	70 91 30 03 	lds	r23, 0x0330
    2b02:	6e 5f       	subi	r22, 0xFE	; 254
    2b04:	7f 4f       	sbci	r23, 0xFF	; 255
    2b06:	0e 94 af 10 	call	0x215e	; 0x215e <vListInsert>
			}
	}
	#endif
}
    2b0a:	1f 91       	pop	r17
    2b0c:	0f 91       	pop	r16
    2b0e:	08 95       	ret

00002b10 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    2b10:	cf 92       	push	r12
    2b12:	df 92       	push	r13
    2b14:	ff 92       	push	r15
    2b16:	0f 93       	push	r16
    2b18:	1f 93       	push	r17
    2b1a:	df 93       	push	r29
    2b1c:	cf 93       	push	r28
    2b1e:	0f 92       	push	r0
    2b20:	cd b7       	in	r28, 0x3d	; 61
    2b22:	de b7       	in	r29, 0x3e	; 62
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	portENTER_CRITICAL();
    2b24:	0f b6       	in	r0, 0x3f	; 63
    2b26:	f8 94       	cli
    2b28:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2b2a:	80 91 35 03 	lds	r24, 0x0335
    2b2e:	81 50       	subi	r24, 0x01	; 1
    2b30:	80 93 35 03 	sts	0x0335, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2b34:	80 91 35 03 	lds	r24, 0x0335
    2b38:	88 23       	and	r24, r24
    2b3a:	09 f0       	breq	.+2      	; 0x2b3e <xTaskResumeAll+0x2e>
    2b3c:	5b c0       	rjmp	.+182    	; 0x2bf4 <xTaskResumeAll+0xe4>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
    2b3e:	80 91 38 03 	lds	r24, 0x0338
    2b42:	88 23       	and	r24, r24
    2b44:	09 f4       	brne	.+2      	; 0x2b48 <xTaskResumeAll+0x38>
    2b46:	56 c0       	rjmp	.+172    	; 0x2bf4 <xTaskResumeAll+0xe4>
    2b48:	19 82       	std	Y+1, r1	; 0x01
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    2b4a:	99 e0       	ldi	r25, 0x09	; 9
    2b4c:	f9 2e       	mov	r15, r25
    2b4e:	27 c0       	rjmp	.+78     	; 0x2b9e <xTaskResumeAll+0x8e>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
    2b50:	c6 01       	movw	r24, r12
    2b52:	0c 96       	adiw	r24, 0x0c	; 12
    2b54:	0e 94 e4 10 	call	0x21c8	; 0x21c8 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    2b58:	86 01       	movw	r16, r12
    2b5a:	0e 5f       	subi	r16, 0xFE	; 254
    2b5c:	1f 4f       	sbci	r17, 0xFF	; 255
    2b5e:	c8 01       	movw	r24, r16
    2b60:	0e 94 e4 10 	call	0x21c8	; 0x21c8 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    2b64:	d6 01       	movw	r26, r12
    2b66:	56 96       	adiw	r26, 0x16	; 22
    2b68:	9c 91       	ld	r25, X
    2b6a:	80 91 36 03 	lds	r24, 0x0336
    2b6e:	89 17       	cp	r24, r25
    2b70:	10 f4       	brcc	.+4      	; 0x2b76 <xTaskResumeAll+0x66>
    2b72:	90 93 36 03 	sts	0x0336, r25
    2b76:	9f 9d       	mul	r25, r15
    2b78:	c0 01       	movw	r24, r0
    2b7a:	11 24       	eor	r1, r1
    2b7c:	83 5c       	subi	r24, 0xC3	; 195
    2b7e:	9c 4f       	sbci	r25, 0xFC	; 252
    2b80:	b8 01       	movw	r22, r16
    2b82:	0e 94 86 10 	call	0x210c	; 0x210c <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2b86:	e0 91 2f 03 	lds	r30, 0x032F
    2b8a:	f0 91 30 03 	lds	r31, 0x0330
    2b8e:	d6 01       	movw	r26, r12
    2b90:	56 96       	adiw	r26, 0x16	; 22
    2b92:	9c 91       	ld	r25, X
    2b94:	86 89       	ldd	r24, Z+22	; 0x16
    2b96:	98 17       	cp	r25, r24
    2b98:	10 f0       	brcs	.+4      	; 0x2b9e <xTaskResumeAll+0x8e>
    2b9a:	b1 e0       	ldi	r27, 0x01	; 1
    2b9c:	b9 83       	std	Y+1, r27	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
    2b9e:	80 91 77 03 	lds	r24, 0x0377
    2ba2:	88 23       	and	r24, r24
    2ba4:	49 f0       	breq	.+18     	; 0x2bb8 <xTaskResumeAll+0xa8>
    2ba6:	e0 91 7c 03 	lds	r30, 0x037C
    2baa:	f0 91 7d 03 	lds	r31, 0x037D
    2bae:	c6 80       	ldd	r12, Z+6	; 0x06
    2bb0:	d7 80       	ldd	r13, Z+7	; 0x07
    2bb2:	c1 14       	cp	r12, r1
    2bb4:	d1 04       	cpc	r13, r1
    2bb6:	61 f6       	brne	.-104    	; 0x2b50 <xTaskResumeAll+0x40>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    2bb8:	80 91 37 03 	lds	r24, 0x0337
    2bbc:	88 23       	and	r24, r24
    2bbe:	41 f4       	brne	.+16     	; 0x2bd0 <xTaskResumeAll+0xc0>
    2bc0:	0c c0       	rjmp	.+24     	; 0x2bda <xTaskResumeAll+0xca>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
    2bc2:	0e 94 d9 14 	call	0x29b2	; 0x29b2 <vTaskIncrementTick>
						--uxMissedTicks;
    2bc6:	80 91 37 03 	lds	r24, 0x0337
    2bca:	81 50       	subi	r24, 0x01	; 1
    2bcc:	80 93 37 03 	sts	0x0337, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    2bd0:	80 91 37 03 	lds	r24, 0x0337
    2bd4:	88 23       	and	r24, r24
    2bd6:	a9 f7       	brne	.-22     	; 0x2bc2 <xTaskResumeAll+0xb2>
    2bd8:	07 c0       	rjmp	.+14     	; 0x2be8 <xTaskResumeAll+0xd8>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    2bda:	e9 81       	ldd	r30, Y+1	; 0x01
    2bdc:	e1 30       	cpi	r30, 0x01	; 1
    2bde:	21 f0       	breq	.+8      	; 0x2be8 <xTaskResumeAll+0xd8>
    2be0:	80 91 31 03 	lds	r24, 0x0331
    2be4:	81 30       	cpi	r24, 0x01	; 1
    2be6:	31 f4       	brne	.+12     	; 0x2bf4 <xTaskResumeAll+0xe4>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    2be8:	10 92 31 03 	sts	0x0331, r1
					portYIELD_WITHIN_API();
    2bec:	0e 94 5e 19 	call	0x32bc	; 0x32bc <vPortYield>
    2bf0:	81 e0       	ldi	r24, 0x01	; 1
    2bf2:	01 c0       	rjmp	.+2      	; 0x2bf6 <xTaskResumeAll+0xe6>
    2bf4:	80 e0       	ldi	r24, 0x00	; 0
				}
			}
		}
	}
	portEXIT_CRITICAL();
    2bf6:	0f 90       	pop	r0
    2bf8:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    2bfa:	0f 90       	pop	r0
    2bfc:	cf 91       	pop	r28
    2bfe:	df 91       	pop	r29
    2c00:	1f 91       	pop	r17
    2c02:	0f 91       	pop	r16
    2c04:	ff 90       	pop	r15
    2c06:	df 90       	pop	r13
    2c08:	cf 90       	pop	r12
    2c0a:	08 95       	ret

00002c0c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    2c0c:	0f 93       	push	r16
    2c0e:	1f 93       	push	r17
    2c10:	9c 01       	movw	r18, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
    2c12:	00 97       	sbiw	r24, 0x00	; 0
    2c14:	a1 f1       	breq	.+104    	; 0x2c7e <vTaskDelay+0x72>

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    2c16:	80 91 35 03 	lds	r24, 0x0335
    2c1a:	8f 5f       	subi	r24, 0xFF	; 255
    2c1c:	80 93 35 03 	sts	0x0335, r24
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2c20:	00 91 33 03 	lds	r16, 0x0333
    2c24:	10 91 34 03 	lds	r17, 0x0334
    2c28:	02 0f       	add	r16, r18
    2c2a:	13 1f       	adc	r17, r19

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2c2c:	80 91 2f 03 	lds	r24, 0x032F
    2c30:	90 91 30 03 	lds	r25, 0x0330
    2c34:	02 96       	adiw	r24, 0x02	; 2
    2c36:	0e 94 e4 10 	call	0x21c8	; 0x21c8 <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    2c3a:	e0 91 2f 03 	lds	r30, 0x032F
    2c3e:	f0 91 30 03 	lds	r31, 0x0330
    2c42:	13 83       	std	Z+3, r17	; 0x03
    2c44:	02 83       	std	Z+2, r16	; 0x02

				if( xTimeToWake < xTickCount )
    2c46:	80 91 33 03 	lds	r24, 0x0333
    2c4a:	90 91 34 03 	lds	r25, 0x0334
    2c4e:	08 17       	cp	r16, r24
    2c50:	19 07       	cpc	r17, r25
    2c52:	28 f4       	brcc	.+10     	; 0x2c5e <vTaskDelay+0x52>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2c54:	80 91 75 03 	lds	r24, 0x0375
    2c58:	90 91 76 03 	lds	r25, 0x0376
    2c5c:	04 c0       	rjmp	.+8      	; 0x2c66 <vTaskDelay+0x5a>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2c5e:	80 91 73 03 	lds	r24, 0x0373
    2c62:	90 91 74 03 	lds	r25, 0x0374
    2c66:	60 91 2f 03 	lds	r22, 0x032F
    2c6a:	70 91 30 03 	lds	r23, 0x0330
    2c6e:	6e 5f       	subi	r22, 0xFE	; 254
    2c70:	7f 4f       	sbci	r23, 0xFF	; 255
    2c72:	0e 94 af 10 	call	0x215e	; 0x215e <vListInsert>
				}
			}
			xAlreadyYielded = xTaskResumeAll();
    2c76:	0e 94 88 15 	call	0x2b10	; 0x2b10 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
    2c7a:	88 23       	and	r24, r24
    2c7c:	11 f4       	brne	.+4      	; 0x2c82 <vTaskDelay+0x76>
		{
			portYIELD_WITHIN_API();
    2c7e:	0e 94 5e 19 	call	0x32bc	; 0x32bc <vPortYield>
		}
	}
    2c82:	1f 91       	pop	r17
    2c84:	0f 91       	pop	r16
    2c86:	08 95       	ret

00002c88 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    2c88:	cf 93       	push	r28
    2c8a:	df 93       	push	r29
    2c8c:	fc 01       	movw	r30, r24
    2c8e:	eb 01       	movw	r28, r22

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    2c90:	80 91 35 03 	lds	r24, 0x0335
    2c94:	8f 5f       	subi	r24, 0xFF	; 255
    2c96:	80 93 35 03 	sts	0x0335, r24
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		vTaskSuspendAll();
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2c9a:	20 81       	ld	r18, Z
    2c9c:	31 81       	ldd	r19, Z+1	; 0x01
    2c9e:	c2 0f       	add	r28, r18
    2ca0:	d3 1f       	adc	r29, r19

			if( xTickCount < *pxPreviousWakeTime )
    2ca2:	80 91 33 03 	lds	r24, 0x0333
    2ca6:	90 91 34 03 	lds	r25, 0x0334
    2caa:	82 17       	cp	r24, r18
    2cac:	93 07       	cpc	r25, r19
    2cae:	28 f4       	brcc	.+10     	; 0x2cba <vTaskDelayUntil+0x32>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    2cb0:	c2 17       	cp	r28, r18
    2cb2:	d3 07       	cpc	r29, r19
    2cb4:	28 f0       	brcs	.+10     	; 0x2cc0 <vTaskDelayUntil+0x38>
    2cb6:	20 e0       	ldi	r18, 0x00	; 0
    2cb8:	0c c0       	rjmp	.+24     	; 0x2cd2 <vTaskDelayUntil+0x4a>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    2cba:	c2 17       	cp	r28, r18
    2cbc:	d3 07       	cpc	r29, r19
    2cbe:	40 f0       	brcs	.+16     	; 0x2cd0 <vTaskDelayUntil+0x48>
    2cc0:	80 91 33 03 	lds	r24, 0x0333
    2cc4:	90 91 34 03 	lds	r25, 0x0334
    2cc8:	20 e0       	ldi	r18, 0x00	; 0
    2cca:	8c 17       	cp	r24, r28
    2ccc:	9d 07       	cpc	r25, r29
    2cce:	08 f4       	brcc	.+2      	; 0x2cd2 <vTaskDelayUntil+0x4a>
    2cd0:	21 e0       	ldi	r18, 0x01	; 1
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2cd2:	d1 83       	std	Z+1, r29	; 0x01
    2cd4:	c0 83       	st	Z, r28

			if( xShouldDelay )
    2cd6:	22 23       	and	r18, r18
    2cd8:	29 f1       	breq	.+74     	; 0x2d24 <vTaskDelayUntil+0x9c>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2cda:	80 91 2f 03 	lds	r24, 0x032F
    2cde:	90 91 30 03 	lds	r25, 0x0330
    2ce2:	02 96       	adiw	r24, 0x02	; 2
    2ce4:	0e 94 e4 10 	call	0x21c8	; 0x21c8 <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    2ce8:	e0 91 2f 03 	lds	r30, 0x032F
    2cec:	f0 91 30 03 	lds	r31, 0x0330
    2cf0:	d3 83       	std	Z+3, r29	; 0x03
    2cf2:	c2 83       	std	Z+2, r28	; 0x02

				if( xTimeToWake < xTickCount )
    2cf4:	80 91 33 03 	lds	r24, 0x0333
    2cf8:	90 91 34 03 	lds	r25, 0x0334
    2cfc:	c8 17       	cp	r28, r24
    2cfe:	d9 07       	cpc	r29, r25
    2d00:	28 f4       	brcc	.+10     	; 0x2d0c <vTaskDelayUntil+0x84>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2d02:	80 91 75 03 	lds	r24, 0x0375
    2d06:	90 91 76 03 	lds	r25, 0x0376
    2d0a:	04 c0       	rjmp	.+8      	; 0x2d14 <vTaskDelayUntil+0x8c>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2d0c:	80 91 73 03 	lds	r24, 0x0373
    2d10:	90 91 74 03 	lds	r25, 0x0374
    2d14:	60 91 2f 03 	lds	r22, 0x032F
    2d18:	70 91 30 03 	lds	r23, 0x0330
    2d1c:	6e 5f       	subi	r22, 0xFE	; 254
    2d1e:	7f 4f       	sbci	r23, 0xFF	; 255
    2d20:	0e 94 af 10 	call	0x215e	; 0x215e <vListInsert>
				}
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    2d24:	0e 94 88 15 	call	0x2b10	; 0x2b10 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
    2d28:	88 23       	and	r24, r24
    2d2a:	11 f4       	brne	.+4      	; 0x2d30 <vTaskDelayUntil+0xa8>
		{
			portYIELD_WITHIN_API();
    2d2c:	0e 94 5e 19 	call	0x32bc	; 0x32bc <vPortYield>
		}
	}
    2d30:	df 91       	pop	r29
    2d32:	cf 91       	pop	r28
    2d34:	08 95       	ret

00002d36 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    2d36:	ef 92       	push	r14
    2d38:	ff 92       	push	r15
    2d3a:	0f 93       	push	r16
    2d3c:	1f 93       	push	r17
    2d3e:	cf 93       	push	r28
    2d40:	df 93       	push	r29
    2d42:	8c 01       	movw	r16, r24
	tskTCB *pxTCB;

		portENTER_CRITICAL();
    2d44:	0f b6       	in	r0, 0x3f	; 63
    2d46:	f8 94       	cli
    2d48:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    2d4a:	80 91 2f 03 	lds	r24, 0x032F
    2d4e:	90 91 30 03 	lds	r25, 0x0330
    2d52:	08 17       	cp	r16, r24
    2d54:	19 07       	cpc	r17, r25
    2d56:	19 f4       	brne	.+6      	; 0x2d5e <vTaskDelete+0x28>
    2d58:	00 e0       	ldi	r16, 0x00	; 0
    2d5a:	10 e0       	ldi	r17, 0x00	; 0
    2d5c:	03 c0       	rjmp	.+6      	; 0x2d64 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    2d5e:	01 15       	cp	r16, r1
    2d60:	11 05       	cpc	r17, r1
    2d62:	29 f4       	brne	.+10     	; 0x2d6e <vTaskDelete+0x38>
    2d64:	c0 91 2f 03 	lds	r28, 0x032F
    2d68:	d0 91 30 03 	lds	r29, 0x0330
    2d6c:	01 c0       	rjmp	.+2      	; 0x2d70 <vTaskDelete+0x3a>
    2d6e:	e8 01       	movw	r28, r16

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    2d70:	22 e0       	ldi	r18, 0x02	; 2
    2d72:	e2 2e       	mov	r14, r18
    2d74:	f1 2c       	mov	r15, r1
    2d76:	ec 0e       	add	r14, r28
    2d78:	fd 1e       	adc	r15, r29
    2d7a:	c7 01       	movw	r24, r14
    2d7c:	0e 94 e4 10 	call	0x21c8	; 0x21c8 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer )
    2d80:	8c 89       	ldd	r24, Y+20	; 0x14
    2d82:	9d 89       	ldd	r25, Y+21	; 0x15
    2d84:	89 2b       	or	r24, r25
    2d86:	21 f0       	breq	.+8      	; 0x2d90 <vTaskDelete+0x5a>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    2d88:	ce 01       	movw	r24, r28
    2d8a:	0c 96       	adiw	r24, 0x0c	; 12
    2d8c:	0e 94 e4 10 	call	0x21c8	; 0x21c8 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    2d90:	80 e8       	ldi	r24, 0x80	; 128
    2d92:	93 e0       	ldi	r25, 0x03	; 3
    2d94:	b7 01       	movw	r22, r14
    2d96:	0e 94 86 10 	call	0x210c	; 0x210c <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    2d9a:	80 91 3a 03 	lds	r24, 0x033A
    2d9e:	8f 5f       	subi	r24, 0xFF	; 255
    2da0:	80 93 3a 03 	sts	0x033A, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    2da4:	80 91 3b 03 	lds	r24, 0x033B
    2da8:	8f 5f       	subi	r24, 0xFF	; 255
    2daa:	80 93 3b 03 	sts	0x033B, r24

			traceTASK_DELETE( pxTCB );
		}
		portEXIT_CRITICAL();
    2dae:	0f 90       	pop	r0
    2db0:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    2db2:	80 91 39 03 	lds	r24, 0x0339
    2db6:	88 23       	and	r24, r24
    2db8:	21 f0       	breq	.+8      	; 0x2dc2 <vTaskDelete+0x8c>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    2dba:	01 2b       	or	r16, r17
    2dbc:	11 f4       	brne	.+4      	; 0x2dc2 <vTaskDelete+0x8c>
			{
				portYIELD_WITHIN_API();
    2dbe:	0e 94 5e 19 	call	0x32bc	; 0x32bc <vPortYield>
			}
		}
	}
    2dc2:	df 91       	pop	r29
    2dc4:	cf 91       	pop	r28
    2dc6:	1f 91       	pop	r17
    2dc8:	0f 91       	pop	r16
    2dca:	ff 90       	pop	r15
    2dcc:	ef 90       	pop	r14
    2dce:	08 95       	ret

00002dd0 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    2dd0:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    2dd2:	10 92 39 03 	sts	0x0339, r1
	vPortEndScheduler();
    2dd6:	0e 94 ff 18 	call	0x31fe	; 0x31fe <vPortEndScheduler>
}
    2dda:	08 95       	ret

00002ddc <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    2ddc:	1f 93       	push	r17
    2dde:	cf 93       	push	r28
    2de0:	df 93       	push	r29
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
    2de2:	80 91 3a 03 	lds	r24, 0x033A
    2de6:	88 23       	and	r24, r24
    2de8:	91 f1       	breq	.+100    	; 0x2e4e <prvIdleTask+0x72>

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    2dea:	80 91 35 03 	lds	r24, 0x0335
    2dee:	8f 5f       	subi	r24, 0xFF	; 255
    2df0:	80 93 35 03 	sts	0x0335, r24
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    2df4:	10 91 80 03 	lds	r17, 0x0380
			xTaskResumeAll();
    2df8:	0e 94 88 15 	call	0x2b10	; 0x2b10 <xTaskResumeAll>

			if( !xListIsEmpty )
    2dfc:	11 23       	and	r17, r17
    2dfe:	39 f1       	breq	.+78     	; 0x2e4e <prvIdleTask+0x72>
			{
				tskTCB *pxTCB;

				portENTER_CRITICAL();
    2e00:	0f b6       	in	r0, 0x3f	; 63
    2e02:	f8 94       	cli
    2e04:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    2e06:	80 91 80 03 	lds	r24, 0x0380
    2e0a:	88 23       	and	r24, r24
    2e0c:	19 f4       	brne	.+6      	; 0x2e14 <prvIdleTask+0x38>
    2e0e:	c0 e0       	ldi	r28, 0x00	; 0
    2e10:	d0 e0       	ldi	r29, 0x00	; 0
    2e12:	06 c0       	rjmp	.+12     	; 0x2e20 <prvIdleTask+0x44>
    2e14:	e0 91 85 03 	lds	r30, 0x0385
    2e18:	f0 91 86 03 	lds	r31, 0x0386
    2e1c:	c6 81       	ldd	r28, Z+6	; 0x06
    2e1e:	d7 81       	ldd	r29, Z+7	; 0x07
					vListRemove( &( pxTCB->xGenericListItem ) );
    2e20:	ce 01       	movw	r24, r28
    2e22:	02 96       	adiw	r24, 0x02	; 2
    2e24:	0e 94 e4 10 	call	0x21c8	; 0x21c8 <vListRemove>
					--uxCurrentNumberOfTasks;
    2e28:	80 91 38 03 	lds	r24, 0x0338
    2e2c:	81 50       	subi	r24, 0x01	; 1
    2e2e:	80 93 38 03 	sts	0x0338, r24
					--uxTasksDeleted;
    2e32:	80 91 3a 03 	lds	r24, 0x033A
    2e36:	81 50       	subi	r24, 0x01	; 1
    2e38:	80 93 3a 03 	sts	0x033A, r24
				}
				portEXIT_CRITICAL();
    2e3c:	0f 90       	pop	r0
    2e3e:	0f be       	out	0x3f, r0	; 63

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    2e40:	8f 89       	ldd	r24, Y+23	; 0x17
    2e42:	98 8d       	ldd	r25, Y+24	; 0x18
    2e44:	0e 94 81 1b 	call	0x3702	; 0x3702 <vPortFree>
		vPortFree( pxTCB );
    2e48:	ce 01       	movw	r24, r28
    2e4a:	0e 94 81 1b 	call	0x3702	; 0x3702 <vPortFree>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    2e4e:	80 91 3d 03 	lds	r24, 0x033D
    2e52:	82 30       	cpi	r24, 0x02	; 2
    2e54:	30 f2       	brcs	.-116    	; 0x2de2 <prvIdleTask+0x6>
			{
				taskYIELD();
    2e56:	0e 94 5e 19 	call	0x32bc	; 0x32bc <vPortYield>
    2e5a:	c3 cf       	rjmp	.-122    	; 0x2de2 <prvIdleTask+0x6>

00002e5c <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    2e5c:	2f 92       	push	r2
    2e5e:	3f 92       	push	r3
    2e60:	5f 92       	push	r5
    2e62:	6f 92       	push	r6
    2e64:	7f 92       	push	r7
    2e66:	8f 92       	push	r8
    2e68:	9f 92       	push	r9
    2e6a:	af 92       	push	r10
    2e6c:	bf 92       	push	r11
    2e6e:	cf 92       	push	r12
    2e70:	df 92       	push	r13
    2e72:	ef 92       	push	r14
    2e74:	ff 92       	push	r15
    2e76:	0f 93       	push	r16
    2e78:	1f 93       	push	r17
    2e7a:	df 93       	push	r29
    2e7c:	cf 93       	push	r28
    2e7e:	00 d0       	rcall	.+0      	; 0x2e80 <xTaskGenericCreate+0x24>
    2e80:	00 d0       	rcall	.+0      	; 0x2e82 <xTaskGenericCreate+0x26>
    2e82:	cd b7       	in	r28, 0x3d	; 61
    2e84:	de b7       	in	r29, 0x3e	; 62
    2e86:	9a 83       	std	Y+2, r25	; 0x02
    2e88:	89 83       	std	Y+1, r24	; 0x01
    2e8a:	4b 01       	movw	r8, r22
    2e8c:	5a 01       	movw	r10, r20
    2e8e:	19 01       	movw	r2, r18
    2e90:	50 2e       	mov	r5, r16
    2e92:	37 01       	movw	r6, r14
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    2e94:	81 e2       	ldi	r24, 0x21	; 33
    2e96:	90 e0       	ldi	r25, 0x00	; 0
    2e98:	0e 94 91 1b 	call	0x3722	; 0x3722 <pvPortMalloc>
    2e9c:	8b 83       	std	Y+3, r24	; 0x03
    2e9e:	9c 83       	std	Y+4, r25	; 0x04

	if( pxNewTCB != NULL )
    2ea0:	8b 81       	ldd	r24, Y+3	; 0x03
    2ea2:	9c 81       	ldd	r25, Y+4	; 0x04
    2ea4:	89 2b       	or	r24, r25
    2ea6:	89 f0       	breq	.+34     	; 0x2eca <xTaskGenericCreate+0x6e>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    2ea8:	c1 14       	cp	r12, r1
    2eaa:	d1 04       	cpc	r13, r1
    2eac:	21 f4       	brne	.+8      	; 0x2eb6 <xTaskGenericCreate+0x5a>
    2eae:	c5 01       	movw	r24, r10
    2eb0:	0e 94 91 1b 	call	0x3722	; 0x3722 <pvPortMalloc>
    2eb4:	6c 01       	movw	r12, r24
    2eb6:	eb 81       	ldd	r30, Y+3	; 0x03
    2eb8:	fc 81       	ldd	r31, Y+4	; 0x04
    2eba:	d0 8e       	std	Z+24, r13	; 0x18
    2ebc:	c7 8a       	std	Z+23, r12	; 0x17

		if( pxNewTCB->pxStack == NULL )
    2ebe:	c1 14       	cp	r12, r1
    2ec0:	d1 04       	cpc	r13, r1
    2ec2:	29 f4       	brne	.+10     	; 0x2ece <xTaskGenericCreate+0x72>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    2ec4:	cf 01       	movw	r24, r30
    2ec6:	0e 94 81 1b 	call	0x3702	; 0x3702 <vPortFree>
    2eca:	8f ef       	ldi	r24, 0xFF	; 255
    2ecc:	d5 c0       	rjmp	.+426    	; 0x3078 <xTaskGenericCreate+0x21c>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
    2ece:	c6 01       	movw	r24, r12
    2ed0:	65 ea       	ldi	r22, 0xA5	; 165
    2ed2:	70 e0       	ldi	r23, 0x00	; 0
    2ed4:	a5 01       	movw	r20, r10
    2ed6:	0e 94 71 2d 	call	0x5ae2	; 0x5ae2 <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
    2eda:	08 94       	sec
    2edc:	a1 08       	sbc	r10, r1
    2ede:	b1 08       	sbc	r11, r1
    2ee0:	eb 81       	ldd	r30, Y+3	; 0x03
    2ee2:	fc 81       	ldd	r31, Y+4	; 0x04
    2ee4:	e7 88       	ldd	r14, Z+23	; 0x17
    2ee6:	f0 8c       	ldd	r15, Z+24	; 0x18
    2ee8:	ea 0c       	add	r14, r10
    2eea:	fb 1c       	adc	r15, r11
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    2eec:	cf 01       	movw	r24, r30
    2eee:	49 96       	adiw	r24, 0x19	; 25
    2ef0:	b4 01       	movw	r22, r8
    2ef2:	48 e0       	ldi	r20, 0x08	; 8
    2ef4:	50 e0       	ldi	r21, 0x00	; 0
    2ef6:	0e 94 78 2d 	call	0x5af0	; 0x5af0 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
    2efa:	eb 81       	ldd	r30, Y+3	; 0x03
    2efc:	fc 81       	ldd	r31, Y+4	; 0x04
    2efe:	10 a2       	std	Z+32, r1	; 0x20
    2f00:	05 2d       	mov	r16, r5
    2f02:	f3 e0       	ldi	r31, 0x03	; 3
    2f04:	f5 15       	cp	r31, r5
    2f06:	08 f4       	brcc	.+2      	; 0x2f0a <xTaskGenericCreate+0xae>
    2f08:	03 e0       	ldi	r16, 0x03	; 3
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - 1;
	}

	pxTCB->uxPriority = uxPriority;
    2f0a:	eb 81       	ldd	r30, Y+3	; 0x03
    2f0c:	fc 81       	ldd	r31, Y+4	; 0x04
    2f0e:	06 8b       	std	Z+22, r16	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    2f10:	42 e0       	ldi	r20, 0x02	; 2
    2f12:	c4 2e       	mov	r12, r20
    2f14:	d1 2c       	mov	r13, r1
    2f16:	ce 0e       	add	r12, r30
    2f18:	df 1e       	adc	r13, r31
    2f1a:	c6 01       	movw	r24, r12
    2f1c:	0e 94 82 10 	call	0x2104	; 0x2104 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    2f20:	8b 81       	ldd	r24, Y+3	; 0x03
    2f22:	9c 81       	ldd	r25, Y+4	; 0x04
    2f24:	0c 96       	adiw	r24, 0x0c	; 12
    2f26:	0e 94 82 10 	call	0x2104	; 0x2104 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    2f2a:	8b 81       	ldd	r24, Y+3	; 0x03
    2f2c:	9c 81       	ldd	r25, Y+4	; 0x04
    2f2e:	fc 01       	movw	r30, r24
    2f30:	91 87       	std	Z+9, r25	; 0x09
    2f32:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    2f34:	84 e0       	ldi	r24, 0x04	; 4
    2f36:	90 e0       	ldi	r25, 0x00	; 0
    2f38:	80 1b       	sub	r24, r16
    2f3a:	91 09       	sbc	r25, r1
    2f3c:	95 87       	std	Z+13, r25	; 0x0d
    2f3e:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    2f40:	f3 8b       	std	Z+19, r31	; 0x13
    2f42:	e2 8b       	std	Z+18, r30	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    2f44:	c7 01       	movw	r24, r14
    2f46:	69 81       	ldd	r22, Y+1	; 0x01
    2f48:	7a 81       	ldd	r23, Y+2	; 0x02
    2f4a:	a1 01       	movw	r20, r2
    2f4c:	0e 94 7d 18 	call	0x30fa	; 0x30fa <pxPortInitialiseStack>
    2f50:	eb 81       	ldd	r30, Y+3	; 0x03
    2f52:	fc 81       	ldd	r31, Y+4	; 0x04
    2f54:	91 83       	std	Z+1, r25	; 0x01
    2f56:	80 83       	st	Z, r24
		}
		#endif

		if( ( void * ) pxCreatedTask != NULL )
    2f58:	61 14       	cp	r6, r1
    2f5a:	71 04       	cpc	r7, r1
    2f5c:	21 f0       	breq	.+8      	; 0x2f66 <xTaskGenericCreate+0x10a>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    2f5e:	cf 01       	movw	r24, r30
    2f60:	f3 01       	movw	r30, r6
    2f62:	91 83       	std	Z+1, r25	; 0x01
    2f64:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		portENTER_CRITICAL();
    2f66:	0f b6       	in	r0, 0x3f	; 63
    2f68:	f8 94       	cli
    2f6a:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    2f6c:	80 91 38 03 	lds	r24, 0x0338
    2f70:	8f 5f       	subi	r24, 0xFF	; 255
    2f72:	80 93 38 03 	sts	0x0338, r24
			if( pxCurrentTCB == NULL )
    2f76:	80 91 2f 03 	lds	r24, 0x032F
    2f7a:	90 91 30 03 	lds	r25, 0x0330
    2f7e:	89 2b       	or	r24, r25
    2f80:	b9 f5       	brne	.+110    	; 0x2ff0 <xTaskGenericCreate+0x194>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    2f82:	eb 81       	ldd	r30, Y+3	; 0x03
    2f84:	fc 81       	ldd	r31, Y+4	; 0x04
    2f86:	f0 93 30 03 	sts	0x0330, r31
    2f8a:	e0 93 2f 03 	sts	0x032F, r30

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    2f8e:	80 91 38 03 	lds	r24, 0x0338
    2f92:	81 30       	cpi	r24, 0x01	; 1
    2f94:	f1 f5       	brne	.+124    	; 0x3012 <xTaskGenericCreate+0x1b6>
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    2f96:	8d e3       	ldi	r24, 0x3D	; 61
    2f98:	93 e0       	ldi	r25, 0x03	; 3
    2f9a:	0e 94 72 10 	call	0x20e4	; 0x20e4 <vListInitialise>
    2f9e:	86 e4       	ldi	r24, 0x46	; 70
    2fa0:	93 e0       	ldi	r25, 0x03	; 3
    2fa2:	0e 94 72 10 	call	0x20e4	; 0x20e4 <vListInitialise>
    2fa6:	8f e4       	ldi	r24, 0x4F	; 79
    2fa8:	93 e0       	ldi	r25, 0x03	; 3
    2faa:	0e 94 72 10 	call	0x20e4	; 0x20e4 <vListInitialise>
    2fae:	88 e5       	ldi	r24, 0x58	; 88
    2fb0:	93 e0       	ldi	r25, 0x03	; 3
    2fb2:	0e 94 72 10 	call	0x20e4	; 0x20e4 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    2fb6:	31 e6       	ldi	r19, 0x61	; 97
    2fb8:	e3 2e       	mov	r14, r19
    2fba:	33 e0       	ldi	r19, 0x03	; 3
    2fbc:	f3 2e       	mov	r15, r19
    2fbe:	c7 01       	movw	r24, r14
    2fc0:	0e 94 72 10 	call	0x20e4	; 0x20e4 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    2fc4:	0a e6       	ldi	r16, 0x6A	; 106
    2fc6:	13 e0       	ldi	r17, 0x03	; 3
    2fc8:	c8 01       	movw	r24, r16
    2fca:	0e 94 72 10 	call	0x20e4	; 0x20e4 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    2fce:	87 e7       	ldi	r24, 0x77	; 119
    2fd0:	93 e0       	ldi	r25, 0x03	; 3
    2fd2:	0e 94 72 10 	call	0x20e4	; 0x20e4 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    2fd6:	80 e8       	ldi	r24, 0x80	; 128
    2fd8:	93 e0       	ldi	r25, 0x03	; 3
    2fda:	0e 94 72 10 	call	0x20e4	; 0x20e4 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    2fde:	f0 92 74 03 	sts	0x0374, r15
    2fe2:	e0 92 73 03 	sts	0x0373, r14
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    2fe6:	10 93 76 03 	sts	0x0376, r17
    2fea:	00 93 75 03 	sts	0x0375, r16
    2fee:	11 c0       	rjmp	.+34     	; 0x3012 <xTaskGenericCreate+0x1b6>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    2ff0:	80 91 39 03 	lds	r24, 0x0339
    2ff4:	88 23       	and	r24, r24
    2ff6:	69 f4       	brne	.+26     	; 0x3012 <xTaskGenericCreate+0x1b6>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    2ff8:	e0 91 2f 03 	lds	r30, 0x032F
    2ffc:	f0 91 30 03 	lds	r31, 0x0330
    3000:	86 89       	ldd	r24, Z+22	; 0x16
    3002:	58 16       	cp	r5, r24
    3004:	30 f0       	brcs	.+12     	; 0x3012 <xTaskGenericCreate+0x1b6>
					{
						pxCurrentTCB = pxNewTCB;
    3006:	8b 81       	ldd	r24, Y+3	; 0x03
    3008:	9c 81       	ldd	r25, Y+4	; 0x04
    300a:	90 93 30 03 	sts	0x0330, r25
    300e:	80 93 2f 03 	sts	0x032F, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    3012:	eb 81       	ldd	r30, Y+3	; 0x03
    3014:	fc 81       	ldd	r31, Y+4	; 0x04
    3016:	96 89       	ldd	r25, Z+22	; 0x16
    3018:	80 91 3c 03 	lds	r24, 0x033C
    301c:	89 17       	cp	r24, r25
    301e:	10 f4       	brcc	.+4      	; 0x3024 <xTaskGenericCreate+0x1c8>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    3020:	90 93 3c 03 	sts	0x033C, r25
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    3024:	80 91 3b 03 	lds	r24, 0x033B
    3028:	8f 5f       	subi	r24, 0xFF	; 255
    302a:	80 93 3b 03 	sts	0x033B, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    302e:	eb 81       	ldd	r30, Y+3	; 0x03
    3030:	fc 81       	ldd	r31, Y+4	; 0x04
    3032:	96 89       	ldd	r25, Z+22	; 0x16
    3034:	80 91 36 03 	lds	r24, 0x0336
    3038:	89 17       	cp	r24, r25
    303a:	10 f4       	brcc	.+4      	; 0x3040 <xTaskGenericCreate+0x1e4>
    303c:	90 93 36 03 	sts	0x0336, r25
    3040:	eb 81       	ldd	r30, Y+3	; 0x03
    3042:	fc 81       	ldd	r31, Y+4	; 0x04
    3044:	86 89       	ldd	r24, Z+22	; 0x16
    3046:	29 e0       	ldi	r18, 0x09	; 9
    3048:	82 9f       	mul	r24, r18
    304a:	c0 01       	movw	r24, r0
    304c:	11 24       	eor	r1, r1
    304e:	83 5c       	subi	r24, 0xC3	; 195
    3050:	9c 4f       	sbci	r25, 0xFC	; 252
    3052:	b6 01       	movw	r22, r12
    3054:	0e 94 86 10 	call	0x210c	; 0x210c <vListInsertEnd>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		portEXIT_CRITICAL();
    3058:	0f 90       	pop	r0
    305a:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED( pxNewTCB );
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    305c:	80 91 39 03 	lds	r24, 0x0339
    3060:	88 23       	and	r24, r24
    3062:	49 f0       	breq	.+18     	; 0x3076 <xTaskGenericCreate+0x21a>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    3064:	e0 91 2f 03 	lds	r30, 0x032F
    3068:	f0 91 30 03 	lds	r31, 0x0330
    306c:	86 89       	ldd	r24, Z+22	; 0x16
    306e:	85 15       	cp	r24, r5
    3070:	10 f4       	brcc	.+4      	; 0x3076 <xTaskGenericCreate+0x21a>
			{
				portYIELD_WITHIN_API();
    3072:	0e 94 5e 19 	call	0x32bc	; 0x32bc <vPortYield>
    3076:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    3078:	0f 90       	pop	r0
    307a:	0f 90       	pop	r0
    307c:	0f 90       	pop	r0
    307e:	0f 90       	pop	r0
    3080:	cf 91       	pop	r28
    3082:	df 91       	pop	r29
    3084:	1f 91       	pop	r17
    3086:	0f 91       	pop	r16
    3088:	ff 90       	pop	r15
    308a:	ef 90       	pop	r14
    308c:	df 90       	pop	r13
    308e:	cf 90       	pop	r12
    3090:	bf 90       	pop	r11
    3092:	af 90       	pop	r10
    3094:	9f 90       	pop	r9
    3096:	8f 90       	pop	r8
    3098:	7f 90       	pop	r7
    309a:	6f 90       	pop	r6
    309c:	5f 90       	pop	r5
    309e:	3f 90       	pop	r3
    30a0:	2f 90       	pop	r2
    30a2:	08 95       	ret

000030a4 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    30a4:	af 92       	push	r10
    30a6:	bf 92       	push	r11
    30a8:	cf 92       	push	r12
    30aa:	df 92       	push	r13
    30ac:	ef 92       	push	r14
    30ae:	ff 92       	push	r15
    30b0:	0f 93       	push	r16
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
    30b2:	8e ee       	ldi	r24, 0xEE	; 238
    30b4:	96 e1       	ldi	r25, 0x16	; 22
    30b6:	60 eb       	ldi	r22, 0xB0	; 176
    30b8:	72 e0       	ldi	r23, 0x02	; 2
    30ba:	45 e5       	ldi	r20, 0x55	; 85
    30bc:	50 e0       	ldi	r21, 0x00	; 0
    30be:	20 e0       	ldi	r18, 0x00	; 0
    30c0:	30 e0       	ldi	r19, 0x00	; 0
    30c2:	00 e0       	ldi	r16, 0x00	; 0
    30c4:	ee 24       	eor	r14, r14
    30c6:	ff 24       	eor	r15, r15
    30c8:	cc 24       	eor	r12, r12
    30ca:	dd 24       	eor	r13, r13
    30cc:	aa 24       	eor	r10, r10
    30ce:	bb 24       	eor	r11, r11
    30d0:	0e 94 2e 17 	call	0x2e5c	; 0x2e5c <xTaskGenericCreate>

	if( xReturn == pdPASS )
    30d4:	81 30       	cpi	r24, 0x01	; 1
    30d6:	49 f4       	brne	.+18     	; 0x30ea <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    30d8:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    30da:	80 93 39 03 	sts	0x0339, r24
		xTickCount = ( portTickType ) 0;
    30de:	10 92 34 03 	sts	0x0334, r1
    30e2:	10 92 33 03 	sts	0x0333, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
    30e6:	0e 94 c5 18 	call	0x318a	; 0x318a <xPortStartScheduler>
		else
		{
			/* Should only reach here if a task calls xTaskEndScheduler(). */
		}
	}
}
    30ea:	0f 91       	pop	r16
    30ec:	ff 90       	pop	r15
    30ee:	ef 90       	pop	r14
    30f0:	df 90       	pop	r13
    30f2:	cf 90       	pop	r12
    30f4:	bf 90       	pop	r11
    30f6:	af 90       	pop	r10
    30f8:	08 95       	ret

000030fa <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    30fa:	fc 01       	movw	r30, r24
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    30fc:	91 e1       	ldi	r25, 0x11	; 17
    30fe:	90 83       	st	Z, r25
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    3100:	22 e2       	ldi	r18, 0x22	; 34
    3102:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    3104:	83 e3       	ldi	r24, 0x33	; 51
    3106:	82 93       	st	-Z, r24
	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	

	usAddress = ( unsigned short ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    3108:	62 93       	st	-Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    310a:	72 93       	st	-Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    310c:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    310e:	80 e8       	ldi	r24, 0x80	; 128
    3110:	82 93       	st	-Z, r24
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    3112:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    3114:	82 e0       	ldi	r24, 0x02	; 2
    3116:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    3118:	83 e0       	ldi	r24, 0x03	; 3
    311a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    311c:	84 e0       	ldi	r24, 0x04	; 4
    311e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    3120:	85 e0       	ldi	r24, 0x05	; 5
    3122:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    3124:	86 e0       	ldi	r24, 0x06	; 6
    3126:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    3128:	87 e0       	ldi	r24, 0x07	; 7
    312a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    312c:	88 e0       	ldi	r24, 0x08	; 8
    312e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    3130:	89 e0       	ldi	r24, 0x09	; 9
    3132:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    3134:	80 e1       	ldi	r24, 0x10	; 16
    3136:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    3138:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    313a:	82 e1       	ldi	r24, 0x12	; 18
    313c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    313e:	83 e1       	ldi	r24, 0x13	; 19
    3140:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    3142:	84 e1       	ldi	r24, 0x14	; 20
    3144:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    3146:	85 e1       	ldi	r24, 0x15	; 21
    3148:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    314a:	86 e1       	ldi	r24, 0x16	; 22
    314c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    314e:	87 e1       	ldi	r24, 0x17	; 23
    3150:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    3152:	88 e1       	ldi	r24, 0x18	; 24
    3154:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    3156:	89 e1       	ldi	r24, 0x19	; 25
    3158:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    315a:	80 e2       	ldi	r24, 0x20	; 32
    315c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    315e:	81 e2       	ldi	r24, 0x21	; 33
    3160:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    3162:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    3164:	83 e2       	ldi	r24, 0x23	; 35
    3166:	82 93       	st	-Z, r24
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */

	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    3168:	42 93       	st	-Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    316a:	52 93       	st	-Z, r21
	pxTopOfStack--;


	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    316c:	86 e2       	ldi	r24, 0x26	; 38
    316e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    3170:	87 e2       	ldi	r24, 0x27	; 39
    3172:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    3174:	88 e2       	ldi	r24, 0x28	; 40
    3176:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    3178:	89 e2       	ldi	r24, 0x29	; 41
    317a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    317c:	80 e3       	ldi	r24, 0x30	; 48
    317e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    3180:	81 e3       	ldi	r24, 0x31	; 49
    3182:	82 93       	st	-Z, r24
    3184:	31 97       	sbiw	r30, 0x01	; 1
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    3186:	cf 01       	movw	r24, r30
    3188:	08 95       	ret

0000318a <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	OCR1AH = ucHighByte;
    318a:	10 92 89 00 	sts	0x0089, r1
	OCR1AL = ucLowByte;
    318e:	89 ef       	ldi	r24, 0xF9	; 249
    3190:	80 93 88 00 	sts	0x0088, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    3194:	8b e0       	ldi	r24, 0x0B	; 11
    3196:	80 93 81 00 	sts	0x0081, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
    319a:	ef e6       	ldi	r30, 0x6F	; 111
    319c:	f0 e0       	ldi	r31, 0x00	; 0
    319e:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    31a0:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
    31a2:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    31a4:	a0 91 2f 03 	lds	r26, 0x032F
    31a8:	b0 91 30 03 	lds	r27, 0x0330
    31ac:	cd 91       	ld	r28, X+
    31ae:	cd bf       	out	0x3d, r28	; 61
    31b0:	dd 91       	ld	r29, X+
    31b2:	de bf       	out	0x3e, r29	; 62
    31b4:	ff 91       	pop	r31
    31b6:	ef 91       	pop	r30
    31b8:	df 91       	pop	r29
    31ba:	cf 91       	pop	r28
    31bc:	bf 91       	pop	r27
    31be:	af 91       	pop	r26
    31c0:	9f 91       	pop	r25
    31c2:	8f 91       	pop	r24
    31c4:	7f 91       	pop	r23
    31c6:	6f 91       	pop	r22
    31c8:	5f 91       	pop	r21
    31ca:	4f 91       	pop	r20
    31cc:	3f 91       	pop	r19
    31ce:	2f 91       	pop	r18
    31d0:	1f 91       	pop	r17
    31d2:	0f 91       	pop	r16
    31d4:	ff 90       	pop	r15
    31d6:	ef 90       	pop	r14
    31d8:	df 90       	pop	r13
    31da:	cf 90       	pop	r12
    31dc:	bf 90       	pop	r11
    31de:	af 90       	pop	r10
    31e0:	9f 90       	pop	r9
    31e2:	8f 90       	pop	r8
    31e4:	7f 90       	pop	r7
    31e6:	6f 90       	pop	r6
    31e8:	5f 90       	pop	r5
    31ea:	4f 90       	pop	r4
    31ec:	3f 90       	pop	r3
    31ee:	2f 90       	pop	r2
    31f0:	1f 90       	pop	r1
    31f2:	0f 90       	pop	r0
    31f4:	0f be       	out	0x3f, r0	; 63
    31f6:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    31f8:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    31fa:	81 e0       	ldi	r24, 0x01	; 1
    31fc:	08 95       	ret

000031fe <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    31fe:	08 95       	ret

00003200 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    3200:	0f 92       	push	r0
    3202:	0f b6       	in	r0, 0x3f	; 63
    3204:	f8 94       	cli
    3206:	0f 92       	push	r0
    3208:	1f 92       	push	r1
    320a:	11 24       	eor	r1, r1
    320c:	2f 92       	push	r2
    320e:	3f 92       	push	r3
    3210:	4f 92       	push	r4
    3212:	5f 92       	push	r5
    3214:	6f 92       	push	r6
    3216:	7f 92       	push	r7
    3218:	8f 92       	push	r8
    321a:	9f 92       	push	r9
    321c:	af 92       	push	r10
    321e:	bf 92       	push	r11
    3220:	cf 92       	push	r12
    3222:	df 92       	push	r13
    3224:	ef 92       	push	r14
    3226:	ff 92       	push	r15
    3228:	0f 93       	push	r16
    322a:	1f 93       	push	r17
    322c:	2f 93       	push	r18
    322e:	3f 93       	push	r19
    3230:	4f 93       	push	r20
    3232:	5f 93       	push	r21
    3234:	6f 93       	push	r22
    3236:	7f 93       	push	r23
    3238:	8f 93       	push	r24
    323a:	9f 93       	push	r25
    323c:	af 93       	push	r26
    323e:	bf 93       	push	r27
    3240:	cf 93       	push	r28
    3242:	df 93       	push	r29
    3244:	ef 93       	push	r30
    3246:	ff 93       	push	r31
    3248:	a0 91 2f 03 	lds	r26, 0x032F
    324c:	b0 91 30 03 	lds	r27, 0x0330
    3250:	0d b6       	in	r0, 0x3d	; 61
    3252:	0d 92       	st	X+, r0
    3254:	0e b6       	in	r0, 0x3e	; 62
    3256:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    3258:	0e 94 d9 14 	call	0x29b2	; 0x29b2 <vTaskIncrementTick>
	vTaskSwitchContext();
    325c:	0e 94 0b 14 	call	0x2816	; 0x2816 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    3260:	a0 91 2f 03 	lds	r26, 0x032F
    3264:	b0 91 30 03 	lds	r27, 0x0330
    3268:	cd 91       	ld	r28, X+
    326a:	cd bf       	out	0x3d, r28	; 61
    326c:	dd 91       	ld	r29, X+
    326e:	de bf       	out	0x3e, r29	; 62
    3270:	ff 91       	pop	r31
    3272:	ef 91       	pop	r30
    3274:	df 91       	pop	r29
    3276:	cf 91       	pop	r28
    3278:	bf 91       	pop	r27
    327a:	af 91       	pop	r26
    327c:	9f 91       	pop	r25
    327e:	8f 91       	pop	r24
    3280:	7f 91       	pop	r23
    3282:	6f 91       	pop	r22
    3284:	5f 91       	pop	r21
    3286:	4f 91       	pop	r20
    3288:	3f 91       	pop	r19
    328a:	2f 91       	pop	r18
    328c:	1f 91       	pop	r17
    328e:	0f 91       	pop	r16
    3290:	ff 90       	pop	r15
    3292:	ef 90       	pop	r14
    3294:	df 90       	pop	r13
    3296:	cf 90       	pop	r12
    3298:	bf 90       	pop	r11
    329a:	af 90       	pop	r10
    329c:	9f 90       	pop	r9
    329e:	8f 90       	pop	r8
    32a0:	7f 90       	pop	r7
    32a2:	6f 90       	pop	r6
    32a4:	5f 90       	pop	r5
    32a6:	4f 90       	pop	r4
    32a8:	3f 90       	pop	r3
    32aa:	2f 90       	pop	r2
    32ac:	1f 90       	pop	r1
    32ae:	0f 90       	pop	r0
    32b0:	0f be       	out	0x3f, r0	; 63
    32b2:	0f 90       	pop	r0

	asm volatile ( "ret" );
    32b4:	08 95       	ret

000032b6 <__vector_17>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    32b6:	0e 94 00 19 	call	0x3200	; 0x3200 <vPortYieldFromTick>
		asm volatile ( "reti" );
    32ba:	18 95       	reti

000032bc <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    32bc:	0f 92       	push	r0
    32be:	0f b6       	in	r0, 0x3f	; 63
    32c0:	f8 94       	cli
    32c2:	0f 92       	push	r0
    32c4:	1f 92       	push	r1
    32c6:	11 24       	eor	r1, r1
    32c8:	2f 92       	push	r2
    32ca:	3f 92       	push	r3
    32cc:	4f 92       	push	r4
    32ce:	5f 92       	push	r5
    32d0:	6f 92       	push	r6
    32d2:	7f 92       	push	r7
    32d4:	8f 92       	push	r8
    32d6:	9f 92       	push	r9
    32d8:	af 92       	push	r10
    32da:	bf 92       	push	r11
    32dc:	cf 92       	push	r12
    32de:	df 92       	push	r13
    32e0:	ef 92       	push	r14
    32e2:	ff 92       	push	r15
    32e4:	0f 93       	push	r16
    32e6:	1f 93       	push	r17
    32e8:	2f 93       	push	r18
    32ea:	3f 93       	push	r19
    32ec:	4f 93       	push	r20
    32ee:	5f 93       	push	r21
    32f0:	6f 93       	push	r22
    32f2:	7f 93       	push	r23
    32f4:	8f 93       	push	r24
    32f6:	9f 93       	push	r25
    32f8:	af 93       	push	r26
    32fa:	bf 93       	push	r27
    32fc:	cf 93       	push	r28
    32fe:	df 93       	push	r29
    3300:	ef 93       	push	r30
    3302:	ff 93       	push	r31
    3304:	a0 91 2f 03 	lds	r26, 0x032F
    3308:	b0 91 30 03 	lds	r27, 0x0330
    330c:	0d b6       	in	r0, 0x3d	; 61
    330e:	0d 92       	st	X+, r0
    3310:	0e b6       	in	r0, 0x3e	; 62
    3312:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    3314:	0e 94 0b 14 	call	0x2816	; 0x2816 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    3318:	a0 91 2f 03 	lds	r26, 0x032F
    331c:	b0 91 30 03 	lds	r27, 0x0330
    3320:	cd 91       	ld	r28, X+
    3322:	cd bf       	out	0x3d, r28	; 61
    3324:	dd 91       	ld	r29, X+
    3326:	de bf       	out	0x3e, r29	; 62
    3328:	ff 91       	pop	r31
    332a:	ef 91       	pop	r30
    332c:	df 91       	pop	r29
    332e:	cf 91       	pop	r28
    3330:	bf 91       	pop	r27
    3332:	af 91       	pop	r26
    3334:	9f 91       	pop	r25
    3336:	8f 91       	pop	r24
    3338:	7f 91       	pop	r23
    333a:	6f 91       	pop	r22
    333c:	5f 91       	pop	r21
    333e:	4f 91       	pop	r20
    3340:	3f 91       	pop	r19
    3342:	2f 91       	pop	r18
    3344:	1f 91       	pop	r17
    3346:	0f 91       	pop	r16
    3348:	ff 90       	pop	r15
    334a:	ef 90       	pop	r14
    334c:	df 90       	pop	r13
    334e:	cf 90       	pop	r12
    3350:	bf 90       	pop	r11
    3352:	af 90       	pop	r10
    3354:	9f 90       	pop	r9
    3356:	8f 90       	pop	r8
    3358:	7f 90       	pop	r7
    335a:	6f 90       	pop	r6
    335c:	5f 90       	pop	r5
    335e:	4f 90       	pop	r4
    3360:	3f 90       	pop	r3
    3362:	2f 90       	pop	r2
    3364:	1f 90       	pop	r1
    3366:	0f 90       	pop	r0
    3368:	0f be       	out	0x3f, r0	; 63
    336a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    336c:	08 95       	ret

0000336e <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    336e:	0f 93       	push	r16
    3370:	1f 93       	push	r17
    3372:	cf 93       	push	r28
    3374:	df 93       	push	r29
    3376:	fc 01       	movw	r30, r24
corCRCB *pxUnblockedCRCB;
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    3378:	80 81       	ld	r24, Z
    337a:	88 23       	and	r24, r24
    337c:	19 f4       	brne	.+6      	; 0x3384 <xCoRoutineRemoveFromEventList+0x16>
    337e:	c0 e0       	ldi	r28, 0x00	; 0
    3380:	d0 e0       	ldi	r29, 0x00	; 0
    3382:	05 c0       	rjmp	.+10     	; 0x338e <xCoRoutineRemoveFromEventList+0x20>
    3384:	05 80       	ldd	r0, Z+5	; 0x05
    3386:	f6 81       	ldd	r31, Z+6	; 0x06
    3388:	e0 2d       	mov	r30, r0
    338a:	c6 81       	ldd	r28, Z+6	; 0x06
    338c:	d7 81       	ldd	r29, Z+7	; 0x07
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    338e:	8e 01       	movw	r16, r28
    3390:	04 5f       	subi	r16, 0xF4	; 244
    3392:	1f 4f       	sbci	r17, 0xFF	; 255
    3394:	c8 01       	movw	r24, r16
    3396:	0e 94 e4 10 	call	0x21c8	; 0x21c8 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    339a:	8a eb       	ldi	r24, 0xBA	; 186
    339c:	93 e0       	ldi	r25, 0x03	; 3
    339e:	b8 01       	movw	r22, r16
    33a0:	0e 94 86 10 	call	0x210c	; 0x210c <vListInsertEnd>
    33a4:	20 e0       	ldi	r18, 0x00	; 0
    33a6:	e0 91 89 03 	lds	r30, 0x0389
    33aa:	f0 91 8a 03 	lds	r31, 0x038A
    33ae:	9e 89       	ldd	r25, Y+22	; 0x16
    33b0:	86 89       	ldd	r24, Z+22	; 0x16
    33b2:	98 17       	cp	r25, r24
    33b4:	08 f0       	brcs	.+2      	; 0x33b8 <xCoRoutineRemoveFromEventList+0x4a>
    33b6:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    33b8:	82 2f       	mov	r24, r18
    33ba:	df 91       	pop	r29
    33bc:	cf 91       	pop	r28
    33be:	1f 91       	pop	r17
    33c0:	0f 91       	pop	r16
    33c2:	08 95       	ret

000033c4 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    33c4:	ff 92       	push	r15
    33c6:	0f 93       	push	r16
    33c8:	1f 93       	push	r17
    33ca:	cf 93       	push	r28
    33cc:	df 93       	push	r29
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    33ce:	99 e0       	ldi	r25, 0x09	; 9
    33d0:	f9 2e       	mov	r15, r25
    33d2:	28 c0       	rjmp	.+80     	; 0x3424 <vCoRoutineSchedule+0x60>
	while( !listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    33d4:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    33d6:	80 91 ba 03 	lds	r24, 0x03BA
    33da:	88 23       	and	r24, r24
    33dc:	19 f4       	brne	.+6      	; 0x33e4 <vCoRoutineSchedule+0x20>
    33de:	c0 e0       	ldi	r28, 0x00	; 0
    33e0:	d0 e0       	ldi	r29, 0x00	; 0
    33e2:	06 c0       	rjmp	.+12     	; 0x33f0 <vCoRoutineSchedule+0x2c>
    33e4:	e0 91 bf 03 	lds	r30, 0x03BF
    33e8:	f0 91 c0 03 	lds	r31, 0x03C0
    33ec:	c6 81       	ldd	r28, Z+6	; 0x06
    33ee:	d7 81       	ldd	r29, Z+7	; 0x07
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    33f0:	ce 01       	movw	r24, r28
    33f2:	0c 96       	adiw	r24, 0x0c	; 12
    33f4:	0e 94 e4 10 	call	0x21c8	; 0x21c8 <vListRemove>
		}
		portENABLE_INTERRUPTS();
    33f8:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    33fa:	8e 01       	movw	r16, r28
    33fc:	0e 5f       	subi	r16, 0xFE	; 254
    33fe:	1f 4f       	sbci	r17, 0xFF	; 255
    3400:	c8 01       	movw	r24, r16
    3402:	0e 94 e4 10 	call	0x21c8	; 0x21c8 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    3406:	9e 89       	ldd	r25, Y+22	; 0x16
    3408:	80 91 8b 03 	lds	r24, 0x038B
    340c:	89 17       	cp	r24, r25
    340e:	10 f4       	brcc	.+4      	; 0x3414 <vCoRoutineSchedule+0x50>
    3410:	90 93 8b 03 	sts	0x038B, r25
    3414:	9f 9d       	mul	r25, r15
    3416:	c0 01       	movw	r24, r0
    3418:	11 24       	eor	r1, r1
    341a:	8e 56       	subi	r24, 0x6E	; 110
    341c:	9c 4f       	sbci	r25, 0xFC	; 252
    341e:	b8 01       	movw	r22, r16
    3420:	0e 94 86 10 	call	0x210c	; 0x210c <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( !listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) )
    3424:	80 91 ba 03 	lds	r24, 0x03BA
    3428:	88 23       	and	r24, r24
    342a:	a1 f6       	brne	.-88     	; 0x33d4 <vCoRoutineSchedule+0x10>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    342c:	0e 94 f7 13 	call	0x27ee	; 0x27ee <xTaskGetTickCount>
    3430:	20 91 8c 03 	lds	r18, 0x038C
    3434:	30 91 8d 03 	lds	r19, 0x038D
    3438:	82 1b       	sub	r24, r18
    343a:	93 0b       	sbc	r25, r19
    343c:	90 93 8f 03 	sts	0x038F, r25
    3440:	80 93 8e 03 	sts	0x038E, r24
					vListRemove( &( pxCRCB->xEventListItem ) );											
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    3444:	89 e0       	ldi	r24, 0x09	; 9
    3446:	f8 2e       	mov	r15, r24
    3448:	54 c0       	rjmp	.+168    	; 0x34f2 <vCoRoutineSchedule+0x12e>
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    344a:	01 96       	adiw	r24, 0x01	; 1
    344c:	90 93 91 03 	sts	0x0391, r25
    3450:	80 93 90 03 	sts	0x0390, r24
		xPassedTicks--;
    3454:	21 50       	subi	r18, 0x01	; 1
    3456:	30 40       	sbci	r19, 0x00	; 0
    3458:	30 93 8f 03 	sts	0x038F, r19
    345c:	20 93 8e 03 	sts	0x038E, r18

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    3460:	89 2b       	or	r24, r25
    3462:	c9 f5       	brne	.+114    	; 0x34d6 <vCoRoutineSchedule+0x112>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    3464:	20 91 b6 03 	lds	r18, 0x03B6
    3468:	30 91 b7 03 	lds	r19, 0x03B7
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    346c:	80 91 b8 03 	lds	r24, 0x03B8
    3470:	90 91 b9 03 	lds	r25, 0x03B9
    3474:	90 93 b7 03 	sts	0x03B7, r25
    3478:	80 93 b6 03 	sts	0x03B6, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    347c:	30 93 b9 03 	sts	0x03B9, r19
    3480:	20 93 b8 03 	sts	0x03B8, r18
    3484:	28 c0       	rjmp	.+80     	; 0x34d6 <vCoRoutineSchedule+0x112>
		}

		/* See if this tick has made a timeout expire. */
		while( ( pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList ) ) != NULL )
		{	
			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    3486:	20 91 90 03 	lds	r18, 0x0390
    348a:	30 91 91 03 	lds	r19, 0x0391
    348e:	8a 81       	ldd	r24, Y+2	; 0x02
    3490:	9b 81       	ldd	r25, Y+3	; 0x03
    3492:	28 17       	cp	r18, r24
    3494:	39 07       	cpc	r19, r25
    3496:	68 f1       	brcs	.+90     	; 0x34f2 <vCoRoutineSchedule+0x12e>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    3498:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    349a:	8e 01       	movw	r16, r28
    349c:	0e 5f       	subi	r16, 0xFE	; 254
    349e:	1f 4f       	sbci	r17, 0xFF	; 255
    34a0:	c8 01       	movw	r24, r16
    34a2:	0e 94 e4 10 	call	0x21c8	; 0x21c8 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    34a6:	8c 89       	ldd	r24, Y+20	; 0x14
    34a8:	9d 89       	ldd	r25, Y+21	; 0x15
    34aa:	89 2b       	or	r24, r25
    34ac:	21 f0       	breq	.+8      	; 0x34b6 <vCoRoutineSchedule+0xf2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    34ae:	ce 01       	movw	r24, r28
    34b0:	0c 96       	adiw	r24, 0x0c	; 12
    34b2:	0e 94 e4 10 	call	0x21c8	; 0x21c8 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    34b6:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    34b8:	9e 89       	ldd	r25, Y+22	; 0x16
    34ba:	80 91 8b 03 	lds	r24, 0x038B
    34be:	89 17       	cp	r24, r25
    34c0:	10 f4       	brcc	.+4      	; 0x34c6 <vCoRoutineSchedule+0x102>
    34c2:	90 93 8b 03 	sts	0x038B, r25
    34c6:	9f 9d       	mul	r25, r15
    34c8:	c0 01       	movw	r24, r0
    34ca:	11 24       	eor	r1, r1
    34cc:	8e 56       	subi	r24, 0x6E	; 110
    34ce:	9c 4f       	sbci	r25, 0xFC	; 252
    34d0:	b8 01       	movw	r22, r16
    34d2:	0e 94 86 10 	call	0x210c	; 0x210c <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( ( pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList ) ) != NULL )
    34d6:	e0 91 b6 03 	lds	r30, 0x03B6
    34da:	f0 91 b7 03 	lds	r31, 0x03B7
    34de:	80 81       	ld	r24, Z
    34e0:	88 23       	and	r24, r24
    34e2:	39 f0       	breq	.+14     	; 0x34f2 <vCoRoutineSchedule+0x12e>
    34e4:	05 80       	ldd	r0, Z+5	; 0x05
    34e6:	f6 81       	ldd	r31, Z+6	; 0x06
    34e8:	e0 2d       	mov	r30, r0
    34ea:	c6 81       	ldd	r28, Z+6	; 0x06
    34ec:	d7 81       	ldd	r29, Z+7	; 0x07
    34ee:	20 97       	sbiw	r28, 0x00	; 0
    34f0:	51 f6       	brne	.-108    	; 0x3486 <vCoRoutineSchedule+0xc2>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    34f2:	20 91 8e 03 	lds	r18, 0x038E
    34f6:	30 91 8f 03 	lds	r19, 0x038F
    34fa:	80 91 90 03 	lds	r24, 0x0390
    34fe:	90 91 91 03 	lds	r25, 0x0391
    3502:	21 15       	cp	r18, r1
    3504:	31 05       	cpc	r19, r1
    3506:	09 f0       	breq	.+2      	; 0x350a <vCoRoutineSchedule+0x146>
    3508:	a0 cf       	rjmp	.-192    	; 0x344a <vCoRoutineSchedule+0x86>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    350a:	90 93 8d 03 	sts	0x038D, r25
    350e:	80 93 8c 03 	sts	0x038C, r24
    3512:	90 91 8b 03 	lds	r25, 0x038B

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    3516:	29 e0       	ldi	r18, 0x09	; 9
    3518:	06 c0       	rjmp	.+12     	; 0x3526 <vCoRoutineSchedule+0x162>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    351a:	99 23       	and	r25, r25
    351c:	19 f4       	brne	.+6      	; 0x3524 <vCoRoutineSchedule+0x160>
    351e:	10 92 8b 03 	sts	0x038B, r1
    3522:	32 c0       	rjmp	.+100    	; 0x3588 <vCoRoutineSchedule+0x1c4>
    3524:	91 50       	subi	r25, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    3526:	92 9f       	mul	r25, r18
    3528:	d0 01       	movw	r26, r0
    352a:	11 24       	eor	r1, r1
    352c:	ae 56       	subi	r26, 0x6E	; 110
    352e:	bc 4f       	sbci	r27, 0xFC	; 252
    3530:	8c 91       	ld	r24, X
    3532:	88 23       	and	r24, r24
    3534:	91 f3       	breq	.-28     	; 0x351a <vCoRoutineSchedule+0x156>
    3536:	90 93 8b 03 	sts	0x038B, r25
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    353a:	11 96       	adiw	r26, 0x01	; 1
    353c:	ed 91       	ld	r30, X+
    353e:	fc 91       	ld	r31, X
    3540:	12 97       	sbiw	r26, 0x02	; 2
    3542:	02 80       	ldd	r0, Z+2	; 0x02
    3544:	f3 81       	ldd	r31, Z+3	; 0x03
    3546:	e0 2d       	mov	r30, r0
    3548:	12 96       	adiw	r26, 0x02	; 2
    354a:	fc 93       	st	X, r31
    354c:	ee 93       	st	-X, r30
    354e:	11 97       	sbiw	r26, 0x01	; 1
    3550:	cd 01       	movw	r24, r26
    3552:	03 96       	adiw	r24, 0x03	; 3
    3554:	e8 17       	cp	r30, r24
    3556:	f9 07       	cpc	r31, r25
    3558:	31 f4       	brne	.+12     	; 0x3566 <vCoRoutineSchedule+0x1a2>
    355a:	82 81       	ldd	r24, Z+2	; 0x02
    355c:	93 81       	ldd	r25, Z+3	; 0x03
    355e:	12 96       	adiw	r26, 0x02	; 2
    3560:	9c 93       	st	X, r25
    3562:	8e 93       	st	-X, r24
    3564:	11 97       	sbiw	r26, 0x01	; 1
    3566:	11 96       	adiw	r26, 0x01	; 1
    3568:	ed 91       	ld	r30, X+
    356a:	fc 91       	ld	r31, X
    356c:	12 97       	sbiw	r26, 0x02	; 2
    356e:	06 80       	ldd	r0, Z+6	; 0x06
    3570:	f7 81       	ldd	r31, Z+7	; 0x07
    3572:	e0 2d       	mov	r30, r0
    3574:	f0 93 8a 03 	sts	0x038A, r31
    3578:	e0 93 89 03 	sts	0x0389, r30

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    357c:	20 81       	ld	r18, Z
    357e:	31 81       	ldd	r19, Z+1	; 0x01
    3580:	cf 01       	movw	r24, r30
    3582:	67 89       	ldd	r22, Z+23	; 0x17
    3584:	f9 01       	movw	r30, r18
    3586:	09 95       	icall

	return;
}
    3588:	df 91       	pop	r29
    358a:	cf 91       	pop	r28
    358c:	1f 91       	pop	r17
    358e:	0f 91       	pop	r16
    3590:	ff 90       	pop	r15
    3592:	08 95       	ret

00003594 <vCoRoutineAddToDelayedList>:
	return xReturn;	
}
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    3594:	0f 93       	push	r16
    3596:	1f 93       	push	r17
    3598:	cf 93       	push	r28
    359a:	df 93       	push	r29
    359c:	eb 01       	movw	r28, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    359e:	00 91 90 03 	lds	r16, 0x0390
    35a2:	10 91 91 03 	lds	r17, 0x0391
    35a6:	08 0f       	add	r16, r24
    35a8:	19 1f       	adc	r17, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    35aa:	80 91 89 03 	lds	r24, 0x0389
    35ae:	90 91 8a 03 	lds	r25, 0x038A
    35b2:	02 96       	adiw	r24, 0x02	; 2
    35b4:	0e 94 e4 10 	call	0x21c8	; 0x21c8 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    35b8:	e0 91 89 03 	lds	r30, 0x0389
    35bc:	f0 91 8a 03 	lds	r31, 0x038A
    35c0:	13 83       	std	Z+3, r17	; 0x03
    35c2:	02 83       	std	Z+2, r16	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    35c4:	80 91 90 03 	lds	r24, 0x0390
    35c8:	90 91 91 03 	lds	r25, 0x0391
    35cc:	bf 01       	movw	r22, r30
    35ce:	6e 5f       	subi	r22, 0xFE	; 254
    35d0:	7f 4f       	sbci	r23, 0xFF	; 255
    35d2:	08 17       	cp	r16, r24
    35d4:	19 07       	cpc	r17, r25
    35d6:	28 f4       	brcc	.+10     	; 0x35e2 <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    35d8:	80 91 b8 03 	lds	r24, 0x03B8
    35dc:	90 91 b9 03 	lds	r25, 0x03B9
    35e0:	04 c0       	rjmp	.+8      	; 0x35ea <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    35e2:	80 91 b6 03 	lds	r24, 0x03B6
    35e6:	90 91 b7 03 	lds	r25, 0x03B7
    35ea:	0e 94 af 10 	call	0x215e	; 0x215e <vListInsert>
	}

	if( pxEventList )
    35ee:	20 97       	sbiw	r28, 0x00	; 0
    35f0:	49 f0       	breq	.+18     	; 0x3604 <vCoRoutineAddToDelayedList+0x70>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    35f2:	60 91 89 03 	lds	r22, 0x0389
    35f6:	70 91 8a 03 	lds	r23, 0x038A
    35fa:	64 5f       	subi	r22, 0xF4	; 244
    35fc:	7f 4f       	sbci	r23, 0xFF	; 255
    35fe:	ce 01       	movw	r24, r28
    3600:	0e 94 af 10 	call	0x215e	; 0x215e <vListInsert>
	}
}
    3604:	df 91       	pop	r29
    3606:	cf 91       	pop	r28
    3608:	1f 91       	pop	r17
    360a:	0f 91       	pop	r16
    360c:	08 95       	ret

0000360e <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    360e:	af 92       	push	r10
    3610:	bf 92       	push	r11
    3612:	cf 92       	push	r12
    3614:	df 92       	push	r13
    3616:	ef 92       	push	r14
    3618:	ff 92       	push	r15
    361a:	0f 93       	push	r16
    361c:	1f 93       	push	r17
    361e:	cf 93       	push	r28
    3620:	df 93       	push	r29
    3622:	6c 01       	movw	r12, r24
    3624:	b6 2e       	mov	r11, r22
    3626:	a4 2e       	mov	r10, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    3628:	8a e1       	ldi	r24, 0x1A	; 26
    362a:	90 e0       	ldi	r25, 0x00	; 0
    362c:	0e 94 91 1b 	call	0x3722	; 0x3722 <pvPortMalloc>
    3630:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
    3632:	00 97       	sbiw	r24, 0x00	; 0
    3634:	11 f4       	brne	.+4      	; 0x363a <xCoRoutineCreate+0x2c>
    3636:	8f ef       	ldi	r24, 0xFF	; 255
    3638:	59 c0       	rjmp	.+178    	; 0x36ec <xCoRoutineCreate+0xde>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    363a:	80 91 89 03 	lds	r24, 0x0389
    363e:	90 91 8a 03 	lds	r25, 0x038A
    3642:	89 2b       	or	r24, r25
    3644:	21 f5       	brne	.+72     	; 0x368e <xCoRoutineCreate+0x80>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    3646:	d0 93 8a 03 	sts	0x038A, r29
    364a:	c0 93 89 03 	sts	0x0389, r28
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    364e:	82 e9       	ldi	r24, 0x92	; 146
    3650:	93 e0       	ldi	r25, 0x03	; 3
    3652:	0e 94 72 10 	call	0x20e4	; 0x20e4 <vListInitialise>
    3656:	8b e9       	ldi	r24, 0x9B	; 155
    3658:	93 e0       	ldi	r25, 0x03	; 3
    365a:	0e 94 72 10 	call	0x20e4	; 0x20e4 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    365e:	24 ea       	ldi	r18, 0xA4	; 164
    3660:	e2 2e       	mov	r14, r18
    3662:	23 e0       	ldi	r18, 0x03	; 3
    3664:	f2 2e       	mov	r15, r18
    3666:	c7 01       	movw	r24, r14
    3668:	0e 94 72 10 	call	0x20e4	; 0x20e4 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    366c:	0d ea       	ldi	r16, 0xAD	; 173
    366e:	13 e0       	ldi	r17, 0x03	; 3
    3670:	c8 01       	movw	r24, r16
    3672:	0e 94 72 10 	call	0x20e4	; 0x20e4 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    3676:	8a eb       	ldi	r24, 0xBA	; 186
    3678:	93 e0       	ldi	r25, 0x03	; 3
    367a:	0e 94 72 10 	call	0x20e4	; 0x20e4 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    367e:	f0 92 b7 03 	sts	0x03B7, r15
    3682:	e0 92 b6 03 	sts	0x03B6, r14
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    3686:	10 93 b9 03 	sts	0x03B9, r17
    368a:	00 93 b8 03 	sts	0x03B8, r16
    368e:	eb 2c       	mov	r14, r11
    3690:	bb 20       	and	r11, r11
    3692:	11 f0       	breq	.+4      	; 0x3698 <xCoRoutineCreate+0x8a>
    3694:	ee 24       	eor	r14, r14
    3696:	e3 94       	inc	r14
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    3698:	19 8e       	std	Y+25, r1	; 0x19
    369a:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    369c:	ee 8a       	std	Y+22, r14	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    369e:	af 8a       	std	Y+23, r10	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    36a0:	fe 01       	movw	r30, r28
    36a2:	c1 92       	st	Z+, r12
    36a4:	d1 92       	st	Z+, r13
    36a6:	8f 01       	movw	r16, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    36a8:	cf 01       	movw	r24, r30
    36aa:	0e 94 82 10 	call	0x2104	; 0x2104 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    36ae:	ce 01       	movw	r24, r28
    36b0:	0c 96       	adiw	r24, 0x0c	; 12
    36b2:	0e 94 82 10 	call	0x2104	; 0x2104 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    36b6:	d9 87       	std	Y+9, r29	; 0x09
    36b8:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    36ba:	db 8b       	std	Y+19, r29	; 0x13
    36bc:	ca 8b       	std	Y+18, r28	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    36be:	84 e0       	ldi	r24, 0x04	; 4
    36c0:	90 e0       	ldi	r25, 0x00	; 0
    36c2:	8e 19       	sub	r24, r14
    36c4:	91 09       	sbc	r25, r1
    36c6:	9d 87       	std	Y+13, r25	; 0x0d
    36c8:	8c 87       	std	Y+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    36ca:	9e 89       	ldd	r25, Y+22	; 0x16
    36cc:	80 91 8b 03 	lds	r24, 0x038B
    36d0:	89 17       	cp	r24, r25
    36d2:	10 f4       	brcc	.+4      	; 0x36d8 <xCoRoutineCreate+0xca>
    36d4:	90 93 8b 03 	sts	0x038B, r25
    36d8:	89 e0       	ldi	r24, 0x09	; 9
    36da:	98 9f       	mul	r25, r24
    36dc:	c0 01       	movw	r24, r0
    36de:	11 24       	eor	r1, r1
    36e0:	8e 56       	subi	r24, 0x6E	; 110
    36e2:	9c 4f       	sbci	r25, 0xFC	; 252
    36e4:	b8 01       	movw	r22, r16
    36e6:	0e 94 86 10 	call	0x210c	; 0x210c <vListInsertEnd>
    36ea:	81 e0       	ldi	r24, 0x01	; 1
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
	}
	
	return xReturn;	
}
    36ec:	df 91       	pop	r29
    36ee:	cf 91       	pop	r28
    36f0:	1f 91       	pop	r17
    36f2:	0f 91       	pop	r16
    36f4:	ff 90       	pop	r15
    36f6:	ef 90       	pop	r14
    36f8:	df 90       	pop	r13
    36fa:	cf 90       	pop	r12
    36fc:	bf 90       	pop	r11
    36fe:	af 90       	pop	r10
    3700:	08 95       	ret

00003702 <vPortFree>:
{
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    3702:	08 95       	ret

00003704 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    3704:	10 92 c4 03 	sts	0x03C4, r1
    3708:	10 92 c3 03 	sts	0x03C3, r1
}
    370c:	08 95       	ret

0000370e <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    370e:	28 eb       	ldi	r18, 0xB8	; 184
    3710:	3b e0       	ldi	r19, 0x0B	; 11
    3712:	80 91 c3 03 	lds	r24, 0x03C3
    3716:	90 91 c4 03 	lds	r25, 0x03C4
    371a:	28 1b       	sub	r18, r24
    371c:	39 0b       	sbc	r19, r25
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
}
    371e:	c9 01       	movw	r24, r18
    3720:	08 95       	ret

00003722 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    3722:	0f 93       	push	r16
    3724:	1f 93       	push	r17
    3726:	cf 93       	push	r28
    3728:	df 93       	push	r29
    372a:	8c 01       	movw	r16, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    372c:	0e 94 f1 13 	call	0x27e2	; 0x27e2 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    3730:	80 91 c3 03 	lds	r24, 0x03C3
    3734:	90 91 c4 03 	lds	r25, 0x03C4
    3738:	98 01       	movw	r18, r16
    373a:	28 0f       	add	r18, r24
    373c:	39 1f       	adc	r19, r25
    373e:	4b e0       	ldi	r20, 0x0B	; 11
    3740:	28 3b       	cpi	r18, 0xB8	; 184
    3742:	34 07       	cpc	r19, r20
    3744:	58 f4       	brcc	.+22     	; 0x375c <pvPortMalloc+0x3a>
    3746:	82 17       	cp	r24, r18
    3748:	93 07       	cpc	r25, r19
    374a:	40 f4       	brcc	.+16     	; 0x375c <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    374c:	ec 01       	movw	r28, r24
    374e:	cb 53       	subi	r28, 0x3B	; 59
    3750:	dc 4f       	sbci	r29, 0xFC	; 252
			xNextFreeByte += xWantedSize;			
    3752:	30 93 c4 03 	sts	0x03C4, r19
    3756:	20 93 c3 03 	sts	0x03C3, r18
    375a:	02 c0       	rjmp	.+4      	; 0x3760 <pvPortMalloc+0x3e>
    375c:	c0 e0       	ldi	r28, 0x00	; 0
    375e:	d0 e0       	ldi	r29, 0x00	; 0
		}	
	}
	xTaskResumeAll();
    3760:	0e 94 88 15 	call	0x2b10	; 0x2b10 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
    3764:	ce 01       	movw	r24, r28
    3766:	df 91       	pop	r29
    3768:	cf 91       	pop	r28
    376a:	1f 91       	pop	r17
    376c:	0f 91       	pop	r16
    376e:	08 95       	ret

00003770 <prescaler_hex_to_value>:
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    3770:	e8 2f       	mov	r30, r24
    3772:	f0 e0       	ldi	r31, 0x00	; 0
    3774:	e7 70       	andi	r30, 0x07	; 7
    3776:	f0 70       	andi	r31, 0x00	; 0
    3778:	ee 0f       	add	r30, r30
    377a:	ff 1f       	adc	r31, r31
    377c:	ec 54       	subi	r30, 0x4C	; 76
    377e:	fe 4f       	sbci	r31, 0xFE	; 254
    3780:	25 91       	lpm	r18, Z+
    3782:	34 91       	lpm	r19, Z+
}
    3784:	c9 01       	movw	r24, r18
    3786:	08 95       	ret

00003788 <prescaler_hex_to_value_for_timer2>:
uint16_t prescaler_hex_to_value_for_timer2(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to Timer2PrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(Timer2PrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    3788:	e8 2f       	mov	r30, r24
    378a:	f0 e0       	ldi	r31, 0x00	; 0
    378c:	e7 70       	andi	r30, 0x07	; 7
    378e:	f0 70       	andi	r31, 0x00	; 0
    3790:	ee 0f       	add	r30, r30
    3792:	ff 1f       	adc	r31, r31
    3794:	e0 54       	subi	r30, 0x40	; 64
    3796:	fe 4f       	sbci	r31, 0xFE	; 254
    3798:	25 91       	lpm	r18, Z+
    379a:	34 91       	lpm	r19, Z+
}
    379c:	c9 01       	movw	r24, r18
    379e:	08 95       	ret

000037a0 <get_timer0_prescaler>:

uint16_t get_timer0_prescaler(void)
{
  return prescaler_hex_to_value(TCCR0B);
    37a0:	85 b5       	in	r24, 0x25	; 37
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    37a2:	e8 2f       	mov	r30, r24
    37a4:	f0 e0       	ldi	r31, 0x00	; 0
    37a6:	e7 70       	andi	r30, 0x07	; 7
    37a8:	f0 70       	andi	r31, 0x00	; 0
    37aa:	ee 0f       	add	r30, r30
    37ac:	ff 1f       	adc	r31, r31
    37ae:	ec 54       	subi	r30, 0x4C	; 76
    37b0:	fe 4f       	sbci	r31, 0xFE	; 254
    37b2:	25 91       	lpm	r18, Z+
    37b4:	34 91       	lpm	r19, Z+
}

uint16_t get_timer0_prescaler(void)
{
  return prescaler_hex_to_value(TCCR0B);
}
    37b6:	c9 01       	movw	r24, r18
    37b8:	08 95       	ret

000037ba <get_timer1_prescaler>:
uint16_t get_timer1_prescaler(void)
{
  return prescaler_hex_to_value(TCCR1B);
    37ba:	80 91 81 00 	lds	r24, 0x0081
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    37be:	e8 2f       	mov	r30, r24
    37c0:	f0 e0       	ldi	r31, 0x00	; 0
    37c2:	e7 70       	andi	r30, 0x07	; 7
    37c4:	f0 70       	andi	r31, 0x00	; 0
    37c6:	ee 0f       	add	r30, r30
    37c8:	ff 1f       	adc	r31, r31
    37ca:	ec 54       	subi	r30, 0x4C	; 76
    37cc:	fe 4f       	sbci	r31, 0xFE	; 254
    37ce:	25 91       	lpm	r18, Z+
    37d0:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR0B);
}
uint16_t get_timer1_prescaler(void)
{
  return prescaler_hex_to_value(TCCR1B);
}
    37d2:	c9 01       	movw	r24, r18
    37d4:	08 95       	ret

000037d6 <get_timer2_prescaler>:
uint16_t get_timer2_prescaler(void)
{
  return prescaler_hex_to_value_for_timer2(TCCR2B);
    37d6:	80 91 b1 00 	lds	r24, 0x00B1
uint16_t prescaler_hex_to_value_for_timer2(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to Timer2PrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(Timer2PrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    37da:	e8 2f       	mov	r30, r24
    37dc:	f0 e0       	ldi	r31, 0x00	; 0
    37de:	e7 70       	andi	r30, 0x07	; 7
    37e0:	f0 70       	andi	r31, 0x00	; 0
    37e2:	ee 0f       	add	r30, r30
    37e4:	ff 1f       	adc	r31, r31
    37e6:	e0 54       	subi	r30, 0x40	; 64
    37e8:	fe 4f       	sbci	r31, 0xFE	; 254
    37ea:	25 91       	lpm	r18, Z+
    37ec:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR1B);
}
uint16_t get_timer2_prescaler(void)
{
  return prescaler_hex_to_value_for_timer2(TCCR2B);
}
    37ee:	c9 01       	movw	r24, r18
    37f0:	08 95       	ret

000037f2 <get_timer3_prescaler>:
uint16_t get_timer3_prescaler(void)
{
  return prescaler_hex_to_value(TCCR3B);
    37f2:	80 91 91 00 	lds	r24, 0x0091
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    37f6:	e8 2f       	mov	r30, r24
    37f8:	f0 e0       	ldi	r31, 0x00	; 0
    37fa:	e7 70       	andi	r30, 0x07	; 7
    37fc:	f0 70       	andi	r31, 0x00	; 0
    37fe:	ee 0f       	add	r30, r30
    3800:	ff 1f       	adc	r31, r31
    3802:	ec 54       	subi	r30, 0x4C	; 76
    3804:	fe 4f       	sbci	r31, 0xFE	; 254
    3806:	25 91       	lpm	r18, Z+
    3808:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value_for_timer2(TCCR2B);
}
uint16_t get_timer3_prescaler(void)
{
  return prescaler_hex_to_value(TCCR3B);
}
    380a:	c9 01       	movw	r24, r18
    380c:	08 95       	ret

0000380e <get_timer4_prescaler>:
uint16_t get_timer4_prescaler(void)
{
  return prescaler_hex_to_value(TCCR4B);
    380e:	80 91 a1 00 	lds	r24, 0x00A1
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    3812:	e8 2f       	mov	r30, r24
    3814:	f0 e0       	ldi	r31, 0x00	; 0
    3816:	e7 70       	andi	r30, 0x07	; 7
    3818:	f0 70       	andi	r31, 0x00	; 0
    381a:	ee 0f       	add	r30, r30
    381c:	ff 1f       	adc	r31, r31
    381e:	ec 54       	subi	r30, 0x4C	; 76
    3820:	fe 4f       	sbci	r31, 0xFE	; 254
    3822:	25 91       	lpm	r18, Z+
    3824:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR3B);
}
uint16_t get_timer4_prescaler(void)
{
  return prescaler_hex_to_value(TCCR4B);
}
    3826:	c9 01       	movw	r24, r18
    3828:	08 95       	ret

0000382a <get_timer5_prescaler>:
uint16_t get_timer5_prescaler(void)
{
  return prescaler_hex_to_value(TCCR5B);
    382a:	80 91 21 01 	lds	r24, 0x0121
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    382e:	e8 2f       	mov	r30, r24
    3830:	f0 e0       	ldi	r31, 0x00	; 0
    3832:	e7 70       	andi	r30, 0x07	; 7
    3834:	f0 70       	andi	r31, 0x00	; 0
    3836:	ee 0f       	add	r30, r30
    3838:	ff 1f       	adc	r31, r31
    383a:	ec 54       	subi	r30, 0x4C	; 76
    383c:	fe 4f       	sbci	r31, 0xFE	; 254
    383e:	25 91       	lpm	r18, Z+
    3840:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR4B);
}
uint16_t get_timer5_prescaler(void)
{
  return prescaler_hex_to_value(TCCR5B);
}
    3842:	c9 01       	movw	r24, r18
    3844:	08 95       	ret

00003846 <get_timer0_overflow>:

const uint32_t get_timer0_overflow(void)
{
    return timer0_ovrflow_cnt;
    3846:	20 91 64 12 	lds	r18, 0x1264
    384a:	30 91 65 12 	lds	r19, 0x1265
    384e:	40 91 66 12 	lds	r20, 0x1266
    3852:	50 91 67 12 	lds	r21, 0x1267
}
    3856:	b9 01       	movw	r22, r18
    3858:	ca 01       	movw	r24, r20
    385a:	08 95       	ret

0000385c <get_timer1_overflow>:
const uint32_t get_timer1_overflow(void)
{
    return timer1_ovrflow_cnt;
    385c:	20 91 60 12 	lds	r18, 0x1260
    3860:	30 91 61 12 	lds	r19, 0x1261
    3864:	40 91 62 12 	lds	r20, 0x1262
    3868:	50 91 63 12 	lds	r21, 0x1263
}
    386c:	b9 01       	movw	r22, r18
    386e:	ca 01       	movw	r24, r20
    3870:	08 95       	ret

00003872 <get_timer2_overflow>:
const uint32_t get_timer2_overflow(void)
{
    return timer2_ovrflow_cnt;
    3872:	20 91 68 12 	lds	r18, 0x1268
    3876:	30 91 69 12 	lds	r19, 0x1269
    387a:	40 91 6a 12 	lds	r20, 0x126A
    387e:	50 91 6b 12 	lds	r21, 0x126B
}
    3882:	b9 01       	movw	r22, r18
    3884:	ca 01       	movw	r24, r20
    3886:	08 95       	ret

00003888 <get_timer3_overflow>:
const uint32_t get_timer3_overflow(void)
{
    return timer3_ovrflow_cnt;
    3888:	20 91 70 12 	lds	r18, 0x1270
    388c:	30 91 71 12 	lds	r19, 0x1271
    3890:	40 91 72 12 	lds	r20, 0x1272
    3894:	50 91 73 12 	lds	r21, 0x1273
}
    3898:	b9 01       	movw	r22, r18
    389a:	ca 01       	movw	r24, r20
    389c:	08 95       	ret

0000389e <get_timer4_overflow>:
const uint32_t get_timer4_overflow(void)
{
    return timer4_ovrflow_cnt;
    389e:	20 91 5c 12 	lds	r18, 0x125C
    38a2:	30 91 5d 12 	lds	r19, 0x125D
    38a6:	40 91 5e 12 	lds	r20, 0x125E
    38aa:	50 91 5f 12 	lds	r21, 0x125F
}
    38ae:	b9 01       	movw	r22, r18
    38b0:	ca 01       	movw	r24, r20
    38b2:	08 95       	ret

000038b4 <get_timer5_overflow>:
const uint32_t get_timer5_overflow(void)
{
    return timer5_ovrflow_cnt;
    38b4:	20 91 74 12 	lds	r18, 0x1274
    38b8:	30 91 75 12 	lds	r19, 0x1275
    38bc:	40 91 76 12 	lds	r20, 0x1276
    38c0:	50 91 77 12 	lds	r21, 0x1277
}
    38c4:	b9 01       	movw	r22, r18
    38c6:	ca 01       	movw	r24, r20
    38c8:	08 95       	ret

000038ca <get_timer0_counter>:

const uint8_t get_timer0_counter(void)
{
    return TCNT0;
    38ca:	86 b5       	in	r24, 0x26	; 38
}
    38cc:	08 95       	ret

000038ce <get_timer1_counter>:
const uint16_t get_timer1_counter(void)
{
    return TCNT1;
    38ce:	20 91 84 00 	lds	r18, 0x0084
    38d2:	30 91 85 00 	lds	r19, 0x0085
}
    38d6:	c9 01       	movw	r24, r18
    38d8:	08 95       	ret

000038da <get_timer2_counter>:
const uint8_t get_timer2_counter(void)
{
    return TCNT2;
    38da:	80 91 b2 00 	lds	r24, 0x00B2
}
    38de:	08 95       	ret

000038e0 <get_timer3_counter>:
const uint16_t get_timer3_counter(void)
{
    return TCNT3;
    38e0:	20 91 94 00 	lds	r18, 0x0094
    38e4:	30 91 95 00 	lds	r19, 0x0095
}
    38e8:	c9 01       	movw	r24, r18
    38ea:	08 95       	ret

000038ec <get_timer4_counter>:
const uint16_t get_timer4_counter(void)
{
    return TCNT4;
    38ec:	20 91 a4 00 	lds	r18, 0x00A4
    38f0:	30 91 a5 00 	lds	r19, 0x00A5
}
    38f4:	c9 01       	movw	r24, r18
    38f6:	08 95       	ret

000038f8 <get_timer5_counter>:
const uint16_t get_timer5_counter(void)
{
    return TCNT5;
    38f8:	20 91 24 01 	lds	r18, 0x0124
    38fc:	30 91 25 01 	lds	r19, 0x0125
}
    3900:	c9 01       	movw	r24, r18
    3902:	08 95       	ret

00003904 <reset_timer0>:

void reset_timer0(void)
{
    TCNT0 = timer0_ovrflow_cnt = 0;
    3904:	10 92 64 12 	sts	0x1264, r1
    3908:	10 92 65 12 	sts	0x1265, r1
    390c:	10 92 66 12 	sts	0x1266, r1
    3910:	10 92 67 12 	sts	0x1267, r1
    3914:	16 bc       	out	0x26, r1	; 38
}
    3916:	08 95       	ret

00003918 <reset_timer1>:
void reset_timer1(void)
{
    TCNT1 = timer1_ovrflow_cnt = 0;
    3918:	10 92 60 12 	sts	0x1260, r1
    391c:	10 92 61 12 	sts	0x1261, r1
    3920:	10 92 62 12 	sts	0x1262, r1
    3924:	10 92 63 12 	sts	0x1263, r1
    3928:	10 92 85 00 	sts	0x0085, r1
    392c:	10 92 84 00 	sts	0x0084, r1
}
    3930:	08 95       	ret

00003932 <reset_timer2>:
void reset_timer2(void)
{
    TCNT2 = timer2_ovrflow_cnt = 0;
    3932:	10 92 68 12 	sts	0x1268, r1
    3936:	10 92 69 12 	sts	0x1269, r1
    393a:	10 92 6a 12 	sts	0x126A, r1
    393e:	10 92 6b 12 	sts	0x126B, r1
    3942:	10 92 b2 00 	sts	0x00B2, r1
}
    3946:	08 95       	ret

00003948 <reset_timer3>:
void reset_timer3(void)
{
    TCNT3 = timer3_ovrflow_cnt = 0;
    3948:	10 92 70 12 	sts	0x1270, r1
    394c:	10 92 71 12 	sts	0x1271, r1
    3950:	10 92 72 12 	sts	0x1272, r1
    3954:	10 92 73 12 	sts	0x1273, r1
    3958:	10 92 95 00 	sts	0x0095, r1
    395c:	10 92 94 00 	sts	0x0094, r1
}
    3960:	08 95       	ret

00003962 <reset_timer4>:
void reset_timer4(void)
{
    TCNT4 = timer4_ovrflow_cnt = 0;
    3962:	10 92 5c 12 	sts	0x125C, r1
    3966:	10 92 5d 12 	sts	0x125D, r1
    396a:	10 92 5e 12 	sts	0x125E, r1
    396e:	10 92 5f 12 	sts	0x125F, r1
    3972:	10 92 a5 00 	sts	0x00A5, r1
    3976:	10 92 a4 00 	sts	0x00A4, r1
}
    397a:	08 95       	ret

0000397c <reset_timer5>:
void reset_timer5(void)
{
    TCNT5 = timer5_ovrflow_cnt = 0;
    397c:	10 92 74 12 	sts	0x1274, r1
    3980:	10 92 75 12 	sts	0x1275, r1
    3984:	10 92 76 12 	sts	0x1276, r1
    3988:	10 92 77 12 	sts	0x1277, r1
    398c:	10 92 25 01 	sts	0x0125, r1
    3990:	10 92 24 01 	sts	0x0124, r1
}
    3994:	08 95       	ret

00003996 <delay_us>:

	delay_loops = ((time_us * CYCLES_PER_US)+3) / 5; // +3 for rounding up (dirty) 

	// one loop takes 5 cpu cycles 
	for (i=0; i < delay_loops; i++) {};
}
    3996:	08 95       	ret

00003998 <init_timer0>:

void init_timer0(const uint8_t prescaler)
{
  TCCR0B = prescaler;
    3998:	85 bd       	out	0x25, r24	; 37
  TIMSK0 = _BV(TOIE0); // enable interrupts
    399a:	81 e0       	ldi	r24, 0x01	; 1
    399c:	80 93 6e 00 	sts	0x006E, r24
    return TCNT5;
}

void reset_timer0(void)
{
    TCNT0 = timer0_ovrflow_cnt = 0;
    39a0:	10 92 64 12 	sts	0x1264, r1
    39a4:	10 92 65 12 	sts	0x1265, r1
    39a8:	10 92 66 12 	sts	0x1266, r1
    39ac:	10 92 67 12 	sts	0x1267, r1
    39b0:	16 bc       	out	0x26, r1	; 38
void init_timer0(const uint8_t prescaler)
{
  TCCR0B = prescaler;
  TIMSK0 = _BV(TOIE0); // enable interrupts
  reset_timer0(); // reset counter
}
    39b2:	08 95       	ret

000039b4 <init_timer1>:
void init_timer1(const uint8_t prescaler)
{
  TCCR1B = prescaler;
    39b4:	80 93 81 00 	sts	0x0081, r24
  TIMSK1 = _BV(TOIE1); // enable interrupts
    39b8:	81 e0       	ldi	r24, 0x01	; 1
    39ba:	80 93 6f 00 	sts	0x006F, r24
{
    TCNT0 = timer0_ovrflow_cnt = 0;
}
void reset_timer1(void)
{
    TCNT1 = timer1_ovrflow_cnt = 0;
    39be:	10 92 60 12 	sts	0x1260, r1
    39c2:	10 92 61 12 	sts	0x1261, r1
    39c6:	10 92 62 12 	sts	0x1262, r1
    39ca:	10 92 63 12 	sts	0x1263, r1
    39ce:	10 92 85 00 	sts	0x0085, r1
    39d2:	10 92 84 00 	sts	0x0084, r1
void init_timer1(const uint8_t prescaler)
{
  TCCR1B = prescaler;
  TIMSK1 = _BV(TOIE1); // enable interrupts
  reset_timer1(); // reset counter
}
    39d6:	08 95       	ret

000039d8 <init_timer2>:
void init_timer2(const uint8_t prescaler)
{
  TCCR2B = prescaler;
    39d8:	80 93 b1 00 	sts	0x00B1, r24
  TIMSK2 = _BV(TOIE2); // enable interrupts
    39dc:	81 e0       	ldi	r24, 0x01	; 1
    39de:	80 93 70 00 	sts	0x0070, r24
{
    TCNT1 = timer1_ovrflow_cnt = 0;
}
void reset_timer2(void)
{
    TCNT2 = timer2_ovrflow_cnt = 0;
    39e2:	10 92 68 12 	sts	0x1268, r1
    39e6:	10 92 69 12 	sts	0x1269, r1
    39ea:	10 92 6a 12 	sts	0x126A, r1
    39ee:	10 92 6b 12 	sts	0x126B, r1
    39f2:	10 92 b2 00 	sts	0x00B2, r1
void init_timer2(const uint8_t prescaler)
{
  TCCR2B = prescaler;
  TIMSK2 = _BV(TOIE2); // enable interrupts
  reset_timer2(); // reset counter
}
    39f6:	08 95       	ret

000039f8 <init_timer3>:
void init_timer3(const uint8_t prescaler)
{
  TCCR3B = prescaler;
    39f8:	80 93 91 00 	sts	0x0091, r24
  TIMSK3 = _BV(TOIE3); // enable interrupts
    39fc:	81 e0       	ldi	r24, 0x01	; 1
    39fe:	80 93 71 00 	sts	0x0071, r24
{
    TCNT2 = timer2_ovrflow_cnt = 0;
}
void reset_timer3(void)
{
    TCNT3 = timer3_ovrflow_cnt = 0;
    3a02:	10 92 70 12 	sts	0x1270, r1
    3a06:	10 92 71 12 	sts	0x1271, r1
    3a0a:	10 92 72 12 	sts	0x1272, r1
    3a0e:	10 92 73 12 	sts	0x1273, r1
    3a12:	10 92 95 00 	sts	0x0095, r1
    3a16:	10 92 94 00 	sts	0x0094, r1
void init_timer3(const uint8_t prescaler)
{
  TCCR3B = prescaler;
  TIMSK3 = _BV(TOIE3); // enable interrupts
  reset_timer3(); // reset counter
}
    3a1a:	08 95       	ret

00003a1c <init_timer4>:
void init_timer4(const uint8_t prescaler)
{
  TCCR4B = prescaler;
    3a1c:	80 93 a1 00 	sts	0x00A1, r24
  TIMSK4 = _BV(TOIE4); // enable interrupts
    3a20:	81 e0       	ldi	r24, 0x01	; 1
    3a22:	80 93 72 00 	sts	0x0072, r24
{
    TCNT3 = timer3_ovrflow_cnt = 0;
}
void reset_timer4(void)
{
    TCNT4 = timer4_ovrflow_cnt = 0;
    3a26:	10 92 5c 12 	sts	0x125C, r1
    3a2a:	10 92 5d 12 	sts	0x125D, r1
    3a2e:	10 92 5e 12 	sts	0x125E, r1
    3a32:	10 92 5f 12 	sts	0x125F, r1
    3a36:	10 92 a5 00 	sts	0x00A5, r1
    3a3a:	10 92 a4 00 	sts	0x00A4, r1
void init_timer4(const uint8_t prescaler)
{
  TCCR4B = prescaler;
  TIMSK4 = _BV(TOIE4); // enable interrupts
  reset_timer4(); // reset counter
}
    3a3e:	08 95       	ret

00003a40 <init_timer5>:
void init_timer5(const uint8_t prescaler)
{
  TCCR5B = prescaler;
    3a40:	80 93 21 01 	sts	0x0121, r24
  TIMSK5 = _BV(TOIE5); // enable interrupts
    3a44:	81 e0       	ldi	r24, 0x01	; 1
    3a46:	80 93 73 00 	sts	0x0073, r24
{
    TCNT4 = timer4_ovrflow_cnt = 0;
}
void reset_timer5(void)
{
    TCNT5 = timer5_ovrflow_cnt = 0;
    3a4a:	10 92 74 12 	sts	0x1274, r1
    3a4e:	10 92 75 12 	sts	0x1275, r1
    3a52:	10 92 76 12 	sts	0x1276, r1
    3a56:	10 92 77 12 	sts	0x1277, r1
    3a5a:	10 92 25 01 	sts	0x0125, r1
    3a5e:	10 92 24 01 	sts	0x0124, r1
void init_timer5(const uint8_t prescaler)
{
  TCCR5B = prescaler;
  TIMSK5 = _BV(TOIE5); // enable interrupts
  reset_timer5(); // reset counter
}
    3a62:	08 95       	ret

00003a64 <timer_attach>:

void timer_attach(TimerInterrupt_t interrupt, void (*user_func)(void) )
{
  // set the interrupt function to run
  // the supplied user's function
  TimerIntFunc[interrupt] = user_func;
    3a64:	e8 2f       	mov	r30, r24
    3a66:	f0 e0       	ldi	r31, 0x00	; 0
    3a68:	ee 0f       	add	r30, r30
    3a6a:	ff 1f       	adc	r31, r31
    3a6c:	e3 58       	subi	r30, 0x83	; 131
    3a6e:	f0 4f       	sbci	r31, 0xF0	; 240
    3a70:	71 83       	std	Z+1, r23	; 0x01
    3a72:	60 83       	st	Z, r22
}
    3a74:	08 95       	ret

00003a76 <timer_detach>:

void timer_detach(TimerInterrupt_t interrupt)
{
  // clear the user defined interrupt function
  TimerIntFunc[interrupt] = NULL;
    3a76:	e8 2f       	mov	r30, r24
    3a78:	f0 e0       	ldi	r31, 0x00	; 0
    3a7a:	ee 0f       	add	r30, r30
    3a7c:	ff 1f       	adc	r31, r31
    3a7e:	e3 58       	subi	r30, 0x83	; 131
    3a80:	f0 4f       	sbci	r31, 0xF0	; 240
    3a82:	11 82       	std	Z+1, r1	; 0x01
    3a84:	10 82       	st	Z, r1
}
    3a86:	08 95       	ret

00003a88 <_delay_loop_2>:

void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3a88:	01 97       	sbiw	r24, 0x01	; 1
    3a8a:	f1 f7       	brne	.-4      	; 0x3a88 <_delay_loop_2>
		"1: sbiw %0,1" "\n\t"
		"brne 1b"
		: "=w" (__count)
		: "0" (__count)
	);
}
    3a8c:	08 95       	ret

00003a8e <sleep>:

void sleep(uint16_t time_ms)
{
    3a8e:	af 92       	push	r10
    3a90:	bf 92       	push	r11
    3a92:	cf 92       	push	r12
    3a94:	df 92       	push	r13
    3a96:	ef 92       	push	r14
    3a98:	ff 92       	push	r15
    3a9a:	0f 93       	push	r16
    3a9c:	1f 93       	push	r17
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * time_ms;
    3a9e:	a0 e0       	ldi	r26, 0x00	; 0
    3aa0:	b0 e0       	ldi	r27, 0x00	; 0
    3aa2:	bc 01       	movw	r22, r24
    3aa4:	cd 01       	movw	r24, r26
    3aa6:	0e 94 89 2e 	call	0x5d12	; 0x5d12 <__floatunsisf>
    3aaa:	5b 01       	movw	r10, r22
    3aac:	6c 01       	movw	r12, r24
    3aae:	20 e0       	ldi	r18, 0x00	; 0
    3ab0:	30 e0       	ldi	r19, 0x00	; 0
    3ab2:	4a e7       	ldi	r20, 0x7A	; 122
    3ab4:	55 e4       	ldi	r21, 0x45	; 69
    3ab6:	0e 94 3f 2f 	call	0x5e7e	; 0x5e7e <__mulsf3>
    3aba:	7b 01       	movw	r14, r22
    3abc:	8c 01       	movw	r16, r24
	if (__tmp < 1.0)
    3abe:	20 e0       	ldi	r18, 0x00	; 0
    3ac0:	30 e0       	ldi	r19, 0x00	; 0
    3ac2:	40 e8       	ldi	r20, 0x80	; 128
    3ac4:	5f e3       	ldi	r21, 0x3F	; 63
    3ac6:	0e 94 ec 2d 	call	0x5bd8	; 0x5bd8 <__cmpsf2>
    3aca:	88 23       	and	r24, r24
    3acc:	1c f4       	brge	.+6      	; 0x3ad4 <sleep+0x46>
    3ace:	61 e0       	ldi	r22, 0x01	; 1
    3ad0:	70 e0       	ldi	r23, 0x00	; 0
    3ad2:	24 c0       	rjmp	.+72     	; 0x3b1c <sleep+0x8e>
		__ticks = 1;
	else if (__tmp > 65535)
    3ad4:	c8 01       	movw	r24, r16
    3ad6:	b7 01       	movw	r22, r14
    3ad8:	20 e0       	ldi	r18, 0x00	; 0
    3ada:	3f ef       	ldi	r19, 0xFF	; 255
    3adc:	4f e7       	ldi	r20, 0x7F	; 127
    3ade:	57 e4       	ldi	r21, 0x47	; 71
    3ae0:	0e 94 3b 2f 	call	0x5e76	; 0x5e76 <__gesf2>
    3ae4:	18 16       	cp	r1, r24
    3ae6:	b4 f4       	brge	.+44     	; 0x3b14 <sleep+0x86>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (time_ms * 10.0);
    3ae8:	c6 01       	movw	r24, r12
    3aea:	b5 01       	movw	r22, r10
    3aec:	20 e0       	ldi	r18, 0x00	; 0
    3aee:	30 e0       	ldi	r19, 0x00	; 0
    3af0:	40 e2       	ldi	r20, 0x20	; 32
    3af2:	51 e4       	ldi	r21, 0x41	; 65
    3af4:	0e 94 3f 2f 	call	0x5e7e	; 0x5e7e <__mulsf3>
    3af8:	0e 94 5d 2e 	call	0x5cba	; 0x5cba <__fixunssfsi>
}

void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3afc:	80 e9       	ldi	r24, 0x90	; 144
    3afe:	91 e0       	ldi	r25, 0x01	; 1
    3b00:	05 c0       	rjmp	.+10     	; 0x3b0c <sleep+0x7e>
    3b02:	fc 01       	movw	r30, r24
    3b04:	31 97       	sbiw	r30, 0x01	; 1
    3b06:	f1 f7       	brne	.-4      	; 0x3b04 <sleep+0x76>
		__ticks = (uint16_t) (time_ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3b08:	61 50       	subi	r22, 0x01	; 1
    3b0a:	70 40       	sbci	r23, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (time_ms * 10.0);
		while(__ticks)
    3b0c:	61 15       	cp	r22, r1
    3b0e:	71 05       	cpc	r23, r1
    3b10:	c1 f7       	brne	.-16     	; 0x3b02 <sleep+0x74>
    3b12:	07 c0       	rjmp	.+14     	; 0x3b22 <sleep+0x94>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3b14:	c8 01       	movw	r24, r16
    3b16:	b7 01       	movw	r22, r14
    3b18:	0e 94 5d 2e 	call	0x5cba	; 0x5cba <__fixunssfsi>
}

void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3b1c:	cb 01       	movw	r24, r22
    3b1e:	01 97       	sbiw	r24, 0x01	; 1
    3b20:	f1 f7       	brne	.-4      	; 0x3b1e <sleep+0x90>
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
	_delay_loop_2(__ticks);
}
    3b22:	1f 91       	pop	r17
    3b24:	0f 91       	pop	r16
    3b26:	ff 90       	pop	r15
    3b28:	ef 90       	pop	r14
    3b2a:	df 90       	pop	r13
    3b2c:	cf 90       	pop	r12
    3b2e:	bf 90       	pop	r11
    3b30:	af 90       	pop	r10
    3b32:	08 95       	ret

00003b34 <__vector_23>:
    }
  }
}*/

ISR(TIMER0_OVF_vect) 
{
    3b34:	1f 92       	push	r1
    3b36:	0f 92       	push	r0
    3b38:	0f b6       	in	r0, 0x3f	; 63
    3b3a:	0f 92       	push	r0
    3b3c:	11 24       	eor	r1, r1
    3b3e:	2f 93       	push	r18
    3b40:	3f 93       	push	r19
    3b42:	4f 93       	push	r20
    3b44:	5f 93       	push	r21
    3b46:	6f 93       	push	r22
    3b48:	7f 93       	push	r23
    3b4a:	8f 93       	push	r24
    3b4c:	9f 93       	push	r25
    3b4e:	af 93       	push	r26
    3b50:	bf 93       	push	r27
    3b52:	ef 93       	push	r30
    3b54:	ff 93       	push	r31
  timer0_ovrflow_cnt++;
    3b56:	80 91 64 12 	lds	r24, 0x1264
    3b5a:	90 91 65 12 	lds	r25, 0x1265
    3b5e:	a0 91 66 12 	lds	r26, 0x1266
    3b62:	b0 91 67 12 	lds	r27, 0x1267
    3b66:	01 96       	adiw	r24, 0x01	; 1
    3b68:	a1 1d       	adc	r26, r1
    3b6a:	b1 1d       	adc	r27, r1
    3b6c:	80 93 64 12 	sts	0x1264, r24
    3b70:	90 93 65 12 	sts	0x1265, r25
    3b74:	a0 93 66 12 	sts	0x1266, r26
    3b78:	b0 93 67 12 	sts	0x1267, r27
  timer_sleep_cnt++;
    3b7c:	80 91 6c 12 	lds	r24, 0x126C
    3b80:	90 91 6d 12 	lds	r25, 0x126D
    3b84:	a0 91 6e 12 	lds	r26, 0x126E
    3b88:	b0 91 6f 12 	lds	r27, 0x126F
    3b8c:	01 96       	adiw	r24, 0x01	; 1
    3b8e:	a1 1d       	adc	r26, r1
    3b90:	b1 1d       	adc	r27, r1
    3b92:	80 93 6c 12 	sts	0x126C, r24
    3b96:	90 93 6d 12 	sts	0x126D, r25
    3b9a:	a0 93 6e 12 	sts	0x126E, r26
    3b9e:	b0 93 6f 12 	sts	0x126F, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER0_OVF_interrupt);
    3ba2:	80 91 81 0f 	lds	r24, 0x0F81
    3ba6:	90 91 82 0f 	lds	r25, 0x0F82
    3baa:	89 2b       	or	r24, r25
    3bac:	29 f0       	breq	.+10     	; 0x3bb8 <__vector_23+0x84>
    3bae:	e0 91 81 0f 	lds	r30, 0x0F81
    3bb2:	f0 91 82 0f 	lds	r31, 0x0F82
    3bb6:	09 95       	icall
}
    3bb8:	ff 91       	pop	r31
    3bba:	ef 91       	pop	r30
    3bbc:	bf 91       	pop	r27
    3bbe:	af 91       	pop	r26
    3bc0:	9f 91       	pop	r25
    3bc2:	8f 91       	pop	r24
    3bc4:	7f 91       	pop	r23
    3bc6:	6f 91       	pop	r22
    3bc8:	5f 91       	pop	r21
    3bca:	4f 91       	pop	r20
    3bcc:	3f 91       	pop	r19
    3bce:	2f 91       	pop	r18
    3bd0:	0f 90       	pop	r0
    3bd2:	0f be       	out	0x3f, r0	; 63
    3bd4:	0f 90       	pop	r0
    3bd6:	1f 90       	pop	r1
    3bd8:	18 95       	reti

00003bda <__vector_20>:
ISR(TIMER1_OVF_vect) 
{
    3bda:	1f 92       	push	r1
    3bdc:	0f 92       	push	r0
    3bde:	0f b6       	in	r0, 0x3f	; 63
    3be0:	0f 92       	push	r0
    3be2:	11 24       	eor	r1, r1
    3be4:	2f 93       	push	r18
    3be6:	3f 93       	push	r19
    3be8:	4f 93       	push	r20
    3bea:	5f 93       	push	r21
    3bec:	6f 93       	push	r22
    3bee:	7f 93       	push	r23
    3bf0:	8f 93       	push	r24
    3bf2:	9f 93       	push	r25
    3bf4:	af 93       	push	r26
    3bf6:	bf 93       	push	r27
    3bf8:	ef 93       	push	r30
    3bfa:	ff 93       	push	r31
  timer1_ovrflow_cnt++;
    3bfc:	80 91 60 12 	lds	r24, 0x1260
    3c00:	90 91 61 12 	lds	r25, 0x1261
    3c04:	a0 91 62 12 	lds	r26, 0x1262
    3c08:	b0 91 63 12 	lds	r27, 0x1263
    3c0c:	01 96       	adiw	r24, 0x01	; 1
    3c0e:	a1 1d       	adc	r26, r1
    3c10:	b1 1d       	adc	r27, r1
    3c12:	80 93 60 12 	sts	0x1260, r24
    3c16:	90 93 61 12 	sts	0x1261, r25
    3c1a:	a0 93 62 12 	sts	0x1262, r26
    3c1e:	b0 93 63 12 	sts	0x1263, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER1_OVF_interrupt);
    3c22:	80 91 8b 0f 	lds	r24, 0x0F8B
    3c26:	90 91 8c 0f 	lds	r25, 0x0F8C
    3c2a:	89 2b       	or	r24, r25
    3c2c:	29 f0       	breq	.+10     	; 0x3c38 <__vector_20+0x5e>
    3c2e:	e0 91 8b 0f 	lds	r30, 0x0F8B
    3c32:	f0 91 8c 0f 	lds	r31, 0x0F8C
    3c36:	09 95       	icall
}
    3c38:	ff 91       	pop	r31
    3c3a:	ef 91       	pop	r30
    3c3c:	bf 91       	pop	r27
    3c3e:	af 91       	pop	r26
    3c40:	9f 91       	pop	r25
    3c42:	8f 91       	pop	r24
    3c44:	7f 91       	pop	r23
    3c46:	6f 91       	pop	r22
    3c48:	5f 91       	pop	r21
    3c4a:	4f 91       	pop	r20
    3c4c:	3f 91       	pop	r19
    3c4e:	2f 91       	pop	r18
    3c50:	0f 90       	pop	r0
    3c52:	0f be       	out	0x3f, r0	; 63
    3c54:	0f 90       	pop	r0
    3c56:	1f 90       	pop	r1
    3c58:	18 95       	reti

00003c5a <__vector_15>:
ISR(TIMER2_OVF_vect) 
{
    3c5a:	1f 92       	push	r1
    3c5c:	0f 92       	push	r0
    3c5e:	0f b6       	in	r0, 0x3f	; 63
    3c60:	0f 92       	push	r0
    3c62:	11 24       	eor	r1, r1
    3c64:	2f 93       	push	r18
    3c66:	3f 93       	push	r19
    3c68:	4f 93       	push	r20
    3c6a:	5f 93       	push	r21
    3c6c:	6f 93       	push	r22
    3c6e:	7f 93       	push	r23
    3c70:	8f 93       	push	r24
    3c72:	9f 93       	push	r25
    3c74:	af 93       	push	r26
    3c76:	bf 93       	push	r27
    3c78:	ef 93       	push	r30
    3c7a:	ff 93       	push	r31
  timer2_ovrflow_cnt++;
    3c7c:	80 91 68 12 	lds	r24, 0x1268
    3c80:	90 91 69 12 	lds	r25, 0x1269
    3c84:	a0 91 6a 12 	lds	r26, 0x126A
    3c88:	b0 91 6b 12 	lds	r27, 0x126B
    3c8c:	01 96       	adiw	r24, 0x01	; 1
    3c8e:	a1 1d       	adc	r26, r1
    3c90:	b1 1d       	adc	r27, r1
    3c92:	80 93 68 12 	sts	0x1268, r24
    3c96:	90 93 69 12 	sts	0x1269, r25
    3c9a:	a0 93 6a 12 	sts	0x126A, r26
    3c9e:	b0 93 6b 12 	sts	0x126B, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER2_OVF_interrupt);
    3ca2:	80 91 91 0f 	lds	r24, 0x0F91
    3ca6:	90 91 92 0f 	lds	r25, 0x0F92
    3caa:	89 2b       	or	r24, r25
    3cac:	29 f0       	breq	.+10     	; 0x3cb8 <__vector_15+0x5e>
    3cae:	e0 91 91 0f 	lds	r30, 0x0F91
    3cb2:	f0 91 92 0f 	lds	r31, 0x0F92
    3cb6:	09 95       	icall
}
    3cb8:	ff 91       	pop	r31
    3cba:	ef 91       	pop	r30
    3cbc:	bf 91       	pop	r27
    3cbe:	af 91       	pop	r26
    3cc0:	9f 91       	pop	r25
    3cc2:	8f 91       	pop	r24
    3cc4:	7f 91       	pop	r23
    3cc6:	6f 91       	pop	r22
    3cc8:	5f 91       	pop	r21
    3cca:	4f 91       	pop	r20
    3ccc:	3f 91       	pop	r19
    3cce:	2f 91       	pop	r18
    3cd0:	0f 90       	pop	r0
    3cd2:	0f be       	out	0x3f, r0	; 63
    3cd4:	0f 90       	pop	r0
    3cd6:	1f 90       	pop	r1
    3cd8:	18 95       	reti

00003cda <__vector_35>:
ISR(TIMER3_OVF_vect) 
{
    3cda:	1f 92       	push	r1
    3cdc:	0f 92       	push	r0
    3cde:	0f b6       	in	r0, 0x3f	; 63
    3ce0:	0f 92       	push	r0
    3ce2:	11 24       	eor	r1, r1
    3ce4:	2f 93       	push	r18
    3ce6:	3f 93       	push	r19
    3ce8:	4f 93       	push	r20
    3cea:	5f 93       	push	r21
    3cec:	6f 93       	push	r22
    3cee:	7f 93       	push	r23
    3cf0:	8f 93       	push	r24
    3cf2:	9f 93       	push	r25
    3cf4:	af 93       	push	r26
    3cf6:	bf 93       	push	r27
    3cf8:	ef 93       	push	r30
    3cfa:	ff 93       	push	r31
  timer3_ovrflow_cnt++;
    3cfc:	80 91 70 12 	lds	r24, 0x1270
    3d00:	90 91 71 12 	lds	r25, 0x1271
    3d04:	a0 91 72 12 	lds	r26, 0x1272
    3d08:	b0 91 73 12 	lds	r27, 0x1273
    3d0c:	01 96       	adiw	r24, 0x01	; 1
    3d0e:	a1 1d       	adc	r26, r1
    3d10:	b1 1d       	adc	r27, r1
    3d12:	80 93 70 12 	sts	0x1270, r24
    3d16:	90 93 71 12 	sts	0x1271, r25
    3d1a:	a0 93 72 12 	sts	0x1272, r26
    3d1e:	b0 93 73 12 	sts	0x1273, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER3_OVF_interrupt);
    3d22:	80 91 9b 0f 	lds	r24, 0x0F9B
    3d26:	90 91 9c 0f 	lds	r25, 0x0F9C
    3d2a:	89 2b       	or	r24, r25
    3d2c:	29 f0       	breq	.+10     	; 0x3d38 <__vector_35+0x5e>
    3d2e:	e0 91 9b 0f 	lds	r30, 0x0F9B
    3d32:	f0 91 9c 0f 	lds	r31, 0x0F9C
    3d36:	09 95       	icall
}
    3d38:	ff 91       	pop	r31
    3d3a:	ef 91       	pop	r30
    3d3c:	bf 91       	pop	r27
    3d3e:	af 91       	pop	r26
    3d40:	9f 91       	pop	r25
    3d42:	8f 91       	pop	r24
    3d44:	7f 91       	pop	r23
    3d46:	6f 91       	pop	r22
    3d48:	5f 91       	pop	r21
    3d4a:	4f 91       	pop	r20
    3d4c:	3f 91       	pop	r19
    3d4e:	2f 91       	pop	r18
    3d50:	0f 90       	pop	r0
    3d52:	0f be       	out	0x3f, r0	; 63
    3d54:	0f 90       	pop	r0
    3d56:	1f 90       	pop	r1
    3d58:	18 95       	reti

00003d5a <__vector_45>:
ISR(TIMER4_OVF_vect) 
{
    3d5a:	1f 92       	push	r1
    3d5c:	0f 92       	push	r0
    3d5e:	0f b6       	in	r0, 0x3f	; 63
    3d60:	0f 92       	push	r0
    3d62:	11 24       	eor	r1, r1
    3d64:	2f 93       	push	r18
    3d66:	3f 93       	push	r19
    3d68:	4f 93       	push	r20
    3d6a:	5f 93       	push	r21
    3d6c:	6f 93       	push	r22
    3d6e:	7f 93       	push	r23
    3d70:	8f 93       	push	r24
    3d72:	9f 93       	push	r25
    3d74:	af 93       	push	r26
    3d76:	bf 93       	push	r27
    3d78:	ef 93       	push	r30
    3d7a:	ff 93       	push	r31
  timer4_ovrflow_cnt++;
    3d7c:	80 91 5c 12 	lds	r24, 0x125C
    3d80:	90 91 5d 12 	lds	r25, 0x125D
    3d84:	a0 91 5e 12 	lds	r26, 0x125E
    3d88:	b0 91 5f 12 	lds	r27, 0x125F
    3d8c:	01 96       	adiw	r24, 0x01	; 1
    3d8e:	a1 1d       	adc	r26, r1
    3d90:	b1 1d       	adc	r27, r1
    3d92:	80 93 5c 12 	sts	0x125C, r24
    3d96:	90 93 5d 12 	sts	0x125D, r25
    3d9a:	a0 93 5e 12 	sts	0x125E, r26
    3d9e:	b0 93 5f 12 	sts	0x125F, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER4_OVF_interrupt);
    3da2:	80 91 a5 0f 	lds	r24, 0x0FA5
    3da6:	90 91 a6 0f 	lds	r25, 0x0FA6
    3daa:	89 2b       	or	r24, r25
    3dac:	29 f0       	breq	.+10     	; 0x3db8 <__vector_45+0x5e>
    3dae:	e0 91 a5 0f 	lds	r30, 0x0FA5
    3db2:	f0 91 a6 0f 	lds	r31, 0x0FA6
    3db6:	09 95       	icall
}
    3db8:	ff 91       	pop	r31
    3dba:	ef 91       	pop	r30
    3dbc:	bf 91       	pop	r27
    3dbe:	af 91       	pop	r26
    3dc0:	9f 91       	pop	r25
    3dc2:	8f 91       	pop	r24
    3dc4:	7f 91       	pop	r23
    3dc6:	6f 91       	pop	r22
    3dc8:	5f 91       	pop	r21
    3dca:	4f 91       	pop	r20
    3dcc:	3f 91       	pop	r19
    3dce:	2f 91       	pop	r18
    3dd0:	0f 90       	pop	r0
    3dd2:	0f be       	out	0x3f, r0	; 63
    3dd4:	0f 90       	pop	r0
    3dd6:	1f 90       	pop	r1
    3dd8:	18 95       	reti

00003dda <__vector_50>:
ISR(TIMER5_OVF_vect) 
{
    3dda:	1f 92       	push	r1
    3ddc:	0f 92       	push	r0
    3dde:	0f b6       	in	r0, 0x3f	; 63
    3de0:	0f 92       	push	r0
    3de2:	11 24       	eor	r1, r1
    3de4:	2f 93       	push	r18
    3de6:	3f 93       	push	r19
    3de8:	4f 93       	push	r20
    3dea:	5f 93       	push	r21
    3dec:	6f 93       	push	r22
    3dee:	7f 93       	push	r23
    3df0:	8f 93       	push	r24
    3df2:	9f 93       	push	r25
    3df4:	af 93       	push	r26
    3df6:	bf 93       	push	r27
    3df8:	ef 93       	push	r30
    3dfa:	ff 93       	push	r31
  timer5_ovrflow_cnt++;
    3dfc:	80 91 74 12 	lds	r24, 0x1274
    3e00:	90 91 75 12 	lds	r25, 0x1275
    3e04:	a0 91 76 12 	lds	r26, 0x1276
    3e08:	b0 91 77 12 	lds	r27, 0x1277
    3e0c:	01 96       	adiw	r24, 0x01	; 1
    3e0e:	a1 1d       	adc	r26, r1
    3e10:	b1 1d       	adc	r27, r1
    3e12:	80 93 74 12 	sts	0x1274, r24
    3e16:	90 93 75 12 	sts	0x1275, r25
    3e1a:	a0 93 76 12 	sts	0x1276, r26
    3e1e:	b0 93 77 12 	sts	0x1277, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER5_OVF_interrupt);
    3e22:	80 91 af 0f 	lds	r24, 0x0FAF
    3e26:	90 91 b0 0f 	lds	r25, 0x0FB0
    3e2a:	89 2b       	or	r24, r25
    3e2c:	29 f0       	breq	.+10     	; 0x3e38 <__vector_50+0x5e>
    3e2e:	e0 91 af 0f 	lds	r30, 0x0FAF
    3e32:	f0 91 b0 0f 	lds	r31, 0x0FB0
    3e36:	09 95       	icall
}
    3e38:	ff 91       	pop	r31
    3e3a:	ef 91       	pop	r30
    3e3c:	bf 91       	pop	r27
    3e3e:	af 91       	pop	r26
    3e40:	9f 91       	pop	r25
    3e42:	8f 91       	pop	r24
    3e44:	7f 91       	pop	r23
    3e46:	6f 91       	pop	r22
    3e48:	5f 91       	pop	r21
    3e4a:	4f 91       	pop	r20
    3e4c:	3f 91       	pop	r19
    3e4e:	2f 91       	pop	r18
    3e50:	0f 90       	pop	r0
    3e52:	0f be       	out	0x3f, r0	; 63
    3e54:	0f 90       	pop	r0
    3e56:	1f 90       	pop	r1
    3e58:	18 95       	reti

00003e5a <__vector_21>:
ISR(TIMER0_COMPA_vect)
{
    3e5a:	1f 92       	push	r1
    3e5c:	0f 92       	push	r0
    3e5e:	0f b6       	in	r0, 0x3f	; 63
    3e60:	0f 92       	push	r0
    3e62:	11 24       	eor	r1, r1
    3e64:	2f 93       	push	r18
    3e66:	3f 93       	push	r19
    3e68:	4f 93       	push	r20
    3e6a:	5f 93       	push	r21
    3e6c:	6f 93       	push	r22
    3e6e:	7f 93       	push	r23
    3e70:	8f 93       	push	r24
    3e72:	9f 93       	push	r25
    3e74:	af 93       	push	r26
    3e76:	bf 93       	push	r27
    3e78:	ef 93       	push	r30
    3e7a:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER0_COMPA_interrupt);
    3e7c:	80 91 7d 0f 	lds	r24, 0x0F7D
    3e80:	90 91 7e 0f 	lds	r25, 0x0F7E
    3e84:	89 2b       	or	r24, r25
    3e86:	29 f0       	breq	.+10     	; 0x3e92 <__vector_21+0x38>
    3e88:	e0 91 7d 0f 	lds	r30, 0x0F7D
    3e8c:	f0 91 7e 0f 	lds	r31, 0x0F7E
    3e90:	09 95       	icall
}
    3e92:	ff 91       	pop	r31
    3e94:	ef 91       	pop	r30
    3e96:	bf 91       	pop	r27
    3e98:	af 91       	pop	r26
    3e9a:	9f 91       	pop	r25
    3e9c:	8f 91       	pop	r24
    3e9e:	7f 91       	pop	r23
    3ea0:	6f 91       	pop	r22
    3ea2:	5f 91       	pop	r21
    3ea4:	4f 91       	pop	r20
    3ea6:	3f 91       	pop	r19
    3ea8:	2f 91       	pop	r18
    3eaa:	0f 90       	pop	r0
    3eac:	0f be       	out	0x3f, r0	; 63
    3eae:	0f 90       	pop	r0
    3eb0:	1f 90       	pop	r1
    3eb2:	18 95       	reti

00003eb4 <__vector_22>:
ISR(TIMER0_COMPB_vect)
{
    3eb4:	1f 92       	push	r1
    3eb6:	0f 92       	push	r0
    3eb8:	0f b6       	in	r0, 0x3f	; 63
    3eba:	0f 92       	push	r0
    3ebc:	11 24       	eor	r1, r1
    3ebe:	2f 93       	push	r18
    3ec0:	3f 93       	push	r19
    3ec2:	4f 93       	push	r20
    3ec4:	5f 93       	push	r21
    3ec6:	6f 93       	push	r22
    3ec8:	7f 93       	push	r23
    3eca:	8f 93       	push	r24
    3ecc:	9f 93       	push	r25
    3ece:	af 93       	push	r26
    3ed0:	bf 93       	push	r27
    3ed2:	ef 93       	push	r30
    3ed4:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER0_COMPB_interrupt);
    3ed6:	80 91 7f 0f 	lds	r24, 0x0F7F
    3eda:	90 91 80 0f 	lds	r25, 0x0F80
    3ede:	89 2b       	or	r24, r25
    3ee0:	29 f0       	breq	.+10     	; 0x3eec <__vector_22+0x38>
    3ee2:	e0 91 7f 0f 	lds	r30, 0x0F7F
    3ee6:	f0 91 80 0f 	lds	r31, 0x0F80
    3eea:	09 95       	icall
}
    3eec:	ff 91       	pop	r31
    3eee:	ef 91       	pop	r30
    3ef0:	bf 91       	pop	r27
    3ef2:	af 91       	pop	r26
    3ef4:	9f 91       	pop	r25
    3ef6:	8f 91       	pop	r24
    3ef8:	7f 91       	pop	r23
    3efa:	6f 91       	pop	r22
    3efc:	5f 91       	pop	r21
    3efe:	4f 91       	pop	r20
    3f00:	3f 91       	pop	r19
    3f02:	2f 91       	pop	r18
    3f04:	0f 90       	pop	r0
    3f06:	0f be       	out	0x3f, r0	; 63
    3f08:	0f 90       	pop	r0
    3f0a:	1f 90       	pop	r1
    3f0c:	18 95       	reti

00003f0e <__vector_16>:
ISR(TIMER1_CAPT_vect)
{
    3f0e:	1f 92       	push	r1
    3f10:	0f 92       	push	r0
    3f12:	0f b6       	in	r0, 0x3f	; 63
    3f14:	0f 92       	push	r0
    3f16:	11 24       	eor	r1, r1
    3f18:	2f 93       	push	r18
    3f1a:	3f 93       	push	r19
    3f1c:	4f 93       	push	r20
    3f1e:	5f 93       	push	r21
    3f20:	6f 93       	push	r22
    3f22:	7f 93       	push	r23
    3f24:	8f 93       	push	r24
    3f26:	9f 93       	push	r25
    3f28:	af 93       	push	r26
    3f2a:	bf 93       	push	r27
    3f2c:	ef 93       	push	r30
    3f2e:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER1_CAPT_interrupt);
    3f30:	80 91 83 0f 	lds	r24, 0x0F83
    3f34:	90 91 84 0f 	lds	r25, 0x0F84
    3f38:	89 2b       	or	r24, r25
    3f3a:	29 f0       	breq	.+10     	; 0x3f46 <__vector_16+0x38>
    3f3c:	e0 91 83 0f 	lds	r30, 0x0F83
    3f40:	f0 91 84 0f 	lds	r31, 0x0F84
    3f44:	09 95       	icall
}
    3f46:	ff 91       	pop	r31
    3f48:	ef 91       	pop	r30
    3f4a:	bf 91       	pop	r27
    3f4c:	af 91       	pop	r26
    3f4e:	9f 91       	pop	r25
    3f50:	8f 91       	pop	r24
    3f52:	7f 91       	pop	r23
    3f54:	6f 91       	pop	r22
    3f56:	5f 91       	pop	r21
    3f58:	4f 91       	pop	r20
    3f5a:	3f 91       	pop	r19
    3f5c:	2f 91       	pop	r18
    3f5e:	0f 90       	pop	r0
    3f60:	0f be       	out	0x3f, r0	; 63
    3f62:	0f 90       	pop	r0
    3f64:	1f 90       	pop	r1
    3f66:	18 95       	reti

00003f68 <__vector_18>:
{
  RUN_USER_DEFINE_INTERRUPT(TIMER1_COMPA_interrupt);
}
*/
ISR(TIMER1_COMPB_vect)
{
    3f68:	1f 92       	push	r1
    3f6a:	0f 92       	push	r0
    3f6c:	0f b6       	in	r0, 0x3f	; 63
    3f6e:	0f 92       	push	r0
    3f70:	11 24       	eor	r1, r1
    3f72:	2f 93       	push	r18
    3f74:	3f 93       	push	r19
    3f76:	4f 93       	push	r20
    3f78:	5f 93       	push	r21
    3f7a:	6f 93       	push	r22
    3f7c:	7f 93       	push	r23
    3f7e:	8f 93       	push	r24
    3f80:	9f 93       	push	r25
    3f82:	af 93       	push	r26
    3f84:	bf 93       	push	r27
    3f86:	ef 93       	push	r30
    3f88:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER1_COMPB_interrupt);
    3f8a:	80 91 87 0f 	lds	r24, 0x0F87
    3f8e:	90 91 88 0f 	lds	r25, 0x0F88
    3f92:	89 2b       	or	r24, r25
    3f94:	29 f0       	breq	.+10     	; 0x3fa0 <__vector_18+0x38>
    3f96:	e0 91 87 0f 	lds	r30, 0x0F87
    3f9a:	f0 91 88 0f 	lds	r31, 0x0F88
    3f9e:	09 95       	icall
}
    3fa0:	ff 91       	pop	r31
    3fa2:	ef 91       	pop	r30
    3fa4:	bf 91       	pop	r27
    3fa6:	af 91       	pop	r26
    3fa8:	9f 91       	pop	r25
    3faa:	8f 91       	pop	r24
    3fac:	7f 91       	pop	r23
    3fae:	6f 91       	pop	r22
    3fb0:	5f 91       	pop	r21
    3fb2:	4f 91       	pop	r20
    3fb4:	3f 91       	pop	r19
    3fb6:	2f 91       	pop	r18
    3fb8:	0f 90       	pop	r0
    3fba:	0f be       	out	0x3f, r0	; 63
    3fbc:	0f 90       	pop	r0
    3fbe:	1f 90       	pop	r1
    3fc0:	18 95       	reti

00003fc2 <__vector_19>:
ISR(TIMER1_COMPC_vect)
{
    3fc2:	1f 92       	push	r1
    3fc4:	0f 92       	push	r0
    3fc6:	0f b6       	in	r0, 0x3f	; 63
    3fc8:	0f 92       	push	r0
    3fca:	11 24       	eor	r1, r1
    3fcc:	2f 93       	push	r18
    3fce:	3f 93       	push	r19
    3fd0:	4f 93       	push	r20
    3fd2:	5f 93       	push	r21
    3fd4:	6f 93       	push	r22
    3fd6:	7f 93       	push	r23
    3fd8:	8f 93       	push	r24
    3fda:	9f 93       	push	r25
    3fdc:	af 93       	push	r26
    3fde:	bf 93       	push	r27
    3fe0:	ef 93       	push	r30
    3fe2:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER1_COMPC_interrupt);
    3fe4:	80 91 89 0f 	lds	r24, 0x0F89
    3fe8:	90 91 8a 0f 	lds	r25, 0x0F8A
    3fec:	89 2b       	or	r24, r25
    3fee:	29 f0       	breq	.+10     	; 0x3ffa <__vector_19+0x38>
    3ff0:	e0 91 89 0f 	lds	r30, 0x0F89
    3ff4:	f0 91 8a 0f 	lds	r31, 0x0F8A
    3ff8:	09 95       	icall
}
    3ffa:	ff 91       	pop	r31
    3ffc:	ef 91       	pop	r30
    3ffe:	bf 91       	pop	r27
    4000:	af 91       	pop	r26
    4002:	9f 91       	pop	r25
    4004:	8f 91       	pop	r24
    4006:	7f 91       	pop	r23
    4008:	6f 91       	pop	r22
    400a:	5f 91       	pop	r21
    400c:	4f 91       	pop	r20
    400e:	3f 91       	pop	r19
    4010:	2f 91       	pop	r18
    4012:	0f 90       	pop	r0
    4014:	0f be       	out	0x3f, r0	; 63
    4016:	0f 90       	pop	r0
    4018:	1f 90       	pop	r1
    401a:	18 95       	reti

0000401c <__vector_13>:
ISR(TIMER2_COMPA_vect)
{
    401c:	1f 92       	push	r1
    401e:	0f 92       	push	r0
    4020:	0f b6       	in	r0, 0x3f	; 63
    4022:	0f 92       	push	r0
    4024:	11 24       	eor	r1, r1
    4026:	2f 93       	push	r18
    4028:	3f 93       	push	r19
    402a:	4f 93       	push	r20
    402c:	5f 93       	push	r21
    402e:	6f 93       	push	r22
    4030:	7f 93       	push	r23
    4032:	8f 93       	push	r24
    4034:	9f 93       	push	r25
    4036:	af 93       	push	r26
    4038:	bf 93       	push	r27
    403a:	ef 93       	push	r30
    403c:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER2_COMPA_interrupt);
    403e:	80 91 8d 0f 	lds	r24, 0x0F8D
    4042:	90 91 8e 0f 	lds	r25, 0x0F8E
    4046:	89 2b       	or	r24, r25
    4048:	29 f0       	breq	.+10     	; 0x4054 <__vector_13+0x38>
    404a:	e0 91 8d 0f 	lds	r30, 0x0F8D
    404e:	f0 91 8e 0f 	lds	r31, 0x0F8E
    4052:	09 95       	icall
}
    4054:	ff 91       	pop	r31
    4056:	ef 91       	pop	r30
    4058:	bf 91       	pop	r27
    405a:	af 91       	pop	r26
    405c:	9f 91       	pop	r25
    405e:	8f 91       	pop	r24
    4060:	7f 91       	pop	r23
    4062:	6f 91       	pop	r22
    4064:	5f 91       	pop	r21
    4066:	4f 91       	pop	r20
    4068:	3f 91       	pop	r19
    406a:	2f 91       	pop	r18
    406c:	0f 90       	pop	r0
    406e:	0f be       	out	0x3f, r0	; 63
    4070:	0f 90       	pop	r0
    4072:	1f 90       	pop	r1
    4074:	18 95       	reti

00004076 <__vector_14>:
ISR(TIMER2_COMPB_vect)
{
    4076:	1f 92       	push	r1
    4078:	0f 92       	push	r0
    407a:	0f b6       	in	r0, 0x3f	; 63
    407c:	0f 92       	push	r0
    407e:	11 24       	eor	r1, r1
    4080:	2f 93       	push	r18
    4082:	3f 93       	push	r19
    4084:	4f 93       	push	r20
    4086:	5f 93       	push	r21
    4088:	6f 93       	push	r22
    408a:	7f 93       	push	r23
    408c:	8f 93       	push	r24
    408e:	9f 93       	push	r25
    4090:	af 93       	push	r26
    4092:	bf 93       	push	r27
    4094:	ef 93       	push	r30
    4096:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER2_COMPB_interrupt);
    4098:	80 91 8f 0f 	lds	r24, 0x0F8F
    409c:	90 91 90 0f 	lds	r25, 0x0F90
    40a0:	89 2b       	or	r24, r25
    40a2:	29 f0       	breq	.+10     	; 0x40ae <__vector_14+0x38>
    40a4:	e0 91 8f 0f 	lds	r30, 0x0F8F
    40a8:	f0 91 90 0f 	lds	r31, 0x0F90
    40ac:	09 95       	icall
}
    40ae:	ff 91       	pop	r31
    40b0:	ef 91       	pop	r30
    40b2:	bf 91       	pop	r27
    40b4:	af 91       	pop	r26
    40b6:	9f 91       	pop	r25
    40b8:	8f 91       	pop	r24
    40ba:	7f 91       	pop	r23
    40bc:	6f 91       	pop	r22
    40be:	5f 91       	pop	r21
    40c0:	4f 91       	pop	r20
    40c2:	3f 91       	pop	r19
    40c4:	2f 91       	pop	r18
    40c6:	0f 90       	pop	r0
    40c8:	0f be       	out	0x3f, r0	; 63
    40ca:	0f 90       	pop	r0
    40cc:	1f 90       	pop	r1
    40ce:	18 95       	reti

000040d0 <__vector_31>:
ISR(TIMER3_CAPT_vect)
{
    40d0:	1f 92       	push	r1
    40d2:	0f 92       	push	r0
    40d4:	0f b6       	in	r0, 0x3f	; 63
    40d6:	0f 92       	push	r0
    40d8:	11 24       	eor	r1, r1
    40da:	2f 93       	push	r18
    40dc:	3f 93       	push	r19
    40de:	4f 93       	push	r20
    40e0:	5f 93       	push	r21
    40e2:	6f 93       	push	r22
    40e4:	7f 93       	push	r23
    40e6:	8f 93       	push	r24
    40e8:	9f 93       	push	r25
    40ea:	af 93       	push	r26
    40ec:	bf 93       	push	r27
    40ee:	ef 93       	push	r30
    40f0:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_CAPT_interrupt);
    40f2:	80 91 93 0f 	lds	r24, 0x0F93
    40f6:	90 91 94 0f 	lds	r25, 0x0F94
    40fa:	89 2b       	or	r24, r25
    40fc:	29 f0       	breq	.+10     	; 0x4108 <__vector_31+0x38>
    40fe:	e0 91 93 0f 	lds	r30, 0x0F93
    4102:	f0 91 94 0f 	lds	r31, 0x0F94
    4106:	09 95       	icall
}
    4108:	ff 91       	pop	r31
    410a:	ef 91       	pop	r30
    410c:	bf 91       	pop	r27
    410e:	af 91       	pop	r26
    4110:	9f 91       	pop	r25
    4112:	8f 91       	pop	r24
    4114:	7f 91       	pop	r23
    4116:	6f 91       	pop	r22
    4118:	5f 91       	pop	r21
    411a:	4f 91       	pop	r20
    411c:	3f 91       	pop	r19
    411e:	2f 91       	pop	r18
    4120:	0f 90       	pop	r0
    4122:	0f be       	out	0x3f, r0	; 63
    4124:	0f 90       	pop	r0
    4126:	1f 90       	pop	r1
    4128:	18 95       	reti

0000412a <__vector_32>:
ISR(TIMER3_COMPA_vect)
{
    412a:	1f 92       	push	r1
    412c:	0f 92       	push	r0
    412e:	0f b6       	in	r0, 0x3f	; 63
    4130:	0f 92       	push	r0
    4132:	11 24       	eor	r1, r1
    4134:	2f 93       	push	r18
    4136:	3f 93       	push	r19
    4138:	4f 93       	push	r20
    413a:	5f 93       	push	r21
    413c:	6f 93       	push	r22
    413e:	7f 93       	push	r23
    4140:	8f 93       	push	r24
    4142:	9f 93       	push	r25
    4144:	af 93       	push	r26
    4146:	bf 93       	push	r27
    4148:	ef 93       	push	r30
    414a:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_COMPA_interrupt);
    414c:	80 91 95 0f 	lds	r24, 0x0F95
    4150:	90 91 96 0f 	lds	r25, 0x0F96
    4154:	89 2b       	or	r24, r25
    4156:	29 f0       	breq	.+10     	; 0x4162 <__vector_32+0x38>
    4158:	e0 91 95 0f 	lds	r30, 0x0F95
    415c:	f0 91 96 0f 	lds	r31, 0x0F96
    4160:	09 95       	icall
}
    4162:	ff 91       	pop	r31
    4164:	ef 91       	pop	r30
    4166:	bf 91       	pop	r27
    4168:	af 91       	pop	r26
    416a:	9f 91       	pop	r25
    416c:	8f 91       	pop	r24
    416e:	7f 91       	pop	r23
    4170:	6f 91       	pop	r22
    4172:	5f 91       	pop	r21
    4174:	4f 91       	pop	r20
    4176:	3f 91       	pop	r19
    4178:	2f 91       	pop	r18
    417a:	0f 90       	pop	r0
    417c:	0f be       	out	0x3f, r0	; 63
    417e:	0f 90       	pop	r0
    4180:	1f 90       	pop	r1
    4182:	18 95       	reti

00004184 <__vector_33>:
ISR(TIMER3_COMPB_vect)
{
    4184:	1f 92       	push	r1
    4186:	0f 92       	push	r0
    4188:	0f b6       	in	r0, 0x3f	; 63
    418a:	0f 92       	push	r0
    418c:	11 24       	eor	r1, r1
    418e:	2f 93       	push	r18
    4190:	3f 93       	push	r19
    4192:	4f 93       	push	r20
    4194:	5f 93       	push	r21
    4196:	6f 93       	push	r22
    4198:	7f 93       	push	r23
    419a:	8f 93       	push	r24
    419c:	9f 93       	push	r25
    419e:	af 93       	push	r26
    41a0:	bf 93       	push	r27
    41a2:	ef 93       	push	r30
    41a4:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_COMPB_interrupt);
    41a6:	80 91 97 0f 	lds	r24, 0x0F97
    41aa:	90 91 98 0f 	lds	r25, 0x0F98
    41ae:	89 2b       	or	r24, r25
    41b0:	29 f0       	breq	.+10     	; 0x41bc <__vector_33+0x38>
    41b2:	e0 91 97 0f 	lds	r30, 0x0F97
    41b6:	f0 91 98 0f 	lds	r31, 0x0F98
    41ba:	09 95       	icall
}
    41bc:	ff 91       	pop	r31
    41be:	ef 91       	pop	r30
    41c0:	bf 91       	pop	r27
    41c2:	af 91       	pop	r26
    41c4:	9f 91       	pop	r25
    41c6:	8f 91       	pop	r24
    41c8:	7f 91       	pop	r23
    41ca:	6f 91       	pop	r22
    41cc:	5f 91       	pop	r21
    41ce:	4f 91       	pop	r20
    41d0:	3f 91       	pop	r19
    41d2:	2f 91       	pop	r18
    41d4:	0f 90       	pop	r0
    41d6:	0f be       	out	0x3f, r0	; 63
    41d8:	0f 90       	pop	r0
    41da:	1f 90       	pop	r1
    41dc:	18 95       	reti

000041de <__vector_34>:
ISR(TIMER3_COMPC_vect)
{
    41de:	1f 92       	push	r1
    41e0:	0f 92       	push	r0
    41e2:	0f b6       	in	r0, 0x3f	; 63
    41e4:	0f 92       	push	r0
    41e6:	11 24       	eor	r1, r1
    41e8:	2f 93       	push	r18
    41ea:	3f 93       	push	r19
    41ec:	4f 93       	push	r20
    41ee:	5f 93       	push	r21
    41f0:	6f 93       	push	r22
    41f2:	7f 93       	push	r23
    41f4:	8f 93       	push	r24
    41f6:	9f 93       	push	r25
    41f8:	af 93       	push	r26
    41fa:	bf 93       	push	r27
    41fc:	ef 93       	push	r30
    41fe:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_COMPC_interrupt);
    4200:	80 91 99 0f 	lds	r24, 0x0F99
    4204:	90 91 9a 0f 	lds	r25, 0x0F9A
    4208:	89 2b       	or	r24, r25
    420a:	29 f0       	breq	.+10     	; 0x4216 <__vector_34+0x38>
    420c:	e0 91 99 0f 	lds	r30, 0x0F99
    4210:	f0 91 9a 0f 	lds	r31, 0x0F9A
    4214:	09 95       	icall
}
    4216:	ff 91       	pop	r31
    4218:	ef 91       	pop	r30
    421a:	bf 91       	pop	r27
    421c:	af 91       	pop	r26
    421e:	9f 91       	pop	r25
    4220:	8f 91       	pop	r24
    4222:	7f 91       	pop	r23
    4224:	6f 91       	pop	r22
    4226:	5f 91       	pop	r21
    4228:	4f 91       	pop	r20
    422a:	3f 91       	pop	r19
    422c:	2f 91       	pop	r18
    422e:	0f 90       	pop	r0
    4230:	0f be       	out	0x3f, r0	; 63
    4232:	0f 90       	pop	r0
    4234:	1f 90       	pop	r1
    4236:	18 95       	reti

00004238 <__vector_41>:
ISR(TIMER4_CAPT_vect)
{
    4238:	1f 92       	push	r1
    423a:	0f 92       	push	r0
    423c:	0f b6       	in	r0, 0x3f	; 63
    423e:	0f 92       	push	r0
    4240:	11 24       	eor	r1, r1
    4242:	2f 93       	push	r18
    4244:	3f 93       	push	r19
    4246:	4f 93       	push	r20
    4248:	5f 93       	push	r21
    424a:	6f 93       	push	r22
    424c:	7f 93       	push	r23
    424e:	8f 93       	push	r24
    4250:	9f 93       	push	r25
    4252:	af 93       	push	r26
    4254:	bf 93       	push	r27
    4256:	ef 93       	push	r30
    4258:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_CAPT_interrupt);
    425a:	80 91 9d 0f 	lds	r24, 0x0F9D
    425e:	90 91 9e 0f 	lds	r25, 0x0F9E
    4262:	89 2b       	or	r24, r25
    4264:	29 f0       	breq	.+10     	; 0x4270 <__vector_41+0x38>
    4266:	e0 91 9d 0f 	lds	r30, 0x0F9D
    426a:	f0 91 9e 0f 	lds	r31, 0x0F9E
    426e:	09 95       	icall
}
    4270:	ff 91       	pop	r31
    4272:	ef 91       	pop	r30
    4274:	bf 91       	pop	r27
    4276:	af 91       	pop	r26
    4278:	9f 91       	pop	r25
    427a:	8f 91       	pop	r24
    427c:	7f 91       	pop	r23
    427e:	6f 91       	pop	r22
    4280:	5f 91       	pop	r21
    4282:	4f 91       	pop	r20
    4284:	3f 91       	pop	r19
    4286:	2f 91       	pop	r18
    4288:	0f 90       	pop	r0
    428a:	0f be       	out	0x3f, r0	; 63
    428c:	0f 90       	pop	r0
    428e:	1f 90       	pop	r1
    4290:	18 95       	reti

00004292 <__vector_42>:
ISR(TIMER4_COMPA_vect)
{
    4292:	1f 92       	push	r1
    4294:	0f 92       	push	r0
    4296:	0f b6       	in	r0, 0x3f	; 63
    4298:	0f 92       	push	r0
    429a:	11 24       	eor	r1, r1
    429c:	2f 93       	push	r18
    429e:	3f 93       	push	r19
    42a0:	4f 93       	push	r20
    42a2:	5f 93       	push	r21
    42a4:	6f 93       	push	r22
    42a6:	7f 93       	push	r23
    42a8:	8f 93       	push	r24
    42aa:	9f 93       	push	r25
    42ac:	af 93       	push	r26
    42ae:	bf 93       	push	r27
    42b0:	ef 93       	push	r30
    42b2:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_COMPA_interrupt);
    42b4:	80 91 9f 0f 	lds	r24, 0x0F9F
    42b8:	90 91 a0 0f 	lds	r25, 0x0FA0
    42bc:	89 2b       	or	r24, r25
    42be:	29 f0       	breq	.+10     	; 0x42ca <__vector_42+0x38>
    42c0:	e0 91 9f 0f 	lds	r30, 0x0F9F
    42c4:	f0 91 a0 0f 	lds	r31, 0x0FA0
    42c8:	09 95       	icall
}
    42ca:	ff 91       	pop	r31
    42cc:	ef 91       	pop	r30
    42ce:	bf 91       	pop	r27
    42d0:	af 91       	pop	r26
    42d2:	9f 91       	pop	r25
    42d4:	8f 91       	pop	r24
    42d6:	7f 91       	pop	r23
    42d8:	6f 91       	pop	r22
    42da:	5f 91       	pop	r21
    42dc:	4f 91       	pop	r20
    42de:	3f 91       	pop	r19
    42e0:	2f 91       	pop	r18
    42e2:	0f 90       	pop	r0
    42e4:	0f be       	out	0x3f, r0	; 63
    42e6:	0f 90       	pop	r0
    42e8:	1f 90       	pop	r1
    42ea:	18 95       	reti

000042ec <__vector_43>:
ISR(TIMER4_COMPB_vect)
{
    42ec:	1f 92       	push	r1
    42ee:	0f 92       	push	r0
    42f0:	0f b6       	in	r0, 0x3f	; 63
    42f2:	0f 92       	push	r0
    42f4:	11 24       	eor	r1, r1
    42f6:	2f 93       	push	r18
    42f8:	3f 93       	push	r19
    42fa:	4f 93       	push	r20
    42fc:	5f 93       	push	r21
    42fe:	6f 93       	push	r22
    4300:	7f 93       	push	r23
    4302:	8f 93       	push	r24
    4304:	9f 93       	push	r25
    4306:	af 93       	push	r26
    4308:	bf 93       	push	r27
    430a:	ef 93       	push	r30
    430c:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_COMPB_interrupt);
    430e:	80 91 a1 0f 	lds	r24, 0x0FA1
    4312:	90 91 a2 0f 	lds	r25, 0x0FA2
    4316:	89 2b       	or	r24, r25
    4318:	29 f0       	breq	.+10     	; 0x4324 <__vector_43+0x38>
    431a:	e0 91 a1 0f 	lds	r30, 0x0FA1
    431e:	f0 91 a2 0f 	lds	r31, 0x0FA2
    4322:	09 95       	icall
}
    4324:	ff 91       	pop	r31
    4326:	ef 91       	pop	r30
    4328:	bf 91       	pop	r27
    432a:	af 91       	pop	r26
    432c:	9f 91       	pop	r25
    432e:	8f 91       	pop	r24
    4330:	7f 91       	pop	r23
    4332:	6f 91       	pop	r22
    4334:	5f 91       	pop	r21
    4336:	4f 91       	pop	r20
    4338:	3f 91       	pop	r19
    433a:	2f 91       	pop	r18
    433c:	0f 90       	pop	r0
    433e:	0f be       	out	0x3f, r0	; 63
    4340:	0f 90       	pop	r0
    4342:	1f 90       	pop	r1
    4344:	18 95       	reti

00004346 <__vector_44>:
ISR(TIMER4_COMPC_vect)
{
    4346:	1f 92       	push	r1
    4348:	0f 92       	push	r0
    434a:	0f b6       	in	r0, 0x3f	; 63
    434c:	0f 92       	push	r0
    434e:	11 24       	eor	r1, r1
    4350:	2f 93       	push	r18
    4352:	3f 93       	push	r19
    4354:	4f 93       	push	r20
    4356:	5f 93       	push	r21
    4358:	6f 93       	push	r22
    435a:	7f 93       	push	r23
    435c:	8f 93       	push	r24
    435e:	9f 93       	push	r25
    4360:	af 93       	push	r26
    4362:	bf 93       	push	r27
    4364:	ef 93       	push	r30
    4366:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_COMPC_interrupt);
    4368:	80 91 a3 0f 	lds	r24, 0x0FA3
    436c:	90 91 a4 0f 	lds	r25, 0x0FA4
    4370:	89 2b       	or	r24, r25
    4372:	29 f0       	breq	.+10     	; 0x437e <__vector_44+0x38>
    4374:	e0 91 a3 0f 	lds	r30, 0x0FA3
    4378:	f0 91 a4 0f 	lds	r31, 0x0FA4
    437c:	09 95       	icall
}
    437e:	ff 91       	pop	r31
    4380:	ef 91       	pop	r30
    4382:	bf 91       	pop	r27
    4384:	af 91       	pop	r26
    4386:	9f 91       	pop	r25
    4388:	8f 91       	pop	r24
    438a:	7f 91       	pop	r23
    438c:	6f 91       	pop	r22
    438e:	5f 91       	pop	r21
    4390:	4f 91       	pop	r20
    4392:	3f 91       	pop	r19
    4394:	2f 91       	pop	r18
    4396:	0f 90       	pop	r0
    4398:	0f be       	out	0x3f, r0	; 63
    439a:	0f 90       	pop	r0
    439c:	1f 90       	pop	r1
    439e:	18 95       	reti

000043a0 <__vector_46>:
ISR(TIMER5_CAPT_vect)
{
    43a0:	1f 92       	push	r1
    43a2:	0f 92       	push	r0
    43a4:	0f b6       	in	r0, 0x3f	; 63
    43a6:	0f 92       	push	r0
    43a8:	11 24       	eor	r1, r1
    43aa:	2f 93       	push	r18
    43ac:	3f 93       	push	r19
    43ae:	4f 93       	push	r20
    43b0:	5f 93       	push	r21
    43b2:	6f 93       	push	r22
    43b4:	7f 93       	push	r23
    43b6:	8f 93       	push	r24
    43b8:	9f 93       	push	r25
    43ba:	af 93       	push	r26
    43bc:	bf 93       	push	r27
    43be:	ef 93       	push	r30
    43c0:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_CAPT_interrupt);
    43c2:	80 91 a7 0f 	lds	r24, 0x0FA7
    43c6:	90 91 a8 0f 	lds	r25, 0x0FA8
    43ca:	89 2b       	or	r24, r25
    43cc:	29 f0       	breq	.+10     	; 0x43d8 <__vector_46+0x38>
    43ce:	e0 91 a7 0f 	lds	r30, 0x0FA7
    43d2:	f0 91 a8 0f 	lds	r31, 0x0FA8
    43d6:	09 95       	icall
}
    43d8:	ff 91       	pop	r31
    43da:	ef 91       	pop	r30
    43dc:	bf 91       	pop	r27
    43de:	af 91       	pop	r26
    43e0:	9f 91       	pop	r25
    43e2:	8f 91       	pop	r24
    43e4:	7f 91       	pop	r23
    43e6:	6f 91       	pop	r22
    43e8:	5f 91       	pop	r21
    43ea:	4f 91       	pop	r20
    43ec:	3f 91       	pop	r19
    43ee:	2f 91       	pop	r18
    43f0:	0f 90       	pop	r0
    43f2:	0f be       	out	0x3f, r0	; 63
    43f4:	0f 90       	pop	r0
    43f6:	1f 90       	pop	r1
    43f8:	18 95       	reti

000043fa <__vector_47>:
ISR(TIMER5_COMPA_vect)
{
    43fa:	1f 92       	push	r1
    43fc:	0f 92       	push	r0
    43fe:	0f b6       	in	r0, 0x3f	; 63
    4400:	0f 92       	push	r0
    4402:	11 24       	eor	r1, r1
    4404:	2f 93       	push	r18
    4406:	3f 93       	push	r19
    4408:	4f 93       	push	r20
    440a:	5f 93       	push	r21
    440c:	6f 93       	push	r22
    440e:	7f 93       	push	r23
    4410:	8f 93       	push	r24
    4412:	9f 93       	push	r25
    4414:	af 93       	push	r26
    4416:	bf 93       	push	r27
    4418:	ef 93       	push	r30
    441a:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_COMPA_interrupt);
    441c:	80 91 a9 0f 	lds	r24, 0x0FA9
    4420:	90 91 aa 0f 	lds	r25, 0x0FAA
    4424:	89 2b       	or	r24, r25
    4426:	29 f0       	breq	.+10     	; 0x4432 <__vector_47+0x38>
    4428:	e0 91 a9 0f 	lds	r30, 0x0FA9
    442c:	f0 91 aa 0f 	lds	r31, 0x0FAA
    4430:	09 95       	icall
}
    4432:	ff 91       	pop	r31
    4434:	ef 91       	pop	r30
    4436:	bf 91       	pop	r27
    4438:	af 91       	pop	r26
    443a:	9f 91       	pop	r25
    443c:	8f 91       	pop	r24
    443e:	7f 91       	pop	r23
    4440:	6f 91       	pop	r22
    4442:	5f 91       	pop	r21
    4444:	4f 91       	pop	r20
    4446:	3f 91       	pop	r19
    4448:	2f 91       	pop	r18
    444a:	0f 90       	pop	r0
    444c:	0f be       	out	0x3f, r0	; 63
    444e:	0f 90       	pop	r0
    4450:	1f 90       	pop	r1
    4452:	18 95       	reti

00004454 <__vector_48>:
ISR(TIMER5_COMPB_vect)
{
    4454:	1f 92       	push	r1
    4456:	0f 92       	push	r0
    4458:	0f b6       	in	r0, 0x3f	; 63
    445a:	0f 92       	push	r0
    445c:	11 24       	eor	r1, r1
    445e:	2f 93       	push	r18
    4460:	3f 93       	push	r19
    4462:	4f 93       	push	r20
    4464:	5f 93       	push	r21
    4466:	6f 93       	push	r22
    4468:	7f 93       	push	r23
    446a:	8f 93       	push	r24
    446c:	9f 93       	push	r25
    446e:	af 93       	push	r26
    4470:	bf 93       	push	r27
    4472:	ef 93       	push	r30
    4474:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_COMPB_interrupt);
    4476:	80 91 ab 0f 	lds	r24, 0x0FAB
    447a:	90 91 ac 0f 	lds	r25, 0x0FAC
    447e:	89 2b       	or	r24, r25
    4480:	29 f0       	breq	.+10     	; 0x448c <__vector_48+0x38>
    4482:	e0 91 ab 0f 	lds	r30, 0x0FAB
    4486:	f0 91 ac 0f 	lds	r31, 0x0FAC
    448a:	09 95       	icall
}
    448c:	ff 91       	pop	r31
    448e:	ef 91       	pop	r30
    4490:	bf 91       	pop	r27
    4492:	af 91       	pop	r26
    4494:	9f 91       	pop	r25
    4496:	8f 91       	pop	r24
    4498:	7f 91       	pop	r23
    449a:	6f 91       	pop	r22
    449c:	5f 91       	pop	r21
    449e:	4f 91       	pop	r20
    44a0:	3f 91       	pop	r19
    44a2:	2f 91       	pop	r18
    44a4:	0f 90       	pop	r0
    44a6:	0f be       	out	0x3f, r0	; 63
    44a8:	0f 90       	pop	r0
    44aa:	1f 90       	pop	r1
    44ac:	18 95       	reti

000044ae <__vector_49>:
ISR(TIMER5_COMPC_vect)
{
    44ae:	1f 92       	push	r1
    44b0:	0f 92       	push	r0
    44b2:	0f b6       	in	r0, 0x3f	; 63
    44b4:	0f 92       	push	r0
    44b6:	11 24       	eor	r1, r1
    44b8:	2f 93       	push	r18
    44ba:	3f 93       	push	r19
    44bc:	4f 93       	push	r20
    44be:	5f 93       	push	r21
    44c0:	6f 93       	push	r22
    44c2:	7f 93       	push	r23
    44c4:	8f 93       	push	r24
    44c6:	9f 93       	push	r25
    44c8:	af 93       	push	r26
    44ca:	bf 93       	push	r27
    44cc:	ef 93       	push	r30
    44ce:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_COMPC_interrupt);
    44d0:	80 91 ad 0f 	lds	r24, 0x0FAD
    44d4:	90 91 ae 0f 	lds	r25, 0x0FAE
    44d8:	89 2b       	or	r24, r25
    44da:	29 f0       	breq	.+10     	; 0x44e6 <__vector_49+0x38>
    44dc:	e0 91 ad 0f 	lds	r30, 0x0FAD
    44e0:	f0 91 ae 0f 	lds	r31, 0x0FAE
    44e4:	09 95       	icall
}
    44e6:	ff 91       	pop	r31
    44e8:	ef 91       	pop	r30
    44ea:	bf 91       	pop	r27
    44ec:	af 91       	pop	r26
    44ee:	9f 91       	pop	r25
    44f0:	8f 91       	pop	r24
    44f2:	7f 91       	pop	r23
    44f4:	6f 91       	pop	r22
    44f6:	5f 91       	pop	r21
    44f8:	4f 91       	pop	r20
    44fa:	3f 91       	pop	r19
    44fc:	2f 91       	pop	r18
    44fe:	0f 90       	pop	r0
    4500:	0f be       	out	0x3f, r0	; 63
    4502:	0f 90       	pop	r0
    4504:	1f 90       	pop	r1
    4506:	18 95       	reti

00004508 <__vector_default>:

ISR(BADISR_vect)
{
    4508:	1f 92       	push	r1
    450a:	0f 92       	push	r0
    450c:	0f b6       	in	r0, 0x3f	; 63
    450e:	0f 92       	push	r0
    4510:	11 24       	eor	r1, r1
    4512:	2f 93       	push	r18
    4514:	3f 93       	push	r19
    4516:	4f 93       	push	r20
    4518:	5f 93       	push	r21
    451a:	6f 93       	push	r22
    451c:	7f 93       	push	r23
    451e:	8f 93       	push	r24
    4520:	9f 93       	push	r25
    4522:	af 93       	push	r26
    4524:	bf 93       	push	r27
    4526:	ef 93       	push	r30
    4528:	ff 93       	push	r31
  rprintf("BAD_vect called!");
    452a:	00 d0       	rcall	.+0      	; 0x452c <__vector_default+0x24>
    452c:	0f 92       	push	r0
    452e:	81 e0       	ldi	r24, 0x01	; 1
    4530:	ed b7       	in	r30, 0x3d	; 61
    4532:	fe b7       	in	r31, 0x3e	; 62
    4534:	81 83       	std	Z+1, r24	; 0x01
    4536:	80 ed       	ldi	r24, 0xD0	; 208
    4538:	91 e0       	ldi	r25, 0x01	; 1
    453a:	93 83       	std	Z+3, r25	; 0x03
    453c:	82 83       	std	Z+2, r24	; 0x02
    453e:	0e 94 4e 2a 	call	0x549c	; 0x549c <rprintf1RamRom>
    4542:	0f 90       	pop	r0
    4544:	0f 90       	pop	r0
    4546:	0f 90       	pop	r0
}
    4548:	ff 91       	pop	r31
    454a:	ef 91       	pop	r30
    454c:	bf 91       	pop	r27
    454e:	af 91       	pop	r26
    4550:	9f 91       	pop	r25
    4552:	8f 91       	pop	r24
    4554:	7f 91       	pop	r23
    4556:	6f 91       	pop	r22
    4558:	5f 91       	pop	r21
    455a:	4f 91       	pop	r20
    455c:	3f 91       	pop	r19
    455e:	2f 91       	pop	r18
    4560:	0f 90       	pop	r0
    4562:	0f be       	out	0x3f, r0	; 63
    4564:	0f 90       	pop	r0
    4566:	1f 90       	pop	r1
    4568:	18 95       	reti

0000456a <uartSetRxHandler>:
}

void uartSetRxHandler(u08 nUart, void (*rx_func)(unsigned char c))
{
	// make sure the uart number is within bounds
	if(nUart < 4)
    456a:	84 30       	cpi	r24, 0x04	; 4
    456c:	40 f4       	brcc	.+16     	; 0x457e <uartSetRxHandler+0x14>
	{
		// set the receive interrupt to run the supplied user function
		UartRxFunc[nUart] = rx_func;
    456e:	e8 2f       	mov	r30, r24
    4570:	f0 e0       	ldi	r31, 0x00	; 0
    4572:	ee 0f       	add	r30, r30
    4574:	ff 1f       	adc	r31, r31
    4576:	ef 50       	subi	r30, 0x0F	; 15
    4578:	fe 4e       	sbci	r31, 0xEE	; 238
    457a:	71 83       	std	Z+1, r23	; 0x01
    457c:	60 83       	st	Z, r22
    457e:	08 95       	ret

00004580 <uartSetBaudRate>:
	}
}

void uartSetBaudRate(u08 nUart, u32 baudrate)
{
    4580:	1f 93       	push	r17
    4582:	18 2f       	mov	r17, r24
    4584:	9a 01       	movw	r18, r20
    4586:	ab 01       	movw	r20, r22
	// calculate division factor for requested baud rate, and set it
	u16 bauddiv = ((F_CPU+(baudrate*8L))/(baudrate*16L)-1);
    4588:	ca 01       	movw	r24, r20
    458a:	b9 01       	movw	r22, r18
    458c:	60 58       	subi	r22, 0x80	; 128
    458e:	7b 47       	sbci	r23, 0x7B	; 123
    4590:	81 4e       	sbci	r24, 0xE1	; 225
    4592:	9f 4f       	sbci	r25, 0xFF	; 255
    4594:	f3 e0       	ldi	r31, 0x03	; 3
    4596:	66 0f       	add	r22, r22
    4598:	77 1f       	adc	r23, r23
    459a:	88 1f       	adc	r24, r24
    459c:	99 1f       	adc	r25, r25
    459e:	fa 95       	dec	r31
    45a0:	d1 f7       	brne	.-12     	; 0x4596 <uartSetBaudRate+0x16>
    45a2:	e4 e0       	ldi	r30, 0x04	; 4
    45a4:	22 0f       	add	r18, r18
    45a6:	33 1f       	adc	r19, r19
    45a8:	44 1f       	adc	r20, r20
    45aa:	55 1f       	adc	r21, r21
    45ac:	ea 95       	dec	r30
    45ae:	d1 f7       	brne	.-12     	; 0x45a4 <uartSetBaudRate+0x24>
    45b0:	0e 94 e8 2f 	call	0x5fd0	; 0x5fd0 <__udivmodsi4>
    45b4:	21 50       	subi	r18, 0x01	; 1
    45b6:	30 40       	sbci	r19, 0x00	; 0
	if(nUart==3)
    45b8:	13 30       	cpi	r17, 0x03	; 3
    45ba:	29 f4       	brne	.+10     	; 0x45c6 <uartSetBaudRate+0x46>
	{
		outb(UBRR3L, bauddiv);
    45bc:	20 93 34 01 	sts	0x0134, r18
		#ifdef UBRR3H
		outb(UBRR3H, bauddiv>>8);
    45c0:	30 93 35 01 	sts	0x0135, r19
    45c4:	12 c0       	rjmp	.+36     	; 0x45ea <uartSetBaudRate+0x6a>
		#endif
	}
	else if(nUart==2)
    45c6:	12 30       	cpi	r17, 0x02	; 2
    45c8:	29 f4       	brne	.+10     	; 0x45d4 <uartSetBaudRate+0x54>
	{
		outb(UBRR2L, bauddiv);
    45ca:	20 93 d4 00 	sts	0x00D4, r18
		#ifdef UBRR2H
		outb(UBRR2H, bauddiv>>8);
    45ce:	30 93 d5 00 	sts	0x00D5, r19
    45d2:	0b c0       	rjmp	.+22     	; 0x45ea <uartSetBaudRate+0x6a>
		#endif
	}
	else if(nUart==1)
    45d4:	11 30       	cpi	r17, 0x01	; 1
    45d6:	29 f4       	brne	.+10     	; 0x45e2 <uartSetBaudRate+0x62>
	{
		outb(UBRR1L, bauddiv);
    45d8:	20 93 cc 00 	sts	0x00CC, r18
		#ifdef UBRR1H
		outb(UBRR1H, bauddiv>>8);
    45dc:	30 93 cd 00 	sts	0x00CD, r19
    45e0:	04 c0       	rjmp	.+8      	; 0x45ea <uartSetBaudRate+0x6a>
		#endif
	}
	else
	{
		outb(UBRR0L, bauddiv);
    45e2:	20 93 c4 00 	sts	0x00C4, r18
		#ifdef UBRR0H
		outb(UBRR0H, bauddiv>>8);
    45e6:	30 93 c5 00 	sts	0x00C5, r19
		#endif
	}
}
    45ea:	1f 91       	pop	r17
    45ec:	08 95       	ret

000045ee <uartGetRxBuffer>:

cBuffer* uartGetRxBuffer(u08 nUart)
{
    45ee:	28 2f       	mov	r18, r24
    45f0:	30 e0       	ldi	r19, 0x00	; 0
    45f2:	a3 e0       	ldi	r26, 0x03	; 3
    45f4:	22 0f       	add	r18, r18
    45f6:	33 1f       	adc	r19, r19
    45f8:	aa 95       	dec	r26
    45fa:	e1 f7       	brne	.-8      	; 0x45f4 <uartGetRxBuffer+0x6>
    45fc:	24 58       	subi	r18, 0x84	; 132
    45fe:	3d 4e       	sbci	r19, 0xED	; 237
	// return rx buffer pointer
	return &uartRxBuffer[nUart];
}
    4600:	c9 01       	movw	r24, r18
    4602:	08 95       	ret

00004604 <uartGetTxBuffer>:

cBuffer* uartGetTxBuffer(u08 nUart)
{
    4604:	28 2f       	mov	r18, r24
    4606:	30 e0       	ldi	r19, 0x00	; 0
    4608:	b3 e0       	ldi	r27, 0x03	; 3
    460a:	22 0f       	add	r18, r18
    460c:	33 1f       	adc	r19, r19
    460e:	ba 95       	dec	r27
    4610:	e1 f7       	brne	.-8      	; 0x460a <uartGetTxBuffer+0x6>
    4612:	20 56       	subi	r18, 0x60	; 96
    4614:	3d 4e       	sbci	r19, 0xED	; 237
	// return tx buffer pointer
	return &uartTxBuffer[nUart];
}
    4616:	c9 01       	movw	r24, r18
    4618:	08 95       	ret

0000461a <uartSendByte>:

void uartSendByte(u08 nUart, u08 txData)
{
    461a:	e8 2f       	mov	r30, r24
	// wait for the transmitter to be ready
//	while(!uartReadyTx[nUart]);
	// send byte
	if(nUart==3)
    461c:	83 30       	cpi	r24, 0x03	; 3
    461e:	39 f4       	brne	.+14     	; 0x462e <uartSendByte+0x14>
	{
		while(!(UCSR3A & (1<<UDRE3)));
    4620:	80 91 30 01 	lds	r24, 0x0130
    4624:	85 ff       	sbrs	r24, 5
    4626:	fc cf       	rjmp	.-8      	; 0x4620 <uartSendByte+0x6>
		outb(UDR3, txData);
    4628:	60 93 36 01 	sts	0x0136, r22
    462c:	18 c0       	rjmp	.+48     	; 0x465e <uartSendByte+0x44>
	}
	else if(nUart==2)
    462e:	82 30       	cpi	r24, 0x02	; 2
    4630:	39 f4       	brne	.+14     	; 0x4640 <uartSendByte+0x26>
	{
		while(!(UCSR2A & (1<<UDRE2)));
    4632:	80 91 d0 00 	lds	r24, 0x00D0
    4636:	85 ff       	sbrs	r24, 5
    4638:	fc cf       	rjmp	.-8      	; 0x4632 <uartSendByte+0x18>
		outb(UDR2, txData);
    463a:	60 93 d6 00 	sts	0x00D6, r22
    463e:	0f c0       	rjmp	.+30     	; 0x465e <uartSendByte+0x44>
	}
	else if(nUart==1)
    4640:	81 30       	cpi	r24, 0x01	; 1
    4642:	39 f4       	brne	.+14     	; 0x4652 <uartSendByte+0x38>
	{
		while(!(UCSR1A & (1<<UDRE1)));
    4644:	80 91 c8 00 	lds	r24, 0x00C8
    4648:	85 ff       	sbrs	r24, 5
    464a:	fc cf       	rjmp	.-8      	; 0x4644 <uartSendByte+0x2a>
		outb(UDR1, txData);
    464c:	60 93 ce 00 	sts	0x00CE, r22
    4650:	06 c0       	rjmp	.+12     	; 0x465e <uartSendByte+0x44>
	}
	else
	{
		while(!(UCSR0A & (1<<UDRE0)));
    4652:	80 91 c0 00 	lds	r24, 0x00C0
    4656:	85 ff       	sbrs	r24, 5
    4658:	fc cf       	rjmp	.-8      	; 0x4652 <uartSendByte+0x38>
		outb(UDR0, txData);
    465a:	60 93 c6 00 	sts	0x00C6, r22
	}
	// set ready state to FALSE
	uartReadyTx[nUart] = FALSE;
    465e:	f0 e0       	ldi	r31, 0x00	; 0
    4660:	e8 58       	subi	r30, 0x88	; 136
    4662:	fd 4e       	sbci	r31, 0xED	; 237
    4664:	10 82       	st	Z, r1
}
    4666:	08 95       	ret

00004668 <uart0SendByte>:

void uart0SendByte(u08 data)
{
    4668:	68 2f       	mov	r22, r24
	// send byte on UART0
	uartSendByte(0, data);
    466a:	80 e0       	ldi	r24, 0x00	; 0
    466c:	0e 94 0d 23 	call	0x461a	; 0x461a <uartSendByte>
}
    4670:	08 95       	ret

00004672 <uart1SendByte>:

void uart1SendByte(u08 data)
{
    4672:	68 2f       	mov	r22, r24
	// send byte on UART1
	uartSendByte(1, data);
    4674:	81 e0       	ldi	r24, 0x01	; 1
    4676:	0e 94 0d 23 	call	0x461a	; 0x461a <uartSendByte>
}
    467a:	08 95       	ret

0000467c <uart2SendByte>:

void uart2SendByte(u08 data)
{
    467c:	68 2f       	mov	r22, r24
	// send byte on UART2
	uartSendByte(2, data);
    467e:	82 e0       	ldi	r24, 0x02	; 2
    4680:	0e 94 0d 23 	call	0x461a	; 0x461a <uartSendByte>
}
    4684:	08 95       	ret

00004686 <uart3SendByte>:

void uart3SendByte(u08 data)
{
    4686:	68 2f       	mov	r22, r24
	// send byte on UART3
	uartSendByte(3, data);
    4688:	83 e0       	ldi	r24, 0x03	; 3
    468a:	0e 94 0d 23 	call	0x461a	; 0x461a <uartSendByte>
}
    468e:	08 95       	ret

00004690 <uartReceiveBufferIsEmpty>:
	// flush all data from receive buffer
	bufferFlush(&uartRxBuffer[nUart]);
}

u08 uartReceiveBufferIsEmpty(u08 nUart)
{
    4690:	20 e0       	ldi	r18, 0x00	; 0
    4692:	e8 2f       	mov	r30, r24
    4694:	f0 e0       	ldi	r31, 0x00	; 0
    4696:	83 e0       	ldi	r24, 0x03	; 3
    4698:	ee 0f       	add	r30, r30
    469a:	ff 1f       	adc	r31, r31
    469c:	8a 95       	dec	r24
    469e:	e1 f7       	brne	.-8      	; 0x4698 <uartReceiveBufferIsEmpty+0x8>
    46a0:	e0 58       	subi	r30, 0x80	; 128
    46a2:	fd 4e       	sbci	r31, 0xED	; 237
    46a4:	80 81       	ld	r24, Z
    46a6:	91 81       	ldd	r25, Z+1	; 0x01
    46a8:	89 2b       	or	r24, r25
    46aa:	09 f4       	brne	.+2      	; 0x46ae <uartReceiveBufferIsEmpty+0x1e>
    46ac:	21 e0       	ldi	r18, 0x01	; 1
	return (uartRxBuffer[nUart].datalength == 0);
}
    46ae:	82 2f       	mov	r24, r18
    46b0:	08 95       	ret

000046b2 <uartReceiveService>:
	}
}

// UART Receive Complete Interrupt Function
void uartReceiveService(u08 nUart)
{
    46b2:	cf 93       	push	r28
    46b4:	df 93       	push	r29
	u08 c;
	// get received char
	if(nUart==3)
    46b6:	83 30       	cpi	r24, 0x03	; 3
    46b8:	19 f4       	brne	.+6      	; 0x46c0 <uartReceiveService+0xe>
		c = inb(UDR3);
    46ba:	60 91 36 01 	lds	r22, 0x0136
    46be:	0c c0       	rjmp	.+24     	; 0x46d8 <uartReceiveService+0x26>
	else if(nUart==2)
    46c0:	82 30       	cpi	r24, 0x02	; 2
    46c2:	19 f4       	brne	.+6      	; 0x46ca <uartReceiveService+0x18>
		c = inb(UDR2);
    46c4:	60 91 d6 00 	lds	r22, 0x00D6
    46c8:	07 c0       	rjmp	.+14     	; 0x46d8 <uartReceiveService+0x26>
	else if(nUart==1)
    46ca:	81 30       	cpi	r24, 0x01	; 1
    46cc:	19 f4       	brne	.+6      	; 0x46d4 <uartReceiveService+0x22>
		c = inb(UDR1);
    46ce:	60 91 ce 00 	lds	r22, 0x00CE
    46d2:	02 c0       	rjmp	.+4      	; 0x46d8 <uartReceiveService+0x26>
	else
		c = inb(UDR0);
    46d4:	60 91 c6 00 	lds	r22, 0x00C6

	// if there's a user function to handle this receive event
	if(UartRxFunc[nUart])
    46d8:	28 2f       	mov	r18, r24
    46da:	30 e0       	ldi	r19, 0x00	; 0
    46dc:	e9 01       	movw	r28, r18
    46de:	cc 0f       	add	r28, r28
    46e0:	dd 1f       	adc	r29, r29
    46e2:	fe 01       	movw	r30, r28
    46e4:	ef 50       	subi	r30, 0x0F	; 15
    46e6:	fe 4e       	sbci	r31, 0xEE	; 238
    46e8:	80 81       	ld	r24, Z
    46ea:	91 81       	ldd	r25, Z+1	; 0x01
    46ec:	89 2b       	or	r24, r25
    46ee:	31 f0       	breq	.+12     	; 0x46fc <uartReceiveService+0x4a>
	{
		// call it and pass the received data
		UartRxFunc[nUart](c);
    46f0:	01 90       	ld	r0, Z+
    46f2:	f0 81       	ld	r31, Z
    46f4:	e0 2d       	mov	r30, r0
    46f6:	86 2f       	mov	r24, r22
    46f8:	09 95       	icall
    46fa:	14 c0       	rjmp	.+40     	; 0x4724 <uartReceiveService+0x72>
	else
	{
		// otherwise do default processing
		// put received char in buffer
		// check if there's space
		if( !bufferAddToEnd(&uartRxBuffer[nUart], c) )
    46fc:	93 e0       	ldi	r25, 0x03	; 3
    46fe:	22 0f       	add	r18, r18
    4700:	33 1f       	adc	r19, r19
    4702:	9a 95       	dec	r25
    4704:	e1 f7       	brne	.-8      	; 0x46fe <uartReceiveService+0x4c>
    4706:	c9 01       	movw	r24, r18
    4708:	84 58       	subi	r24, 0x84	; 132
    470a:	9d 4e       	sbci	r25, 0xED	; 237
    470c:	0e 94 65 27 	call	0x4eca	; 0x4eca <bufferAddToEnd>
    4710:	88 23       	and	r24, r24
    4712:	41 f4       	brne	.+16     	; 0x4724 <uartReceiveService+0x72>
		{
			// no space in buffer
			// count overflow
			uartRxOverflow[nUart]++;
    4714:	fe 01       	movw	r30, r28
    4716:	e0 54       	subi	r30, 0x40	; 64
    4718:	fd 4e       	sbci	r31, 0xED	; 237
    471a:	80 81       	ld	r24, Z
    471c:	91 81       	ldd	r25, Z+1	; 0x01
    471e:	01 96       	adiw	r24, 0x01	; 1
    4720:	91 83       	std	Z+1, r25	; 0x01
    4722:	80 83       	st	Z, r24
		}
	}
}
    4724:	df 91       	pop	r29
    4726:	cf 91       	pop	r28
    4728:	08 95       	ret

0000472a <__vector_54>:
{
	uartReceiveService(2);
}

UART_INTERRUPT_HANDLER(SIG_USART3_RECV)      
{
    472a:	1f 92       	push	r1
    472c:	0f 92       	push	r0
    472e:	0f b6       	in	r0, 0x3f	; 63
    4730:	0f 92       	push	r0
    4732:	11 24       	eor	r1, r1
    4734:	2f 93       	push	r18
    4736:	3f 93       	push	r19
    4738:	4f 93       	push	r20
    473a:	5f 93       	push	r21
    473c:	6f 93       	push	r22
    473e:	7f 93       	push	r23
    4740:	8f 93       	push	r24
    4742:	9f 93       	push	r25
    4744:	af 93       	push	r26
    4746:	bf 93       	push	r27
    4748:	ef 93       	push	r30
    474a:	ff 93       	push	r31
	uartReceiveService(3);
    474c:	83 e0       	ldi	r24, 0x03	; 3
    474e:	0e 94 59 23 	call	0x46b2	; 0x46b2 <uartReceiveService>
}
    4752:	ff 91       	pop	r31
    4754:	ef 91       	pop	r30
    4756:	bf 91       	pop	r27
    4758:	af 91       	pop	r26
    475a:	9f 91       	pop	r25
    475c:	8f 91       	pop	r24
    475e:	7f 91       	pop	r23
    4760:	6f 91       	pop	r22
    4762:	5f 91       	pop	r21
    4764:	4f 91       	pop	r20
    4766:	3f 91       	pop	r19
    4768:	2f 91       	pop	r18
    476a:	0f 90       	pop	r0
    476c:	0f be       	out	0x3f, r0	; 63
    476e:	0f 90       	pop	r0
    4770:	1f 90       	pop	r1
    4772:	18 95       	reti

00004774 <__vector_51>:
{
	uartReceiveService(1);
}

UART_INTERRUPT_HANDLER(SIG_USART2_RECV)      
{
    4774:	1f 92       	push	r1
    4776:	0f 92       	push	r0
    4778:	0f b6       	in	r0, 0x3f	; 63
    477a:	0f 92       	push	r0
    477c:	11 24       	eor	r1, r1
    477e:	2f 93       	push	r18
    4780:	3f 93       	push	r19
    4782:	4f 93       	push	r20
    4784:	5f 93       	push	r21
    4786:	6f 93       	push	r22
    4788:	7f 93       	push	r23
    478a:	8f 93       	push	r24
    478c:	9f 93       	push	r25
    478e:	af 93       	push	r26
    4790:	bf 93       	push	r27
    4792:	ef 93       	push	r30
    4794:	ff 93       	push	r31
	uartReceiveService(2);
    4796:	82 e0       	ldi	r24, 0x02	; 2
    4798:	0e 94 59 23 	call	0x46b2	; 0x46b2 <uartReceiveService>
}
    479c:	ff 91       	pop	r31
    479e:	ef 91       	pop	r30
    47a0:	bf 91       	pop	r27
    47a2:	af 91       	pop	r26
    47a4:	9f 91       	pop	r25
    47a6:	8f 91       	pop	r24
    47a8:	7f 91       	pop	r23
    47aa:	6f 91       	pop	r22
    47ac:	5f 91       	pop	r21
    47ae:	4f 91       	pop	r20
    47b0:	3f 91       	pop	r19
    47b2:	2f 91       	pop	r18
    47b4:	0f 90       	pop	r0
    47b6:	0f be       	out	0x3f, r0	; 63
    47b8:	0f 90       	pop	r0
    47ba:	1f 90       	pop	r1
    47bc:	18 95       	reti

000047be <__vector_36>:
{
	uartReceiveService(0);
}

UART_INTERRUPT_HANDLER(SIG_USART1_RECV)      
{
    47be:	1f 92       	push	r1
    47c0:	0f 92       	push	r0
    47c2:	0f b6       	in	r0, 0x3f	; 63
    47c4:	0f 92       	push	r0
    47c6:	11 24       	eor	r1, r1
    47c8:	2f 93       	push	r18
    47ca:	3f 93       	push	r19
    47cc:	4f 93       	push	r20
    47ce:	5f 93       	push	r21
    47d0:	6f 93       	push	r22
    47d2:	7f 93       	push	r23
    47d4:	8f 93       	push	r24
    47d6:	9f 93       	push	r25
    47d8:	af 93       	push	r26
    47da:	bf 93       	push	r27
    47dc:	ef 93       	push	r30
    47de:	ff 93       	push	r31
	uartReceiveService(1);
    47e0:	81 e0       	ldi	r24, 0x01	; 1
    47e2:	0e 94 59 23 	call	0x46b2	; 0x46b2 <uartReceiveService>
}
    47e6:	ff 91       	pop	r31
    47e8:	ef 91       	pop	r30
    47ea:	bf 91       	pop	r27
    47ec:	af 91       	pop	r26
    47ee:	9f 91       	pop	r25
    47f0:	8f 91       	pop	r24
    47f2:	7f 91       	pop	r23
    47f4:	6f 91       	pop	r22
    47f6:	5f 91       	pop	r21
    47f8:	4f 91       	pop	r20
    47fa:	3f 91       	pop	r19
    47fc:	2f 91       	pop	r18
    47fe:	0f 90       	pop	r0
    4800:	0f be       	out	0x3f, r0	; 63
    4802:	0f 90       	pop	r0
    4804:	1f 90       	pop	r1
    4806:	18 95       	reti

00004808 <__vector_25>:
	uartTransmitService(3);
}

	// service UART receive interrupt
UART_INTERRUPT_HANDLER(SIG_USART0_RECV)      
{
    4808:	1f 92       	push	r1
    480a:	0f 92       	push	r0
    480c:	0f b6       	in	r0, 0x3f	; 63
    480e:	0f 92       	push	r0
    4810:	11 24       	eor	r1, r1
    4812:	2f 93       	push	r18
    4814:	3f 93       	push	r19
    4816:	4f 93       	push	r20
    4818:	5f 93       	push	r21
    481a:	6f 93       	push	r22
    481c:	7f 93       	push	r23
    481e:	8f 93       	push	r24
    4820:	9f 93       	push	r25
    4822:	af 93       	push	r26
    4824:	bf 93       	push	r27
    4826:	ef 93       	push	r30
    4828:	ff 93       	push	r31
	uartReceiveService(0);
    482a:	80 e0       	ldi	r24, 0x00	; 0
    482c:	0e 94 59 23 	call	0x46b2	; 0x46b2 <uartReceiveService>
}
    4830:	ff 91       	pop	r31
    4832:	ef 91       	pop	r30
    4834:	bf 91       	pop	r27
    4836:	af 91       	pop	r26
    4838:	9f 91       	pop	r25
    483a:	8f 91       	pop	r24
    483c:	7f 91       	pop	r23
    483e:	6f 91       	pop	r22
    4840:	5f 91       	pop	r21
    4842:	4f 91       	pop	r20
    4844:	3f 91       	pop	r19
    4846:	2f 91       	pop	r18
    4848:	0f 90       	pop	r0
    484a:	0f be       	out	0x3f, r0	; 63
    484c:	0f 90       	pop	r0
    484e:	1f 90       	pop	r1
    4850:	18 95       	reti

00004852 <uartSendBuffer>:
	// send the first byte to get things going by interrupts
	uartSendByte(nUart, bufferGetFromFront(&uartTxBuffer[nUart]));
}

u08 uartSendBuffer(u08 nUart, char *buffer, u16 nBytes)
{
    4852:	8f 92       	push	r8
    4854:	9f 92       	push	r9
    4856:	af 92       	push	r10
    4858:	bf 92       	push	r11
    485a:	cf 92       	push	r12
    485c:	df 92       	push	r13
    485e:	ef 92       	push	r14
    4860:	ff 92       	push	r15
    4862:	0f 93       	push	r16
    4864:	1f 93       	push	r17
    4866:	cf 93       	push	r28
    4868:	df 93       	push	r29
    486a:	88 2e       	mov	r8, r24
    486c:	db 01       	movw	r26, r22
	register u08 first;
	register u16 i;

	// check if there's space (and that we have any bytes to send at all)
	if((uartTxBuffer[nUart].datalength + nBytes < uartTxBuffer[nUart].size) && nBytes)
    486e:	c8 2e       	mov	r12, r24
    4870:	dd 24       	eor	r13, r13
    4872:	f6 01       	movw	r30, r12
    4874:	13 e0       	ldi	r17, 0x03	; 3
    4876:	ee 0f       	add	r30, r30
    4878:	ff 1f       	adc	r31, r31
    487a:	1a 95       	dec	r17
    487c:	e1 f7       	brne	.-8      	; 0x4876 <uartSendBuffer+0x24>
    487e:	ec 55       	subi	r30, 0x5C	; 92
    4880:	fd 4e       	sbci	r31, 0xED	; 237
    4882:	20 81       	ld	r18, Z
    4884:	31 81       	ldd	r19, Z+1	; 0x01
    4886:	24 0f       	add	r18, r20
    4888:	35 1f       	adc	r19, r21
    488a:	f6 01       	movw	r30, r12
    488c:	73 e0       	ldi	r23, 0x03	; 3
    488e:	ee 0f       	add	r30, r30
    4890:	ff 1f       	adc	r31, r31
    4892:	7a 95       	dec	r23
    4894:	e1 f7       	brne	.-8      	; 0x488e <uartSendBuffer+0x3c>
    4896:	ee 55       	subi	r30, 0x5E	; 94
    4898:	fd 4e       	sbci	r31, 0xED	; 237
    489a:	80 81       	ld	r24, Z
    489c:	91 81       	ldd	r25, Z+1	; 0x01
    489e:	28 17       	cp	r18, r24
    48a0:	39 07       	cpc	r19, r25
    48a2:	70 f5       	brcc	.+92     	; 0x4900 <uartSendBuffer+0xae>
    48a4:	41 15       	cp	r20, r1
    48a6:	51 05       	cpc	r21, r1
    48a8:	59 f1       	breq	.+86     	; 0x4900 <uartSendBuffer+0xae>
	{
		// grab first character
		first = *buffer++;
    48aa:	9c 90       	ld	r9, X
		// copy user buffer to uart transmit buffer
		for(i = 0; i < nBytes-1; i++)
		{
			// put data bytes at end of buffer
			bufferAddToEnd(&uartTxBuffer[nUart], *buffer++);
    48ac:	76 01       	movw	r14, r12
    48ae:	63 e0       	ldi	r22, 0x03	; 3
    48b0:	ee 0c       	add	r14, r14
    48b2:	ff 1c       	adc	r15, r15
    48b4:	6a 95       	dec	r22
    48b6:	e1 f7       	brne	.-8      	; 0x48b0 <uartSendBuffer+0x5e>
    48b8:	80 ea       	ldi	r24, 0xA0	; 160
    48ba:	92 e1       	ldi	r25, 0x12	; 18
    48bc:	e8 0e       	add	r14, r24
    48be:	f9 1e       	adc	r15, r25
    48c0:	8d 01       	movw	r16, r26
    48c2:	c0 e0       	ldi	r28, 0x00	; 0
    48c4:	d0 e0       	ldi	r29, 0x00	; 0
	if((uartTxBuffer[nUart].datalength + nBytes < uartTxBuffer[nUart].size) && nBytes)
	{
		// grab first character
		first = *buffer++;
		// copy user buffer to uart transmit buffer
		for(i = 0; i < nBytes-1; i++)
    48c6:	5a 01       	movw	r10, r20
    48c8:	08 94       	sec
    48ca:	a1 08       	sbc	r10, r1
    48cc:	b1 08       	sbc	r11, r1
    48ce:	06 c0       	rjmp	.+12     	; 0x48dc <uartSendBuffer+0x8a>
    48d0:	c7 01       	movw	r24, r14
    48d2:	f8 01       	movw	r30, r16
    48d4:	60 81       	ld	r22, Z
    48d6:	0e 94 65 27 	call	0x4eca	; 0x4eca <bufferAddToEnd>
    48da:	21 96       	adiw	r28, 0x01	; 1
    48dc:	0f 5f       	subi	r16, 0xFF	; 255
    48de:	1f 4f       	sbci	r17, 0xFF	; 255
    48e0:	ca 15       	cp	r28, r10
    48e2:	db 05       	cpc	r29, r11
    48e4:	a8 f3       	brcs	.-22     	; 0x48d0 <uartSendBuffer+0x7e>
			// put data bytes at end of buffer
			bufferAddToEnd(&uartTxBuffer[nUart], *buffer++);
		}

		// send the first byte to get things going by interrupts
		uartBufferedTx[nUart] = TRUE;
    48e6:	8c e9       	ldi	r24, 0x9C	; 156
    48e8:	92 e1       	ldi	r25, 0x12	; 18
    48ea:	c8 0e       	add	r12, r24
    48ec:	d9 1e       	adc	r13, r25
    48ee:	8f ef       	ldi	r24, 0xFF	; 255
    48f0:	f6 01       	movw	r30, r12
    48f2:	80 83       	st	Z, r24
		uartSendByte(nUart, first);
    48f4:	88 2d       	mov	r24, r8
    48f6:	69 2d       	mov	r22, r9
    48f8:	0e 94 0d 23 	call	0x461a	; 0x461a <uartSendByte>
    48fc:	8f ef       	ldi	r24, 0xFF	; 255
    48fe:	01 c0       	rjmp	.+2      	; 0x4902 <uartSendBuffer+0xb0>
		// return success
		return TRUE;
    4900:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		// return failure
		return FALSE;
	}
}
    4902:	df 91       	pop	r29
    4904:	cf 91       	pop	r28
    4906:	1f 91       	pop	r17
    4908:	0f 91       	pop	r16
    490a:	ff 90       	pop	r15
    490c:	ef 90       	pop	r14
    490e:	df 90       	pop	r13
    4910:	cf 90       	pop	r12
    4912:	bf 90       	pop	r11
    4914:	af 90       	pop	r10
    4916:	9f 90       	pop	r9
    4918:	8f 90       	pop	r8
    491a:	08 95       	ret

0000491c <uartAddToTxBuffer>:
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    491c:	90 e0       	ldi	r25, 0x00	; 0
    491e:	23 e0       	ldi	r18, 0x03	; 3
    4920:	88 0f       	add	r24, r24
    4922:	99 1f       	adc	r25, r25
    4924:	2a 95       	dec	r18
    4926:	e1 f7       	brne	.-8      	; 0x4920 <uartAddToTxBuffer+0x4>
    4928:	80 56       	subi	r24, 0x60	; 96
    492a:	9d 4e       	sbci	r25, 0xED	; 237
    492c:	0e 94 65 27 	call	0x4eca	; 0x4eca <bufferAddToEnd>
}
    4930:	08 95       	ret

00004932 <uart3AddToTxBuffer>:
{
	uartAddToTxBuffer(2,data);
}

void uart3AddToTxBuffer(u08 data)
{
    4932:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    4934:	88 eb       	ldi	r24, 0xB8	; 184
    4936:	92 e1       	ldi	r25, 0x12	; 18
    4938:	0e 94 65 27 	call	0x4eca	; 0x4eca <bufferAddToEnd>
}

void uart3AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(3,data);
}
    493c:	08 95       	ret

0000493e <uart2AddToTxBuffer>:
{
	uartAddToTxBuffer(1,data);
}

void uart2AddToTxBuffer(u08 data)
{
    493e:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    4940:	80 eb       	ldi	r24, 0xB0	; 176
    4942:	92 e1       	ldi	r25, 0x12	; 18
    4944:	0e 94 65 27 	call	0x4eca	; 0x4eca <bufferAddToEnd>
}

void uart2AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(2,data);
}
    4948:	08 95       	ret

0000494a <uart1AddToTxBuffer>:
{
	uartAddToTxBuffer(0,data);
}

void uart1AddToTxBuffer(u08 data)
{
    494a:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    494c:	88 ea       	ldi	r24, 0xA8	; 168
    494e:	92 e1       	ldi	r25, 0x12	; 18
    4950:	0e 94 65 27 	call	0x4eca	; 0x4eca <bufferAddToEnd>
}

void uart1AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(1,data);
}
    4954:	08 95       	ret

00004956 <uart0AddToTxBuffer>:
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
}

void uart0AddToTxBuffer(u08 data)
{
    4956:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    4958:	80 ea       	ldi	r24, 0xA0	; 160
    495a:	92 e1       	ldi	r25, 0x12	; 18
    495c:	0e 94 65 27 	call	0x4eca	; 0x4eca <bufferAddToEnd>
}

void uart0AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(0,data);
}
    4960:	08 95       	ret

00004962 <uartTransmitService>:
	}
}

// UART Transmit Complete Interrupt Function
void uartTransmitService(u08 nUart)
{
    4962:	cf 93       	push	r28
    4964:	df 93       	push	r29
    4966:	28 2f       	mov	r18, r24
	// check if buffered tx is enabled
	if(uartBufferedTx[nUart])
    4968:	a8 2f       	mov	r26, r24
    496a:	b0 e0       	ldi	r27, 0x00	; 0
    496c:	ed 01       	movw	r28, r26
    496e:	c4 56       	subi	r28, 0x64	; 100
    4970:	dd 4e       	sbci	r29, 0xED	; 237
    4972:	88 81       	ld	r24, Y
    4974:	88 23       	and	r24, r24
    4976:	79 f1       	breq	.+94     	; 0x49d6 <uartTransmitService+0x74>
	{
		// check if there's data left in the buffer
		if(uartTxBuffer[nUart].datalength)
    4978:	fd 01       	movw	r30, r26
    497a:	33 e0       	ldi	r19, 0x03	; 3
    497c:	ee 0f       	add	r30, r30
    497e:	ff 1f       	adc	r31, r31
    4980:	3a 95       	dec	r19
    4982:	e1 f7       	brne	.-8      	; 0x497c <uartTransmitService+0x1a>
    4984:	ec 55       	subi	r30, 0x5C	; 92
    4986:	fd 4e       	sbci	r31, 0xED	; 237
    4988:	80 81       	ld	r24, Z
    498a:	91 81       	ldd	r25, Z+1	; 0x01
    498c:	89 2b       	or	r24, r25
    498e:	11 f1       	breq	.+68     	; 0x49d4 <uartTransmitService+0x72>
		{
			// send byte from top of buffer
			if(nUart==3)
    4990:	23 30       	cpi	r18, 0x03	; 3
    4992:	39 f4       	brne	.+14     	; 0x49a2 <uartTransmitService+0x40>
				outb(UDR3,  bufferGetFromFront(&uartTxBuffer[3]) );
    4994:	88 eb       	ldi	r24, 0xB8	; 184
    4996:	92 e1       	ldi	r25, 0x12	; 18
    4998:	0e 94 fc 26 	call	0x4df8	; 0x4df8 <bufferGetFromFront>
    499c:	80 93 36 01 	sts	0x0136, r24
    49a0:	1e c0       	rjmp	.+60     	; 0x49de <uartTransmitService+0x7c>
			else if(nUart==2)
    49a2:	22 30       	cpi	r18, 0x02	; 2
    49a4:	39 f4       	brne	.+14     	; 0x49b4 <uartTransmitService+0x52>
				outb(UDR2,  bufferGetFromFront(&uartTxBuffer[2]) );
    49a6:	80 eb       	ldi	r24, 0xB0	; 176
    49a8:	92 e1       	ldi	r25, 0x12	; 18
    49aa:	0e 94 fc 26 	call	0x4df8	; 0x4df8 <bufferGetFromFront>
    49ae:	80 93 d6 00 	sts	0x00D6, r24
    49b2:	15 c0       	rjmp	.+42     	; 0x49de <uartTransmitService+0x7c>
			else if(nUart==1)
    49b4:	21 30       	cpi	r18, 0x01	; 1
    49b6:	39 f4       	brne	.+14     	; 0x49c6 <uartTransmitService+0x64>
				outb(UDR1,  bufferGetFromFront(&uartTxBuffer[1]) );
    49b8:	88 ea       	ldi	r24, 0xA8	; 168
    49ba:	92 e1       	ldi	r25, 0x12	; 18
    49bc:	0e 94 fc 26 	call	0x4df8	; 0x4df8 <bufferGetFromFront>
    49c0:	80 93 ce 00 	sts	0x00CE, r24
    49c4:	0c c0       	rjmp	.+24     	; 0x49de <uartTransmitService+0x7c>
			else
				outb(UDR0,  bufferGetFromFront(&uartTxBuffer[0]) );
    49c6:	80 ea       	ldi	r24, 0xA0	; 160
    49c8:	92 e1       	ldi	r25, 0x12	; 18
    49ca:	0e 94 fc 26 	call	0x4df8	; 0x4df8 <bufferGetFromFront>
    49ce:	80 93 c6 00 	sts	0x00C6, r24
    49d2:	05 c0       	rjmp	.+10     	; 0x49de <uartTransmitService+0x7c>
		}
		else
		{
			// no data left
			uartBufferedTx[nUart] = FALSE;
    49d4:	18 82       	st	Y, r1
	}
	else
	{
		// we're using single-byte tx mode
		// indicate transmit complete, back to ready
		uartReadyTx[nUart] = TRUE;
    49d6:	a8 58       	subi	r26, 0x88	; 136
    49d8:	bd 4e       	sbci	r27, 0xED	; 237
    49da:	8f ef       	ldi	r24, 0xFF	; 255
    49dc:	8c 93       	st	X, r24
	}
}
    49de:	df 91       	pop	r29
    49e0:	cf 91       	pop	r28
    49e2:	08 95       	ret

000049e4 <__vector_56>:
{
	uartTransmitService(2);
}

UART_INTERRUPT_HANDLER(SIG_USART3_TRANS)      
{
    49e4:	1f 92       	push	r1
    49e6:	0f 92       	push	r0
    49e8:	0f b6       	in	r0, 0x3f	; 63
    49ea:	0f 92       	push	r0
    49ec:	11 24       	eor	r1, r1
    49ee:	2f 93       	push	r18
    49f0:	3f 93       	push	r19
    49f2:	4f 93       	push	r20
    49f4:	5f 93       	push	r21
    49f6:	6f 93       	push	r22
    49f8:	7f 93       	push	r23
    49fa:	8f 93       	push	r24
    49fc:	9f 93       	push	r25
    49fe:	af 93       	push	r26
    4a00:	bf 93       	push	r27
    4a02:	ef 93       	push	r30
    4a04:	ff 93       	push	r31
	uartTransmitService(3);
    4a06:	83 e0       	ldi	r24, 0x03	; 3
    4a08:	0e 94 b1 24 	call	0x4962	; 0x4962 <uartTransmitService>
}
    4a0c:	ff 91       	pop	r31
    4a0e:	ef 91       	pop	r30
    4a10:	bf 91       	pop	r27
    4a12:	af 91       	pop	r26
    4a14:	9f 91       	pop	r25
    4a16:	8f 91       	pop	r24
    4a18:	7f 91       	pop	r23
    4a1a:	6f 91       	pop	r22
    4a1c:	5f 91       	pop	r21
    4a1e:	4f 91       	pop	r20
    4a20:	3f 91       	pop	r19
    4a22:	2f 91       	pop	r18
    4a24:	0f 90       	pop	r0
    4a26:	0f be       	out	0x3f, r0	; 63
    4a28:	0f 90       	pop	r0
    4a2a:	1f 90       	pop	r1
    4a2c:	18 95       	reti

00004a2e <__vector_53>:
{
	uartTransmitService(1);
}

UART_INTERRUPT_HANDLER(SIG_USART2_TRANS)      
{
    4a2e:	1f 92       	push	r1
    4a30:	0f 92       	push	r0
    4a32:	0f b6       	in	r0, 0x3f	; 63
    4a34:	0f 92       	push	r0
    4a36:	11 24       	eor	r1, r1
    4a38:	2f 93       	push	r18
    4a3a:	3f 93       	push	r19
    4a3c:	4f 93       	push	r20
    4a3e:	5f 93       	push	r21
    4a40:	6f 93       	push	r22
    4a42:	7f 93       	push	r23
    4a44:	8f 93       	push	r24
    4a46:	9f 93       	push	r25
    4a48:	af 93       	push	r26
    4a4a:	bf 93       	push	r27
    4a4c:	ef 93       	push	r30
    4a4e:	ff 93       	push	r31
	uartTransmitService(2);
    4a50:	82 e0       	ldi	r24, 0x02	; 2
    4a52:	0e 94 b1 24 	call	0x4962	; 0x4962 <uartTransmitService>
}
    4a56:	ff 91       	pop	r31
    4a58:	ef 91       	pop	r30
    4a5a:	bf 91       	pop	r27
    4a5c:	af 91       	pop	r26
    4a5e:	9f 91       	pop	r25
    4a60:	8f 91       	pop	r24
    4a62:	7f 91       	pop	r23
    4a64:	6f 91       	pop	r22
    4a66:	5f 91       	pop	r21
    4a68:	4f 91       	pop	r20
    4a6a:	3f 91       	pop	r19
    4a6c:	2f 91       	pop	r18
    4a6e:	0f 90       	pop	r0
    4a70:	0f be       	out	0x3f, r0	; 63
    4a72:	0f 90       	pop	r0
    4a74:	1f 90       	pop	r1
    4a76:	18 95       	reti

00004a78 <__vector_38>:
{
	uartTransmitService(0);
}

UART_INTERRUPT_HANDLER(SIG_USART1_TRANS)      
{
    4a78:	1f 92       	push	r1
    4a7a:	0f 92       	push	r0
    4a7c:	0f b6       	in	r0, 0x3f	; 63
    4a7e:	0f 92       	push	r0
    4a80:	11 24       	eor	r1, r1
    4a82:	2f 93       	push	r18
    4a84:	3f 93       	push	r19
    4a86:	4f 93       	push	r20
    4a88:	5f 93       	push	r21
    4a8a:	6f 93       	push	r22
    4a8c:	7f 93       	push	r23
    4a8e:	8f 93       	push	r24
    4a90:	9f 93       	push	r25
    4a92:	af 93       	push	r26
    4a94:	bf 93       	push	r27
    4a96:	ef 93       	push	r30
    4a98:	ff 93       	push	r31
	uartTransmitService(1);
    4a9a:	81 e0       	ldi	r24, 0x01	; 1
    4a9c:	0e 94 b1 24 	call	0x4962	; 0x4962 <uartTransmitService>
}
    4aa0:	ff 91       	pop	r31
    4aa2:	ef 91       	pop	r30
    4aa4:	bf 91       	pop	r27
    4aa6:	af 91       	pop	r26
    4aa8:	9f 91       	pop	r25
    4aaa:	8f 91       	pop	r24
    4aac:	7f 91       	pop	r23
    4aae:	6f 91       	pop	r22
    4ab0:	5f 91       	pop	r21
    4ab2:	4f 91       	pop	r20
    4ab4:	3f 91       	pop	r19
    4ab6:	2f 91       	pop	r18
    4ab8:	0f 90       	pop	r0
    4aba:	0f be       	out	0x3f, r0	; 63
    4abc:	0f 90       	pop	r0
    4abe:	1f 90       	pop	r1
    4ac0:	18 95       	reti

00004ac2 <__vector_27>:
	}
}

	// service UART transmit interrupt
UART_INTERRUPT_HANDLER(SIG_USART0_TRANS)      
{
    4ac2:	1f 92       	push	r1
    4ac4:	0f 92       	push	r0
    4ac6:	0f b6       	in	r0, 0x3f	; 63
    4ac8:	0f 92       	push	r0
    4aca:	11 24       	eor	r1, r1
    4acc:	2f 93       	push	r18
    4ace:	3f 93       	push	r19
    4ad0:	4f 93       	push	r20
    4ad2:	5f 93       	push	r21
    4ad4:	6f 93       	push	r22
    4ad6:	7f 93       	push	r23
    4ad8:	8f 93       	push	r24
    4ada:	9f 93       	push	r25
    4adc:	af 93       	push	r26
    4ade:	bf 93       	push	r27
    4ae0:	ef 93       	push	r30
    4ae2:	ff 93       	push	r31
	uartTransmitService(0);
    4ae4:	80 e0       	ldi	r24, 0x00	; 0
    4ae6:	0e 94 b1 24 	call	0x4962	; 0x4962 <uartTransmitService>
}
    4aea:	ff 91       	pop	r31
    4aec:	ef 91       	pop	r30
    4aee:	bf 91       	pop	r27
    4af0:	af 91       	pop	r26
    4af2:	9f 91       	pop	r25
    4af4:	8f 91       	pop	r24
    4af6:	7f 91       	pop	r23
    4af8:	6f 91       	pop	r22
    4afa:	5f 91       	pop	r21
    4afc:	4f 91       	pop	r20
    4afe:	3f 91       	pop	r19
    4b00:	2f 91       	pop	r18
    4b02:	0f 90       	pop	r0
    4b04:	0f be       	out	0x3f, r0	; 63
    4b06:	0f 90       	pop	r0
    4b08:	1f 90       	pop	r1
    4b0a:	18 95       	reti

00004b0c <uartSendTxBuffer>:
{
	uartAddToTxBuffer(3,data);
}

void uartSendTxBuffer(u08 nUart)
{
    4b0c:	1f 93       	push	r17
    4b0e:	18 2f       	mov	r17, r24
	// turn on buffered transmit
	uartBufferedTx[nUart] = TRUE;
    4b10:	90 e0       	ldi	r25, 0x00	; 0
    4b12:	fc 01       	movw	r30, r24
    4b14:	e4 56       	subi	r30, 0x64	; 100
    4b16:	fd 4e       	sbci	r31, 0xED	; 237
    4b18:	2f ef       	ldi	r18, 0xFF	; 255
    4b1a:	20 83       	st	Z, r18
	// send the first byte to get things going by interrupts
	uartSendByte(nUart, bufferGetFromFront(&uartTxBuffer[nUart]));
    4b1c:	43 e0       	ldi	r20, 0x03	; 3
    4b1e:	88 0f       	add	r24, r24
    4b20:	99 1f       	adc	r25, r25
    4b22:	4a 95       	dec	r20
    4b24:	e1 f7       	brne	.-8      	; 0x4b1e <uartSendTxBuffer+0x12>
    4b26:	80 56       	subi	r24, 0x60	; 96
    4b28:	9d 4e       	sbci	r25, 0xED	; 237
    4b2a:	0e 94 fc 26 	call	0x4df8	; 0x4df8 <bufferGetFromFront>
    4b2e:	68 2f       	mov	r22, r24
    4b30:	81 2f       	mov	r24, r17
    4b32:	0e 94 0d 23 	call	0x461a	; 0x461a <uartSendByte>
}
    4b36:	1f 91       	pop	r17
    4b38:	08 95       	ret

00004b3a <uartReceiveByte>:
		return -1;
}


u08 uartReceiveByte(u08 nUart, u08* rxData)
{
    4b3a:	cf 93       	push	r28
    4b3c:	df 93       	push	r29
    4b3e:	eb 01       	movw	r28, r22
	// make sure we have a receive buffer
	if(uartRxBuffer[nUart].size)
    4b40:	28 2f       	mov	r18, r24
    4b42:	30 e0       	ldi	r19, 0x00	; 0
    4b44:	f9 01       	movw	r30, r18
    4b46:	73 e0       	ldi	r23, 0x03	; 3
    4b48:	ee 0f       	add	r30, r30
    4b4a:	ff 1f       	adc	r31, r31
    4b4c:	7a 95       	dec	r23
    4b4e:	e1 f7       	brne	.-8      	; 0x4b48 <uartReceiveByte+0xe>
    4b50:	e2 58       	subi	r30, 0x82	; 130
    4b52:	fd 4e       	sbci	r31, 0xED	; 237
    4b54:	80 81       	ld	r24, Z
    4b56:	91 81       	ldd	r25, Z+1	; 0x01
    4b58:	89 2b       	or	r24, r25
    4b5a:	c9 f0       	breq	.+50     	; 0x4b8e <uartReceiveByte+0x54>
	{
		// make sure we have data
		if(uartRxBuffer[nUart].datalength)
    4b5c:	f9 01       	movw	r30, r18
    4b5e:	63 e0       	ldi	r22, 0x03	; 3
    4b60:	ee 0f       	add	r30, r30
    4b62:	ff 1f       	adc	r31, r31
    4b64:	6a 95       	dec	r22
    4b66:	e1 f7       	brne	.-8      	; 0x4b60 <uartReceiveByte+0x26>
    4b68:	e0 58       	subi	r30, 0x80	; 128
    4b6a:	fd 4e       	sbci	r31, 0xED	; 237
    4b6c:	80 81       	ld	r24, Z
    4b6e:	91 81       	ldd	r25, Z+1	; 0x01
    4b70:	89 2b       	or	r24, r25
    4b72:	69 f0       	breq	.+26     	; 0x4b8e <uartReceiveByte+0x54>
		{
			// get byte from beginning of buffer
			*rxData = bufferGetFromFront(&uartRxBuffer[nUart]);
    4b74:	53 e0       	ldi	r21, 0x03	; 3
    4b76:	22 0f       	add	r18, r18
    4b78:	33 1f       	adc	r19, r19
    4b7a:	5a 95       	dec	r21
    4b7c:	e1 f7       	brne	.-8      	; 0x4b76 <uartReceiveByte+0x3c>
    4b7e:	c9 01       	movw	r24, r18
    4b80:	84 58       	subi	r24, 0x84	; 132
    4b82:	9d 4e       	sbci	r25, 0xED	; 237
    4b84:	0e 94 fc 26 	call	0x4df8	; 0x4df8 <bufferGetFromFront>
    4b88:	88 83       	st	Y, r24
    4b8a:	8f ef       	ldi	r24, 0xFF	; 255
    4b8c:	01 c0       	rjmp	.+2      	; 0x4b90 <uartReceiveByte+0x56>
			return TRUE;
    4b8e:	80 e0       	ldi	r24, 0x00	; 0
		else
			return FALSE;			// no data
	}
	else
		return FALSE;				// no buffer
}
    4b90:	df 91       	pop	r29
    4b92:	cf 91       	pop	r28
    4b94:	08 95       	ret

00004b96 <uart3GetByte>:
	else
		return -1;
}

int uart3GetByte(void)
{
    4b96:	df 93       	push	r29
    4b98:	cf 93       	push	r28
    4b9a:	0f 92       	push	r0
    4b9c:	cd b7       	in	r28, 0x3d	; 61
    4b9e:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(3,&c))
    4ba0:	83 e0       	ldi	r24, 0x03	; 3
    4ba2:	be 01       	movw	r22, r28
    4ba4:	6f 5f       	subi	r22, 0xFF	; 255
    4ba6:	7f 4f       	sbci	r23, 0xFF	; 255
    4ba8:	0e 94 9d 25 	call	0x4b3a	; 0x4b3a <uartReceiveByte>
    4bac:	88 23       	and	r24, r24
    4bae:	19 f4       	brne	.+6      	; 0x4bb6 <uart3GetByte+0x20>
    4bb0:	2f ef       	ldi	r18, 0xFF	; 255
    4bb2:	3f ef       	ldi	r19, 0xFF	; 255
    4bb4:	03 c0       	rjmp	.+6      	; 0x4bbc <uart3GetByte+0x26>
		return c;
    4bb6:	89 81       	ldd	r24, Y+1	; 0x01
    4bb8:	28 2f       	mov	r18, r24
    4bba:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    4bbc:	c9 01       	movw	r24, r18
    4bbe:	0f 90       	pop	r0
    4bc0:	cf 91       	pop	r28
    4bc2:	df 91       	pop	r29
    4bc4:	08 95       	ret

00004bc6 <uart2GetByte>:
	else
		return -1;
}

int uart2GetByte(void)
{
    4bc6:	df 93       	push	r29
    4bc8:	cf 93       	push	r28
    4bca:	0f 92       	push	r0
    4bcc:	cd b7       	in	r28, 0x3d	; 61
    4bce:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(2,&c))
    4bd0:	82 e0       	ldi	r24, 0x02	; 2
    4bd2:	be 01       	movw	r22, r28
    4bd4:	6f 5f       	subi	r22, 0xFF	; 255
    4bd6:	7f 4f       	sbci	r23, 0xFF	; 255
    4bd8:	0e 94 9d 25 	call	0x4b3a	; 0x4b3a <uartReceiveByte>
    4bdc:	88 23       	and	r24, r24
    4bde:	19 f4       	brne	.+6      	; 0x4be6 <uart2GetByte+0x20>
    4be0:	2f ef       	ldi	r18, 0xFF	; 255
    4be2:	3f ef       	ldi	r19, 0xFF	; 255
    4be4:	03 c0       	rjmp	.+6      	; 0x4bec <uart2GetByte+0x26>
		return c;
    4be6:	89 81       	ldd	r24, Y+1	; 0x01
    4be8:	28 2f       	mov	r18, r24
    4bea:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    4bec:	c9 01       	movw	r24, r18
    4bee:	0f 90       	pop	r0
    4bf0:	cf 91       	pop	r28
    4bf2:	df 91       	pop	r29
    4bf4:	08 95       	ret

00004bf6 <uart1GetByte>:
	else
		return -1;
}

int uart1GetByte(void)
{
    4bf6:	df 93       	push	r29
    4bf8:	cf 93       	push	r28
    4bfa:	0f 92       	push	r0
    4bfc:	cd b7       	in	r28, 0x3d	; 61
    4bfe:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(1,&c))
    4c00:	81 e0       	ldi	r24, 0x01	; 1
    4c02:	be 01       	movw	r22, r28
    4c04:	6f 5f       	subi	r22, 0xFF	; 255
    4c06:	7f 4f       	sbci	r23, 0xFF	; 255
    4c08:	0e 94 9d 25 	call	0x4b3a	; 0x4b3a <uartReceiveByte>
    4c0c:	88 23       	and	r24, r24
    4c0e:	19 f4       	brne	.+6      	; 0x4c16 <uart1GetByte+0x20>
    4c10:	2f ef       	ldi	r18, 0xFF	; 255
    4c12:	3f ef       	ldi	r19, 0xFF	; 255
    4c14:	03 c0       	rjmp	.+6      	; 0x4c1c <uart1GetByte+0x26>
		return c;
    4c16:	89 81       	ldd	r24, Y+1	; 0x01
    4c18:	28 2f       	mov	r18, r24
    4c1a:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    4c1c:	c9 01       	movw	r24, r18
    4c1e:	0f 90       	pop	r0
    4c20:	cf 91       	pop	r28
    4c22:	df 91       	pop	r29
    4c24:	08 95       	ret

00004c26 <uart0GetByte>:
	// send byte on UART3
	uartSendByte(3, data);
}

int uart0GetByte(void)
{
    4c26:	df 93       	push	r29
    4c28:	cf 93       	push	r28
    4c2a:	0f 92       	push	r0
    4c2c:	cd b7       	in	r28, 0x3d	; 61
    4c2e:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(0,&c))
    4c30:	80 e0       	ldi	r24, 0x00	; 0
    4c32:	be 01       	movw	r22, r28
    4c34:	6f 5f       	subi	r22, 0xFF	; 255
    4c36:	7f 4f       	sbci	r23, 0xFF	; 255
    4c38:	0e 94 9d 25 	call	0x4b3a	; 0x4b3a <uartReceiveByte>
    4c3c:	88 23       	and	r24, r24
    4c3e:	19 f4       	brne	.+6      	; 0x4c46 <uart0GetByte+0x20>
    4c40:	2f ef       	ldi	r18, 0xFF	; 255
    4c42:	3f ef       	ldi	r19, 0xFF	; 255
    4c44:	03 c0       	rjmp	.+6      	; 0x4c4c <uart0GetByte+0x26>
		return c;
    4c46:	89 81       	ldd	r24, Y+1	; 0x01
    4c48:	28 2f       	mov	r18, r24
    4c4a:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    4c4c:	c9 01       	movw	r24, r18
    4c4e:	0f 90       	pop	r0
    4c50:	cf 91       	pop	r28
    4c52:	df 91       	pop	r29
    4c54:	08 95       	ret

00004c56 <uartFlushReceiveBuffer>:
}

void uartFlushReceiveBuffer(u08 nUart)
{
	// flush all data from receive buffer
	bufferFlush(&uartRxBuffer[nUart]);
    4c56:	90 e0       	ldi	r25, 0x00	; 0
    4c58:	e3 e0       	ldi	r30, 0x03	; 3
    4c5a:	88 0f       	add	r24, r24
    4c5c:	99 1f       	adc	r25, r25
    4c5e:	ea 95       	dec	r30
    4c60:	e1 f7       	brne	.-8      	; 0x4c5a <uartFlushReceiveBuffer+0x4>
    4c62:	84 58       	subi	r24, 0x84	; 132
    4c64:	9d 4e       	sbci	r25, 0xED	; 237
    4c66:	0e 94 98 27 	call	0x4f30	; 0x4f30 <bufferFlush>
}
    4c6a:	08 95       	ret

00004c6c <uart3InitBuffers>:

void uart3InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART3 buffers
		bufferInit(&uartRxBuffer[3], (u08*) uart3RxData, UART3_RX_BUFFER_SIZE);
    4c6c:	84 e9       	ldi	r24, 0x94	; 148
    4c6e:	92 e1       	ldi	r25, 0x12	; 18
    4c70:	61 e6       	ldi	r22, 0x61	; 97
    4c72:	71 e1       	ldi	r23, 0x11	; 17
    4c74:	40 e8       	ldi	r20, 0x80	; 128
    4c76:	50 e0       	ldi	r21, 0x00	; 0
    4c78:	0e 94 ef 26 	call	0x4dde	; 0x4dde <bufferInit>
		bufferInit(&uartTxBuffer[3], (u08*) uart3TxData, UART3_TX_BUFFER_SIZE);
    4c7c:	88 eb       	ldi	r24, 0xB8	; 184
    4c7e:	92 e1       	ldi	r25, 0x12	; 18
    4c80:	61 ee       	ldi	r22, 0xE1	; 225
    4c82:	71 e1       	ldi	r23, 0x11	; 17
    4c84:	40 e1       	ldi	r20, 0x10	; 16
    4c86:	50 e0       	ldi	r21, 0x00	; 0
    4c88:	0e 94 ef 26 	call	0x4dde	; 0x4dde <bufferInit>
	#else
		// initialize the UART3 buffers
		bufferInit(&uartRxBuffer[3], (u08*) UART3_RX_BUFFER_ADDR, UART3_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[3], (u08*) UART3_TX_BUFFER_ADDR, UART3_TX_BUFFER_SIZE);
	#endif
}
    4c8c:	08 95       	ret

00004c8e <uart3Init>:
}

void uart3Init(void)
{
	// initialize the buffers
	uart3InitBuffers();
    4c8e:	0e 94 36 26 	call	0x4c6c	; 0x4c6c <uart3InitBuffers>
	// initialize user receive handlers
	UartRxFunc[3] = 0;
    4c92:	10 92 f8 11 	sts	0x11F8, r1
    4c96:	10 92 f7 11 	sts	0x11F7, r1
	// enable RxD/TxD and interrupts
	outb(UCSR3B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    4c9a:	88 ed       	ldi	r24, 0xD8	; 216
    4c9c:	80 93 31 01 	sts	0x0131, r24
	// set default baud rate
	uartSetBaudRate(3, UART3_DEFAULT_BAUD_RATE);
    4ca0:	83 e0       	ldi	r24, 0x03	; 3
    4ca2:	40 e8       	ldi	r20, 0x80	; 128
    4ca4:	55 e2       	ldi	r21, 0x25	; 37
    4ca6:	60 e0       	ldi	r22, 0x00	; 0
    4ca8:	70 e0       	ldi	r23, 0x00	; 0
    4caa:	0e 94 c0 22 	call	0x4580	; 0x4580 <uartSetBaudRate>
	// initialize states
	uartReadyTx[3] = TRUE;
    4cae:	8f ef       	ldi	r24, 0xFF	; 255
    4cb0:	80 93 7b 12 	sts	0x127B, r24
	uartBufferedTx[3] = FALSE;
    4cb4:	10 92 9f 12 	sts	0x129F, r1
	// clear overflow count
	uartRxOverflow[3] = 0;
    4cb8:	10 92 c7 12 	sts	0x12C7, r1
    4cbc:	10 92 c6 12 	sts	0x12C6, r1
	// enable interrupts
	sei();
    4cc0:	78 94       	sei
}
    4cc2:	08 95       	ret

00004cc4 <uart2InitBuffers>:

void uart2InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART2 buffers
		bufferInit(&uartRxBuffer[2], (u08*) uart2RxData, UART2_RX_BUFFER_SIZE);
    4cc4:	8c e8       	ldi	r24, 0x8C	; 140
    4cc6:	92 e1       	ldi	r25, 0x12	; 18
    4cc8:	61 ed       	ldi	r22, 0xD1	; 209
    4cca:	70 e1       	ldi	r23, 0x10	; 16
    4ccc:	40 e8       	ldi	r20, 0x80	; 128
    4cce:	50 e0       	ldi	r21, 0x00	; 0
    4cd0:	0e 94 ef 26 	call	0x4dde	; 0x4dde <bufferInit>
		bufferInit(&uartTxBuffer[2], (u08*) uart2TxData, UART2_TX_BUFFER_SIZE);
    4cd4:	80 eb       	ldi	r24, 0xB0	; 176
    4cd6:	92 e1       	ldi	r25, 0x12	; 18
    4cd8:	61 e5       	ldi	r22, 0x51	; 81
    4cda:	71 e1       	ldi	r23, 0x11	; 17
    4cdc:	40 e1       	ldi	r20, 0x10	; 16
    4cde:	50 e0       	ldi	r21, 0x00	; 0
    4ce0:	0e 94 ef 26 	call	0x4dde	; 0x4dde <bufferInit>
	#else
		// initialize the UART2 buffers
		bufferInit(&uartRxBuffer[2], (u08*) UART2_RX_BUFFER_ADDR, UART2_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[2], (u08*) UART2_TX_BUFFER_ADDR, UART2_TX_BUFFER_SIZE);
	#endif
}
    4ce4:	08 95       	ret

00004ce6 <uart2Init>:
}

void uart2Init(void)
{
	// initialize the buffers
	uart2InitBuffers();
    4ce6:	0e 94 62 26 	call	0x4cc4	; 0x4cc4 <uart2InitBuffers>
	// initialize user receive handlers
	UartRxFunc[2] = 0;
    4cea:	10 92 f6 11 	sts	0x11F6, r1
    4cee:	10 92 f5 11 	sts	0x11F5, r1
	// enable RxD/TxD and interrupts
	outb(UCSR2B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    4cf2:	88 ed       	ldi	r24, 0xD8	; 216
    4cf4:	80 93 d1 00 	sts	0x00D1, r24
	// set default baud rate
	uartSetBaudRate(2, UART2_DEFAULT_BAUD_RATE);
    4cf8:	82 e0       	ldi	r24, 0x02	; 2
    4cfa:	40 e8       	ldi	r20, 0x80	; 128
    4cfc:	55 e2       	ldi	r21, 0x25	; 37
    4cfe:	60 e0       	ldi	r22, 0x00	; 0
    4d00:	70 e0       	ldi	r23, 0x00	; 0
    4d02:	0e 94 c0 22 	call	0x4580	; 0x4580 <uartSetBaudRate>
	// initialize states
	uartReadyTx[2] = TRUE;
    4d06:	8f ef       	ldi	r24, 0xFF	; 255
    4d08:	80 93 7a 12 	sts	0x127A, r24
	uartBufferedTx[2] = FALSE;
    4d0c:	10 92 9e 12 	sts	0x129E, r1
	// clear overflow count
	uartRxOverflow[2] = 0;
    4d10:	10 92 c5 12 	sts	0x12C5, r1
    4d14:	10 92 c4 12 	sts	0x12C4, r1
	// enable interrupts
	sei();
    4d18:	78 94       	sei
}
    4d1a:	08 95       	ret

00004d1c <uart1InitBuffers>:

void uart1InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART1 buffers
		bufferInit(&uartRxBuffer[1], (u08*) uart1RxData, UART1_RX_BUFFER_SIZE);
    4d1c:	84 e8       	ldi	r24, 0x84	; 132
    4d1e:	92 e1       	ldi	r25, 0x12	; 18
    4d20:	61 e4       	ldi	r22, 0x41	; 65
    4d22:	70 e1       	ldi	r23, 0x10	; 16
    4d24:	40 e8       	ldi	r20, 0x80	; 128
    4d26:	50 e0       	ldi	r21, 0x00	; 0
    4d28:	0e 94 ef 26 	call	0x4dde	; 0x4dde <bufferInit>
		bufferInit(&uartTxBuffer[1], (u08*) uart1TxData, UART1_TX_BUFFER_SIZE);
    4d2c:	88 ea       	ldi	r24, 0xA8	; 168
    4d2e:	92 e1       	ldi	r25, 0x12	; 18
    4d30:	61 ec       	ldi	r22, 0xC1	; 193
    4d32:	70 e1       	ldi	r23, 0x10	; 16
    4d34:	40 e1       	ldi	r20, 0x10	; 16
    4d36:	50 e0       	ldi	r21, 0x00	; 0
    4d38:	0e 94 ef 26 	call	0x4dde	; 0x4dde <bufferInit>
	#else
		// initialize the UART1 buffers
		bufferInit(&uartRxBuffer[1], (u08*) UART1_RX_BUFFER_ADDR, UART1_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[1], (u08*) UART1_TX_BUFFER_ADDR, UART1_TX_BUFFER_SIZE);
	#endif
}
    4d3c:	08 95       	ret

00004d3e <uart1Init>:
}

void uart1Init(void)
{
	// initialize the buffers
	uart1InitBuffers();
    4d3e:	0e 94 8e 26 	call	0x4d1c	; 0x4d1c <uart1InitBuffers>
	// initialize user receive handlers
	UartRxFunc[1] = 0;
    4d42:	10 92 f4 11 	sts	0x11F4, r1
    4d46:	10 92 f3 11 	sts	0x11F3, r1
	// enable RxD/TxD and interrupts
	outb(UCSR1B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    4d4a:	88 ed       	ldi	r24, 0xD8	; 216
    4d4c:	80 93 c9 00 	sts	0x00C9, r24
	// set default baud rate
	uartSetBaudRate(1, UART1_DEFAULT_BAUD_RATE);
    4d50:	81 e0       	ldi	r24, 0x01	; 1
    4d52:	40 e8       	ldi	r20, 0x80	; 128
    4d54:	55 e2       	ldi	r21, 0x25	; 37
    4d56:	60 e0       	ldi	r22, 0x00	; 0
    4d58:	70 e0       	ldi	r23, 0x00	; 0
    4d5a:	0e 94 c0 22 	call	0x4580	; 0x4580 <uartSetBaudRate>
	// initialize states
	uartReadyTx[1] = TRUE;
    4d5e:	8f ef       	ldi	r24, 0xFF	; 255
    4d60:	80 93 79 12 	sts	0x1279, r24
	uartBufferedTx[1] = FALSE;
    4d64:	10 92 9d 12 	sts	0x129D, r1
	// clear overflow count
	uartRxOverflow[1] = 0;
    4d68:	10 92 c3 12 	sts	0x12C3, r1
    4d6c:	10 92 c2 12 	sts	0x12C2, r1
	// enable interrupts
	sei();
    4d70:	78 94       	sei
}
    4d72:	08 95       	ret

00004d74 <uart0InitBuffers>:

void uart0InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART0 buffers
		bufferInit(&uartRxBuffer[0], (u08*) uart0RxData, UART0_RX_BUFFER_SIZE);
    4d74:	8c e7       	ldi	r24, 0x7C	; 124
    4d76:	92 e1       	ldi	r25, 0x12	; 18
    4d78:	61 eb       	ldi	r22, 0xB1	; 177
    4d7a:	7f e0       	ldi	r23, 0x0F	; 15
    4d7c:	40 e8       	ldi	r20, 0x80	; 128
    4d7e:	50 e0       	ldi	r21, 0x00	; 0
    4d80:	0e 94 ef 26 	call	0x4dde	; 0x4dde <bufferInit>
		bufferInit(&uartTxBuffer[0], (u08*) uart0TxData, UART0_TX_BUFFER_SIZE);
    4d84:	80 ea       	ldi	r24, 0xA0	; 160
    4d86:	92 e1       	ldi	r25, 0x12	; 18
    4d88:	61 e3       	ldi	r22, 0x31	; 49
    4d8a:	70 e1       	ldi	r23, 0x10	; 16
    4d8c:	40 e1       	ldi	r20, 0x10	; 16
    4d8e:	50 e0       	ldi	r21, 0x00	; 0
    4d90:	0e 94 ef 26 	call	0x4dde	; 0x4dde <bufferInit>
	#else
		// initialize the UART0 buffers
		bufferInit(&uartRxBuffer[0], (u08*) UART0_RX_BUFFER_ADDR, UART0_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[0], (u08*) UART0_TX_BUFFER_ADDR, UART0_TX_BUFFER_SIZE);
	#endif
}
    4d94:	08 95       	ret

00004d96 <uart0Init>:
}

void uart0Init(void)
{
	// initialize the buffers
	uart0InitBuffers();
    4d96:	0e 94 ba 26 	call	0x4d74	; 0x4d74 <uart0InitBuffers>
	// initialize user receive handlers
	UartRxFunc[0] = 0;
    4d9a:	10 92 f2 11 	sts	0x11F2, r1
    4d9e:	10 92 f1 11 	sts	0x11F1, r1
	// enable RxD/TxD and interrupts
	outb(UCSR0B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    4da2:	88 ed       	ldi	r24, 0xD8	; 216
    4da4:	80 93 c1 00 	sts	0x00C1, r24
	// set default baud rate
	uartSetBaudRate(0, UART0_DEFAULT_BAUD_RATE); 
    4da8:	80 e0       	ldi	r24, 0x00	; 0
    4daa:	40 e8       	ldi	r20, 0x80	; 128
    4dac:	55 e2       	ldi	r21, 0x25	; 37
    4dae:	60 e0       	ldi	r22, 0x00	; 0
    4db0:	70 e0       	ldi	r23, 0x00	; 0
    4db2:	0e 94 c0 22 	call	0x4580	; 0x4580 <uartSetBaudRate>
	// initialize states
	uartReadyTx[0] = TRUE;
    4db6:	8f ef       	ldi	r24, 0xFF	; 255
    4db8:	80 93 78 12 	sts	0x1278, r24
	uartBufferedTx[0] = FALSE;
    4dbc:	10 92 9c 12 	sts	0x129C, r1
	// clear overflow count
	uartRxOverflow[0] = 0;
    4dc0:	10 92 c1 12 	sts	0x12C1, r1
    4dc4:	10 92 c0 12 	sts	0x12C0, r1
	// enable interrupts
	sei();
    4dc8:	78 94       	sei
}
    4dca:	08 95       	ret

00004dcc <uartInit>:
volatile static voidFuncPtru08 UartRxFunc[4];

void uartInit(void)
{
	// initialize all uarts
	uart0Init();
    4dcc:	0e 94 cb 26 	call	0x4d96	; 0x4d96 <uart0Init>
	uart1Init();
    4dd0:	0e 94 9f 26 	call	0x4d3e	; 0x4d3e <uart1Init>
	uart2Init();
    4dd4:	0e 94 73 26 	call	0x4ce6	; 0x4ce6 <uart2Init>
	uart3Init();
    4dd8:	0e 94 47 26 	call	0x4c8e	; 0x4c8e <uart3Init>
}
    4ddc:	08 95       	ret

00004dde <bufferInit>:
// global variables

// initialization

void bufferInit(cBuffer* buffer, unsigned char *start, unsigned short size)
{
    4dde:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    4de0:	8f b7       	in	r24, 0x3f	; 63
    4de2:	f8 94       	cli
	// set start pointer of the buffer
	buffer->dataptr = start;
    4de4:	71 83       	std	Z+1, r23	; 0x01
    4de6:	60 83       	st	Z, r22
	buffer->size = size;
    4de8:	53 83       	std	Z+3, r21	; 0x03
    4dea:	42 83       	std	Z+2, r20	; 0x02
	// initialize index and length
	buffer->dataindex = 0;
    4dec:	17 82       	std	Z+7, r1	; 0x07
    4dee:	16 82       	std	Z+6, r1	; 0x06
	buffer->datalength = 0;
    4df0:	15 82       	std	Z+5, r1	; 0x05
    4df2:	14 82       	std	Z+4, r1	; 0x04
	// end critical section
	CRITICAL_SECTION_END;
    4df4:	8f bf       	out	0x3f, r24	; 63
}
    4df6:	08 95       	ret

00004df8 <bufferGetFromFront>:

// access routines
unsigned char  bufferGetFromFront(cBuffer* buffer)
{
    4df8:	dc 01       	movw	r26, r24
	unsigned char data = 0;
	// begin critical section
	CRITICAL_SECTION_START;
    4dfa:	4f b7       	in	r20, 0x3f	; 63
    4dfc:	f8 94       	cli
	// check to see if there's data in the buffer
	if(buffer->datalength)
    4dfe:	14 96       	adiw	r26, 0x04	; 4
    4e00:	8d 91       	ld	r24, X+
    4e02:	9c 91       	ld	r25, X
    4e04:	15 97       	sbiw	r26, 0x05	; 5
    4e06:	89 2b       	or	r24, r25
    4e08:	11 f4       	brne	.+4      	; 0x4e0e <bufferGetFromFront+0x16>
    4e0a:	e0 e0       	ldi	r30, 0x00	; 0
    4e0c:	25 c0       	rjmp	.+74     	; 0x4e58 <bufferGetFromFront+0x60>
	{
		// get the first character from buffer
		data = buffer->dataptr[buffer->dataindex];
    4e0e:	16 96       	adiw	r26, 0x06	; 6
    4e10:	8d 91       	ld	r24, X+
    4e12:	9c 91       	ld	r25, X
    4e14:	17 97       	sbiw	r26, 0x07	; 7
    4e16:	ed 91       	ld	r30, X+
    4e18:	fc 91       	ld	r31, X
    4e1a:	11 97       	sbiw	r26, 0x01	; 1
    4e1c:	e8 0f       	add	r30, r24
    4e1e:	f9 1f       	adc	r31, r25
    4e20:	e0 81       	ld	r30, Z
		// move index down and decrement length
		buffer->dataindex++;
    4e22:	01 96       	adiw	r24, 0x01	; 1
    4e24:	17 96       	adiw	r26, 0x07	; 7
    4e26:	9c 93       	st	X, r25
    4e28:	8e 93       	st	-X, r24
    4e2a:	16 97       	sbiw	r26, 0x06	; 6
		if(buffer->dataindex >= buffer->size)
    4e2c:	12 96       	adiw	r26, 0x02	; 2
    4e2e:	2d 91       	ld	r18, X+
    4e30:	3c 91       	ld	r19, X
    4e32:	13 97       	sbiw	r26, 0x03	; 3
    4e34:	82 17       	cp	r24, r18
    4e36:	93 07       	cpc	r25, r19
    4e38:	30 f0       	brcs	.+12     	; 0x4e46 <bufferGetFromFront+0x4e>
		{
			buffer->dataindex -= buffer->size;
    4e3a:	82 1b       	sub	r24, r18
    4e3c:	93 0b       	sbc	r25, r19
    4e3e:	17 96       	adiw	r26, 0x07	; 7
    4e40:	9c 93       	st	X, r25
    4e42:	8e 93       	st	-X, r24
    4e44:	16 97       	sbiw	r26, 0x06	; 6
		}
		buffer->datalength--;
    4e46:	14 96       	adiw	r26, 0x04	; 4
    4e48:	8d 91       	ld	r24, X+
    4e4a:	9c 91       	ld	r25, X
    4e4c:	15 97       	sbiw	r26, 0x05	; 5
    4e4e:	01 97       	sbiw	r24, 0x01	; 1
    4e50:	15 96       	adiw	r26, 0x05	; 5
    4e52:	9c 93       	st	X, r25
    4e54:	8e 93       	st	-X, r24
    4e56:	14 97       	sbiw	r26, 0x04	; 4
	}
	// end critical section
	CRITICAL_SECTION_END;
    4e58:	4f bf       	out	0x3f, r20	; 63
	// return
	return data;
}
    4e5a:	8e 2f       	mov	r24, r30
    4e5c:	08 95       	ret

00004e5e <bufferDumpFromFront>:

void bufferDumpFromFront(cBuffer* buffer, unsigned short numbytes)
{
    4e5e:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    4e60:	4f b7       	in	r20, 0x3f	; 63
    4e62:	f8 94       	cli
	// dump numbytes from the front of the buffer
	// are we dumping less than the entire buffer?
	if(numbytes < buffer->datalength)
    4e64:	84 81       	ldd	r24, Z+4	; 0x04
    4e66:	95 81       	ldd	r25, Z+5	; 0x05
    4e68:	68 17       	cp	r22, r24
    4e6a:	79 07       	cpc	r23, r25
    4e6c:	b0 f4       	brcc	.+44     	; 0x4e9a <bufferDumpFromFront+0x3c>
	{
		// move index down by numbytes and decrement length by numbytes
		buffer->dataindex += numbytes;
    4e6e:	86 81       	ldd	r24, Z+6	; 0x06
    4e70:	97 81       	ldd	r25, Z+7	; 0x07
    4e72:	86 0f       	add	r24, r22
    4e74:	97 1f       	adc	r25, r23
    4e76:	97 83       	std	Z+7, r25	; 0x07
    4e78:	86 83       	std	Z+6, r24	; 0x06
		if(buffer->dataindex >= buffer->size)
    4e7a:	22 81       	ldd	r18, Z+2	; 0x02
    4e7c:	33 81       	ldd	r19, Z+3	; 0x03
    4e7e:	82 17       	cp	r24, r18
    4e80:	93 07       	cpc	r25, r19
    4e82:	20 f0       	brcs	.+8      	; 0x4e8c <bufferDumpFromFront+0x2e>
		{
			buffer->dataindex -= buffer->size;
    4e84:	82 1b       	sub	r24, r18
    4e86:	93 0b       	sbc	r25, r19
    4e88:	97 83       	std	Z+7, r25	; 0x07
    4e8a:	86 83       	std	Z+6, r24	; 0x06
		}
		buffer->datalength -= numbytes;
    4e8c:	84 81       	ldd	r24, Z+4	; 0x04
    4e8e:	95 81       	ldd	r25, Z+5	; 0x05
    4e90:	86 1b       	sub	r24, r22
    4e92:	97 0b       	sbc	r25, r23
    4e94:	95 83       	std	Z+5, r25	; 0x05
    4e96:	84 83       	std	Z+4, r24	; 0x04
    4e98:	02 c0       	rjmp	.+4      	; 0x4e9e <bufferDumpFromFront+0x40>
	}
	else
	{
		// flush the whole buffer
		buffer->datalength = 0;
    4e9a:	15 82       	std	Z+5, r1	; 0x05
    4e9c:	14 82       	std	Z+4, r1	; 0x04
	}
	// end critical section
	CRITICAL_SECTION_END;
    4e9e:	4f bf       	out	0x3f, r20	; 63
}
    4ea0:	08 95       	ret

00004ea2 <bufferGetAtIndex>:

unsigned char bufferGetAtIndex(cBuffer* buffer, unsigned short index)
{
    4ea2:	fc 01       	movw	r30, r24
    4ea4:	cb 01       	movw	r24, r22
	// begin critical section
	CRITICAL_SECTION_START;
    4ea6:	2f b7       	in	r18, 0x3f	; 63
    4ea8:	f8 94       	cli
	// return character at index in buffer
	unsigned char data = buffer->dataptr[(buffer->dataindex+index)%(buffer->size)];
	// end critical section
	CRITICAL_SECTION_END;
    4eaa:	2f bf       	out	0x3f, r18	; 63
    4eac:	26 81       	ldd	r18, Z+6	; 0x06
    4eae:	37 81       	ldd	r19, Z+7	; 0x07
    4eb0:	62 81       	ldd	r22, Z+2	; 0x02
    4eb2:	73 81       	ldd	r23, Z+3	; 0x03
    4eb4:	82 0f       	add	r24, r18
    4eb6:	93 1f       	adc	r25, r19
    4eb8:	0e 94 c1 2f 	call	0x5f82	; 0x5f82 <__udivmodhi4>
    4ebc:	01 90       	ld	r0, Z+
    4ebe:	f0 81       	ld	r31, Z
    4ec0:	e0 2d       	mov	r30, r0
    4ec2:	e8 0f       	add	r30, r24
    4ec4:	f9 1f       	adc	r31, r25
	return data;
}
    4ec6:	80 81       	ld	r24, Z
    4ec8:	08 95       	ret

00004eca <bufferAddToEnd>:

unsigned char bufferAddToEnd(cBuffer* buffer, unsigned char data)
{
    4eca:	1f 93       	push	r17
    4ecc:	cf 93       	push	r28
    4ece:	df 93       	push	r29
    4ed0:	ec 01       	movw	r28, r24
    4ed2:	16 2f       	mov	r17, r22
	// begin critical section
	CRITICAL_SECTION_START;
    4ed4:	4f b7       	in	r20, 0x3f	; 63
    4ed6:	f8 94       	cli
	// make sure the buffer has room
	if(buffer->datalength < buffer->size)
    4ed8:	2c 81       	ldd	r18, Y+4	; 0x04
    4eda:	3d 81       	ldd	r19, Y+5	; 0x05
    4edc:	6a 81       	ldd	r22, Y+2	; 0x02
    4ede:	7b 81       	ldd	r23, Y+3	; 0x03
    4ee0:	26 17       	cp	r18, r22
    4ee2:	37 07       	cpc	r19, r23
    4ee4:	98 f4       	brcc	.+38     	; 0x4f0c <bufferAddToEnd+0x42>
	{
		// save data byte at end of buffer
		buffer->dataptr[(buffer->dataindex + buffer->datalength) % buffer->size] = data;
    4ee6:	8e 81       	ldd	r24, Y+6	; 0x06
    4ee8:	9f 81       	ldd	r25, Y+7	; 0x07
    4eea:	82 0f       	add	r24, r18
    4eec:	93 1f       	adc	r25, r19
    4eee:	0e 94 c1 2f 	call	0x5f82	; 0x5f82 <__udivmodhi4>
    4ef2:	e8 81       	ld	r30, Y
    4ef4:	f9 81       	ldd	r31, Y+1	; 0x01
    4ef6:	e8 0f       	add	r30, r24
    4ef8:	f9 1f       	adc	r31, r25
    4efa:	10 83       	st	Z, r17
		// increment the length
		buffer->datalength++;
    4efc:	8c 81       	ldd	r24, Y+4	; 0x04
    4efe:	9d 81       	ldd	r25, Y+5	; 0x05
    4f00:	01 96       	adiw	r24, 0x01	; 1
    4f02:	9d 83       	std	Y+5, r25	; 0x05
    4f04:	8c 83       	std	Y+4, r24	; 0x04
		// end critical section
		CRITICAL_SECTION_END;
    4f06:	4f bf       	out	0x3f, r20	; 63
    4f08:	8f ef       	ldi	r24, 0xFF	; 255
    4f0a:	02 c0       	rjmp	.+4      	; 0x4f10 <bufferAddToEnd+0x46>
		// return success
		return -1;
	}
	// end critical section
	CRITICAL_SECTION_END;
    4f0c:	4f bf       	out	0x3f, r20	; 63
    4f0e:	80 e0       	ldi	r24, 0x00	; 0
	// return failure
	return 0;
}
    4f10:	df 91       	pop	r29
    4f12:	cf 91       	pop	r28
    4f14:	1f 91       	pop	r17
    4f16:	08 95       	ret

00004f18 <bufferIsNotFull>:

unsigned short bufferIsNotFull(cBuffer* buffer)
{
    4f18:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    4f1a:	8f b7       	in	r24, 0x3f	; 63
    4f1c:	f8 94       	cli
	// check to see if the buffer has room
	// return true if there is room
	unsigned short bytesleft = (buffer->size - buffer->datalength);
	// end critical section
	CRITICAL_SECTION_END;
    4f1e:	8f bf       	out	0x3f, r24	; 63
    4f20:	22 81       	ldd	r18, Z+2	; 0x02
    4f22:	33 81       	ldd	r19, Z+3	; 0x03
    4f24:	84 81       	ldd	r24, Z+4	; 0x04
    4f26:	95 81       	ldd	r25, Z+5	; 0x05
    4f28:	28 1b       	sub	r18, r24
    4f2a:	39 0b       	sbc	r19, r25
	return bytesleft;
}
    4f2c:	c9 01       	movw	r24, r18
    4f2e:	08 95       	ret

00004f30 <bufferFlush>:

void bufferFlush(cBuffer* buffer)
{
    4f30:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    4f32:	8f b7       	in	r24, 0x3f	; 63
    4f34:	f8 94       	cli
	// flush contents of the buffer
	buffer->datalength = 0;
    4f36:	15 82       	std	Z+5, r1	; 0x05
    4f38:	14 82       	std	Z+4, r1	; 0x04
	// end critical section
	CRITICAL_SECTION_END;
    4f3a:	8f bf       	out	0x3f, r24	; 63
}
    4f3c:	08 95       	ret

00004f3e <a2dInit>:
// functions

// initialize a2d converter
void a2dInit(void)
{
	sbi(ADCSR, ADEN);				// enable ADC (turn on ADC power)
    4f3e:	aa e7       	ldi	r26, 0x7A	; 122
    4f40:	b0 e0       	ldi	r27, 0x00	; 0
    4f42:	8c 91       	ld	r24, X
    4f44:	80 68       	ori	r24, 0x80	; 128
    4f46:	8c 93       	st	X, r24
	cbi(ADCSR, ADFR);				// default to single sample convert mode
    4f48:	8c 91       	ld	r24, X
    4f4a:	8f 7d       	andi	r24, 0xDF	; 223
    4f4c:	8c 93       	st	X, r24
}

// configure A2D converter clock division (prescaling)
void a2dSetPrescaler(unsigned char prescale)
{
	outb(ADCSR, ((inb(ADCSR) & ~ADC_PRESCALE_MASK) | prescale));
    4f4e:	8c 91       	ld	r24, X
    4f50:	88 7f       	andi	r24, 0xF8	; 248
    4f52:	86 60       	ori	r24, 0x06	; 6
    4f54:	8c 93       	st	X, r24
}

// configure A2D converter voltage reference
void a2dSetReference(unsigned char ref)
{
	outb(ADMUX, ((inb(ADMUX) & ~ADC_REFERENCE_MASK) | (ref<<6)));
    4f56:	ec e7       	ldi	r30, 0x7C	; 124
    4f58:	f0 e0       	ldi	r31, 0x00	; 0
    4f5a:	80 81       	ld	r24, Z
    4f5c:	8f 73       	andi	r24, 0x3F	; 63
    4f5e:	80 64       	ori	r24, 0x40	; 64
    4f60:	80 83       	st	Z, r24
{
	sbi(ADCSR, ADEN);				// enable ADC (turn on ADC power)
	cbi(ADCSR, ADFR);				// default to single sample convert mode
	a2dSetPrescaler(ADC_PRESCALE);	// set default prescaler
	a2dSetReference(ADC_REFERENCE);	// set default reference
	cbi(ADMUX, ADLAR);				// set to right-adjusted result
    4f62:	80 81       	ld	r24, Z
    4f64:	8f 7d       	andi	r24, 0xDF	; 223
    4f66:	80 83       	st	Z, r24

	sbi(ADCSR, ADIE);				// enable ADC interrupts
    4f68:	8c 91       	ld	r24, X
    4f6a:	88 60       	ori	r24, 0x08	; 8
    4f6c:	8c 93       	st	X, r24

	a2dCompleteFlag = FALSE;		// clear conversion complete flag
    4f6e:	10 92 c8 12 	sts	0x12C8, r1
	sei();							// turn on interrupts (if not already on)
    4f72:	78 94       	sei
}
    4f74:	08 95       	ret

00004f76 <a2dOff>:

// turn off a2d converter
void a2dOff(void)
{
	cbi(ADCSR, ADIE);				// disable ADC interrupts
    4f76:	ea e7       	ldi	r30, 0x7A	; 122
    4f78:	f0 e0       	ldi	r31, 0x00	; 0
    4f7a:	80 81       	ld	r24, Z
    4f7c:	87 7f       	andi	r24, 0xF7	; 247
    4f7e:	80 83       	st	Z, r24
	cbi(ADCSR, ADEN);				// disable ADC (turn off ADC power)
    4f80:	80 81       	ld	r24, Z
    4f82:	8f 77       	andi	r24, 0x7F	; 127
    4f84:	80 83       	st	Z, r24
}
    4f86:	08 95       	ret

00004f88 <a2dSetPrescaler>:

// configure A2D converter clock division (prescaling)
void a2dSetPrescaler(unsigned char prescale)
{
	outb(ADCSR, ((inb(ADCSR) & ~ADC_PRESCALE_MASK) | prescale));
    4f88:	ea e7       	ldi	r30, 0x7A	; 122
    4f8a:	f0 e0       	ldi	r31, 0x00	; 0
    4f8c:	90 81       	ld	r25, Z
    4f8e:	98 7f       	andi	r25, 0xF8	; 248
    4f90:	98 2b       	or	r25, r24
    4f92:	90 83       	st	Z, r25
}
    4f94:	08 95       	ret

00004f96 <a2dSetReference>:

// configure A2D converter voltage reference
void a2dSetReference(unsigned char ref)
{
	outb(ADMUX, ((inb(ADMUX) & ~ADC_REFERENCE_MASK) | (ref<<6)));
    4f96:	ec e7       	ldi	r30, 0x7C	; 124
    4f98:	f0 e0       	ldi	r31, 0x00	; 0
    4f9a:	90 81       	ld	r25, Z
    4f9c:	82 95       	swap	r24
    4f9e:	88 0f       	add	r24, r24
    4fa0:	88 0f       	add	r24, r24
    4fa2:	80 7c       	andi	r24, 0xC0	; 192
    4fa4:	9f 73       	andi	r25, 0x3F	; 63
    4fa6:	98 2b       	or	r25, r24
    4fa8:	90 83       	st	Z, r25
}
    4faa:	08 95       	ret

00004fac <a2dSetChannel>:

// sets the a2d input channel
void a2dSetChannel(unsigned char ch)
{
	outb(ADMUX, (inb(ADMUX) & ~ADC_MUX_MASK) | (ch & ADC_MUX_MASK));	// set channel
    4fac:	ec e7       	ldi	r30, 0x7C	; 124
    4fae:	f0 e0       	ldi	r31, 0x00	; 0
    4fb0:	90 81       	ld	r25, Z
    4fb2:	8f 71       	andi	r24, 0x1F	; 31
    4fb4:	90 7e       	andi	r25, 0xE0	; 224
    4fb6:	89 2b       	or	r24, r25
    4fb8:	80 83       	st	Z, r24
}
    4fba:	08 95       	ret

00004fbc <a2dStartConvert>:

// start a conversion on the current a2d input channel
void a2dStartConvert(void)
{
	sbi(ADCSR, ADIF);	// clear hardware "conversion complete" flag 
    4fbc:	ea e7       	ldi	r30, 0x7A	; 122
    4fbe:	f0 e0       	ldi	r31, 0x00	; 0
    4fc0:	80 81       	ld	r24, Z
    4fc2:	80 61       	ori	r24, 0x10	; 16
    4fc4:	80 83       	st	Z, r24
	sbi(ADCSR, ADSC);	// start conversion
    4fc6:	80 81       	ld	r24, Z
    4fc8:	80 64       	ori	r24, 0x40	; 64
    4fca:	80 83       	st	Z, r24
}
    4fcc:	08 95       	ret

00004fce <a2dIsComplete>:

// return TRUE if conversion is complete
u08 a2dIsComplete(void)
{
	return bit_is_set(ADCSR, ADSC);
    4fce:	80 91 7a 00 	lds	r24, 0x007A
}
    4fd2:	80 74       	andi	r24, 0x40	; 64
    4fd4:	08 95       	ret

00004fd6 <a2dConvert10bit>:

// Perform a 10-bit conversion
// starts conversion, waits until conversion is done, and returns result
unsigned short a2dConvert10bit(unsigned char ch)
{
    4fd6:	98 2f       	mov	r25, r24
	a2dCompleteFlag = FALSE;				// clear conversion complete flag
    4fd8:	10 92 c8 12 	sts	0x12C8, r1

if (ch >= 8)
    4fdc:	88 30       	cpi	r24, 0x08	; 8
    4fde:	20 f0       	brcs	.+8      	; 0x4fe8 <a2dConvert10bit+0x12>
    ADCSRB |= _BV(MUX5);
    4fe0:	80 91 7b 00 	lds	r24, 0x007B
    4fe4:	88 60       	ori	r24, 0x08	; 8
    4fe6:	03 c0       	rjmp	.+6      	; 0x4fee <a2dConvert10bit+0x18>
else
    ADCSRB &= ~_BV(MUX5);
    4fe8:	80 91 7b 00 	lds	r24, 0x007B
    4fec:	87 7f       	andi	r24, 0xF7	; 247
    4fee:	80 93 7b 00 	sts	0x007B, r24

   outb(ADMUX, (inb(ADMUX) & ~7) | (ch & 7));   // set channel
    4ff2:	80 91 7c 00 	lds	r24, 0x007C
    4ff6:	97 70       	andi	r25, 0x07	; 7
    4ff8:	88 7f       	andi	r24, 0xF8	; 248
    4ffa:	89 2b       	or	r24, r25
    4ffc:	80 93 7c 00 	sts	0x007C, r24

	//outb(ADMUX, (inb(ADMUX) & ~ADC_MUX_MASK) | (ch & ADC_MUX_MASK));	// set channel
	sbi(ADCSR, ADIF);						// clear hardware "conversion complete" flag 
    5000:	80 91 7a 00 	lds	r24, 0x007A
    5004:	80 61       	ori	r24, 0x10	; 16
    5006:	80 93 7a 00 	sts	0x007A, r24
	sbi(ADCSR, ADSC);						// start conversion
    500a:	80 91 7a 00 	lds	r24, 0x007A
    500e:	80 64       	ori	r24, 0x40	; 64
    5010:	80 93 7a 00 	sts	0x007A, r24
	//while(!a2dCompleteFlag);				// wait until conversion complete
	//while( bit_is_clear(ADCSR, ADIF) );		// wait until conversion complete
	while( bit_is_set(ADCSR, ADSC) );		// wait until conversion complete
    5014:	80 91 7a 00 	lds	r24, 0x007A
    5018:	86 fd       	sbrc	r24, 6
    501a:	fc cf       	rjmp	.-8      	; 0x5014 <a2dConvert10bit+0x3e>

	// CAUTION: MUST READ ADCL BEFORE ADCH!!!
	//return (inb(ADCL) | (inb(ADCH)<<8));	// read ADC (full 10 bits) //old version
	return ADC;//new version code
    501c:	20 91 78 00 	lds	r18, 0x0078
    5020:	30 91 79 00 	lds	r19, 0x0079
}
    5024:	c9 01       	movw	r24, r18
    5026:	08 95       	ret

00005028 <a2dConvert8bit>:
// Perform a 8-bit conversion.
// starts conversion, waits until conversion is done, and returns result
unsigned char a2dConvert8bit(unsigned char ch)
{
	// do 10-bit conversion and return highest 8 bits
	return a2dConvert10bit(ch)>>2;			// return ADC MSB byte
    5028:	0e 94 eb 27 	call	0x4fd6	; 0x4fd6 <a2dConvert10bit>
    502c:	96 95       	lsr	r25
    502e:	87 95       	ror	r24
    5030:	96 95       	lsr	r25
    5032:	87 95       	ror	r24
}
    5034:	08 95       	ret

00005036 <__vector_29>:

//! Interrupt handler for ADC complete interrupt.
SIGNAL(SIG_ADC)
{
    5036:	1f 92       	push	r1
    5038:	0f 92       	push	r0
    503a:	0f b6       	in	r0, 0x3f	; 63
    503c:	0f 92       	push	r0
    503e:	11 24       	eor	r1, r1
    5040:	8f 93       	push	r24
	// set the a2d conversion flag to indicate "complete"
	a2dCompleteFlag = TRUE;
    5042:	8f ef       	ldi	r24, 0xFF	; 255
    5044:	80 93 c8 12 	sts	0x12C8, r24
}
    5048:	8f 91       	pop	r24
    504a:	0f 90       	pop	r0
    504c:	0f be       	out	0x3f, r0	; 63
    504e:	0f 90       	pop	r0
    5050:	1f 90       	pop	r1
    5052:	18 95       	reti

00005054 <rprintfInit>:
// *** rprintf initialization ***
// you must call this function once and supply the character output
// routine before using other functions in this library
void rprintfInit(void (*putchar_func)(unsigned char c))
{
	rputchar = putchar_func;
    5054:	90 93 fa 11 	sts	0x11FA, r25
    5058:	80 93 f9 11 	sts	0x11F9, r24
}
    505c:	08 95       	ret

0000505e <rprintfChar>:

// *** rprintfChar ***
// send a character/byte to the current output device
void rprintfChar(unsigned char c)
{
    505e:	1f 93       	push	r17
    5060:	18 2f       	mov	r17, r24
	// do LF -> CR/LF translation
	if(c == '\n')
    5062:	8a 30       	cpi	r24, 0x0A	; 10
    5064:	31 f4       	brne	.+12     	; 0x5072 <rprintfChar+0x14>
		rputchar('\r');
    5066:	e0 91 f9 11 	lds	r30, 0x11F9
    506a:	f0 91 fa 11 	lds	r31, 0x11FA
    506e:	8d e0       	ldi	r24, 0x0D	; 13
    5070:	09 95       	icall
	// send character
	rputchar(c);
    5072:	e0 91 f9 11 	lds	r30, 0x11F9
    5076:	f0 91 fa 11 	lds	r31, 0x11FA
    507a:	81 2f       	mov	r24, r17
    507c:	09 95       	icall
}
    507e:	1f 91       	pop	r17
    5080:	08 95       	ret

00005082 <rprintfStr>:

// *** rprintfStr ***
// prints a null-terminated string stored in RAM
void rprintfStr(char str[])
{
    5082:	cf 93       	push	r28
    5084:	df 93       	push	r29
    5086:	ec 01       	movw	r28, r24
	// send a string stored in RAM
	// check to make sure we have a good pointer
	if (!str) return;
    5088:	00 97       	sbiw	r24, 0x00	; 0
    508a:	21 f4       	brne	.+8      	; 0x5094 <rprintfStr+0x12>
    508c:	06 c0       	rjmp	.+12     	; 0x509a <rprintfStr+0x18>

	// print the string until a null-terminator
	while (*str)
		rprintfChar(*str++);
    508e:	21 96       	adiw	r28, 0x01	; 1
    5090:	0e 94 2f 28 	call	0x505e	; 0x505e <rprintfChar>
	// send a string stored in RAM
	// check to make sure we have a good pointer
	if (!str) return;

	// print the string until a null-terminator
	while (*str)
    5094:	88 81       	ld	r24, Y
    5096:	88 23       	and	r24, r24
    5098:	d1 f7       	brne	.-12     	; 0x508e <rprintfStr+0xc>
		rprintfChar(*str++);
}
    509a:	df 91       	pop	r29
    509c:	cf 91       	pop	r28
    509e:	08 95       	ret

000050a0 <rprintfStrLen>:
// *** rprintfStrLen ***
// prints a section of a string stored in RAM
// begins printing at position indicated by <start>
// prints number of characters indicated by <len>
void rprintfStrLen(char str[], unsigned int start, unsigned int len)
{
    50a0:	ef 92       	push	r14
    50a2:	ff 92       	push	r15
    50a4:	0f 93       	push	r16
    50a6:	1f 93       	push	r17
    50a8:	cf 93       	push	r28
    50aa:	df 93       	push	r29
    50ac:	8c 01       	movw	r16, r24
    50ae:	7a 01       	movw	r14, r20
	register int i=0;

	// check to make sure we have a good pointer
	if (!str) return;
    50b0:	00 97       	sbiw	r24, 0x00	; 0
    50b2:	e9 f0       	breq	.+58     	; 0x50ee <rprintfStrLen+0x4e>
    50b4:	20 e0       	ldi	r18, 0x00	; 0
    50b6:	30 e0       	ldi	r19, 0x00	; 0
	// spin through characters up to requested start
	// keep going as long as there's no null
	while((i++<start) && (*str++));
    50b8:	26 17       	cp	r18, r22
    50ba:	37 07       	cpc	r19, r23
    50bc:	38 f4       	brcc	.+14     	; 0x50cc <rprintfStrLen+0x2c>
    50be:	f8 01       	movw	r30, r16
    50c0:	81 91       	ld	r24, Z+
    50c2:	8f 01       	movw	r16, r30
    50c4:	2f 5f       	subi	r18, 0xFF	; 255
    50c6:	3f 4f       	sbci	r19, 0xFF	; 255
    50c8:	88 23       	and	r24, r24
    50ca:	b1 f7       	brne	.-20     	; 0x50b8 <rprintfStrLen+0x18>
    50cc:	c0 e0       	ldi	r28, 0x00	; 0
    50ce:	d0 e0       	ldi	r29, 0x00	; 0
    50d0:	0b c0       	rjmp	.+22     	; 0x50e8 <rprintfStrLen+0x48>
	// then print exactly len characters
	for(i=0; i<len; i++)
	{
		// print data out of the string as long as we haven't reached a null yet
		// at the null, start printing spaces
		if(*str)
    50d2:	f8 01       	movw	r30, r16
    50d4:	80 81       	ld	r24, Z
    50d6:	88 23       	and	r24, r24
    50d8:	19 f0       	breq	.+6      	; 0x50e0 <rprintfStrLen+0x40>
			rprintfChar(*str++);
    50da:	0f 5f       	subi	r16, 0xFF	; 255
    50dc:	1f 4f       	sbci	r17, 0xFF	; 255
    50de:	01 c0       	rjmp	.+2      	; 0x50e2 <rprintfStrLen+0x42>
		else
			rprintfChar(' ');
    50e0:	80 e2       	ldi	r24, 0x20	; 32
    50e2:	0e 94 2f 28 	call	0x505e	; 0x505e <rprintfChar>
//		// keep steping through string as long as there's no null
//		if(*str) str++;
//	}

	// then print exactly len characters
	for(i=0; i<len; i++)
    50e6:	21 96       	adiw	r28, 0x01	; 1
    50e8:	ce 15       	cp	r28, r14
    50ea:	df 05       	cpc	r29, r15
    50ec:	90 f3       	brcs	.-28     	; 0x50d2 <rprintfStrLen+0x32>
			rprintfChar(*str++);
		else
			rprintfChar(' ');
	}

}
    50ee:	df 91       	pop	r29
    50f0:	cf 91       	pop	r28
    50f2:	1f 91       	pop	r17
    50f4:	0f 91       	pop	r16
    50f6:	ff 90       	pop	r15
    50f8:	ef 90       	pop	r14
    50fa:	08 95       	ret

000050fc <rprintfProgStr>:

// *** rprintfProgStr ***
// prints a null-terminated string stored in program ROM
void rprintfProgStr(const prog_char str[])
{
    50fc:	cf 93       	push	r28
    50fe:	df 93       	push	r29
    5100:	ec 01       	movw	r28, r24
	// print a string stored in program memory
	register char c;

	// check to make sure we have a good pointer
	if (!str) return;
    5102:	00 97       	sbiw	r24, 0x00	; 0
    5104:	19 f4       	brne	.+6      	; 0x510c <rprintfProgStr+0x10>
    5106:	07 c0       	rjmp	.+14     	; 0x5116 <rprintfProgStr+0x1a>
	
	// print the string until the null-terminator
	while((c = pgm_read_byte(str++)))
		rprintfChar(c);
    5108:	0e 94 2f 28 	call	0x505e	; 0x505e <rprintfChar>
    510c:	fe 01       	movw	r30, r28

	// check to make sure we have a good pointer
	if (!str) return;
	
	// print the string until the null-terminator
	while((c = pgm_read_byte(str++)))
    510e:	21 96       	adiw	r28, 0x01	; 1
    5110:	84 91       	lpm	r24, Z+
    5112:	88 23       	and	r24, r24
    5114:	c9 f7       	brne	.-14     	; 0x5108 <rprintfProgStr+0xc>
		rprintfChar(c);
}
    5116:	df 91       	pop	r29
    5118:	cf 91       	pop	r28
    511a:	08 95       	ret

0000511c <rprintfCRLF>:
void rprintfCRLF(void)
{
	// print CR/LF
	//rprintfChar('\r');
	// LF -> CR/LF translation built-in to rprintfChar()
	rprintfChar('\n');
    511c:	8a e0       	ldi	r24, 0x0A	; 10
    511e:	0e 94 2f 28 	call	0x505e	; 0x505e <rprintfChar>
}
    5122:	08 95       	ret

00005124 <rprintfu04>:
//	char Character = data&0x0f;
//	if (Character>9)
//		Character+='A'-10;
//	else
//		Character+='0';
	rprintfChar(hexchar(data));
    5124:	e8 2f       	mov	r30, r24
    5126:	f0 e0       	ldi	r31, 0x00	; 0
    5128:	ef 70       	andi	r30, 0x0F	; 15
    512a:	f0 70       	andi	r31, 0x00	; 0
    512c:	ef 51       	subi	r30, 0x1F	; 31
    512e:	fe 4f       	sbci	r31, 0xFE	; 254
    5130:	e4 91       	lpm	r30, Z+
    5132:	8e 2f       	mov	r24, r30
    5134:	0e 94 2f 28 	call	0x505e	; 0x505e <rprintfChar>
}
    5138:	08 95       	ret

0000513a <rprintfu08>:

// *** rprintfu08 ***
// prints an unsigned 8-bit number in hex (2 digits)
void rprintfu08(unsigned char data)
{
    513a:	1f 93       	push	r17
    513c:	18 2f       	mov	r17, r24
	// print 8-bit hex value
	rprintfu04(data>>4);
    513e:	82 95       	swap	r24
    5140:	8f 70       	andi	r24, 0x0F	; 15
    5142:	0e 94 92 28 	call	0x5124	; 0x5124 <rprintfu04>
	rprintfu04(data);
    5146:	81 2f       	mov	r24, r17
    5148:	0e 94 92 28 	call	0x5124	; 0x5124 <rprintfu04>
}
    514c:	1f 91       	pop	r17
    514e:	08 95       	ret

00005150 <rprintfu16>:

// *** rprintfu16 ***
// prints an unsigned 16-bit number in hex (4 digits)
void rprintfu16(unsigned short data)
{
    5150:	1f 93       	push	r17
    5152:	18 2f       	mov	r17, r24
	// print 16-bit hex value
	rprintfu08(data>>8);
    5154:	89 2f       	mov	r24, r25
    5156:	0e 94 9d 28 	call	0x513a	; 0x513a <rprintfu08>
	rprintfu08(data);
    515a:	81 2f       	mov	r24, r17
    515c:	0e 94 9d 28 	call	0x513a	; 0x513a <rprintfu08>
}
    5160:	1f 91       	pop	r17
    5162:	08 95       	ret

00005164 <rprintfu32>:

// *** rprintfu32 ***
// prints an unsigned 32-bit number in hex (8 digits)
void rprintfu32(unsigned long data)
{
    5164:	ef 92       	push	r14
    5166:	ff 92       	push	r15
    5168:	0f 93       	push	r16
    516a:	1f 93       	push	r17
    516c:	7b 01       	movw	r14, r22
    516e:	8c 01       	movw	r16, r24
	// print 32-bit hex value
	rprintfu16(data>>16);
    5170:	c8 01       	movw	r24, r16
    5172:	aa 27       	eor	r26, r26
    5174:	bb 27       	eor	r27, r27
    5176:	0e 94 a8 28 	call	0x5150	; 0x5150 <rprintfu16>
	rprintfu16(data);
    517a:	c7 01       	movw	r24, r14
    517c:	0e 94 a8 28 	call	0x5150	; 0x5150 <rprintfu16>
}
    5180:	1f 91       	pop	r17
    5182:	0f 91       	pop	r16
    5184:	ff 90       	pop	r15
    5186:	ef 90       	pop	r14
    5188:	08 95       	ret

0000518a <rprintfNum>:
//	Examples:
//	uartPrintfNum(10, 6,  TRUE, ' ',   1234);  -->  " +1234"
//	uartPrintfNum(10, 6, FALSE, '0',   1234);  -->  "001234"
//	uartPrintfNum(16, 6, FALSE, '.', 0x5AA5);  -->  "..5AA5"
void rprintfNum(char base, char numDigits, char isSigned, char padchar, long n)
{
    518a:	2f 92       	push	r2
    518c:	3f 92       	push	r3
    518e:	4f 92       	push	r4
    5190:	5f 92       	push	r5
    5192:	6f 92       	push	r6
    5194:	7f 92       	push	r7
    5196:	8f 92       	push	r8
    5198:	9f 92       	push	r9
    519a:	af 92       	push	r10
    519c:	bf 92       	push	r11
    519e:	cf 92       	push	r12
    51a0:	df 92       	push	r13
    51a2:	ef 92       	push	r14
    51a4:	ff 92       	push	r15
    51a6:	0f 93       	push	r16
    51a8:	1f 93       	push	r17
    51aa:	df 93       	push	r29
    51ac:	cf 93       	push	r28
    51ae:	cd b7       	in	r28, 0x3d	; 61
    51b0:	de b7       	in	r29, 0x3e	; 62
    51b2:	a3 97       	sbiw	r28, 0x23	; 35
    51b4:	0f b6       	in	r0, 0x3f	; 63
    51b6:	f8 94       	cli
    51b8:	de bf       	out	0x3e, r29	; 62
    51ba:	0f be       	out	0x3f, r0	; 63
    51bc:	cd bf       	out	0x3d, r28	; 61
    51be:	6a a3       	std	Y+34, r22	; 0x22
    51c0:	24 2e       	mov	r2, r20
    51c2:	2b a3       	std	Y+35, r18	; 0x23
    51c4:	37 01       	movw	r6, r14
    51c6:	48 01       	movw	r8, r16
	char *p, buf[32];
	unsigned long x;
	unsigned char count;

	// prepare negative number
	if( isSigned && (n < 0) )
    51c8:	44 23       	and	r20, r20
    51ca:	51 f0       	breq	.+20     	; 0x51e0 <rprintfNum+0x56>
    51cc:	17 ff       	sbrs	r17, 7
    51ce:	08 c0       	rjmp	.+16     	; 0x51e0 <rprintfNum+0x56>
	{
		x = -n;
    51d0:	ee 24       	eor	r14, r14
    51d2:	ff 24       	eor	r15, r15
    51d4:	87 01       	movw	r16, r14
    51d6:	e6 18       	sub	r14, r6
    51d8:	f7 08       	sbc	r15, r7
    51da:	08 09       	sbc	r16, r8
    51dc:	19 09       	sbc	r17, r9
    51de:	02 c0       	rjmp	.+4      	; 0x51e4 <rprintfNum+0x5a>
	}
	else
	{
	 	x = n;
    51e0:	84 01       	movw	r16, r8
    51e2:	73 01       	movw	r14, r6
	}

	// setup little string buffer
	count = (numDigits-1)-(isSigned?1:0);
    51e4:	2a a1       	ldd	r18, Y+34	; 0x22
    51e6:	21 50       	subi	r18, 0x01	; 1
    51e8:	90 e0       	ldi	r25, 0x00	; 0
    51ea:	21 10       	cpse	r2, r1
    51ec:	91 e0       	ldi	r25, 0x01	; 1
    51ee:	29 1b       	sub	r18, r25
    51f0:	29 a3       	std	Y+33, r18	; 0x21
  	p = buf + sizeof (buf);
  	*--p = '\0';
    51f2:	18 a2       	std	Y+32, r1	; 0x20
	
	// force calculation of first digit
	// (to prevent zero from not printing at all!!!)
	*--p = hexchar(x%base); x /= base;
    51f4:	a8 2e       	mov	r10, r24
    51f6:	bb 24       	eor	r11, r11
    51f8:	cc 24       	eor	r12, r12
    51fa:	dd 24       	eor	r13, r13
    51fc:	c8 01       	movw	r24, r16
    51fe:	b7 01       	movw	r22, r14
    5200:	a6 01       	movw	r20, r12
    5202:	95 01       	movw	r18, r10
    5204:	0e 94 e8 2f 	call	0x5fd0	; 0x5fd0 <__udivmodsi4>
    5208:	fb 01       	movw	r30, r22
    520a:	ef 70       	andi	r30, 0x0F	; 15
    520c:	f0 70       	andi	r31, 0x00	; 0
    520e:	ef 51       	subi	r30, 0x1F	; 31
    5210:	fe 4f       	sbci	r31, 0xFE	; 254
    5212:	64 91       	lpm	r22, Z+
    5214:	6f 8f       	std	Y+31, r22	; 0x1f
    5216:	c8 01       	movw	r24, r16
    5218:	b7 01       	movw	r22, r14
    521a:	a6 01       	movw	r20, r12
    521c:	95 01       	movw	r18, r10
    521e:	0e 94 e8 2f 	call	0x5fd0	; 0x5fd0 <__udivmodsi4>
    5222:	c9 01       	movw	r24, r18
    5224:	da 01       	movw	r26, r20
    5226:	7c 01       	movw	r14, r24
    5228:	8d 01       	movw	r16, r26
    522a:	9e e1       	ldi	r25, 0x1E	; 30
    522c:	49 2e       	mov	r4, r25
    522e:	51 2c       	mov	r5, r1
    5230:	4c 0e       	add	r4, r28
    5232:	5d 1e       	adc	r5, r29
    5234:	39 a0       	ldd	r3, Y+33	; 0x21
    5236:	25 c0       	rjmp	.+74     	; 0x5282 <rprintfNum+0xf8>
	// calculate remaining digits
	while(count--)
	{
		if(x != 0)
    5238:	e1 14       	cp	r14, r1
    523a:	f1 04       	cpc	r15, r1
    523c:	01 05       	cpc	r16, r1
    523e:	11 05       	cpc	r17, r1
    5240:	c9 f0       	breq	.+50     	; 0x5274 <rprintfNum+0xea>
		{
			// calculate next digit
			*--p = hexchar(x%base); x /= base;
    5242:	c8 01       	movw	r24, r16
    5244:	b7 01       	movw	r22, r14
    5246:	a6 01       	movw	r20, r12
    5248:	95 01       	movw	r18, r10
    524a:	0e 94 e8 2f 	call	0x5fd0	; 0x5fd0 <__udivmodsi4>
    524e:	fb 01       	movw	r30, r22
    5250:	ef 70       	andi	r30, 0x0F	; 15
    5252:	f0 70       	andi	r31, 0x00	; 0
    5254:	ef 51       	subi	r30, 0x1F	; 31
    5256:	fe 4f       	sbci	r31, 0xFE	; 254
    5258:	64 91       	lpm	r22, Z+
    525a:	f2 01       	movw	r30, r4
    525c:	60 83       	st	Z, r22
    525e:	c8 01       	movw	r24, r16
    5260:	b7 01       	movw	r22, r14
    5262:	a6 01       	movw	r20, r12
    5264:	95 01       	movw	r18, r10
    5266:	0e 94 e8 2f 	call	0x5fd0	; 0x5fd0 <__udivmodsi4>
    526a:	c9 01       	movw	r24, r18
    526c:	da 01       	movw	r26, r20
    526e:	7c 01       	movw	r14, r24
    5270:	8d 01       	movw	r16, r26
    5272:	03 c0       	rjmp	.+6      	; 0x527a <rprintfNum+0xf0>
		}
		else
		{
			// no more digits left, pad out to desired length
			*--p = padchar;
    5274:	2b a1       	ldd	r18, Y+35	; 0x23
    5276:	f2 01       	movw	r30, r4
    5278:	20 83       	st	Z, r18
    527a:	3a 94       	dec	r3
    527c:	08 94       	sec
    527e:	41 08       	sbc	r4, r1
    5280:	51 08       	sbc	r5, r1
	
	// force calculation of first digit
	// (to prevent zero from not printing at all!!!)
	*--p = hexchar(x%base); x /= base;
	// calculate remaining digits
	while(count--)
    5282:	33 20       	and	r3, r3
    5284:	c9 f6       	brne	.-78     	; 0x5238 <rprintfNum+0xae>
    5286:	ce 01       	movw	r24, r28
    5288:	4f 96       	adiw	r24, 0x1f	; 31
    528a:	8c 01       	movw	r16, r24
    528c:	e9 a1       	ldd	r30, Y+33	; 0x21
    528e:	0e 1b       	sub	r16, r30
    5290:	11 09       	sbc	r17, r1
			*--p = padchar;
		}
	}

	// apply signed notation if requested
	if( isSigned )
    5292:	22 20       	and	r2, r2
    5294:	f1 f0       	breq	.+60     	; 0x52d2 <rprintfNum+0x148>
	{
		if(n < 0)
    5296:	97 fe       	sbrs	r9, 7
    5298:	05 c0       	rjmp	.+10     	; 0x52a4 <rprintfNum+0x11a>
		{
   			*--p = '-';
    529a:	8d e2       	ldi	r24, 0x2D	; 45
    529c:	f8 01       	movw	r30, r16
    529e:	82 93       	st	-Z, r24
    52a0:	8f 01       	movw	r16, r30
    52a2:	17 c0       	rjmp	.+46     	; 0x52d2 <rprintfNum+0x148>
    52a4:	c8 01       	movw	r24, r16
    52a6:	01 97       	sbiw	r24, 0x01	; 1
		}
		else if(n > 0)
    52a8:	61 14       	cp	r6, r1
    52aa:	71 04       	cpc	r7, r1
    52ac:	81 04       	cpc	r8, r1
    52ae:	91 04       	cpc	r9, r1
    52b0:	19 f0       	breq	.+6      	; 0x52b8 <rprintfNum+0x12e>
		{
	   		*--p = '+';
    52b2:	8c 01       	movw	r16, r24
    52b4:	8b e2       	ldi	r24, 0x2B	; 43
    52b6:	02 c0       	rjmp	.+4      	; 0x52bc <rprintfNum+0x132>
		}
		else
		{
	   		*--p = ' ';
    52b8:	8c 01       	movw	r16, r24
    52ba:	80 e2       	ldi	r24, 0x20	; 32
    52bc:	f8 01       	movw	r30, r16
    52be:	80 83       	st	Z, r24
    52c0:	08 c0       	rjmp	.+16     	; 0x52d2 <rprintfNum+0x148>

	// print the string right-justified
	count = numDigits;
	while(count--)
	{
		rprintfChar(*p++);
    52c2:	f8 01       	movw	r30, r16
    52c4:	81 91       	ld	r24, Z+
    52c6:	8f 01       	movw	r16, r30
    52c8:	0e 94 2f 28 	call	0x505e	; 0x505e <rprintfChar>
    52cc:	fa a1       	ldd	r31, Y+34	; 0x22
    52ce:	f1 50       	subi	r31, 0x01	; 1
    52d0:	fa a3       	std	Y+34, r31	; 0x22
		}
	}

	// print the string right-justified
	count = numDigits;
	while(count--)
    52d2:	2a a1       	ldd	r18, Y+34	; 0x22
    52d4:	22 23       	and	r18, r18
    52d6:	a9 f7       	brne	.-22     	; 0x52c2 <rprintfNum+0x138>
	{
		rprintfChar(*p++);
	}
}
    52d8:	a3 96       	adiw	r28, 0x23	; 35
    52da:	0f b6       	in	r0, 0x3f	; 63
    52dc:	f8 94       	cli
    52de:	de bf       	out	0x3e, r29	; 62
    52e0:	0f be       	out	0x3f, r0	; 63
    52e2:	cd bf       	out	0x3d, r28	; 61
    52e4:	cf 91       	pop	r28
    52e6:	df 91       	pop	r29
    52e8:	1f 91       	pop	r17
    52ea:	0f 91       	pop	r16
    52ec:	ff 90       	pop	r15
    52ee:	ef 90       	pop	r14
    52f0:	df 90       	pop	r13
    52f2:	cf 90       	pop	r12
    52f4:	bf 90       	pop	r11
    52f6:	af 90       	pop	r10
    52f8:	9f 90       	pop	r9
    52fa:	8f 90       	pop	r8
    52fc:	7f 90       	pop	r7
    52fe:	6f 90       	pop	r6
    5300:	5f 90       	pop	r5
    5302:	4f 90       	pop	r4
    5304:	3f 90       	pop	r3
    5306:	2f 90       	pop	r2
    5308:	08 95       	ret

0000530a <rprintfFloat>:

#ifdef RPRINTF_FLOAT
// *** rprintfFloat ***
// floating-point print
void rprintfFloat(char numDigits, double x)
{
    530a:	4f 92       	push	r4
    530c:	5f 92       	push	r5
    530e:	6f 92       	push	r6
    5310:	7f 92       	push	r7
    5312:	8f 92       	push	r8
    5314:	9f 92       	push	r9
    5316:	af 92       	push	r10
    5318:	bf 92       	push	r11
    531a:	cf 92       	push	r12
    531c:	df 92       	push	r13
    531e:	ef 92       	push	r14
    5320:	ff 92       	push	r15
    5322:	0f 93       	push	r16
    5324:	1f 93       	push	r17
    5326:	cf 93       	push	r28
    5328:	df 93       	push	r29
    532a:	48 2e       	mov	r4, r24
    532c:	5a 01       	movw	r10, r20
    532e:	6b 01       	movw	r12, r22
	double place = 1.0;
	
	// save sign
	negative = (x<0);
	// convert to absolute value
	x = (x>0)?(x):(-x);
    5330:	cb 01       	movw	r24, r22
    5332:	ba 01       	movw	r22, r20
    5334:	20 e0       	ldi	r18, 0x00	; 0
    5336:	30 e0       	ldi	r19, 0x00	; 0
    5338:	40 e0       	ldi	r20, 0x00	; 0
    533a:	50 e0       	ldi	r21, 0x00	; 0
    533c:	0e 94 3b 2f 	call	0x5e76	; 0x5e76 <__gesf2>
    5340:	18 16       	cp	r1, r24
    5342:	1c f4       	brge	.+6      	; 0x534a <rprintfFloat+0x40>
    5344:	35 01       	movw	r6, r10
    5346:	46 01       	movw	r8, r12
    5348:	06 c0       	rjmp	.+12     	; 0x5356 <rprintfFloat+0x4c>
    534a:	35 01       	movw	r6, r10
    534c:	46 01       	movw	r8, r12
    534e:	97 fa       	bst	r9, 7
    5350:	90 94       	com	r9
    5352:	97 f8       	bld	r9, 7
    5354:	90 94       	com	r9
    5356:	0f 2e       	mov	r0, r31
    5358:	f0 e0       	ldi	r31, 0x00	; 0
    535a:	ef 2e       	mov	r14, r31
    535c:	f0 e0       	ldi	r31, 0x00	; 0
    535e:	ff 2e       	mov	r15, r31
    5360:	f0 e8       	ldi	r31, 0x80	; 128
    5362:	0f 2f       	mov	r16, r31
    5364:	ff e3       	ldi	r31, 0x3F	; 63
    5366:	1f 2f       	mov	r17, r31
    5368:	f0 2d       	mov	r31, r0
    536a:	55 24       	eor	r5, r5
	
	// find starting digit place
	for(i=0; i<15; i++)
	{
		if((x/place) < 10.0)
    536c:	c4 01       	movw	r24, r8
    536e:	b3 01       	movw	r22, r6
    5370:	a8 01       	movw	r20, r16
    5372:	97 01       	movw	r18, r14
    5374:	0e 94 f0 2d 	call	0x5be0	; 0x5be0 <__divsf3>
    5378:	20 e0       	ldi	r18, 0x00	; 0
    537a:	30 e0       	ldi	r19, 0x00	; 0
    537c:	40 e2       	ldi	r20, 0x20	; 32
    537e:	51 e4       	ldi	r21, 0x41	; 65
    5380:	0e 94 ec 2d 	call	0x5bd8	; 0x5bd8 <__cmpsf2>
    5384:	87 fd       	sbrc	r24, 7
    5386:	0e c0       	rjmp	.+28     	; 0x53a4 <rprintfFloat+0x9a>
			break;
		else
			place *= 10.0;
    5388:	c8 01       	movw	r24, r16
    538a:	b7 01       	movw	r22, r14
    538c:	20 e0       	ldi	r18, 0x00	; 0
    538e:	30 e0       	ldi	r19, 0x00	; 0
    5390:	40 e2       	ldi	r20, 0x20	; 32
    5392:	51 e4       	ldi	r21, 0x41	; 65
    5394:	0e 94 3f 2f 	call	0x5e7e	; 0x5e7e <__mulsf3>
    5398:	7b 01       	movw	r14, r22
    539a:	8c 01       	movw	r16, r24
	negative = (x<0);
	// convert to absolute value
	x = (x>0)?(x):(-x);
	
	// find starting digit place
	for(i=0; i<15; i++)
    539c:	53 94       	inc	r5
    539e:	8f e0       	ldi	r24, 0x0F	; 15
    53a0:	58 16       	cp	r5, r24
    53a2:	21 f7       	brne	.-56     	; 0x536c <rprintfFloat+0x62>
			break;
		else
			place *= 10.0;
	}
	// print polarity character
	if(negative)
    53a4:	c6 01       	movw	r24, r12
    53a6:	b5 01       	movw	r22, r10
    53a8:	20 e0       	ldi	r18, 0x00	; 0
    53aa:	30 e0       	ldi	r19, 0x00	; 0
    53ac:	40 e0       	ldi	r20, 0x00	; 0
    53ae:	50 e0       	ldi	r21, 0x00	; 0
    53b0:	0e 94 ec 2d 	call	0x5bd8	; 0x5bd8 <__cmpsf2>
    53b4:	88 23       	and	r24, r24
    53b6:	14 f4       	brge	.+4      	; 0x53bc <rprintfFloat+0xb2>
		rprintfChar('-');
    53b8:	8d e2       	ldi	r24, 0x2D	; 45
    53ba:	01 c0       	rjmp	.+2      	; 0x53be <rprintfFloat+0xb4>
	else
		rprintfChar('+');
    53bc:	8b e2       	ldi	r24, 0x2B	; 43
    53be:	0e 94 2f 28 	call	0x505e	; 0x505e <rprintfChar>
    53c2:	dd 24       	eor	r13, r13
    53c4:	aa 24       	eor	r10, r10
    53c6:	56 c0       	rjmp	.+172    	; 0x5474 <rprintfFloat+0x16a>

	// print digits
	for(i=0; i<numDigits; i++)
	{
		digit = (x/place);
    53c8:	c4 01       	movw	r24, r8
    53ca:	b3 01       	movw	r22, r6
    53cc:	a8 01       	movw	r20, r16
    53ce:	97 01       	movw	r18, r14
    53d0:	0e 94 f0 2d 	call	0x5be0	; 0x5be0 <__divsf3>
    53d4:	0e 94 5d 2e 	call	0x5cba	; 0x5cba <__fixunssfsi>
    53d8:	b6 2e       	mov	r11, r22

		if(digit | firstplace | (place == 1.0))
    53da:	d6 2a       	or	r13, r22
    53dc:	cd 2d       	mov	r28, r13
    53de:	d0 e0       	ldi	r29, 0x00	; 0
    53e0:	cc 24       	eor	r12, r12
    53e2:	dd 24       	eor	r13, r13
    53e4:	c8 01       	movw	r24, r16
    53e6:	b7 01       	movw	r22, r14
    53e8:	20 e0       	ldi	r18, 0x00	; 0
    53ea:	30 e0       	ldi	r19, 0x00	; 0
    53ec:	40 e8       	ldi	r20, 0x80	; 128
    53ee:	5f e3       	ldi	r21, 0x3F	; 63
    53f0:	0e 94 ec 2d 	call	0x5bd8	; 0x5bd8 <__cmpsf2>
    53f4:	88 23       	and	r24, r24
    53f6:	19 f4       	brne	.+6      	; 0x53fe <rprintfFloat+0xf4>
    53f8:	21 e0       	ldi	r18, 0x01	; 1
    53fa:	c2 2e       	mov	r12, r18
    53fc:	d1 2c       	mov	r13, r1
    53fe:	cc 29       	or	r28, r12
    5400:	dd 29       	or	r29, r13
    5402:	cd 2b       	or	r28, r29
    5404:	39 f0       	breq	.+14     	; 0x5414 <rprintfFloat+0x10a>
		{
			firstplace = TRUE;
			rprintfChar(digit+0x30);
    5406:	8b 2d       	mov	r24, r11
    5408:	80 5d       	subi	r24, 0xD0	; 208
    540a:	0e 94 2f 28 	call	0x505e	; 0x505e <rprintfChar>
    540e:	dd 24       	eor	r13, r13
    5410:	da 94       	dec	r13
    5412:	04 c0       	rjmp	.+8      	; 0x541c <rprintfFloat+0x112>
		}
		else
			rprintfChar(' ');
    5414:	80 e2       	ldi	r24, 0x20	; 32
    5416:	0e 94 2f 28 	call	0x505e	; 0x505e <rprintfChar>
    541a:	dd 24       	eor	r13, r13
		
		if(place == 1.0)
    541c:	c8 01       	movw	r24, r16
    541e:	b7 01       	movw	r22, r14
    5420:	20 e0       	ldi	r18, 0x00	; 0
    5422:	30 e0       	ldi	r19, 0x00	; 0
    5424:	40 e8       	ldi	r20, 0x80	; 128
    5426:	5f e3       	ldi	r21, 0x3F	; 63
    5428:	0e 94 ec 2d 	call	0x5bd8	; 0x5bd8 <__cmpsf2>
    542c:	88 23       	and	r24, r24
    542e:	19 f4       	brne	.+6      	; 0x5436 <rprintfFloat+0x12c>
		{
			rprintfChar('.');
    5430:	8e e2       	ldi	r24, 0x2E	; 46
    5432:	0e 94 2f 28 	call	0x505e	; 0x505e <rprintfChar>
		}
		
		x -= (digit*place);
    5436:	6b 2d       	mov	r22, r11
    5438:	70 e0       	ldi	r23, 0x00	; 0
    543a:	88 27       	eor	r24, r24
    543c:	77 fd       	sbrc	r23, 7
    543e:	80 95       	com	r24
    5440:	98 2f       	mov	r25, r24
    5442:	0e 94 8b 2e 	call	0x5d16	; 0x5d16 <__floatsisf>
    5446:	a8 01       	movw	r20, r16
    5448:	97 01       	movw	r18, r14
    544a:	0e 94 3f 2f 	call	0x5e7e	; 0x5e7e <__mulsf3>
    544e:	9b 01       	movw	r18, r22
    5450:	ac 01       	movw	r20, r24
    5452:	c4 01       	movw	r24, r8
    5454:	b3 01       	movw	r22, r6
    5456:	0e 94 87 2d 	call	0x5b0e	; 0x5b0e <__subsf3>
    545a:	3b 01       	movw	r6, r22
    545c:	4c 01       	movw	r8, r24
		place /= 10.0;
    545e:	c8 01       	movw	r24, r16
    5460:	b7 01       	movw	r22, r14
    5462:	20 e0       	ldi	r18, 0x00	; 0
    5464:	30 e0       	ldi	r19, 0x00	; 0
    5466:	40 e2       	ldi	r20, 0x20	; 32
    5468:	51 e4       	ldi	r21, 0x41	; 65
    546a:	0e 94 f0 2d 	call	0x5be0	; 0x5be0 <__divsf3>
    546e:	7b 01       	movw	r14, r22
    5470:	8c 01       	movw	r16, r24
		rprintfChar('-');
	else
		rprintfChar('+');

	// print digits
	for(i=0; i<numDigits; i++)
    5472:	a3 94       	inc	r10
    5474:	a4 14       	cp	r10, r4
    5476:	08 f4       	brcc	.+2      	; 0x547a <rprintfFloat+0x170>
    5478:	a7 cf       	rjmp	.-178    	; 0x53c8 <rprintfFloat+0xbe>
		}
		
		x -= (digit*place);
		place /= 10.0;
	}
}
    547a:	df 91       	pop	r29
    547c:	cf 91       	pop	r28
    547e:	1f 91       	pop	r17
    5480:	0f 91       	pop	r16
    5482:	ff 90       	pop	r15
    5484:	ef 90       	pop	r14
    5486:	df 90       	pop	r13
    5488:	cf 90       	pop	r12
    548a:	bf 90       	pop	r11
    548c:	af 90       	pop	r10
    548e:	9f 90       	pop	r9
    5490:	8f 90       	pop	r8
    5492:	7f 90       	pop	r7
    5494:	6f 90       	pop	r6
    5496:	5f 90       	pop	r5
    5498:	4f 90       	pop	r4
    549a:	08 95       	ret

0000549c <rprintf1RamRom>:
// Supports:
// %d - decimal
// %x - hex
// %c - character
int rprintf1RamRom(unsigned char stringInRom, const char *format, ...)
{
    549c:	7f 92       	push	r7
    549e:	8f 92       	push	r8
    54a0:	9f 92       	push	r9
    54a2:	af 92       	push	r10
    54a4:	bf 92       	push	r11
    54a6:	cf 92       	push	r12
    54a8:	df 92       	push	r13
    54aa:	ef 92       	push	r14
    54ac:	ff 92       	push	r15
    54ae:	0f 93       	push	r16
    54b0:	1f 93       	push	r17
    54b2:	df 93       	push	r29
    54b4:	cf 93       	push	r28
    54b6:	cd b7       	in	r28, 0x3d	; 61
    54b8:	de b7       	in	r29, 0x3e	; 62
    54ba:	78 88       	ldd	r7, Y+16	; 0x10
    54bc:	c9 88       	ldd	r12, Y+17	; 0x11
    54be:	da 88       	ldd	r13, Y+18	; 0x12
    54c0:	63 e1       	ldi	r22, 0x13	; 19
    54c2:	e6 2e       	mov	r14, r22
    54c4:	f1 2c       	mov	r15, r1
    54c6:	ec 0e       	add	r14, r28
    54c8:	fd 1e       	adc	r15, r29
    54ca:	14 c0       	rjmp	.+40     	; 0x54f4 <rprintf1RamRom+0x58>
	va_start(ap, format);
	for (;;)
	{
		while ((format_flag = READMEMBYTE(stringInRom,format++) ) != '%')
		{	// Until '%' or '\0'
			if (!format_flag)
    54cc:	88 23       	and	r24, r24
    54ce:	81 f4       	brne	.+32     	; 0x54f0 <rprintf1RamRom+0x54>
				div_val /= base;
			} while (div_val);
		}
	}
	va_end(ap);
}
    54d0:	80 e0       	ldi	r24, 0x00	; 0
    54d2:	90 e0       	ldi	r25, 0x00	; 0
    54d4:	cf 91       	pop	r28
    54d6:	df 91       	pop	r29
    54d8:	1f 91       	pop	r17
    54da:	0f 91       	pop	r16
    54dc:	ff 90       	pop	r15
    54de:	ef 90       	pop	r14
    54e0:	df 90       	pop	r13
    54e2:	cf 90       	pop	r12
    54e4:	bf 90       	pop	r11
    54e6:	af 90       	pop	r10
    54e8:	9f 90       	pop	r9
    54ea:	8f 90       	pop	r8
    54ec:	7f 90       	pop	r7
    54ee:	08 95       	ret
			if (!format_flag)
			{
				va_end(ap);
				return(0);
			}
			rprintfChar(format_flag);
    54f0:	0e 94 2f 28 	call	0x505e	; 0x505e <rprintfChar>
    54f4:	96 01       	movw	r18, r12
    54f6:	2f 5f       	subi	r18, 0xFF	; 255
    54f8:	3f 4f       	sbci	r19, 0xFF	; 255
	va_list ap;

	va_start(ap, format);
	for (;;)
	{
		while ((format_flag = READMEMBYTE(stringInRom,format++) ) != '%')
    54fa:	77 20       	and	r7, r7
    54fc:	21 f0       	breq	.+8      	; 0x5506 <rprintf1RamRom+0x6a>
    54fe:	f6 01       	movw	r30, r12
    5500:	69 01       	movw	r12, r18
    5502:	84 91       	lpm	r24, Z+
    5504:	03 c0       	rjmp	.+6      	; 0x550c <rprintf1RamRom+0x70>
    5506:	f6 01       	movw	r30, r12
    5508:	80 81       	ld	r24, Z
    550a:	69 01       	movw	r12, r18
    550c:	85 32       	cpi	r24, 0x25	; 37
    550e:	f1 f6       	brne	.-68     	; 0x54cc <rprintf1RamRom+0x30>
    5510:	2f 5f       	subi	r18, 0xFF	; 255
    5512:	3f 4f       	sbci	r19, 0xFF	; 255
				return(0);
			}
			rprintfChar(format_flag);
		}

		switch (format_flag = READMEMBYTE(stringInRom,format++) )
    5514:	77 20       	and	r7, r7
    5516:	21 f0       	breq	.+8      	; 0x5520 <rprintf1RamRom+0x84>
    5518:	f6 01       	movw	r30, r12
    551a:	69 01       	movw	r12, r18
    551c:	84 91       	lpm	r24, Z+
    551e:	03 c0       	rjmp	.+6      	; 0x5526 <rprintf1RamRom+0x8a>
    5520:	f6 01       	movw	r30, r12
    5522:	80 81       	ld	r24, Z
    5524:	69 01       	movw	r12, r18
    5526:	84 36       	cpi	r24, 0x64	; 100
    5528:	29 f0       	breq	.+10     	; 0x5534 <rprintf1RamRom+0x98>
    552a:	88 37       	cpi	r24, 0x78	; 120
    552c:	81 f0       	breq	.+32     	; 0x554e <rprintf1RamRom+0xb2>
    552e:	83 36       	cpi	r24, 0x63	; 99
    5530:	f9 f6       	brne	.-66     	; 0x54f0 <rprintf1RamRom+0x54>
    5532:	06 c0       	rjmp	.+12     	; 0x5540 <rprintf1RamRom+0xa4>
    5534:	00 e1       	ldi	r16, 0x10	; 16
    5536:	17 e2       	ldi	r17, 0x27	; 39
    5538:	5a e0       	ldi	r21, 0x0A	; 10
    553a:	a5 2e       	mov	r10, r21
    553c:	b1 2c       	mov	r11, r1
    553e:	0c c0       	rjmp	.+24     	; 0x5558 <rprintf1RamRom+0xbc>
		{
			case 'c': format_flag = va_arg(ap,int);
    5540:	f7 01       	movw	r30, r14
    5542:	80 81       	ld	r24, Z
    5544:	22 e0       	ldi	r18, 0x02	; 2
    5546:	30 e0       	ldi	r19, 0x00	; 0
    5548:	e2 0e       	add	r14, r18
    554a:	f3 1e       	adc	r15, r19
    554c:	d1 cf       	rjmp	.-94     	; 0x54f0 <rprintf1RamRom+0x54>
			default:  rprintfChar(format_flag); continue;
    554e:	00 e0       	ldi	r16, 0x00	; 0
    5550:	10 e1       	ldi	r17, 0x10	; 16
    5552:	40 e1       	ldi	r20, 0x10	; 16
    5554:	a4 2e       	mov	r10, r20
    5556:	b1 2c       	mov	r11, r1
			case 'd': base = 10; div_val = 10000; goto CONVERSION_LOOP;
//			case 'x': base = 16; div_val = 0x10;
			case 'x': base = 16; div_val = 0x1000;

			CONVERSION_LOOP:
			u_val = va_arg(ap,int);
    5558:	32 e0       	ldi	r19, 0x02	; 2
    555a:	83 2e       	mov	r8, r19
    555c:	91 2c       	mov	r9, r1
    555e:	8e 0c       	add	r8, r14
    5560:	9f 1c       	adc	r9, r15
    5562:	f7 01       	movw	r30, r14
    5564:	e0 80       	ld	r14, Z
    5566:	f1 80       	ldd	r15, Z+1	; 0x01
			if (format_flag == 'd')
    5568:	84 36       	cpi	r24, 0x64	; 100
    556a:	b1 f4       	brne	.+44     	; 0x5598 <rprintf1RamRom+0xfc>
			{
				if (((int)u_val) < 0)
    556c:	f7 fe       	sbrs	r15, 7
    556e:	11 c0       	rjmp	.+34     	; 0x5592 <rprintf1RamRom+0xf6>
				{
					u_val = - u_val;
    5570:	f0 94       	com	r15
    5572:	e1 94       	neg	r14
    5574:	f1 08       	sbc	r15, r1
    5576:	f3 94       	inc	r15
					rprintfChar('-');
    5578:	8d e2       	ldi	r24, 0x2D	; 45
    557a:	0e 94 2f 28 	call	0x505e	; 0x505e <rprintfChar>
    557e:	09 c0       	rjmp	.+18     	; 0x5592 <rprintf1RamRom+0xf6>
				}
				while (div_val > 1 && div_val > u_val) div_val /= 10;
    5580:	c8 01       	movw	r24, r16
    5582:	6a e0       	ldi	r22, 0x0A	; 10
    5584:	70 e0       	ldi	r23, 0x00	; 0
    5586:	0e 94 c1 2f 	call	0x5f82	; 0x5f82 <__udivmodhi4>
    558a:	8b 01       	movw	r16, r22
    558c:	62 30       	cpi	r22, 0x02	; 2
    558e:	71 05       	cpc	r23, r1
    5590:	18 f0       	brcs	.+6      	; 0x5598 <rprintf1RamRom+0xfc>
    5592:	e0 16       	cp	r14, r16
    5594:	f1 06       	cpc	r15, r17
    5596:	a0 f3       	brcs	.-24     	; 0x5580 <rprintf1RamRom+0xe4>
			}
			do
			{
				//rprintfChar(pgm_read_byte(HexChars+(u_val/div_val)));
				rprintfu04(u_val/div_val);
    5598:	c7 01       	movw	r24, r14
    559a:	b8 01       	movw	r22, r16
    559c:	0e 94 c1 2f 	call	0x5f82	; 0x5f82 <__udivmodhi4>
    55a0:	86 2f       	mov	r24, r22
    55a2:	0e 94 92 28 	call	0x5124	; 0x5124 <rprintfu04>
				u_val %= div_val;
    55a6:	c7 01       	movw	r24, r14
    55a8:	b8 01       	movw	r22, r16
    55aa:	0e 94 c1 2f 	call	0x5f82	; 0x5f82 <__udivmodhi4>
    55ae:	7c 01       	movw	r14, r24
				div_val /= base;
    55b0:	c8 01       	movw	r24, r16
    55b2:	b5 01       	movw	r22, r10
    55b4:	0e 94 c1 2f 	call	0x5f82	; 0x5f82 <__udivmodhi4>
    55b8:	8b 01       	movw	r16, r22
			} while (div_val);
    55ba:	61 15       	cp	r22, r1
    55bc:	71 05       	cpc	r23, r1
    55be:	61 f7       	brne	.-40     	; 0x5598 <rprintf1RamRom+0xfc>
    55c0:	74 01       	movw	r14, r8
    55c2:	98 cf       	rjmp	.-208    	; 0x54f4 <rprintf1RamRom+0x58>

000055c4 <i2cSetBitrate>:
	// SCL freq = F_CPU/(16+2*TWBR))
	#ifdef TWPS0
		// for processors with additional bitrate division (mega128)
		// SCL freq = F_CPU/(16+2*TWBR*4^TWPS)
		// set TWPS to zero
		cbi(TWSR, TWPS0);
    55c4:	20 91 b9 00 	lds	r18, 0x00B9
    55c8:	2e 7f       	andi	r18, 0xFE	; 254
    55ca:	20 93 b9 00 	sts	0x00B9, r18
		cbi(TWSR, TWPS1);
    55ce:	20 91 b9 00 	lds	r18, 0x00B9
    55d2:	2d 7f       	andi	r18, 0xFD	; 253
    55d4:	20 93 b9 00 	sts	0x00B9, r18
	#endif
	// calculate bitrate division	
	bitrate_div = ((F_CPU/1000l)/bitrateKHz);
    55d8:	9c 01       	movw	r18, r24
    55da:	40 e0       	ldi	r20, 0x00	; 0
    55dc:	50 e0       	ldi	r21, 0x00	; 0
    55de:	60 e8       	ldi	r22, 0x80	; 128
    55e0:	7e e3       	ldi	r23, 0x3E	; 62
    55e2:	80 e0       	ldi	r24, 0x00	; 0
    55e4:	90 e0       	ldi	r25, 0x00	; 0
    55e6:	0e 94 0a 30 	call	0x6014	; 0x6014 <__divmodsi4>
	if(bitrate_div >= 16)
    55ea:	20 31       	cpi	r18, 0x10	; 16
    55ec:	30 f0       	brcs	.+12     	; 0x55fa <i2cSetBitrate+0x36>
		bitrate_div = (bitrate_div-16)/2;
    55ee:	82 2f       	mov	r24, r18
    55f0:	90 e0       	ldi	r25, 0x00	; 0
    55f2:	40 97       	sbiw	r24, 0x10	; 16
    55f4:	95 95       	asr	r25
    55f6:	87 95       	ror	r24
    55f8:	28 2f       	mov	r18, r24
	outb(TWBR, bitrate_div);
    55fa:	20 93 b8 00 	sts	0x00B8, r18
}
    55fe:	08 95       	ret

00005600 <i2cInit>:

// functions
void i2cInit(void)
{
	// set pull-up resistors on I2C bus pins
	sbi(PORTD, 0);	// i2c SCL on 640
    5600:	58 9a       	sbi	0x0b, 0	; 11
	sbi(PORTD, 1);	// i2c SDA on 640
    5602:	59 9a       	sbi	0x0b, 1	; 11

	// clear SlaveReceive and SlaveTransmit handler to null
	i2cSlaveReceive = 0;
    5604:	10 92 42 12 	sts	0x1242, r1
    5608:	10 92 41 12 	sts	0x1241, r1
	i2cSlaveTransmit = 0;
    560c:	10 92 44 12 	sts	0x1244, r1
    5610:	10 92 43 12 	sts	0x1243, r1
	// set i2c bit rate to 100KHz
	i2cSetBitrate(100);
    5614:	84 e6       	ldi	r24, 0x64	; 100
    5616:	90 e0       	ldi	r25, 0x00	; 0
    5618:	0e 94 e2 2a 	call	0x55c4	; 0x55c4 <i2cSetBitrate>
	// enable TWI (two-wire interface)
	sbi(TWCR, TWEN);
    561c:	ec eb       	ldi	r30, 0xBC	; 188
    561e:	f0 e0       	ldi	r31, 0x00	; 0
    5620:	80 81       	ld	r24, Z
    5622:	84 60       	ori	r24, 0x04	; 4
    5624:	80 83       	st	Z, r24
	// set state
	I2cState = I2C_IDLE;
    5626:	10 92 fb 11 	sts	0x11FB, r1
	// enable TWI interrupt and slave address ACK
	sbi(TWCR, TWIE);
    562a:	80 81       	ld	r24, Z
    562c:	81 60       	ori	r24, 0x01	; 1
    562e:	80 83       	st	Z, r24
	sbi(TWCR, TWEA);
    5630:	80 81       	ld	r24, Z
    5632:	80 64       	ori	r24, 0x40	; 64
    5634:	80 83       	st	Z, r24
	//outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
	// enable interrupts
	sei();
    5636:	78 94       	sei
}
    5638:	08 95       	ret

0000563a <i2cSetLocalDeviceAddr>:
}

void i2cSetLocalDeviceAddr(u08 deviceAddr, u08 genCallEn)
{
	// set local device address (used in slave mode only)
	outb(TWAR, ((deviceAddr&0xFE) | (genCallEn?1:0)) );
    563a:	90 e0       	ldi	r25, 0x00	; 0
    563c:	61 11       	cpse	r22, r1
    563e:	91 e0       	ldi	r25, 0x01	; 1
    5640:	8e 7f       	andi	r24, 0xFE	; 254
    5642:	98 2b       	or	r25, r24
    5644:	90 93 ba 00 	sts	0x00BA, r25
}
    5648:	08 95       	ret

0000564a <i2cSetSlaveReceiveHandler>:

void i2cSetSlaveReceiveHandler(void (*i2cSlaveRx_func)(u08 receiveDataLength, u08* recieveData))
{
	i2cSlaveReceive = i2cSlaveRx_func;
    564a:	90 93 42 12 	sts	0x1242, r25
    564e:	80 93 41 12 	sts	0x1241, r24
}
    5652:	08 95       	ret

00005654 <i2cSetSlaveTransmitHandler>:

void i2cSetSlaveTransmitHandler(u08 (*i2cSlaveTx_func)(u08 transmitDataLengthMax, u08* transmitData))
{
	i2cSlaveTransmit = i2cSlaveTx_func;
    5654:	90 93 44 12 	sts	0x1244, r25
    5658:	80 93 43 12 	sts	0x1243, r24
}
    565c:	08 95       	ret

0000565e <i2cSendStart>:

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    565e:	ec eb       	ldi	r30, 0xBC	; 188
    5660:	f0 e0       	ldi	r31, 0x00	; 0
    5662:	80 81       	ld	r24, Z
    5664:	8f 70       	andi	r24, 0x0F	; 15
    5666:	80 6a       	ori	r24, 0xA0	; 160
    5668:	80 83       	st	Z, r24
}
    566a:	08 95       	ret

0000566c <i2cSendStop>:

inline void i2cSendStop(void)
{
	// transmit stop condition
	// leave with TWEA on for slave receiving
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA)|BV(TWSTO));
    566c:	ec eb       	ldi	r30, 0xBC	; 188
    566e:	f0 e0       	ldi	r31, 0x00	; 0
    5670:	80 81       	ld	r24, Z
    5672:	8f 70       	andi	r24, 0x0F	; 15
    5674:	80 6d       	ori	r24, 0xD0	; 208
    5676:	80 83       	st	Z, r24
}
    5678:	08 95       	ret

0000567a <i2cWaitForComplete>:

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    567a:	80 91 bc 00 	lds	r24, 0x00BC
    567e:	87 ff       	sbrs	r24, 7
    5680:	fc cf       	rjmp	.-8      	; 0x567a <i2cWaitForComplete>
}
    5682:	08 95       	ret

00005684 <i2cSendByte>:

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    5684:	80 93 bb 00 	sts	0x00BB, r24
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    5688:	ec eb       	ldi	r30, 0xBC	; 188
    568a:	f0 e0       	ldi	r31, 0x00	; 0
    568c:	80 81       	ld	r24, Z
    568e:	8f 70       	andi	r24, 0x0F	; 15
    5690:	80 68       	ori	r24, 0x80	; 128
    5692:	80 83       	st	Z, r24
}
    5694:	08 95       	ret

00005696 <i2cReceiveByte>:

inline void i2cReceiveByte(u08 ackFlag)
{
	// begin receive over i2c
	if( ackFlag )
    5696:	88 23       	and	r24, r24
    5698:	29 f0       	breq	.+10     	; 0x56a4 <i2cReceiveByte+0xe>
	{
		// ackFlag = TRUE: ACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    569a:	80 91 bc 00 	lds	r24, 0x00BC
    569e:	8f 70       	andi	r24, 0x0F	; 15
    56a0:	80 6c       	ori	r24, 0xC0	; 192
    56a2:	04 c0       	rjmp	.+8      	; 0x56ac <i2cReceiveByte+0x16>
	}
	else
	{
		// ackFlag = FALSE: NACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    56a4:	80 91 bc 00 	lds	r24, 0x00BC
    56a8:	8f 70       	andi	r24, 0x0F	; 15
    56aa:	80 68       	ori	r24, 0x80	; 128
    56ac:	80 93 bc 00 	sts	0x00BC, r24
    56b0:	08 95       	ret

000056b2 <i2cGetReceivedByte>:
}

inline u08 i2cGetReceivedByte(void)
{
	// retieve received data byte from i2c TWDR
	return( inb(TWDR) );
    56b2:	80 91 bb 00 	lds	r24, 0x00BB
}
    56b6:	08 95       	ret

000056b8 <i2cGetStatus>:

inline u08 i2cGetStatus(void)
{
	// retieve current i2c status from i2c TWSR
	return( inb(TWSR) );
    56b8:	80 91 b9 00 	lds	r24, 0x00B9
}
    56bc:	08 95       	ret

000056be <i2cMasterSend>:

void i2cMasterSend(u08 deviceAddr, u08 length, u08* data)
{
    56be:	98 2f       	mov	r25, r24
	u08 i;
	// wait for interface to be ready
	while(I2cState);
    56c0:	80 91 fb 11 	lds	r24, 0x11FB
    56c4:	88 23       	and	r24, r24
    56c6:	e1 f7       	brne	.-8      	; 0x56c0 <i2cMasterSend+0x2>
	// set state
	I2cState = I2C_MASTER_TX;
    56c8:	82 e0       	ldi	r24, 0x02	; 2
    56ca:	80 93 fb 11 	sts	0x11FB, r24
	// save data
	I2cDeviceAddrRW = (deviceAddr & 0xFE);	// RW cleared: write operation
    56ce:	9e 7f       	andi	r25, 0xFE	; 254
    56d0:	90 93 fc 11 	sts	0x11FC, r25
    56d4:	ad ef       	ldi	r26, 0xFD	; 253
    56d6:	b1 e1       	ldi	r27, 0x11	; 17
    56d8:	fa 01       	movw	r30, r20
    56da:	02 c0       	rjmp	.+4      	; 0x56e0 <i2cMasterSend+0x22>
	for(i=0; i<length; i++)
		I2cSendData[i] = *data++;
    56dc:	81 91       	ld	r24, Z+
    56de:	8d 93       	st	X+, r24
	while(I2cState);
	// set state
	I2cState = I2C_MASTER_TX;
	// save data
	I2cDeviceAddrRW = (deviceAddr & 0xFE);	// RW cleared: write operation
	for(i=0; i<length; i++)
    56e0:	8e 2f       	mov	r24, r30
    56e2:	84 1b       	sub	r24, r20
    56e4:	86 17       	cp	r24, r22
    56e6:	d0 f3       	brcs	.-12     	; 0x56dc <i2cMasterSend+0x1e>
		I2cSendData[i] = *data++;
	I2cSendDataIndex = 0;
    56e8:	10 92 1d 12 	sts	0x121D, r1
	I2cSendDataLength = length;
    56ec:	60 93 1e 12 	sts	0x121E, r22
}

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    56f0:	80 91 bc 00 	lds	r24, 0x00BC
    56f4:	8f 70       	andi	r24, 0x0F	; 15
    56f6:	80 6a       	ori	r24, 0xA0	; 160
    56f8:	80 93 bc 00 	sts	0x00BC, r24
		I2cSendData[i] = *data++;
	I2cSendDataIndex = 0;
	I2cSendDataLength = length;
	// send start condition
	i2cSendStart();
}
    56fc:	08 95       	ret

000056fe <i2cMasterReceive>:

void i2cMasterReceive(u08 deviceAddr, u08 length, u08* data)
{
    56fe:	98 2f       	mov	r25, r24
	u08 i;
	// wait for interface to be ready
	while(I2cState);
    5700:	80 91 fb 11 	lds	r24, 0x11FB
    5704:	88 23       	and	r24, r24
    5706:	e1 f7       	brne	.-8      	; 0x5700 <i2cMasterReceive+0x2>
	// set state
	I2cState = I2C_MASTER_RX;
    5708:	83 e0       	ldi	r24, 0x03	; 3
    570a:	80 93 fb 11 	sts	0x11FB, r24
	// save data
	I2cDeviceAddrRW = (deviceAddr|0x01);	// RW set: read operation
    570e:	91 60       	ori	r25, 0x01	; 1
    5710:	90 93 fc 11 	sts	0x11FC, r25
	I2cReceiveDataIndex = 0;
    5714:	10 92 3f 12 	sts	0x123F, r1
	I2cReceiveDataLength = length;
    5718:	60 93 40 12 	sts	0x1240, r22
}

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    571c:	80 91 bc 00 	lds	r24, 0x00BC
    5720:	8f 70       	andi	r24, 0x0F	; 15
    5722:	80 6a       	ori	r24, 0xA0	; 160
    5724:	80 93 bc 00 	sts	0x00BC, r24
	I2cReceiveDataIndex = 0;
	I2cReceiveDataLength = length;
	// send start condition
	i2cSendStart();
	// wait for data
	while(I2cState);
    5728:	80 91 fb 11 	lds	r24, 0x11FB
    572c:	88 23       	and	r24, r24
    572e:	e1 f7       	brne	.-8      	; 0x5728 <i2cMasterReceive+0x2a>
    5730:	af e1       	ldi	r26, 0x1F	; 31
    5732:	b2 e1       	ldi	r27, 0x12	; 18
    5734:	fa 01       	movw	r30, r20
    5736:	02 c0       	rjmp	.+4      	; 0x573c <i2cMasterReceive+0x3e>
	// return data
	for(i=0; i<length; i++)
		*data++ = I2cReceiveData[i];
    5738:	8d 91       	ld	r24, X+
    573a:	81 93       	st	Z+, r24
	// send start condition
	i2cSendStart();
	// wait for data
	while(I2cState);
	// return data
	for(i=0; i<length; i++)
    573c:	8e 2f       	mov	r24, r30
    573e:	84 1b       	sub	r24, r20
    5740:	86 17       	cp	r24, r22
    5742:	d0 f3       	brcs	.-12     	; 0x5738 <i2cMasterReceive+0x3a>
		*data++ = I2cReceiveData[i];
}
    5744:	08 95       	ret

00005746 <i2cMasterSendNI>:

u08 i2cMasterSendNI(u08 deviceAddr, u08 length, u08* data)
{
    5746:	98 2f       	mov	r25, r24
    5748:	fa 01       	movw	r30, r20
	u08 retval = I2C_OK;

	// disable TWI interrupt
	cbi(TWCR, TWIE);
    574a:	80 91 bc 00 	lds	r24, 0x00BC
    574e:	8e 7f       	andi	r24, 0xFE	; 254
    5750:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    5754:	80 91 bc 00 	lds	r24, 0x00BC
    5758:	8f 70       	andi	r24, 0x0F	; 15
    575a:	80 6a       	ori	r24, 0xA0	; 160
    575c:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    5760:	80 91 bc 00 	lds	r24, 0x00BC
    5764:	87 ff       	sbrs	r24, 7
    5766:	fc cf       	rjmp	.-8      	; 0x5760 <i2cMasterSendNI+0x1a>
	// send start condition
	i2cSendStart();
	i2cWaitForComplete();

	// send device address with write
	i2cSendByte( deviceAddr & 0xFE );
    5768:	9e 7f       	andi	r25, 0xFE	; 254
}

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    576a:	90 93 bb 00 	sts	0x00BB, r25
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    576e:	80 91 bc 00 	lds	r24, 0x00BC
    5772:	8f 70       	andi	r24, 0x0F	; 15
    5774:	80 68       	ori	r24, 0x80	; 128
    5776:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    577a:	80 91 bc 00 	lds	r24, 0x00BC
    577e:	87 ff       	sbrs	r24, 7
    5780:	fc cf       	rjmp	.-8      	; 0x577a <i2cMasterSendNI+0x34>
	// send device address with write
	i2cSendByte( deviceAddr & 0xFE );
	i2cWaitForComplete();

	// check if device is present and live
	if( inb(TWSR) == TW_MT_SLA_ACK)
    5782:	80 91 b9 00 	lds	r24, 0x00B9
    5786:	88 31       	cpi	r24, 0x18	; 24
    5788:	89 f0       	breq	.+34     	; 0x57ac <i2cMasterSendNI+0x66>
    578a:	91 e0       	ldi	r25, 0x01	; 1
    578c:	12 c0       	rjmp	.+36     	; 0x57b2 <i2cMasterSendNI+0x6c>
	{
		// send data
		while(length)
		{
			i2cSendByte( *data++ );
    578e:	80 81       	ld	r24, Z
}

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    5790:	80 93 bb 00 	sts	0x00BB, r24
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    5794:	80 91 bc 00 	lds	r24, 0x00BC
    5798:	8f 70       	andi	r24, 0x0F	; 15
    579a:	80 68       	ori	r24, 0x80	; 128
    579c:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    57a0:	80 91 bc 00 	lds	r24, 0x00BC
    57a4:	87 ff       	sbrs	r24, 7
    57a6:	fc cf       	rjmp	.-8      	; 0x57a0 <i2cMasterSendNI+0x5a>
	if( inb(TWSR) == TW_MT_SLA_ACK)
	{
		// send data
		while(length)
		{
			i2cSendByte( *data++ );
    57a8:	31 96       	adiw	r30, 0x01	; 1
			i2cWaitForComplete();
			length--;
    57aa:	61 50       	subi	r22, 0x01	; 1

	// check if device is present and live
	if( inb(TWSR) == TW_MT_SLA_ACK)
	{
		// send data
		while(length)
    57ac:	66 23       	and	r22, r22
    57ae:	79 f7       	brne	.-34     	; 0x578e <i2cMasterSendNI+0x48>
    57b0:	90 e0       	ldi	r25, 0x00	; 0

inline void i2cSendStop(void)
{
	// transmit stop condition
	// leave with TWEA on for slave receiving
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA)|BV(TWSTO));
    57b2:	80 91 bc 00 	lds	r24, 0x00BC
    57b6:	8f 70       	andi	r24, 0x0F	; 15
    57b8:	80 6d       	ori	r24, 0xD0	; 208
    57ba:	80 93 bc 00 	sts	0x00BC, r24
	}

	// transmit stop condition
	// leave with TWEA on for slave receiving
	i2cSendStop();
	while( !(inb(TWCR) & BV(TWSTO)) );
    57be:	80 91 bc 00 	lds	r24, 0x00BC
    57c2:	84 ff       	sbrs	r24, 4
    57c4:	fc cf       	rjmp	.-8      	; 0x57be <i2cMasterSendNI+0x78>

	// enable TWI interrupt
	sbi(TWCR, TWIE);
    57c6:	80 91 bc 00 	lds	r24, 0x00BC
    57ca:	81 60       	ori	r24, 0x01	; 1
    57cc:	80 93 bc 00 	sts	0x00BC, r24

	return retval;
}
    57d0:	89 2f       	mov	r24, r25
    57d2:	08 95       	ret

000057d4 <i2cMasterReceiveNI>:

u08 i2cMasterReceiveNI(u08 deviceAddr, u08 length, u08 *data)
{
    57d4:	98 2f       	mov	r25, r24
    57d6:	fa 01       	movw	r30, r20
	u08 retval = I2C_OK;

	// disable TWI interrupt
	cbi(TWCR, TWIE);
    57d8:	80 91 bc 00 	lds	r24, 0x00BC
    57dc:	8e 7f       	andi	r24, 0xFE	; 254
    57de:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    57e2:	80 91 bc 00 	lds	r24, 0x00BC
    57e6:	8f 70       	andi	r24, 0x0F	; 15
    57e8:	80 6a       	ori	r24, 0xA0	; 160
    57ea:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    57ee:	80 91 bc 00 	lds	r24, 0x00BC
    57f2:	87 ff       	sbrs	r24, 7
    57f4:	fc cf       	rjmp	.-8      	; 0x57ee <i2cMasterReceiveNI+0x1a>
	// send start condition
	i2cSendStart();
	i2cWaitForComplete();

	// send device address with read
	i2cSendByte( deviceAddr | 0x01 );
    57f6:	91 60       	ori	r25, 0x01	; 1
}

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    57f8:	90 93 bb 00 	sts	0x00BB, r25
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    57fc:	80 91 bc 00 	lds	r24, 0x00BC
    5800:	8f 70       	andi	r24, 0x0F	; 15
    5802:	80 68       	ori	r24, 0x80	; 128
    5804:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    5808:	80 91 bc 00 	lds	r24, 0x00BC
    580c:	87 ff       	sbrs	r24, 7
    580e:	fc cf       	rjmp	.-8      	; 0x5808 <i2cMasterReceiveNI+0x34>
	// send device address with read
	i2cSendByte( deviceAddr | 0x01 );
	i2cWaitForComplete();

	// check if device is present and live
	if( inb(TWSR) == TW_MR_SLA_ACK)
    5810:	80 91 b9 00 	lds	r24, 0x00B9
    5814:	80 34       	cpi	r24, 0x40	; 64
    5816:	81 f0       	breq	.+32     	; 0x5838 <i2cMasterReceiveNI+0x64>
    5818:	91 e0       	ldi	r25, 0x01	; 1
    581a:	1e c0       	rjmp	.+60     	; 0x5858 <i2cMasterReceiveNI+0x84>
{
	// begin receive over i2c
	if( ackFlag )
	{
		// ackFlag = TRUE: ACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    581c:	80 91 bc 00 	lds	r24, 0x00BC
    5820:	8f 70       	andi	r24, 0x0F	; 15
    5822:	80 6c       	ori	r24, 0xC0	; 192
    5824:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    5828:	80 91 bc 00 	lds	r24, 0x00BC
    582c:	87 ff       	sbrs	r24, 7
    582e:	fc cf       	rjmp	.-8      	; 0x5828 <i2cMasterReceiveNI+0x54>
}

inline u08 i2cGetReceivedByte(void)
{
	// retieve received data byte from i2c TWDR
	return( inb(TWDR) );
    5830:	80 91 bb 00 	lds	r24, 0x00BB
		// accept receive data and ack it
		while(length > 1)
		{
			i2cReceiveByte(TRUE);
			i2cWaitForComplete();
			*data++ = i2cGetReceivedByte();
    5834:	81 93       	st	Z+, r24
			// decrement length
			length--;
    5836:	61 50       	subi	r22, 0x01	; 1

	// check if device is present and live
	if( inb(TWSR) == TW_MR_SLA_ACK)
	{
		// accept receive data and ack it
		while(length > 1)
    5838:	62 30       	cpi	r22, 0x02	; 2
    583a:	80 f7       	brcc	.-32     	; 0x581c <i2cMasterReceiveNI+0x48>
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
	}
	else
	{
		// ackFlag = FALSE: NACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    583c:	80 91 bc 00 	lds	r24, 0x00BC
    5840:	8f 70       	andi	r24, 0x0F	; 15
    5842:	80 68       	ori	r24, 0x80	; 128
    5844:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    5848:	80 91 bc 00 	lds	r24, 0x00BC
    584c:	87 ff       	sbrs	r24, 7
    584e:	fc cf       	rjmp	.-8      	; 0x5848 <i2cMasterReceiveNI+0x74>
}

inline u08 i2cGetReceivedByte(void)
{
	// retieve received data byte from i2c TWDR
	return( inb(TWDR) );
    5850:	80 91 bb 00 	lds	r24, 0x00BB
		}

		// accept receive data and nack it (last-byte signal)
		i2cReceiveByte(FALSE);
		i2cWaitForComplete();
		*data++ = i2cGetReceivedByte();
    5854:	80 83       	st	Z, r24
    5856:	90 e0       	ldi	r25, 0x00	; 0

inline void i2cSendStop(void)
{
	// transmit stop condition
	// leave with TWEA on for slave receiving
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA)|BV(TWSTO));
    5858:	80 91 bc 00 	lds	r24, 0x00BC
    585c:	8f 70       	andi	r24, 0x0F	; 15
    585e:	80 6d       	ori	r24, 0xD0	; 208
    5860:	80 93 bc 00 	sts	0x00BC, r24
	// transmit stop condition
	// leave with TWEA on for slave receiving
	i2cSendStop();

	// enable TWI interrupt
	sbi(TWCR, TWIE);
    5864:	80 91 bc 00 	lds	r24, 0x00BC
    5868:	81 60       	ori	r24, 0x01	; 1
    586a:	80 93 bc 00 	sts	0x00BC, r24

	return retval;
}
    586e:	89 2f       	mov	r24, r25
    5870:	08 95       	ret

00005872 <__vector_39>:
}
*/

//! I2C (TWI) interrupt service routine
SIGNAL(SIG_2WIRE_SERIAL)
{
    5872:	1f 92       	push	r1
    5874:	0f 92       	push	r0
    5876:	0f b6       	in	r0, 0x3f	; 63
    5878:	0f 92       	push	r0
    587a:	11 24       	eor	r1, r1
    587c:	2f 93       	push	r18
    587e:	3f 93       	push	r19
    5880:	4f 93       	push	r20
    5882:	5f 93       	push	r21
    5884:	6f 93       	push	r22
    5886:	7f 93       	push	r23
    5888:	8f 93       	push	r24
    588a:	9f 93       	push	r25
    588c:	af 93       	push	r26
    588e:	bf 93       	push	r27
    5890:	ef 93       	push	r30
    5892:	ff 93       	push	r31
	// read status bits
	u08 status = inb(TWSR) & TWSR_STATUS_MASK;
    5894:	80 91 b9 00 	lds	r24, 0x00B9

	switch(status)
    5898:	88 7f       	andi	r24, 0xF8	; 248
    589a:	80 36       	cpi	r24, 0x60	; 96
    589c:	09 f4       	brne	.+2      	; 0x58a0 <__vector_39+0x2e>
    589e:	a0 c0       	rjmp	.+320    	; 0x59e0 <__vector_39+0x16e>
    58a0:	81 36       	cpi	r24, 0x61	; 97
    58a2:	70 f5       	brcc	.+92     	; 0x5900 <__vector_39+0x8e>
    58a4:	88 32       	cpi	r24, 0x28	; 40
    58a6:	09 f4       	brne	.+2      	; 0x58aa <__vector_39+0x38>
    58a8:	5f c0       	rjmp	.+190    	; 0x5968 <__vector_39+0xf6>
    58aa:	89 32       	cpi	r24, 0x29	; 41
    58ac:	98 f4       	brcc	.+38     	; 0x58d4 <__vector_39+0x62>
    58ae:	80 31       	cpi	r24, 0x10	; 16
    58b0:	09 f4       	brne	.+2      	; 0x58b4 <__vector_39+0x42>
    58b2:	57 c0       	rjmp	.+174    	; 0x5962 <__vector_39+0xf0>
    58b4:	81 31       	cpi	r24, 0x11	; 17
    58b6:	38 f4       	brcc	.+14     	; 0x58c6 <__vector_39+0x54>
    58b8:	88 23       	and	r24, r24
    58ba:	09 f4       	brne	.+2      	; 0x58be <__vector_39+0x4c>
    58bc:	ea c0       	rjmp	.+468    	; 0x5a92 <__vector_39+0x220>
    58be:	88 30       	cpi	r24, 0x08	; 8
    58c0:	09 f0       	breq	.+2      	; 0x58c4 <__vector_39+0x52>
    58c2:	ef c0       	rjmp	.+478    	; 0x5aa2 <__vector_39+0x230>
    58c4:	4e c0       	rjmp	.+156    	; 0x5962 <__vector_39+0xf0>
    58c6:	88 31       	cpi	r24, 0x18	; 24
    58c8:	09 f4       	brne	.+2      	; 0x58cc <__vector_39+0x5a>
    58ca:	4e c0       	rjmp	.+156    	; 0x5968 <__vector_39+0xf6>
    58cc:	80 32       	cpi	r24, 0x20	; 32
    58ce:	09 f0       	breq	.+2      	; 0x58d2 <__vector_39+0x60>
    58d0:	e8 c0       	rjmp	.+464    	; 0x5aa2 <__vector_39+0x230>
    58d2:	df c0       	rjmp	.+446    	; 0x5a92 <__vector_39+0x220>
    58d4:	80 34       	cpi	r24, 0x40	; 64
    58d6:	09 f4       	brne	.+2      	; 0x58da <__vector_39+0x68>
    58d8:	77 c0       	rjmp	.+238    	; 0x59c8 <__vector_39+0x156>
    58da:	81 34       	cpi	r24, 0x41	; 65
    58dc:	38 f4       	brcc	.+14     	; 0x58ec <__vector_39+0x7a>
    58de:	80 33       	cpi	r24, 0x30	; 48
    58e0:	09 f4       	brne	.+2      	; 0x58e4 <__vector_39+0x72>
    58e2:	d7 c0       	rjmp	.+430    	; 0x5a92 <__vector_39+0x220>
    58e4:	88 33       	cpi	r24, 0x38	; 56
    58e6:	09 f0       	breq	.+2      	; 0x58ea <__vector_39+0x78>
    58e8:	dc c0       	rjmp	.+440    	; 0x5aa2 <__vector_39+0x230>
    58ea:	5d c0       	rjmp	.+186    	; 0x59a6 <__vector_39+0x134>
    58ec:	80 35       	cpi	r24, 0x50	; 80
    58ee:	09 f4       	brne	.+2      	; 0x58f2 <__vector_39+0x80>
    58f0:	5f c0       	rjmp	.+190    	; 0x59b0 <__vector_39+0x13e>
    58f2:	88 35       	cpi	r24, 0x58	; 88
    58f4:	09 f4       	brne	.+2      	; 0x58f8 <__vector_39+0x86>
    58f6:	4a c0       	rjmp	.+148    	; 0x598c <__vector_39+0x11a>
    58f8:	88 34       	cpi	r24, 0x48	; 72
    58fa:	09 f0       	breq	.+2      	; 0x58fe <__vector_39+0x8c>
    58fc:	d2 c0       	rjmp	.+420    	; 0x5aa2 <__vector_39+0x230>
    58fe:	c9 c0       	rjmp	.+402    	; 0x5a92 <__vector_39+0x220>
    5900:	88 39       	cpi	r24, 0x98	; 152
    5902:	09 f4       	brne	.+2      	; 0x5906 <__vector_39+0x94>
    5904:	ba c0       	rjmp	.+372    	; 0x5a7a <__vector_39+0x208>
    5906:	89 39       	cpi	r24, 0x99	; 153
    5908:	b0 f4       	brcc	.+44     	; 0x5936 <__vector_39+0xc4>
    590a:	88 37       	cpi	r24, 0x78	; 120
    590c:	09 f4       	brne	.+2      	; 0x5910 <__vector_39+0x9e>
    590e:	68 c0       	rjmp	.+208    	; 0x59e0 <__vector_39+0x16e>
    5910:	89 37       	cpi	r24, 0x79	; 121
    5912:	38 f4       	brcc	.+14     	; 0x5922 <__vector_39+0xb0>
    5914:	88 36       	cpi	r24, 0x68	; 104
    5916:	09 f4       	brne	.+2      	; 0x591a <__vector_39+0xa8>
    5918:	63 c0       	rjmp	.+198    	; 0x59e0 <__vector_39+0x16e>
    591a:	80 37       	cpi	r24, 0x70	; 112
    591c:	09 f0       	breq	.+2      	; 0x5920 <__vector_39+0xae>
    591e:	c1 c0       	rjmp	.+386    	; 0x5aa2 <__vector_39+0x230>
    5920:	5f c0       	rjmp	.+190    	; 0x59e0 <__vector_39+0x16e>
    5922:	88 38       	cpi	r24, 0x88	; 136
    5924:	09 f4       	brne	.+2      	; 0x5928 <__vector_39+0xb6>
    5926:	a9 c0       	rjmp	.+338    	; 0x5a7a <__vector_39+0x208>
    5928:	80 39       	cpi	r24, 0x90	; 144
    592a:	09 f4       	brne	.+2      	; 0x592e <__vector_39+0xbc>
    592c:	5f c0       	rjmp	.+190    	; 0x59ec <__vector_39+0x17a>
    592e:	80 38       	cpi	r24, 0x80	; 128
    5930:	09 f0       	breq	.+2      	; 0x5934 <__vector_39+0xc2>
    5932:	b7 c0       	rjmp	.+366    	; 0x5aa2 <__vector_39+0x230>
    5934:	5b c0       	rjmp	.+182    	; 0x59ec <__vector_39+0x17a>
    5936:	80 3b       	cpi	r24, 0xB0	; 176
    5938:	09 f4       	brne	.+2      	; 0x593c <__vector_39+0xca>
    593a:	79 c0       	rjmp	.+242    	; 0x5a2e <__vector_39+0x1bc>
    593c:	81 3b       	cpi	r24, 0xB1	; 177
    593e:	38 f4       	brcc	.+14     	; 0x594e <__vector_39+0xdc>
    5940:	80 3a       	cpi	r24, 0xA0	; 160
    5942:	09 f4       	brne	.+2      	; 0x5946 <__vector_39+0xd4>
    5944:	62 c0       	rjmp	.+196    	; 0x5a0a <__vector_39+0x198>
    5946:	88 3a       	cpi	r24, 0xA8	; 168
    5948:	09 f0       	breq	.+2      	; 0x594c <__vector_39+0xda>
    594a:	ab c0       	rjmp	.+342    	; 0x5aa2 <__vector_39+0x230>
    594c:	70 c0       	rjmp	.+224    	; 0x5a2e <__vector_39+0x1bc>
    594e:	80 3c       	cpi	r24, 0xC0	; 192
    5950:	09 f4       	brne	.+2      	; 0x5954 <__vector_39+0xe2>
    5952:	9a c0       	rjmp	.+308    	; 0x5a88 <__vector_39+0x216>
    5954:	88 3c       	cpi	r24, 0xC8	; 200
    5956:	09 f4       	brne	.+2      	; 0x595a <__vector_39+0xe8>
    5958:	97 c0       	rjmp	.+302    	; 0x5a88 <__vector_39+0x216>
    595a:	88 3b       	cpi	r24, 0xB8	; 184
    595c:	09 f0       	breq	.+2      	; 0x5960 <__vector_39+0xee>
    595e:	a1 c0       	rjmp	.+322    	; 0x5aa2 <__vector_39+0x230>
    5960:	77 c0       	rjmp	.+238    	; 0x5a50 <__vector_39+0x1de>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: M->START\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// send device address
		i2cSendByte(I2cDeviceAddrRW);
    5962:	80 91 fc 11 	lds	r24, 0x11FC
    5966:	0f c0       	rjmp	.+30     	; 0x5986 <__vector_39+0x114>
		#ifdef I2C_DEBUG
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MT->SLA_ACK or DATA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		if(I2cSendDataIndex < I2cSendDataLength)
    5968:	90 91 1d 12 	lds	r25, 0x121D
    596c:	80 91 1e 12 	lds	r24, 0x121E
    5970:	98 17       	cp	r25, r24
    5972:	08 f0       	brcs	.+2      	; 0x5976 <__vector_39+0x104>
    5974:	8e c0       	rjmp	.+284    	; 0x5a92 <__vector_39+0x220>
		{
			// send data
			i2cSendByte( I2cSendData[I2cSendDataIndex++] );
    5976:	e9 2f       	mov	r30, r25
    5978:	f0 e0       	ldi	r31, 0x00	; 0
    597a:	e3 50       	subi	r30, 0x03	; 3
    597c:	fe 4e       	sbci	r31, 0xEE	; 238
    597e:	80 81       	ld	r24, Z
    5980:	9f 5f       	subi	r25, 0xFF	; 255
    5982:	90 93 1d 12 	sts	0x121D, r25
}

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    5986:	80 93 bb 00 	sts	0x00BB, r24
    598a:	77 c0       	rjmp	.+238    	; 0x5a7a <__vector_39+0x208>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MR->DATA_NACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// store final received data byte
		I2cReceiveData[I2cReceiveDataIndex++] = inb(TWDR);
    598c:	80 91 3f 12 	lds	r24, 0x123F
    5990:	90 91 bb 00 	lds	r25, 0x00BB
    5994:	e8 2f       	mov	r30, r24
    5996:	f0 e0       	ldi	r31, 0x00	; 0
    5998:	e1 5e       	subi	r30, 0xE1	; 225
    599a:	fd 4e       	sbci	r31, 0xED	; 237
    599c:	90 83       	st	Z, r25
    599e:	8f 5f       	subi	r24, 0xFF	; 255
    59a0:	80 93 3f 12 	sts	0x123F, r24
    59a4:	76 c0       	rjmp	.+236    	; 0x5a92 <__vector_39+0x220>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MT->ARB_LOST\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// release bus
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    59a6:	80 91 bc 00 	lds	r24, 0x00BC
    59aa:	8f 70       	andi	r24, 0x0F	; 15
    59ac:	80 68       	ori	r24, 0x80	; 128
    59ae:	75 c0       	rjmp	.+234    	; 0x5a9a <__vector_39+0x228>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MR->DATA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// store received data byte
		I2cReceiveData[I2cReceiveDataIndex++] = inb(TWDR);
    59b0:	80 91 3f 12 	lds	r24, 0x123F
    59b4:	90 91 bb 00 	lds	r25, 0x00BB
    59b8:	e8 2f       	mov	r30, r24
    59ba:	f0 e0       	ldi	r31, 0x00	; 0
    59bc:	e1 5e       	subi	r30, 0xE1	; 225
    59be:	fd 4e       	sbci	r31, 0xED	; 237
    59c0:	90 83       	st	Z, r25
    59c2:	8f 5f       	subi	r24, 0xFF	; 255
    59c4:	80 93 3f 12 	sts	0x123F, r24
		#ifdef I2C_DEBUG
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MR->SLA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		if(I2cReceiveDataIndex < (I2cReceiveDataLength-1))
    59c8:	20 91 3f 12 	lds	r18, 0x123F
    59cc:	30 e0       	ldi	r19, 0x00	; 0
    59ce:	80 91 40 12 	lds	r24, 0x1240
    59d2:	90 e0       	ldi	r25, 0x00	; 0
    59d4:	01 97       	sbiw	r24, 0x01	; 1
    59d6:	28 17       	cp	r18, r24
    59d8:	39 07       	cpc	r19, r25
    59da:	0c f0       	brlt	.+2      	; 0x59de <__vector_39+0x16c>
    59dc:	4e c0       	rjmp	.+156    	; 0x5a7a <__vector_39+0x208>
    59de:	48 c0       	rjmp	.+144    	; 0x5a70 <__vector_39+0x1fe>
		rprintf("I2C: SR->SLA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// we are being addressed as slave for writing (data will be received from master)
		// set state
		I2cState = I2C_SLAVE_RX;
    59e0:	85 e0       	ldi	r24, 0x05	; 5
    59e2:	80 93 fb 11 	sts	0x11FB, r24
		// prepare buffer
		I2cReceiveDataIndex = 0;
    59e6:	10 92 3f 12 	sts	0x123F, r1
    59ea:	42 c0       	rjmp	.+132    	; 0x5a70 <__vector_39+0x1fe>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: SR->DATA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// get previously received data byte
		I2cReceiveData[I2cReceiveDataIndex++] = inb(TWDR);
    59ec:	80 91 3f 12 	lds	r24, 0x123F
    59f0:	90 91 bb 00 	lds	r25, 0x00BB
    59f4:	e8 2f       	mov	r30, r24
    59f6:	f0 e0       	ldi	r31, 0x00	; 0
    59f8:	e1 5e       	subi	r30, 0xE1	; 225
    59fa:	fd 4e       	sbci	r31, 0xED	; 237
    59fc:	90 83       	st	Z, r25
    59fe:	8f 5f       	subi	r24, 0xFF	; 255
    5a00:	80 93 3f 12 	sts	0x123F, r24
		// check receive buffer status
		if(I2cReceiveDataIndex < I2C_RECEIVE_DATA_BUFFER_SIZE)
    5a04:	80 32       	cpi	r24, 0x20	; 32
    5a06:	c8 f5       	brcc	.+114    	; 0x5a7a <__vector_39+0x208>
    5a08:	33 c0       	rjmp	.+102    	; 0x5a70 <__vector_39+0x1fe>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: SR->SR_STOP\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// switch to SR mode with SLA ACK
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    5a0a:	80 91 bc 00 	lds	r24, 0x00BC
    5a0e:	8f 70       	andi	r24, 0x0F	; 15
    5a10:	80 6c       	ori	r24, 0xC0	; 192
    5a12:	80 93 bc 00 	sts	0x00BC, r24
		// i2c receive is complete, call i2cSlaveReceive
		if(i2cSlaveReceive) i2cSlaveReceive(I2cReceiveDataIndex, I2cReceiveData);
    5a16:	e0 91 41 12 	lds	r30, 0x1241
    5a1a:	f0 91 42 12 	lds	r31, 0x1242
    5a1e:	30 97       	sbiw	r30, 0x00	; 0
    5a20:	f1 f1       	breq	.+124    	; 0x5a9e <__vector_39+0x22c>
    5a22:	80 91 3f 12 	lds	r24, 0x123F
    5a26:	6f e1       	ldi	r22, 0x1F	; 31
    5a28:	72 e1       	ldi	r23, 0x12	; 18
    5a2a:	09 95       	icall
    5a2c:	38 c0       	rjmp	.+112    	; 0x5a9e <__vector_39+0x22c>
		rprintf("I2C: ST->SLA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// we are being addressed as slave for reading (data must be transmitted back to master)
		// set state
		I2cState = I2C_SLAVE_TX;
    5a2e:	84 e0       	ldi	r24, 0x04	; 4
    5a30:	80 93 fb 11 	sts	0x11FB, r24
		// request data from application
		if(i2cSlaveTransmit) I2cSendDataLength = i2cSlaveTransmit(I2C_SEND_DATA_BUFFER_SIZE, I2cSendData);
    5a34:	e0 91 43 12 	lds	r30, 0x1243
    5a38:	f0 91 44 12 	lds	r31, 0x1244
    5a3c:	30 97       	sbiw	r30, 0x00	; 0
    5a3e:	31 f0       	breq	.+12     	; 0x5a4c <__vector_39+0x1da>
    5a40:	80 e2       	ldi	r24, 0x20	; 32
    5a42:	6d ef       	ldi	r22, 0xFD	; 253
    5a44:	71 e1       	ldi	r23, 0x11	; 17
    5a46:	09 95       	icall
    5a48:	80 93 1e 12 	sts	0x121E, r24
		// reset data index
		I2cSendDataIndex = 0;
    5a4c:	10 92 1d 12 	sts	0x121D, r1
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: ST->DATA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// transmit data byte
		outb(TWDR, I2cSendData[I2cSendDataIndex++]);
    5a50:	90 91 1d 12 	lds	r25, 0x121D
    5a54:	e9 2f       	mov	r30, r25
    5a56:	f0 e0       	ldi	r31, 0x00	; 0
    5a58:	e3 50       	subi	r30, 0x03	; 3
    5a5a:	fe 4e       	sbci	r31, 0xEE	; 238
    5a5c:	80 81       	ld	r24, Z
    5a5e:	80 93 bb 00 	sts	0x00BB, r24
    5a62:	9f 5f       	subi	r25, 0xFF	; 255
    5a64:	90 93 1d 12 	sts	0x121D, r25
		if(I2cSendDataIndex < I2cSendDataLength)
    5a68:	80 91 1e 12 	lds	r24, 0x121E
    5a6c:	98 17       	cp	r25, r24
    5a6e:	28 f4       	brcc	.+10     	; 0x5a7a <__vector_39+0x208>
			// expect ACK to data byte
			outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    5a70:	80 91 bc 00 	lds	r24, 0x00BC
    5a74:	8f 70       	andi	r24, 0x0F	; 15
    5a76:	80 6c       	ori	r24, 0xC0	; 192
    5a78:	04 c0       	rjmp	.+8      	; 0x5a82 <__vector_39+0x210>
		else
			// expect NACK to data byte
			outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    5a7a:	80 91 bc 00 	lds	r24, 0x00BC
    5a7e:	8f 70       	andi	r24, 0x0F	; 15
    5a80:	80 68       	ori	r24, 0x80	; 128
    5a82:	80 93 bc 00 	sts	0x00BC, r24
    5a86:	0d c0       	rjmp	.+26     	; 0x5aa2 <__vector_39+0x230>
		rprintf("I2C: ST->DATA_NACK or LAST_DATA\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// all done
		// switch to open slave
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    5a88:	80 91 bc 00 	lds	r24, 0x00BC
    5a8c:	8f 70       	andi	r24, 0x0F	; 15
    5a8e:	80 6c       	ori	r24, 0xC0	; 192
    5a90:	04 c0       	rjmp	.+8      	; 0x5a9a <__vector_39+0x228>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: BUS_ERROR\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// reset internal hardware and release bus
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTO)|BV(TWEA));
    5a92:	80 91 bc 00 	lds	r24, 0x00BC
    5a96:	8f 70       	andi	r24, 0x0F	; 15
    5a98:	80 6d       	ori	r24, 0xD0	; 208
    5a9a:	80 93 bc 00 	sts	0x00BC, r24
		// set state
		I2cState = I2C_IDLE;
    5a9e:	10 92 fb 11 	sts	0x11FB, r1
		break;
	}
}
    5aa2:	ff 91       	pop	r31
    5aa4:	ef 91       	pop	r30
    5aa6:	bf 91       	pop	r27
    5aa8:	af 91       	pop	r26
    5aaa:	9f 91       	pop	r25
    5aac:	8f 91       	pop	r24
    5aae:	7f 91       	pop	r23
    5ab0:	6f 91       	pop	r22
    5ab2:	5f 91       	pop	r21
    5ab4:	4f 91       	pop	r20
    5ab6:	3f 91       	pop	r19
    5ab8:	2f 91       	pop	r18
    5aba:	0f 90       	pop	r0
    5abc:	0f be       	out	0x3f, r0	; 63
    5abe:	0f 90       	pop	r0
    5ac0:	1f 90       	pop	r1
    5ac2:	18 95       	reti

00005ac4 <i2cGetState>:

eI2cStateType i2cGetState(void)
{
	return I2cState;
    5ac4:	80 91 fb 11 	lds	r24, 0x11FB
}
    5ac8:	08 95       	ret

00005aca <exit>:
    5aca:	f8 94       	cli
    5acc:	0c 94 25 30 	jmp	0x604a	; 0x604a <_exit>

00005ad0 <memcpy>:
    5ad0:	fb 01       	movw	r30, r22
    5ad2:	dc 01       	movw	r26, r24
    5ad4:	02 c0       	rjmp	.+4      	; 0x5ada <memcpy+0xa>
    5ad6:	01 90       	ld	r0, Z+
    5ad8:	0d 92       	st	X+, r0
    5ada:	41 50       	subi	r20, 0x01	; 1
    5adc:	50 40       	sbci	r21, 0x00	; 0
    5ade:	d8 f7       	brcc	.-10     	; 0x5ad6 <memcpy+0x6>
    5ae0:	08 95       	ret

00005ae2 <memset>:
    5ae2:	dc 01       	movw	r26, r24
    5ae4:	01 c0       	rjmp	.+2      	; 0x5ae8 <memset+0x6>
    5ae6:	6d 93       	st	X+, r22
    5ae8:	41 50       	subi	r20, 0x01	; 1
    5aea:	50 40       	sbci	r21, 0x00	; 0
    5aec:	e0 f7       	brcc	.-8      	; 0x5ae6 <memset+0x4>
    5aee:	08 95       	ret

00005af0 <strncpy>:
    5af0:	fb 01       	movw	r30, r22
    5af2:	dc 01       	movw	r26, r24
    5af4:	41 50       	subi	r20, 0x01	; 1
    5af6:	50 40       	sbci	r21, 0x00	; 0
    5af8:	48 f0       	brcs	.+18     	; 0x5b0c <strncpy+0x1c>
    5afa:	01 90       	ld	r0, Z+
    5afc:	0d 92       	st	X+, r0
    5afe:	00 20       	and	r0, r0
    5b00:	c9 f7       	brne	.-14     	; 0x5af4 <strncpy+0x4>
    5b02:	01 c0       	rjmp	.+2      	; 0x5b06 <strncpy+0x16>
    5b04:	1d 92       	st	X+, r1
    5b06:	41 50       	subi	r20, 0x01	; 1
    5b08:	50 40       	sbci	r21, 0x00	; 0
    5b0a:	e0 f7       	brcc	.-8      	; 0x5b04 <strncpy+0x14>
    5b0c:	08 95       	ret

00005b0e <__subsf3>:
    5b0e:	50 58       	subi	r21, 0x80	; 128

00005b10 <__addsf3>:
    5b10:	bb 27       	eor	r27, r27
    5b12:	aa 27       	eor	r26, r26
    5b14:	0e d0       	rcall	.+28     	; 0x5b32 <__addsf3x>
    5b16:	75 c1       	rjmp	.+746    	; 0x5e02 <__fp_round>
    5b18:	66 d1       	rcall	.+716    	; 0x5de6 <__fp_pscA>
    5b1a:	30 f0       	brcs	.+12     	; 0x5b28 <__addsf3+0x18>
    5b1c:	6b d1       	rcall	.+726    	; 0x5df4 <__fp_pscB>
    5b1e:	20 f0       	brcs	.+8      	; 0x5b28 <__addsf3+0x18>
    5b20:	31 f4       	brne	.+12     	; 0x5b2e <__addsf3+0x1e>
    5b22:	9f 3f       	cpi	r25, 0xFF	; 255
    5b24:	11 f4       	brne	.+4      	; 0x5b2a <__addsf3+0x1a>
    5b26:	1e f4       	brtc	.+6      	; 0x5b2e <__addsf3+0x1e>
    5b28:	5b c1       	rjmp	.+694    	; 0x5de0 <__fp_nan>
    5b2a:	0e f4       	brtc	.+2      	; 0x5b2e <__addsf3+0x1e>
    5b2c:	e0 95       	com	r30
    5b2e:	e7 fb       	bst	r30, 7
    5b30:	51 c1       	rjmp	.+674    	; 0x5dd4 <__fp_inf>

00005b32 <__addsf3x>:
    5b32:	e9 2f       	mov	r30, r25
    5b34:	77 d1       	rcall	.+750    	; 0x5e24 <__fp_split3>
    5b36:	80 f3       	brcs	.-32     	; 0x5b18 <__addsf3+0x8>
    5b38:	ba 17       	cp	r27, r26
    5b3a:	62 07       	cpc	r22, r18
    5b3c:	73 07       	cpc	r23, r19
    5b3e:	84 07       	cpc	r24, r20
    5b40:	95 07       	cpc	r25, r21
    5b42:	18 f0       	brcs	.+6      	; 0x5b4a <__addsf3x+0x18>
    5b44:	71 f4       	brne	.+28     	; 0x5b62 <__addsf3x+0x30>
    5b46:	9e f5       	brtc	.+102    	; 0x5bae <__addsf3x+0x7c>
    5b48:	8f c1       	rjmp	.+798    	; 0x5e68 <__fp_zero>
    5b4a:	0e f4       	brtc	.+2      	; 0x5b4e <__addsf3x+0x1c>
    5b4c:	e0 95       	com	r30
    5b4e:	0b 2e       	mov	r0, r27
    5b50:	ba 2f       	mov	r27, r26
    5b52:	a0 2d       	mov	r26, r0
    5b54:	0b 01       	movw	r0, r22
    5b56:	b9 01       	movw	r22, r18
    5b58:	90 01       	movw	r18, r0
    5b5a:	0c 01       	movw	r0, r24
    5b5c:	ca 01       	movw	r24, r20
    5b5e:	a0 01       	movw	r20, r0
    5b60:	11 24       	eor	r1, r1
    5b62:	ff 27       	eor	r31, r31
    5b64:	59 1b       	sub	r21, r25
    5b66:	99 f0       	breq	.+38     	; 0x5b8e <__addsf3x+0x5c>
    5b68:	59 3f       	cpi	r21, 0xF9	; 249
    5b6a:	50 f4       	brcc	.+20     	; 0x5b80 <__addsf3x+0x4e>
    5b6c:	50 3e       	cpi	r21, 0xE0	; 224
    5b6e:	68 f1       	brcs	.+90     	; 0x5bca <__addsf3x+0x98>
    5b70:	1a 16       	cp	r1, r26
    5b72:	f0 40       	sbci	r31, 0x00	; 0
    5b74:	a2 2f       	mov	r26, r18
    5b76:	23 2f       	mov	r18, r19
    5b78:	34 2f       	mov	r19, r20
    5b7a:	44 27       	eor	r20, r20
    5b7c:	58 5f       	subi	r21, 0xF8	; 248
    5b7e:	f3 cf       	rjmp	.-26     	; 0x5b66 <__addsf3x+0x34>
    5b80:	46 95       	lsr	r20
    5b82:	37 95       	ror	r19
    5b84:	27 95       	ror	r18
    5b86:	a7 95       	ror	r26
    5b88:	f0 40       	sbci	r31, 0x00	; 0
    5b8a:	53 95       	inc	r21
    5b8c:	c9 f7       	brne	.-14     	; 0x5b80 <__addsf3x+0x4e>
    5b8e:	7e f4       	brtc	.+30     	; 0x5bae <__addsf3x+0x7c>
    5b90:	1f 16       	cp	r1, r31
    5b92:	ba 0b       	sbc	r27, r26
    5b94:	62 0b       	sbc	r22, r18
    5b96:	73 0b       	sbc	r23, r19
    5b98:	84 0b       	sbc	r24, r20
    5b9a:	ba f0       	brmi	.+46     	; 0x5bca <__addsf3x+0x98>
    5b9c:	91 50       	subi	r25, 0x01	; 1
    5b9e:	a1 f0       	breq	.+40     	; 0x5bc8 <__addsf3x+0x96>
    5ba0:	ff 0f       	add	r31, r31
    5ba2:	bb 1f       	adc	r27, r27
    5ba4:	66 1f       	adc	r22, r22
    5ba6:	77 1f       	adc	r23, r23
    5ba8:	88 1f       	adc	r24, r24
    5baa:	c2 f7       	brpl	.-16     	; 0x5b9c <__addsf3x+0x6a>
    5bac:	0e c0       	rjmp	.+28     	; 0x5bca <__addsf3x+0x98>
    5bae:	ba 0f       	add	r27, r26
    5bb0:	62 1f       	adc	r22, r18
    5bb2:	73 1f       	adc	r23, r19
    5bb4:	84 1f       	adc	r24, r20
    5bb6:	48 f4       	brcc	.+18     	; 0x5bca <__addsf3x+0x98>
    5bb8:	87 95       	ror	r24
    5bba:	77 95       	ror	r23
    5bbc:	67 95       	ror	r22
    5bbe:	b7 95       	ror	r27
    5bc0:	f7 95       	ror	r31
    5bc2:	9e 3f       	cpi	r25, 0xFE	; 254
    5bc4:	08 f0       	brcs	.+2      	; 0x5bc8 <__addsf3x+0x96>
    5bc6:	b3 cf       	rjmp	.-154    	; 0x5b2e <__addsf3+0x1e>
    5bc8:	93 95       	inc	r25
    5bca:	88 0f       	add	r24, r24
    5bcc:	08 f0       	brcs	.+2      	; 0x5bd0 <__addsf3x+0x9e>
    5bce:	99 27       	eor	r25, r25
    5bd0:	ee 0f       	add	r30, r30
    5bd2:	97 95       	ror	r25
    5bd4:	87 95       	ror	r24
    5bd6:	08 95       	ret

00005bd8 <__cmpsf2>:
    5bd8:	d9 d0       	rcall	.+434    	; 0x5d8c <__fp_cmp>
    5bda:	08 f4       	brcc	.+2      	; 0x5bde <__cmpsf2+0x6>
    5bdc:	81 e0       	ldi	r24, 0x01	; 1
    5bde:	08 95       	ret

00005be0 <__divsf3>:
    5be0:	0c d0       	rcall	.+24     	; 0x5bfa <__divsf3x>
    5be2:	0f c1       	rjmp	.+542    	; 0x5e02 <__fp_round>
    5be4:	07 d1       	rcall	.+526    	; 0x5df4 <__fp_pscB>
    5be6:	40 f0       	brcs	.+16     	; 0x5bf8 <__divsf3+0x18>
    5be8:	fe d0       	rcall	.+508    	; 0x5de6 <__fp_pscA>
    5bea:	30 f0       	brcs	.+12     	; 0x5bf8 <__divsf3+0x18>
    5bec:	21 f4       	brne	.+8      	; 0x5bf6 <__divsf3+0x16>
    5bee:	5f 3f       	cpi	r21, 0xFF	; 255
    5bf0:	19 f0       	breq	.+6      	; 0x5bf8 <__divsf3+0x18>
    5bf2:	f0 c0       	rjmp	.+480    	; 0x5dd4 <__fp_inf>
    5bf4:	51 11       	cpse	r21, r1
    5bf6:	39 c1       	rjmp	.+626    	; 0x5e6a <__fp_szero>
    5bf8:	f3 c0       	rjmp	.+486    	; 0x5de0 <__fp_nan>

00005bfa <__divsf3x>:
    5bfa:	14 d1       	rcall	.+552    	; 0x5e24 <__fp_split3>
    5bfc:	98 f3       	brcs	.-26     	; 0x5be4 <__divsf3+0x4>

00005bfe <__divsf3_pse>:
    5bfe:	99 23       	and	r25, r25
    5c00:	c9 f3       	breq	.-14     	; 0x5bf4 <__divsf3+0x14>
    5c02:	55 23       	and	r21, r21
    5c04:	b1 f3       	breq	.-20     	; 0x5bf2 <__divsf3+0x12>
    5c06:	95 1b       	sub	r25, r21
    5c08:	55 0b       	sbc	r21, r21
    5c0a:	bb 27       	eor	r27, r27
    5c0c:	aa 27       	eor	r26, r26
    5c0e:	62 17       	cp	r22, r18
    5c10:	73 07       	cpc	r23, r19
    5c12:	84 07       	cpc	r24, r20
    5c14:	38 f0       	brcs	.+14     	; 0x5c24 <__divsf3_pse+0x26>
    5c16:	9f 5f       	subi	r25, 0xFF	; 255
    5c18:	5f 4f       	sbci	r21, 0xFF	; 255
    5c1a:	22 0f       	add	r18, r18
    5c1c:	33 1f       	adc	r19, r19
    5c1e:	44 1f       	adc	r20, r20
    5c20:	aa 1f       	adc	r26, r26
    5c22:	a9 f3       	breq	.-22     	; 0x5c0e <__divsf3_pse+0x10>
    5c24:	33 d0       	rcall	.+102    	; 0x5c8c <__divsf3_pse+0x8e>
    5c26:	0e 2e       	mov	r0, r30
    5c28:	3a f0       	brmi	.+14     	; 0x5c38 <__divsf3_pse+0x3a>
    5c2a:	e0 e8       	ldi	r30, 0x80	; 128
    5c2c:	30 d0       	rcall	.+96     	; 0x5c8e <__divsf3_pse+0x90>
    5c2e:	91 50       	subi	r25, 0x01	; 1
    5c30:	50 40       	sbci	r21, 0x00	; 0
    5c32:	e6 95       	lsr	r30
    5c34:	00 1c       	adc	r0, r0
    5c36:	ca f7       	brpl	.-14     	; 0x5c2a <__divsf3_pse+0x2c>
    5c38:	29 d0       	rcall	.+82     	; 0x5c8c <__divsf3_pse+0x8e>
    5c3a:	fe 2f       	mov	r31, r30
    5c3c:	27 d0       	rcall	.+78     	; 0x5c8c <__divsf3_pse+0x8e>
    5c3e:	66 0f       	add	r22, r22
    5c40:	77 1f       	adc	r23, r23
    5c42:	88 1f       	adc	r24, r24
    5c44:	bb 1f       	adc	r27, r27
    5c46:	26 17       	cp	r18, r22
    5c48:	37 07       	cpc	r19, r23
    5c4a:	48 07       	cpc	r20, r24
    5c4c:	ab 07       	cpc	r26, r27
    5c4e:	b0 e8       	ldi	r27, 0x80	; 128
    5c50:	09 f0       	breq	.+2      	; 0x5c54 <__divsf3_pse+0x56>
    5c52:	bb 0b       	sbc	r27, r27
    5c54:	80 2d       	mov	r24, r0
    5c56:	bf 01       	movw	r22, r30
    5c58:	ff 27       	eor	r31, r31
    5c5a:	93 58       	subi	r25, 0x83	; 131
    5c5c:	5f 4f       	sbci	r21, 0xFF	; 255
    5c5e:	2a f0       	brmi	.+10     	; 0x5c6a <__divsf3_pse+0x6c>
    5c60:	9e 3f       	cpi	r25, 0xFE	; 254
    5c62:	51 05       	cpc	r21, r1
    5c64:	68 f0       	brcs	.+26     	; 0x5c80 <__divsf3_pse+0x82>
    5c66:	b6 c0       	rjmp	.+364    	; 0x5dd4 <__fp_inf>
    5c68:	00 c1       	rjmp	.+512    	; 0x5e6a <__fp_szero>
    5c6a:	5f 3f       	cpi	r21, 0xFF	; 255
    5c6c:	ec f3       	brlt	.-6      	; 0x5c68 <__divsf3_pse+0x6a>
    5c6e:	98 3e       	cpi	r25, 0xE8	; 232
    5c70:	dc f3       	brlt	.-10     	; 0x5c68 <__divsf3_pse+0x6a>
    5c72:	86 95       	lsr	r24
    5c74:	77 95       	ror	r23
    5c76:	67 95       	ror	r22
    5c78:	b7 95       	ror	r27
    5c7a:	f7 95       	ror	r31
    5c7c:	9f 5f       	subi	r25, 0xFF	; 255
    5c7e:	c9 f7       	brne	.-14     	; 0x5c72 <__divsf3_pse+0x74>
    5c80:	88 0f       	add	r24, r24
    5c82:	91 1d       	adc	r25, r1
    5c84:	96 95       	lsr	r25
    5c86:	87 95       	ror	r24
    5c88:	97 f9       	bld	r25, 7
    5c8a:	08 95       	ret
    5c8c:	e1 e0       	ldi	r30, 0x01	; 1
    5c8e:	66 0f       	add	r22, r22
    5c90:	77 1f       	adc	r23, r23
    5c92:	88 1f       	adc	r24, r24
    5c94:	bb 1f       	adc	r27, r27
    5c96:	62 17       	cp	r22, r18
    5c98:	73 07       	cpc	r23, r19
    5c9a:	84 07       	cpc	r24, r20
    5c9c:	ba 07       	cpc	r27, r26
    5c9e:	20 f0       	brcs	.+8      	; 0x5ca8 <__divsf3_pse+0xaa>
    5ca0:	62 1b       	sub	r22, r18
    5ca2:	73 0b       	sbc	r23, r19
    5ca4:	84 0b       	sbc	r24, r20
    5ca6:	ba 0b       	sbc	r27, r26
    5ca8:	ee 1f       	adc	r30, r30
    5caa:	88 f7       	brcc	.-30     	; 0x5c8e <__divsf3_pse+0x90>
    5cac:	e0 95       	com	r30
    5cae:	08 95       	ret

00005cb0 <__fixsfsi>:
    5cb0:	04 d0       	rcall	.+8      	; 0x5cba <__fixunssfsi>
    5cb2:	68 94       	set
    5cb4:	b1 11       	cpse	r27, r1
    5cb6:	d9 c0       	rjmp	.+434    	; 0x5e6a <__fp_szero>
    5cb8:	08 95       	ret

00005cba <__fixunssfsi>:
    5cba:	bc d0       	rcall	.+376    	; 0x5e34 <__fp_splitA>
    5cbc:	88 f0       	brcs	.+34     	; 0x5ce0 <__fixunssfsi+0x26>
    5cbe:	9f 57       	subi	r25, 0x7F	; 127
    5cc0:	90 f0       	brcs	.+36     	; 0x5ce6 <__fixunssfsi+0x2c>
    5cc2:	b9 2f       	mov	r27, r25
    5cc4:	99 27       	eor	r25, r25
    5cc6:	b7 51       	subi	r27, 0x17	; 23
    5cc8:	a0 f0       	brcs	.+40     	; 0x5cf2 <__fixunssfsi+0x38>
    5cca:	d1 f0       	breq	.+52     	; 0x5d00 <__fixunssfsi+0x46>
    5ccc:	66 0f       	add	r22, r22
    5cce:	77 1f       	adc	r23, r23
    5cd0:	88 1f       	adc	r24, r24
    5cd2:	99 1f       	adc	r25, r25
    5cd4:	1a f0       	brmi	.+6      	; 0x5cdc <__fixunssfsi+0x22>
    5cd6:	ba 95       	dec	r27
    5cd8:	c9 f7       	brne	.-14     	; 0x5ccc <__fixunssfsi+0x12>
    5cda:	12 c0       	rjmp	.+36     	; 0x5d00 <__fixunssfsi+0x46>
    5cdc:	b1 30       	cpi	r27, 0x01	; 1
    5cde:	81 f0       	breq	.+32     	; 0x5d00 <__fixunssfsi+0x46>
    5ce0:	c3 d0       	rcall	.+390    	; 0x5e68 <__fp_zero>
    5ce2:	b1 e0       	ldi	r27, 0x01	; 1
    5ce4:	08 95       	ret
    5ce6:	c0 c0       	rjmp	.+384    	; 0x5e68 <__fp_zero>
    5ce8:	67 2f       	mov	r22, r23
    5cea:	78 2f       	mov	r23, r24
    5cec:	88 27       	eor	r24, r24
    5cee:	b8 5f       	subi	r27, 0xF8	; 248
    5cf0:	39 f0       	breq	.+14     	; 0x5d00 <__fixunssfsi+0x46>
    5cf2:	b9 3f       	cpi	r27, 0xF9	; 249
    5cf4:	cc f3       	brlt	.-14     	; 0x5ce8 <__fixunssfsi+0x2e>
    5cf6:	86 95       	lsr	r24
    5cf8:	77 95       	ror	r23
    5cfa:	67 95       	ror	r22
    5cfc:	b3 95       	inc	r27
    5cfe:	d9 f7       	brne	.-10     	; 0x5cf6 <__fixunssfsi+0x3c>
    5d00:	3e f4       	brtc	.+14     	; 0x5d10 <__fixunssfsi+0x56>
    5d02:	90 95       	com	r25
    5d04:	80 95       	com	r24
    5d06:	70 95       	com	r23
    5d08:	61 95       	neg	r22
    5d0a:	7f 4f       	sbci	r23, 0xFF	; 255
    5d0c:	8f 4f       	sbci	r24, 0xFF	; 255
    5d0e:	9f 4f       	sbci	r25, 0xFF	; 255
    5d10:	08 95       	ret

00005d12 <__floatunsisf>:
    5d12:	e8 94       	clt
    5d14:	09 c0       	rjmp	.+18     	; 0x5d28 <__floatsisf+0x12>

00005d16 <__floatsisf>:
    5d16:	97 fb       	bst	r25, 7
    5d18:	3e f4       	brtc	.+14     	; 0x5d28 <__floatsisf+0x12>
    5d1a:	90 95       	com	r25
    5d1c:	80 95       	com	r24
    5d1e:	70 95       	com	r23
    5d20:	61 95       	neg	r22
    5d22:	7f 4f       	sbci	r23, 0xFF	; 255
    5d24:	8f 4f       	sbci	r24, 0xFF	; 255
    5d26:	9f 4f       	sbci	r25, 0xFF	; 255
    5d28:	99 23       	and	r25, r25
    5d2a:	a9 f0       	breq	.+42     	; 0x5d56 <__floatsisf+0x40>
    5d2c:	f9 2f       	mov	r31, r25
    5d2e:	96 e9       	ldi	r25, 0x96	; 150
    5d30:	bb 27       	eor	r27, r27
    5d32:	93 95       	inc	r25
    5d34:	f6 95       	lsr	r31
    5d36:	87 95       	ror	r24
    5d38:	77 95       	ror	r23
    5d3a:	67 95       	ror	r22
    5d3c:	b7 95       	ror	r27
    5d3e:	f1 11       	cpse	r31, r1
    5d40:	f8 cf       	rjmp	.-16     	; 0x5d32 <__floatsisf+0x1c>
    5d42:	fa f4       	brpl	.+62     	; 0x5d82 <__floatsisf+0x6c>
    5d44:	bb 0f       	add	r27, r27
    5d46:	11 f4       	brne	.+4      	; 0x5d4c <__floatsisf+0x36>
    5d48:	60 ff       	sbrs	r22, 0
    5d4a:	1b c0       	rjmp	.+54     	; 0x5d82 <__floatsisf+0x6c>
    5d4c:	6f 5f       	subi	r22, 0xFF	; 255
    5d4e:	7f 4f       	sbci	r23, 0xFF	; 255
    5d50:	8f 4f       	sbci	r24, 0xFF	; 255
    5d52:	9f 4f       	sbci	r25, 0xFF	; 255
    5d54:	16 c0       	rjmp	.+44     	; 0x5d82 <__floatsisf+0x6c>
    5d56:	88 23       	and	r24, r24
    5d58:	11 f0       	breq	.+4      	; 0x5d5e <__floatsisf+0x48>
    5d5a:	96 e9       	ldi	r25, 0x96	; 150
    5d5c:	11 c0       	rjmp	.+34     	; 0x5d80 <__floatsisf+0x6a>
    5d5e:	77 23       	and	r23, r23
    5d60:	21 f0       	breq	.+8      	; 0x5d6a <__floatsisf+0x54>
    5d62:	9e e8       	ldi	r25, 0x8E	; 142
    5d64:	87 2f       	mov	r24, r23
    5d66:	76 2f       	mov	r23, r22
    5d68:	05 c0       	rjmp	.+10     	; 0x5d74 <__floatsisf+0x5e>
    5d6a:	66 23       	and	r22, r22
    5d6c:	71 f0       	breq	.+28     	; 0x5d8a <__floatsisf+0x74>
    5d6e:	96 e8       	ldi	r25, 0x86	; 134
    5d70:	86 2f       	mov	r24, r22
    5d72:	70 e0       	ldi	r23, 0x00	; 0
    5d74:	60 e0       	ldi	r22, 0x00	; 0
    5d76:	2a f0       	brmi	.+10     	; 0x5d82 <__floatsisf+0x6c>
    5d78:	9a 95       	dec	r25
    5d7a:	66 0f       	add	r22, r22
    5d7c:	77 1f       	adc	r23, r23
    5d7e:	88 1f       	adc	r24, r24
    5d80:	da f7       	brpl	.-10     	; 0x5d78 <__floatsisf+0x62>
    5d82:	88 0f       	add	r24, r24
    5d84:	96 95       	lsr	r25
    5d86:	87 95       	ror	r24
    5d88:	97 f9       	bld	r25, 7
    5d8a:	08 95       	ret

00005d8c <__fp_cmp>:
    5d8c:	99 0f       	add	r25, r25
    5d8e:	00 08       	sbc	r0, r0
    5d90:	55 0f       	add	r21, r21
    5d92:	aa 0b       	sbc	r26, r26
    5d94:	e0 e8       	ldi	r30, 0x80	; 128
    5d96:	fe ef       	ldi	r31, 0xFE	; 254
    5d98:	16 16       	cp	r1, r22
    5d9a:	17 06       	cpc	r1, r23
    5d9c:	e8 07       	cpc	r30, r24
    5d9e:	f9 07       	cpc	r31, r25
    5da0:	c0 f0       	brcs	.+48     	; 0x5dd2 <__fp_cmp+0x46>
    5da2:	12 16       	cp	r1, r18
    5da4:	13 06       	cpc	r1, r19
    5da6:	e4 07       	cpc	r30, r20
    5da8:	f5 07       	cpc	r31, r21
    5daa:	98 f0       	brcs	.+38     	; 0x5dd2 <__fp_cmp+0x46>
    5dac:	62 1b       	sub	r22, r18
    5dae:	73 0b       	sbc	r23, r19
    5db0:	84 0b       	sbc	r24, r20
    5db2:	95 0b       	sbc	r25, r21
    5db4:	39 f4       	brne	.+14     	; 0x5dc4 <__fp_cmp+0x38>
    5db6:	0a 26       	eor	r0, r26
    5db8:	61 f0       	breq	.+24     	; 0x5dd2 <__fp_cmp+0x46>
    5dba:	23 2b       	or	r18, r19
    5dbc:	24 2b       	or	r18, r20
    5dbe:	25 2b       	or	r18, r21
    5dc0:	21 f4       	brne	.+8      	; 0x5dca <__fp_cmp+0x3e>
    5dc2:	08 95       	ret
    5dc4:	0a 26       	eor	r0, r26
    5dc6:	09 f4       	brne	.+2      	; 0x5dca <__fp_cmp+0x3e>
    5dc8:	a1 40       	sbci	r26, 0x01	; 1
    5dca:	a6 95       	lsr	r26
    5dcc:	8f ef       	ldi	r24, 0xFF	; 255
    5dce:	81 1d       	adc	r24, r1
    5dd0:	81 1d       	adc	r24, r1
    5dd2:	08 95       	ret

00005dd4 <__fp_inf>:
    5dd4:	97 f9       	bld	r25, 7
    5dd6:	9f 67       	ori	r25, 0x7F	; 127
    5dd8:	80 e8       	ldi	r24, 0x80	; 128
    5dda:	70 e0       	ldi	r23, 0x00	; 0
    5ddc:	60 e0       	ldi	r22, 0x00	; 0
    5dde:	08 95       	ret

00005de0 <__fp_nan>:
    5de0:	9f ef       	ldi	r25, 0xFF	; 255
    5de2:	80 ec       	ldi	r24, 0xC0	; 192
    5de4:	08 95       	ret

00005de6 <__fp_pscA>:
    5de6:	00 24       	eor	r0, r0
    5de8:	0a 94       	dec	r0
    5dea:	16 16       	cp	r1, r22
    5dec:	17 06       	cpc	r1, r23
    5dee:	18 06       	cpc	r1, r24
    5df0:	09 06       	cpc	r0, r25
    5df2:	08 95       	ret

00005df4 <__fp_pscB>:
    5df4:	00 24       	eor	r0, r0
    5df6:	0a 94       	dec	r0
    5df8:	12 16       	cp	r1, r18
    5dfa:	13 06       	cpc	r1, r19
    5dfc:	14 06       	cpc	r1, r20
    5dfe:	05 06       	cpc	r0, r21
    5e00:	08 95       	ret

00005e02 <__fp_round>:
    5e02:	09 2e       	mov	r0, r25
    5e04:	03 94       	inc	r0
    5e06:	00 0c       	add	r0, r0
    5e08:	11 f4       	brne	.+4      	; 0x5e0e <__fp_round+0xc>
    5e0a:	88 23       	and	r24, r24
    5e0c:	52 f0       	brmi	.+20     	; 0x5e22 <__fp_round+0x20>
    5e0e:	bb 0f       	add	r27, r27
    5e10:	40 f4       	brcc	.+16     	; 0x5e22 <__fp_round+0x20>
    5e12:	bf 2b       	or	r27, r31
    5e14:	11 f4       	brne	.+4      	; 0x5e1a <__fp_round+0x18>
    5e16:	60 ff       	sbrs	r22, 0
    5e18:	04 c0       	rjmp	.+8      	; 0x5e22 <__fp_round+0x20>
    5e1a:	6f 5f       	subi	r22, 0xFF	; 255
    5e1c:	7f 4f       	sbci	r23, 0xFF	; 255
    5e1e:	8f 4f       	sbci	r24, 0xFF	; 255
    5e20:	9f 4f       	sbci	r25, 0xFF	; 255
    5e22:	08 95       	ret

00005e24 <__fp_split3>:
    5e24:	57 fd       	sbrc	r21, 7
    5e26:	90 58       	subi	r25, 0x80	; 128
    5e28:	44 0f       	add	r20, r20
    5e2a:	55 1f       	adc	r21, r21
    5e2c:	59 f0       	breq	.+22     	; 0x5e44 <__fp_splitA+0x10>
    5e2e:	5f 3f       	cpi	r21, 0xFF	; 255
    5e30:	71 f0       	breq	.+28     	; 0x5e4e <__fp_splitA+0x1a>
    5e32:	47 95       	ror	r20

00005e34 <__fp_splitA>:
    5e34:	88 0f       	add	r24, r24
    5e36:	97 fb       	bst	r25, 7
    5e38:	99 1f       	adc	r25, r25
    5e3a:	61 f0       	breq	.+24     	; 0x5e54 <__fp_splitA+0x20>
    5e3c:	9f 3f       	cpi	r25, 0xFF	; 255
    5e3e:	79 f0       	breq	.+30     	; 0x5e5e <__fp_splitA+0x2a>
    5e40:	87 95       	ror	r24
    5e42:	08 95       	ret
    5e44:	12 16       	cp	r1, r18
    5e46:	13 06       	cpc	r1, r19
    5e48:	14 06       	cpc	r1, r20
    5e4a:	55 1f       	adc	r21, r21
    5e4c:	f2 cf       	rjmp	.-28     	; 0x5e32 <__fp_split3+0xe>
    5e4e:	46 95       	lsr	r20
    5e50:	f1 df       	rcall	.-30     	; 0x5e34 <__fp_splitA>
    5e52:	08 c0       	rjmp	.+16     	; 0x5e64 <__fp_splitA+0x30>
    5e54:	16 16       	cp	r1, r22
    5e56:	17 06       	cpc	r1, r23
    5e58:	18 06       	cpc	r1, r24
    5e5a:	99 1f       	adc	r25, r25
    5e5c:	f1 cf       	rjmp	.-30     	; 0x5e40 <__fp_splitA+0xc>
    5e5e:	86 95       	lsr	r24
    5e60:	71 05       	cpc	r23, r1
    5e62:	61 05       	cpc	r22, r1
    5e64:	08 94       	sec
    5e66:	08 95       	ret

00005e68 <__fp_zero>:
    5e68:	e8 94       	clt

00005e6a <__fp_szero>:
    5e6a:	bb 27       	eor	r27, r27
    5e6c:	66 27       	eor	r22, r22
    5e6e:	77 27       	eor	r23, r23
    5e70:	cb 01       	movw	r24, r22
    5e72:	97 f9       	bld	r25, 7
    5e74:	08 95       	ret

00005e76 <__gesf2>:
    5e76:	8a df       	rcall	.-236    	; 0x5d8c <__fp_cmp>
    5e78:	08 f4       	brcc	.+2      	; 0x5e7c <__gesf2+0x6>
    5e7a:	8f ef       	ldi	r24, 0xFF	; 255
    5e7c:	08 95       	ret

00005e7e <__mulsf3>:
    5e7e:	0b d0       	rcall	.+22     	; 0x5e96 <__mulsf3x>
    5e80:	c0 cf       	rjmp	.-128    	; 0x5e02 <__fp_round>
    5e82:	b1 df       	rcall	.-158    	; 0x5de6 <__fp_pscA>
    5e84:	28 f0       	brcs	.+10     	; 0x5e90 <__mulsf3+0x12>
    5e86:	b6 df       	rcall	.-148    	; 0x5df4 <__fp_pscB>
    5e88:	18 f0       	brcs	.+6      	; 0x5e90 <__mulsf3+0x12>
    5e8a:	95 23       	and	r25, r21
    5e8c:	09 f0       	breq	.+2      	; 0x5e90 <__mulsf3+0x12>
    5e8e:	a2 cf       	rjmp	.-188    	; 0x5dd4 <__fp_inf>
    5e90:	a7 cf       	rjmp	.-178    	; 0x5de0 <__fp_nan>
    5e92:	11 24       	eor	r1, r1
    5e94:	ea cf       	rjmp	.-44     	; 0x5e6a <__fp_szero>

00005e96 <__mulsf3x>:
    5e96:	c6 df       	rcall	.-116    	; 0x5e24 <__fp_split3>
    5e98:	a0 f3       	brcs	.-24     	; 0x5e82 <__mulsf3+0x4>

00005e9a <__mulsf3_pse>:
    5e9a:	95 9f       	mul	r25, r21
    5e9c:	d1 f3       	breq	.-12     	; 0x5e92 <__mulsf3+0x14>
    5e9e:	95 0f       	add	r25, r21
    5ea0:	50 e0       	ldi	r21, 0x00	; 0
    5ea2:	55 1f       	adc	r21, r21
    5ea4:	62 9f       	mul	r22, r18
    5ea6:	f0 01       	movw	r30, r0
    5ea8:	72 9f       	mul	r23, r18
    5eaa:	bb 27       	eor	r27, r27
    5eac:	f0 0d       	add	r31, r0
    5eae:	b1 1d       	adc	r27, r1
    5eb0:	63 9f       	mul	r22, r19
    5eb2:	aa 27       	eor	r26, r26
    5eb4:	f0 0d       	add	r31, r0
    5eb6:	b1 1d       	adc	r27, r1
    5eb8:	aa 1f       	adc	r26, r26
    5eba:	64 9f       	mul	r22, r20
    5ebc:	66 27       	eor	r22, r22
    5ebe:	b0 0d       	add	r27, r0
    5ec0:	a1 1d       	adc	r26, r1
    5ec2:	66 1f       	adc	r22, r22
    5ec4:	82 9f       	mul	r24, r18
    5ec6:	22 27       	eor	r18, r18
    5ec8:	b0 0d       	add	r27, r0
    5eca:	a1 1d       	adc	r26, r1
    5ecc:	62 1f       	adc	r22, r18
    5ece:	73 9f       	mul	r23, r19
    5ed0:	b0 0d       	add	r27, r0
    5ed2:	a1 1d       	adc	r26, r1
    5ed4:	62 1f       	adc	r22, r18
    5ed6:	83 9f       	mul	r24, r19
    5ed8:	a0 0d       	add	r26, r0
    5eda:	61 1d       	adc	r22, r1
    5edc:	22 1f       	adc	r18, r18
    5ede:	74 9f       	mul	r23, r20
    5ee0:	33 27       	eor	r19, r19
    5ee2:	a0 0d       	add	r26, r0
    5ee4:	61 1d       	adc	r22, r1
    5ee6:	23 1f       	adc	r18, r19
    5ee8:	84 9f       	mul	r24, r20
    5eea:	60 0d       	add	r22, r0
    5eec:	21 1d       	adc	r18, r1
    5eee:	82 2f       	mov	r24, r18
    5ef0:	76 2f       	mov	r23, r22
    5ef2:	6a 2f       	mov	r22, r26
    5ef4:	11 24       	eor	r1, r1
    5ef6:	9f 57       	subi	r25, 0x7F	; 127
    5ef8:	50 40       	sbci	r21, 0x00	; 0
    5efa:	8a f0       	brmi	.+34     	; 0x5f1e <__mulsf3_pse+0x84>
    5efc:	e1 f0       	breq	.+56     	; 0x5f36 <__mulsf3_pse+0x9c>
    5efe:	88 23       	and	r24, r24
    5f00:	4a f0       	brmi	.+18     	; 0x5f14 <__mulsf3_pse+0x7a>
    5f02:	ee 0f       	add	r30, r30
    5f04:	ff 1f       	adc	r31, r31
    5f06:	bb 1f       	adc	r27, r27
    5f08:	66 1f       	adc	r22, r22
    5f0a:	77 1f       	adc	r23, r23
    5f0c:	88 1f       	adc	r24, r24
    5f0e:	91 50       	subi	r25, 0x01	; 1
    5f10:	50 40       	sbci	r21, 0x00	; 0
    5f12:	a9 f7       	brne	.-22     	; 0x5efe <__mulsf3_pse+0x64>
    5f14:	9e 3f       	cpi	r25, 0xFE	; 254
    5f16:	51 05       	cpc	r21, r1
    5f18:	70 f0       	brcs	.+28     	; 0x5f36 <__mulsf3_pse+0x9c>
    5f1a:	5c cf       	rjmp	.-328    	; 0x5dd4 <__fp_inf>
    5f1c:	a6 cf       	rjmp	.-180    	; 0x5e6a <__fp_szero>
    5f1e:	5f 3f       	cpi	r21, 0xFF	; 255
    5f20:	ec f3       	brlt	.-6      	; 0x5f1c <__mulsf3_pse+0x82>
    5f22:	98 3e       	cpi	r25, 0xE8	; 232
    5f24:	dc f3       	brlt	.-10     	; 0x5f1c <__mulsf3_pse+0x82>
    5f26:	86 95       	lsr	r24
    5f28:	77 95       	ror	r23
    5f2a:	67 95       	ror	r22
    5f2c:	b7 95       	ror	r27
    5f2e:	f7 95       	ror	r31
    5f30:	e7 95       	ror	r30
    5f32:	9f 5f       	subi	r25, 0xFF	; 255
    5f34:	c1 f7       	brne	.-16     	; 0x5f26 <__mulsf3_pse+0x8c>
    5f36:	fe 2b       	or	r31, r30
    5f38:	88 0f       	add	r24, r24
    5f3a:	91 1d       	adc	r25, r1
    5f3c:	96 95       	lsr	r25
    5f3e:	87 95       	ror	r24
    5f40:	97 f9       	bld	r25, 7
    5f42:	08 95       	ret

00005f44 <__mulsi3>:
    5f44:	62 9f       	mul	r22, r18
    5f46:	d0 01       	movw	r26, r0
    5f48:	73 9f       	mul	r23, r19
    5f4a:	f0 01       	movw	r30, r0
    5f4c:	82 9f       	mul	r24, r18
    5f4e:	e0 0d       	add	r30, r0
    5f50:	f1 1d       	adc	r31, r1
    5f52:	64 9f       	mul	r22, r20
    5f54:	e0 0d       	add	r30, r0
    5f56:	f1 1d       	adc	r31, r1
    5f58:	92 9f       	mul	r25, r18
    5f5a:	f0 0d       	add	r31, r0
    5f5c:	83 9f       	mul	r24, r19
    5f5e:	f0 0d       	add	r31, r0
    5f60:	74 9f       	mul	r23, r20
    5f62:	f0 0d       	add	r31, r0
    5f64:	65 9f       	mul	r22, r21
    5f66:	f0 0d       	add	r31, r0
    5f68:	99 27       	eor	r25, r25
    5f6a:	72 9f       	mul	r23, r18
    5f6c:	b0 0d       	add	r27, r0
    5f6e:	e1 1d       	adc	r30, r1
    5f70:	f9 1f       	adc	r31, r25
    5f72:	63 9f       	mul	r22, r19
    5f74:	b0 0d       	add	r27, r0
    5f76:	e1 1d       	adc	r30, r1
    5f78:	f9 1f       	adc	r31, r25
    5f7a:	bd 01       	movw	r22, r26
    5f7c:	cf 01       	movw	r24, r30
    5f7e:	11 24       	eor	r1, r1
    5f80:	08 95       	ret

00005f82 <__udivmodhi4>:
    5f82:	aa 1b       	sub	r26, r26
    5f84:	bb 1b       	sub	r27, r27
    5f86:	51 e1       	ldi	r21, 0x11	; 17
    5f88:	07 c0       	rjmp	.+14     	; 0x5f98 <__udivmodhi4_ep>

00005f8a <__udivmodhi4_loop>:
    5f8a:	aa 1f       	adc	r26, r26
    5f8c:	bb 1f       	adc	r27, r27
    5f8e:	a6 17       	cp	r26, r22
    5f90:	b7 07       	cpc	r27, r23
    5f92:	10 f0       	brcs	.+4      	; 0x5f98 <__udivmodhi4_ep>
    5f94:	a6 1b       	sub	r26, r22
    5f96:	b7 0b       	sbc	r27, r23

00005f98 <__udivmodhi4_ep>:
    5f98:	88 1f       	adc	r24, r24
    5f9a:	99 1f       	adc	r25, r25
    5f9c:	5a 95       	dec	r21
    5f9e:	a9 f7       	brne	.-22     	; 0x5f8a <__udivmodhi4_loop>
    5fa0:	80 95       	com	r24
    5fa2:	90 95       	com	r25
    5fa4:	bc 01       	movw	r22, r24
    5fa6:	cd 01       	movw	r24, r26
    5fa8:	08 95       	ret

00005faa <__divmodhi4>:
    5faa:	97 fb       	bst	r25, 7
    5fac:	09 2e       	mov	r0, r25
    5fae:	07 26       	eor	r0, r23
    5fb0:	0a d0       	rcall	.+20     	; 0x5fc6 <__divmodhi4_neg1>
    5fb2:	77 fd       	sbrc	r23, 7
    5fb4:	04 d0       	rcall	.+8      	; 0x5fbe <__divmodhi4_neg2>
    5fb6:	e5 df       	rcall	.-54     	; 0x5f82 <__udivmodhi4>
    5fb8:	06 d0       	rcall	.+12     	; 0x5fc6 <__divmodhi4_neg1>
    5fba:	00 20       	and	r0, r0
    5fbc:	1a f4       	brpl	.+6      	; 0x5fc4 <__divmodhi4_exit>

00005fbe <__divmodhi4_neg2>:
    5fbe:	70 95       	com	r23
    5fc0:	61 95       	neg	r22
    5fc2:	7f 4f       	sbci	r23, 0xFF	; 255

00005fc4 <__divmodhi4_exit>:
    5fc4:	08 95       	ret

00005fc6 <__divmodhi4_neg1>:
    5fc6:	f6 f7       	brtc	.-4      	; 0x5fc4 <__divmodhi4_exit>
    5fc8:	90 95       	com	r25
    5fca:	81 95       	neg	r24
    5fcc:	9f 4f       	sbci	r25, 0xFF	; 255
    5fce:	08 95       	ret

00005fd0 <__udivmodsi4>:
    5fd0:	a1 e2       	ldi	r26, 0x21	; 33
    5fd2:	1a 2e       	mov	r1, r26
    5fd4:	aa 1b       	sub	r26, r26
    5fd6:	bb 1b       	sub	r27, r27
    5fd8:	fd 01       	movw	r30, r26
    5fda:	0d c0       	rjmp	.+26     	; 0x5ff6 <__udivmodsi4_ep>

00005fdc <__udivmodsi4_loop>:
    5fdc:	aa 1f       	adc	r26, r26
    5fde:	bb 1f       	adc	r27, r27
    5fe0:	ee 1f       	adc	r30, r30
    5fe2:	ff 1f       	adc	r31, r31
    5fe4:	a2 17       	cp	r26, r18
    5fe6:	b3 07       	cpc	r27, r19
    5fe8:	e4 07       	cpc	r30, r20
    5fea:	f5 07       	cpc	r31, r21
    5fec:	20 f0       	brcs	.+8      	; 0x5ff6 <__udivmodsi4_ep>
    5fee:	a2 1b       	sub	r26, r18
    5ff0:	b3 0b       	sbc	r27, r19
    5ff2:	e4 0b       	sbc	r30, r20
    5ff4:	f5 0b       	sbc	r31, r21

00005ff6 <__udivmodsi4_ep>:
    5ff6:	66 1f       	adc	r22, r22
    5ff8:	77 1f       	adc	r23, r23
    5ffa:	88 1f       	adc	r24, r24
    5ffc:	99 1f       	adc	r25, r25
    5ffe:	1a 94       	dec	r1
    6000:	69 f7       	brne	.-38     	; 0x5fdc <__udivmodsi4_loop>
    6002:	60 95       	com	r22
    6004:	70 95       	com	r23
    6006:	80 95       	com	r24
    6008:	90 95       	com	r25
    600a:	9b 01       	movw	r18, r22
    600c:	ac 01       	movw	r20, r24
    600e:	bd 01       	movw	r22, r26
    6010:	cf 01       	movw	r24, r30
    6012:	08 95       	ret

00006014 <__divmodsi4>:
    6014:	97 fb       	bst	r25, 7
    6016:	09 2e       	mov	r0, r25
    6018:	05 26       	eor	r0, r21
    601a:	0e d0       	rcall	.+28     	; 0x6038 <__divmodsi4_neg1>
    601c:	57 fd       	sbrc	r21, 7
    601e:	04 d0       	rcall	.+8      	; 0x6028 <__divmodsi4_neg2>
    6020:	d7 df       	rcall	.-82     	; 0x5fd0 <__udivmodsi4>
    6022:	0a d0       	rcall	.+20     	; 0x6038 <__divmodsi4_neg1>
    6024:	00 1c       	adc	r0, r0
    6026:	38 f4       	brcc	.+14     	; 0x6036 <__divmodsi4_exit>

00006028 <__divmodsi4_neg2>:
    6028:	50 95       	com	r21
    602a:	40 95       	com	r20
    602c:	30 95       	com	r19
    602e:	21 95       	neg	r18
    6030:	3f 4f       	sbci	r19, 0xFF	; 255
    6032:	4f 4f       	sbci	r20, 0xFF	; 255
    6034:	5f 4f       	sbci	r21, 0xFF	; 255

00006036 <__divmodsi4_exit>:
    6036:	08 95       	ret

00006038 <__divmodsi4_neg1>:
    6038:	f6 f7       	brtc	.-4      	; 0x6036 <__divmodsi4_exit>
    603a:	90 95       	com	r25
    603c:	80 95       	com	r24
    603e:	70 95       	com	r23
    6040:	61 95       	neg	r22
    6042:	7f 4f       	sbci	r23, 0xFF	; 255
    6044:	8f 4f       	sbci	r24, 0xFF	; 255
    6046:	9f 4f       	sbci	r25, 0xFF	; 255
    6048:	08 95       	ret

0000604a <_exit>:
    604a:	f8 94       	cli

0000604c <__stop_program>:
    604c:	ff cf       	rjmp	.-2      	; 0x604c <__stop_program>

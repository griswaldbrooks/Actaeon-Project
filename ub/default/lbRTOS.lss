
lbRTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000098  00800200  00004fb4  00005048  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00004fb4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00001093  00800298  00800298  000050e0  2**0
                  ALLOC
  3 .debug_aranges 000001c0  00000000  00000000  000050e0  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000016c1  00000000  00000000  000052a0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00005304  00000000  00000000  00006961  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001794  00000000  00000000  0000bc65  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00004229  00000000  00000000  0000d3f9  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00001150  00000000  00000000  00011624  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000230d  00000000  00000000  00012774  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00002634  00000000  00000000  00014a81  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000060  00000000  00000000  000170b5  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__ctors_end>
       4:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
       8:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
       c:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
      10:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
      14:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
      18:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
      1c:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
      20:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
      24:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
      28:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
      2c:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
      30:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
      34:	0c 94 37 15 	jmp	0x2a6e	; 0x2a6e <__vector_13>
      38:	0c 94 64 15 	jmp	0x2ac8	; 0x2ac8 <__vector_14>
      3c:	0c 94 56 13 	jmp	0x26ac	; 0x26ac <__vector_15>
      40:	0c 94 b0 14 	jmp	0x2960	; 0x2960 <__vector_16>
      44:	0c 94 84 0e 	jmp	0x1d08	; 0x1d08 <__vector_17>
      48:	0c 94 dd 14 	jmp	0x29ba	; 0x29ba <__vector_18>
      4c:	0c 94 0a 15 	jmp	0x2a14	; 0x2a14 <__vector_19>
      50:	0c 94 16 13 	jmp	0x262c	; 0x262c <__vector_20>
      54:	0c 94 56 14 	jmp	0x28ac	; 0x28ac <__vector_21>
      58:	0c 94 83 14 	jmp	0x2906	; 0x2906 <__vector_22>
      5c:	0c 94 c3 12 	jmp	0x2586	; 0x2586 <__vector_23>
      60:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
      64:	0c 94 2d 19 	jmp	0x325a	; 0x325a <__vector_25>
      68:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
      6c:	0c 94 8a 1a 	jmp	0x3514	; 0x3514 <__vector_27>
      70:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
      74:	0c 94 44 1d 	jmp	0x3a88	; 0x3a88 <__vector_29>
      78:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
      7c:	0c 94 91 15 	jmp	0x2b22	; 0x2b22 <__vector_31>
      80:	0c 94 be 15 	jmp	0x2b7c	; 0x2b7c <__vector_32>
      84:	0c 94 eb 15 	jmp	0x2bd6	; 0x2bd6 <__vector_33>
      88:	0c 94 18 16 	jmp	0x2c30	; 0x2c30 <__vector_34>
      8c:	0c 94 96 13 	jmp	0x272c	; 0x272c <__vector_35>
      90:	0c 94 08 19 	jmp	0x3210	; 0x3210 <__vector_36>
      94:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
      98:	0c 94 65 1a 	jmp	0x34ca	; 0x34ca <__vector_38>
      9c:	0c 94 62 21 	jmp	0x42c4	; 0x42c4 <__vector_39>
      a0:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
      a4:	0c 94 45 16 	jmp	0x2c8a	; 0x2c8a <__vector_41>
      a8:	0c 94 72 16 	jmp	0x2ce4	; 0x2ce4 <__vector_42>
      ac:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__vector_43>
      b0:	0c 94 cc 16 	jmp	0x2d98	; 0x2d98 <__vector_44>
      b4:	0c 94 d6 13 	jmp	0x27ac	; 0x27ac <__vector_45>
      b8:	0c 94 f9 16 	jmp	0x2df2	; 0x2df2 <__vector_46>
      bc:	0c 94 26 17 	jmp	0x2e4c	; 0x2e4c <__vector_47>
      c0:	0c 94 53 17 	jmp	0x2ea6	; 0x2ea6 <__vector_48>
      c4:	0c 94 80 17 	jmp	0x2f00	; 0x2f00 <__vector_49>
      c8:	0c 94 16 14 	jmp	0x282c	; 0x282c <__vector_50>
      cc:	0c 94 e3 18 	jmp	0x31c6	; 0x31c6 <__vector_51>
      d0:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
      d4:	0c 94 40 1a 	jmp	0x3480	; 0x3480 <__vector_53>
      d8:	0c 94 be 18 	jmp	0x317c	; 0x317c <__vector_54>
      dc:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
      e0:	0c 94 1b 1a 	jmp	0x3436	; 0x3436 <__vector_56>

000000e4 <__c.2766>:
      e4:	0a 53 63 61 6e 20 65 6e 64 0a 0a 00                 .Scan end...

000000f0 <__c.2761>:
      f0:	25 64 00                                            %d.

000000f3 <__c.2758>:
      f3:	53 63 61 6e 20 73 74 61 72 74 0a 00                 Scan start..

000000ff <__c.2756>:
      ff:	53 74 61 72 74 69 6e 67 20 70 72 6f 67 72 61 6d     Starting program
     10f:	2e 0a 00                                            ...

00000112 <__c.2727>:
     112:	49 6e 69 74 69 61 6c 69 7a 61 74 69 6f 6e 20 43     Initialization C
     122:	6f 6d 70 6c 65 74 65 20 0d 0a 00                    omplete ...

0000012d <__c.2722>:
     12d:	2e 00                                               ..

0000012f <__c.2720>:
     12f:	0d 0a 53 79 73 74 65 6d 20 57 61 72 6d 65 64 20     ..System Warmed 
     13f:	55 70 00                                            Up.

00000142 <TimerPrescaleFactor>:
     142:	00 00 01 00 08 00 40 00 00 01 00 04                 ......@.....

0000014e <Timer2PrescaleFactor>:
     14e:	00 00 01 00 08 00 20 00 40 00 80 00 00 01 00 04     ...... .@.......

0000015e <__c.1991>:
     15e:	42 41 44 5f 76 65 63 74 20 63 61 6c 6c 65 64 21     BAD_vect called!
	...

0000016f <HexChars>:
     16f:	30 31 32 33 34 35 36 37 38 39 41 42 43 44 45 46     0123456789ABCDEF
	...

00000180 <__c.1708>:
     180:	25 64 20 00                                         %d .

00000184 <__c.1705>:
     184:	20 44 69 73 74 61 6e 63 65 73 3a 20 00               Distances: .

00000191 <__c.1703>:
     191:	20 4d 6f 74 6f 72 20 53 70 65 65 64 3a 20 00         Motor Speed: .

000001a0 <__c.1701>:
     1a0:	49 6e 64 65 78 3a 20 00                             Index: .

000001a8 <__ctors_end>:
     1a8:	11 24       	eor	r1, r1
     1aa:	1f be       	out	0x3f, r1	; 63
     1ac:	cf ef       	ldi	r28, 0xFF	; 255
     1ae:	d1 e2       	ldi	r29, 0x21	; 33
     1b0:	de bf       	out	0x3e, r29	; 62
     1b2:	cd bf       	out	0x3d, r28	; 61

000001b4 <__do_copy_data>:
     1b4:	12 e0       	ldi	r17, 0x02	; 2
     1b6:	a0 e0       	ldi	r26, 0x00	; 0
     1b8:	b2 e0       	ldi	r27, 0x02	; 2
     1ba:	e4 eb       	ldi	r30, 0xB4	; 180
     1bc:	ff e4       	ldi	r31, 0x4F	; 79
     1be:	02 c0       	rjmp	.+4      	; 0x1c4 <.do_copy_data_start>

000001c0 <.do_copy_data_loop>:
     1c0:	05 90       	lpm	r0, Z+
     1c2:	0d 92       	st	X+, r0

000001c4 <.do_copy_data_start>:
     1c4:	a8 39       	cpi	r26, 0x98	; 152
     1c6:	b1 07       	cpc	r27, r17
     1c8:	d9 f7       	brne	.-10     	; 0x1c0 <.do_copy_data_loop>

000001ca <__do_clear_bss>:
     1ca:	13 e1       	ldi	r17, 0x13	; 19
     1cc:	a8 e9       	ldi	r26, 0x98	; 152
     1ce:	b2 e0       	ldi	r27, 0x02	; 2
     1d0:	01 c0       	rjmp	.+2      	; 0x1d4 <.do_clear_bss_start>

000001d2 <.do_clear_bss_loop>:
     1d2:	1d 92       	st	X+, r1

000001d4 <.do_clear_bss_start>:
     1d4:	ab 32       	cpi	r26, 0x2B	; 43
     1d6:	b1 07       	cpc	r27, r17
     1d8:	e1 f7       	brne	.-8      	; 0x1d2 <.do_clear_bss_loop>
     1da:	0e 94 12 05 	call	0xa24	; 0xa24 <main>
     1de:	0c 94 3c 25 	jmp	0x4a78	; 0x4a78 <exit>

000001e2 <__bad_interrupt>:
     1e2:	0c 94 ad 17 	jmp	0x2f5a	; 0x2f5a <__vector_default>

000001e6 <PWM_Init_timer1_LED>:

//OC1B  pin B6 (attached to green LED)
void PWM_Init_timer1_LED(u08 bitRes)
{
	// enable timer2 as 8,9,10bit PWM
	if(bitRes == 9)
     1e6:	89 30       	cpi	r24, 0x09	; 9
     1e8:	49 f4       	brne	.+18     	; 0x1fc <PWM_Init_timer1_LED+0x16>
	{	// 9bit mode
		sbi(TCCR1A,PWM11);
     1ea:	80 91 80 00 	lds	r24, 0x0080
     1ee:	82 60       	ori	r24, 0x02	; 2
     1f0:	80 93 80 00 	sts	0x0080, r24
		cbi(TCCR1A,PWM10);
     1f4:	80 91 80 00 	lds	r24, 0x0080
     1f8:	8e 7f       	andi	r24, 0xFE	; 254
     1fa:	0e c0       	rjmp	.+28     	; 0x218 <PWM_Init_timer1_LED+0x32>
	}
	else if( bitRes == 10 )
     1fc:	8a 30       	cpi	r24, 0x0A	; 10
     1fe:	21 f4       	brne	.+8      	; 0x208 <PWM_Init_timer1_LED+0x22>
	{	// 10bit mode
		sbi(TCCR1A,PWM11);
     200:	80 91 80 00 	lds	r24, 0x0080
     204:	82 60       	ori	r24, 0x02	; 2
     206:	03 c0       	rjmp	.+6      	; 0x20e <PWM_Init_timer1_LED+0x28>
		sbi(TCCR1A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR1A,PWM11);
     208:	80 91 80 00 	lds	r24, 0x0080
     20c:	8d 7f       	andi	r24, 0xFD	; 253
     20e:	80 93 80 00 	sts	0x0080, r24
		sbi(TCCR1A,PWM10);
     212:	80 91 80 00 	lds	r24, 0x0080
     216:	81 60       	ori	r24, 0x01	; 1
     218:	80 93 80 00 	sts	0x0080, r24
	}
	// clear output compare values
	OCR1B = 0;
     21c:	10 92 8b 00 	sts	0x008B, r1
     220:	10 92 8a 00 	sts	0x008A, r1
}
     224:	08 95       	ret

00000226 <PWM_Init_timer2_H6>:
//pin H6, timer2
void PWM_Init_timer2_H6(u08 bitRes)
{
	// enable timer2 as 8,9,10bit PWM
	if(bitRes == 9)
     226:	89 30       	cpi	r24, 0x09	; 9
     228:	49 f4       	brne	.+18     	; 0x23c <PWM_Init_timer2_H6+0x16>
	{	// 9bit mode
		sbi(TCCR2A,PWM11);
     22a:	80 91 b0 00 	lds	r24, 0x00B0
     22e:	82 60       	ori	r24, 0x02	; 2
     230:	80 93 b0 00 	sts	0x00B0, r24
		cbi(TCCR2A,PWM10);
     234:	80 91 b0 00 	lds	r24, 0x00B0
     238:	8e 7f       	andi	r24, 0xFE	; 254
     23a:	0e c0       	rjmp	.+28     	; 0x258 <PWM_Init_timer2_H6+0x32>
	}
	else if( bitRes == 10 )
     23c:	8a 30       	cpi	r24, 0x0A	; 10
     23e:	21 f4       	brne	.+8      	; 0x248 <PWM_Init_timer2_H6+0x22>
	{	// 10bit mode
		sbi(TCCR2A,PWM11);
     240:	80 91 b0 00 	lds	r24, 0x00B0
     244:	82 60       	ori	r24, 0x02	; 2
     246:	03 c0       	rjmp	.+6      	; 0x24e <PWM_Init_timer2_H6+0x28>
		sbi(TCCR2A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR2A,PWM11);
     248:	80 91 b0 00 	lds	r24, 0x00B0
     24c:	8d 7f       	andi	r24, 0xFD	; 253
     24e:	80 93 b0 00 	sts	0x00B0, r24
		sbi(TCCR2A,PWM10);
     252:	80 91 b0 00 	lds	r24, 0x00B0
     256:	81 60       	ori	r24, 0x01	; 1
     258:	80 93 b0 00 	sts	0x00B0, r24
	}
	// clear output compare values
	OCR2B = 0;
     25c:	10 92 b4 00 	sts	0x00B4, r1
}
     260:	08 95       	ret

00000262 <PWM_Init_timer3_E3>:
//pin E3
void PWM_Init_timer3_E3(u08 bitRes)
{
	// enable timer3 as 8,9,10bit PWM
	if(bitRes == 9)
     262:	89 30       	cpi	r24, 0x09	; 9
     264:	49 f4       	brne	.+18     	; 0x278 <PWM_Init_timer3_E3+0x16>
	{	// 9bit mode
		sbi(TCCR3A,PWM11);
     266:	80 91 90 00 	lds	r24, 0x0090
     26a:	82 60       	ori	r24, 0x02	; 2
     26c:	80 93 90 00 	sts	0x0090, r24
		cbi(TCCR3A,PWM10);
     270:	80 91 90 00 	lds	r24, 0x0090
     274:	8e 7f       	andi	r24, 0xFE	; 254
     276:	0e c0       	rjmp	.+28     	; 0x294 <PWM_Init_timer3_E3+0x32>
	}
	else if( bitRes == 10 )
     278:	8a 30       	cpi	r24, 0x0A	; 10
     27a:	21 f4       	brne	.+8      	; 0x284 <PWM_Init_timer3_E3+0x22>
	{	// 10bit mode
		sbi(TCCR3A,PWM11);
     27c:	80 91 90 00 	lds	r24, 0x0090
     280:	82 60       	ori	r24, 0x02	; 2
     282:	03 c0       	rjmp	.+6      	; 0x28a <PWM_Init_timer3_E3+0x28>
		sbi(TCCR3A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR3A,PWM11);
     284:	80 91 90 00 	lds	r24, 0x0090
     288:	8d 7f       	andi	r24, 0xFD	; 253
     28a:	80 93 90 00 	sts	0x0090, r24
		sbi(TCCR3A,PWM10);
     28e:	80 91 90 00 	lds	r24, 0x0090
     292:	81 60       	ori	r24, 0x01	; 1
     294:	80 93 90 00 	sts	0x0090, r24
	}
	// clear output compare values
	OCR3A = 0;
     298:	10 92 99 00 	sts	0x0099, r1
     29c:	10 92 98 00 	sts	0x0098, r1
	//timer3PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     2a0:	08 95       	ret

000002a2 <PWM_Init_timer3_E4>:
//pin E4
void PWM_Init_timer3_E4(u08 bitRes)
{
	// enable timer3 as 8,9,10bit PWM
	if(bitRes == 9)
     2a2:	89 30       	cpi	r24, 0x09	; 9
     2a4:	49 f4       	brne	.+18     	; 0x2b8 <PWM_Init_timer3_E4+0x16>
	{	// 9bit mode
		sbi(TCCR3B,PWM11);
     2a6:	80 91 91 00 	lds	r24, 0x0091
     2aa:	82 60       	ori	r24, 0x02	; 2
     2ac:	80 93 91 00 	sts	0x0091, r24
		cbi(TCCR3B,PWM10);
     2b0:	80 91 91 00 	lds	r24, 0x0091
     2b4:	8e 7f       	andi	r24, 0xFE	; 254
     2b6:	0e c0       	rjmp	.+28     	; 0x2d4 <PWM_Init_timer3_E4+0x32>
	}
	else if( bitRes == 10 )
     2b8:	8a 30       	cpi	r24, 0x0A	; 10
     2ba:	21 f4       	brne	.+8      	; 0x2c4 <PWM_Init_timer3_E4+0x22>
	{	// 10bit mode
		sbi(TCCR3B,PWM11);
     2bc:	80 91 91 00 	lds	r24, 0x0091
     2c0:	82 60       	ori	r24, 0x02	; 2
     2c2:	03 c0       	rjmp	.+6      	; 0x2ca <PWM_Init_timer3_E4+0x28>
		sbi(TCCR3B,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR3B,PWM11);
     2c4:	80 91 91 00 	lds	r24, 0x0091
     2c8:	8d 7f       	andi	r24, 0xFD	; 253
     2ca:	80 93 91 00 	sts	0x0091, r24
		sbi(TCCR3B,PWM10);
     2ce:	80 91 91 00 	lds	r24, 0x0091
     2d2:	81 60       	ori	r24, 0x01	; 1
     2d4:	80 93 91 00 	sts	0x0091, r24
	}
	// clear output compare values
	OCR3B = 0;
     2d8:	10 92 9b 00 	sts	0x009B, r1
     2dc:	10 92 9a 00 	sts	0x009A, r1
	//timer3PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     2e0:	08 95       	ret

000002e2 <PWM_Init_timer3_E5>:
//pin E5
void PWM_Init_timer3_E5(u08 bitRes)
{
	// enable timer3 as 8,9,10bit PWM
	if(bitRes == 9)
     2e2:	89 30       	cpi	r24, 0x09	; 9
     2e4:	49 f4       	brne	.+18     	; 0x2f8 <PWM_Init_timer3_E5+0x16>
	{	// 9bit mode
		sbi(TCCR3C,PWM11);
     2e6:	80 91 92 00 	lds	r24, 0x0092
     2ea:	82 60       	ori	r24, 0x02	; 2
     2ec:	80 93 92 00 	sts	0x0092, r24
		cbi(TCCR3C,PWM10);
     2f0:	80 91 92 00 	lds	r24, 0x0092
     2f4:	8e 7f       	andi	r24, 0xFE	; 254
     2f6:	0e c0       	rjmp	.+28     	; 0x314 <PWM_Init_timer3_E5+0x32>
	}
	else if( bitRes == 10 )
     2f8:	8a 30       	cpi	r24, 0x0A	; 10
     2fa:	21 f4       	brne	.+8      	; 0x304 <PWM_Init_timer3_E5+0x22>
	{	// 10bit mode
		sbi(TCCR3C,PWM11);
     2fc:	80 91 92 00 	lds	r24, 0x0092
     300:	82 60       	ori	r24, 0x02	; 2
     302:	03 c0       	rjmp	.+6      	; 0x30a <PWM_Init_timer3_E5+0x28>
		sbi(TCCR3C,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR3C,PWM11);
     304:	80 91 92 00 	lds	r24, 0x0092
     308:	8d 7f       	andi	r24, 0xFD	; 253
     30a:	80 93 92 00 	sts	0x0092, r24
		sbi(TCCR3C,PWM10);
     30e:	80 91 92 00 	lds	r24, 0x0092
     312:	81 60       	ori	r24, 0x01	; 1
     314:	80 93 92 00 	sts	0x0092, r24
	}
	// clear output compare values
	OCR3C = 0;
     318:	10 92 9d 00 	sts	0x009D, r1
     31c:	10 92 9c 00 	sts	0x009C, r1
	//timer3PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     320:	08 95       	ret

00000322 <PWM_Init_timer4_H3>:
//pin H3, timer4
void PWM_Init_timer4_H3(u08 bitRes)
{
	// enable timer4 as 8,9,10bit PWM
	if(bitRes == 9)
     322:	89 30       	cpi	r24, 0x09	; 9
     324:	49 f4       	brne	.+18     	; 0x338 <PWM_Init_timer4_H3+0x16>
	{	// 9bit mode
		sbi(TCCR4A,PWM11);
     326:	80 91 a0 00 	lds	r24, 0x00A0
     32a:	82 60       	ori	r24, 0x02	; 2
     32c:	80 93 a0 00 	sts	0x00A0, r24
		cbi(TCCR4A,PWM10);
     330:	80 91 a0 00 	lds	r24, 0x00A0
     334:	8e 7f       	andi	r24, 0xFE	; 254
     336:	0e c0       	rjmp	.+28     	; 0x354 <PWM_Init_timer4_H3+0x32>
	}
	else if( bitRes == 10 )
     338:	8a 30       	cpi	r24, 0x0A	; 10
     33a:	21 f4       	brne	.+8      	; 0x344 <PWM_Init_timer4_H3+0x22>
	{	// 10bit mode
		sbi(TCCR4A,PWM11);
     33c:	80 91 a0 00 	lds	r24, 0x00A0
     340:	82 60       	ori	r24, 0x02	; 2
     342:	03 c0       	rjmp	.+6      	; 0x34a <PWM_Init_timer4_H3+0x28>
		sbi(TCCR4A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR4A,PWM11);
     344:	80 91 a0 00 	lds	r24, 0x00A0
     348:	8d 7f       	andi	r24, 0xFD	; 253
     34a:	80 93 a0 00 	sts	0x00A0, r24
		sbi(TCCR4A,PWM10);
     34e:	80 91 a0 00 	lds	r24, 0x00A0
     352:	81 60       	ori	r24, 0x01	; 1
     354:	80 93 a0 00 	sts	0x00A0, r24
	}
	// clear output compare values
	OCR4A = 0;
     358:	10 92 a9 00 	sts	0x00A9, r1
     35c:	10 92 a8 00 	sts	0x00A8, r1
	//timer4PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     360:	08 95       	ret

00000362 <PWM_Init_timer4_H4>:
//pin H4, timer4
void PWM_Init_timer4_H4(u08 bitRes)
{
	// enable timer4 as 8,9,10bit PWM
	if(bitRes == 9)
     362:	89 30       	cpi	r24, 0x09	; 9
     364:	49 f4       	brne	.+18     	; 0x378 <PWM_Init_timer4_H4+0x16>
	{	// 9bit mode
		sbi(TCCR4B,PWM11);
     366:	80 91 a1 00 	lds	r24, 0x00A1
     36a:	82 60       	ori	r24, 0x02	; 2
     36c:	80 93 a1 00 	sts	0x00A1, r24
		cbi(TCCR4B,PWM10);
     370:	80 91 a1 00 	lds	r24, 0x00A1
     374:	8e 7f       	andi	r24, 0xFE	; 254
     376:	0e c0       	rjmp	.+28     	; 0x394 <PWM_Init_timer4_H4+0x32>
	}
	else if( bitRes == 10 )
     378:	8a 30       	cpi	r24, 0x0A	; 10
     37a:	21 f4       	brne	.+8      	; 0x384 <PWM_Init_timer4_H4+0x22>
	{	// 10bit mode
		sbi(TCCR4B,PWM11);
     37c:	80 91 a1 00 	lds	r24, 0x00A1
     380:	82 60       	ori	r24, 0x02	; 2
     382:	03 c0       	rjmp	.+6      	; 0x38a <PWM_Init_timer4_H4+0x28>
		sbi(TCCR4B,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR4B,PWM11);
     384:	80 91 a1 00 	lds	r24, 0x00A1
     388:	8d 7f       	andi	r24, 0xFD	; 253
     38a:	80 93 a1 00 	sts	0x00A1, r24
		sbi(TCCR4B,PWM10);
     38e:	80 91 a1 00 	lds	r24, 0x00A1
     392:	81 60       	ori	r24, 0x01	; 1
     394:	80 93 a1 00 	sts	0x00A1, r24
	}
	// clear output compare values
	OCR4B = 0;
     398:	10 92 ab 00 	sts	0x00AB, r1
     39c:	10 92 aa 00 	sts	0x00AA, r1
	//timer4PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     3a0:	08 95       	ret

000003a2 <PWM_Init_timer4_H5>:
//pin H5, timer4
void PWM_Init_timer4_H5(u08 bitRes)
{
	// enable timer4 as 8,9,10bit PWM
	if(bitRes == 9)
     3a2:	89 30       	cpi	r24, 0x09	; 9
     3a4:	49 f4       	brne	.+18     	; 0x3b8 <PWM_Init_timer4_H5+0x16>
	{	// 9bit mode
		sbi(TCCR4A,PWM11);
     3a6:	80 91 a0 00 	lds	r24, 0x00A0
     3aa:	82 60       	ori	r24, 0x02	; 2
     3ac:	80 93 a0 00 	sts	0x00A0, r24
		cbi(TCCR4A,PWM10);
     3b0:	80 91 a0 00 	lds	r24, 0x00A0
     3b4:	8e 7f       	andi	r24, 0xFE	; 254
     3b6:	0e c0       	rjmp	.+28     	; 0x3d4 <PWM_Init_timer4_H5+0x32>
	}
	else if( bitRes == 10 )
     3b8:	8a 30       	cpi	r24, 0x0A	; 10
     3ba:	21 f4       	brne	.+8      	; 0x3c4 <PWM_Init_timer4_H5+0x22>
	{	// 10bit mode
		sbi(TCCR4A,PWM11);
     3bc:	80 91 a0 00 	lds	r24, 0x00A0
     3c0:	82 60       	ori	r24, 0x02	; 2
     3c2:	03 c0       	rjmp	.+6      	; 0x3ca <PWM_Init_timer4_H5+0x28>
		sbi(TCCR4A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR4A,PWM11);
     3c4:	80 91 a0 00 	lds	r24, 0x00A0
     3c8:	8d 7f       	andi	r24, 0xFD	; 253
     3ca:	80 93 a0 00 	sts	0x00A0, r24
		sbi(TCCR4A,PWM10);
     3ce:	80 91 a0 00 	lds	r24, 0x00A0
     3d2:	81 60       	ori	r24, 0x01	; 1
     3d4:	80 93 a0 00 	sts	0x00A0, r24
	}
	// clear output compare values
	OCR4C = 0;
     3d8:	10 92 ad 00 	sts	0x00AD, r1
     3dc:	10 92 ac 00 	sts	0x00AC, r1
	//timer4PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     3e0:	08 95       	ret

000003e2 <timer1PWMInitICR>:
// include support for arbitrary top-count PWM
// on new AVR processors that support it
void timer1PWMInitICR(u16 topcount)
{
	// set PWM mode with ICR top-count
	cbi(TCCR1A,WGM10);
     3e2:	e0 e8       	ldi	r30, 0x80	; 128
     3e4:	f0 e0       	ldi	r31, 0x00	; 0
     3e6:	20 81       	ld	r18, Z
     3e8:	2e 7f       	andi	r18, 0xFE	; 254
     3ea:	20 83       	st	Z, r18
	sbi(TCCR1A,WGM11);
     3ec:	20 81       	ld	r18, Z
     3ee:	22 60       	ori	r18, 0x02	; 2
     3f0:	20 83       	st	Z, r18
	sbi(TCCR1B,WGM12);
     3f2:	e1 e8       	ldi	r30, 0x81	; 129
     3f4:	f0 e0       	ldi	r31, 0x00	; 0
     3f6:	20 81       	ld	r18, Z
     3f8:	28 60       	ori	r18, 0x08	; 8
     3fa:	20 83       	st	Z, r18
	sbi(TCCR1B,WGM13);
     3fc:	20 81       	ld	r18, Z
     3fe:	20 61       	ori	r18, 0x10	; 16
     400:	20 83       	st	Z, r18
	
	// set top count value
	ICR1 = topcount;
     402:	90 93 87 00 	sts	0x0087, r25
     406:	80 93 86 00 	sts	0x0086, r24
	
	// clear output compare values
	OCR1A = 0;
     40a:	10 92 89 00 	sts	0x0089, r1
     40e:	10 92 88 00 	sts	0x0088, r1
	OCR1B = 0;
     412:	10 92 8b 00 	sts	0x008B, r1
     416:	10 92 8a 00 	sts	0x008A, r1
	OCR1C = 0;
     41a:	10 92 8d 00 	sts	0x008D, r1
     41e:	10 92 8c 00 	sts	0x008C, r1
}
     422:	08 95       	ret

00000424 <timer3PWMInitICR>:
void timer3PWMInitICR(u16 topcount)
{
	// set PWM mode with ICR top-count
	cbi(TCCR3A,WGM10);
     424:	e0 e9       	ldi	r30, 0x90	; 144
     426:	f0 e0       	ldi	r31, 0x00	; 0
     428:	20 81       	ld	r18, Z
     42a:	2e 7f       	andi	r18, 0xFE	; 254
     42c:	20 83       	st	Z, r18
	sbi(TCCR3A,WGM11);
     42e:	20 81       	ld	r18, Z
     430:	22 60       	ori	r18, 0x02	; 2
     432:	20 83       	st	Z, r18
	sbi(TCCR3B,WGM12);
     434:	e1 e9       	ldi	r30, 0x91	; 145
     436:	f0 e0       	ldi	r31, 0x00	; 0
     438:	20 81       	ld	r18, Z
     43a:	28 60       	ori	r18, 0x08	; 8
     43c:	20 83       	st	Z, r18
	sbi(TCCR3B,WGM13);
     43e:	20 81       	ld	r18, Z
     440:	20 61       	ori	r18, 0x10	; 16
     442:	20 83       	st	Z, r18
	
	// set top count value
	ICR3 = topcount;
     444:	90 93 97 00 	sts	0x0097, r25
     448:	80 93 96 00 	sts	0x0096, r24
	
	// clear output compare values
	OCR3A = 0;
     44c:	10 92 99 00 	sts	0x0099, r1
     450:	10 92 98 00 	sts	0x0098, r1
	OCR3B = 0;
     454:	10 92 9b 00 	sts	0x009B, r1
     458:	10 92 9a 00 	sts	0x009A, r1
	OCR3C = 0;
     45c:	10 92 9d 00 	sts	0x009D, r1
     460:	10 92 9c 00 	sts	0x009C, r1
}
     464:	08 95       	ret

00000466 <timer4PWMInitICR>:
void timer4PWMInitICR(u16 topcount)
{
	// set PWM mode with ICR top-count
	cbi(TCCR4A,WGM10);
     466:	e0 ea       	ldi	r30, 0xA0	; 160
     468:	f0 e0       	ldi	r31, 0x00	; 0
     46a:	20 81       	ld	r18, Z
     46c:	2e 7f       	andi	r18, 0xFE	; 254
     46e:	20 83       	st	Z, r18
	sbi(TCCR4A,WGM11);
     470:	20 81       	ld	r18, Z
     472:	22 60       	ori	r18, 0x02	; 2
     474:	20 83       	st	Z, r18
	sbi(TCCR4B,WGM12);
     476:	e1 ea       	ldi	r30, 0xA1	; 161
     478:	f0 e0       	ldi	r31, 0x00	; 0
     47a:	20 81       	ld	r18, Z
     47c:	28 60       	ori	r18, 0x08	; 8
     47e:	20 83       	st	Z, r18
	sbi(TCCR4B,WGM13);
     480:	20 81       	ld	r18, Z
     482:	20 61       	ori	r18, 0x10	; 16
     484:	20 83       	st	Z, r18
	
	// set top count value
	ICR4 = topcount;
     486:	90 93 a7 00 	sts	0x00A7, r25
     48a:	80 93 a6 00 	sts	0x00A6, r24
	
	// clear output compare values
	OCR4A = 0;
     48e:	10 92 a9 00 	sts	0x00A9, r1
     492:	10 92 a8 00 	sts	0x00A8, r1
	OCR4B = 0;
     496:	10 92 ab 00 	sts	0x00AB, r1
     49a:	10 92 aa 00 	sts	0x00AA, r1
	OCR4C = 0;
     49e:	10 92 ad 00 	sts	0x00AD, r1
     4a2:	10 92 ac 00 	sts	0x00AC, r1
}
     4a6:	08 95       	ret

000004a8 <PWM_timer1_On_LED>:
#endif

//on commands
void PWM_timer1_On_LED(void)
{
	sbi(TCCR1A,COM1B1);
     4a8:	e0 e8       	ldi	r30, 0x80	; 128
     4aa:	f0 e0       	ldi	r31, 0x00	; 0
     4ac:	80 81       	ld	r24, Z
     4ae:	80 62       	ori	r24, 0x20	; 32
     4b0:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B0);
     4b2:	80 81       	ld	r24, Z
     4b4:	8f 7e       	andi	r24, 0xEF	; 239
     4b6:	80 83       	st	Z, r24
}
     4b8:	08 95       	ret

000004ba <PWM_timer2_On_H6>:
void PWM_timer2_On_H6(void)
{
	sbi(TCCR2A,COM2B1);
     4ba:	e0 eb       	ldi	r30, 0xB0	; 176
     4bc:	f0 e0       	ldi	r31, 0x00	; 0
     4be:	80 81       	ld	r24, Z
     4c0:	80 62       	ori	r24, 0x20	; 32
     4c2:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B0);
     4c4:	80 81       	ld	r24, Z
     4c6:	8f 7e       	andi	r24, 0xEF	; 239
     4c8:	80 83       	st	Z, r24
}
     4ca:	08 95       	ret

000004cc <PWM_timer3_On_E3>:
void PWM_timer3_On_E3(void)
{
	sbi(TCCR3A,COM3A1);
     4cc:	e0 e9       	ldi	r30, 0x90	; 144
     4ce:	f0 e0       	ldi	r31, 0x00	; 0
     4d0:	80 81       	ld	r24, Z
     4d2:	80 68       	ori	r24, 0x80	; 128
     4d4:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3A0);
     4d6:	80 81       	ld	r24, Z
     4d8:	8f 7b       	andi	r24, 0xBF	; 191
     4da:	80 83       	st	Z, r24
}
     4dc:	08 95       	ret

000004de <PWM_timer3_On_E4>:
void PWM_timer3_On_E4(void)
{
	sbi(TCCR3A,COM3B1);
     4de:	e0 e9       	ldi	r30, 0x90	; 144
     4e0:	f0 e0       	ldi	r31, 0x00	; 0
     4e2:	80 81       	ld	r24, Z
     4e4:	80 62       	ori	r24, 0x20	; 32
     4e6:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3B0);
     4e8:	80 81       	ld	r24, Z
     4ea:	8f 7e       	andi	r24, 0xEF	; 239
     4ec:	80 83       	st	Z, r24
}
     4ee:	08 95       	ret

000004f0 <PWM_timer3_On_E5>:
void PWM_timer3_On_E5(void)
{
	sbi(TCCR3A,COM3C1);
     4f0:	e0 e9       	ldi	r30, 0x90	; 144
     4f2:	f0 e0       	ldi	r31, 0x00	; 0
     4f4:	80 81       	ld	r24, Z
     4f6:	88 60       	ori	r24, 0x08	; 8
     4f8:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C0);
     4fa:	80 81       	ld	r24, Z
     4fc:	8b 7f       	andi	r24, 0xFB	; 251
     4fe:	80 83       	st	Z, r24
}
     500:	08 95       	ret

00000502 <PWM_timer4_On_H3>:
void PWM_timer4_On_H3(void)
{
	sbi(TCCR4A,COM4A1);
     502:	e0 ea       	ldi	r30, 0xA0	; 160
     504:	f0 e0       	ldi	r31, 0x00	; 0
     506:	80 81       	ld	r24, Z
     508:	80 68       	ori	r24, 0x80	; 128
     50a:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4A0);
     50c:	80 81       	ld	r24, Z
     50e:	8f 7b       	andi	r24, 0xBF	; 191
     510:	80 83       	st	Z, r24
}
     512:	08 95       	ret

00000514 <PWM_timer4_On_H4>:
void PWM_timer4_On_H4(void)
{
	sbi(TCCR4A,COM4B1);
     514:	e0 ea       	ldi	r30, 0xA0	; 160
     516:	f0 e0       	ldi	r31, 0x00	; 0
     518:	80 81       	ld	r24, Z
     51a:	80 62       	ori	r24, 0x20	; 32
     51c:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4B0);
     51e:	80 81       	ld	r24, Z
     520:	8f 7e       	andi	r24, 0xEF	; 239
     522:	80 83       	st	Z, r24
}
     524:	08 95       	ret

00000526 <PWM_timer4_On_H5>:
void PWM_timer4_On_H5(void)
{
	sbi(TCCR4A,COM4C1);
     526:	e0 ea       	ldi	r30, 0xA0	; 160
     528:	f0 e0       	ldi	r31, 0x00	; 0
     52a:	80 81       	ld	r24, Z
     52c:	88 60       	ori	r24, 0x08	; 8
     52e:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4C0);
     530:	80 81       	ld	r24, Z
     532:	8b 7f       	andi	r24, 0xFB	; 251
     534:	80 83       	st	Z, r24
}
     536:	08 95       	ret

00000538 <PWM_timer1_Off_LED>:

//off commands
void PWM_timer1_Off_LED(void)
{
	cbi(TCCR1A,COM1B1);
     538:	e0 e8       	ldi	r30, 0x80	; 128
     53a:	f0 e0       	ldi	r31, 0x00	; 0
     53c:	80 81       	ld	r24, Z
     53e:	8f 7d       	andi	r24, 0xDF	; 223
     540:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B0);
     542:	80 81       	ld	r24, Z
     544:	8f 7e       	andi	r24, 0xEF	; 239
     546:	80 83       	st	Z, r24
}
     548:	08 95       	ret

0000054a <PWM_timer2_Off_H6>:
void PWM_timer2_Off_H6(void)
{
	cbi(TCCR2A,COM2B1);
     54a:	e0 eb       	ldi	r30, 0xB0	; 176
     54c:	f0 e0       	ldi	r31, 0x00	; 0
     54e:	80 81       	ld	r24, Z
     550:	8f 7d       	andi	r24, 0xDF	; 223
     552:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B0);
     554:	80 81       	ld	r24, Z
     556:	8f 7e       	andi	r24, 0xEF	; 239
     558:	80 83       	st	Z, r24
}
     55a:	08 95       	ret

0000055c <PWM_timer3_Off_E3>:
void PWM_timer3_Off_E3(void)
{
	cbi(TCCR3A,COM3A1);
     55c:	e0 e9       	ldi	r30, 0x90	; 144
     55e:	f0 e0       	ldi	r31, 0x00	; 0
     560:	80 81       	ld	r24, Z
     562:	8f 77       	andi	r24, 0x7F	; 127
     564:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3A0);
     566:	80 81       	ld	r24, Z
     568:	8f 7b       	andi	r24, 0xBF	; 191
     56a:	80 83       	st	Z, r24
}
     56c:	08 95       	ret

0000056e <PWM_timer3_Off_E4>:
void PWM_timer3_Off_E4(void)
{
	cbi(TCCR3A,COM3B1);
     56e:	e0 e9       	ldi	r30, 0x90	; 144
     570:	f0 e0       	ldi	r31, 0x00	; 0
     572:	80 81       	ld	r24, Z
     574:	8f 7d       	andi	r24, 0xDF	; 223
     576:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3B0);
     578:	80 81       	ld	r24, Z
     57a:	8f 7e       	andi	r24, 0xEF	; 239
     57c:	80 83       	st	Z, r24
}
     57e:	08 95       	ret

00000580 <PWM_timer3_Off_E5>:
void PWM_timer3_Off_E5(void)
{
	cbi(TCCR3A,COM3C1);
     580:	e0 e9       	ldi	r30, 0x90	; 144
     582:	f0 e0       	ldi	r31, 0x00	; 0
     584:	80 81       	ld	r24, Z
     586:	87 7f       	andi	r24, 0xF7	; 247
     588:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C0);
     58a:	80 81       	ld	r24, Z
     58c:	8b 7f       	andi	r24, 0xFB	; 251
     58e:	80 83       	st	Z, r24
}
     590:	08 95       	ret

00000592 <PWM_timer4_Off_H3>:
void PWM_timer4_Off_H3(void)
{
	cbi(TCCR4A,COM4A1);
     592:	e0 ea       	ldi	r30, 0xA0	; 160
     594:	f0 e0       	ldi	r31, 0x00	; 0
     596:	80 81       	ld	r24, Z
     598:	8f 77       	andi	r24, 0x7F	; 127
     59a:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4A0);
     59c:	80 81       	ld	r24, Z
     59e:	8f 7b       	andi	r24, 0xBF	; 191
     5a0:	80 83       	st	Z, r24
}
     5a2:	08 95       	ret

000005a4 <PWM_timer4_Off_H4>:
void PWM_timer4_Off_H4(void)
{
	cbi(TCCR4A,COM4B1);
     5a4:	e0 ea       	ldi	r30, 0xA0	; 160
     5a6:	f0 e0       	ldi	r31, 0x00	; 0
     5a8:	80 81       	ld	r24, Z
     5aa:	8f 7d       	andi	r24, 0xDF	; 223
     5ac:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4B0);
     5ae:	80 81       	ld	r24, Z
     5b0:	8f 7e       	andi	r24, 0xEF	; 239
     5b2:	80 83       	st	Z, r24
}
     5b4:	08 95       	ret

000005b6 <PWM_timer4_Off_H5>:
void PWM_timer4_Off_H5(void)
{
	cbi(TCCR4A,COM4C1);
     5b6:	e0 ea       	ldi	r30, 0xA0	; 160
     5b8:	f0 e0       	ldi	r31, 0x00	; 0
     5ba:	80 81       	ld	r24, Z
     5bc:	87 7f       	andi	r24, 0xF7	; 247
     5be:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4C0);
     5c0:	80 81       	ld	r24, Z
     5c2:	8b 7f       	andi	r24, 0xFB	; 251
     5c4:	80 83       	st	Z, r24
}
     5c6:	08 95       	ret

000005c8 <PWM_timer1_Off_All>:


void PWM_timer1_Off_All(void)
{
	cbi(TCCR1A,PWM11);
     5c8:	e0 e8       	ldi	r30, 0x80	; 128
     5ca:	f0 e0       	ldi	r31, 0x00	; 0
     5cc:	80 81       	ld	r24, Z
     5ce:	8d 7f       	andi	r24, 0xFD	; 253
     5d0:	80 83       	st	Z, r24
	cbi(TCCR1A,PWM10);
     5d2:	80 81       	ld	r24, Z
     5d4:	8e 7f       	andi	r24, 0xFE	; 254
     5d6:	80 83       	st	Z, r24
}

//off commands
void PWM_timer1_Off_LED(void)
{
	cbi(TCCR1A,COM1B1);
     5d8:	80 81       	ld	r24, Z
     5da:	8f 7d       	andi	r24, 0xDF	; 223
     5dc:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B0);
     5de:	80 81       	ld	r24, Z
     5e0:	8f 7e       	andi	r24, 0xEF	; 239
     5e2:	80 83       	st	Z, r24
	cbi(TCCR1A,PWM11);
	cbi(TCCR1A,PWM10);
	//timer2PWMAOff();
	PWM_timer1_Off_LED();
	//timer2PWMCOff();
}
     5e4:	08 95       	ret

000005e6 <PWM_timer2_Off_All>:
void PWM_timer2_Off_All(void)
{
	cbi(TCCR2A,PWM11);
     5e6:	e0 eb       	ldi	r30, 0xB0	; 176
     5e8:	f0 e0       	ldi	r31, 0x00	; 0
     5ea:	80 81       	ld	r24, Z
     5ec:	8d 7f       	andi	r24, 0xFD	; 253
     5ee:	80 83       	st	Z, r24
	cbi(TCCR2A,PWM10);
     5f0:	80 81       	ld	r24, Z
     5f2:	8e 7f       	andi	r24, 0xFE	; 254
     5f4:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B1);
	cbi(TCCR1A,COM1B0);
}
void PWM_timer2_Off_H6(void)
{
	cbi(TCCR2A,COM2B1);
     5f6:	80 81       	ld	r24, Z
     5f8:	8f 7d       	andi	r24, 0xDF	; 223
     5fa:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B0);
     5fc:	80 81       	ld	r24, Z
     5fe:	8f 7e       	andi	r24, 0xEF	; 239
     600:	80 83       	st	Z, r24
	cbi(TCCR2A,PWM11);
	cbi(TCCR2A,PWM10);
	//timer2PWMAOff();
	PWM_timer2_Off_H6();
	//timer2PWMCOff();
}
     602:	08 95       	ret

00000604 <PWM_timer3_Off_All>:
void PWM_timer3_Off_All(void)
{
	cbi(TCCR3A,PWM11);
     604:	e0 e9       	ldi	r30, 0x90	; 144
     606:	f0 e0       	ldi	r31, 0x00	; 0
     608:	80 81       	ld	r24, Z
     60a:	8d 7f       	andi	r24, 0xFD	; 253
     60c:	80 83       	st	Z, r24
	cbi(TCCR3A,PWM10);
     60e:	80 81       	ld	r24, Z
     610:	8e 7f       	andi	r24, 0xFE	; 254
     612:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B1);
	cbi(TCCR2A,COM2B0);
}
void PWM_timer3_Off_E3(void)
{
	cbi(TCCR3A,COM3A1);
     614:	80 81       	ld	r24, Z
     616:	8f 77       	andi	r24, 0x7F	; 127
     618:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3A0);
     61a:	80 81       	ld	r24, Z
     61c:	8f 7b       	andi	r24, 0xBF	; 191
     61e:	80 83       	st	Z, r24
}
void PWM_timer3_Off_E4(void)
{
	cbi(TCCR3A,COM3B1);
     620:	80 81       	ld	r24, Z
     622:	8f 7d       	andi	r24, 0xDF	; 223
     624:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3B0);
     626:	80 81       	ld	r24, Z
     628:	8f 7e       	andi	r24, 0xEF	; 239
     62a:	80 83       	st	Z, r24
}
void PWM_timer3_Off_E5(void)
{
	cbi(TCCR3A,COM3C1);
     62c:	80 81       	ld	r24, Z
     62e:	87 7f       	andi	r24, 0xF7	; 247
     630:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C0);
     632:	80 81       	ld	r24, Z
     634:	8b 7f       	andi	r24, 0xFB	; 251
     636:	80 83       	st	Z, r24
	//timer2PWMAOff();
	PWM_timer3_Off_E3();
	PWM_timer3_Off_E4();
	PWM_timer3_Off_E5();
	//timer2PWMCOff();
}
     638:	08 95       	ret

0000063a <PWM_timer4_Off_All>:
void PWM_timer4_Off_All(void)
{
	cbi(TCCR4A,PWM11);
     63a:	e0 ea       	ldi	r30, 0xA0	; 160
     63c:	f0 e0       	ldi	r31, 0x00	; 0
     63e:	80 81       	ld	r24, Z
     640:	8d 7f       	andi	r24, 0xFD	; 253
     642:	80 83       	st	Z, r24
	cbi(TCCR4A,PWM10);
     644:	80 81       	ld	r24, Z
     646:	8e 7f       	andi	r24, 0xFE	; 254
     648:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C1);
	cbi(TCCR3A,COM3C0);
}
void PWM_timer4_Off_H3(void)
{
	cbi(TCCR4A,COM4A1);
     64a:	80 81       	ld	r24, Z
     64c:	8f 77       	andi	r24, 0x7F	; 127
     64e:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4A0);
     650:	80 81       	ld	r24, Z
     652:	8f 7b       	andi	r24, 0xBF	; 191
     654:	80 83       	st	Z, r24
}
void PWM_timer4_Off_H4(void)
{
	cbi(TCCR4A,COM4B1);
     656:	80 81       	ld	r24, Z
     658:	8f 7d       	andi	r24, 0xDF	; 223
     65a:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4B0);
     65c:	80 81       	ld	r24, Z
     65e:	8f 7e       	andi	r24, 0xEF	; 239
     660:	80 83       	st	Z, r24
}
void PWM_timer4_Off_H5(void)
{
	cbi(TCCR4A,COM4C1);
     662:	80 81       	ld	r24, Z
     664:	87 7f       	andi	r24, 0xF7	; 247
     666:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4C0);
     668:	80 81       	ld	r24, Z
     66a:	8b 7f       	andi	r24, 0xFB	; 251
     66c:	80 83       	st	Z, r24
	//timer2PWMAOff();
	PWM_timer4_Off_H3();
	PWM_timer4_Off_H4();
	PWM_timer4_Off_H5();
	//timer2PWMCOff();
}
     66e:	08 95       	ret

00000670 <PWM_timer1_Set_LED>:
// this PWM output is generated on OC2B pin
// NOTE:	pwmDuty should be in the range 0-255 for 8bit PWM
//			pwmDuty should be in the range 0-511 for 9bit PWM
//			pwmDuty should be in the range 0-1023 for 10bit PWM
void PWM_timer1_Set_LED(u16 pwmDuty)
	{OCR1B = pwmDuty;}
     670:	90 93 8b 00 	sts	0x008B, r25
     674:	80 93 8a 00 	sts	0x008A, r24
     678:	08 95       	ret

0000067a <PWM_timer2_Set_H6>:
void PWM_timer2_Set_H6(u16 pwmDuty)
	{OCR2B = pwmDuty;}
     67a:	80 93 b4 00 	sts	0x00B4, r24
     67e:	08 95       	ret

00000680 <PWM_timer3_Set_E3>:
void PWM_timer3_Set_E3(u16 pwmDuty)
	{OCR3A = pwmDuty;}
     680:	90 93 99 00 	sts	0x0099, r25
     684:	80 93 98 00 	sts	0x0098, r24
     688:	08 95       	ret

0000068a <PWM_timer3_Set_E4>:
void PWM_timer3_Set_E4(u16 pwmDuty)
	{OCR3B = pwmDuty;}
     68a:	90 93 9b 00 	sts	0x009B, r25
     68e:	80 93 9a 00 	sts	0x009A, r24
     692:	08 95       	ret

00000694 <PWM_timer3_Set_E5>:
void PWM_timer3_Set_E5(u16 pwmDuty)
	{OCR3C = pwmDuty;}
     694:	90 93 9d 00 	sts	0x009D, r25
     698:	80 93 9c 00 	sts	0x009C, r24
     69c:	08 95       	ret

0000069e <PWM_timer4_Set_H3>:
void PWM_timer4_Set_H3(u16 pwmDuty)
	{OCR4A = pwmDuty;}
     69e:	90 93 a9 00 	sts	0x00A9, r25
     6a2:	80 93 a8 00 	sts	0x00A8, r24
     6a6:	08 95       	ret

000006a8 <PWM_timer4_Set_H4>:
void PWM_timer4_Set_H4(u16 pwmDuty)
	{OCR4B = pwmDuty;}
     6a8:	90 93 ab 00 	sts	0x00AB, r25
     6ac:	80 93 aa 00 	sts	0x00AA, r24
     6b0:	08 95       	ret

000006b2 <PWM_timer4_Set_H5>:
void PWM_timer4_Set_H5(u16 pwmDuty)
	{OCR4C = pwmDuty;}
     6b2:	90 93 ad 00 	sts	0x00AD, r25
     6b6:	80 93 ac 00 	sts	0x00AC, r24
     6ba:	08 95       	ret

000006bc <configure_ports>:
	//cbi(DDRG, PG5);  //set G5 as input pin

	//ANALOG PORTS
	//useful for sensors, SharpIR, photoresistors, etc.
	//analog ports can be configured as digital ports if desired
	DDRF = 0b00000000;  //configure all F ports for input				0x00
     6bc:	10 ba       	out	0x10, r1	; 16
	PORTF = 0b00000000; //make sure pull-up resistors are turned off	0x00
     6be:	11 ba       	out	0x11, r1	; 17
	DDRK = 0b00000000;  //configure all K ports for input				0x00
     6c0:	10 92 07 01 	sts	0x0107, r1
	PORTK = 0b00000000; //make sure pull-up resistors are turned off	0x00
     6c4:	10 92 08 01 	sts	0x0108, r1

	//DIGITAL PORTS
	//useful for servos, PWM, LED's, UART, interrupts, timers
	DDRA = 0b11111111;  //configure ports for output
     6c8:	9f ef       	ldi	r25, 0xFF	; 255
     6ca:	91 b9       	out	0x01, r25	; 1
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	//PORTB reserved for programmer (use programmer pins if you know what you are doing)
	DDRB = _BV (PB6);	//PB6 is LED, hold low to turn it on
     6cc:	80 e4       	ldi	r24, 0x40	; 64
     6ce:	84 b9       	out	0x04, r24	; 4
	DDRC = 0b11111111;  //configure ports for output
     6d0:	97 b9       	out	0x07, r25	; 7
	//       ||||\______3: 
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 	
	sbi(PORTD, PD0); // SCL pull-up
     6d2:	58 9a       	sbi	0x0b, 0	; 11
	sbi(PORTD, PD1); // SDA pull-up
     6d4:	59 9a       	sbi	0x0b, 1	; 11
	DDRD = 0b11110011;  //configure ports for output
     6d6:	83 ef       	ldi	r24, 0xF3	; 243
     6d8:	8a b9       	out	0x0a, r24	; 10
	//       ||||\______3: serial TXD1, output -> 1
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: timer0
	DDRE = 0b11111110;  //configure ports for output
     6da:	8e ef       	ldi	r24, 0xFE	; 254
     6dc:	8d b9       	out	0x0d, r24	; 13
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	//cbi(PORTG, PG5);  // disable pull-up resistor for Axon v1e and earlier
	sbi(PORTG, PG5);  // enable pull-up resistor for v1f and later
     6de:	a5 9a       	sbi	0x14, 5	; 20
	cbi(DDRG, PG5);	//PG5 is for the button, make a digital input
     6e0:	9d 98       	cbi	0x13, 5	; 19
	//note that button actions are inverted between both versions!!!
	DDRH = 0b11111110;  //configure ports for output
     6e2:	80 93 01 01 	sts	0x0101, r24
	//       ||||\______3: 
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	DDRJ = 0b11111110;  //configure ports for output
     6e6:	80 93 04 01 	sts	0x0104, r24
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	//PORTL has no headers
	};
     6ea:	08 95       	ret

000006ec <delay_cycles>:
void delay_cycles(unsigned long int cycles)
	{
	cycles=cycles;//doubled frequency but too lazy to change times
	while(cycles > 0)
		cycles--;
	}
     6ec:	08 95       	ret

000006ee <LED_off>:


//***************STATUS LED**************
//tank test
void LED_off(void)
	{PORT_ON(PORTB,6);}
     6ee:	2e 9a       	sbi	0x05, 6	; 5
     6f0:	08 95       	ret

000006f2 <LED_on>:
void LED_on(void)
	{PORT_OFF(PORTB,6);}
     6f2:	2e 98       	cbi	0x05, 6	; 5
     6f4:	08 95       	ret

000006f6 <button_pressed>:


//*****************BUTTON****************
int button_pressed(void)
	{
	return (bit_is_clear(PING, 5));
     6f6:	22 b3       	in	r18, 0x12	; 18
     6f8:	30 e0       	ldi	r19, 0x00	; 0
     6fa:	85 e0       	ldi	r24, 0x05	; 5
     6fc:	36 95       	lsr	r19
     6fe:	27 95       	ror	r18
     700:	8a 95       	dec	r24
     702:	e1 f7       	brne	.-8      	; 0x6fc <button_pressed+0x6>
     704:	20 95       	com	r18
     706:	30 95       	com	r19
     708:	21 70       	andi	r18, 0x01	; 1
     70a:	30 70       	andi	r19, 0x00	; 0
	//return ((PING) & (1<<PG5));//old version, went high when button pushed
	}
     70c:	c9 01       	movw	r24, r18
     70e:	08 95       	ret

00000710 <cos_SoR>:
signed int angtable[73]={100,100,98,97,94,91,87,82,77,71,64,57,50,42,34,26,17,9,0,-9,-17,-26,-34,-42,-50,-57,-64,-71,-77,-82,-87,-91,-94,-97,-98,-100,
						 -100,-100,-98,-97,-94,-91,-87,-82,-77,-71,-64,-57,-50,-42,-34,-26,-17,-9,0,9,17,26,34,42,50,57,64,71,77,82,87,91,94,97,98,100,100};

signed int cos_SoR(long signed int degrees)//returns cos*100
	{
	if (degrees >= 0)//positive angles
     710:	97 fd       	sbrc	r25, 7
     712:	10 c0       	rjmp	.+32     	; 0x734 <cos_SoR+0x24>
		return angtable[degrees/5];
     714:	25 e0       	ldi	r18, 0x05	; 5
     716:	30 e0       	ldi	r19, 0x00	; 0
     718:	40 e0       	ldi	r20, 0x00	; 0
     71a:	50 e0       	ldi	r21, 0x00	; 0
     71c:	0e 94 bd 27 	call	0x4f7a	; 0x4f7a <__divmodsi4>
     720:	da 01       	movw	r26, r20
     722:	c9 01       	movw	r24, r18
     724:	88 0f       	add	r24, r24
     726:	99 1f       	adc	r25, r25
     728:	80 50       	subi	r24, 0x00	; 0
     72a:	9e 4f       	sbci	r25, 0xFE	; 254
     72c:	fc 01       	movw	r30, r24
     72e:	20 81       	ld	r18, Z
     730:	31 81       	ldd	r19, Z+1	; 0x01
     732:	17 c0       	rjmp	.+46     	; 0x762 <cos_SoR+0x52>
	else
		return -angtable[72-(-degrees)/5];
     734:	25 e0       	ldi	r18, 0x05	; 5
     736:	30 e0       	ldi	r19, 0x00	; 0
     738:	40 e0       	ldi	r20, 0x00	; 0
     73a:	50 e0       	ldi	r21, 0x00	; 0
     73c:	0e 94 bd 27 	call	0x4f7a	; 0x4f7a <__divmodsi4>
     740:	da 01       	movw	r26, r20
     742:	c9 01       	movw	r24, r18
     744:	88 5b       	subi	r24, 0xB8	; 184
     746:	9f 4f       	sbci	r25, 0xFF	; 255
     748:	af 4f       	sbci	r26, 0xFF	; 255
     74a:	bf 4f       	sbci	r27, 0xFF	; 255
     74c:	88 0f       	add	r24, r24
     74e:	99 1f       	adc	r25, r25
     750:	80 50       	subi	r24, 0x00	; 0
     752:	9e 4f       	sbci	r25, 0xFE	; 254
     754:	fc 01       	movw	r30, r24
     756:	80 81       	ld	r24, Z
     758:	91 81       	ldd	r25, Z+1	; 0x01
     75a:	22 27       	eor	r18, r18
     75c:	33 27       	eor	r19, r19
     75e:	28 1b       	sub	r18, r24
     760:	39 0b       	sbc	r19, r25
	}
     762:	c9 01       	movw	r24, r18
     764:	08 95       	ret

00000766 <sin_SoR>:

signed int sin_SoR(long signed int degrees)//returns sin*100
	{
	degrees=degrees - 90;//phase shift 90 degrees
     766:	6a 55       	subi	r22, 0x5A	; 90
     768:	70 40       	sbci	r23, 0x00	; 0
     76a:	80 40       	sbci	r24, 0x00	; 0
     76c:	90 40       	sbci	r25, 0x00	; 0

	if (degrees >= 0)//positive angles
     76e:	97 fd       	sbrc	r25, 7
     770:	10 c0       	rjmp	.+32     	; 0x792 <sin_SoR+0x2c>
		return angtable[degrees/5];
     772:	25 e0       	ldi	r18, 0x05	; 5
     774:	30 e0       	ldi	r19, 0x00	; 0
     776:	40 e0       	ldi	r20, 0x00	; 0
     778:	50 e0       	ldi	r21, 0x00	; 0
     77a:	0e 94 bd 27 	call	0x4f7a	; 0x4f7a <__divmodsi4>
     77e:	da 01       	movw	r26, r20
     780:	c9 01       	movw	r24, r18
     782:	88 0f       	add	r24, r24
     784:	99 1f       	adc	r25, r25
     786:	80 50       	subi	r24, 0x00	; 0
     788:	9e 4f       	sbci	r25, 0xFE	; 254
     78a:	fc 01       	movw	r30, r24
     78c:	20 81       	ld	r18, Z
     78e:	31 81       	ldd	r19, Z+1	; 0x01
     790:	17 c0       	rjmp	.+46     	; 0x7c0 <sin_SoR+0x5a>
	else
		return -angtable[72-(-degrees)/5];
     792:	25 e0       	ldi	r18, 0x05	; 5
     794:	30 e0       	ldi	r19, 0x00	; 0
     796:	40 e0       	ldi	r20, 0x00	; 0
     798:	50 e0       	ldi	r21, 0x00	; 0
     79a:	0e 94 bd 27 	call	0x4f7a	; 0x4f7a <__divmodsi4>
     79e:	da 01       	movw	r26, r20
     7a0:	c9 01       	movw	r24, r18
     7a2:	88 5b       	subi	r24, 0xB8	; 184
     7a4:	9f 4f       	sbci	r25, 0xFF	; 255
     7a6:	af 4f       	sbci	r26, 0xFF	; 255
     7a8:	bf 4f       	sbci	r27, 0xFF	; 255
     7aa:	88 0f       	add	r24, r24
     7ac:	99 1f       	adc	r25, r25
     7ae:	80 50       	subi	r24, 0x00	; 0
     7b0:	9e 4f       	sbci	r25, 0xFE	; 254
     7b2:	fc 01       	movw	r30, r24
     7b4:	80 81       	ld	r24, Z
     7b6:	91 81       	ldd	r25, Z+1	; 0x01
     7b8:	22 27       	eor	r18, r18
     7ba:	33 27       	eor	r19, r19
     7bc:	28 1b       	sub	r18, r24
     7be:	39 0b       	sbc	r19, r25
	}
     7c0:	c9 01       	movw	r24, r18
     7c2:	08 95       	ret

000007c4 <tan_SoR>:

signed int tan_SoR(long signed int degrees)//returns tan * 10
	{
     7c4:	cf 92       	push	r12
     7c6:	df 92       	push	r13
     7c8:	ef 92       	push	r14
     7ca:	ff 92       	push	r15
     7cc:	0f 93       	push	r16
     7ce:	1f 93       	push	r17
     7d0:	6b 01       	movw	r12, r22
     7d2:	7c 01       	movw	r14, r24
	//tan(x) = sin(x)/cos(x)
	if (degrees == 90 || degrees == -90 || degrees == 270 || degrees == -270)//blows up
     7d4:	8a e5       	ldi	r24, 0x5A	; 90
     7d6:	c8 16       	cp	r12, r24
     7d8:	d1 04       	cpc	r13, r1
     7da:	e1 04       	cpc	r14, r1
     7dc:	f1 04       	cpc	r15, r1
     7de:	a1 f1       	breq	.+104    	; 0x848 <tan_SoR+0x84>
     7e0:	86 ea       	ldi	r24, 0xA6	; 166
     7e2:	c8 16       	cp	r12, r24
     7e4:	8f ef       	ldi	r24, 0xFF	; 255
     7e6:	d8 06       	cpc	r13, r24
     7e8:	8f ef       	ldi	r24, 0xFF	; 255
     7ea:	e8 06       	cpc	r14, r24
     7ec:	8f ef       	ldi	r24, 0xFF	; 255
     7ee:	f8 06       	cpc	r15, r24
     7f0:	59 f1       	breq	.+86     	; 0x848 <tan_SoR+0x84>
     7f2:	8e e0       	ldi	r24, 0x0E	; 14
     7f4:	c8 16       	cp	r12, r24
     7f6:	81 e0       	ldi	r24, 0x01	; 1
     7f8:	d8 06       	cpc	r13, r24
     7fa:	80 e0       	ldi	r24, 0x00	; 0
     7fc:	e8 06       	cpc	r14, r24
     7fe:	80 e0       	ldi	r24, 0x00	; 0
     800:	f8 06       	cpc	r15, r24
     802:	11 f1       	breq	.+68     	; 0x848 <tan_SoR+0x84>
     804:	82 ef       	ldi	r24, 0xF2	; 242
     806:	c8 16       	cp	r12, r24
     808:	8e ef       	ldi	r24, 0xFE	; 254
     80a:	d8 06       	cpc	r13, r24
     80c:	8f ef       	ldi	r24, 0xFF	; 255
     80e:	e8 06       	cpc	r14, r24
     810:	8f ef       	ldi	r24, 0xFF	; 255
     812:	f8 06       	cpc	r15, r24
     814:	c9 f0       	breq	.+50     	; 0x848 <tan_SoR+0x84>
		return 0;//what else should I return?!?!?
	return sin_SoR(degrees)/cos_SoR(degrees)*10;
     816:	c7 01       	movw	r24, r14
     818:	b6 01       	movw	r22, r12
     81a:	0e 94 b3 03 	call	0x766	; 0x766 <sin_SoR>
     81e:	8c 01       	movw	r16, r24
     820:	c7 01       	movw	r24, r14
     822:	b6 01       	movw	r22, r12
     824:	0e 94 88 03 	call	0x710	; 0x710 <cos_SoR>
     828:	bc 01       	movw	r22, r24
     82a:	c8 01       	movw	r24, r16
     82c:	0e 94 88 27 	call	0x4f10	; 0x4f10 <__divmodhi4>
     830:	cb 01       	movw	r24, r22
     832:	9b 01       	movw	r18, r22
     834:	73 e0       	ldi	r23, 0x03	; 3
     836:	22 0f       	add	r18, r18
     838:	33 1f       	adc	r19, r19
     83a:	7a 95       	dec	r23
     83c:	e1 f7       	brne	.-8      	; 0x836 <tan_SoR+0x72>
     83e:	88 0f       	add	r24, r24
     840:	99 1f       	adc	r25, r25
     842:	28 0f       	add	r18, r24
     844:	39 1f       	adc	r19, r25
     846:	02 c0       	rjmp	.+4      	; 0x84c <tan_SoR+0x88>
     848:	20 e0       	ldi	r18, 0x00	; 0
     84a:	30 e0       	ldi	r19, 0x00	; 0
	}
     84c:	c9 01       	movw	r24, r18
     84e:	1f 91       	pop	r17
     850:	0f 91       	pop	r16
     852:	ff 90       	pop	r15
     854:	ef 90       	pop	r14
     856:	df 90       	pop	r13
     858:	cf 90       	pop	r12
     85a:	08 95       	ret

0000085c <lbRcv>:
//-----------------------------**&&**


void lbRcv(unsigned char c){
		
}
     85c:	08 95       	ret

0000085e <send_frame>:

/*************************************************/



void send_frame(float velocity, float omega){
     85e:	2f 92       	push	r2
     860:	3f 92       	push	r3
     862:	4f 92       	push	r4
     864:	5f 92       	push	r5
     866:	6f 92       	push	r6
     868:	7f 92       	push	r7
     86a:	8f 92       	push	r8
     86c:	9f 92       	push	r9
     86e:	af 92       	push	r10
     870:	bf 92       	push	r11
     872:	cf 92       	push	r12
     874:	df 92       	push	r13
     876:	ef 92       	push	r14
     878:	ff 92       	push	r15
     87a:	0f 93       	push	r16
     87c:	1f 93       	push	r17
     87e:	06 2f       	mov	r16, r22
     880:	f7 2e       	mov	r15, r23
     882:	e8 2e       	mov	r14, r24
     884:	d9 2e       	mov	r13, r25
     886:	c2 2e       	mov	r12, r18
     888:	b3 2e       	mov	r11, r19
     88a:	a4 2e       	mov	r10, r20
     88c:	95 2e       	mov	r9, r21
//send data frame
	
	// Break the floats into 4 bytes
	union u_vel fltuint8_velocity;
	union u_ome fltuint8_omega;
	fltuint8_velocity.f_vel = velocity;
     88e:	17 2f       	mov	r17, r23
	fltuint8_omega.f_ome = omega;
     890:	36 01       	movw	r6, r12
     892:	25 01       	movw	r4, r10
		
	// Send header
	uart0SendByte(0xFA);
     894:	8a ef       	ldi	r24, 0xFA	; 250
     896:	0e 94 5d 18 	call	0x30ba	; 0x30ba <uart0SendByte>

	// Send linear velocity
	uart0SendByte(fltuint8_velocity.arr_vel[0]);
     89a:	80 2f       	mov	r24, r16
     89c:	0e 94 5d 18 	call	0x30ba	; 0x30ba <uart0SendByte>
	uart0SendByte(fltuint8_velocity.arr_vel[1]);
     8a0:	8f 2d       	mov	r24, r15
     8a2:	0e 94 5d 18 	call	0x30ba	; 0x30ba <uart0SendByte>
	uart0SendByte(fltuint8_velocity.arr_vel[2]);
     8a6:	8e 2d       	mov	r24, r14
     8a8:	0e 94 5d 18 	call	0x30ba	; 0x30ba <uart0SendByte>
	uart0SendByte(fltuint8_velocity.arr_vel[3]);
     8ac:	8d 2d       	mov	r24, r13
     8ae:	0e 94 5d 18 	call	0x30ba	; 0x30ba <uart0SendByte>

	// Send angular velocity
	uart0SendByte(fltuint8_omega.arr_ome[0]);
     8b2:	8c 2d       	mov	r24, r12
     8b4:	0e 94 5d 18 	call	0x30ba	; 0x30ba <uart0SendByte>
	uart0SendByte(fltuint8_omega.arr_ome[1]);
     8b8:	8b 2d       	mov	r24, r11
     8ba:	0e 94 5d 18 	call	0x30ba	; 0x30ba <uart0SendByte>
	uart0SendByte(fltuint8_omega.arr_ome[2]);
     8be:	8a 2d       	mov	r24, r10
     8c0:	0e 94 5d 18 	call	0x30ba	; 0x30ba <uart0SendByte>
	uart0SendByte(fltuint8_omega.arr_ome[3]);
     8c4:	89 2d       	mov	r24, r9
     8c6:	0e 94 5d 18 	call	0x30ba	; 0x30ba <uart0SendByte>
	// Send checksum
	uint8_t chk = fltuint8_velocity.arr_vel[0] + fltuint8_velocity.arr_vel[1] + fltuint8_velocity.arr_vel[2]
	+ fltuint8_velocity.arr_vel[3] + fltuint8_omega.arr_ome[0] + fltuint8_omega.arr_ome[1] 
	+ fltuint8_omega.arr_ome[2] + fltuint8_omega.arr_ome[3];

	uart0SendByte(chk);
     8ca:	10 0f       	add	r17, r16
     8cc:	1e 0d       	add	r17, r14
     8ce:	17 0d       	add	r17, r7
     8d0:	16 0d       	add	r17, r6
     8d2:	15 0d       	add	r17, r5
     8d4:	14 0d       	add	r17, r4
     8d6:	81 2f       	mov	r24, r17
     8d8:	89 0d       	add	r24, r9
     8da:	0e 94 5d 18 	call	0x30ba	; 0x30ba <uart0SendByte>
}
     8de:	1f 91       	pop	r17
     8e0:	0f 91       	pop	r16
     8e2:	ff 90       	pop	r15
     8e4:	ef 90       	pop	r14
     8e6:	df 90       	pop	r13
     8e8:	cf 90       	pop	r12
     8ea:	bf 90       	pop	r11
     8ec:	af 90       	pop	r10
     8ee:	9f 90       	pop	r9
     8f0:	8f 90       	pop	r8
     8f2:	7f 90       	pop	r7
     8f4:	6f 90       	pop	r6
     8f6:	5f 90       	pop	r5
     8f8:	4f 90       	pop	r4
     8fa:	3f 90       	pop	r3
     8fc:	2f 90       	pop	r2
     8fe:	08 95       	ret

00000900 <prvSetupHardware>:
}

  


void prvSetupHardware(){
     900:	0f 93       	push	r16
     902:	1f 93       	push	r17
     904:	cf 93       	push	r28
     906:	df 93       	push	r29
	delay_cycles(65535);
	delay_cycles(65535);
	
	

	uartInit();  // initialize the UART (serial port)
     908:	0e 94 0f 1c 	call	0x381e	; 0x381e <uartInit>
    uartSetBaudRate(0, 38400); // set UARTE speed, for Bluetooth
     90c:	80 e0       	ldi	r24, 0x00	; 0
     90e:	40 e0       	ldi	r20, 0x00	; 0
     910:	56 e9       	ldi	r21, 0x96	; 150
     912:	60 e0       	ldi	r22, 0x00	; 0
     914:	70 e0       	ldi	r23, 0x00	; 0
     916:	0e 94 e9 17 	call	0x2fd2	; 0x2fd2 <uartSetBaudRate>
    uartSetBaudRate(1, 115200); // set UARTD speed, for USB connection, up to 500k, try 115200 if it doesn't work
     91a:	81 e0       	ldi	r24, 0x01	; 1
     91c:	40 e0       	ldi	r20, 0x00	; 0
     91e:	52 ec       	ldi	r21, 0xC2	; 194
     920:	61 e0       	ldi	r22, 0x01	; 1
     922:	70 e0       	ldi	r23, 0x00	; 0
     924:	0e 94 e9 17 	call	0x2fd2	; 0x2fd2 <uartSetBaudRate>
    uartSetBaudRate(2, 38400); // set UARTH speed
     928:	82 e0       	ldi	r24, 0x02	; 2
     92a:	40 e0       	ldi	r20, 0x00	; 0
     92c:	56 e9       	ldi	r21, 0x96	; 150
     92e:	60 e0       	ldi	r22, 0x00	; 0
     930:	70 e0       	ldi	r23, 0x00	; 0
     932:	0e 94 e9 17 	call	0x2fd2	; 0x2fd2 <uartSetBaudRate>
    uartSetBaudRate(3, 115200); // set UARTJ speed, for Blackfin
     936:	83 e0       	ldi	r24, 0x03	; 3
     938:	40 e0       	ldi	r20, 0x00	; 0
     93a:	52 ec       	ldi	r21, 0xC2	; 194
     93c:	61 e0       	ldi	r22, 0x01	; 1
     93e:	70 e0       	ldi	r23, 0x00	; 0
     940:	0e 94 e9 17 	call	0x2fd2	; 0x2fd2 <uartSetBaudRate>
	//G=Ground, T=Tx (connect to external Rx), R=Rx (connect to external Tx)

	rprintfInit(uart1SendByte);// initialize rprintf system and configure uart1 (USB) for rprintf
     944:	82 e6       	ldi	r24, 0x62	; 98
     946:	98 e1       	ldi	r25, 0x18	; 24
     948:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <rprintfInit>

	configure_ports(); // configure which ports are analog, digital, etc.
     94c:	0e 94 5e 03 	call	0x6bc	; 0x6bc <configure_ports>
	*/

	
	//UART ISR *** UART ISR ***
	
	uartSetRxHandler(0, &lbRcv);
     950:	80 e0       	ldi	r24, 0x00	; 0
     952:	6e e2       	ldi	r22, 0x2E	; 46
     954:	74 e0       	ldi	r23, 0x04	; 4
     956:	0e 94 de 17 	call	0x2fbc	; 0x2fbc <uartSetRxHandler>
	uartSetRxHandler(3, &LDSRcv);
     95a:	83 e0       	ldi	r24, 0x03	; 3
     95c:	69 e9       	ldi	r22, 0x99	; 153
     95e:	72 e2       	ldi	r23, 0x22	; 34
     960:	0e 94 de 17 	call	0x2fbc	; 0x2fbc <uartSetRxHandler>
//***************STATUS LED**************
//tank test
void LED_off(void)
	{PORT_ON(PORTB,6);}
void LED_on(void)
	{PORT_OFF(PORTB,6);}
     964:	2e 98       	cbi	0x05, 6	; 5

	//UART ISR *** UART ISR ***

	LED_on();

	rprintf("\r\nSystem Warmed Up");
     966:	00 d0       	rcall	.+0      	; 0x968 <prvSetupHardware+0x68>
     968:	0f 92       	push	r0
     96a:	81 e0       	ldi	r24, 0x01	; 1
     96c:	ed b7       	in	r30, 0x3d	; 61
     96e:	fe b7       	in	r31, 0x3e	; 62
     970:	81 83       	std	Z+1, r24	; 0x01
     972:	8f e2       	ldi	r24, 0x2F	; 47
     974:	91 e0       	ldi	r25, 0x01	; 1
     976:	93 83       	std	Z+3, r25	; 0x03
     978:	82 83       	std	Z+2, r24	; 0x02
     97a:	0e 94 77 1f 	call	0x3eee	; 0x3eee <rprintf1RamRom>

	// initialize the timer system
 	init_timer0(TIMER_CLK_1024);
     97e:	0f 90       	pop	r0
     980:	0f 90       	pop	r0
     982:	0f 90       	pop	r0
     984:	85 e0       	ldi	r24, 0x05	; 5
     986:	0e 94 f5 11 	call	0x23ea	; 0x23ea <init_timer0>
 	init_timer1(TIMER_CLK_64); // Timer 1 is initialized by FreeRTOS
     98a:	83 e0       	ldi	r24, 0x03	; 3
     98c:	0e 94 03 12 	call	0x2406	; 0x2406 <init_timer1>
 	//init_timer2(TIMER2_CLK_64);
	init_timer2(TIMER2_CLK_1024);
     990:	87 e0       	ldi	r24, 0x07	; 7
     992:	0e 94 15 12 	call	0x242a	; 0x242a <init_timer2>
 	init_timer3(TIMER_CLK_64);
     996:	83 e0       	ldi	r24, 0x03	; 3
     998:	0e 94 25 12 	call	0x244a	; 0x244a <init_timer3>
 	init_timer4(TIMER_CLK_64);
     99c:	83 e0       	ldi	r24, 0x03	; 3
     99e:	0e 94 37 12 	call	0x246e	; 0x246e <init_timer4>
 	init_timer5(TIMER_CLK_64);
     9a2:	83 e0       	ldi	r24, 0x03	; 3
     9a4:	0e 94 49 12 	call	0x2492	; 0x2492 <init_timer5>

	a2dInit(); // initialize analog to digital converter (ADC)
     9a8:	0e 94 c8 1c 	call	0x3990	; 0x3990 <a2dInit>
	a2dSetPrescaler(ADC_PRESCALE_DIV32); // configure ADC scaling
     9ac:	85 e0       	ldi	r24, 0x05	; 5
     9ae:	0e 94 ed 1c 	call	0x39da	; 0x39da <a2dSetPrescaler>
	a2dSetReference(ADC_REFERENCE_AVCC); // configure ADC reference voltage
     9b2:	81 e0       	ldi	r24, 0x01	; 1
     9b4:	0e 94 f4 1c 	call	0x39e8	; 0x39e8 <a2dSetReference>
     9b8:	10 e0       	ldi	r17, 0x00	; 0
	//let system stabelize for X time
	for(i=0;i<16;i++)
		{
		j=a2dConvert8bit(i);//read each ADC once to get it working accurately
		delay_cycles(5000); //keep LED on long enough to see Axon reseting
		rprintf(".");
     9ba:	01 e0       	ldi	r16, 0x01	; 1
     9bc:	cd e2       	ldi	r28, 0x2D	; 45
     9be:	d1 e0       	ldi	r29, 0x01	; 1
	a2dSetReference(ADC_REFERENCE_AVCC); // configure ADC reference voltage

	//let system stabelize for X time
	for(i=0;i<16;i++)
		{
		j=a2dConvert8bit(i);//read each ADC once to get it working accurately
     9c0:	81 2f       	mov	r24, r17
     9c2:	0e 94 3d 1d 	call	0x3a7a	; 0x3a7a <a2dConvert8bit>
		delay_cycles(5000); //keep LED on long enough to see Axon reseting
		rprintf(".");
     9c6:	00 d0       	rcall	.+0      	; 0x9c8 <prvSetupHardware+0xc8>
     9c8:	0f 92       	push	r0
     9ca:	ed b7       	in	r30, 0x3d	; 61
     9cc:	fe b7       	in	r31, 0x3e	; 62
     9ce:	01 83       	std	Z+1, r16	; 0x01
     9d0:	d3 83       	std	Z+3, r29	; 0x03
     9d2:	c2 83       	std	Z+2, r28	; 0x02
     9d4:	0e 94 77 1f 	call	0x3eee	; 0x3eee <rprintf1RamRom>
     9d8:	1f 5f       	subi	r17, 0xFF	; 255
	a2dInit(); // initialize analog to digital converter (ADC)
	a2dSetPrescaler(ADC_PRESCALE_DIV32); // configure ADC scaling
	a2dSetReference(ADC_REFERENCE_AVCC); // configure ADC reference voltage

	//let system stabelize for X time
	for(i=0;i<16;i++)
     9da:	0f 90       	pop	r0
     9dc:	0f 90       	pop	r0
     9de:	0f 90       	pop	r0
     9e0:	10 31       	cpi	r17, 0x10	; 16
     9e2:	71 f7       	brne	.-36     	; 0x9c0 <prvSetupHardware+0xc0>


//***************STATUS LED**************
//tank test
void LED_off(void)
	{PORT_ON(PORTB,6);}
     9e4:	2e 9a       	sbi	0x05, 6	; 5
		rprintf(".");
		}

	LED_off();

	rprintf("Initialization Complete \r\n");
     9e6:	00 d0       	rcall	.+0      	; 0x9e8 <prvSetupHardware+0xe8>
     9e8:	0f 92       	push	r0
     9ea:	ed b7       	in	r30, 0x3d	; 61
     9ec:	fe b7       	in	r31, 0x3e	; 62
     9ee:	01 83       	std	Z+1, r16	; 0x01
     9f0:	82 e1       	ldi	r24, 0x12	; 18
     9f2:	91 e0       	ldi	r25, 0x01	; 1
     9f4:	93 83       	std	Z+3, r25	; 0x03
     9f6:	82 83       	std	Z+2, r24	; 0x02
     9f8:	0e 94 77 1f 	call	0x3eee	; 0x3eee <rprintf1RamRom>

	//reset all timers to zero
	reset_timer0();
     9fc:	0f 90       	pop	r0
     9fe:	0f 90       	pop	r0
     a00:	0f 90       	pop	r0
     a02:	0e 94 ab 11 	call	0x2356	; 0x2356 <reset_timer0>
	reset_timer1();
     a06:	0e 94 b5 11 	call	0x236a	; 0x236a <reset_timer1>
	reset_timer2();
     a0a:	0e 94 c2 11 	call	0x2384	; 0x2384 <reset_timer2>
	reset_timer3();
     a0e:	0e 94 cd 11 	call	0x239a	; 0x239a <reset_timer3>
	reset_timer4();
     a12:	0e 94 da 11 	call	0x23b4	; 0x23b4 <reset_timer4>
	reset_timer5();
     a16:	0e 94 e7 11 	call	0x23ce	; 0x23ce <reset_timer5>


}
     a1a:	df 91       	pop	r29
     a1c:	cf 91       	pop	r28
     a1e:	1f 91       	pop	r17
     a20:	0f 91       	pop	r16
     a22:	08 95       	ret

00000a24 <main>:
	uart0SendByte(chk);
}


int main(void)
{
     a24:	4f 92       	push	r4
     a26:	5f 92       	push	r5
     a28:	6f 92       	push	r6
     a2a:	7f 92       	push	r7
     a2c:	8f 92       	push	r8
     a2e:	9f 92       	push	r9
     a30:	af 92       	push	r10
     a32:	bf 92       	push	r11
     a34:	cf 92       	push	r12
     a36:	df 92       	push	r13
     a38:	ef 92       	push	r14
     a3a:	ff 92       	push	r15
     a3c:	0f 93       	push	r16
     a3e:	1f 93       	push	r17
     a40:	df 93       	push	r29
     a42:	cf 93       	push	r28
     a44:	cd b7       	in	r28, 0x3d	; 61
     a46:	de b7       	in	r29, 0x3e	; 62
     a48:	c0 5d       	subi	r28, 0xD0	; 208
     a4a:	d2 40       	sbci	r29, 0x02	; 2
     a4c:	0f b6       	in	r0, 0x3f	; 63
     a4e:	f8 94       	cli
     a50:	de bf       	out	0x3e, r29	; 62
     a52:	0f be       	out	0x3f, r0	; 63
     a54:	cd bf       	out	0x3d, r28	; 61
	
	uint16_t ranges[360];
	init_LDS_buffer();
     a56:	0e 94 8e 22 	call	0x451c	; 0x451c <init_LDS_buffer>
	prvSetupHardware();
     a5a:	0e 94 80 04 	call	0x900	; 0x900 <prvSetupHardware>
	rprintf("Starting program.\n");
     a5e:	00 d0       	rcall	.+0      	; 0xa60 <main+0x3c>
     a60:	0f 92       	push	r0
     a62:	81 e0       	ldi	r24, 0x01	; 1
     a64:	ad b7       	in	r26, 0x3d	; 61
     a66:	be b7       	in	r27, 0x3e	; 62
     a68:	11 96       	adiw	r26, 0x01	; 1
     a6a:	8c 93       	st	X, r24
     a6c:	11 97       	sbiw	r26, 0x01	; 1
     a6e:	8f ef       	ldi	r24, 0xFF	; 255
     a70:	90 e0       	ldi	r25, 0x00	; 0
     a72:	13 96       	adiw	r26, 0x03	; 3
     a74:	9c 93       	st	X, r25
     a76:	8e 93       	st	-X, r24
     a78:	12 97       	sbiw	r26, 0x02	; 2
     a7a:	0e 94 77 1f 	call	0x3eee	; 0x3eee <rprintf1RamRom>
     a7e:	0f 90       	pop	r0
     a80:	0f 90       	pop	r0
     a82:	0f 90       	pop	r0

	while(1){
		// Print ranges
		rprintf("Scan start\n");
     a84:	55 24       	eor	r5, r5
     a86:	53 94       	inc	r5
     a88:	b3 ef       	ldi	r27, 0xF3	; 243
     a8a:	6b 2e       	mov	r6, r27
     a8c:	b0 e0       	ldi	r27, 0x00	; 0
     a8e:	7b 2e       	mov	r7, r27
		get_range_scan(ranges);
     a90:	7e 01       	movw	r14, r28
     a92:	08 94       	sec
     a94:	e1 1c       	adc	r14, r1
     a96:	f1 1c       	adc	r15, r1
		for(uint16_t r_ndx = 0; r_ndx < 360; r_ndx++){
			rprintf("%d",ranges[r_ndx]);
     a98:	a0 ef       	ldi	r26, 0xF0	; 240
     a9a:	8a 2e       	mov	r8, r26
     a9c:	a0 e0       	ldi	r26, 0x00	; 0
     a9e:	9a 2e       	mov	r9, r26

	while(1){
		// Print ranges
		rprintf("Scan start\n");
		get_range_scan(ranges);
		for(uint16_t r_ndx = 0; r_ndx < 360; r_ndx++){
     aa0:	f1 ed       	ldi	r31, 0xD1	; 209
     aa2:	af 2e       	mov	r10, r31
     aa4:	f2 e0       	ldi	r31, 0x02	; 2
     aa6:	bf 2e       	mov	r11, r31
     aa8:	ac 0e       	add	r10, r28
     aaa:	bd 1e       	adc	r11, r29
			rprintf("%d",ranges[r_ndx]);
     aac:	44 24       	eor	r4, r4
     aae:	43 94       	inc	r4
			rprintfCRLF();
		}
		rprintf("\nScan end\n\n");
     ab0:	e4 ee       	ldi	r30, 0xE4	; 228
     ab2:	ce 2e       	mov	r12, r30
     ab4:	e0 e0       	ldi	r30, 0x00	; 0
     ab6:	de 2e       	mov	r13, r30
	prvSetupHardware();
	rprintf("Starting program.\n");

	while(1){
		// Print ranges
		rprintf("Scan start\n");
     ab8:	00 d0       	rcall	.+0      	; 0xaba <main+0x96>
     aba:	0f 92       	push	r0
     abc:	ed b7       	in	r30, 0x3d	; 61
     abe:	fe b7       	in	r31, 0x3e	; 62
     ac0:	51 82       	std	Z+1, r5	; 0x01
     ac2:	73 82       	std	Z+3, r7	; 0x03
     ac4:	62 82       	std	Z+2, r6	; 0x02
     ac6:	0e 94 77 1f 	call	0x3eee	; 0x3eee <rprintf1RamRom>
		get_range_scan(ranges);
     aca:	0f 90       	pop	r0
     acc:	0f 90       	pop	r0
     ace:	0f 90       	pop	r0
     ad0:	c7 01       	movw	r24, r14
     ad2:	0e 94 03 25 	call	0x4a06	; 0x4a06 <get_range_scan>
     ad6:	87 01       	movw	r16, r14
		for(uint16_t r_ndx = 0; r_ndx < 360; r_ndx++){
			rprintf("%d",ranges[r_ndx]);
     ad8:	00 d0       	rcall	.+0      	; 0xada <main+0xb6>
     ada:	00 d0       	rcall	.+0      	; 0xadc <main+0xb8>
     adc:	0f 92       	push	r0
     ade:	ed b7       	in	r30, 0x3d	; 61
     ae0:	fe b7       	in	r31, 0x3e	; 62
     ae2:	31 96       	adiw	r30, 0x01	; 1
     ae4:	ad b7       	in	r26, 0x3d	; 61
     ae6:	be b7       	in	r27, 0x3e	; 62
     ae8:	11 96       	adiw	r26, 0x01	; 1
     aea:	5c 92       	st	X, r5
     aec:	92 82       	std	Z+2, r9	; 0x02
     aee:	81 82       	std	Z+1, r8	; 0x01
     af0:	d8 01       	movw	r26, r16
     af2:	8d 91       	ld	r24, X+
     af4:	9d 91       	ld	r25, X+
     af6:	8d 01       	movw	r16, r26
     af8:	94 83       	std	Z+4, r25	; 0x04
     afa:	83 83       	std	Z+3, r24	; 0x03
     afc:	0e 94 77 1f 	call	0x3eee	; 0x3eee <rprintf1RamRom>
			rprintfCRLF();
     b00:	0f 90       	pop	r0
     b02:	0f 90       	pop	r0
     b04:	0f 90       	pop	r0
     b06:	0f 90       	pop	r0
     b08:	0f 90       	pop	r0
     b0a:	0e 94 b7 1d 	call	0x3b6e	; 0x3b6e <rprintfCRLF>

	while(1){
		// Print ranges
		rprintf("Scan start\n");
		get_range_scan(ranges);
		for(uint16_t r_ndx = 0; r_ndx < 360; r_ndx++){
     b0e:	0a 15       	cp	r16, r10
     b10:	1b 05       	cpc	r17, r11
     b12:	11 f7       	brne	.-60     	; 0xad8 <main+0xb4>
			rprintf("%d",ranges[r_ndx]);
			rprintfCRLF();
		}
		rprintf("\nScan end\n\n");
     b14:	00 d0       	rcall	.+0      	; 0xb16 <main+0xf2>
     b16:	0f 92       	push	r0
     b18:	ed b7       	in	r30, 0x3d	; 61
     b1a:	fe b7       	in	r31, 0x3e	; 62
     b1c:	41 82       	std	Z+1, r4	; 0x01
     b1e:	d3 82       	std	Z+3, r13	; 0x03
     b20:	c2 82       	std	Z+2, r12	; 0x02
     b22:	0e 94 77 1f 	call	0x3eee	; 0x3eee <rprintf1RamRom>

		//for(uint8_t ndx = 0; ndx < 100; ndx++){
		//	rprintf("nop\n");
		//}
		delay_ms(1000);
     b26:	0f 90       	pop	r0
     b28:	0f 90       	pop	r0
     b2a:	0f 90       	pop	r0
     b2c:	88 ee       	ldi	r24, 0xE8	; 232
     b2e:	93 e0       	ldi	r25, 0x03	; 3
     b30:	0e 94 70 12 	call	0x24e0	; 0x24e0 <sleep>
     b34:	c1 cf       	rjmp	.-126    	; 0xab8 <main+0x94>

00000b36 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     b36:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     b38:	9c 01       	movw	r18, r24
     b3a:	2d 5f       	subi	r18, 0xFD	; 253
     b3c:	3f 4f       	sbci	r19, 0xFF	; 255
     b3e:	32 83       	std	Z+2, r19	; 0x02
     b40:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     b42:	8f ef       	ldi	r24, 0xFF	; 255
     b44:	9f ef       	ldi	r25, 0xFF	; 255
     b46:	94 83       	std	Z+4, r25	; 0x04
     b48:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     b4a:	36 83       	std	Z+6, r19	; 0x06
     b4c:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     b4e:	30 87       	std	Z+8, r19	; 0x08
     b50:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = 0;
     b52:	10 82       	st	Z, r1
}
     b54:	08 95       	ret

00000b56 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     b56:	fc 01       	movw	r30, r24
     b58:	11 86       	std	Z+9, r1	; 0x09
     b5a:	10 86       	std	Z+8, r1	; 0x08
}
     b5c:	08 95       	ret

00000b5e <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     b5e:	cf 93       	push	r28
     b60:	df 93       	push	r29
     b62:	ac 01       	movw	r20, r24
     b64:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     b66:	ec 01       	movw	r28, r24
     b68:	29 81       	ldd	r18, Y+1	; 0x01
     b6a:	3a 81       	ldd	r19, Y+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     b6c:	f9 01       	movw	r30, r18
     b6e:	82 81       	ldd	r24, Z+2	; 0x02
     b70:	93 81       	ldd	r25, Z+3	; 0x03
     b72:	13 96       	adiw	r26, 0x03	; 3
     b74:	9c 93       	st	X, r25
     b76:	8e 93       	st	-X, r24
     b78:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
     b7a:	89 81       	ldd	r24, Y+1	; 0x01
     b7c:	9a 81       	ldd	r25, Y+2	; 0x02
     b7e:	15 96       	adiw	r26, 0x05	; 5
     b80:	9c 93       	st	X, r25
     b82:	8e 93       	st	-X, r24
     b84:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     b86:	02 80       	ldd	r0, Z+2	; 0x02
     b88:	f3 81       	ldd	r31, Z+3	; 0x03
     b8a:	e0 2d       	mov	r30, r0
     b8c:	75 83       	std	Z+5, r23	; 0x05
     b8e:	64 83       	std	Z+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     b90:	e9 01       	movw	r28, r18
     b92:	7b 83       	std	Y+3, r23	; 0x03
     b94:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     b96:	fa 01       	movw	r30, r20
     b98:	72 83       	std	Z+2, r23	; 0x02
     b9a:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     b9c:	19 96       	adiw	r26, 0x09	; 9
     b9e:	5c 93       	st	X, r21
     ba0:	4e 93       	st	-X, r20
     ba2:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
     ba4:	80 81       	ld	r24, Z
     ba6:	8f 5f       	subi	r24, 0xFF	; 255
     ba8:	80 83       	st	Z, r24
}
     baa:	df 91       	pop	r29
     bac:	cf 91       	pop	r28
     bae:	08 95       	ret

00000bb0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     bb0:	cf 93       	push	r28
     bb2:	df 93       	push	r29
     bb4:	9c 01       	movw	r18, r24
     bb6:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     bb8:	48 81       	ld	r20, Y
     bba:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as 
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the 
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     bbc:	8f ef       	ldi	r24, 0xFF	; 255
     bbe:	4f 3f       	cpi	r20, 0xFF	; 255
     bc0:	58 07       	cpc	r21, r24
     bc2:	21 f4       	brne	.+8      	; 0xbcc <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     bc4:	f9 01       	movw	r30, r18
     bc6:	a7 81       	ldd	r26, Z+7	; 0x07
     bc8:	b0 85       	ldd	r27, Z+8	; 0x08
     bca:	10 c0       	rjmp	.+32     	; 0xbec <vListInsert+0x3c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips. 
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     bcc:	d9 01       	movw	r26, r18
     bce:	13 96       	adiw	r26, 0x03	; 3
     bd0:	04 c0       	rjmp	.+8      	; 0xbda <vListInsert+0x2a>
     bd2:	12 96       	adiw	r26, 0x02	; 2
     bd4:	0d 90       	ld	r0, X+
     bd6:	bc 91       	ld	r27, X
     bd8:	a0 2d       	mov	r26, r0
     bda:	12 96       	adiw	r26, 0x02	; 2
     bdc:	ed 91       	ld	r30, X+
     bde:	fc 91       	ld	r31, X
     be0:	13 97       	sbiw	r26, 0x03	; 3
     be2:	80 81       	ld	r24, Z
     be4:	91 81       	ldd	r25, Z+1	; 0x01
     be6:	48 17       	cp	r20, r24
     be8:	59 07       	cpc	r21, r25
     bea:	98 f7       	brcc	.-26     	; 0xbd2 <vListInsert+0x22>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     bec:	12 96       	adiw	r26, 0x02	; 2
     bee:	ed 91       	ld	r30, X+
     bf0:	fc 91       	ld	r31, X
     bf2:	13 97       	sbiw	r26, 0x03	; 3
     bf4:	fb 83       	std	Y+3, r31	; 0x03
     bf6:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     bf8:	d5 83       	std	Z+5, r29	; 0x05
     bfa:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     bfc:	bd 83       	std	Y+5, r27	; 0x05
     bfe:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     c00:	13 96       	adiw	r26, 0x03	; 3
     c02:	dc 93       	st	X, r29
     c04:	ce 93       	st	-X, r28
     c06:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     c08:	39 87       	std	Y+9, r19	; 0x09
     c0a:	28 87       	std	Y+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     c0c:	f9 01       	movw	r30, r18
     c0e:	80 81       	ld	r24, Z
     c10:	8f 5f       	subi	r24, 0xFF	; 255
     c12:	80 83       	st	Z, r24
}
     c14:	df 91       	pop	r29
     c16:	cf 91       	pop	r28
     c18:	08 95       	ret

00000c1a <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     c1a:	cf 93       	push	r28
     c1c:	df 93       	push	r29
     c1e:	dc 01       	movw	r26, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     c20:	12 96       	adiw	r26, 0x02	; 2
     c22:	ed 91       	ld	r30, X+
     c24:	fc 91       	ld	r31, X
     c26:	13 97       	sbiw	r26, 0x03	; 3
     c28:	14 96       	adiw	r26, 0x04	; 4
     c2a:	8d 91       	ld	r24, X+
     c2c:	9c 91       	ld	r25, X
     c2e:	15 97       	sbiw	r26, 0x05	; 5
     c30:	95 83       	std	Z+5, r25	; 0x05
     c32:	84 83       	std	Z+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     c34:	14 96       	adiw	r26, 0x04	; 4
     c36:	cd 91       	ld	r28, X+
     c38:	dc 91       	ld	r29, X
     c3a:	15 97       	sbiw	r26, 0x05	; 5
     c3c:	fb 83       	std	Y+3, r31	; 0x03
     c3e:	ea 83       	std	Y+2, r30	; 0x02
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     c40:	18 96       	adiw	r26, 0x08	; 8
     c42:	ed 91       	ld	r30, X+
     c44:	fc 91       	ld	r31, X
     c46:	19 97       	sbiw	r26, 0x09	; 9

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     c48:	81 81       	ldd	r24, Z+1	; 0x01
     c4a:	92 81       	ldd	r25, Z+2	; 0x02
     c4c:	8a 17       	cp	r24, r26
     c4e:	9b 07       	cpc	r25, r27
     c50:	11 f4       	brne	.+4      	; 0xc56 <vListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     c52:	d2 83       	std	Z+2, r29	; 0x02
     c54:	c1 83       	std	Z+1, r28	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
     c56:	19 96       	adiw	r26, 0x09	; 9
     c58:	1c 92       	st	X, r1
     c5a:	1e 92       	st	-X, r1
     c5c:	18 97       	sbiw	r26, 0x08	; 8
	( pxList->uxNumberOfItems )--;
     c5e:	80 81       	ld	r24, Z
     c60:	81 50       	subi	r24, 0x01	; 1
     c62:	80 83       	st	Z, r24
}
     c64:	df 91       	pop	r29
     c66:	cf 91       	pop	r28
     c68:	08 95       	ret

00000c6a <uxQueueMessagesWaiting>:
	return xReturn;
}
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
     c6a:	fc 01       	movw	r30, r24
unsigned portBASE_TYPE uxReturn;

	taskENTER_CRITICAL();
     c6c:	0f b6       	in	r0, 0x3f	; 63
     c6e:	f8 94       	cli
     c70:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
     c72:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     c74:	0f 90       	pop	r0
     c76:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
     c78:	08 95       	ret

00000c7a <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
     c7a:	fc 01       	movw	r30, r24
unsigned portBASE_TYPE uxReturn;

	uxReturn = pxQueue->uxMessagesWaiting;
     c7c:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
     c7e:	08 95       	ret

00000c80 <xQueueIsQueueEmptyFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
     c80:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
     c82:	82 8d       	ldd	r24, Z+26	; 0x1a
     c84:	90 e0       	ldi	r25, 0x00	; 0
     c86:	88 23       	and	r24, r24
     c88:	09 f4       	brne	.+2      	; 0xc8c <xQueueIsQueueEmptyFromISR+0xc>
     c8a:	91 e0       	ldi	r25, 0x01	; 1

	return xReturn;
}
     c8c:	89 2f       	mov	r24, r25
     c8e:	08 95       	ret

00000c90 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
     c90:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
     c92:	92 8d       	ldd	r25, Z+26	; 0x1a
     c94:	20 e0       	ldi	r18, 0x00	; 0
     c96:	83 8d       	ldd	r24, Z+27	; 0x1b
     c98:	98 17       	cp	r25, r24
     c9a:	09 f4       	brne	.+2      	; 0xc9e <xQueueIsQueueFullFromISR+0xe>
     c9c:	21 e0       	ldi	r18, 0x01	; 1

	return xReturn;
}
     c9e:	82 2f       	mov	r24, r18
     ca0:	08 95       	ret

00000ca2 <vQueueDelete>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
     ca2:	0f 93       	push	r16
     ca4:	1f 93       	push	r17
     ca6:	8c 01       	movw	r16, r24
	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
     ca8:	fc 01       	movw	r30, r24
     caa:	80 81       	ld	r24, Z
     cac:	91 81       	ldd	r25, Z+1	; 0x01
     cae:	0e 94 aa 10 	call	0x2154	; 0x2154 <vPortFree>
	vPortFree( pxQueue );
     cb2:	c8 01       	movw	r24, r16
     cb4:	0e 94 aa 10 	call	0x2154	; 0x2154 <vPortFree>
}
     cb8:	1f 91       	pop	r17
     cba:	0f 91       	pop	r16
     cbc:	08 95       	ret

00000cbe <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
     cbe:	0f 93       	push	r16
     cc0:	1f 93       	push	r17
     cc2:	cf 93       	push	r28
     cc4:	df 93       	push	r29
     cc6:	ec 01       	movw	r28, r24
     cc8:	fb 01       	movw	r30, r22
     cca:	8a 01       	movw	r16, r20
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
     ccc:	8a 8d       	ldd	r24, Y+26	; 0x1a
     cce:	88 23       	and	r24, r24
     cd0:	81 f1       	breq	.+96     	; 0xd32 <xQueueReceiveFromISR+0x74>
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
     cd2:	48 81       	ld	r20, Y
     cd4:	59 81       	ldd	r21, Y+1	; 0x01
     cd6:	41 15       	cp	r20, r1
     cd8:	51 05       	cpc	r21, r1
     cda:	a9 f0       	breq	.+42     	; 0xd06 <xQueueReceiveFromISR+0x48>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
     cdc:	8c 8d       	ldd	r24, Y+28	; 0x1c
     cde:	2e 81       	ldd	r18, Y+6	; 0x06
     ce0:	3f 81       	ldd	r19, Y+7	; 0x07
     ce2:	28 0f       	add	r18, r24
     ce4:	31 1d       	adc	r19, r1
     ce6:	3f 83       	std	Y+7, r19	; 0x07
     ce8:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
     cea:	8a 81       	ldd	r24, Y+2	; 0x02
     cec:	9b 81       	ldd	r25, Y+3	; 0x03
     cee:	28 17       	cp	r18, r24
     cf0:	39 07       	cpc	r19, r25
     cf2:	10 f0       	brcs	.+4      	; 0xcf8 <xQueueReceiveFromISR+0x3a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
     cf4:	5f 83       	std	Y+7, r21	; 0x07
     cf6:	4e 83       	std	Y+6, r20	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
     cf8:	4c 8d       	ldd	r20, Y+28	; 0x1c
     cfa:	6e 81       	ldd	r22, Y+6	; 0x06
     cfc:	7f 81       	ldd	r23, Y+7	; 0x07
     cfe:	cf 01       	movw	r24, r30
     d00:	50 e0       	ldi	r21, 0x00	; 0
     d02:	0e 94 3f 25 	call	0x4a7e	; 0x4a7e <memcpy>
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
			--( pxQueue->uxMessagesWaiting );
     d06:	8a 8d       	ldd	r24, Y+26	; 0x1a
     d08:	81 50       	subi	r24, 0x01	; 1
     d0a:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
     d0c:	8d 8d       	ldd	r24, Y+29	; 0x1d
     d0e:	8f 3f       	cpi	r24, 0xFF	; 255
     d10:	69 f4       	brne	.+26     	; 0xd2c <xQueueReceiveFromISR+0x6e>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
     d12:	88 85       	ldd	r24, Y+8	; 0x08
     d14:	88 23       	and	r24, r24
     d16:	61 f0       	breq	.+24     	; 0xd30 <xQueueReceiveFromISR+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     d18:	ce 01       	movw	r24, r28
     d1a:	08 96       	adiw	r24, 0x08	; 8
     d1c:	0e 94 bf 09 	call	0x137e	; 0x137e <xTaskRemoveFromEventList>
     d20:	88 23       	and	r24, r24
     d22:	31 f0       	breq	.+12     	; 0xd30 <xQueueReceiveFromISR+0x72>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
     d24:	81 e0       	ldi	r24, 0x01	; 1
     d26:	f8 01       	movw	r30, r16
     d28:	80 83       	st	Z, r24
     d2a:	03 c0       	rjmp	.+6      	; 0xd32 <xQueueReceiveFromISR+0x74>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
     d2c:	8f 5f       	subi	r24, 0xFF	; 255
     d2e:	8d 8f       	std	Y+29, r24	; 0x1d
     d30:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     d32:	df 91       	pop	r29
     d34:	cf 91       	pop	r28
     d36:	1f 91       	pop	r17
     d38:	0f 91       	pop	r16
     d3a:	08 95       	ret

00000d3c <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
     d3c:	cf 93       	push	r28
     d3e:	df 93       	push	r29
     d40:	ec 01       	movw	r28, r24
     d42:	84 2f       	mov	r24, r20
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
     d44:	4c 8d       	ldd	r20, Y+28	; 0x1c
     d46:	44 23       	and	r20, r20
     d48:	a1 f1       	breq	.+104    	; 0xdb2 <prvCopyDataToQueue+0x76>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
     d4a:	88 23       	and	r24, r24
     d4c:	b1 f4       	brne	.+44     	; 0xd7a <prvCopyDataToQueue+0x3e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     d4e:	8c 81       	ldd	r24, Y+4	; 0x04
     d50:	9d 81       	ldd	r25, Y+5	; 0x05
     d52:	50 e0       	ldi	r21, 0x00	; 0
     d54:	0e 94 3f 25 	call	0x4a7e	; 0x4a7e <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     d58:	8c 8d       	ldd	r24, Y+28	; 0x1c
     d5a:	2c 81       	ldd	r18, Y+4	; 0x04
     d5c:	3d 81       	ldd	r19, Y+5	; 0x05
     d5e:	28 0f       	add	r18, r24
     d60:	31 1d       	adc	r19, r1
     d62:	3d 83       	std	Y+5, r19	; 0x05
     d64:	2c 83       	std	Y+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
     d66:	8a 81       	ldd	r24, Y+2	; 0x02
     d68:	9b 81       	ldd	r25, Y+3	; 0x03
     d6a:	28 17       	cp	r18, r24
     d6c:	39 07       	cpc	r19, r25
     d6e:	08 f1       	brcs	.+66     	; 0xdb2 <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     d70:	88 81       	ld	r24, Y
     d72:	99 81       	ldd	r25, Y+1	; 0x01
     d74:	9d 83       	std	Y+5, r25	; 0x05
     d76:	8c 83       	std	Y+4, r24	; 0x04
     d78:	1c c0       	rjmp	.+56     	; 0xdb2 <prvCopyDataToQueue+0x76>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     d7a:	8e 81       	ldd	r24, Y+6	; 0x06
     d7c:	9f 81       	ldd	r25, Y+7	; 0x07
     d7e:	50 e0       	ldi	r21, 0x00	; 0
     d80:	0e 94 3f 25 	call	0x4a7e	; 0x4a7e <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
     d84:	8c 8d       	ldd	r24, Y+28	; 0x1c
     d86:	90 e0       	ldi	r25, 0x00	; 0
     d88:	44 27       	eor	r20, r20
     d8a:	55 27       	eor	r21, r21
     d8c:	48 1b       	sub	r20, r24
     d8e:	59 0b       	sbc	r21, r25
     d90:	8e 81       	ldd	r24, Y+6	; 0x06
     d92:	9f 81       	ldd	r25, Y+7	; 0x07
     d94:	84 0f       	add	r24, r20
     d96:	95 1f       	adc	r25, r21
     d98:	9f 83       	std	Y+7, r25	; 0x07
     d9a:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
     d9c:	28 81       	ld	r18, Y
     d9e:	39 81       	ldd	r19, Y+1	; 0x01
     da0:	82 17       	cp	r24, r18
     da2:	93 07       	cpc	r25, r19
     da4:	30 f4       	brcc	.+12     	; 0xdb2 <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     da6:	8a 81       	ldd	r24, Y+2	; 0x02
     da8:	9b 81       	ldd	r25, Y+3	; 0x03
     daa:	84 0f       	add	r24, r20
     dac:	95 1f       	adc	r25, r21
     dae:	9f 83       	std	Y+7, r25	; 0x07
     db0:	8e 83       	std	Y+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
     db2:	8a 8d       	ldd	r24, Y+26	; 0x1a
     db4:	8f 5f       	subi	r24, 0xFF	; 255
     db6:	8a 8f       	std	Y+26, r24	; 0x1a
}
     db8:	df 91       	pop	r29
     dba:	cf 91       	pop	r28
     dbc:	08 95       	ret

00000dbe <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
     dbe:	0f 93       	push	r16
     dc0:	1f 93       	push	r17
     dc2:	cf 93       	push	r28
     dc4:	df 93       	push	r29
     dc6:	ec 01       	movw	r28, r24
     dc8:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     dca:	9a 8d       	ldd	r25, Y+26	; 0x1a
     dcc:	8b 8d       	ldd	r24, Y+27	; 0x1b
     dce:	98 17       	cp	r25, r24
     dd0:	10 f0       	brcs	.+4      	; 0xdd6 <xQueueGenericSendFromISR+0x18>
     dd2:	80 e0       	ldi	r24, 0x00	; 0
     dd4:	17 c0       	rjmp	.+46     	; 0xe04 <xQueueGenericSendFromISR+0x46>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     dd6:	ce 01       	movw	r24, r28
     dd8:	42 2f       	mov	r20, r18
     dda:	0e 94 9e 06 	call	0xd3c	; 0xd3c <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
     dde:	8e 8d       	ldd	r24, Y+30	; 0x1e
     de0:	8f 3f       	cpi	r24, 0xFF	; 255
     de2:	69 f4       	brne	.+26     	; 0xdfe <xQueueGenericSendFromISR+0x40>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
     de4:	89 89       	ldd	r24, Y+17	; 0x11
     de6:	88 23       	and	r24, r24
     de8:	61 f0       	breq	.+24     	; 0xe02 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     dea:	ce 01       	movw	r24, r28
     dec:	41 96       	adiw	r24, 0x11	; 17
     dee:	0e 94 bf 09 	call	0x137e	; 0x137e <xTaskRemoveFromEventList>
     df2:	88 23       	and	r24, r24
     df4:	31 f0       	breq	.+12     	; 0xe02 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
     df6:	81 e0       	ldi	r24, 0x01	; 1
     df8:	f8 01       	movw	r30, r16
     dfa:	80 83       	st	Z, r24
     dfc:	03 c0       	rjmp	.+6      	; 0xe04 <xQueueGenericSendFromISR+0x46>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
     dfe:	8f 5f       	subi	r24, 0xFF	; 255
     e00:	8e 8f       	std	Y+30, r24	; 0x1e
     e02:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     e04:	df 91       	pop	r29
     e06:	cf 91       	pop	r28
     e08:	1f 91       	pop	r17
     e0a:	0f 91       	pop	r16
     e0c:	08 95       	ret

00000e0e <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
     e0e:	0f 93       	push	r16
     e10:	1f 93       	push	r17
     e12:	cf 93       	push	r28
     e14:	df 93       	push	r29
     e16:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     e18:	0f b6       	in	r0, 0x3f	; 63
     e1a:	f8 94       	cli
     e1c:	0f 92       	push	r0
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     e1e:	8c 01       	movw	r16, r24
     e20:	0f 5e       	subi	r16, 0xEF	; 239
     e22:	1f 4f       	sbci	r17, 0xFF	; 255
     e24:	0d c0       	rjmp	.+26     	; 0xe40 <prvUnlockQueue+0x32>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
     e26:	89 89       	ldd	r24, Y+17	; 0x11
     e28:	88 23       	and	r24, r24
     e2a:	69 f0       	breq	.+26     	; 0xe46 <prvUnlockQueue+0x38>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     e2c:	c8 01       	movw	r24, r16
     e2e:	0e 94 bf 09 	call	0x137e	; 0x137e <xTaskRemoveFromEventList>
     e32:	88 23       	and	r24, r24
     e34:	11 f0       	breq	.+4      	; 0xe3a <prvUnlockQueue+0x2c>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
     e36:	0e 94 bb 09 	call	0x1376	; 0x1376 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
     e3a:	8e 8d       	ldd	r24, Y+30	; 0x1e
     e3c:	81 50       	subi	r24, 0x01	; 1
     e3e:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     e40:	8e 8d       	ldd	r24, Y+30	; 0x1e
     e42:	18 16       	cp	r1, r24
     e44:	84 f3       	brlt	.-32     	; 0xe26 <prvUnlockQueue+0x18>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
     e46:	8f ef       	ldi	r24, 0xFF	; 255
     e48:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     e4a:	0f 90       	pop	r0
     e4c:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     e4e:	0f b6       	in	r0, 0x3f	; 63
     e50:	f8 94       	cli
     e52:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     e54:	8e 01       	movw	r16, r28
     e56:	08 5f       	subi	r16, 0xF8	; 248
     e58:	1f 4f       	sbci	r17, 0xFF	; 255
     e5a:	0d c0       	rjmp	.+26     	; 0xe76 <prvUnlockQueue+0x68>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
     e5c:	88 85       	ldd	r24, Y+8	; 0x08
     e5e:	88 23       	and	r24, r24
     e60:	69 f0       	breq	.+26     	; 0xe7c <prvUnlockQueue+0x6e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     e62:	c8 01       	movw	r24, r16
     e64:	0e 94 bf 09 	call	0x137e	; 0x137e <xTaskRemoveFromEventList>
     e68:	88 23       	and	r24, r24
     e6a:	11 f0       	breq	.+4      	; 0xe70 <prvUnlockQueue+0x62>
				{
					vTaskMissedYield();
     e6c:	0e 94 bb 09 	call	0x1376	; 0x1376 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
     e70:	8d 8d       	ldd	r24, Y+29	; 0x1d
     e72:	81 50       	subi	r24, 0x01	; 1
     e74:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     e76:	8d 8d       	ldd	r24, Y+29	; 0x1d
     e78:	18 16       	cp	r1, r24
     e7a:	84 f3       	brlt	.-32     	; 0xe5c <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
     e7c:	8f ef       	ldi	r24, 0xFF	; 255
     e7e:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     e80:	0f 90       	pop	r0
     e82:	0f be       	out	0x3f, r0	; 63
}
     e84:	df 91       	pop	r29
     e86:	cf 91       	pop	r28
     e88:	1f 91       	pop	r17
     e8a:	0f 91       	pop	r16
     e8c:	08 95       	ret

00000e8e <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
     e8e:	7f 92       	push	r7
     e90:	8f 92       	push	r8
     e92:	9f 92       	push	r9
     e94:	af 92       	push	r10
     e96:	bf 92       	push	r11
     e98:	cf 92       	push	r12
     e9a:	df 92       	push	r13
     e9c:	ef 92       	push	r14
     e9e:	ff 92       	push	r15
     ea0:	0f 93       	push	r16
     ea2:	1f 93       	push	r17
     ea4:	df 93       	push	r29
     ea6:	cf 93       	push	r28
     ea8:	00 d0       	rcall	.+0      	; 0xeaa <xQueueGenericReceive+0x1c>
     eaa:	00 d0       	rcall	.+0      	; 0xeac <xQueueGenericReceive+0x1e>
     eac:	0f 92       	push	r0
     eae:	cd b7       	in	r28, 0x3d	; 61
     eb0:	de b7       	in	r29, 0x3e	; 62
     eb2:	8c 01       	movw	r16, r24
     eb4:	96 2e       	mov	r9, r22
     eb6:	87 2e       	mov	r8, r23
     eb8:	5d 83       	std	Y+5, r21	; 0x05
     eba:	4c 83       	std	Y+4, r20	; 0x04
     ebc:	72 2e       	mov	r7, r18
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     ebe:	91 e1       	ldi	r25, 0x11	; 17
     ec0:	c9 2e       	mov	r12, r25
     ec2:	d1 2c       	mov	r13, r1
     ec4:	c0 0e       	add	r12, r16
     ec6:	d1 1e       	adc	r13, r17
     ec8:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     eca:	7e 01       	movw	r14, r28
     ecc:	08 94       	sec
     ece:	e1 1c       	adc	r14, r1
     ed0:	f1 1c       	adc	r15, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     ed2:	84 e0       	ldi	r24, 0x04	; 4
     ed4:	a8 2e       	mov	r10, r24
     ed6:	b1 2c       	mov	r11, r1
     ed8:	ac 0e       	add	r10, r28
     eda:	bd 1e       	adc	r11, r29
     edc:	01 c0       	rjmp	.+2      	; 0xee0 <xQueueGenericReceive+0x52>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     ede:	21 e0       	ldi	r18, 0x01	; 1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     ee0:	0f b6       	in	r0, 0x3f	; 63
     ee2:	f8 94       	cli
     ee4:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
     ee6:	f8 01       	movw	r30, r16
     ee8:	82 8d       	ldd	r24, Z+26	; 0x1a
     eea:	88 23       	and	r24, r24
     eec:	09 f4       	brne	.+2      	; 0xef0 <xQueueGenericReceive+0x62>
     eee:	3e c0       	rjmp	.+124    	; 0xf6c <xQueueGenericReceive+0xde>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
     ef0:	e6 80       	ldd	r14, Z+6	; 0x06
     ef2:	f7 80       	ldd	r15, Z+7	; 0x07
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
     ef4:	40 81       	ld	r20, Z
     ef6:	51 81       	ldd	r21, Z+1	; 0x01
     ef8:	41 15       	cp	r20, r1
     efa:	51 05       	cpc	r21, r1
     efc:	b1 f0       	breq	.+44     	; 0xf2a <xQueueGenericReceive+0x9c>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
     efe:	84 8d       	ldd	r24, Z+28	; 0x1c
     f00:	97 01       	movw	r18, r14
     f02:	28 0f       	add	r18, r24
     f04:	31 1d       	adc	r19, r1
     f06:	37 83       	std	Z+7, r19	; 0x07
     f08:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
     f0a:	82 81       	ldd	r24, Z+2	; 0x02
     f0c:	93 81       	ldd	r25, Z+3	; 0x03
     f0e:	28 17       	cp	r18, r24
     f10:	39 07       	cpc	r19, r25
     f12:	10 f0       	brcs	.+4      	; 0xf18 <xQueueGenericReceive+0x8a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
     f14:	57 83       	std	Z+7, r21	; 0x07
     f16:	46 83       	std	Z+6, r20	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
     f18:	f8 01       	movw	r30, r16
     f1a:	44 8d       	ldd	r20, Z+28	; 0x1c
     f1c:	66 81       	ldd	r22, Z+6	; 0x06
     f1e:	77 81       	ldd	r23, Z+7	; 0x07
     f20:	89 2d       	mov	r24, r9
     f22:	98 2d       	mov	r25, r8
     f24:	50 e0       	ldi	r21, 0x00	; 0
     f26:	0e 94 3f 25 	call	0x4a7e	; 0x4a7e <memcpy>
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
     f2a:	77 20       	and	r7, r7
     f2c:	71 f4       	brne	.+28     	; 0xf4a <xQueueGenericReceive+0xbc>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
     f2e:	f8 01       	movw	r30, r16
     f30:	82 8d       	ldd	r24, Z+26	; 0x1a
     f32:	81 50       	subi	r24, 0x01	; 1
     f34:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     f36:	80 85       	ldd	r24, Z+8	; 0x08
     f38:	88 23       	and	r24, r24
     f3a:	a1 f0       	breq	.+40     	; 0xf64 <xQueueGenericReceive+0xd6>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     f3c:	c8 01       	movw	r24, r16
     f3e:	08 96       	adiw	r24, 0x08	; 8
     f40:	0e 94 bf 09 	call	0x137e	; 0x137e <xTaskRemoveFromEventList>
     f44:	81 30       	cpi	r24, 0x01	; 1
     f46:	71 f4       	brne	.+28     	; 0xf64 <xQueueGenericReceive+0xd6>
     f48:	0b c0       	rjmp	.+22     	; 0xf60 <xQueueGenericReceive+0xd2>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
     f4a:	f8 01       	movw	r30, r16
     f4c:	f7 82       	std	Z+7, r15	; 0x07
     f4e:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
     f50:	81 89       	ldd	r24, Z+17	; 0x11
     f52:	88 23       	and	r24, r24
     f54:	39 f0       	breq	.+14     	; 0xf64 <xQueueGenericReceive+0xd6>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     f56:	c6 01       	movw	r24, r12
     f58:	0e 94 bf 09 	call	0x137e	; 0x137e <xTaskRemoveFromEventList>
     f5c:	88 23       	and	r24, r24
     f5e:	11 f0       	breq	.+4      	; 0xf64 <xQueueGenericReceive+0xd6>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
     f60:	0e 94 87 0e 	call	0x1d0e	; 0x1d0e <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
     f64:	0f 90       	pop	r0
     f66:	0f be       	out	0x3f, r0	; 63
     f68:	81 e0       	ldi	r24, 0x01	; 1
     f6a:	4a c0       	rjmp	.+148    	; 0x1000 <xQueueGenericReceive+0x172>
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
     f6c:	8c 81       	ldd	r24, Y+4	; 0x04
     f6e:	9d 81       	ldd	r25, Y+5	; 0x05
     f70:	89 2b       	or	r24, r25
     f72:	19 f4       	brne	.+6      	; 0xf7a <xQueueGenericReceive+0xec>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     f74:	0f 90       	pop	r0
     f76:	0f be       	out	0x3f, r0	; 63
     f78:	42 c0       	rjmp	.+132    	; 0xffe <xQueueGenericReceive+0x170>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
     f7a:	22 23       	and	r18, r18
     f7c:	19 f4       	brne	.+6      	; 0xf84 <xQueueGenericReceive+0xf6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     f7e:	c7 01       	movw	r24, r14
     f80:	0e 94 76 09 	call	0x12ec	; 0x12ec <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
     f84:	0f 90       	pop	r0
     f86:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     f88:	0e 94 1a 09 	call	0x1234	; 0x1234 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     f8c:	0f b6       	in	r0, 0x3f	; 63
     f8e:	f8 94       	cli
     f90:	0f 92       	push	r0
     f92:	f8 01       	movw	r30, r16
     f94:	85 8d       	ldd	r24, Z+29	; 0x1d
     f96:	8f 3f       	cpi	r24, 0xFF	; 255
     f98:	09 f4       	brne	.+2      	; 0xf9c <xQueueGenericReceive+0x10e>
     f9a:	15 8e       	std	Z+29, r1	; 0x1d
     f9c:	f8 01       	movw	r30, r16
     f9e:	86 8d       	ldd	r24, Z+30	; 0x1e
     fa0:	8f 3f       	cpi	r24, 0xFF	; 255
     fa2:	09 f4       	brne	.+2      	; 0xfa6 <xQueueGenericReceive+0x118>
     fa4:	16 8e       	std	Z+30, r1	; 0x1e
     fa6:	0f 90       	pop	r0
     fa8:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     faa:	c7 01       	movw	r24, r14
     fac:	b5 01       	movw	r22, r10
     fae:	0e 94 81 09 	call	0x1302	; 0x1302 <xTaskCheckForTimeOut>
     fb2:	88 23       	and	r24, r24
     fb4:	f9 f4       	brne	.+62     	; 0xff4 <xQueueGenericReceive+0x166>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
     fb6:	0f b6       	in	r0, 0x3f	; 63
     fb8:	f8 94       	cli
     fba:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
     fbc:	f8 01       	movw	r30, r16
     fbe:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     fc0:	0f 90       	pop	r0
     fc2:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
     fc4:	88 23       	and	r24, r24
     fc6:	81 f4       	brne	.+32     	; 0xfe8 <xQueueGenericReceive+0x15a>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     fc8:	6c 81       	ldd	r22, Y+4	; 0x04
     fca:	7d 81       	ldd	r23, Y+5	; 0x05
     fcc:	c6 01       	movw	r24, r12
     fce:	0e 94 78 0a 	call	0x14f0	; 0x14f0 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     fd2:	c8 01       	movw	r24, r16
     fd4:	0e 94 07 07 	call	0xe0e	; 0xe0e <prvUnlockQueue>
				if( !xTaskResumeAll() )
     fd8:	0e 94 b1 0a 	call	0x1562	; 0x1562 <xTaskResumeAll>
     fdc:	88 23       	and	r24, r24
     fde:	09 f0       	breq	.+2      	; 0xfe2 <xQueueGenericReceive+0x154>
     fe0:	7e cf       	rjmp	.-260    	; 0xede <xQueueGenericReceive+0x50>
				{
					portYIELD_WITHIN_API();
     fe2:	0e 94 87 0e 	call	0x1d0e	; 0x1d0e <vPortYield>
     fe6:	7b cf       	rjmp	.-266    	; 0xede <xQueueGenericReceive+0x50>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     fe8:	c8 01       	movw	r24, r16
     fea:	0e 94 07 07 	call	0xe0e	; 0xe0e <prvUnlockQueue>
				( void ) xTaskResumeAll();
     fee:	0e 94 b1 0a 	call	0x1562	; 0x1562 <xTaskResumeAll>
     ff2:	75 cf       	rjmp	.-278    	; 0xede <xQueueGenericReceive+0x50>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     ff4:	c8 01       	movw	r24, r16
     ff6:	0e 94 07 07 	call	0xe0e	; 0xe0e <prvUnlockQueue>
			( void ) xTaskResumeAll();
     ffa:	0e 94 b1 0a 	call	0x1562	; 0x1562 <xTaskResumeAll>
     ffe:	80 e0       	ldi	r24, 0x00	; 0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
    1000:	0f 90       	pop	r0
    1002:	0f 90       	pop	r0
    1004:	0f 90       	pop	r0
    1006:	0f 90       	pop	r0
    1008:	0f 90       	pop	r0
    100a:	cf 91       	pop	r28
    100c:	df 91       	pop	r29
    100e:	1f 91       	pop	r17
    1010:	0f 91       	pop	r16
    1012:	ff 90       	pop	r15
    1014:	ef 90       	pop	r14
    1016:	df 90       	pop	r13
    1018:	cf 90       	pop	r12
    101a:	bf 90       	pop	r11
    101c:	af 90       	pop	r10
    101e:	9f 90       	pop	r9
    1020:	8f 90       	pop	r8
    1022:	7f 90       	pop	r7
    1024:	08 95       	ret

00001026 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    1026:	7f 92       	push	r7
    1028:	8f 92       	push	r8
    102a:	9f 92       	push	r9
    102c:	af 92       	push	r10
    102e:	bf 92       	push	r11
    1030:	cf 92       	push	r12
    1032:	df 92       	push	r13
    1034:	ef 92       	push	r14
    1036:	ff 92       	push	r15
    1038:	0f 93       	push	r16
    103a:	1f 93       	push	r17
    103c:	df 93       	push	r29
    103e:	cf 93       	push	r28
    1040:	00 d0       	rcall	.+0      	; 0x1042 <xQueueGenericSend+0x1c>
    1042:	00 d0       	rcall	.+0      	; 0x1044 <xQueueGenericSend+0x1e>
    1044:	0f 92       	push	r0
    1046:	cd b7       	in	r28, 0x3d	; 61
    1048:	de b7       	in	r29, 0x3e	; 62
    104a:	8c 01       	movw	r16, r24
    104c:	6b 01       	movw	r12, r22
    104e:	5d 83       	std	Y+5, r21	; 0x05
    1050:	4c 83       	std	Y+4, r20	; 0x04
    1052:	72 2e       	mov	r7, r18
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1054:	48 e0       	ldi	r20, 0x08	; 8
    1056:	e4 2e       	mov	r14, r20
    1058:	f1 2c       	mov	r15, r1
    105a:	e8 0e       	add	r14, r24
    105c:	f9 1e       	adc	r15, r25
    105e:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1060:	5e 01       	movw	r10, r28
    1062:	08 94       	sec
    1064:	a1 1c       	adc	r10, r1
    1066:	b1 1c       	adc	r11, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1068:	34 e0       	ldi	r19, 0x04	; 4
    106a:	83 2e       	mov	r8, r19
    106c:	91 2c       	mov	r9, r1
    106e:	8c 0e       	add	r8, r28
    1070:	9d 1e       	adc	r9, r29
    1072:	01 c0       	rjmp	.+2      	; 0x1076 <xQueueGenericSend+0x50>
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1074:	21 e0       	ldi	r18, 0x01	; 1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1076:	0f b6       	in	r0, 0x3f	; 63
    1078:	f8 94       	cli
    107a:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    107c:	f8 01       	movw	r30, r16
    107e:	92 8d       	ldd	r25, Z+26	; 0x1a
    1080:	83 8d       	ldd	r24, Z+27	; 0x1b
    1082:	98 17       	cp	r25, r24
    1084:	a8 f4       	brcc	.+42     	; 0x10b0 <xQueueGenericSend+0x8a>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1086:	c8 01       	movw	r24, r16
    1088:	b6 01       	movw	r22, r12
    108a:	47 2d       	mov	r20, r7
    108c:	0e 94 9e 06 	call	0xd3c	; 0xd3c <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1090:	f8 01       	movw	r30, r16
    1092:	81 89       	ldd	r24, Z+17	; 0x11
    1094:	88 23       	and	r24, r24
    1096:	41 f0       	breq	.+16     	; 0x10a8 <xQueueGenericSend+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1098:	c8 01       	movw	r24, r16
    109a:	41 96       	adiw	r24, 0x11	; 17
    109c:	0e 94 bf 09 	call	0x137e	; 0x137e <xTaskRemoveFromEventList>
    10a0:	81 30       	cpi	r24, 0x01	; 1
    10a2:	11 f4       	brne	.+4      	; 0x10a8 <xQueueGenericSend+0x82>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    10a4:	0e 94 87 0e 	call	0x1d0e	; 0x1d0e <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    10a8:	0f 90       	pop	r0
    10aa:	0f be       	out	0x3f, r0	; 63
    10ac:	81 e0       	ldi	r24, 0x01	; 1
    10ae:	4c c0       	rjmp	.+152    	; 0x1148 <xQueueGenericSend+0x122>
				function. */
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    10b0:	8c 81       	ldd	r24, Y+4	; 0x04
    10b2:	9d 81       	ldd	r25, Y+5	; 0x05
    10b4:	89 2b       	or	r24, r25
    10b6:	19 f4       	brne	.+6      	; 0x10be <xQueueGenericSend+0x98>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    10b8:	0f 90       	pop	r0
    10ba:	0f be       	out	0x3f, r0	; 63
    10bc:	44 c0       	rjmp	.+136    	; 0x1146 <xQueueGenericSend+0x120>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    10be:	22 23       	and	r18, r18
    10c0:	19 f4       	brne	.+6      	; 0x10c8 <xQueueGenericSend+0xa2>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    10c2:	c5 01       	movw	r24, r10
    10c4:	0e 94 76 09 	call	0x12ec	; 0x12ec <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    10c8:	0f 90       	pop	r0
    10ca:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    10cc:	0e 94 1a 09 	call	0x1234	; 0x1234 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    10d0:	0f b6       	in	r0, 0x3f	; 63
    10d2:	f8 94       	cli
    10d4:	0f 92       	push	r0
    10d6:	f8 01       	movw	r30, r16
    10d8:	85 8d       	ldd	r24, Z+29	; 0x1d
    10da:	8f 3f       	cpi	r24, 0xFF	; 255
    10dc:	09 f4       	brne	.+2      	; 0x10e0 <xQueueGenericSend+0xba>
    10de:	15 8e       	std	Z+29, r1	; 0x1d
    10e0:	f8 01       	movw	r30, r16
    10e2:	86 8d       	ldd	r24, Z+30	; 0x1e
    10e4:	8f 3f       	cpi	r24, 0xFF	; 255
    10e6:	09 f4       	brne	.+2      	; 0x10ea <xQueueGenericSend+0xc4>
    10e8:	16 8e       	std	Z+30, r1	; 0x1e
    10ea:	0f 90       	pop	r0
    10ec:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    10ee:	c5 01       	movw	r24, r10
    10f0:	b4 01       	movw	r22, r8
    10f2:	0e 94 81 09 	call	0x1302	; 0x1302 <xTaskCheckForTimeOut>
    10f6:	88 23       	and	r24, r24
    10f8:	09 f5       	brne	.+66     	; 0x113c <xQueueGenericSend+0x116>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    10fa:	0f b6       	in	r0, 0x3f	; 63
    10fc:	f8 94       	cli
    10fe:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    1100:	f8 01       	movw	r30, r16
    1102:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    1104:	0f 90       	pop	r0
    1106:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
    1108:	f8 01       	movw	r30, r16
    110a:	83 8d       	ldd	r24, Z+27	; 0x1b
    110c:	98 17       	cp	r25, r24
    110e:	81 f4       	brne	.+32     	; 0x1130 <xQueueGenericSend+0x10a>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1110:	6c 81       	ldd	r22, Y+4	; 0x04
    1112:	7d 81       	ldd	r23, Y+5	; 0x05
    1114:	c7 01       	movw	r24, r14
    1116:	0e 94 78 0a 	call	0x14f0	; 0x14f0 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    111a:	c8 01       	movw	r24, r16
    111c:	0e 94 07 07 	call	0xe0e	; 0xe0e <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
    1120:	0e 94 b1 0a 	call	0x1562	; 0x1562 <xTaskResumeAll>
    1124:	88 23       	and	r24, r24
    1126:	09 f0       	breq	.+2      	; 0x112a <xQueueGenericSend+0x104>
    1128:	a5 cf       	rjmp	.-182    	; 0x1074 <xQueueGenericSend+0x4e>
				{
					portYIELD_WITHIN_API();
    112a:	0e 94 87 0e 	call	0x1d0e	; 0x1d0e <vPortYield>
    112e:	a2 cf       	rjmp	.-188    	; 0x1074 <xQueueGenericSend+0x4e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1130:	c8 01       	movw	r24, r16
    1132:	0e 94 07 07 	call	0xe0e	; 0xe0e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1136:	0e 94 b1 0a 	call	0x1562	; 0x1562 <xTaskResumeAll>
    113a:	9c cf       	rjmp	.-200    	; 0x1074 <xQueueGenericSend+0x4e>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    113c:	c8 01       	movw	r24, r16
    113e:	0e 94 07 07 	call	0xe0e	; 0xe0e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1142:	0e 94 b1 0a 	call	0x1562	; 0x1562 <xTaskResumeAll>
    1146:	80 e0       	ldi	r24, 0x00	; 0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
    1148:	0f 90       	pop	r0
    114a:	0f 90       	pop	r0
    114c:	0f 90       	pop	r0
    114e:	0f 90       	pop	r0
    1150:	0f 90       	pop	r0
    1152:	cf 91       	pop	r28
    1154:	df 91       	pop	r29
    1156:	1f 91       	pop	r17
    1158:	0f 91       	pop	r16
    115a:	ff 90       	pop	r15
    115c:	ef 90       	pop	r14
    115e:	df 90       	pop	r13
    1160:	cf 90       	pop	r12
    1162:	bf 90       	pop	r11
    1164:	af 90       	pop	r10
    1166:	9f 90       	pop	r9
    1168:	8f 90       	pop	r8
    116a:	7f 90       	pop	r7
    116c:	08 95       	ret

0000116e <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    116e:	8f 92       	push	r8
    1170:	9f 92       	push	r9
    1172:	af 92       	push	r10
    1174:	bf 92       	push	r11
    1176:	cf 92       	push	r12
    1178:	df 92       	push	r13
    117a:	ef 92       	push	r14
    117c:	ff 92       	push	r15
    117e:	0f 93       	push	r16
    1180:	1f 93       	push	r17
    1182:	cf 93       	push	r28
    1184:	df 93       	push	r29
    1186:	98 2e       	mov	r9, r24
    1188:	86 2e       	mov	r8, r22
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    118a:	88 23       	and	r24, r24
    118c:	09 f4       	brne	.+2      	; 0x1190 <xQueueCreate+0x22>
    118e:	42 c0       	rjmp	.+132    	; 0x1214 <xQueueCreate+0xa6>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    1190:	8f e1       	ldi	r24, 0x1F	; 31
    1192:	90 e0       	ldi	r25, 0x00	; 0
    1194:	0e 94 ba 10 	call	0x2174	; 0x2174 <pvPortMalloc>
    1198:	8c 01       	movw	r16, r24
    119a:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    119c:	00 97       	sbiw	r24, 0x00	; 0
    119e:	e1 f1       	breq	.+120    	; 0x1218 <xQueueCreate+0xaa>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    11a0:	c9 2c       	mov	r12, r9
    11a2:	dd 24       	eor	r13, r13
    11a4:	a8 2c       	mov	r10, r8
    11a6:	bb 24       	eor	r11, r11
    11a8:	ac 9c       	mul	r10, r12
    11aa:	70 01       	movw	r14, r0
    11ac:	ad 9c       	mul	r10, r13
    11ae:	f0 0c       	add	r15, r0
    11b0:	bc 9c       	mul	r11, r12
    11b2:	f0 0c       	add	r15, r0
    11b4:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    11b6:	c7 01       	movw	r24, r14
    11b8:	01 96       	adiw	r24, 0x01	; 1
    11ba:	0e 94 ba 10 	call	0x2174	; 0x2174 <pvPortMalloc>
    11be:	9c 01       	movw	r18, r24
    11c0:	99 83       	std	Y+1, r25	; 0x01
    11c2:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    11c4:	00 97       	sbiw	r24, 0x00	; 0
    11c6:	19 f1       	breq	.+70     	; 0x120e <xQueueCreate+0xa0>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    11c8:	e8 0e       	add	r14, r24
    11ca:	f9 1e       	adc	r15, r25
    11cc:	fb 82       	std	Y+3, r15	; 0x03
    11ce:	ea 82       	std	Y+2, r14	; 0x02
				pxNewQueue->uxMessagesWaiting = 0;
    11d0:	1a 8e       	std	Y+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    11d2:	9d 83       	std	Y+5, r25	; 0x05
    11d4:	8c 83       	std	Y+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
    11d6:	08 94       	sec
    11d8:	c1 08       	sbc	r12, r1
    11da:	d1 08       	sbc	r13, r1
    11dc:	ca 9c       	mul	r12, r10
    11de:	c0 01       	movw	r24, r0
    11e0:	cb 9c       	mul	r12, r11
    11e2:	90 0d       	add	r25, r0
    11e4:	da 9c       	mul	r13, r10
    11e6:	90 0d       	add	r25, r0
    11e8:	11 24       	eor	r1, r1
    11ea:	28 0f       	add	r18, r24
    11ec:	39 1f       	adc	r19, r25
    11ee:	3f 83       	std	Y+7, r19	; 0x07
    11f0:	2e 83       	std	Y+6, r18	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    11f2:	9b 8e       	std	Y+27, r9	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    11f4:	8c 8e       	std	Y+28, r8	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    11f6:	8f ef       	ldi	r24, 0xFF	; 255
    11f8:	8d 8f       	std	Y+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    11fa:	8e 8f       	std	Y+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    11fc:	c8 01       	movw	r24, r16
    11fe:	08 96       	adiw	r24, 0x08	; 8
    1200:	0e 94 9b 05 	call	0xb36	; 0xb36 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1204:	c8 01       	movw	r24, r16
    1206:	41 96       	adiw	r24, 0x11	; 17
    1208:	0e 94 9b 05 	call	0xb36	; 0xb36 <vListInitialise>
    120c:	05 c0       	rjmp	.+10     	; 0x1218 <xQueueCreate+0xaa>
				return  pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    120e:	c8 01       	movw	r24, r16
    1210:	0e 94 aa 10 	call	0x2154	; 0x2154 <vPortFree>
    1214:	c0 e0       	ldi	r28, 0x00	; 0
    1216:	d0 e0       	ldi	r29, 0x00	; 0
	}

	/* Will only reach here if we could not allocate enough memory or no memory
	was required. */
	return NULL;
}
    1218:	ce 01       	movw	r24, r28
    121a:	df 91       	pop	r29
    121c:	cf 91       	pop	r28
    121e:	1f 91       	pop	r17
    1220:	0f 91       	pop	r16
    1222:	ff 90       	pop	r15
    1224:	ef 90       	pop	r14
    1226:	df 90       	pop	r13
    1228:	cf 90       	pop	r12
    122a:	bf 90       	pop	r11
    122c:	af 90       	pop	r10
    122e:	9f 90       	pop	r9
    1230:	8f 90       	pop	r8
    1232:	08 95       	ret

00001234 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    1234:	80 91 9e 02 	lds	r24, 0x029E
    1238:	8f 5f       	subi	r24, 0xFF	; 255
    123a:	80 93 9e 02 	sts	0x029E, r24
}
    123e:	08 95       	ret

00001240 <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portENTER_CRITICAL();
    1240:	0f b6       	in	r0, 0x3f	; 63
    1242:	f8 94       	cli
    1244:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    1246:	20 91 9c 02 	lds	r18, 0x029C
    124a:	30 91 9d 02 	lds	r19, 0x029D
	}
	portEXIT_CRITICAL();
    124e:	0f 90       	pop	r0
    1250:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    1252:	c9 01       	movw	r24, r18
    1254:	08 95       	ret

00001256 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
	return xTickCount;
    1256:	20 91 9c 02 	lds	r18, 0x029C
    125a:	30 91 9d 02 	lds	r19, 0x029D
}
    125e:	c9 01       	movw	r24, r18
    1260:	08 95       	ret

00001262 <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    1262:	80 91 a1 02 	lds	r24, 0x02A1
}
    1266:	08 95       	ret

00001268 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    1268:	80 91 9e 02 	lds	r24, 0x029E
    126c:	88 23       	and	r24, r24
    126e:	51 f0       	breq	.+20     	; 0x1284 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    1270:	81 e0       	ldi	r24, 0x01	; 1
    1272:	80 93 9a 02 	sts	0x029A, r24
    1276:	08 95       	ret
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
	{
		--uxTopReadyPriority;
    1278:	80 91 9f 02 	lds	r24, 0x029F
    127c:	81 50       	subi	r24, 0x01	; 1
    127e:	80 93 9f 02 	sts	0x029F, r24
    1282:	01 c0       	rjmp	.+2      	; 0x1286 <vTaskSwitchContext+0x1e>

	taskFIRST_CHECK_FOR_STACK_OVERFLOW();
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1284:	99 e0       	ldi	r25, 0x09	; 9
    1286:	e0 91 9f 02 	lds	r30, 0x029F
    128a:	e9 9f       	mul	r30, r25
    128c:	f0 01       	movw	r30, r0
    128e:	11 24       	eor	r1, r1
    1290:	ea 55       	subi	r30, 0x5A	; 90
    1292:	fd 4f       	sbci	r31, 0xFD	; 253
    1294:	80 81       	ld	r24, Z
    1296:	88 23       	and	r24, r24
    1298:	79 f3       	breq	.-34     	; 0x1278 <vTaskSwitchContext+0x10>
		--uxTopReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    129a:	90 91 9f 02 	lds	r25, 0x029F
    129e:	89 e0       	ldi	r24, 0x09	; 9
    12a0:	98 9f       	mul	r25, r24
    12a2:	d0 01       	movw	r26, r0
    12a4:	11 24       	eor	r1, r1
    12a6:	aa 55       	subi	r26, 0x5A	; 90
    12a8:	bd 4f       	sbci	r27, 0xFD	; 253
    12aa:	11 96       	adiw	r26, 0x01	; 1
    12ac:	ed 91       	ld	r30, X+
    12ae:	fc 91       	ld	r31, X
    12b0:	12 97       	sbiw	r26, 0x02	; 2
    12b2:	02 80       	ldd	r0, Z+2	; 0x02
    12b4:	f3 81       	ldd	r31, Z+3	; 0x03
    12b6:	e0 2d       	mov	r30, r0
    12b8:	12 96       	adiw	r26, 0x02	; 2
    12ba:	fc 93       	st	X, r31
    12bc:	ee 93       	st	-X, r30
    12be:	11 97       	sbiw	r26, 0x01	; 1
    12c0:	cd 01       	movw	r24, r26
    12c2:	03 96       	adiw	r24, 0x03	; 3
    12c4:	e8 17       	cp	r30, r24
    12c6:	f9 07       	cpc	r31, r25
    12c8:	31 f4       	brne	.+12     	; 0x12d6 <vTaskSwitchContext+0x6e>
    12ca:	82 81       	ldd	r24, Z+2	; 0x02
    12cc:	93 81       	ldd	r25, Z+3	; 0x03
    12ce:	12 96       	adiw	r26, 0x02	; 2
    12d0:	9c 93       	st	X, r25
    12d2:	8e 93       	st	-X, r24
    12d4:	11 97       	sbiw	r26, 0x01	; 1
    12d6:	11 96       	adiw	r26, 0x01	; 1
    12d8:	ed 91       	ld	r30, X+
    12da:	fc 91       	ld	r31, X
    12dc:	12 97       	sbiw	r26, 0x02	; 2
    12de:	86 81       	ldd	r24, Z+6	; 0x06
    12e0:	97 81       	ldd	r25, Z+7	; 0x07
    12e2:	90 93 99 02 	sts	0x0299, r25
    12e6:	80 93 98 02 	sts	0x0298, r24
    12ea:	08 95       	ret

000012ec <vTaskSetTimeOutState>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    12ec:	fc 01       	movw	r30, r24
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    12ee:	80 91 9b 02 	lds	r24, 0x029B
    12f2:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    12f4:	80 91 9c 02 	lds	r24, 0x029C
    12f8:	90 91 9d 02 	lds	r25, 0x029D
    12fc:	92 83       	std	Z+2, r25	; 0x02
    12fe:	81 83       	std	Z+1, r24	; 0x01
}
    1300:	08 95       	ret

00001302 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    1302:	fc 01       	movw	r30, r24
    1304:	db 01       	movw	r26, r22
portBASE_TYPE xReturn;

	portENTER_CRITICAL();
    1306:	0f b6       	in	r0, 0x3f	; 63
    1308:	f8 94       	cli
    130a:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    130c:	90 91 9b 02 	lds	r25, 0x029B
    1310:	80 81       	ld	r24, Z
    1312:	98 17       	cp	r25, r24
    1314:	49 f0       	breq	.+18     	; 0x1328 <xTaskCheckForTimeOut+0x26>
    1316:	20 91 9c 02 	lds	r18, 0x029C
    131a:	30 91 9d 02 	lds	r19, 0x029D
    131e:	81 81       	ldd	r24, Z+1	; 0x01
    1320:	92 81       	ldd	r25, Z+2	; 0x02
    1322:	28 17       	cp	r18, r24
    1324:	39 07       	cpc	r19, r25
    1326:	18 f5       	brcc	.+70     	; 0x136e <xTaskCheckForTimeOut+0x6c>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    1328:	80 91 9c 02 	lds	r24, 0x029C
    132c:	90 91 9d 02 	lds	r25, 0x029D
    1330:	21 81       	ldd	r18, Z+1	; 0x01
    1332:	32 81       	ldd	r19, Z+2	; 0x02
    1334:	4d 91       	ld	r20, X+
    1336:	5c 91       	ld	r21, X
    1338:	11 97       	sbiw	r26, 0x01	; 1
    133a:	82 1b       	sub	r24, r18
    133c:	93 0b       	sbc	r25, r19
    133e:	84 17       	cp	r24, r20
    1340:	95 07       	cpc	r25, r21
    1342:	a8 f4       	brcc	.+42     	; 0x136e <xTaskCheckForTimeOut+0x6c>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    1344:	80 91 9c 02 	lds	r24, 0x029C
    1348:	90 91 9d 02 	lds	r25, 0x029D
    134c:	28 1b       	sub	r18, r24
    134e:	39 0b       	sbc	r19, r25
    1350:	24 0f       	add	r18, r20
    1352:	35 1f       	adc	r19, r21
    1354:	2d 93       	st	X+, r18
    1356:	3c 93       	st	X, r19
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1358:	80 91 9b 02 	lds	r24, 0x029B
    135c:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    135e:	80 91 9c 02 	lds	r24, 0x029C
    1362:	90 91 9d 02 	lds	r25, 0x029D
    1366:	92 83       	std	Z+2, r25	; 0x02
    1368:	81 83       	std	Z+1, r24	; 0x01
    136a:	80 e0       	ldi	r24, 0x00	; 0
    136c:	01 c0       	rjmp	.+2      	; 0x1370 <xTaskCheckForTimeOut+0x6e>
    136e:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			xReturn = pdTRUE;
		}
	}
	portEXIT_CRITICAL();
    1370:	0f 90       	pop	r0
    1372:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1374:	08 95       	ret

00001376 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    1376:	81 e0       	ldi	r24, 0x01	; 1
    1378:	80 93 9a 02 	sts	0x029A, r24
}
    137c:	08 95       	ret

0000137e <xTaskRemoveFromEventList>:
	#endif
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    137e:	0f 93       	push	r16
    1380:	1f 93       	push	r17
    1382:	cf 93       	push	r28
    1384:	df 93       	push	r29
    1386:	fc 01       	movw	r30, r24
	it to the ready list.

	If an event is for a queue that is locked then this function will never
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1388:	80 81       	ld	r24, Z
    138a:	88 23       	and	r24, r24
    138c:	19 f4       	brne	.+6      	; 0x1394 <xTaskRemoveFromEventList+0x16>
    138e:	c0 e0       	ldi	r28, 0x00	; 0
    1390:	d0 e0       	ldi	r29, 0x00	; 0
    1392:	05 c0       	rjmp	.+10     	; 0x139e <xTaskRemoveFromEventList+0x20>
    1394:	05 80       	ldd	r0, Z+5	; 0x05
    1396:	f6 81       	ldd	r31, Z+6	; 0x06
    1398:	e0 2d       	mov	r30, r0
    139a:	c6 81       	ldd	r28, Z+6	; 0x06
    139c:	d7 81       	ldd	r29, Z+7	; 0x07
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    139e:	8e 01       	movw	r16, r28
    13a0:	04 5f       	subi	r16, 0xF4	; 244
    13a2:	1f 4f       	sbci	r17, 0xFF	; 255
    13a4:	c8 01       	movw	r24, r16
    13a6:	0e 94 0d 06 	call	0xc1a	; 0xc1a <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    13aa:	80 91 9e 02 	lds	r24, 0x029E
    13ae:	88 23       	and	r24, r24
    13b0:	a1 f4       	brne	.+40     	; 0x13da <xTaskRemoveFromEventList+0x5c>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    13b2:	8e 01       	movw	r16, r28
    13b4:	0e 5f       	subi	r16, 0xFE	; 254
    13b6:	1f 4f       	sbci	r17, 0xFF	; 255
    13b8:	c8 01       	movw	r24, r16
    13ba:	0e 94 0d 06 	call	0xc1a	; 0xc1a <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    13be:	9e 89       	ldd	r25, Y+22	; 0x16
    13c0:	80 91 9f 02 	lds	r24, 0x029F
    13c4:	89 17       	cp	r24, r25
    13c6:	10 f4       	brcc	.+4      	; 0x13cc <xTaskRemoveFromEventList+0x4e>
    13c8:	90 93 9f 02 	sts	0x029F, r25
    13cc:	89 e0       	ldi	r24, 0x09	; 9
    13ce:	98 9f       	mul	r25, r24
    13d0:	c0 01       	movw	r24, r0
    13d2:	11 24       	eor	r1, r1
    13d4:	8a 55       	subi	r24, 0x5A	; 90
    13d6:	9d 4f       	sbci	r25, 0xFD	; 253
    13d8:	02 c0       	rjmp	.+4      	; 0x13de <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    13da:	80 ee       	ldi	r24, 0xE0	; 224
    13dc:	92 e0       	ldi	r25, 0x02	; 2
    13de:	b8 01       	movw	r22, r16
    13e0:	0e 94 af 05 	call	0xb5e	; 0xb5e <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    13e4:	e0 91 98 02 	lds	r30, 0x0298
    13e8:	f0 91 99 02 	lds	r31, 0x0299
    13ec:	20 e0       	ldi	r18, 0x00	; 0
    13ee:	9e 89       	ldd	r25, Y+22	; 0x16
    13f0:	86 89       	ldd	r24, Z+22	; 0x16
    13f2:	98 17       	cp	r25, r24
    13f4:	08 f0       	brcs	.+2      	; 0x13f8 <xTaskRemoveFromEventList+0x7a>
    13f6:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    13f8:	82 2f       	mov	r24, r18
    13fa:	df 91       	pop	r29
    13fc:	cf 91       	pop	r28
    13fe:	1f 91       	pop	r17
    1400:	0f 91       	pop	r16
    1402:	08 95       	ret

00001404 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
    1404:	ff 92       	push	r15
    1406:	0f 93       	push	r16
    1408:	1f 93       	push	r17
    140a:	cf 93       	push	r28
    140c:	df 93       	push	r29
	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    140e:	80 91 9e 02 	lds	r24, 0x029E
    1412:	88 23       	and	r24, r24
    1414:	09 f0       	breq	.+2      	; 0x1418 <vTaskIncrementTick+0x14>
    1416:	61 c0       	rjmp	.+194    	; 0x14da <vTaskIncrementTick+0xd6>
	{
		++xTickCount;
    1418:	80 91 9c 02 	lds	r24, 0x029C
    141c:	90 91 9d 02 	lds	r25, 0x029D
    1420:	01 96       	adiw	r24, 0x01	; 1
    1422:	90 93 9d 02 	sts	0x029D, r25
    1426:	80 93 9c 02 	sts	0x029C, r24
		if( xTickCount == ( portTickType ) 0 )
    142a:	80 91 9c 02 	lds	r24, 0x029C
    142e:	90 91 9d 02 	lds	r25, 0x029D
    1432:	89 2b       	or	r24, r25
    1434:	e9 f5       	brne	.+122    	; 0x14b0 <vTaskIncrementTick+0xac>
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			pxTemp = pxDelayedTaskList;
    1436:	80 91 dc 02 	lds	r24, 0x02DC
    143a:	90 91 dd 02 	lds	r25, 0x02DD
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    143e:	20 91 de 02 	lds	r18, 0x02DE
    1442:	30 91 df 02 	lds	r19, 0x02DF
    1446:	30 93 dd 02 	sts	0x02DD, r19
    144a:	20 93 dc 02 	sts	0x02DC, r18
			pxOverflowDelayedTaskList = pxTemp;
    144e:	90 93 df 02 	sts	0x02DF, r25
    1452:	80 93 de 02 	sts	0x02DE, r24
			xNumOfOverflows++;
    1456:	80 91 9b 02 	lds	r24, 0x029B
    145a:	8f 5f       	subi	r24, 0xFF	; 255
    145c:	80 93 9b 02 	sts	0x029B, r24
    1460:	27 c0       	rjmp	.+78     	; 0x14b0 <vTaskIncrementTick+0xac>
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    1462:	20 91 9c 02 	lds	r18, 0x029C
    1466:	30 91 9d 02 	lds	r19, 0x029D
    146a:	8a 81       	ldd	r24, Y+2	; 0x02
    146c:	9b 81       	ldd	r25, Y+3	; 0x03
    146e:	28 17       	cp	r18, r24
    1470:	39 07       	cpc	r19, r25
    1472:	c0 f1       	brcs	.+112    	; 0x14e4 <vTaskIncrementTick+0xe0>
    1474:	8e 01       	movw	r16, r28
    1476:	0e 5f       	subi	r16, 0xFE	; 254
    1478:	1f 4f       	sbci	r17, 0xFF	; 255
    147a:	c8 01       	movw	r24, r16
    147c:	0e 94 0d 06 	call	0xc1a	; 0xc1a <vListRemove>
    1480:	8c 89       	ldd	r24, Y+20	; 0x14
    1482:	9d 89       	ldd	r25, Y+21	; 0x15
    1484:	89 2b       	or	r24, r25
    1486:	21 f0       	breq	.+8      	; 0x1490 <vTaskIncrementTick+0x8c>
    1488:	ce 01       	movw	r24, r28
    148a:	0c 96       	adiw	r24, 0x0c	; 12
    148c:	0e 94 0d 06 	call	0xc1a	; 0xc1a <vListRemove>
    1490:	9e 89       	ldd	r25, Y+22	; 0x16
    1492:	80 91 9f 02 	lds	r24, 0x029F
    1496:	89 17       	cp	r24, r25
    1498:	10 f4       	brcc	.+4      	; 0x149e <vTaskIncrementTick+0x9a>
    149a:	90 93 9f 02 	sts	0x029F, r25
    149e:	9f 9d       	mul	r25, r15
    14a0:	c0 01       	movw	r24, r0
    14a2:	11 24       	eor	r1, r1
    14a4:	8a 55       	subi	r24, 0x5A	; 90
    14a6:	9d 4f       	sbci	r25, 0xFD	; 253
    14a8:	b8 01       	movw	r22, r16
    14aa:	0e 94 af 05 	call	0xb5e	; 0xb5e <vListInsertEnd>
    14ae:	02 c0       	rjmp	.+4      	; 0x14b4 <vTaskIncrementTick+0xb0>
    14b0:	89 e0       	ldi	r24, 0x09	; 9
    14b2:	f8 2e       	mov	r15, r24
    14b4:	e0 91 dc 02 	lds	r30, 0x02DC
    14b8:	f0 91 dd 02 	lds	r31, 0x02DD
    14bc:	80 81       	ld	r24, Z
    14be:	88 23       	and	r24, r24
    14c0:	89 f0       	breq	.+34     	; 0x14e4 <vTaskIncrementTick+0xe0>
    14c2:	e0 91 dc 02 	lds	r30, 0x02DC
    14c6:	f0 91 dd 02 	lds	r31, 0x02DD
    14ca:	05 80       	ldd	r0, Z+5	; 0x05
    14cc:	f6 81       	ldd	r31, Z+6	; 0x06
    14ce:	e0 2d       	mov	r30, r0
    14d0:	c6 81       	ldd	r28, Z+6	; 0x06
    14d2:	d7 81       	ldd	r29, Z+7	; 0x07
    14d4:	20 97       	sbiw	r28, 0x00	; 0
    14d6:	29 f6       	brne	.-118    	; 0x1462 <vTaskIncrementTick+0x5e>
    14d8:	05 c0       	rjmp	.+10     	; 0x14e4 <vTaskIncrementTick+0xe0>
	}
	else
	{
		++uxMissedTicks;
    14da:	80 91 a0 02 	lds	r24, 0x02A0
    14de:	8f 5f       	subi	r24, 0xFF	; 255
    14e0:	80 93 a0 02 	sts	0x02A0, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    14e4:	df 91       	pop	r29
    14e6:	cf 91       	pop	r28
    14e8:	1f 91       	pop	r17
    14ea:	0f 91       	pop	r16
    14ec:	ff 90       	pop	r15
    14ee:	08 95       	ret

000014f0 <vTaskPlaceOnEventList>:
	vWriteTraceToBuffer();
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    14f0:	0f 93       	push	r16
    14f2:	1f 93       	push	r17
    14f4:	8b 01       	movw	r16, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    14f6:	60 91 98 02 	lds	r22, 0x0298
    14fa:	70 91 99 02 	lds	r23, 0x0299
    14fe:	64 5f       	subi	r22, 0xF4	; 244
    1500:	7f 4f       	sbci	r23, 0xFF	; 255
    1502:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1506:	80 91 98 02 	lds	r24, 0x0298
    150a:	90 91 99 02 	lds	r25, 0x0299
    150e:	02 96       	adiw	r24, 0x02	; 2
    1510:	0e 94 0d 06 	call	0xc1a	; 0xc1a <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    1514:	80 91 9c 02 	lds	r24, 0x029C
    1518:	90 91 9d 02 	lds	r25, 0x029D
    151c:	80 0f       	add	r24, r16
    151e:	91 1f       	adc	r25, r17

			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    1520:	e0 91 98 02 	lds	r30, 0x0298
    1524:	f0 91 99 02 	lds	r31, 0x0299
    1528:	93 83       	std	Z+3, r25	; 0x03
    152a:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xTickCount )
    152c:	20 91 9c 02 	lds	r18, 0x029C
    1530:	30 91 9d 02 	lds	r19, 0x029D
    1534:	82 17       	cp	r24, r18
    1536:	93 07       	cpc	r25, r19
    1538:	28 f4       	brcc	.+10     	; 0x1544 <vTaskPlaceOnEventList+0x54>
			{
				/* Wake time has overflowed.  Place this item in the overflow list. */
				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    153a:	80 91 de 02 	lds	r24, 0x02DE
    153e:	90 91 df 02 	lds	r25, 0x02DF
    1542:	04 c0       	rjmp	.+8      	; 0x154c <vTaskPlaceOnEventList+0x5c>
			}
			else
			{
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1544:	80 91 dc 02 	lds	r24, 0x02DC
    1548:	90 91 dd 02 	lds	r25, 0x02DD
    154c:	60 91 98 02 	lds	r22, 0x0298
    1550:	70 91 99 02 	lds	r23, 0x0299
    1554:	6e 5f       	subi	r22, 0xFE	; 254
    1556:	7f 4f       	sbci	r23, 0xFF	; 255
    1558:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <vListInsert>
			}
	}
	#endif
}
    155c:	1f 91       	pop	r17
    155e:	0f 91       	pop	r16
    1560:	08 95       	ret

00001562 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    1562:	cf 92       	push	r12
    1564:	df 92       	push	r13
    1566:	ff 92       	push	r15
    1568:	0f 93       	push	r16
    156a:	1f 93       	push	r17
    156c:	df 93       	push	r29
    156e:	cf 93       	push	r28
    1570:	0f 92       	push	r0
    1572:	cd b7       	in	r28, 0x3d	; 61
    1574:	de b7       	in	r29, 0x3e	; 62
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	portENTER_CRITICAL();
    1576:	0f b6       	in	r0, 0x3f	; 63
    1578:	f8 94       	cli
    157a:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    157c:	80 91 9e 02 	lds	r24, 0x029E
    1580:	81 50       	subi	r24, 0x01	; 1
    1582:	80 93 9e 02 	sts	0x029E, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1586:	80 91 9e 02 	lds	r24, 0x029E
    158a:	88 23       	and	r24, r24
    158c:	09 f0       	breq	.+2      	; 0x1590 <xTaskResumeAll+0x2e>
    158e:	5b c0       	rjmp	.+182    	; 0x1646 <xTaskResumeAll+0xe4>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
    1590:	80 91 a1 02 	lds	r24, 0x02A1
    1594:	88 23       	and	r24, r24
    1596:	09 f4       	brne	.+2      	; 0x159a <xTaskResumeAll+0x38>
    1598:	56 c0       	rjmp	.+172    	; 0x1646 <xTaskResumeAll+0xe4>
    159a:	19 82       	std	Y+1, r1	; 0x01
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    159c:	99 e0       	ldi	r25, 0x09	; 9
    159e:	f9 2e       	mov	r15, r25
    15a0:	27 c0       	rjmp	.+78     	; 0x15f0 <xTaskResumeAll+0x8e>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
    15a2:	c6 01       	movw	r24, r12
    15a4:	0c 96       	adiw	r24, 0x0c	; 12
    15a6:	0e 94 0d 06 	call	0xc1a	; 0xc1a <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    15aa:	86 01       	movw	r16, r12
    15ac:	0e 5f       	subi	r16, 0xFE	; 254
    15ae:	1f 4f       	sbci	r17, 0xFF	; 255
    15b0:	c8 01       	movw	r24, r16
    15b2:	0e 94 0d 06 	call	0xc1a	; 0xc1a <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    15b6:	d6 01       	movw	r26, r12
    15b8:	56 96       	adiw	r26, 0x16	; 22
    15ba:	9c 91       	ld	r25, X
    15bc:	80 91 9f 02 	lds	r24, 0x029F
    15c0:	89 17       	cp	r24, r25
    15c2:	10 f4       	brcc	.+4      	; 0x15c8 <xTaskResumeAll+0x66>
    15c4:	90 93 9f 02 	sts	0x029F, r25
    15c8:	9f 9d       	mul	r25, r15
    15ca:	c0 01       	movw	r24, r0
    15cc:	11 24       	eor	r1, r1
    15ce:	8a 55       	subi	r24, 0x5A	; 90
    15d0:	9d 4f       	sbci	r25, 0xFD	; 253
    15d2:	b8 01       	movw	r22, r16
    15d4:	0e 94 af 05 	call	0xb5e	; 0xb5e <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    15d8:	e0 91 98 02 	lds	r30, 0x0298
    15dc:	f0 91 99 02 	lds	r31, 0x0299
    15e0:	d6 01       	movw	r26, r12
    15e2:	56 96       	adiw	r26, 0x16	; 22
    15e4:	9c 91       	ld	r25, X
    15e6:	86 89       	ldd	r24, Z+22	; 0x16
    15e8:	98 17       	cp	r25, r24
    15ea:	10 f0       	brcs	.+4      	; 0x15f0 <xTaskResumeAll+0x8e>
    15ec:	b1 e0       	ldi	r27, 0x01	; 1
    15ee:	b9 83       	std	Y+1, r27	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
    15f0:	80 91 e0 02 	lds	r24, 0x02E0
    15f4:	88 23       	and	r24, r24
    15f6:	49 f0       	breq	.+18     	; 0x160a <xTaskResumeAll+0xa8>
    15f8:	e0 91 e5 02 	lds	r30, 0x02E5
    15fc:	f0 91 e6 02 	lds	r31, 0x02E6
    1600:	c6 80       	ldd	r12, Z+6	; 0x06
    1602:	d7 80       	ldd	r13, Z+7	; 0x07
    1604:	c1 14       	cp	r12, r1
    1606:	d1 04       	cpc	r13, r1
    1608:	61 f6       	brne	.-104    	; 0x15a2 <xTaskResumeAll+0x40>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    160a:	80 91 a0 02 	lds	r24, 0x02A0
    160e:	88 23       	and	r24, r24
    1610:	41 f4       	brne	.+16     	; 0x1622 <xTaskResumeAll+0xc0>
    1612:	0c c0       	rjmp	.+24     	; 0x162c <xTaskResumeAll+0xca>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
    1614:	0e 94 02 0a 	call	0x1404	; 0x1404 <vTaskIncrementTick>
						--uxMissedTicks;
    1618:	80 91 a0 02 	lds	r24, 0x02A0
    161c:	81 50       	subi	r24, 0x01	; 1
    161e:	80 93 a0 02 	sts	0x02A0, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    1622:	80 91 a0 02 	lds	r24, 0x02A0
    1626:	88 23       	and	r24, r24
    1628:	a9 f7       	brne	.-22     	; 0x1614 <xTaskResumeAll+0xb2>
    162a:	07 c0       	rjmp	.+14     	; 0x163a <xTaskResumeAll+0xd8>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    162c:	e9 81       	ldd	r30, Y+1	; 0x01
    162e:	e1 30       	cpi	r30, 0x01	; 1
    1630:	21 f0       	breq	.+8      	; 0x163a <xTaskResumeAll+0xd8>
    1632:	80 91 9a 02 	lds	r24, 0x029A
    1636:	81 30       	cpi	r24, 0x01	; 1
    1638:	31 f4       	brne	.+12     	; 0x1646 <xTaskResumeAll+0xe4>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    163a:	10 92 9a 02 	sts	0x029A, r1
					portYIELD_WITHIN_API();
    163e:	0e 94 87 0e 	call	0x1d0e	; 0x1d0e <vPortYield>
    1642:	81 e0       	ldi	r24, 0x01	; 1
    1644:	01 c0       	rjmp	.+2      	; 0x1648 <xTaskResumeAll+0xe6>
    1646:	80 e0       	ldi	r24, 0x00	; 0
				}
			}
		}
	}
	portEXIT_CRITICAL();
    1648:	0f 90       	pop	r0
    164a:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    164c:	0f 90       	pop	r0
    164e:	cf 91       	pop	r28
    1650:	df 91       	pop	r29
    1652:	1f 91       	pop	r17
    1654:	0f 91       	pop	r16
    1656:	ff 90       	pop	r15
    1658:	df 90       	pop	r13
    165a:	cf 90       	pop	r12
    165c:	08 95       	ret

0000165e <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    165e:	0f 93       	push	r16
    1660:	1f 93       	push	r17
    1662:	9c 01       	movw	r18, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
    1664:	00 97       	sbiw	r24, 0x00	; 0
    1666:	a1 f1       	breq	.+104    	; 0x16d0 <vTaskDelay+0x72>

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    1668:	80 91 9e 02 	lds	r24, 0x029E
    166c:	8f 5f       	subi	r24, 0xFF	; 255
    166e:	80 93 9e 02 	sts	0x029E, r24
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1672:	00 91 9c 02 	lds	r16, 0x029C
    1676:	10 91 9d 02 	lds	r17, 0x029D
    167a:	02 0f       	add	r16, r18
    167c:	13 1f       	adc	r17, r19

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    167e:	80 91 98 02 	lds	r24, 0x0298
    1682:	90 91 99 02 	lds	r25, 0x0299
    1686:	02 96       	adiw	r24, 0x02	; 2
    1688:	0e 94 0d 06 	call	0xc1a	; 0xc1a <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    168c:	e0 91 98 02 	lds	r30, 0x0298
    1690:	f0 91 99 02 	lds	r31, 0x0299
    1694:	13 83       	std	Z+3, r17	; 0x03
    1696:	02 83       	std	Z+2, r16	; 0x02

				if( xTimeToWake < xTickCount )
    1698:	80 91 9c 02 	lds	r24, 0x029C
    169c:	90 91 9d 02 	lds	r25, 0x029D
    16a0:	08 17       	cp	r16, r24
    16a2:	19 07       	cpc	r17, r25
    16a4:	28 f4       	brcc	.+10     	; 0x16b0 <vTaskDelay+0x52>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    16a6:	80 91 de 02 	lds	r24, 0x02DE
    16aa:	90 91 df 02 	lds	r25, 0x02DF
    16ae:	04 c0       	rjmp	.+8      	; 0x16b8 <vTaskDelay+0x5a>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    16b0:	80 91 dc 02 	lds	r24, 0x02DC
    16b4:	90 91 dd 02 	lds	r25, 0x02DD
    16b8:	60 91 98 02 	lds	r22, 0x0298
    16bc:	70 91 99 02 	lds	r23, 0x0299
    16c0:	6e 5f       	subi	r22, 0xFE	; 254
    16c2:	7f 4f       	sbci	r23, 0xFF	; 255
    16c4:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <vListInsert>
				}
			}
			xAlreadyYielded = xTaskResumeAll();
    16c8:	0e 94 b1 0a 	call	0x1562	; 0x1562 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
    16cc:	88 23       	and	r24, r24
    16ce:	11 f4       	brne	.+4      	; 0x16d4 <vTaskDelay+0x76>
		{
			portYIELD_WITHIN_API();
    16d0:	0e 94 87 0e 	call	0x1d0e	; 0x1d0e <vPortYield>
		}
	}
    16d4:	1f 91       	pop	r17
    16d6:	0f 91       	pop	r16
    16d8:	08 95       	ret

000016da <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    16da:	cf 93       	push	r28
    16dc:	df 93       	push	r29
    16de:	fc 01       	movw	r30, r24
    16e0:	eb 01       	movw	r28, r22

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    16e2:	80 91 9e 02 	lds	r24, 0x029E
    16e6:	8f 5f       	subi	r24, 0xFF	; 255
    16e8:	80 93 9e 02 	sts	0x029E, r24
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		vTaskSuspendAll();
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    16ec:	20 81       	ld	r18, Z
    16ee:	31 81       	ldd	r19, Z+1	; 0x01
    16f0:	c2 0f       	add	r28, r18
    16f2:	d3 1f       	adc	r29, r19

			if( xTickCount < *pxPreviousWakeTime )
    16f4:	80 91 9c 02 	lds	r24, 0x029C
    16f8:	90 91 9d 02 	lds	r25, 0x029D
    16fc:	82 17       	cp	r24, r18
    16fe:	93 07       	cpc	r25, r19
    1700:	28 f4       	brcc	.+10     	; 0x170c <vTaskDelayUntil+0x32>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    1702:	c2 17       	cp	r28, r18
    1704:	d3 07       	cpc	r29, r19
    1706:	28 f0       	brcs	.+10     	; 0x1712 <vTaskDelayUntil+0x38>
    1708:	20 e0       	ldi	r18, 0x00	; 0
    170a:	0c c0       	rjmp	.+24     	; 0x1724 <vTaskDelayUntil+0x4a>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    170c:	c2 17       	cp	r28, r18
    170e:	d3 07       	cpc	r29, r19
    1710:	40 f0       	brcs	.+16     	; 0x1722 <vTaskDelayUntil+0x48>
    1712:	80 91 9c 02 	lds	r24, 0x029C
    1716:	90 91 9d 02 	lds	r25, 0x029D
    171a:	20 e0       	ldi	r18, 0x00	; 0
    171c:	8c 17       	cp	r24, r28
    171e:	9d 07       	cpc	r25, r29
    1720:	08 f4       	brcc	.+2      	; 0x1724 <vTaskDelayUntil+0x4a>
    1722:	21 e0       	ldi	r18, 0x01	; 1
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1724:	d1 83       	std	Z+1, r29	; 0x01
    1726:	c0 83       	st	Z, r28

			if( xShouldDelay )
    1728:	22 23       	and	r18, r18
    172a:	29 f1       	breq	.+74     	; 0x1776 <vTaskDelayUntil+0x9c>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    172c:	80 91 98 02 	lds	r24, 0x0298
    1730:	90 91 99 02 	lds	r25, 0x0299
    1734:	02 96       	adiw	r24, 0x02	; 2
    1736:	0e 94 0d 06 	call	0xc1a	; 0xc1a <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    173a:	e0 91 98 02 	lds	r30, 0x0298
    173e:	f0 91 99 02 	lds	r31, 0x0299
    1742:	d3 83       	std	Z+3, r29	; 0x03
    1744:	c2 83       	std	Z+2, r28	; 0x02

				if( xTimeToWake < xTickCount )
    1746:	80 91 9c 02 	lds	r24, 0x029C
    174a:	90 91 9d 02 	lds	r25, 0x029D
    174e:	c8 17       	cp	r28, r24
    1750:	d9 07       	cpc	r29, r25
    1752:	28 f4       	brcc	.+10     	; 0x175e <vTaskDelayUntil+0x84>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1754:	80 91 de 02 	lds	r24, 0x02DE
    1758:	90 91 df 02 	lds	r25, 0x02DF
    175c:	04 c0       	rjmp	.+8      	; 0x1766 <vTaskDelayUntil+0x8c>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    175e:	80 91 dc 02 	lds	r24, 0x02DC
    1762:	90 91 dd 02 	lds	r25, 0x02DD
    1766:	60 91 98 02 	lds	r22, 0x0298
    176a:	70 91 99 02 	lds	r23, 0x0299
    176e:	6e 5f       	subi	r22, 0xFE	; 254
    1770:	7f 4f       	sbci	r23, 0xFF	; 255
    1772:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <vListInsert>
				}
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1776:	0e 94 b1 0a 	call	0x1562	; 0x1562 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
    177a:	88 23       	and	r24, r24
    177c:	11 f4       	brne	.+4      	; 0x1782 <vTaskDelayUntil+0xa8>
		{
			portYIELD_WITHIN_API();
    177e:	0e 94 87 0e 	call	0x1d0e	; 0x1d0e <vPortYield>
		}
	}
    1782:	df 91       	pop	r29
    1784:	cf 91       	pop	r28
    1786:	08 95       	ret

00001788 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    1788:	ef 92       	push	r14
    178a:	ff 92       	push	r15
    178c:	0f 93       	push	r16
    178e:	1f 93       	push	r17
    1790:	cf 93       	push	r28
    1792:	df 93       	push	r29
    1794:	8c 01       	movw	r16, r24
	tskTCB *pxTCB;

		portENTER_CRITICAL();
    1796:	0f b6       	in	r0, 0x3f	; 63
    1798:	f8 94       	cli
    179a:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    179c:	80 91 98 02 	lds	r24, 0x0298
    17a0:	90 91 99 02 	lds	r25, 0x0299
    17a4:	08 17       	cp	r16, r24
    17a6:	19 07       	cpc	r17, r25
    17a8:	19 f4       	brne	.+6      	; 0x17b0 <vTaskDelete+0x28>
    17aa:	00 e0       	ldi	r16, 0x00	; 0
    17ac:	10 e0       	ldi	r17, 0x00	; 0
    17ae:	03 c0       	rjmp	.+6      	; 0x17b6 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    17b0:	01 15       	cp	r16, r1
    17b2:	11 05       	cpc	r17, r1
    17b4:	29 f4       	brne	.+10     	; 0x17c0 <vTaskDelete+0x38>
    17b6:	c0 91 98 02 	lds	r28, 0x0298
    17ba:	d0 91 99 02 	lds	r29, 0x0299
    17be:	01 c0       	rjmp	.+2      	; 0x17c2 <vTaskDelete+0x3a>
    17c0:	e8 01       	movw	r28, r16

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    17c2:	22 e0       	ldi	r18, 0x02	; 2
    17c4:	e2 2e       	mov	r14, r18
    17c6:	f1 2c       	mov	r15, r1
    17c8:	ec 0e       	add	r14, r28
    17ca:	fd 1e       	adc	r15, r29
    17cc:	c7 01       	movw	r24, r14
    17ce:	0e 94 0d 06 	call	0xc1a	; 0xc1a <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer )
    17d2:	8c 89       	ldd	r24, Y+20	; 0x14
    17d4:	9d 89       	ldd	r25, Y+21	; 0x15
    17d6:	89 2b       	or	r24, r25
    17d8:	21 f0       	breq	.+8      	; 0x17e2 <vTaskDelete+0x5a>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    17da:	ce 01       	movw	r24, r28
    17dc:	0c 96       	adiw	r24, 0x0c	; 12
    17de:	0e 94 0d 06 	call	0xc1a	; 0xc1a <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    17e2:	89 ee       	ldi	r24, 0xE9	; 233
    17e4:	92 e0       	ldi	r25, 0x02	; 2
    17e6:	b7 01       	movw	r22, r14
    17e8:	0e 94 af 05 	call	0xb5e	; 0xb5e <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    17ec:	80 91 a3 02 	lds	r24, 0x02A3
    17f0:	8f 5f       	subi	r24, 0xFF	; 255
    17f2:	80 93 a3 02 	sts	0x02A3, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    17f6:	80 91 a4 02 	lds	r24, 0x02A4
    17fa:	8f 5f       	subi	r24, 0xFF	; 255
    17fc:	80 93 a4 02 	sts	0x02A4, r24

			traceTASK_DELETE( pxTCB );
		}
		portEXIT_CRITICAL();
    1800:	0f 90       	pop	r0
    1802:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    1804:	80 91 a2 02 	lds	r24, 0x02A2
    1808:	88 23       	and	r24, r24
    180a:	21 f0       	breq	.+8      	; 0x1814 <vTaskDelete+0x8c>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    180c:	01 2b       	or	r16, r17
    180e:	11 f4       	brne	.+4      	; 0x1814 <vTaskDelete+0x8c>
			{
				portYIELD_WITHIN_API();
    1810:	0e 94 87 0e 	call	0x1d0e	; 0x1d0e <vPortYield>
			}
		}
	}
    1814:	df 91       	pop	r29
    1816:	cf 91       	pop	r28
    1818:	1f 91       	pop	r17
    181a:	0f 91       	pop	r16
    181c:	ff 90       	pop	r15
    181e:	ef 90       	pop	r14
    1820:	08 95       	ret

00001822 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    1822:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    1824:	10 92 a2 02 	sts	0x02A2, r1
	vPortEndScheduler();
    1828:	0e 94 28 0e 	call	0x1c50	; 0x1c50 <vPortEndScheduler>
}
    182c:	08 95       	ret

0000182e <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    182e:	1f 93       	push	r17
    1830:	cf 93       	push	r28
    1832:	df 93       	push	r29
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
    1834:	80 91 a3 02 	lds	r24, 0x02A3
    1838:	88 23       	and	r24, r24
    183a:	91 f1       	breq	.+100    	; 0x18a0 <prvIdleTask+0x72>

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    183c:	80 91 9e 02 	lds	r24, 0x029E
    1840:	8f 5f       	subi	r24, 0xFF	; 255
    1842:	80 93 9e 02 	sts	0x029E, r24
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    1846:	10 91 e9 02 	lds	r17, 0x02E9
			xTaskResumeAll();
    184a:	0e 94 b1 0a 	call	0x1562	; 0x1562 <xTaskResumeAll>

			if( !xListIsEmpty )
    184e:	11 23       	and	r17, r17
    1850:	39 f1       	breq	.+78     	; 0x18a0 <prvIdleTask+0x72>
			{
				tskTCB *pxTCB;

				portENTER_CRITICAL();
    1852:	0f b6       	in	r0, 0x3f	; 63
    1854:	f8 94       	cli
    1856:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    1858:	80 91 e9 02 	lds	r24, 0x02E9
    185c:	88 23       	and	r24, r24
    185e:	19 f4       	brne	.+6      	; 0x1866 <prvIdleTask+0x38>
    1860:	c0 e0       	ldi	r28, 0x00	; 0
    1862:	d0 e0       	ldi	r29, 0x00	; 0
    1864:	06 c0       	rjmp	.+12     	; 0x1872 <prvIdleTask+0x44>
    1866:	e0 91 ee 02 	lds	r30, 0x02EE
    186a:	f0 91 ef 02 	lds	r31, 0x02EF
    186e:	c6 81       	ldd	r28, Z+6	; 0x06
    1870:	d7 81       	ldd	r29, Z+7	; 0x07
					vListRemove( &( pxTCB->xGenericListItem ) );
    1872:	ce 01       	movw	r24, r28
    1874:	02 96       	adiw	r24, 0x02	; 2
    1876:	0e 94 0d 06 	call	0xc1a	; 0xc1a <vListRemove>
					--uxCurrentNumberOfTasks;
    187a:	80 91 a1 02 	lds	r24, 0x02A1
    187e:	81 50       	subi	r24, 0x01	; 1
    1880:	80 93 a1 02 	sts	0x02A1, r24
					--uxTasksDeleted;
    1884:	80 91 a3 02 	lds	r24, 0x02A3
    1888:	81 50       	subi	r24, 0x01	; 1
    188a:	80 93 a3 02 	sts	0x02A3, r24
				}
				portEXIT_CRITICAL();
    188e:	0f 90       	pop	r0
    1890:	0f be       	out	0x3f, r0	; 63

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    1892:	8f 89       	ldd	r24, Y+23	; 0x17
    1894:	98 8d       	ldd	r25, Y+24	; 0x18
    1896:	0e 94 aa 10 	call	0x2154	; 0x2154 <vPortFree>
		vPortFree( pxTCB );
    189a:	ce 01       	movw	r24, r28
    189c:	0e 94 aa 10 	call	0x2154	; 0x2154 <vPortFree>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    18a0:	80 91 a6 02 	lds	r24, 0x02A6
    18a4:	82 30       	cpi	r24, 0x02	; 2
    18a6:	30 f2       	brcs	.-116    	; 0x1834 <prvIdleTask+0x6>
			{
				taskYIELD();
    18a8:	0e 94 87 0e 	call	0x1d0e	; 0x1d0e <vPortYield>
    18ac:	c3 cf       	rjmp	.-122    	; 0x1834 <prvIdleTask+0x6>

000018ae <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    18ae:	2f 92       	push	r2
    18b0:	3f 92       	push	r3
    18b2:	5f 92       	push	r5
    18b4:	6f 92       	push	r6
    18b6:	7f 92       	push	r7
    18b8:	8f 92       	push	r8
    18ba:	9f 92       	push	r9
    18bc:	af 92       	push	r10
    18be:	bf 92       	push	r11
    18c0:	cf 92       	push	r12
    18c2:	df 92       	push	r13
    18c4:	ef 92       	push	r14
    18c6:	ff 92       	push	r15
    18c8:	0f 93       	push	r16
    18ca:	1f 93       	push	r17
    18cc:	df 93       	push	r29
    18ce:	cf 93       	push	r28
    18d0:	00 d0       	rcall	.+0      	; 0x18d2 <xTaskGenericCreate+0x24>
    18d2:	00 d0       	rcall	.+0      	; 0x18d4 <xTaskGenericCreate+0x26>
    18d4:	cd b7       	in	r28, 0x3d	; 61
    18d6:	de b7       	in	r29, 0x3e	; 62
    18d8:	9a 83       	std	Y+2, r25	; 0x02
    18da:	89 83       	std	Y+1, r24	; 0x01
    18dc:	4b 01       	movw	r8, r22
    18de:	5a 01       	movw	r10, r20
    18e0:	19 01       	movw	r2, r18
    18e2:	50 2e       	mov	r5, r16
    18e4:	37 01       	movw	r6, r14
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    18e6:	81 e2       	ldi	r24, 0x21	; 33
    18e8:	90 e0       	ldi	r25, 0x00	; 0
    18ea:	0e 94 ba 10 	call	0x2174	; 0x2174 <pvPortMalloc>
    18ee:	8b 83       	std	Y+3, r24	; 0x03
    18f0:	9c 83       	std	Y+4, r25	; 0x04

	if( pxNewTCB != NULL )
    18f2:	8b 81       	ldd	r24, Y+3	; 0x03
    18f4:	9c 81       	ldd	r25, Y+4	; 0x04
    18f6:	89 2b       	or	r24, r25
    18f8:	89 f0       	breq	.+34     	; 0x191c <xTaskGenericCreate+0x6e>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    18fa:	c1 14       	cp	r12, r1
    18fc:	d1 04       	cpc	r13, r1
    18fe:	21 f4       	brne	.+8      	; 0x1908 <xTaskGenericCreate+0x5a>
    1900:	c5 01       	movw	r24, r10
    1902:	0e 94 ba 10 	call	0x2174	; 0x2174 <pvPortMalloc>
    1906:	6c 01       	movw	r12, r24
    1908:	eb 81       	ldd	r30, Y+3	; 0x03
    190a:	fc 81       	ldd	r31, Y+4	; 0x04
    190c:	d0 8e       	std	Z+24, r13	; 0x18
    190e:	c7 8a       	std	Z+23, r12	; 0x17

		if( pxNewTCB->pxStack == NULL )
    1910:	c1 14       	cp	r12, r1
    1912:	d1 04       	cpc	r13, r1
    1914:	29 f4       	brne	.+10     	; 0x1920 <xTaskGenericCreate+0x72>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    1916:	cf 01       	movw	r24, r30
    1918:	0e 94 aa 10 	call	0x2154	; 0x2154 <vPortFree>
    191c:	8f ef       	ldi	r24, 0xFF	; 255
    191e:	d5 c0       	rjmp	.+426    	; 0x1aca <xTaskGenericCreate+0x21c>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
    1920:	c6 01       	movw	r24, r12
    1922:	65 ea       	ldi	r22, 0xA5	; 165
    1924:	70 e0       	ldi	r23, 0x00	; 0
    1926:	a5 01       	movw	r20, r10
    1928:	0e 94 48 25 	call	0x4a90	; 0x4a90 <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
    192c:	08 94       	sec
    192e:	a1 08       	sbc	r10, r1
    1930:	b1 08       	sbc	r11, r1
    1932:	eb 81       	ldd	r30, Y+3	; 0x03
    1934:	fc 81       	ldd	r31, Y+4	; 0x04
    1936:	e7 88       	ldd	r14, Z+23	; 0x17
    1938:	f0 8c       	ldd	r15, Z+24	; 0x18
    193a:	ea 0c       	add	r14, r10
    193c:	fb 1c       	adc	r15, r11
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    193e:	cf 01       	movw	r24, r30
    1940:	49 96       	adiw	r24, 0x19	; 25
    1942:	b4 01       	movw	r22, r8
    1944:	48 e0       	ldi	r20, 0x08	; 8
    1946:	50 e0       	ldi	r21, 0x00	; 0
    1948:	0e 94 4f 25 	call	0x4a9e	; 0x4a9e <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
    194c:	eb 81       	ldd	r30, Y+3	; 0x03
    194e:	fc 81       	ldd	r31, Y+4	; 0x04
    1950:	10 a2       	std	Z+32, r1	; 0x20
    1952:	05 2d       	mov	r16, r5
    1954:	f3 e0       	ldi	r31, 0x03	; 3
    1956:	f5 15       	cp	r31, r5
    1958:	08 f4       	brcc	.+2      	; 0x195c <xTaskGenericCreate+0xae>
    195a:	03 e0       	ldi	r16, 0x03	; 3
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - 1;
	}

	pxTCB->uxPriority = uxPriority;
    195c:	eb 81       	ldd	r30, Y+3	; 0x03
    195e:	fc 81       	ldd	r31, Y+4	; 0x04
    1960:	06 8b       	std	Z+22, r16	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    1962:	42 e0       	ldi	r20, 0x02	; 2
    1964:	c4 2e       	mov	r12, r20
    1966:	d1 2c       	mov	r13, r1
    1968:	ce 0e       	add	r12, r30
    196a:	df 1e       	adc	r13, r31
    196c:	c6 01       	movw	r24, r12
    196e:	0e 94 ab 05 	call	0xb56	; 0xb56 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    1972:	8b 81       	ldd	r24, Y+3	; 0x03
    1974:	9c 81       	ldd	r25, Y+4	; 0x04
    1976:	0c 96       	adiw	r24, 0x0c	; 12
    1978:	0e 94 ab 05 	call	0xb56	; 0xb56 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    197c:	8b 81       	ldd	r24, Y+3	; 0x03
    197e:	9c 81       	ldd	r25, Y+4	; 0x04
    1980:	fc 01       	movw	r30, r24
    1982:	91 87       	std	Z+9, r25	; 0x09
    1984:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    1986:	84 e0       	ldi	r24, 0x04	; 4
    1988:	90 e0       	ldi	r25, 0x00	; 0
    198a:	80 1b       	sub	r24, r16
    198c:	91 09       	sbc	r25, r1
    198e:	95 87       	std	Z+13, r25	; 0x0d
    1990:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    1992:	f3 8b       	std	Z+19, r31	; 0x13
    1994:	e2 8b       	std	Z+18, r30	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1996:	c7 01       	movw	r24, r14
    1998:	69 81       	ldd	r22, Y+1	; 0x01
    199a:	7a 81       	ldd	r23, Y+2	; 0x02
    199c:	a1 01       	movw	r20, r2
    199e:	0e 94 a6 0d 	call	0x1b4c	; 0x1b4c <pxPortInitialiseStack>
    19a2:	eb 81       	ldd	r30, Y+3	; 0x03
    19a4:	fc 81       	ldd	r31, Y+4	; 0x04
    19a6:	91 83       	std	Z+1, r25	; 0x01
    19a8:	80 83       	st	Z, r24
		}
		#endif

		if( ( void * ) pxCreatedTask != NULL )
    19aa:	61 14       	cp	r6, r1
    19ac:	71 04       	cpc	r7, r1
    19ae:	21 f0       	breq	.+8      	; 0x19b8 <xTaskGenericCreate+0x10a>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    19b0:	cf 01       	movw	r24, r30
    19b2:	f3 01       	movw	r30, r6
    19b4:	91 83       	std	Z+1, r25	; 0x01
    19b6:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		portENTER_CRITICAL();
    19b8:	0f b6       	in	r0, 0x3f	; 63
    19ba:	f8 94       	cli
    19bc:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    19be:	80 91 a1 02 	lds	r24, 0x02A1
    19c2:	8f 5f       	subi	r24, 0xFF	; 255
    19c4:	80 93 a1 02 	sts	0x02A1, r24
			if( pxCurrentTCB == NULL )
    19c8:	80 91 98 02 	lds	r24, 0x0298
    19cc:	90 91 99 02 	lds	r25, 0x0299
    19d0:	89 2b       	or	r24, r25
    19d2:	b9 f5       	brne	.+110    	; 0x1a42 <xTaskGenericCreate+0x194>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    19d4:	eb 81       	ldd	r30, Y+3	; 0x03
    19d6:	fc 81       	ldd	r31, Y+4	; 0x04
    19d8:	f0 93 99 02 	sts	0x0299, r31
    19dc:	e0 93 98 02 	sts	0x0298, r30

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    19e0:	80 91 a1 02 	lds	r24, 0x02A1
    19e4:	81 30       	cpi	r24, 0x01	; 1
    19e6:	f1 f5       	brne	.+124    	; 0x1a64 <xTaskGenericCreate+0x1b6>
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    19e8:	86 ea       	ldi	r24, 0xA6	; 166
    19ea:	92 e0       	ldi	r25, 0x02	; 2
    19ec:	0e 94 9b 05 	call	0xb36	; 0xb36 <vListInitialise>
    19f0:	8f ea       	ldi	r24, 0xAF	; 175
    19f2:	92 e0       	ldi	r25, 0x02	; 2
    19f4:	0e 94 9b 05 	call	0xb36	; 0xb36 <vListInitialise>
    19f8:	88 eb       	ldi	r24, 0xB8	; 184
    19fa:	92 e0       	ldi	r25, 0x02	; 2
    19fc:	0e 94 9b 05 	call	0xb36	; 0xb36 <vListInitialise>
    1a00:	81 ec       	ldi	r24, 0xC1	; 193
    1a02:	92 e0       	ldi	r25, 0x02	; 2
    1a04:	0e 94 9b 05 	call	0xb36	; 0xb36 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    1a08:	3a ec       	ldi	r19, 0xCA	; 202
    1a0a:	e3 2e       	mov	r14, r19
    1a0c:	32 e0       	ldi	r19, 0x02	; 2
    1a0e:	f3 2e       	mov	r15, r19
    1a10:	c7 01       	movw	r24, r14
    1a12:	0e 94 9b 05 	call	0xb36	; 0xb36 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    1a16:	03 ed       	ldi	r16, 0xD3	; 211
    1a18:	12 e0       	ldi	r17, 0x02	; 2
    1a1a:	c8 01       	movw	r24, r16
    1a1c:	0e 94 9b 05 	call	0xb36	; 0xb36 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    1a20:	80 ee       	ldi	r24, 0xE0	; 224
    1a22:	92 e0       	ldi	r25, 0x02	; 2
    1a24:	0e 94 9b 05 	call	0xb36	; 0xb36 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    1a28:	89 ee       	ldi	r24, 0xE9	; 233
    1a2a:	92 e0       	ldi	r25, 0x02	; 2
    1a2c:	0e 94 9b 05 	call	0xb36	; 0xb36 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    1a30:	f0 92 dd 02 	sts	0x02DD, r15
    1a34:	e0 92 dc 02 	sts	0x02DC, r14
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1a38:	10 93 df 02 	sts	0x02DF, r17
    1a3c:	00 93 de 02 	sts	0x02DE, r16
    1a40:	11 c0       	rjmp	.+34     	; 0x1a64 <xTaskGenericCreate+0x1b6>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    1a42:	80 91 a2 02 	lds	r24, 0x02A2
    1a46:	88 23       	and	r24, r24
    1a48:	69 f4       	brne	.+26     	; 0x1a64 <xTaskGenericCreate+0x1b6>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    1a4a:	e0 91 98 02 	lds	r30, 0x0298
    1a4e:	f0 91 99 02 	lds	r31, 0x0299
    1a52:	86 89       	ldd	r24, Z+22	; 0x16
    1a54:	58 16       	cp	r5, r24
    1a56:	30 f0       	brcs	.+12     	; 0x1a64 <xTaskGenericCreate+0x1b6>
					{
						pxCurrentTCB = pxNewTCB;
    1a58:	8b 81       	ldd	r24, Y+3	; 0x03
    1a5a:	9c 81       	ldd	r25, Y+4	; 0x04
    1a5c:	90 93 99 02 	sts	0x0299, r25
    1a60:	80 93 98 02 	sts	0x0298, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    1a64:	eb 81       	ldd	r30, Y+3	; 0x03
    1a66:	fc 81       	ldd	r31, Y+4	; 0x04
    1a68:	96 89       	ldd	r25, Z+22	; 0x16
    1a6a:	80 91 a5 02 	lds	r24, 0x02A5
    1a6e:	89 17       	cp	r24, r25
    1a70:	10 f4       	brcc	.+4      	; 0x1a76 <xTaskGenericCreate+0x1c8>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    1a72:	90 93 a5 02 	sts	0x02A5, r25
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    1a76:	80 91 a4 02 	lds	r24, 0x02A4
    1a7a:	8f 5f       	subi	r24, 0xFF	; 255
    1a7c:	80 93 a4 02 	sts	0x02A4, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    1a80:	eb 81       	ldd	r30, Y+3	; 0x03
    1a82:	fc 81       	ldd	r31, Y+4	; 0x04
    1a84:	96 89       	ldd	r25, Z+22	; 0x16
    1a86:	80 91 9f 02 	lds	r24, 0x029F
    1a8a:	89 17       	cp	r24, r25
    1a8c:	10 f4       	brcc	.+4      	; 0x1a92 <xTaskGenericCreate+0x1e4>
    1a8e:	90 93 9f 02 	sts	0x029F, r25
    1a92:	eb 81       	ldd	r30, Y+3	; 0x03
    1a94:	fc 81       	ldd	r31, Y+4	; 0x04
    1a96:	86 89       	ldd	r24, Z+22	; 0x16
    1a98:	29 e0       	ldi	r18, 0x09	; 9
    1a9a:	82 9f       	mul	r24, r18
    1a9c:	c0 01       	movw	r24, r0
    1a9e:	11 24       	eor	r1, r1
    1aa0:	8a 55       	subi	r24, 0x5A	; 90
    1aa2:	9d 4f       	sbci	r25, 0xFD	; 253
    1aa4:	b6 01       	movw	r22, r12
    1aa6:	0e 94 af 05 	call	0xb5e	; 0xb5e <vListInsertEnd>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		portEXIT_CRITICAL();
    1aaa:	0f 90       	pop	r0
    1aac:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED( pxNewTCB );
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    1aae:	80 91 a2 02 	lds	r24, 0x02A2
    1ab2:	88 23       	and	r24, r24
    1ab4:	49 f0       	breq	.+18     	; 0x1ac8 <xTaskGenericCreate+0x21a>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    1ab6:	e0 91 98 02 	lds	r30, 0x0298
    1aba:	f0 91 99 02 	lds	r31, 0x0299
    1abe:	86 89       	ldd	r24, Z+22	; 0x16
    1ac0:	85 15       	cp	r24, r5
    1ac2:	10 f4       	brcc	.+4      	; 0x1ac8 <xTaskGenericCreate+0x21a>
			{
				portYIELD_WITHIN_API();
    1ac4:	0e 94 87 0e 	call	0x1d0e	; 0x1d0e <vPortYield>
    1ac8:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    1aca:	0f 90       	pop	r0
    1acc:	0f 90       	pop	r0
    1ace:	0f 90       	pop	r0
    1ad0:	0f 90       	pop	r0
    1ad2:	cf 91       	pop	r28
    1ad4:	df 91       	pop	r29
    1ad6:	1f 91       	pop	r17
    1ad8:	0f 91       	pop	r16
    1ada:	ff 90       	pop	r15
    1adc:	ef 90       	pop	r14
    1ade:	df 90       	pop	r13
    1ae0:	cf 90       	pop	r12
    1ae2:	bf 90       	pop	r11
    1ae4:	af 90       	pop	r10
    1ae6:	9f 90       	pop	r9
    1ae8:	8f 90       	pop	r8
    1aea:	7f 90       	pop	r7
    1aec:	6f 90       	pop	r6
    1aee:	5f 90       	pop	r5
    1af0:	3f 90       	pop	r3
    1af2:	2f 90       	pop	r2
    1af4:	08 95       	ret

00001af6 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    1af6:	af 92       	push	r10
    1af8:	bf 92       	push	r11
    1afa:	cf 92       	push	r12
    1afc:	df 92       	push	r13
    1afe:	ef 92       	push	r14
    1b00:	ff 92       	push	r15
    1b02:	0f 93       	push	r16
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
    1b04:	87 e1       	ldi	r24, 0x17	; 23
    1b06:	9c e0       	ldi	r25, 0x0C	; 12
    1b08:	62 e9       	ldi	r22, 0x92	; 146
    1b0a:	72 e0       	ldi	r23, 0x02	; 2
    1b0c:	45 e5       	ldi	r20, 0x55	; 85
    1b0e:	50 e0       	ldi	r21, 0x00	; 0
    1b10:	20 e0       	ldi	r18, 0x00	; 0
    1b12:	30 e0       	ldi	r19, 0x00	; 0
    1b14:	00 e0       	ldi	r16, 0x00	; 0
    1b16:	ee 24       	eor	r14, r14
    1b18:	ff 24       	eor	r15, r15
    1b1a:	cc 24       	eor	r12, r12
    1b1c:	dd 24       	eor	r13, r13
    1b1e:	aa 24       	eor	r10, r10
    1b20:	bb 24       	eor	r11, r11
    1b22:	0e 94 57 0c 	call	0x18ae	; 0x18ae <xTaskGenericCreate>

	if( xReturn == pdPASS )
    1b26:	81 30       	cpi	r24, 0x01	; 1
    1b28:	49 f4       	brne	.+18     	; 0x1b3c <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    1b2a:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    1b2c:	80 93 a2 02 	sts	0x02A2, r24
		xTickCount = ( portTickType ) 0;
    1b30:	10 92 9d 02 	sts	0x029D, r1
    1b34:	10 92 9c 02 	sts	0x029C, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
    1b38:	0e 94 ee 0d 	call	0x1bdc	; 0x1bdc <xPortStartScheduler>
		else
		{
			/* Should only reach here if a task calls xTaskEndScheduler(). */
		}
	}
}
    1b3c:	0f 91       	pop	r16
    1b3e:	ff 90       	pop	r15
    1b40:	ef 90       	pop	r14
    1b42:	df 90       	pop	r13
    1b44:	cf 90       	pop	r12
    1b46:	bf 90       	pop	r11
    1b48:	af 90       	pop	r10
    1b4a:	08 95       	ret

00001b4c <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    1b4c:	fc 01       	movw	r30, r24
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    1b4e:	91 e1       	ldi	r25, 0x11	; 17
    1b50:	90 83       	st	Z, r25
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    1b52:	22 e2       	ldi	r18, 0x22	; 34
    1b54:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    1b56:	83 e3       	ldi	r24, 0x33	; 51
    1b58:	82 93       	st	-Z, r24
	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	

	usAddress = ( unsigned short ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1b5a:	62 93       	st	-Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1b5c:	72 93       	st	-Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    1b5e:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    1b60:	80 e8       	ldi	r24, 0x80	; 128
    1b62:	82 93       	st	-Z, r24
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    1b64:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    1b66:	82 e0       	ldi	r24, 0x02	; 2
    1b68:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    1b6a:	83 e0       	ldi	r24, 0x03	; 3
    1b6c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    1b6e:	84 e0       	ldi	r24, 0x04	; 4
    1b70:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    1b72:	85 e0       	ldi	r24, 0x05	; 5
    1b74:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    1b76:	86 e0       	ldi	r24, 0x06	; 6
    1b78:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    1b7a:	87 e0       	ldi	r24, 0x07	; 7
    1b7c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    1b7e:	88 e0       	ldi	r24, 0x08	; 8
    1b80:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    1b82:	89 e0       	ldi	r24, 0x09	; 9
    1b84:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    1b86:	80 e1       	ldi	r24, 0x10	; 16
    1b88:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    1b8a:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    1b8c:	82 e1       	ldi	r24, 0x12	; 18
    1b8e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    1b90:	83 e1       	ldi	r24, 0x13	; 19
    1b92:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    1b94:	84 e1       	ldi	r24, 0x14	; 20
    1b96:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    1b98:	85 e1       	ldi	r24, 0x15	; 21
    1b9a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    1b9c:	86 e1       	ldi	r24, 0x16	; 22
    1b9e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    1ba0:	87 e1       	ldi	r24, 0x17	; 23
    1ba2:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    1ba4:	88 e1       	ldi	r24, 0x18	; 24
    1ba6:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    1ba8:	89 e1       	ldi	r24, 0x19	; 25
    1baa:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    1bac:	80 e2       	ldi	r24, 0x20	; 32
    1bae:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    1bb0:	81 e2       	ldi	r24, 0x21	; 33
    1bb2:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    1bb4:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    1bb6:	83 e2       	ldi	r24, 0x23	; 35
    1bb8:	82 93       	st	-Z, r24
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */

	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1bba:	42 93       	st	-Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1bbc:	52 93       	st	-Z, r21
	pxTopOfStack--;


	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    1bbe:	86 e2       	ldi	r24, 0x26	; 38
    1bc0:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    1bc2:	87 e2       	ldi	r24, 0x27	; 39
    1bc4:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    1bc6:	88 e2       	ldi	r24, 0x28	; 40
    1bc8:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    1bca:	89 e2       	ldi	r24, 0x29	; 41
    1bcc:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    1bce:	80 e3       	ldi	r24, 0x30	; 48
    1bd0:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    1bd2:	81 e3       	ldi	r24, 0x31	; 49
    1bd4:	82 93       	st	-Z, r24
    1bd6:	31 97       	sbiw	r30, 0x01	; 1
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    1bd8:	cf 01       	movw	r24, r30
    1bda:	08 95       	ret

00001bdc <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	OCR1AH = ucHighByte;
    1bdc:	10 92 89 00 	sts	0x0089, r1
	OCR1AL = ucLowByte;
    1be0:	89 ef       	ldi	r24, 0xF9	; 249
    1be2:	80 93 88 00 	sts	0x0088, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    1be6:	8b e0       	ldi	r24, 0x0B	; 11
    1be8:	80 93 81 00 	sts	0x0081, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
    1bec:	ef e6       	ldi	r30, 0x6F	; 111
    1bee:	f0 e0       	ldi	r31, 0x00	; 0
    1bf0:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1bf2:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
    1bf4:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    1bf6:	a0 91 98 02 	lds	r26, 0x0298
    1bfa:	b0 91 99 02 	lds	r27, 0x0299
    1bfe:	cd 91       	ld	r28, X+
    1c00:	cd bf       	out	0x3d, r28	; 61
    1c02:	dd 91       	ld	r29, X+
    1c04:	de bf       	out	0x3e, r29	; 62
    1c06:	ff 91       	pop	r31
    1c08:	ef 91       	pop	r30
    1c0a:	df 91       	pop	r29
    1c0c:	cf 91       	pop	r28
    1c0e:	bf 91       	pop	r27
    1c10:	af 91       	pop	r26
    1c12:	9f 91       	pop	r25
    1c14:	8f 91       	pop	r24
    1c16:	7f 91       	pop	r23
    1c18:	6f 91       	pop	r22
    1c1a:	5f 91       	pop	r21
    1c1c:	4f 91       	pop	r20
    1c1e:	3f 91       	pop	r19
    1c20:	2f 91       	pop	r18
    1c22:	1f 91       	pop	r17
    1c24:	0f 91       	pop	r16
    1c26:	ff 90       	pop	r15
    1c28:	ef 90       	pop	r14
    1c2a:	df 90       	pop	r13
    1c2c:	cf 90       	pop	r12
    1c2e:	bf 90       	pop	r11
    1c30:	af 90       	pop	r10
    1c32:	9f 90       	pop	r9
    1c34:	8f 90       	pop	r8
    1c36:	7f 90       	pop	r7
    1c38:	6f 90       	pop	r6
    1c3a:	5f 90       	pop	r5
    1c3c:	4f 90       	pop	r4
    1c3e:	3f 90       	pop	r3
    1c40:	2f 90       	pop	r2
    1c42:	1f 90       	pop	r1
    1c44:	0f 90       	pop	r0
    1c46:	0f be       	out	0x3f, r0	; 63
    1c48:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1c4a:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    1c4c:	81 e0       	ldi	r24, 0x01	; 1
    1c4e:	08 95       	ret

00001c50 <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    1c50:	08 95       	ret

00001c52 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1c52:	0f 92       	push	r0
    1c54:	0f b6       	in	r0, 0x3f	; 63
    1c56:	f8 94       	cli
    1c58:	0f 92       	push	r0
    1c5a:	1f 92       	push	r1
    1c5c:	11 24       	eor	r1, r1
    1c5e:	2f 92       	push	r2
    1c60:	3f 92       	push	r3
    1c62:	4f 92       	push	r4
    1c64:	5f 92       	push	r5
    1c66:	6f 92       	push	r6
    1c68:	7f 92       	push	r7
    1c6a:	8f 92       	push	r8
    1c6c:	9f 92       	push	r9
    1c6e:	af 92       	push	r10
    1c70:	bf 92       	push	r11
    1c72:	cf 92       	push	r12
    1c74:	df 92       	push	r13
    1c76:	ef 92       	push	r14
    1c78:	ff 92       	push	r15
    1c7a:	0f 93       	push	r16
    1c7c:	1f 93       	push	r17
    1c7e:	2f 93       	push	r18
    1c80:	3f 93       	push	r19
    1c82:	4f 93       	push	r20
    1c84:	5f 93       	push	r21
    1c86:	6f 93       	push	r22
    1c88:	7f 93       	push	r23
    1c8a:	8f 93       	push	r24
    1c8c:	9f 93       	push	r25
    1c8e:	af 93       	push	r26
    1c90:	bf 93       	push	r27
    1c92:	cf 93       	push	r28
    1c94:	df 93       	push	r29
    1c96:	ef 93       	push	r30
    1c98:	ff 93       	push	r31
    1c9a:	a0 91 98 02 	lds	r26, 0x0298
    1c9e:	b0 91 99 02 	lds	r27, 0x0299
    1ca2:	0d b6       	in	r0, 0x3d	; 61
    1ca4:	0d 92       	st	X+, r0
    1ca6:	0e b6       	in	r0, 0x3e	; 62
    1ca8:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1caa:	0e 94 02 0a 	call	0x1404	; 0x1404 <vTaskIncrementTick>
	vTaskSwitchContext();
    1cae:	0e 94 34 09 	call	0x1268	; 0x1268 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1cb2:	a0 91 98 02 	lds	r26, 0x0298
    1cb6:	b0 91 99 02 	lds	r27, 0x0299
    1cba:	cd 91       	ld	r28, X+
    1cbc:	cd bf       	out	0x3d, r28	; 61
    1cbe:	dd 91       	ld	r29, X+
    1cc0:	de bf       	out	0x3e, r29	; 62
    1cc2:	ff 91       	pop	r31
    1cc4:	ef 91       	pop	r30
    1cc6:	df 91       	pop	r29
    1cc8:	cf 91       	pop	r28
    1cca:	bf 91       	pop	r27
    1ccc:	af 91       	pop	r26
    1cce:	9f 91       	pop	r25
    1cd0:	8f 91       	pop	r24
    1cd2:	7f 91       	pop	r23
    1cd4:	6f 91       	pop	r22
    1cd6:	5f 91       	pop	r21
    1cd8:	4f 91       	pop	r20
    1cda:	3f 91       	pop	r19
    1cdc:	2f 91       	pop	r18
    1cde:	1f 91       	pop	r17
    1ce0:	0f 91       	pop	r16
    1ce2:	ff 90       	pop	r15
    1ce4:	ef 90       	pop	r14
    1ce6:	df 90       	pop	r13
    1ce8:	cf 90       	pop	r12
    1cea:	bf 90       	pop	r11
    1cec:	af 90       	pop	r10
    1cee:	9f 90       	pop	r9
    1cf0:	8f 90       	pop	r8
    1cf2:	7f 90       	pop	r7
    1cf4:	6f 90       	pop	r6
    1cf6:	5f 90       	pop	r5
    1cf8:	4f 90       	pop	r4
    1cfa:	3f 90       	pop	r3
    1cfc:	2f 90       	pop	r2
    1cfe:	1f 90       	pop	r1
    1d00:	0f 90       	pop	r0
    1d02:	0f be       	out	0x3f, r0	; 63
    1d04:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1d06:	08 95       	ret

00001d08 <__vector_17>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    1d08:	0e 94 29 0e 	call	0x1c52	; 0x1c52 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1d0c:	18 95       	reti

00001d0e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1d0e:	0f 92       	push	r0
    1d10:	0f b6       	in	r0, 0x3f	; 63
    1d12:	f8 94       	cli
    1d14:	0f 92       	push	r0
    1d16:	1f 92       	push	r1
    1d18:	11 24       	eor	r1, r1
    1d1a:	2f 92       	push	r2
    1d1c:	3f 92       	push	r3
    1d1e:	4f 92       	push	r4
    1d20:	5f 92       	push	r5
    1d22:	6f 92       	push	r6
    1d24:	7f 92       	push	r7
    1d26:	8f 92       	push	r8
    1d28:	9f 92       	push	r9
    1d2a:	af 92       	push	r10
    1d2c:	bf 92       	push	r11
    1d2e:	cf 92       	push	r12
    1d30:	df 92       	push	r13
    1d32:	ef 92       	push	r14
    1d34:	ff 92       	push	r15
    1d36:	0f 93       	push	r16
    1d38:	1f 93       	push	r17
    1d3a:	2f 93       	push	r18
    1d3c:	3f 93       	push	r19
    1d3e:	4f 93       	push	r20
    1d40:	5f 93       	push	r21
    1d42:	6f 93       	push	r22
    1d44:	7f 93       	push	r23
    1d46:	8f 93       	push	r24
    1d48:	9f 93       	push	r25
    1d4a:	af 93       	push	r26
    1d4c:	bf 93       	push	r27
    1d4e:	cf 93       	push	r28
    1d50:	df 93       	push	r29
    1d52:	ef 93       	push	r30
    1d54:	ff 93       	push	r31
    1d56:	a0 91 98 02 	lds	r26, 0x0298
    1d5a:	b0 91 99 02 	lds	r27, 0x0299
    1d5e:	0d b6       	in	r0, 0x3d	; 61
    1d60:	0d 92       	st	X+, r0
    1d62:	0e b6       	in	r0, 0x3e	; 62
    1d64:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1d66:	0e 94 34 09 	call	0x1268	; 0x1268 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1d6a:	a0 91 98 02 	lds	r26, 0x0298
    1d6e:	b0 91 99 02 	lds	r27, 0x0299
    1d72:	cd 91       	ld	r28, X+
    1d74:	cd bf       	out	0x3d, r28	; 61
    1d76:	dd 91       	ld	r29, X+
    1d78:	de bf       	out	0x3e, r29	; 62
    1d7a:	ff 91       	pop	r31
    1d7c:	ef 91       	pop	r30
    1d7e:	df 91       	pop	r29
    1d80:	cf 91       	pop	r28
    1d82:	bf 91       	pop	r27
    1d84:	af 91       	pop	r26
    1d86:	9f 91       	pop	r25
    1d88:	8f 91       	pop	r24
    1d8a:	7f 91       	pop	r23
    1d8c:	6f 91       	pop	r22
    1d8e:	5f 91       	pop	r21
    1d90:	4f 91       	pop	r20
    1d92:	3f 91       	pop	r19
    1d94:	2f 91       	pop	r18
    1d96:	1f 91       	pop	r17
    1d98:	0f 91       	pop	r16
    1d9a:	ff 90       	pop	r15
    1d9c:	ef 90       	pop	r14
    1d9e:	df 90       	pop	r13
    1da0:	cf 90       	pop	r12
    1da2:	bf 90       	pop	r11
    1da4:	af 90       	pop	r10
    1da6:	9f 90       	pop	r9
    1da8:	8f 90       	pop	r8
    1daa:	7f 90       	pop	r7
    1dac:	6f 90       	pop	r6
    1dae:	5f 90       	pop	r5
    1db0:	4f 90       	pop	r4
    1db2:	3f 90       	pop	r3
    1db4:	2f 90       	pop	r2
    1db6:	1f 90       	pop	r1
    1db8:	0f 90       	pop	r0
    1dba:	0f be       	out	0x3f, r0	; 63
    1dbc:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1dbe:	08 95       	ret

00001dc0 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    1dc0:	0f 93       	push	r16
    1dc2:	1f 93       	push	r17
    1dc4:	cf 93       	push	r28
    1dc6:	df 93       	push	r29
    1dc8:	fc 01       	movw	r30, r24
corCRCB *pxUnblockedCRCB;
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1dca:	80 81       	ld	r24, Z
    1dcc:	88 23       	and	r24, r24
    1dce:	19 f4       	brne	.+6      	; 0x1dd6 <xCoRoutineRemoveFromEventList+0x16>
    1dd0:	c0 e0       	ldi	r28, 0x00	; 0
    1dd2:	d0 e0       	ldi	r29, 0x00	; 0
    1dd4:	05 c0       	rjmp	.+10     	; 0x1de0 <xCoRoutineRemoveFromEventList+0x20>
    1dd6:	05 80       	ldd	r0, Z+5	; 0x05
    1dd8:	f6 81       	ldd	r31, Z+6	; 0x06
    1dda:	e0 2d       	mov	r30, r0
    1ddc:	c6 81       	ldd	r28, Z+6	; 0x06
    1dde:	d7 81       	ldd	r29, Z+7	; 0x07
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1de0:	8e 01       	movw	r16, r28
    1de2:	04 5f       	subi	r16, 0xF4	; 244
    1de4:	1f 4f       	sbci	r17, 0xFF	; 255
    1de6:	c8 01       	movw	r24, r16
    1de8:	0e 94 0d 06 	call	0xc1a	; 0xc1a <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    1dec:	83 e2       	ldi	r24, 0x23	; 35
    1dee:	93 e0       	ldi	r25, 0x03	; 3
    1df0:	b8 01       	movw	r22, r16
    1df2:	0e 94 af 05 	call	0xb5e	; 0xb5e <vListInsertEnd>
    1df6:	20 e0       	ldi	r18, 0x00	; 0
    1df8:	e0 91 f2 02 	lds	r30, 0x02F2
    1dfc:	f0 91 f3 02 	lds	r31, 0x02F3
    1e00:	9e 89       	ldd	r25, Y+22	; 0x16
    1e02:	86 89       	ldd	r24, Z+22	; 0x16
    1e04:	98 17       	cp	r25, r24
    1e06:	08 f0       	brcs	.+2      	; 0x1e0a <xCoRoutineRemoveFromEventList+0x4a>
    1e08:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    1e0a:	82 2f       	mov	r24, r18
    1e0c:	df 91       	pop	r29
    1e0e:	cf 91       	pop	r28
    1e10:	1f 91       	pop	r17
    1e12:	0f 91       	pop	r16
    1e14:	08 95       	ret

00001e16 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    1e16:	ff 92       	push	r15
    1e18:	0f 93       	push	r16
    1e1a:	1f 93       	push	r17
    1e1c:	cf 93       	push	r28
    1e1e:	df 93       	push	r29
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    1e20:	99 e0       	ldi	r25, 0x09	; 9
    1e22:	f9 2e       	mov	r15, r25
    1e24:	28 c0       	rjmp	.+80     	; 0x1e76 <vCoRoutineSchedule+0x60>
	while( !listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    1e26:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    1e28:	80 91 23 03 	lds	r24, 0x0323
    1e2c:	88 23       	and	r24, r24
    1e2e:	19 f4       	brne	.+6      	; 0x1e36 <vCoRoutineSchedule+0x20>
    1e30:	c0 e0       	ldi	r28, 0x00	; 0
    1e32:	d0 e0       	ldi	r29, 0x00	; 0
    1e34:	06 c0       	rjmp	.+12     	; 0x1e42 <vCoRoutineSchedule+0x2c>
    1e36:	e0 91 28 03 	lds	r30, 0x0328
    1e3a:	f0 91 29 03 	lds	r31, 0x0329
    1e3e:	c6 81       	ldd	r28, Z+6	; 0x06
    1e40:	d7 81       	ldd	r29, Z+7	; 0x07
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1e42:	ce 01       	movw	r24, r28
    1e44:	0c 96       	adiw	r24, 0x0c	; 12
    1e46:	0e 94 0d 06 	call	0xc1a	; 0xc1a <vListRemove>
		}
		portENABLE_INTERRUPTS();
    1e4a:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    1e4c:	8e 01       	movw	r16, r28
    1e4e:	0e 5f       	subi	r16, 0xFE	; 254
    1e50:	1f 4f       	sbci	r17, 0xFF	; 255
    1e52:	c8 01       	movw	r24, r16
    1e54:	0e 94 0d 06 	call	0xc1a	; 0xc1a <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    1e58:	9e 89       	ldd	r25, Y+22	; 0x16
    1e5a:	80 91 f4 02 	lds	r24, 0x02F4
    1e5e:	89 17       	cp	r24, r25
    1e60:	10 f4       	brcc	.+4      	; 0x1e66 <vCoRoutineSchedule+0x50>
    1e62:	90 93 f4 02 	sts	0x02F4, r25
    1e66:	9f 9d       	mul	r25, r15
    1e68:	c0 01       	movw	r24, r0
    1e6a:	11 24       	eor	r1, r1
    1e6c:	85 50       	subi	r24, 0x05	; 5
    1e6e:	9d 4f       	sbci	r25, 0xFD	; 253
    1e70:	b8 01       	movw	r22, r16
    1e72:	0e 94 af 05 	call	0xb5e	; 0xb5e <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( !listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) )
    1e76:	80 91 23 03 	lds	r24, 0x0323
    1e7a:	88 23       	and	r24, r24
    1e7c:	a1 f6       	brne	.-88     	; 0x1e26 <vCoRoutineSchedule+0x10>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    1e7e:	0e 94 20 09 	call	0x1240	; 0x1240 <xTaskGetTickCount>
    1e82:	20 91 f5 02 	lds	r18, 0x02F5
    1e86:	30 91 f6 02 	lds	r19, 0x02F6
    1e8a:	82 1b       	sub	r24, r18
    1e8c:	93 0b       	sbc	r25, r19
    1e8e:	90 93 f8 02 	sts	0x02F8, r25
    1e92:	80 93 f7 02 	sts	0x02F7, r24
					vListRemove( &( pxCRCB->xEventListItem ) );											
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    1e96:	89 e0       	ldi	r24, 0x09	; 9
    1e98:	f8 2e       	mov	r15, r24
    1e9a:	54 c0       	rjmp	.+168    	; 0x1f44 <vCoRoutineSchedule+0x12e>
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    1e9c:	01 96       	adiw	r24, 0x01	; 1
    1e9e:	90 93 fa 02 	sts	0x02FA, r25
    1ea2:	80 93 f9 02 	sts	0x02F9, r24
		xPassedTicks--;
    1ea6:	21 50       	subi	r18, 0x01	; 1
    1ea8:	30 40       	sbci	r19, 0x00	; 0
    1eaa:	30 93 f8 02 	sts	0x02F8, r19
    1eae:	20 93 f7 02 	sts	0x02F7, r18

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    1eb2:	89 2b       	or	r24, r25
    1eb4:	c9 f5       	brne	.+114    	; 0x1f28 <vCoRoutineSchedule+0x112>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    1eb6:	20 91 1f 03 	lds	r18, 0x031F
    1eba:	30 91 20 03 	lds	r19, 0x0320
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    1ebe:	80 91 21 03 	lds	r24, 0x0321
    1ec2:	90 91 22 03 	lds	r25, 0x0322
    1ec6:	90 93 20 03 	sts	0x0320, r25
    1eca:	80 93 1f 03 	sts	0x031F, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    1ece:	30 93 22 03 	sts	0x0322, r19
    1ed2:	20 93 21 03 	sts	0x0321, r18
    1ed6:	28 c0       	rjmp	.+80     	; 0x1f28 <vCoRoutineSchedule+0x112>
		}

		/* See if this tick has made a timeout expire. */
		while( ( pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList ) ) != NULL )
		{	
			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    1ed8:	20 91 f9 02 	lds	r18, 0x02F9
    1edc:	30 91 fa 02 	lds	r19, 0x02FA
    1ee0:	8a 81       	ldd	r24, Y+2	; 0x02
    1ee2:	9b 81       	ldd	r25, Y+3	; 0x03
    1ee4:	28 17       	cp	r18, r24
    1ee6:	39 07       	cpc	r19, r25
    1ee8:	68 f1       	brcs	.+90     	; 0x1f44 <vCoRoutineSchedule+0x12e>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    1eea:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    1eec:	8e 01       	movw	r16, r28
    1eee:	0e 5f       	subi	r16, 0xFE	; 254
    1ef0:	1f 4f       	sbci	r17, 0xFF	; 255
    1ef2:	c8 01       	movw	r24, r16
    1ef4:	0e 94 0d 06 	call	0xc1a	; 0xc1a <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    1ef8:	8c 89       	ldd	r24, Y+20	; 0x14
    1efa:	9d 89       	ldd	r25, Y+21	; 0x15
    1efc:	89 2b       	or	r24, r25
    1efe:	21 f0       	breq	.+8      	; 0x1f08 <vCoRoutineSchedule+0xf2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    1f00:	ce 01       	movw	r24, r28
    1f02:	0c 96       	adiw	r24, 0x0c	; 12
    1f04:	0e 94 0d 06 	call	0xc1a	; 0xc1a <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    1f08:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    1f0a:	9e 89       	ldd	r25, Y+22	; 0x16
    1f0c:	80 91 f4 02 	lds	r24, 0x02F4
    1f10:	89 17       	cp	r24, r25
    1f12:	10 f4       	brcc	.+4      	; 0x1f18 <vCoRoutineSchedule+0x102>
    1f14:	90 93 f4 02 	sts	0x02F4, r25
    1f18:	9f 9d       	mul	r25, r15
    1f1a:	c0 01       	movw	r24, r0
    1f1c:	11 24       	eor	r1, r1
    1f1e:	85 50       	subi	r24, 0x05	; 5
    1f20:	9d 4f       	sbci	r25, 0xFD	; 253
    1f22:	b8 01       	movw	r22, r16
    1f24:	0e 94 af 05 	call	0xb5e	; 0xb5e <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( ( pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList ) ) != NULL )
    1f28:	e0 91 1f 03 	lds	r30, 0x031F
    1f2c:	f0 91 20 03 	lds	r31, 0x0320
    1f30:	80 81       	ld	r24, Z
    1f32:	88 23       	and	r24, r24
    1f34:	39 f0       	breq	.+14     	; 0x1f44 <vCoRoutineSchedule+0x12e>
    1f36:	05 80       	ldd	r0, Z+5	; 0x05
    1f38:	f6 81       	ldd	r31, Z+6	; 0x06
    1f3a:	e0 2d       	mov	r30, r0
    1f3c:	c6 81       	ldd	r28, Z+6	; 0x06
    1f3e:	d7 81       	ldd	r29, Z+7	; 0x07
    1f40:	20 97       	sbiw	r28, 0x00	; 0
    1f42:	51 f6       	brne	.-108    	; 0x1ed8 <vCoRoutineSchedule+0xc2>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    1f44:	20 91 f7 02 	lds	r18, 0x02F7
    1f48:	30 91 f8 02 	lds	r19, 0x02F8
    1f4c:	80 91 f9 02 	lds	r24, 0x02F9
    1f50:	90 91 fa 02 	lds	r25, 0x02FA
    1f54:	21 15       	cp	r18, r1
    1f56:	31 05       	cpc	r19, r1
    1f58:	09 f0       	breq	.+2      	; 0x1f5c <vCoRoutineSchedule+0x146>
    1f5a:	a0 cf       	rjmp	.-192    	; 0x1e9c <vCoRoutineSchedule+0x86>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    1f5c:	90 93 f6 02 	sts	0x02F6, r25
    1f60:	80 93 f5 02 	sts	0x02F5, r24
    1f64:	90 91 f4 02 	lds	r25, 0x02F4

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    1f68:	29 e0       	ldi	r18, 0x09	; 9
    1f6a:	06 c0       	rjmp	.+12     	; 0x1f78 <vCoRoutineSchedule+0x162>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    1f6c:	99 23       	and	r25, r25
    1f6e:	19 f4       	brne	.+6      	; 0x1f76 <vCoRoutineSchedule+0x160>
    1f70:	10 92 f4 02 	sts	0x02F4, r1
    1f74:	32 c0       	rjmp	.+100    	; 0x1fda <vCoRoutineSchedule+0x1c4>
    1f76:	91 50       	subi	r25, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    1f78:	92 9f       	mul	r25, r18
    1f7a:	d0 01       	movw	r26, r0
    1f7c:	11 24       	eor	r1, r1
    1f7e:	a5 50       	subi	r26, 0x05	; 5
    1f80:	bd 4f       	sbci	r27, 0xFD	; 253
    1f82:	8c 91       	ld	r24, X
    1f84:	88 23       	and	r24, r24
    1f86:	91 f3       	breq	.-28     	; 0x1f6c <vCoRoutineSchedule+0x156>
    1f88:	90 93 f4 02 	sts	0x02F4, r25
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    1f8c:	11 96       	adiw	r26, 0x01	; 1
    1f8e:	ed 91       	ld	r30, X+
    1f90:	fc 91       	ld	r31, X
    1f92:	12 97       	sbiw	r26, 0x02	; 2
    1f94:	02 80       	ldd	r0, Z+2	; 0x02
    1f96:	f3 81       	ldd	r31, Z+3	; 0x03
    1f98:	e0 2d       	mov	r30, r0
    1f9a:	12 96       	adiw	r26, 0x02	; 2
    1f9c:	fc 93       	st	X, r31
    1f9e:	ee 93       	st	-X, r30
    1fa0:	11 97       	sbiw	r26, 0x01	; 1
    1fa2:	cd 01       	movw	r24, r26
    1fa4:	03 96       	adiw	r24, 0x03	; 3
    1fa6:	e8 17       	cp	r30, r24
    1fa8:	f9 07       	cpc	r31, r25
    1faa:	31 f4       	brne	.+12     	; 0x1fb8 <vCoRoutineSchedule+0x1a2>
    1fac:	82 81       	ldd	r24, Z+2	; 0x02
    1fae:	93 81       	ldd	r25, Z+3	; 0x03
    1fb0:	12 96       	adiw	r26, 0x02	; 2
    1fb2:	9c 93       	st	X, r25
    1fb4:	8e 93       	st	-X, r24
    1fb6:	11 97       	sbiw	r26, 0x01	; 1
    1fb8:	11 96       	adiw	r26, 0x01	; 1
    1fba:	ed 91       	ld	r30, X+
    1fbc:	fc 91       	ld	r31, X
    1fbe:	12 97       	sbiw	r26, 0x02	; 2
    1fc0:	06 80       	ldd	r0, Z+6	; 0x06
    1fc2:	f7 81       	ldd	r31, Z+7	; 0x07
    1fc4:	e0 2d       	mov	r30, r0
    1fc6:	f0 93 f3 02 	sts	0x02F3, r31
    1fca:	e0 93 f2 02 	sts	0x02F2, r30

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    1fce:	20 81       	ld	r18, Z
    1fd0:	31 81       	ldd	r19, Z+1	; 0x01
    1fd2:	cf 01       	movw	r24, r30
    1fd4:	67 89       	ldd	r22, Z+23	; 0x17
    1fd6:	f9 01       	movw	r30, r18
    1fd8:	09 95       	icall

	return;
}
    1fda:	df 91       	pop	r29
    1fdc:	cf 91       	pop	r28
    1fde:	1f 91       	pop	r17
    1fe0:	0f 91       	pop	r16
    1fe2:	ff 90       	pop	r15
    1fe4:	08 95       	ret

00001fe6 <vCoRoutineAddToDelayedList>:
	return xReturn;	
}
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    1fe6:	0f 93       	push	r16
    1fe8:	1f 93       	push	r17
    1fea:	cf 93       	push	r28
    1fec:	df 93       	push	r29
    1fee:	eb 01       	movw	r28, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    1ff0:	00 91 f9 02 	lds	r16, 0x02F9
    1ff4:	10 91 fa 02 	lds	r17, 0x02FA
    1ff8:	08 0f       	add	r16, r24
    1ffa:	19 1f       	adc	r17, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1ffc:	80 91 f2 02 	lds	r24, 0x02F2
    2000:	90 91 f3 02 	lds	r25, 0x02F3
    2004:	02 96       	adiw	r24, 0x02	; 2
    2006:	0e 94 0d 06 	call	0xc1a	; 0xc1a <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    200a:	e0 91 f2 02 	lds	r30, 0x02F2
    200e:	f0 91 f3 02 	lds	r31, 0x02F3
    2012:	13 83       	std	Z+3, r17	; 0x03
    2014:	02 83       	std	Z+2, r16	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    2016:	80 91 f9 02 	lds	r24, 0x02F9
    201a:	90 91 fa 02 	lds	r25, 0x02FA
    201e:	bf 01       	movw	r22, r30
    2020:	6e 5f       	subi	r22, 0xFE	; 254
    2022:	7f 4f       	sbci	r23, 0xFF	; 255
    2024:	08 17       	cp	r16, r24
    2026:	19 07       	cpc	r17, r25
    2028:	28 f4       	brcc	.+10     	; 0x2034 <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    202a:	80 91 21 03 	lds	r24, 0x0321
    202e:	90 91 22 03 	lds	r25, 0x0322
    2032:	04 c0       	rjmp	.+8      	; 0x203c <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2034:	80 91 1f 03 	lds	r24, 0x031F
    2038:	90 91 20 03 	lds	r25, 0x0320
    203c:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <vListInsert>
	}

	if( pxEventList )
    2040:	20 97       	sbiw	r28, 0x00	; 0
    2042:	49 f0       	breq	.+18     	; 0x2056 <vCoRoutineAddToDelayedList+0x70>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    2044:	60 91 f2 02 	lds	r22, 0x02F2
    2048:	70 91 f3 02 	lds	r23, 0x02F3
    204c:	64 5f       	subi	r22, 0xF4	; 244
    204e:	7f 4f       	sbci	r23, 0xFF	; 255
    2050:	ce 01       	movw	r24, r28
    2052:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <vListInsert>
	}
}
    2056:	df 91       	pop	r29
    2058:	cf 91       	pop	r28
    205a:	1f 91       	pop	r17
    205c:	0f 91       	pop	r16
    205e:	08 95       	ret

00002060 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    2060:	af 92       	push	r10
    2062:	bf 92       	push	r11
    2064:	cf 92       	push	r12
    2066:	df 92       	push	r13
    2068:	ef 92       	push	r14
    206a:	ff 92       	push	r15
    206c:	0f 93       	push	r16
    206e:	1f 93       	push	r17
    2070:	cf 93       	push	r28
    2072:	df 93       	push	r29
    2074:	6c 01       	movw	r12, r24
    2076:	b6 2e       	mov	r11, r22
    2078:	a4 2e       	mov	r10, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    207a:	8a e1       	ldi	r24, 0x1A	; 26
    207c:	90 e0       	ldi	r25, 0x00	; 0
    207e:	0e 94 ba 10 	call	0x2174	; 0x2174 <pvPortMalloc>
    2082:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
    2084:	00 97       	sbiw	r24, 0x00	; 0
    2086:	11 f4       	brne	.+4      	; 0x208c <xCoRoutineCreate+0x2c>
    2088:	8f ef       	ldi	r24, 0xFF	; 255
    208a:	59 c0       	rjmp	.+178    	; 0x213e <xCoRoutineCreate+0xde>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    208c:	80 91 f2 02 	lds	r24, 0x02F2
    2090:	90 91 f3 02 	lds	r25, 0x02F3
    2094:	89 2b       	or	r24, r25
    2096:	21 f5       	brne	.+72     	; 0x20e0 <xCoRoutineCreate+0x80>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    2098:	d0 93 f3 02 	sts	0x02F3, r29
    209c:	c0 93 f2 02 	sts	0x02F2, r28
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    20a0:	8b ef       	ldi	r24, 0xFB	; 251
    20a2:	92 e0       	ldi	r25, 0x02	; 2
    20a4:	0e 94 9b 05 	call	0xb36	; 0xb36 <vListInitialise>
    20a8:	84 e0       	ldi	r24, 0x04	; 4
    20aa:	93 e0       	ldi	r25, 0x03	; 3
    20ac:	0e 94 9b 05 	call	0xb36	; 0xb36 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    20b0:	2d e0       	ldi	r18, 0x0D	; 13
    20b2:	e2 2e       	mov	r14, r18
    20b4:	23 e0       	ldi	r18, 0x03	; 3
    20b6:	f2 2e       	mov	r15, r18
    20b8:	c7 01       	movw	r24, r14
    20ba:	0e 94 9b 05 	call	0xb36	; 0xb36 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    20be:	06 e1       	ldi	r16, 0x16	; 22
    20c0:	13 e0       	ldi	r17, 0x03	; 3
    20c2:	c8 01       	movw	r24, r16
    20c4:	0e 94 9b 05 	call	0xb36	; 0xb36 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    20c8:	83 e2       	ldi	r24, 0x23	; 35
    20ca:	93 e0       	ldi	r25, 0x03	; 3
    20cc:	0e 94 9b 05 	call	0xb36	; 0xb36 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    20d0:	f0 92 20 03 	sts	0x0320, r15
    20d4:	e0 92 1f 03 	sts	0x031F, r14
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    20d8:	10 93 22 03 	sts	0x0322, r17
    20dc:	00 93 21 03 	sts	0x0321, r16
    20e0:	eb 2c       	mov	r14, r11
    20e2:	bb 20       	and	r11, r11
    20e4:	11 f0       	breq	.+4      	; 0x20ea <xCoRoutineCreate+0x8a>
    20e6:	ee 24       	eor	r14, r14
    20e8:	e3 94       	inc	r14
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    20ea:	19 8e       	std	Y+25, r1	; 0x19
    20ec:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    20ee:	ee 8a       	std	Y+22, r14	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    20f0:	af 8a       	std	Y+23, r10	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    20f2:	fe 01       	movw	r30, r28
    20f4:	c1 92       	st	Z+, r12
    20f6:	d1 92       	st	Z+, r13
    20f8:	8f 01       	movw	r16, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    20fa:	cf 01       	movw	r24, r30
    20fc:	0e 94 ab 05 	call	0xb56	; 0xb56 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    2100:	ce 01       	movw	r24, r28
    2102:	0c 96       	adiw	r24, 0x0c	; 12
    2104:	0e 94 ab 05 	call	0xb56	; 0xb56 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    2108:	d9 87       	std	Y+9, r29	; 0x09
    210a:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    210c:	db 8b       	std	Y+19, r29	; 0x13
    210e:	ca 8b       	std	Y+18, r28	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    2110:	84 e0       	ldi	r24, 0x04	; 4
    2112:	90 e0       	ldi	r25, 0x00	; 0
    2114:	8e 19       	sub	r24, r14
    2116:	91 09       	sbc	r25, r1
    2118:	9d 87       	std	Y+13, r25	; 0x0d
    211a:	8c 87       	std	Y+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    211c:	9e 89       	ldd	r25, Y+22	; 0x16
    211e:	80 91 f4 02 	lds	r24, 0x02F4
    2122:	89 17       	cp	r24, r25
    2124:	10 f4       	brcc	.+4      	; 0x212a <xCoRoutineCreate+0xca>
    2126:	90 93 f4 02 	sts	0x02F4, r25
    212a:	89 e0       	ldi	r24, 0x09	; 9
    212c:	98 9f       	mul	r25, r24
    212e:	c0 01       	movw	r24, r0
    2130:	11 24       	eor	r1, r1
    2132:	85 50       	subi	r24, 0x05	; 5
    2134:	9d 4f       	sbci	r25, 0xFD	; 253
    2136:	b8 01       	movw	r22, r16
    2138:	0e 94 af 05 	call	0xb5e	; 0xb5e <vListInsertEnd>
    213c:	81 e0       	ldi	r24, 0x01	; 1
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
	}
	
	return xReturn;	
}
    213e:	df 91       	pop	r29
    2140:	cf 91       	pop	r28
    2142:	1f 91       	pop	r17
    2144:	0f 91       	pop	r16
    2146:	ff 90       	pop	r15
    2148:	ef 90       	pop	r14
    214a:	df 90       	pop	r13
    214c:	cf 90       	pop	r12
    214e:	bf 90       	pop	r11
    2150:	af 90       	pop	r10
    2152:	08 95       	ret

00002154 <vPortFree>:
{
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    2154:	08 95       	ret

00002156 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    2156:	10 92 2d 03 	sts	0x032D, r1
    215a:	10 92 2c 03 	sts	0x032C, r1
}
    215e:	08 95       	ret

00002160 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    2160:	28 eb       	ldi	r18, 0xB8	; 184
    2162:	3b e0       	ldi	r19, 0x0B	; 11
    2164:	80 91 2c 03 	lds	r24, 0x032C
    2168:	90 91 2d 03 	lds	r25, 0x032D
    216c:	28 1b       	sub	r18, r24
    216e:	39 0b       	sbc	r19, r25
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
}
    2170:	c9 01       	movw	r24, r18
    2172:	08 95       	ret

00002174 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2174:	0f 93       	push	r16
    2176:	1f 93       	push	r17
    2178:	cf 93       	push	r28
    217a:	df 93       	push	r29
    217c:	8c 01       	movw	r16, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    217e:	0e 94 1a 09 	call	0x1234	; 0x1234 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    2182:	80 91 2c 03 	lds	r24, 0x032C
    2186:	90 91 2d 03 	lds	r25, 0x032D
    218a:	98 01       	movw	r18, r16
    218c:	28 0f       	add	r18, r24
    218e:	39 1f       	adc	r19, r25
    2190:	4b e0       	ldi	r20, 0x0B	; 11
    2192:	28 3b       	cpi	r18, 0xB8	; 184
    2194:	34 07       	cpc	r19, r20
    2196:	58 f4       	brcc	.+22     	; 0x21ae <pvPortMalloc+0x3a>
    2198:	82 17       	cp	r24, r18
    219a:	93 07       	cpc	r25, r19
    219c:	40 f4       	brcc	.+16     	; 0x21ae <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    219e:	ec 01       	movw	r28, r24
    21a0:	c2 5d       	subi	r28, 0xD2	; 210
    21a2:	dc 4f       	sbci	r29, 0xFC	; 252
			xNextFreeByte += xWantedSize;			
    21a4:	30 93 2d 03 	sts	0x032D, r19
    21a8:	20 93 2c 03 	sts	0x032C, r18
    21ac:	02 c0       	rjmp	.+4      	; 0x21b2 <pvPortMalloc+0x3e>
    21ae:	c0 e0       	ldi	r28, 0x00	; 0
    21b0:	d0 e0       	ldi	r29, 0x00	; 0
		}	
	}
	xTaskResumeAll();
    21b2:	0e 94 b1 0a 	call	0x1562	; 0x1562 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
    21b6:	ce 01       	movw	r24, r28
    21b8:	df 91       	pop	r29
    21ba:	cf 91       	pop	r28
    21bc:	1f 91       	pop	r17
    21be:	0f 91       	pop	r16
    21c0:	08 95       	ret

000021c2 <prescaler_hex_to_value>:
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    21c2:	e8 2f       	mov	r30, r24
    21c4:	f0 e0       	ldi	r31, 0x00	; 0
    21c6:	e7 70       	andi	r30, 0x07	; 7
    21c8:	f0 70       	andi	r31, 0x00	; 0
    21ca:	ee 0f       	add	r30, r30
    21cc:	ff 1f       	adc	r31, r31
    21ce:	ee 5b       	subi	r30, 0xBE	; 190
    21d0:	fe 4f       	sbci	r31, 0xFE	; 254
    21d2:	25 91       	lpm	r18, Z+
    21d4:	34 91       	lpm	r19, Z+
}
    21d6:	c9 01       	movw	r24, r18
    21d8:	08 95       	ret

000021da <prescaler_hex_to_value_for_timer2>:
uint16_t prescaler_hex_to_value_for_timer2(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to Timer2PrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(Timer2PrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    21da:	e8 2f       	mov	r30, r24
    21dc:	f0 e0       	ldi	r31, 0x00	; 0
    21de:	e7 70       	andi	r30, 0x07	; 7
    21e0:	f0 70       	andi	r31, 0x00	; 0
    21e2:	ee 0f       	add	r30, r30
    21e4:	ff 1f       	adc	r31, r31
    21e6:	e2 5b       	subi	r30, 0xB2	; 178
    21e8:	fe 4f       	sbci	r31, 0xFE	; 254
    21ea:	25 91       	lpm	r18, Z+
    21ec:	34 91       	lpm	r19, Z+
}
    21ee:	c9 01       	movw	r24, r18
    21f0:	08 95       	ret

000021f2 <get_timer0_prescaler>:

uint16_t get_timer0_prescaler(void)
{
  return prescaler_hex_to_value(TCCR0B);
    21f2:	85 b5       	in	r24, 0x25	; 37
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    21f4:	e8 2f       	mov	r30, r24
    21f6:	f0 e0       	ldi	r31, 0x00	; 0
    21f8:	e7 70       	andi	r30, 0x07	; 7
    21fa:	f0 70       	andi	r31, 0x00	; 0
    21fc:	ee 0f       	add	r30, r30
    21fe:	ff 1f       	adc	r31, r31
    2200:	ee 5b       	subi	r30, 0xBE	; 190
    2202:	fe 4f       	sbci	r31, 0xFE	; 254
    2204:	25 91       	lpm	r18, Z+
    2206:	34 91       	lpm	r19, Z+
}

uint16_t get_timer0_prescaler(void)
{
  return prescaler_hex_to_value(TCCR0B);
}
    2208:	c9 01       	movw	r24, r18
    220a:	08 95       	ret

0000220c <get_timer1_prescaler>:
uint16_t get_timer1_prescaler(void)
{
  return prescaler_hex_to_value(TCCR1B);
    220c:	80 91 81 00 	lds	r24, 0x0081
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    2210:	e8 2f       	mov	r30, r24
    2212:	f0 e0       	ldi	r31, 0x00	; 0
    2214:	e7 70       	andi	r30, 0x07	; 7
    2216:	f0 70       	andi	r31, 0x00	; 0
    2218:	ee 0f       	add	r30, r30
    221a:	ff 1f       	adc	r31, r31
    221c:	ee 5b       	subi	r30, 0xBE	; 190
    221e:	fe 4f       	sbci	r31, 0xFE	; 254
    2220:	25 91       	lpm	r18, Z+
    2222:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR0B);
}
uint16_t get_timer1_prescaler(void)
{
  return prescaler_hex_to_value(TCCR1B);
}
    2224:	c9 01       	movw	r24, r18
    2226:	08 95       	ret

00002228 <get_timer2_prescaler>:
uint16_t get_timer2_prescaler(void)
{
  return prescaler_hex_to_value_for_timer2(TCCR2B);
    2228:	80 91 b1 00 	lds	r24, 0x00B1
uint16_t prescaler_hex_to_value_for_timer2(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to Timer2PrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(Timer2PrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    222c:	e8 2f       	mov	r30, r24
    222e:	f0 e0       	ldi	r31, 0x00	; 0
    2230:	e7 70       	andi	r30, 0x07	; 7
    2232:	f0 70       	andi	r31, 0x00	; 0
    2234:	ee 0f       	add	r30, r30
    2236:	ff 1f       	adc	r31, r31
    2238:	e2 5b       	subi	r30, 0xB2	; 178
    223a:	fe 4f       	sbci	r31, 0xFE	; 254
    223c:	25 91       	lpm	r18, Z+
    223e:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR1B);
}
uint16_t get_timer2_prescaler(void)
{
  return prescaler_hex_to_value_for_timer2(TCCR2B);
}
    2240:	c9 01       	movw	r24, r18
    2242:	08 95       	ret

00002244 <get_timer3_prescaler>:
uint16_t get_timer3_prescaler(void)
{
  return prescaler_hex_to_value(TCCR3B);
    2244:	80 91 91 00 	lds	r24, 0x0091
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    2248:	e8 2f       	mov	r30, r24
    224a:	f0 e0       	ldi	r31, 0x00	; 0
    224c:	e7 70       	andi	r30, 0x07	; 7
    224e:	f0 70       	andi	r31, 0x00	; 0
    2250:	ee 0f       	add	r30, r30
    2252:	ff 1f       	adc	r31, r31
    2254:	ee 5b       	subi	r30, 0xBE	; 190
    2256:	fe 4f       	sbci	r31, 0xFE	; 254
    2258:	25 91       	lpm	r18, Z+
    225a:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value_for_timer2(TCCR2B);
}
uint16_t get_timer3_prescaler(void)
{
  return prescaler_hex_to_value(TCCR3B);
}
    225c:	c9 01       	movw	r24, r18
    225e:	08 95       	ret

00002260 <get_timer4_prescaler>:
uint16_t get_timer4_prescaler(void)
{
  return prescaler_hex_to_value(TCCR4B);
    2260:	80 91 a1 00 	lds	r24, 0x00A1
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    2264:	e8 2f       	mov	r30, r24
    2266:	f0 e0       	ldi	r31, 0x00	; 0
    2268:	e7 70       	andi	r30, 0x07	; 7
    226a:	f0 70       	andi	r31, 0x00	; 0
    226c:	ee 0f       	add	r30, r30
    226e:	ff 1f       	adc	r31, r31
    2270:	ee 5b       	subi	r30, 0xBE	; 190
    2272:	fe 4f       	sbci	r31, 0xFE	; 254
    2274:	25 91       	lpm	r18, Z+
    2276:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR3B);
}
uint16_t get_timer4_prescaler(void)
{
  return prescaler_hex_to_value(TCCR4B);
}
    2278:	c9 01       	movw	r24, r18
    227a:	08 95       	ret

0000227c <get_timer5_prescaler>:
uint16_t get_timer5_prescaler(void)
{
  return prescaler_hex_to_value(TCCR5B);
    227c:	80 91 21 01 	lds	r24, 0x0121
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    2280:	e8 2f       	mov	r30, r24
    2282:	f0 e0       	ldi	r31, 0x00	; 0
    2284:	e7 70       	andi	r30, 0x07	; 7
    2286:	f0 70       	andi	r31, 0x00	; 0
    2288:	ee 0f       	add	r30, r30
    228a:	ff 1f       	adc	r31, r31
    228c:	ee 5b       	subi	r30, 0xBE	; 190
    228e:	fe 4f       	sbci	r31, 0xFE	; 254
    2290:	25 91       	lpm	r18, Z+
    2292:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR4B);
}
uint16_t get_timer5_prescaler(void)
{
  return prescaler_hex_to_value(TCCR5B);
}
    2294:	c9 01       	movw	r24, r18
    2296:	08 95       	ret

00002298 <get_timer0_overflow>:

const uint32_t get_timer0_overflow(void)
{
    return timer0_ovrflow_cnt;
    2298:	20 91 c6 11 	lds	r18, 0x11C6
    229c:	30 91 c7 11 	lds	r19, 0x11C7
    22a0:	40 91 c8 11 	lds	r20, 0x11C8
    22a4:	50 91 c9 11 	lds	r21, 0x11C9
}
    22a8:	b9 01       	movw	r22, r18
    22aa:	ca 01       	movw	r24, r20
    22ac:	08 95       	ret

000022ae <get_timer1_overflow>:
const uint32_t get_timer1_overflow(void)
{
    return timer1_ovrflow_cnt;
    22ae:	20 91 c2 11 	lds	r18, 0x11C2
    22b2:	30 91 c3 11 	lds	r19, 0x11C3
    22b6:	40 91 c4 11 	lds	r20, 0x11C4
    22ba:	50 91 c5 11 	lds	r21, 0x11C5
}
    22be:	b9 01       	movw	r22, r18
    22c0:	ca 01       	movw	r24, r20
    22c2:	08 95       	ret

000022c4 <get_timer2_overflow>:
const uint32_t get_timer2_overflow(void)
{
    return timer2_ovrflow_cnt;
    22c4:	20 91 ca 11 	lds	r18, 0x11CA
    22c8:	30 91 cb 11 	lds	r19, 0x11CB
    22cc:	40 91 cc 11 	lds	r20, 0x11CC
    22d0:	50 91 cd 11 	lds	r21, 0x11CD
}
    22d4:	b9 01       	movw	r22, r18
    22d6:	ca 01       	movw	r24, r20
    22d8:	08 95       	ret

000022da <get_timer3_overflow>:
const uint32_t get_timer3_overflow(void)
{
    return timer3_ovrflow_cnt;
    22da:	20 91 d2 11 	lds	r18, 0x11D2
    22de:	30 91 d3 11 	lds	r19, 0x11D3
    22e2:	40 91 d4 11 	lds	r20, 0x11D4
    22e6:	50 91 d5 11 	lds	r21, 0x11D5
}
    22ea:	b9 01       	movw	r22, r18
    22ec:	ca 01       	movw	r24, r20
    22ee:	08 95       	ret

000022f0 <get_timer4_overflow>:
const uint32_t get_timer4_overflow(void)
{
    return timer4_ovrflow_cnt;
    22f0:	20 91 be 11 	lds	r18, 0x11BE
    22f4:	30 91 bf 11 	lds	r19, 0x11BF
    22f8:	40 91 c0 11 	lds	r20, 0x11C0
    22fc:	50 91 c1 11 	lds	r21, 0x11C1
}
    2300:	b9 01       	movw	r22, r18
    2302:	ca 01       	movw	r24, r20
    2304:	08 95       	ret

00002306 <get_timer5_overflow>:
const uint32_t get_timer5_overflow(void)
{
    return timer5_ovrflow_cnt;
    2306:	20 91 d6 11 	lds	r18, 0x11D6
    230a:	30 91 d7 11 	lds	r19, 0x11D7
    230e:	40 91 d8 11 	lds	r20, 0x11D8
    2312:	50 91 d9 11 	lds	r21, 0x11D9
}
    2316:	b9 01       	movw	r22, r18
    2318:	ca 01       	movw	r24, r20
    231a:	08 95       	ret

0000231c <get_timer0_counter>:

const uint8_t get_timer0_counter(void)
{
    return TCNT0;
    231c:	86 b5       	in	r24, 0x26	; 38
}
    231e:	08 95       	ret

00002320 <get_timer1_counter>:
const uint16_t get_timer1_counter(void)
{
    return TCNT1;
    2320:	20 91 84 00 	lds	r18, 0x0084
    2324:	30 91 85 00 	lds	r19, 0x0085
}
    2328:	c9 01       	movw	r24, r18
    232a:	08 95       	ret

0000232c <get_timer2_counter>:
const uint8_t get_timer2_counter(void)
{
    return TCNT2;
    232c:	80 91 b2 00 	lds	r24, 0x00B2
}
    2330:	08 95       	ret

00002332 <get_timer3_counter>:
const uint16_t get_timer3_counter(void)
{
    return TCNT3;
    2332:	20 91 94 00 	lds	r18, 0x0094
    2336:	30 91 95 00 	lds	r19, 0x0095
}
    233a:	c9 01       	movw	r24, r18
    233c:	08 95       	ret

0000233e <get_timer4_counter>:
const uint16_t get_timer4_counter(void)
{
    return TCNT4;
    233e:	20 91 a4 00 	lds	r18, 0x00A4
    2342:	30 91 a5 00 	lds	r19, 0x00A5
}
    2346:	c9 01       	movw	r24, r18
    2348:	08 95       	ret

0000234a <get_timer5_counter>:
const uint16_t get_timer5_counter(void)
{
    return TCNT5;
    234a:	20 91 24 01 	lds	r18, 0x0124
    234e:	30 91 25 01 	lds	r19, 0x0125
}
    2352:	c9 01       	movw	r24, r18
    2354:	08 95       	ret

00002356 <reset_timer0>:

void reset_timer0(void)
{
    TCNT0 = timer0_ovrflow_cnt = 0;
    2356:	10 92 c6 11 	sts	0x11C6, r1
    235a:	10 92 c7 11 	sts	0x11C7, r1
    235e:	10 92 c8 11 	sts	0x11C8, r1
    2362:	10 92 c9 11 	sts	0x11C9, r1
    2366:	16 bc       	out	0x26, r1	; 38
}
    2368:	08 95       	ret

0000236a <reset_timer1>:
void reset_timer1(void)
{
    TCNT1 = timer1_ovrflow_cnt = 0;
    236a:	10 92 c2 11 	sts	0x11C2, r1
    236e:	10 92 c3 11 	sts	0x11C3, r1
    2372:	10 92 c4 11 	sts	0x11C4, r1
    2376:	10 92 c5 11 	sts	0x11C5, r1
    237a:	10 92 85 00 	sts	0x0085, r1
    237e:	10 92 84 00 	sts	0x0084, r1
}
    2382:	08 95       	ret

00002384 <reset_timer2>:
void reset_timer2(void)
{
    TCNT2 = timer2_ovrflow_cnt = 0;
    2384:	10 92 ca 11 	sts	0x11CA, r1
    2388:	10 92 cb 11 	sts	0x11CB, r1
    238c:	10 92 cc 11 	sts	0x11CC, r1
    2390:	10 92 cd 11 	sts	0x11CD, r1
    2394:	10 92 b2 00 	sts	0x00B2, r1
}
    2398:	08 95       	ret

0000239a <reset_timer3>:
void reset_timer3(void)
{
    TCNT3 = timer3_ovrflow_cnt = 0;
    239a:	10 92 d2 11 	sts	0x11D2, r1
    239e:	10 92 d3 11 	sts	0x11D3, r1
    23a2:	10 92 d4 11 	sts	0x11D4, r1
    23a6:	10 92 d5 11 	sts	0x11D5, r1
    23aa:	10 92 95 00 	sts	0x0095, r1
    23ae:	10 92 94 00 	sts	0x0094, r1
}
    23b2:	08 95       	ret

000023b4 <reset_timer4>:
void reset_timer4(void)
{
    TCNT4 = timer4_ovrflow_cnt = 0;
    23b4:	10 92 be 11 	sts	0x11BE, r1
    23b8:	10 92 bf 11 	sts	0x11BF, r1
    23bc:	10 92 c0 11 	sts	0x11C0, r1
    23c0:	10 92 c1 11 	sts	0x11C1, r1
    23c4:	10 92 a5 00 	sts	0x00A5, r1
    23c8:	10 92 a4 00 	sts	0x00A4, r1
}
    23cc:	08 95       	ret

000023ce <reset_timer5>:
void reset_timer5(void)
{
    TCNT5 = timer5_ovrflow_cnt = 0;
    23ce:	10 92 d6 11 	sts	0x11D6, r1
    23d2:	10 92 d7 11 	sts	0x11D7, r1
    23d6:	10 92 d8 11 	sts	0x11D8, r1
    23da:	10 92 d9 11 	sts	0x11D9, r1
    23de:	10 92 25 01 	sts	0x0125, r1
    23e2:	10 92 24 01 	sts	0x0124, r1
}
    23e6:	08 95       	ret

000023e8 <delay_us>:

	delay_loops = ((time_us * CYCLES_PER_US)+3) / 5; // +3 for rounding up (dirty) 

	// one loop takes 5 cpu cycles 
	for (i=0; i < delay_loops; i++) {};
}
    23e8:	08 95       	ret

000023ea <init_timer0>:

void init_timer0(const uint8_t prescaler)
{
  TCCR0B = prescaler;
    23ea:	85 bd       	out	0x25, r24	; 37
  TIMSK0 = _BV(TOIE0); // enable interrupts
    23ec:	81 e0       	ldi	r24, 0x01	; 1
    23ee:	80 93 6e 00 	sts	0x006E, r24
    return TCNT5;
}

void reset_timer0(void)
{
    TCNT0 = timer0_ovrflow_cnt = 0;
    23f2:	10 92 c6 11 	sts	0x11C6, r1
    23f6:	10 92 c7 11 	sts	0x11C7, r1
    23fa:	10 92 c8 11 	sts	0x11C8, r1
    23fe:	10 92 c9 11 	sts	0x11C9, r1
    2402:	16 bc       	out	0x26, r1	; 38
void init_timer0(const uint8_t prescaler)
{
  TCCR0B = prescaler;
  TIMSK0 = _BV(TOIE0); // enable interrupts
  reset_timer0(); // reset counter
}
    2404:	08 95       	ret

00002406 <init_timer1>:
void init_timer1(const uint8_t prescaler)
{
  TCCR1B = prescaler;
    2406:	80 93 81 00 	sts	0x0081, r24
  TIMSK1 = _BV(TOIE1); // enable interrupts
    240a:	81 e0       	ldi	r24, 0x01	; 1
    240c:	80 93 6f 00 	sts	0x006F, r24
{
    TCNT0 = timer0_ovrflow_cnt = 0;
}
void reset_timer1(void)
{
    TCNT1 = timer1_ovrflow_cnt = 0;
    2410:	10 92 c2 11 	sts	0x11C2, r1
    2414:	10 92 c3 11 	sts	0x11C3, r1
    2418:	10 92 c4 11 	sts	0x11C4, r1
    241c:	10 92 c5 11 	sts	0x11C5, r1
    2420:	10 92 85 00 	sts	0x0085, r1
    2424:	10 92 84 00 	sts	0x0084, r1
void init_timer1(const uint8_t prescaler)
{
  TCCR1B = prescaler;
  TIMSK1 = _BV(TOIE1); // enable interrupts
  reset_timer1(); // reset counter
}
    2428:	08 95       	ret

0000242a <init_timer2>:
void init_timer2(const uint8_t prescaler)
{
  TCCR2B = prescaler;
    242a:	80 93 b1 00 	sts	0x00B1, r24
  TIMSK2 = _BV(TOIE2); // enable interrupts
    242e:	81 e0       	ldi	r24, 0x01	; 1
    2430:	80 93 70 00 	sts	0x0070, r24
{
    TCNT1 = timer1_ovrflow_cnt = 0;
}
void reset_timer2(void)
{
    TCNT2 = timer2_ovrflow_cnt = 0;
    2434:	10 92 ca 11 	sts	0x11CA, r1
    2438:	10 92 cb 11 	sts	0x11CB, r1
    243c:	10 92 cc 11 	sts	0x11CC, r1
    2440:	10 92 cd 11 	sts	0x11CD, r1
    2444:	10 92 b2 00 	sts	0x00B2, r1
void init_timer2(const uint8_t prescaler)
{
  TCCR2B = prescaler;
  TIMSK2 = _BV(TOIE2); // enable interrupts
  reset_timer2(); // reset counter
}
    2448:	08 95       	ret

0000244a <init_timer3>:
void init_timer3(const uint8_t prescaler)
{
  TCCR3B = prescaler;
    244a:	80 93 91 00 	sts	0x0091, r24
  TIMSK3 = _BV(TOIE3); // enable interrupts
    244e:	81 e0       	ldi	r24, 0x01	; 1
    2450:	80 93 71 00 	sts	0x0071, r24
{
    TCNT2 = timer2_ovrflow_cnt = 0;
}
void reset_timer3(void)
{
    TCNT3 = timer3_ovrflow_cnt = 0;
    2454:	10 92 d2 11 	sts	0x11D2, r1
    2458:	10 92 d3 11 	sts	0x11D3, r1
    245c:	10 92 d4 11 	sts	0x11D4, r1
    2460:	10 92 d5 11 	sts	0x11D5, r1
    2464:	10 92 95 00 	sts	0x0095, r1
    2468:	10 92 94 00 	sts	0x0094, r1
void init_timer3(const uint8_t prescaler)
{
  TCCR3B = prescaler;
  TIMSK3 = _BV(TOIE3); // enable interrupts
  reset_timer3(); // reset counter
}
    246c:	08 95       	ret

0000246e <init_timer4>:
void init_timer4(const uint8_t prescaler)
{
  TCCR4B = prescaler;
    246e:	80 93 a1 00 	sts	0x00A1, r24
  TIMSK4 = _BV(TOIE4); // enable interrupts
    2472:	81 e0       	ldi	r24, 0x01	; 1
    2474:	80 93 72 00 	sts	0x0072, r24
{
    TCNT3 = timer3_ovrflow_cnt = 0;
}
void reset_timer4(void)
{
    TCNT4 = timer4_ovrflow_cnt = 0;
    2478:	10 92 be 11 	sts	0x11BE, r1
    247c:	10 92 bf 11 	sts	0x11BF, r1
    2480:	10 92 c0 11 	sts	0x11C0, r1
    2484:	10 92 c1 11 	sts	0x11C1, r1
    2488:	10 92 a5 00 	sts	0x00A5, r1
    248c:	10 92 a4 00 	sts	0x00A4, r1
void init_timer4(const uint8_t prescaler)
{
  TCCR4B = prescaler;
  TIMSK4 = _BV(TOIE4); // enable interrupts
  reset_timer4(); // reset counter
}
    2490:	08 95       	ret

00002492 <init_timer5>:
void init_timer5(const uint8_t prescaler)
{
  TCCR5B = prescaler;
    2492:	80 93 21 01 	sts	0x0121, r24
  TIMSK5 = _BV(TOIE5); // enable interrupts
    2496:	81 e0       	ldi	r24, 0x01	; 1
    2498:	80 93 73 00 	sts	0x0073, r24
{
    TCNT4 = timer4_ovrflow_cnt = 0;
}
void reset_timer5(void)
{
    TCNT5 = timer5_ovrflow_cnt = 0;
    249c:	10 92 d6 11 	sts	0x11D6, r1
    24a0:	10 92 d7 11 	sts	0x11D7, r1
    24a4:	10 92 d8 11 	sts	0x11D8, r1
    24a8:	10 92 d9 11 	sts	0x11D9, r1
    24ac:	10 92 25 01 	sts	0x0125, r1
    24b0:	10 92 24 01 	sts	0x0124, r1
void init_timer5(const uint8_t prescaler)
{
  TCCR5B = prescaler;
  TIMSK5 = _BV(TOIE5); // enable interrupts
  reset_timer5(); // reset counter
}
    24b4:	08 95       	ret

000024b6 <timer_attach>:

void timer_attach(TimerInterrupt_t interrupt, void (*user_func)(void) )
{
  // set the interrupt function to run
  // the supplied user's function
  TimerIntFunc[interrupt] = user_func;
    24b6:	e8 2f       	mov	r30, r24
    24b8:	f0 e0       	ldi	r31, 0x00	; 0
    24ba:	ee 0f       	add	r30, r30
    24bc:	ff 1f       	adc	r31, r31
    24be:	ea 51       	subi	r30, 0x1A	; 26
    24c0:	f1 4f       	sbci	r31, 0xF1	; 241
    24c2:	71 83       	std	Z+1, r23	; 0x01
    24c4:	60 83       	st	Z, r22
}
    24c6:	08 95       	ret

000024c8 <timer_detach>:

void timer_detach(TimerInterrupt_t interrupt)
{
  // clear the user defined interrupt function
  TimerIntFunc[interrupt] = NULL;
    24c8:	e8 2f       	mov	r30, r24
    24ca:	f0 e0       	ldi	r31, 0x00	; 0
    24cc:	ee 0f       	add	r30, r30
    24ce:	ff 1f       	adc	r31, r31
    24d0:	ea 51       	subi	r30, 0x1A	; 26
    24d2:	f1 4f       	sbci	r31, 0xF1	; 241
    24d4:	11 82       	std	Z+1, r1	; 0x01
    24d6:	10 82       	st	Z, r1
}
    24d8:	08 95       	ret

000024da <_delay_loop_2>:

void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    24da:	01 97       	sbiw	r24, 0x01	; 1
    24dc:	f1 f7       	brne	.-4      	; 0x24da <_delay_loop_2>
		"1: sbiw %0,1" "\n\t"
		"brne 1b"
		: "=w" (__count)
		: "0" (__count)
	);
}
    24de:	08 95       	ret

000024e0 <sleep>:

void sleep(uint16_t time_ms)
{
    24e0:	af 92       	push	r10
    24e2:	bf 92       	push	r11
    24e4:	cf 92       	push	r12
    24e6:	df 92       	push	r13
    24e8:	ef 92       	push	r14
    24ea:	ff 92       	push	r15
    24ec:	0f 93       	push	r16
    24ee:	1f 93       	push	r17
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * time_ms;
    24f0:	a0 e0       	ldi	r26, 0x00	; 0
    24f2:	b0 e0       	ldi	r27, 0x00	; 0
    24f4:	bc 01       	movw	r22, r24
    24f6:	cd 01       	movw	r24, r26
    24f8:	0e 94 5b 26 	call	0x4cb6	; 0x4cb6 <__floatunsisf>
    24fc:	5b 01       	movw	r10, r22
    24fe:	6c 01       	movw	r12, r24
    2500:	20 e0       	ldi	r18, 0x00	; 0
    2502:	30 e0       	ldi	r19, 0x00	; 0
    2504:	4a e7       	ldi	r20, 0x7A	; 122
    2506:	55 e4       	ldi	r21, 0x45	; 69
    2508:	0e 94 11 27 	call	0x4e22	; 0x4e22 <__mulsf3>
    250c:	7b 01       	movw	r14, r22
    250e:	8c 01       	movw	r16, r24
	if (__tmp < 1.0)
    2510:	20 e0       	ldi	r18, 0x00	; 0
    2512:	30 e0       	ldi	r19, 0x00	; 0
    2514:	40 e8       	ldi	r20, 0x80	; 128
    2516:	5f e3       	ldi	r21, 0x3F	; 63
    2518:	0e 94 c3 25 	call	0x4b86	; 0x4b86 <__cmpsf2>
    251c:	88 23       	and	r24, r24
    251e:	1c f4       	brge	.+6      	; 0x2526 <sleep+0x46>
    2520:	61 e0       	ldi	r22, 0x01	; 1
    2522:	70 e0       	ldi	r23, 0x00	; 0
    2524:	24 c0       	rjmp	.+72     	; 0x256e <sleep+0x8e>
		__ticks = 1;
	else if (__tmp > 65535)
    2526:	c8 01       	movw	r24, r16
    2528:	b7 01       	movw	r22, r14
    252a:	20 e0       	ldi	r18, 0x00	; 0
    252c:	3f ef       	ldi	r19, 0xFF	; 255
    252e:	4f e7       	ldi	r20, 0x7F	; 127
    2530:	57 e4       	ldi	r21, 0x47	; 71
    2532:	0e 94 0d 27 	call	0x4e1a	; 0x4e1a <__gesf2>
    2536:	18 16       	cp	r1, r24
    2538:	b4 f4       	brge	.+44     	; 0x2566 <sleep+0x86>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (time_ms * 10.0);
    253a:	c6 01       	movw	r24, r12
    253c:	b5 01       	movw	r22, r10
    253e:	20 e0       	ldi	r18, 0x00	; 0
    2540:	30 e0       	ldi	r19, 0x00	; 0
    2542:	40 e2       	ldi	r20, 0x20	; 32
    2544:	51 e4       	ldi	r21, 0x41	; 65
    2546:	0e 94 11 27 	call	0x4e22	; 0x4e22 <__mulsf3>
    254a:	0e 94 2f 26 	call	0x4c5e	; 0x4c5e <__fixunssfsi>
}

void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    254e:	80 e9       	ldi	r24, 0x90	; 144
    2550:	91 e0       	ldi	r25, 0x01	; 1
    2552:	05 c0       	rjmp	.+10     	; 0x255e <sleep+0x7e>
    2554:	fc 01       	movw	r30, r24
    2556:	31 97       	sbiw	r30, 0x01	; 1
    2558:	f1 f7       	brne	.-4      	; 0x2556 <sleep+0x76>
		__ticks = (uint16_t) (time_ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    255a:	61 50       	subi	r22, 0x01	; 1
    255c:	70 40       	sbci	r23, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (time_ms * 10.0);
		while(__ticks)
    255e:	61 15       	cp	r22, r1
    2560:	71 05       	cpc	r23, r1
    2562:	c1 f7       	brne	.-16     	; 0x2554 <sleep+0x74>
    2564:	07 c0       	rjmp	.+14     	; 0x2574 <sleep+0x94>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2566:	c8 01       	movw	r24, r16
    2568:	b7 01       	movw	r22, r14
    256a:	0e 94 2f 26 	call	0x4c5e	; 0x4c5e <__fixunssfsi>
}

void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    256e:	cb 01       	movw	r24, r22
    2570:	01 97       	sbiw	r24, 0x01	; 1
    2572:	f1 f7       	brne	.-4      	; 0x2570 <sleep+0x90>
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
	_delay_loop_2(__ticks);
}
    2574:	1f 91       	pop	r17
    2576:	0f 91       	pop	r16
    2578:	ff 90       	pop	r15
    257a:	ef 90       	pop	r14
    257c:	df 90       	pop	r13
    257e:	cf 90       	pop	r12
    2580:	bf 90       	pop	r11
    2582:	af 90       	pop	r10
    2584:	08 95       	ret

00002586 <__vector_23>:
    }
  }
}*/

ISR(TIMER0_OVF_vect) 
{
    2586:	1f 92       	push	r1
    2588:	0f 92       	push	r0
    258a:	0f b6       	in	r0, 0x3f	; 63
    258c:	0f 92       	push	r0
    258e:	11 24       	eor	r1, r1
    2590:	2f 93       	push	r18
    2592:	3f 93       	push	r19
    2594:	4f 93       	push	r20
    2596:	5f 93       	push	r21
    2598:	6f 93       	push	r22
    259a:	7f 93       	push	r23
    259c:	8f 93       	push	r24
    259e:	9f 93       	push	r25
    25a0:	af 93       	push	r26
    25a2:	bf 93       	push	r27
    25a4:	ef 93       	push	r30
    25a6:	ff 93       	push	r31
  timer0_ovrflow_cnt++;
    25a8:	80 91 c6 11 	lds	r24, 0x11C6
    25ac:	90 91 c7 11 	lds	r25, 0x11C7
    25b0:	a0 91 c8 11 	lds	r26, 0x11C8
    25b4:	b0 91 c9 11 	lds	r27, 0x11C9
    25b8:	01 96       	adiw	r24, 0x01	; 1
    25ba:	a1 1d       	adc	r26, r1
    25bc:	b1 1d       	adc	r27, r1
    25be:	80 93 c6 11 	sts	0x11C6, r24
    25c2:	90 93 c7 11 	sts	0x11C7, r25
    25c6:	a0 93 c8 11 	sts	0x11C8, r26
    25ca:	b0 93 c9 11 	sts	0x11C9, r27
  timer_sleep_cnt++;
    25ce:	80 91 ce 11 	lds	r24, 0x11CE
    25d2:	90 91 cf 11 	lds	r25, 0x11CF
    25d6:	a0 91 d0 11 	lds	r26, 0x11D0
    25da:	b0 91 d1 11 	lds	r27, 0x11D1
    25de:	01 96       	adiw	r24, 0x01	; 1
    25e0:	a1 1d       	adc	r26, r1
    25e2:	b1 1d       	adc	r27, r1
    25e4:	80 93 ce 11 	sts	0x11CE, r24
    25e8:	90 93 cf 11 	sts	0x11CF, r25
    25ec:	a0 93 d0 11 	sts	0x11D0, r26
    25f0:	b0 93 d1 11 	sts	0x11D1, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER0_OVF_interrupt);
    25f4:	80 91 ea 0e 	lds	r24, 0x0EEA
    25f8:	90 91 eb 0e 	lds	r25, 0x0EEB
    25fc:	89 2b       	or	r24, r25
    25fe:	29 f0       	breq	.+10     	; 0x260a <__vector_23+0x84>
    2600:	e0 91 ea 0e 	lds	r30, 0x0EEA
    2604:	f0 91 eb 0e 	lds	r31, 0x0EEB
    2608:	09 95       	icall
}
    260a:	ff 91       	pop	r31
    260c:	ef 91       	pop	r30
    260e:	bf 91       	pop	r27
    2610:	af 91       	pop	r26
    2612:	9f 91       	pop	r25
    2614:	8f 91       	pop	r24
    2616:	7f 91       	pop	r23
    2618:	6f 91       	pop	r22
    261a:	5f 91       	pop	r21
    261c:	4f 91       	pop	r20
    261e:	3f 91       	pop	r19
    2620:	2f 91       	pop	r18
    2622:	0f 90       	pop	r0
    2624:	0f be       	out	0x3f, r0	; 63
    2626:	0f 90       	pop	r0
    2628:	1f 90       	pop	r1
    262a:	18 95       	reti

0000262c <__vector_20>:
ISR(TIMER1_OVF_vect) 
{
    262c:	1f 92       	push	r1
    262e:	0f 92       	push	r0
    2630:	0f b6       	in	r0, 0x3f	; 63
    2632:	0f 92       	push	r0
    2634:	11 24       	eor	r1, r1
    2636:	2f 93       	push	r18
    2638:	3f 93       	push	r19
    263a:	4f 93       	push	r20
    263c:	5f 93       	push	r21
    263e:	6f 93       	push	r22
    2640:	7f 93       	push	r23
    2642:	8f 93       	push	r24
    2644:	9f 93       	push	r25
    2646:	af 93       	push	r26
    2648:	bf 93       	push	r27
    264a:	ef 93       	push	r30
    264c:	ff 93       	push	r31
  timer1_ovrflow_cnt++;
    264e:	80 91 c2 11 	lds	r24, 0x11C2
    2652:	90 91 c3 11 	lds	r25, 0x11C3
    2656:	a0 91 c4 11 	lds	r26, 0x11C4
    265a:	b0 91 c5 11 	lds	r27, 0x11C5
    265e:	01 96       	adiw	r24, 0x01	; 1
    2660:	a1 1d       	adc	r26, r1
    2662:	b1 1d       	adc	r27, r1
    2664:	80 93 c2 11 	sts	0x11C2, r24
    2668:	90 93 c3 11 	sts	0x11C3, r25
    266c:	a0 93 c4 11 	sts	0x11C4, r26
    2670:	b0 93 c5 11 	sts	0x11C5, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER1_OVF_interrupt);
    2674:	80 91 f4 0e 	lds	r24, 0x0EF4
    2678:	90 91 f5 0e 	lds	r25, 0x0EF5
    267c:	89 2b       	or	r24, r25
    267e:	29 f0       	breq	.+10     	; 0x268a <__vector_20+0x5e>
    2680:	e0 91 f4 0e 	lds	r30, 0x0EF4
    2684:	f0 91 f5 0e 	lds	r31, 0x0EF5
    2688:	09 95       	icall
}
    268a:	ff 91       	pop	r31
    268c:	ef 91       	pop	r30
    268e:	bf 91       	pop	r27
    2690:	af 91       	pop	r26
    2692:	9f 91       	pop	r25
    2694:	8f 91       	pop	r24
    2696:	7f 91       	pop	r23
    2698:	6f 91       	pop	r22
    269a:	5f 91       	pop	r21
    269c:	4f 91       	pop	r20
    269e:	3f 91       	pop	r19
    26a0:	2f 91       	pop	r18
    26a2:	0f 90       	pop	r0
    26a4:	0f be       	out	0x3f, r0	; 63
    26a6:	0f 90       	pop	r0
    26a8:	1f 90       	pop	r1
    26aa:	18 95       	reti

000026ac <__vector_15>:
ISR(TIMER2_OVF_vect) 
{
    26ac:	1f 92       	push	r1
    26ae:	0f 92       	push	r0
    26b0:	0f b6       	in	r0, 0x3f	; 63
    26b2:	0f 92       	push	r0
    26b4:	11 24       	eor	r1, r1
    26b6:	2f 93       	push	r18
    26b8:	3f 93       	push	r19
    26ba:	4f 93       	push	r20
    26bc:	5f 93       	push	r21
    26be:	6f 93       	push	r22
    26c0:	7f 93       	push	r23
    26c2:	8f 93       	push	r24
    26c4:	9f 93       	push	r25
    26c6:	af 93       	push	r26
    26c8:	bf 93       	push	r27
    26ca:	ef 93       	push	r30
    26cc:	ff 93       	push	r31
  timer2_ovrflow_cnt++;
    26ce:	80 91 ca 11 	lds	r24, 0x11CA
    26d2:	90 91 cb 11 	lds	r25, 0x11CB
    26d6:	a0 91 cc 11 	lds	r26, 0x11CC
    26da:	b0 91 cd 11 	lds	r27, 0x11CD
    26de:	01 96       	adiw	r24, 0x01	; 1
    26e0:	a1 1d       	adc	r26, r1
    26e2:	b1 1d       	adc	r27, r1
    26e4:	80 93 ca 11 	sts	0x11CA, r24
    26e8:	90 93 cb 11 	sts	0x11CB, r25
    26ec:	a0 93 cc 11 	sts	0x11CC, r26
    26f0:	b0 93 cd 11 	sts	0x11CD, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER2_OVF_interrupt);
    26f4:	80 91 fa 0e 	lds	r24, 0x0EFA
    26f8:	90 91 fb 0e 	lds	r25, 0x0EFB
    26fc:	89 2b       	or	r24, r25
    26fe:	29 f0       	breq	.+10     	; 0x270a <__vector_15+0x5e>
    2700:	e0 91 fa 0e 	lds	r30, 0x0EFA
    2704:	f0 91 fb 0e 	lds	r31, 0x0EFB
    2708:	09 95       	icall
}
    270a:	ff 91       	pop	r31
    270c:	ef 91       	pop	r30
    270e:	bf 91       	pop	r27
    2710:	af 91       	pop	r26
    2712:	9f 91       	pop	r25
    2714:	8f 91       	pop	r24
    2716:	7f 91       	pop	r23
    2718:	6f 91       	pop	r22
    271a:	5f 91       	pop	r21
    271c:	4f 91       	pop	r20
    271e:	3f 91       	pop	r19
    2720:	2f 91       	pop	r18
    2722:	0f 90       	pop	r0
    2724:	0f be       	out	0x3f, r0	; 63
    2726:	0f 90       	pop	r0
    2728:	1f 90       	pop	r1
    272a:	18 95       	reti

0000272c <__vector_35>:
ISR(TIMER3_OVF_vect) 
{
    272c:	1f 92       	push	r1
    272e:	0f 92       	push	r0
    2730:	0f b6       	in	r0, 0x3f	; 63
    2732:	0f 92       	push	r0
    2734:	11 24       	eor	r1, r1
    2736:	2f 93       	push	r18
    2738:	3f 93       	push	r19
    273a:	4f 93       	push	r20
    273c:	5f 93       	push	r21
    273e:	6f 93       	push	r22
    2740:	7f 93       	push	r23
    2742:	8f 93       	push	r24
    2744:	9f 93       	push	r25
    2746:	af 93       	push	r26
    2748:	bf 93       	push	r27
    274a:	ef 93       	push	r30
    274c:	ff 93       	push	r31
  timer3_ovrflow_cnt++;
    274e:	80 91 d2 11 	lds	r24, 0x11D2
    2752:	90 91 d3 11 	lds	r25, 0x11D3
    2756:	a0 91 d4 11 	lds	r26, 0x11D4
    275a:	b0 91 d5 11 	lds	r27, 0x11D5
    275e:	01 96       	adiw	r24, 0x01	; 1
    2760:	a1 1d       	adc	r26, r1
    2762:	b1 1d       	adc	r27, r1
    2764:	80 93 d2 11 	sts	0x11D2, r24
    2768:	90 93 d3 11 	sts	0x11D3, r25
    276c:	a0 93 d4 11 	sts	0x11D4, r26
    2770:	b0 93 d5 11 	sts	0x11D5, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER3_OVF_interrupt);
    2774:	80 91 04 0f 	lds	r24, 0x0F04
    2778:	90 91 05 0f 	lds	r25, 0x0F05
    277c:	89 2b       	or	r24, r25
    277e:	29 f0       	breq	.+10     	; 0x278a <__vector_35+0x5e>
    2780:	e0 91 04 0f 	lds	r30, 0x0F04
    2784:	f0 91 05 0f 	lds	r31, 0x0F05
    2788:	09 95       	icall
}
    278a:	ff 91       	pop	r31
    278c:	ef 91       	pop	r30
    278e:	bf 91       	pop	r27
    2790:	af 91       	pop	r26
    2792:	9f 91       	pop	r25
    2794:	8f 91       	pop	r24
    2796:	7f 91       	pop	r23
    2798:	6f 91       	pop	r22
    279a:	5f 91       	pop	r21
    279c:	4f 91       	pop	r20
    279e:	3f 91       	pop	r19
    27a0:	2f 91       	pop	r18
    27a2:	0f 90       	pop	r0
    27a4:	0f be       	out	0x3f, r0	; 63
    27a6:	0f 90       	pop	r0
    27a8:	1f 90       	pop	r1
    27aa:	18 95       	reti

000027ac <__vector_45>:
ISR(TIMER4_OVF_vect) 
{
    27ac:	1f 92       	push	r1
    27ae:	0f 92       	push	r0
    27b0:	0f b6       	in	r0, 0x3f	; 63
    27b2:	0f 92       	push	r0
    27b4:	11 24       	eor	r1, r1
    27b6:	2f 93       	push	r18
    27b8:	3f 93       	push	r19
    27ba:	4f 93       	push	r20
    27bc:	5f 93       	push	r21
    27be:	6f 93       	push	r22
    27c0:	7f 93       	push	r23
    27c2:	8f 93       	push	r24
    27c4:	9f 93       	push	r25
    27c6:	af 93       	push	r26
    27c8:	bf 93       	push	r27
    27ca:	ef 93       	push	r30
    27cc:	ff 93       	push	r31
  timer4_ovrflow_cnt++;
    27ce:	80 91 be 11 	lds	r24, 0x11BE
    27d2:	90 91 bf 11 	lds	r25, 0x11BF
    27d6:	a0 91 c0 11 	lds	r26, 0x11C0
    27da:	b0 91 c1 11 	lds	r27, 0x11C1
    27de:	01 96       	adiw	r24, 0x01	; 1
    27e0:	a1 1d       	adc	r26, r1
    27e2:	b1 1d       	adc	r27, r1
    27e4:	80 93 be 11 	sts	0x11BE, r24
    27e8:	90 93 bf 11 	sts	0x11BF, r25
    27ec:	a0 93 c0 11 	sts	0x11C0, r26
    27f0:	b0 93 c1 11 	sts	0x11C1, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER4_OVF_interrupt);
    27f4:	80 91 0e 0f 	lds	r24, 0x0F0E
    27f8:	90 91 0f 0f 	lds	r25, 0x0F0F
    27fc:	89 2b       	or	r24, r25
    27fe:	29 f0       	breq	.+10     	; 0x280a <__vector_45+0x5e>
    2800:	e0 91 0e 0f 	lds	r30, 0x0F0E
    2804:	f0 91 0f 0f 	lds	r31, 0x0F0F
    2808:	09 95       	icall
}
    280a:	ff 91       	pop	r31
    280c:	ef 91       	pop	r30
    280e:	bf 91       	pop	r27
    2810:	af 91       	pop	r26
    2812:	9f 91       	pop	r25
    2814:	8f 91       	pop	r24
    2816:	7f 91       	pop	r23
    2818:	6f 91       	pop	r22
    281a:	5f 91       	pop	r21
    281c:	4f 91       	pop	r20
    281e:	3f 91       	pop	r19
    2820:	2f 91       	pop	r18
    2822:	0f 90       	pop	r0
    2824:	0f be       	out	0x3f, r0	; 63
    2826:	0f 90       	pop	r0
    2828:	1f 90       	pop	r1
    282a:	18 95       	reti

0000282c <__vector_50>:
ISR(TIMER5_OVF_vect) 
{
    282c:	1f 92       	push	r1
    282e:	0f 92       	push	r0
    2830:	0f b6       	in	r0, 0x3f	; 63
    2832:	0f 92       	push	r0
    2834:	11 24       	eor	r1, r1
    2836:	2f 93       	push	r18
    2838:	3f 93       	push	r19
    283a:	4f 93       	push	r20
    283c:	5f 93       	push	r21
    283e:	6f 93       	push	r22
    2840:	7f 93       	push	r23
    2842:	8f 93       	push	r24
    2844:	9f 93       	push	r25
    2846:	af 93       	push	r26
    2848:	bf 93       	push	r27
    284a:	ef 93       	push	r30
    284c:	ff 93       	push	r31
  timer5_ovrflow_cnt++;
    284e:	80 91 d6 11 	lds	r24, 0x11D6
    2852:	90 91 d7 11 	lds	r25, 0x11D7
    2856:	a0 91 d8 11 	lds	r26, 0x11D8
    285a:	b0 91 d9 11 	lds	r27, 0x11D9
    285e:	01 96       	adiw	r24, 0x01	; 1
    2860:	a1 1d       	adc	r26, r1
    2862:	b1 1d       	adc	r27, r1
    2864:	80 93 d6 11 	sts	0x11D6, r24
    2868:	90 93 d7 11 	sts	0x11D7, r25
    286c:	a0 93 d8 11 	sts	0x11D8, r26
    2870:	b0 93 d9 11 	sts	0x11D9, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER5_OVF_interrupt);
    2874:	80 91 18 0f 	lds	r24, 0x0F18
    2878:	90 91 19 0f 	lds	r25, 0x0F19
    287c:	89 2b       	or	r24, r25
    287e:	29 f0       	breq	.+10     	; 0x288a <__vector_50+0x5e>
    2880:	e0 91 18 0f 	lds	r30, 0x0F18
    2884:	f0 91 19 0f 	lds	r31, 0x0F19
    2888:	09 95       	icall
}
    288a:	ff 91       	pop	r31
    288c:	ef 91       	pop	r30
    288e:	bf 91       	pop	r27
    2890:	af 91       	pop	r26
    2892:	9f 91       	pop	r25
    2894:	8f 91       	pop	r24
    2896:	7f 91       	pop	r23
    2898:	6f 91       	pop	r22
    289a:	5f 91       	pop	r21
    289c:	4f 91       	pop	r20
    289e:	3f 91       	pop	r19
    28a0:	2f 91       	pop	r18
    28a2:	0f 90       	pop	r0
    28a4:	0f be       	out	0x3f, r0	; 63
    28a6:	0f 90       	pop	r0
    28a8:	1f 90       	pop	r1
    28aa:	18 95       	reti

000028ac <__vector_21>:
ISR(TIMER0_COMPA_vect)
{
    28ac:	1f 92       	push	r1
    28ae:	0f 92       	push	r0
    28b0:	0f b6       	in	r0, 0x3f	; 63
    28b2:	0f 92       	push	r0
    28b4:	11 24       	eor	r1, r1
    28b6:	2f 93       	push	r18
    28b8:	3f 93       	push	r19
    28ba:	4f 93       	push	r20
    28bc:	5f 93       	push	r21
    28be:	6f 93       	push	r22
    28c0:	7f 93       	push	r23
    28c2:	8f 93       	push	r24
    28c4:	9f 93       	push	r25
    28c6:	af 93       	push	r26
    28c8:	bf 93       	push	r27
    28ca:	ef 93       	push	r30
    28cc:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER0_COMPA_interrupt);
    28ce:	80 91 e6 0e 	lds	r24, 0x0EE6
    28d2:	90 91 e7 0e 	lds	r25, 0x0EE7
    28d6:	89 2b       	or	r24, r25
    28d8:	29 f0       	breq	.+10     	; 0x28e4 <__vector_21+0x38>
    28da:	e0 91 e6 0e 	lds	r30, 0x0EE6
    28de:	f0 91 e7 0e 	lds	r31, 0x0EE7
    28e2:	09 95       	icall
}
    28e4:	ff 91       	pop	r31
    28e6:	ef 91       	pop	r30
    28e8:	bf 91       	pop	r27
    28ea:	af 91       	pop	r26
    28ec:	9f 91       	pop	r25
    28ee:	8f 91       	pop	r24
    28f0:	7f 91       	pop	r23
    28f2:	6f 91       	pop	r22
    28f4:	5f 91       	pop	r21
    28f6:	4f 91       	pop	r20
    28f8:	3f 91       	pop	r19
    28fa:	2f 91       	pop	r18
    28fc:	0f 90       	pop	r0
    28fe:	0f be       	out	0x3f, r0	; 63
    2900:	0f 90       	pop	r0
    2902:	1f 90       	pop	r1
    2904:	18 95       	reti

00002906 <__vector_22>:
ISR(TIMER0_COMPB_vect)
{
    2906:	1f 92       	push	r1
    2908:	0f 92       	push	r0
    290a:	0f b6       	in	r0, 0x3f	; 63
    290c:	0f 92       	push	r0
    290e:	11 24       	eor	r1, r1
    2910:	2f 93       	push	r18
    2912:	3f 93       	push	r19
    2914:	4f 93       	push	r20
    2916:	5f 93       	push	r21
    2918:	6f 93       	push	r22
    291a:	7f 93       	push	r23
    291c:	8f 93       	push	r24
    291e:	9f 93       	push	r25
    2920:	af 93       	push	r26
    2922:	bf 93       	push	r27
    2924:	ef 93       	push	r30
    2926:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER0_COMPB_interrupt);
    2928:	80 91 e8 0e 	lds	r24, 0x0EE8
    292c:	90 91 e9 0e 	lds	r25, 0x0EE9
    2930:	89 2b       	or	r24, r25
    2932:	29 f0       	breq	.+10     	; 0x293e <__vector_22+0x38>
    2934:	e0 91 e8 0e 	lds	r30, 0x0EE8
    2938:	f0 91 e9 0e 	lds	r31, 0x0EE9
    293c:	09 95       	icall
}
    293e:	ff 91       	pop	r31
    2940:	ef 91       	pop	r30
    2942:	bf 91       	pop	r27
    2944:	af 91       	pop	r26
    2946:	9f 91       	pop	r25
    2948:	8f 91       	pop	r24
    294a:	7f 91       	pop	r23
    294c:	6f 91       	pop	r22
    294e:	5f 91       	pop	r21
    2950:	4f 91       	pop	r20
    2952:	3f 91       	pop	r19
    2954:	2f 91       	pop	r18
    2956:	0f 90       	pop	r0
    2958:	0f be       	out	0x3f, r0	; 63
    295a:	0f 90       	pop	r0
    295c:	1f 90       	pop	r1
    295e:	18 95       	reti

00002960 <__vector_16>:
ISR(TIMER1_CAPT_vect)
{
    2960:	1f 92       	push	r1
    2962:	0f 92       	push	r0
    2964:	0f b6       	in	r0, 0x3f	; 63
    2966:	0f 92       	push	r0
    2968:	11 24       	eor	r1, r1
    296a:	2f 93       	push	r18
    296c:	3f 93       	push	r19
    296e:	4f 93       	push	r20
    2970:	5f 93       	push	r21
    2972:	6f 93       	push	r22
    2974:	7f 93       	push	r23
    2976:	8f 93       	push	r24
    2978:	9f 93       	push	r25
    297a:	af 93       	push	r26
    297c:	bf 93       	push	r27
    297e:	ef 93       	push	r30
    2980:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER1_CAPT_interrupt);
    2982:	80 91 ec 0e 	lds	r24, 0x0EEC
    2986:	90 91 ed 0e 	lds	r25, 0x0EED
    298a:	89 2b       	or	r24, r25
    298c:	29 f0       	breq	.+10     	; 0x2998 <__vector_16+0x38>
    298e:	e0 91 ec 0e 	lds	r30, 0x0EEC
    2992:	f0 91 ed 0e 	lds	r31, 0x0EED
    2996:	09 95       	icall
}
    2998:	ff 91       	pop	r31
    299a:	ef 91       	pop	r30
    299c:	bf 91       	pop	r27
    299e:	af 91       	pop	r26
    29a0:	9f 91       	pop	r25
    29a2:	8f 91       	pop	r24
    29a4:	7f 91       	pop	r23
    29a6:	6f 91       	pop	r22
    29a8:	5f 91       	pop	r21
    29aa:	4f 91       	pop	r20
    29ac:	3f 91       	pop	r19
    29ae:	2f 91       	pop	r18
    29b0:	0f 90       	pop	r0
    29b2:	0f be       	out	0x3f, r0	; 63
    29b4:	0f 90       	pop	r0
    29b6:	1f 90       	pop	r1
    29b8:	18 95       	reti

000029ba <__vector_18>:
{
  RUN_USER_DEFINE_INTERRUPT(TIMER1_COMPA_interrupt);
}
*/
ISR(TIMER1_COMPB_vect)
{
    29ba:	1f 92       	push	r1
    29bc:	0f 92       	push	r0
    29be:	0f b6       	in	r0, 0x3f	; 63
    29c0:	0f 92       	push	r0
    29c2:	11 24       	eor	r1, r1
    29c4:	2f 93       	push	r18
    29c6:	3f 93       	push	r19
    29c8:	4f 93       	push	r20
    29ca:	5f 93       	push	r21
    29cc:	6f 93       	push	r22
    29ce:	7f 93       	push	r23
    29d0:	8f 93       	push	r24
    29d2:	9f 93       	push	r25
    29d4:	af 93       	push	r26
    29d6:	bf 93       	push	r27
    29d8:	ef 93       	push	r30
    29da:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER1_COMPB_interrupt);
    29dc:	80 91 f0 0e 	lds	r24, 0x0EF0
    29e0:	90 91 f1 0e 	lds	r25, 0x0EF1
    29e4:	89 2b       	or	r24, r25
    29e6:	29 f0       	breq	.+10     	; 0x29f2 <__vector_18+0x38>
    29e8:	e0 91 f0 0e 	lds	r30, 0x0EF0
    29ec:	f0 91 f1 0e 	lds	r31, 0x0EF1
    29f0:	09 95       	icall
}
    29f2:	ff 91       	pop	r31
    29f4:	ef 91       	pop	r30
    29f6:	bf 91       	pop	r27
    29f8:	af 91       	pop	r26
    29fa:	9f 91       	pop	r25
    29fc:	8f 91       	pop	r24
    29fe:	7f 91       	pop	r23
    2a00:	6f 91       	pop	r22
    2a02:	5f 91       	pop	r21
    2a04:	4f 91       	pop	r20
    2a06:	3f 91       	pop	r19
    2a08:	2f 91       	pop	r18
    2a0a:	0f 90       	pop	r0
    2a0c:	0f be       	out	0x3f, r0	; 63
    2a0e:	0f 90       	pop	r0
    2a10:	1f 90       	pop	r1
    2a12:	18 95       	reti

00002a14 <__vector_19>:
ISR(TIMER1_COMPC_vect)
{
    2a14:	1f 92       	push	r1
    2a16:	0f 92       	push	r0
    2a18:	0f b6       	in	r0, 0x3f	; 63
    2a1a:	0f 92       	push	r0
    2a1c:	11 24       	eor	r1, r1
    2a1e:	2f 93       	push	r18
    2a20:	3f 93       	push	r19
    2a22:	4f 93       	push	r20
    2a24:	5f 93       	push	r21
    2a26:	6f 93       	push	r22
    2a28:	7f 93       	push	r23
    2a2a:	8f 93       	push	r24
    2a2c:	9f 93       	push	r25
    2a2e:	af 93       	push	r26
    2a30:	bf 93       	push	r27
    2a32:	ef 93       	push	r30
    2a34:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER1_COMPC_interrupt);
    2a36:	80 91 f2 0e 	lds	r24, 0x0EF2
    2a3a:	90 91 f3 0e 	lds	r25, 0x0EF3
    2a3e:	89 2b       	or	r24, r25
    2a40:	29 f0       	breq	.+10     	; 0x2a4c <__vector_19+0x38>
    2a42:	e0 91 f2 0e 	lds	r30, 0x0EF2
    2a46:	f0 91 f3 0e 	lds	r31, 0x0EF3
    2a4a:	09 95       	icall
}
    2a4c:	ff 91       	pop	r31
    2a4e:	ef 91       	pop	r30
    2a50:	bf 91       	pop	r27
    2a52:	af 91       	pop	r26
    2a54:	9f 91       	pop	r25
    2a56:	8f 91       	pop	r24
    2a58:	7f 91       	pop	r23
    2a5a:	6f 91       	pop	r22
    2a5c:	5f 91       	pop	r21
    2a5e:	4f 91       	pop	r20
    2a60:	3f 91       	pop	r19
    2a62:	2f 91       	pop	r18
    2a64:	0f 90       	pop	r0
    2a66:	0f be       	out	0x3f, r0	; 63
    2a68:	0f 90       	pop	r0
    2a6a:	1f 90       	pop	r1
    2a6c:	18 95       	reti

00002a6e <__vector_13>:
ISR(TIMER2_COMPA_vect)
{
    2a6e:	1f 92       	push	r1
    2a70:	0f 92       	push	r0
    2a72:	0f b6       	in	r0, 0x3f	; 63
    2a74:	0f 92       	push	r0
    2a76:	11 24       	eor	r1, r1
    2a78:	2f 93       	push	r18
    2a7a:	3f 93       	push	r19
    2a7c:	4f 93       	push	r20
    2a7e:	5f 93       	push	r21
    2a80:	6f 93       	push	r22
    2a82:	7f 93       	push	r23
    2a84:	8f 93       	push	r24
    2a86:	9f 93       	push	r25
    2a88:	af 93       	push	r26
    2a8a:	bf 93       	push	r27
    2a8c:	ef 93       	push	r30
    2a8e:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER2_COMPA_interrupt);
    2a90:	80 91 f6 0e 	lds	r24, 0x0EF6
    2a94:	90 91 f7 0e 	lds	r25, 0x0EF7
    2a98:	89 2b       	or	r24, r25
    2a9a:	29 f0       	breq	.+10     	; 0x2aa6 <__vector_13+0x38>
    2a9c:	e0 91 f6 0e 	lds	r30, 0x0EF6
    2aa0:	f0 91 f7 0e 	lds	r31, 0x0EF7
    2aa4:	09 95       	icall
}
    2aa6:	ff 91       	pop	r31
    2aa8:	ef 91       	pop	r30
    2aaa:	bf 91       	pop	r27
    2aac:	af 91       	pop	r26
    2aae:	9f 91       	pop	r25
    2ab0:	8f 91       	pop	r24
    2ab2:	7f 91       	pop	r23
    2ab4:	6f 91       	pop	r22
    2ab6:	5f 91       	pop	r21
    2ab8:	4f 91       	pop	r20
    2aba:	3f 91       	pop	r19
    2abc:	2f 91       	pop	r18
    2abe:	0f 90       	pop	r0
    2ac0:	0f be       	out	0x3f, r0	; 63
    2ac2:	0f 90       	pop	r0
    2ac4:	1f 90       	pop	r1
    2ac6:	18 95       	reti

00002ac8 <__vector_14>:
ISR(TIMER2_COMPB_vect)
{
    2ac8:	1f 92       	push	r1
    2aca:	0f 92       	push	r0
    2acc:	0f b6       	in	r0, 0x3f	; 63
    2ace:	0f 92       	push	r0
    2ad0:	11 24       	eor	r1, r1
    2ad2:	2f 93       	push	r18
    2ad4:	3f 93       	push	r19
    2ad6:	4f 93       	push	r20
    2ad8:	5f 93       	push	r21
    2ada:	6f 93       	push	r22
    2adc:	7f 93       	push	r23
    2ade:	8f 93       	push	r24
    2ae0:	9f 93       	push	r25
    2ae2:	af 93       	push	r26
    2ae4:	bf 93       	push	r27
    2ae6:	ef 93       	push	r30
    2ae8:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER2_COMPB_interrupt);
    2aea:	80 91 f8 0e 	lds	r24, 0x0EF8
    2aee:	90 91 f9 0e 	lds	r25, 0x0EF9
    2af2:	89 2b       	or	r24, r25
    2af4:	29 f0       	breq	.+10     	; 0x2b00 <__vector_14+0x38>
    2af6:	e0 91 f8 0e 	lds	r30, 0x0EF8
    2afa:	f0 91 f9 0e 	lds	r31, 0x0EF9
    2afe:	09 95       	icall
}
    2b00:	ff 91       	pop	r31
    2b02:	ef 91       	pop	r30
    2b04:	bf 91       	pop	r27
    2b06:	af 91       	pop	r26
    2b08:	9f 91       	pop	r25
    2b0a:	8f 91       	pop	r24
    2b0c:	7f 91       	pop	r23
    2b0e:	6f 91       	pop	r22
    2b10:	5f 91       	pop	r21
    2b12:	4f 91       	pop	r20
    2b14:	3f 91       	pop	r19
    2b16:	2f 91       	pop	r18
    2b18:	0f 90       	pop	r0
    2b1a:	0f be       	out	0x3f, r0	; 63
    2b1c:	0f 90       	pop	r0
    2b1e:	1f 90       	pop	r1
    2b20:	18 95       	reti

00002b22 <__vector_31>:
ISR(TIMER3_CAPT_vect)
{
    2b22:	1f 92       	push	r1
    2b24:	0f 92       	push	r0
    2b26:	0f b6       	in	r0, 0x3f	; 63
    2b28:	0f 92       	push	r0
    2b2a:	11 24       	eor	r1, r1
    2b2c:	2f 93       	push	r18
    2b2e:	3f 93       	push	r19
    2b30:	4f 93       	push	r20
    2b32:	5f 93       	push	r21
    2b34:	6f 93       	push	r22
    2b36:	7f 93       	push	r23
    2b38:	8f 93       	push	r24
    2b3a:	9f 93       	push	r25
    2b3c:	af 93       	push	r26
    2b3e:	bf 93       	push	r27
    2b40:	ef 93       	push	r30
    2b42:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_CAPT_interrupt);
    2b44:	80 91 fc 0e 	lds	r24, 0x0EFC
    2b48:	90 91 fd 0e 	lds	r25, 0x0EFD
    2b4c:	89 2b       	or	r24, r25
    2b4e:	29 f0       	breq	.+10     	; 0x2b5a <__vector_31+0x38>
    2b50:	e0 91 fc 0e 	lds	r30, 0x0EFC
    2b54:	f0 91 fd 0e 	lds	r31, 0x0EFD
    2b58:	09 95       	icall
}
    2b5a:	ff 91       	pop	r31
    2b5c:	ef 91       	pop	r30
    2b5e:	bf 91       	pop	r27
    2b60:	af 91       	pop	r26
    2b62:	9f 91       	pop	r25
    2b64:	8f 91       	pop	r24
    2b66:	7f 91       	pop	r23
    2b68:	6f 91       	pop	r22
    2b6a:	5f 91       	pop	r21
    2b6c:	4f 91       	pop	r20
    2b6e:	3f 91       	pop	r19
    2b70:	2f 91       	pop	r18
    2b72:	0f 90       	pop	r0
    2b74:	0f be       	out	0x3f, r0	; 63
    2b76:	0f 90       	pop	r0
    2b78:	1f 90       	pop	r1
    2b7a:	18 95       	reti

00002b7c <__vector_32>:
ISR(TIMER3_COMPA_vect)
{
    2b7c:	1f 92       	push	r1
    2b7e:	0f 92       	push	r0
    2b80:	0f b6       	in	r0, 0x3f	; 63
    2b82:	0f 92       	push	r0
    2b84:	11 24       	eor	r1, r1
    2b86:	2f 93       	push	r18
    2b88:	3f 93       	push	r19
    2b8a:	4f 93       	push	r20
    2b8c:	5f 93       	push	r21
    2b8e:	6f 93       	push	r22
    2b90:	7f 93       	push	r23
    2b92:	8f 93       	push	r24
    2b94:	9f 93       	push	r25
    2b96:	af 93       	push	r26
    2b98:	bf 93       	push	r27
    2b9a:	ef 93       	push	r30
    2b9c:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_COMPA_interrupt);
    2b9e:	80 91 fe 0e 	lds	r24, 0x0EFE
    2ba2:	90 91 ff 0e 	lds	r25, 0x0EFF
    2ba6:	89 2b       	or	r24, r25
    2ba8:	29 f0       	breq	.+10     	; 0x2bb4 <__vector_32+0x38>
    2baa:	e0 91 fe 0e 	lds	r30, 0x0EFE
    2bae:	f0 91 ff 0e 	lds	r31, 0x0EFF
    2bb2:	09 95       	icall
}
    2bb4:	ff 91       	pop	r31
    2bb6:	ef 91       	pop	r30
    2bb8:	bf 91       	pop	r27
    2bba:	af 91       	pop	r26
    2bbc:	9f 91       	pop	r25
    2bbe:	8f 91       	pop	r24
    2bc0:	7f 91       	pop	r23
    2bc2:	6f 91       	pop	r22
    2bc4:	5f 91       	pop	r21
    2bc6:	4f 91       	pop	r20
    2bc8:	3f 91       	pop	r19
    2bca:	2f 91       	pop	r18
    2bcc:	0f 90       	pop	r0
    2bce:	0f be       	out	0x3f, r0	; 63
    2bd0:	0f 90       	pop	r0
    2bd2:	1f 90       	pop	r1
    2bd4:	18 95       	reti

00002bd6 <__vector_33>:
ISR(TIMER3_COMPB_vect)
{
    2bd6:	1f 92       	push	r1
    2bd8:	0f 92       	push	r0
    2bda:	0f b6       	in	r0, 0x3f	; 63
    2bdc:	0f 92       	push	r0
    2bde:	11 24       	eor	r1, r1
    2be0:	2f 93       	push	r18
    2be2:	3f 93       	push	r19
    2be4:	4f 93       	push	r20
    2be6:	5f 93       	push	r21
    2be8:	6f 93       	push	r22
    2bea:	7f 93       	push	r23
    2bec:	8f 93       	push	r24
    2bee:	9f 93       	push	r25
    2bf0:	af 93       	push	r26
    2bf2:	bf 93       	push	r27
    2bf4:	ef 93       	push	r30
    2bf6:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_COMPB_interrupt);
    2bf8:	80 91 00 0f 	lds	r24, 0x0F00
    2bfc:	90 91 01 0f 	lds	r25, 0x0F01
    2c00:	89 2b       	or	r24, r25
    2c02:	29 f0       	breq	.+10     	; 0x2c0e <__vector_33+0x38>
    2c04:	e0 91 00 0f 	lds	r30, 0x0F00
    2c08:	f0 91 01 0f 	lds	r31, 0x0F01
    2c0c:	09 95       	icall
}
    2c0e:	ff 91       	pop	r31
    2c10:	ef 91       	pop	r30
    2c12:	bf 91       	pop	r27
    2c14:	af 91       	pop	r26
    2c16:	9f 91       	pop	r25
    2c18:	8f 91       	pop	r24
    2c1a:	7f 91       	pop	r23
    2c1c:	6f 91       	pop	r22
    2c1e:	5f 91       	pop	r21
    2c20:	4f 91       	pop	r20
    2c22:	3f 91       	pop	r19
    2c24:	2f 91       	pop	r18
    2c26:	0f 90       	pop	r0
    2c28:	0f be       	out	0x3f, r0	; 63
    2c2a:	0f 90       	pop	r0
    2c2c:	1f 90       	pop	r1
    2c2e:	18 95       	reti

00002c30 <__vector_34>:
ISR(TIMER3_COMPC_vect)
{
    2c30:	1f 92       	push	r1
    2c32:	0f 92       	push	r0
    2c34:	0f b6       	in	r0, 0x3f	; 63
    2c36:	0f 92       	push	r0
    2c38:	11 24       	eor	r1, r1
    2c3a:	2f 93       	push	r18
    2c3c:	3f 93       	push	r19
    2c3e:	4f 93       	push	r20
    2c40:	5f 93       	push	r21
    2c42:	6f 93       	push	r22
    2c44:	7f 93       	push	r23
    2c46:	8f 93       	push	r24
    2c48:	9f 93       	push	r25
    2c4a:	af 93       	push	r26
    2c4c:	bf 93       	push	r27
    2c4e:	ef 93       	push	r30
    2c50:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_COMPC_interrupt);
    2c52:	80 91 02 0f 	lds	r24, 0x0F02
    2c56:	90 91 03 0f 	lds	r25, 0x0F03
    2c5a:	89 2b       	or	r24, r25
    2c5c:	29 f0       	breq	.+10     	; 0x2c68 <__vector_34+0x38>
    2c5e:	e0 91 02 0f 	lds	r30, 0x0F02
    2c62:	f0 91 03 0f 	lds	r31, 0x0F03
    2c66:	09 95       	icall
}
    2c68:	ff 91       	pop	r31
    2c6a:	ef 91       	pop	r30
    2c6c:	bf 91       	pop	r27
    2c6e:	af 91       	pop	r26
    2c70:	9f 91       	pop	r25
    2c72:	8f 91       	pop	r24
    2c74:	7f 91       	pop	r23
    2c76:	6f 91       	pop	r22
    2c78:	5f 91       	pop	r21
    2c7a:	4f 91       	pop	r20
    2c7c:	3f 91       	pop	r19
    2c7e:	2f 91       	pop	r18
    2c80:	0f 90       	pop	r0
    2c82:	0f be       	out	0x3f, r0	; 63
    2c84:	0f 90       	pop	r0
    2c86:	1f 90       	pop	r1
    2c88:	18 95       	reti

00002c8a <__vector_41>:
ISR(TIMER4_CAPT_vect)
{
    2c8a:	1f 92       	push	r1
    2c8c:	0f 92       	push	r0
    2c8e:	0f b6       	in	r0, 0x3f	; 63
    2c90:	0f 92       	push	r0
    2c92:	11 24       	eor	r1, r1
    2c94:	2f 93       	push	r18
    2c96:	3f 93       	push	r19
    2c98:	4f 93       	push	r20
    2c9a:	5f 93       	push	r21
    2c9c:	6f 93       	push	r22
    2c9e:	7f 93       	push	r23
    2ca0:	8f 93       	push	r24
    2ca2:	9f 93       	push	r25
    2ca4:	af 93       	push	r26
    2ca6:	bf 93       	push	r27
    2ca8:	ef 93       	push	r30
    2caa:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_CAPT_interrupt);
    2cac:	80 91 06 0f 	lds	r24, 0x0F06
    2cb0:	90 91 07 0f 	lds	r25, 0x0F07
    2cb4:	89 2b       	or	r24, r25
    2cb6:	29 f0       	breq	.+10     	; 0x2cc2 <__vector_41+0x38>
    2cb8:	e0 91 06 0f 	lds	r30, 0x0F06
    2cbc:	f0 91 07 0f 	lds	r31, 0x0F07
    2cc0:	09 95       	icall
}
    2cc2:	ff 91       	pop	r31
    2cc4:	ef 91       	pop	r30
    2cc6:	bf 91       	pop	r27
    2cc8:	af 91       	pop	r26
    2cca:	9f 91       	pop	r25
    2ccc:	8f 91       	pop	r24
    2cce:	7f 91       	pop	r23
    2cd0:	6f 91       	pop	r22
    2cd2:	5f 91       	pop	r21
    2cd4:	4f 91       	pop	r20
    2cd6:	3f 91       	pop	r19
    2cd8:	2f 91       	pop	r18
    2cda:	0f 90       	pop	r0
    2cdc:	0f be       	out	0x3f, r0	; 63
    2cde:	0f 90       	pop	r0
    2ce0:	1f 90       	pop	r1
    2ce2:	18 95       	reti

00002ce4 <__vector_42>:
ISR(TIMER4_COMPA_vect)
{
    2ce4:	1f 92       	push	r1
    2ce6:	0f 92       	push	r0
    2ce8:	0f b6       	in	r0, 0x3f	; 63
    2cea:	0f 92       	push	r0
    2cec:	11 24       	eor	r1, r1
    2cee:	2f 93       	push	r18
    2cf0:	3f 93       	push	r19
    2cf2:	4f 93       	push	r20
    2cf4:	5f 93       	push	r21
    2cf6:	6f 93       	push	r22
    2cf8:	7f 93       	push	r23
    2cfa:	8f 93       	push	r24
    2cfc:	9f 93       	push	r25
    2cfe:	af 93       	push	r26
    2d00:	bf 93       	push	r27
    2d02:	ef 93       	push	r30
    2d04:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_COMPA_interrupt);
    2d06:	80 91 08 0f 	lds	r24, 0x0F08
    2d0a:	90 91 09 0f 	lds	r25, 0x0F09
    2d0e:	89 2b       	or	r24, r25
    2d10:	29 f0       	breq	.+10     	; 0x2d1c <__vector_42+0x38>
    2d12:	e0 91 08 0f 	lds	r30, 0x0F08
    2d16:	f0 91 09 0f 	lds	r31, 0x0F09
    2d1a:	09 95       	icall
}
    2d1c:	ff 91       	pop	r31
    2d1e:	ef 91       	pop	r30
    2d20:	bf 91       	pop	r27
    2d22:	af 91       	pop	r26
    2d24:	9f 91       	pop	r25
    2d26:	8f 91       	pop	r24
    2d28:	7f 91       	pop	r23
    2d2a:	6f 91       	pop	r22
    2d2c:	5f 91       	pop	r21
    2d2e:	4f 91       	pop	r20
    2d30:	3f 91       	pop	r19
    2d32:	2f 91       	pop	r18
    2d34:	0f 90       	pop	r0
    2d36:	0f be       	out	0x3f, r0	; 63
    2d38:	0f 90       	pop	r0
    2d3a:	1f 90       	pop	r1
    2d3c:	18 95       	reti

00002d3e <__vector_43>:
ISR(TIMER4_COMPB_vect)
{
    2d3e:	1f 92       	push	r1
    2d40:	0f 92       	push	r0
    2d42:	0f b6       	in	r0, 0x3f	; 63
    2d44:	0f 92       	push	r0
    2d46:	11 24       	eor	r1, r1
    2d48:	2f 93       	push	r18
    2d4a:	3f 93       	push	r19
    2d4c:	4f 93       	push	r20
    2d4e:	5f 93       	push	r21
    2d50:	6f 93       	push	r22
    2d52:	7f 93       	push	r23
    2d54:	8f 93       	push	r24
    2d56:	9f 93       	push	r25
    2d58:	af 93       	push	r26
    2d5a:	bf 93       	push	r27
    2d5c:	ef 93       	push	r30
    2d5e:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_COMPB_interrupt);
    2d60:	80 91 0a 0f 	lds	r24, 0x0F0A
    2d64:	90 91 0b 0f 	lds	r25, 0x0F0B
    2d68:	89 2b       	or	r24, r25
    2d6a:	29 f0       	breq	.+10     	; 0x2d76 <__vector_43+0x38>
    2d6c:	e0 91 0a 0f 	lds	r30, 0x0F0A
    2d70:	f0 91 0b 0f 	lds	r31, 0x0F0B
    2d74:	09 95       	icall
}
    2d76:	ff 91       	pop	r31
    2d78:	ef 91       	pop	r30
    2d7a:	bf 91       	pop	r27
    2d7c:	af 91       	pop	r26
    2d7e:	9f 91       	pop	r25
    2d80:	8f 91       	pop	r24
    2d82:	7f 91       	pop	r23
    2d84:	6f 91       	pop	r22
    2d86:	5f 91       	pop	r21
    2d88:	4f 91       	pop	r20
    2d8a:	3f 91       	pop	r19
    2d8c:	2f 91       	pop	r18
    2d8e:	0f 90       	pop	r0
    2d90:	0f be       	out	0x3f, r0	; 63
    2d92:	0f 90       	pop	r0
    2d94:	1f 90       	pop	r1
    2d96:	18 95       	reti

00002d98 <__vector_44>:
ISR(TIMER4_COMPC_vect)
{
    2d98:	1f 92       	push	r1
    2d9a:	0f 92       	push	r0
    2d9c:	0f b6       	in	r0, 0x3f	; 63
    2d9e:	0f 92       	push	r0
    2da0:	11 24       	eor	r1, r1
    2da2:	2f 93       	push	r18
    2da4:	3f 93       	push	r19
    2da6:	4f 93       	push	r20
    2da8:	5f 93       	push	r21
    2daa:	6f 93       	push	r22
    2dac:	7f 93       	push	r23
    2dae:	8f 93       	push	r24
    2db0:	9f 93       	push	r25
    2db2:	af 93       	push	r26
    2db4:	bf 93       	push	r27
    2db6:	ef 93       	push	r30
    2db8:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_COMPC_interrupt);
    2dba:	80 91 0c 0f 	lds	r24, 0x0F0C
    2dbe:	90 91 0d 0f 	lds	r25, 0x0F0D
    2dc2:	89 2b       	or	r24, r25
    2dc4:	29 f0       	breq	.+10     	; 0x2dd0 <__vector_44+0x38>
    2dc6:	e0 91 0c 0f 	lds	r30, 0x0F0C
    2dca:	f0 91 0d 0f 	lds	r31, 0x0F0D
    2dce:	09 95       	icall
}
    2dd0:	ff 91       	pop	r31
    2dd2:	ef 91       	pop	r30
    2dd4:	bf 91       	pop	r27
    2dd6:	af 91       	pop	r26
    2dd8:	9f 91       	pop	r25
    2dda:	8f 91       	pop	r24
    2ddc:	7f 91       	pop	r23
    2dde:	6f 91       	pop	r22
    2de0:	5f 91       	pop	r21
    2de2:	4f 91       	pop	r20
    2de4:	3f 91       	pop	r19
    2de6:	2f 91       	pop	r18
    2de8:	0f 90       	pop	r0
    2dea:	0f be       	out	0x3f, r0	; 63
    2dec:	0f 90       	pop	r0
    2dee:	1f 90       	pop	r1
    2df0:	18 95       	reti

00002df2 <__vector_46>:
ISR(TIMER5_CAPT_vect)
{
    2df2:	1f 92       	push	r1
    2df4:	0f 92       	push	r0
    2df6:	0f b6       	in	r0, 0x3f	; 63
    2df8:	0f 92       	push	r0
    2dfa:	11 24       	eor	r1, r1
    2dfc:	2f 93       	push	r18
    2dfe:	3f 93       	push	r19
    2e00:	4f 93       	push	r20
    2e02:	5f 93       	push	r21
    2e04:	6f 93       	push	r22
    2e06:	7f 93       	push	r23
    2e08:	8f 93       	push	r24
    2e0a:	9f 93       	push	r25
    2e0c:	af 93       	push	r26
    2e0e:	bf 93       	push	r27
    2e10:	ef 93       	push	r30
    2e12:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_CAPT_interrupt);
    2e14:	80 91 10 0f 	lds	r24, 0x0F10
    2e18:	90 91 11 0f 	lds	r25, 0x0F11
    2e1c:	89 2b       	or	r24, r25
    2e1e:	29 f0       	breq	.+10     	; 0x2e2a <__vector_46+0x38>
    2e20:	e0 91 10 0f 	lds	r30, 0x0F10
    2e24:	f0 91 11 0f 	lds	r31, 0x0F11
    2e28:	09 95       	icall
}
    2e2a:	ff 91       	pop	r31
    2e2c:	ef 91       	pop	r30
    2e2e:	bf 91       	pop	r27
    2e30:	af 91       	pop	r26
    2e32:	9f 91       	pop	r25
    2e34:	8f 91       	pop	r24
    2e36:	7f 91       	pop	r23
    2e38:	6f 91       	pop	r22
    2e3a:	5f 91       	pop	r21
    2e3c:	4f 91       	pop	r20
    2e3e:	3f 91       	pop	r19
    2e40:	2f 91       	pop	r18
    2e42:	0f 90       	pop	r0
    2e44:	0f be       	out	0x3f, r0	; 63
    2e46:	0f 90       	pop	r0
    2e48:	1f 90       	pop	r1
    2e4a:	18 95       	reti

00002e4c <__vector_47>:
ISR(TIMER5_COMPA_vect)
{
    2e4c:	1f 92       	push	r1
    2e4e:	0f 92       	push	r0
    2e50:	0f b6       	in	r0, 0x3f	; 63
    2e52:	0f 92       	push	r0
    2e54:	11 24       	eor	r1, r1
    2e56:	2f 93       	push	r18
    2e58:	3f 93       	push	r19
    2e5a:	4f 93       	push	r20
    2e5c:	5f 93       	push	r21
    2e5e:	6f 93       	push	r22
    2e60:	7f 93       	push	r23
    2e62:	8f 93       	push	r24
    2e64:	9f 93       	push	r25
    2e66:	af 93       	push	r26
    2e68:	bf 93       	push	r27
    2e6a:	ef 93       	push	r30
    2e6c:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_COMPA_interrupt);
    2e6e:	80 91 12 0f 	lds	r24, 0x0F12
    2e72:	90 91 13 0f 	lds	r25, 0x0F13
    2e76:	89 2b       	or	r24, r25
    2e78:	29 f0       	breq	.+10     	; 0x2e84 <__vector_47+0x38>
    2e7a:	e0 91 12 0f 	lds	r30, 0x0F12
    2e7e:	f0 91 13 0f 	lds	r31, 0x0F13
    2e82:	09 95       	icall
}
    2e84:	ff 91       	pop	r31
    2e86:	ef 91       	pop	r30
    2e88:	bf 91       	pop	r27
    2e8a:	af 91       	pop	r26
    2e8c:	9f 91       	pop	r25
    2e8e:	8f 91       	pop	r24
    2e90:	7f 91       	pop	r23
    2e92:	6f 91       	pop	r22
    2e94:	5f 91       	pop	r21
    2e96:	4f 91       	pop	r20
    2e98:	3f 91       	pop	r19
    2e9a:	2f 91       	pop	r18
    2e9c:	0f 90       	pop	r0
    2e9e:	0f be       	out	0x3f, r0	; 63
    2ea0:	0f 90       	pop	r0
    2ea2:	1f 90       	pop	r1
    2ea4:	18 95       	reti

00002ea6 <__vector_48>:
ISR(TIMER5_COMPB_vect)
{
    2ea6:	1f 92       	push	r1
    2ea8:	0f 92       	push	r0
    2eaa:	0f b6       	in	r0, 0x3f	; 63
    2eac:	0f 92       	push	r0
    2eae:	11 24       	eor	r1, r1
    2eb0:	2f 93       	push	r18
    2eb2:	3f 93       	push	r19
    2eb4:	4f 93       	push	r20
    2eb6:	5f 93       	push	r21
    2eb8:	6f 93       	push	r22
    2eba:	7f 93       	push	r23
    2ebc:	8f 93       	push	r24
    2ebe:	9f 93       	push	r25
    2ec0:	af 93       	push	r26
    2ec2:	bf 93       	push	r27
    2ec4:	ef 93       	push	r30
    2ec6:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_COMPB_interrupt);
    2ec8:	80 91 14 0f 	lds	r24, 0x0F14
    2ecc:	90 91 15 0f 	lds	r25, 0x0F15
    2ed0:	89 2b       	or	r24, r25
    2ed2:	29 f0       	breq	.+10     	; 0x2ede <__vector_48+0x38>
    2ed4:	e0 91 14 0f 	lds	r30, 0x0F14
    2ed8:	f0 91 15 0f 	lds	r31, 0x0F15
    2edc:	09 95       	icall
}
    2ede:	ff 91       	pop	r31
    2ee0:	ef 91       	pop	r30
    2ee2:	bf 91       	pop	r27
    2ee4:	af 91       	pop	r26
    2ee6:	9f 91       	pop	r25
    2ee8:	8f 91       	pop	r24
    2eea:	7f 91       	pop	r23
    2eec:	6f 91       	pop	r22
    2eee:	5f 91       	pop	r21
    2ef0:	4f 91       	pop	r20
    2ef2:	3f 91       	pop	r19
    2ef4:	2f 91       	pop	r18
    2ef6:	0f 90       	pop	r0
    2ef8:	0f be       	out	0x3f, r0	; 63
    2efa:	0f 90       	pop	r0
    2efc:	1f 90       	pop	r1
    2efe:	18 95       	reti

00002f00 <__vector_49>:
ISR(TIMER5_COMPC_vect)
{
    2f00:	1f 92       	push	r1
    2f02:	0f 92       	push	r0
    2f04:	0f b6       	in	r0, 0x3f	; 63
    2f06:	0f 92       	push	r0
    2f08:	11 24       	eor	r1, r1
    2f0a:	2f 93       	push	r18
    2f0c:	3f 93       	push	r19
    2f0e:	4f 93       	push	r20
    2f10:	5f 93       	push	r21
    2f12:	6f 93       	push	r22
    2f14:	7f 93       	push	r23
    2f16:	8f 93       	push	r24
    2f18:	9f 93       	push	r25
    2f1a:	af 93       	push	r26
    2f1c:	bf 93       	push	r27
    2f1e:	ef 93       	push	r30
    2f20:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_COMPC_interrupt);
    2f22:	80 91 16 0f 	lds	r24, 0x0F16
    2f26:	90 91 17 0f 	lds	r25, 0x0F17
    2f2a:	89 2b       	or	r24, r25
    2f2c:	29 f0       	breq	.+10     	; 0x2f38 <__vector_49+0x38>
    2f2e:	e0 91 16 0f 	lds	r30, 0x0F16
    2f32:	f0 91 17 0f 	lds	r31, 0x0F17
    2f36:	09 95       	icall
}
    2f38:	ff 91       	pop	r31
    2f3a:	ef 91       	pop	r30
    2f3c:	bf 91       	pop	r27
    2f3e:	af 91       	pop	r26
    2f40:	9f 91       	pop	r25
    2f42:	8f 91       	pop	r24
    2f44:	7f 91       	pop	r23
    2f46:	6f 91       	pop	r22
    2f48:	5f 91       	pop	r21
    2f4a:	4f 91       	pop	r20
    2f4c:	3f 91       	pop	r19
    2f4e:	2f 91       	pop	r18
    2f50:	0f 90       	pop	r0
    2f52:	0f be       	out	0x3f, r0	; 63
    2f54:	0f 90       	pop	r0
    2f56:	1f 90       	pop	r1
    2f58:	18 95       	reti

00002f5a <__vector_default>:

ISR(BADISR_vect)
{
    2f5a:	1f 92       	push	r1
    2f5c:	0f 92       	push	r0
    2f5e:	0f b6       	in	r0, 0x3f	; 63
    2f60:	0f 92       	push	r0
    2f62:	11 24       	eor	r1, r1
    2f64:	2f 93       	push	r18
    2f66:	3f 93       	push	r19
    2f68:	4f 93       	push	r20
    2f6a:	5f 93       	push	r21
    2f6c:	6f 93       	push	r22
    2f6e:	7f 93       	push	r23
    2f70:	8f 93       	push	r24
    2f72:	9f 93       	push	r25
    2f74:	af 93       	push	r26
    2f76:	bf 93       	push	r27
    2f78:	ef 93       	push	r30
    2f7a:	ff 93       	push	r31
  rprintf("BAD_vect called!");
    2f7c:	00 d0       	rcall	.+0      	; 0x2f7e <__vector_default+0x24>
    2f7e:	0f 92       	push	r0
    2f80:	81 e0       	ldi	r24, 0x01	; 1
    2f82:	ed b7       	in	r30, 0x3d	; 61
    2f84:	fe b7       	in	r31, 0x3e	; 62
    2f86:	81 83       	std	Z+1, r24	; 0x01
    2f88:	8e e5       	ldi	r24, 0x5E	; 94
    2f8a:	91 e0       	ldi	r25, 0x01	; 1
    2f8c:	93 83       	std	Z+3, r25	; 0x03
    2f8e:	82 83       	std	Z+2, r24	; 0x02
    2f90:	0e 94 77 1f 	call	0x3eee	; 0x3eee <rprintf1RamRom>
    2f94:	0f 90       	pop	r0
    2f96:	0f 90       	pop	r0
    2f98:	0f 90       	pop	r0
}
    2f9a:	ff 91       	pop	r31
    2f9c:	ef 91       	pop	r30
    2f9e:	bf 91       	pop	r27
    2fa0:	af 91       	pop	r26
    2fa2:	9f 91       	pop	r25
    2fa4:	8f 91       	pop	r24
    2fa6:	7f 91       	pop	r23
    2fa8:	6f 91       	pop	r22
    2faa:	5f 91       	pop	r21
    2fac:	4f 91       	pop	r20
    2fae:	3f 91       	pop	r19
    2fb0:	2f 91       	pop	r18
    2fb2:	0f 90       	pop	r0
    2fb4:	0f be       	out	0x3f, r0	; 63
    2fb6:	0f 90       	pop	r0
    2fb8:	1f 90       	pop	r1
    2fba:	18 95       	reti

00002fbc <uartSetRxHandler>:
}

void uartSetRxHandler(u08 nUart, void (*rx_func)(unsigned char c))
{
	// make sure the uart number is within bounds
	if(nUart < 4)
    2fbc:	84 30       	cpi	r24, 0x04	; 4
    2fbe:	40 f4       	brcc	.+16     	; 0x2fd0 <uartSetRxHandler+0x14>
	{
		// set the receive interrupt to run the supplied user function
		UartRxFunc[nUart] = rx_func;
    2fc0:	e8 2f       	mov	r30, r24
    2fc2:	f0 e0       	ldi	r31, 0x00	; 0
    2fc4:	ee 0f       	add	r30, r30
    2fc6:	ff 1f       	adc	r31, r31
    2fc8:	e6 5a       	subi	r30, 0xA6	; 166
    2fca:	fe 4e       	sbci	r31, 0xEE	; 238
    2fcc:	71 83       	std	Z+1, r23	; 0x01
    2fce:	60 83       	st	Z, r22
    2fd0:	08 95       	ret

00002fd2 <uartSetBaudRate>:
	}
}

void uartSetBaudRate(u08 nUart, u32 baudrate)
{
    2fd2:	1f 93       	push	r17
    2fd4:	18 2f       	mov	r17, r24
    2fd6:	9a 01       	movw	r18, r20
    2fd8:	ab 01       	movw	r20, r22
	// calculate division factor for requested baud rate, and set it
	u16 bauddiv = ((F_CPU+(baudrate*8L))/(baudrate*16L)-1);
    2fda:	ca 01       	movw	r24, r20
    2fdc:	b9 01       	movw	r22, r18
    2fde:	60 58       	subi	r22, 0x80	; 128
    2fe0:	7b 47       	sbci	r23, 0x7B	; 123
    2fe2:	81 4e       	sbci	r24, 0xE1	; 225
    2fe4:	9f 4f       	sbci	r25, 0xFF	; 255
    2fe6:	f3 e0       	ldi	r31, 0x03	; 3
    2fe8:	66 0f       	add	r22, r22
    2fea:	77 1f       	adc	r23, r23
    2fec:	88 1f       	adc	r24, r24
    2fee:	99 1f       	adc	r25, r25
    2ff0:	fa 95       	dec	r31
    2ff2:	d1 f7       	brne	.-12     	; 0x2fe8 <uartSetBaudRate+0x16>
    2ff4:	e4 e0       	ldi	r30, 0x04	; 4
    2ff6:	22 0f       	add	r18, r18
    2ff8:	33 1f       	adc	r19, r19
    2ffa:	44 1f       	adc	r20, r20
    2ffc:	55 1f       	adc	r21, r21
    2ffe:	ea 95       	dec	r30
    3000:	d1 f7       	brne	.-12     	; 0x2ff6 <uartSetBaudRate+0x24>
    3002:	0e 94 9b 27 	call	0x4f36	; 0x4f36 <__udivmodsi4>
    3006:	21 50       	subi	r18, 0x01	; 1
    3008:	30 40       	sbci	r19, 0x00	; 0
	if(nUart==3)
    300a:	13 30       	cpi	r17, 0x03	; 3
    300c:	29 f4       	brne	.+10     	; 0x3018 <uartSetBaudRate+0x46>
	{
		outb(UBRR3L, bauddiv);
    300e:	20 93 34 01 	sts	0x0134, r18
		#ifdef UBRR3H
		outb(UBRR3H, bauddiv>>8);
    3012:	30 93 35 01 	sts	0x0135, r19
    3016:	12 c0       	rjmp	.+36     	; 0x303c <uartSetBaudRate+0x6a>
		#endif
	}
	else if(nUart==2)
    3018:	12 30       	cpi	r17, 0x02	; 2
    301a:	29 f4       	brne	.+10     	; 0x3026 <uartSetBaudRate+0x54>
	{
		outb(UBRR2L, bauddiv);
    301c:	20 93 d4 00 	sts	0x00D4, r18
		#ifdef UBRR2H
		outb(UBRR2H, bauddiv>>8);
    3020:	30 93 d5 00 	sts	0x00D5, r19
    3024:	0b c0       	rjmp	.+22     	; 0x303c <uartSetBaudRate+0x6a>
		#endif
	}
	else if(nUart==1)
    3026:	11 30       	cpi	r17, 0x01	; 1
    3028:	29 f4       	brne	.+10     	; 0x3034 <uartSetBaudRate+0x62>
	{
		outb(UBRR1L, bauddiv);
    302a:	20 93 cc 00 	sts	0x00CC, r18
		#ifdef UBRR1H
		outb(UBRR1H, bauddiv>>8);
    302e:	30 93 cd 00 	sts	0x00CD, r19
    3032:	04 c0       	rjmp	.+8      	; 0x303c <uartSetBaudRate+0x6a>
		#endif
	}
	else
	{
		outb(UBRR0L, bauddiv);
    3034:	20 93 c4 00 	sts	0x00C4, r18
		#ifdef UBRR0H
		outb(UBRR0H, bauddiv>>8);
    3038:	30 93 c5 00 	sts	0x00C5, r19
		#endif
	}
}
    303c:	1f 91       	pop	r17
    303e:	08 95       	ret

00003040 <uartGetRxBuffer>:

cBuffer* uartGetRxBuffer(u08 nUart)
{
    3040:	28 2f       	mov	r18, r24
    3042:	30 e0       	ldi	r19, 0x00	; 0
    3044:	a3 e0       	ldi	r26, 0x03	; 3
    3046:	22 0f       	add	r18, r18
    3048:	33 1f       	adc	r19, r19
    304a:	aa 95       	dec	r26
    304c:	e1 f7       	brne	.-8      	; 0x3046 <uartGetRxBuffer+0x6>
    304e:	22 52       	subi	r18, 0x22	; 34
    3050:	3e 4e       	sbci	r19, 0xEE	; 238
	// return rx buffer pointer
	return &uartRxBuffer[nUart];
}
    3052:	c9 01       	movw	r24, r18
    3054:	08 95       	ret

00003056 <uartGetTxBuffer>:

cBuffer* uartGetTxBuffer(u08 nUart)
{
    3056:	28 2f       	mov	r18, r24
    3058:	30 e0       	ldi	r19, 0x00	; 0
    305a:	b3 e0       	ldi	r27, 0x03	; 3
    305c:	22 0f       	add	r18, r18
    305e:	33 1f       	adc	r19, r19
    3060:	ba 95       	dec	r27
    3062:	e1 f7       	brne	.-8      	; 0x305c <uartGetTxBuffer+0x6>
    3064:	2e 5f       	subi	r18, 0xFE	; 254
    3066:	3d 4e       	sbci	r19, 0xED	; 237
	// return tx buffer pointer
	return &uartTxBuffer[nUart];
}
    3068:	c9 01       	movw	r24, r18
    306a:	08 95       	ret

0000306c <uartSendByte>:

void uartSendByte(u08 nUart, u08 txData)
{
    306c:	e8 2f       	mov	r30, r24
	// wait for the transmitter to be ready
//	while(!uartReadyTx[nUart]);
	// send byte
	if(nUart==3)
    306e:	83 30       	cpi	r24, 0x03	; 3
    3070:	39 f4       	brne	.+14     	; 0x3080 <uartSendByte+0x14>
	{
		while(!(UCSR3A & (1<<UDRE3)));
    3072:	80 91 30 01 	lds	r24, 0x0130
    3076:	85 ff       	sbrs	r24, 5
    3078:	fc cf       	rjmp	.-8      	; 0x3072 <uartSendByte+0x6>
		outb(UDR3, txData);
    307a:	60 93 36 01 	sts	0x0136, r22
    307e:	18 c0       	rjmp	.+48     	; 0x30b0 <uartSendByte+0x44>
	}
	else if(nUart==2)
    3080:	82 30       	cpi	r24, 0x02	; 2
    3082:	39 f4       	brne	.+14     	; 0x3092 <uartSendByte+0x26>
	{
		while(!(UCSR2A & (1<<UDRE2)));
    3084:	80 91 d0 00 	lds	r24, 0x00D0
    3088:	85 ff       	sbrs	r24, 5
    308a:	fc cf       	rjmp	.-8      	; 0x3084 <uartSendByte+0x18>
		outb(UDR2, txData);
    308c:	60 93 d6 00 	sts	0x00D6, r22
    3090:	0f c0       	rjmp	.+30     	; 0x30b0 <uartSendByte+0x44>
	}
	else if(nUart==1)
    3092:	81 30       	cpi	r24, 0x01	; 1
    3094:	39 f4       	brne	.+14     	; 0x30a4 <uartSendByte+0x38>
	{
		while(!(UCSR1A & (1<<UDRE1)));
    3096:	80 91 c8 00 	lds	r24, 0x00C8
    309a:	85 ff       	sbrs	r24, 5
    309c:	fc cf       	rjmp	.-8      	; 0x3096 <uartSendByte+0x2a>
		outb(UDR1, txData);
    309e:	60 93 ce 00 	sts	0x00CE, r22
    30a2:	06 c0       	rjmp	.+12     	; 0x30b0 <uartSendByte+0x44>
	}
	else
	{
		while(!(UCSR0A & (1<<UDRE0)));
    30a4:	80 91 c0 00 	lds	r24, 0x00C0
    30a8:	85 ff       	sbrs	r24, 5
    30aa:	fc cf       	rjmp	.-8      	; 0x30a4 <uartSendByte+0x38>
		outb(UDR0, txData);
    30ac:	60 93 c6 00 	sts	0x00C6, r22
	}
	// set ready state to FALSE
	uartReadyTx[nUart] = FALSE;
    30b0:	f0 e0       	ldi	r31, 0x00	; 0
    30b2:	e6 52       	subi	r30, 0x26	; 38
    30b4:	fe 4e       	sbci	r31, 0xEE	; 238
    30b6:	10 82       	st	Z, r1
}
    30b8:	08 95       	ret

000030ba <uart0SendByte>:

void uart0SendByte(u08 data)
{
    30ba:	68 2f       	mov	r22, r24
	// send byte on UART0
	uartSendByte(0, data);
    30bc:	80 e0       	ldi	r24, 0x00	; 0
    30be:	0e 94 36 18 	call	0x306c	; 0x306c <uartSendByte>
}
    30c2:	08 95       	ret

000030c4 <uart1SendByte>:

void uart1SendByte(u08 data)
{
    30c4:	68 2f       	mov	r22, r24
	// send byte on UART1
	uartSendByte(1, data);
    30c6:	81 e0       	ldi	r24, 0x01	; 1
    30c8:	0e 94 36 18 	call	0x306c	; 0x306c <uartSendByte>
}
    30cc:	08 95       	ret

000030ce <uart2SendByte>:

void uart2SendByte(u08 data)
{
    30ce:	68 2f       	mov	r22, r24
	// send byte on UART2
	uartSendByte(2, data);
    30d0:	82 e0       	ldi	r24, 0x02	; 2
    30d2:	0e 94 36 18 	call	0x306c	; 0x306c <uartSendByte>
}
    30d6:	08 95       	ret

000030d8 <uart3SendByte>:

void uart3SendByte(u08 data)
{
    30d8:	68 2f       	mov	r22, r24
	// send byte on UART3
	uartSendByte(3, data);
    30da:	83 e0       	ldi	r24, 0x03	; 3
    30dc:	0e 94 36 18 	call	0x306c	; 0x306c <uartSendByte>
}
    30e0:	08 95       	ret

000030e2 <uartReceiveBufferIsEmpty>:
	// flush all data from receive buffer
	bufferFlush(&uartRxBuffer[nUart]);
}

u08 uartReceiveBufferIsEmpty(u08 nUart)
{
    30e2:	20 e0       	ldi	r18, 0x00	; 0
    30e4:	e8 2f       	mov	r30, r24
    30e6:	f0 e0       	ldi	r31, 0x00	; 0
    30e8:	83 e0       	ldi	r24, 0x03	; 3
    30ea:	ee 0f       	add	r30, r30
    30ec:	ff 1f       	adc	r31, r31
    30ee:	8a 95       	dec	r24
    30f0:	e1 f7       	brne	.-8      	; 0x30ea <uartReceiveBufferIsEmpty+0x8>
    30f2:	ee 51       	subi	r30, 0x1E	; 30
    30f4:	fe 4e       	sbci	r31, 0xEE	; 238
    30f6:	80 81       	ld	r24, Z
    30f8:	91 81       	ldd	r25, Z+1	; 0x01
    30fa:	89 2b       	or	r24, r25
    30fc:	09 f4       	brne	.+2      	; 0x3100 <uartReceiveBufferIsEmpty+0x1e>
    30fe:	21 e0       	ldi	r18, 0x01	; 1
	return (uartRxBuffer[nUart].datalength == 0);
}
    3100:	82 2f       	mov	r24, r18
    3102:	08 95       	ret

00003104 <uartReceiveService>:
	}
}

// UART Receive Complete Interrupt Function
void uartReceiveService(u08 nUart)
{
    3104:	cf 93       	push	r28
    3106:	df 93       	push	r29
	u08 c;
	// get received char
	if(nUart==3)
    3108:	83 30       	cpi	r24, 0x03	; 3
    310a:	19 f4       	brne	.+6      	; 0x3112 <uartReceiveService+0xe>
		c = inb(UDR3);
    310c:	60 91 36 01 	lds	r22, 0x0136
    3110:	0c c0       	rjmp	.+24     	; 0x312a <uartReceiveService+0x26>
	else if(nUart==2)
    3112:	82 30       	cpi	r24, 0x02	; 2
    3114:	19 f4       	brne	.+6      	; 0x311c <uartReceiveService+0x18>
		c = inb(UDR2);
    3116:	60 91 d6 00 	lds	r22, 0x00D6
    311a:	07 c0       	rjmp	.+14     	; 0x312a <uartReceiveService+0x26>
	else if(nUart==1)
    311c:	81 30       	cpi	r24, 0x01	; 1
    311e:	19 f4       	brne	.+6      	; 0x3126 <uartReceiveService+0x22>
		c = inb(UDR1);
    3120:	60 91 ce 00 	lds	r22, 0x00CE
    3124:	02 c0       	rjmp	.+4      	; 0x312a <uartReceiveService+0x26>
	else
		c = inb(UDR0);
    3126:	60 91 c6 00 	lds	r22, 0x00C6

	// if there's a user function to handle this receive event
	if(UartRxFunc[nUart])
    312a:	28 2f       	mov	r18, r24
    312c:	30 e0       	ldi	r19, 0x00	; 0
    312e:	e9 01       	movw	r28, r18
    3130:	cc 0f       	add	r28, r28
    3132:	dd 1f       	adc	r29, r29
    3134:	fe 01       	movw	r30, r28
    3136:	e6 5a       	subi	r30, 0xA6	; 166
    3138:	fe 4e       	sbci	r31, 0xEE	; 238
    313a:	80 81       	ld	r24, Z
    313c:	91 81       	ldd	r25, Z+1	; 0x01
    313e:	89 2b       	or	r24, r25
    3140:	31 f0       	breq	.+12     	; 0x314e <uartReceiveService+0x4a>
	{
		// call it and pass the received data
		UartRxFunc[nUart](c);
    3142:	01 90       	ld	r0, Z+
    3144:	f0 81       	ld	r31, Z
    3146:	e0 2d       	mov	r30, r0
    3148:	86 2f       	mov	r24, r22
    314a:	09 95       	icall
    314c:	14 c0       	rjmp	.+40     	; 0x3176 <uartReceiveService+0x72>
	else
	{
		// otherwise do default processing
		// put received char in buffer
		// check if there's space
		if( !bufferAddToEnd(&uartRxBuffer[nUart], c) )
    314e:	93 e0       	ldi	r25, 0x03	; 3
    3150:	22 0f       	add	r18, r18
    3152:	33 1f       	adc	r19, r19
    3154:	9a 95       	dec	r25
    3156:	e1 f7       	brne	.-8      	; 0x3150 <uartReceiveService+0x4c>
    3158:	c9 01       	movw	r24, r18
    315a:	82 52       	subi	r24, 0x22	; 34
    315c:	9e 4e       	sbci	r25, 0xEE	; 238
    315e:	0e 94 8e 1c 	call	0x391c	; 0x391c <bufferAddToEnd>
    3162:	88 23       	and	r24, r24
    3164:	41 f4       	brne	.+16     	; 0x3176 <uartReceiveService+0x72>
		{
			// no space in buffer
			// count overflow
			uartRxOverflow[nUart]++;
    3166:	fe 01       	movw	r30, r28
    3168:	ee 5d       	subi	r30, 0xDE	; 222
    316a:	fd 4e       	sbci	r31, 0xED	; 237
    316c:	80 81       	ld	r24, Z
    316e:	91 81       	ldd	r25, Z+1	; 0x01
    3170:	01 96       	adiw	r24, 0x01	; 1
    3172:	91 83       	std	Z+1, r25	; 0x01
    3174:	80 83       	st	Z, r24
		}
	}
}
    3176:	df 91       	pop	r29
    3178:	cf 91       	pop	r28
    317a:	08 95       	ret

0000317c <__vector_54>:
{
	uartReceiveService(2);
}

UART_INTERRUPT_HANDLER(SIG_USART3_RECV)      
{
    317c:	1f 92       	push	r1
    317e:	0f 92       	push	r0
    3180:	0f b6       	in	r0, 0x3f	; 63
    3182:	0f 92       	push	r0
    3184:	11 24       	eor	r1, r1
    3186:	2f 93       	push	r18
    3188:	3f 93       	push	r19
    318a:	4f 93       	push	r20
    318c:	5f 93       	push	r21
    318e:	6f 93       	push	r22
    3190:	7f 93       	push	r23
    3192:	8f 93       	push	r24
    3194:	9f 93       	push	r25
    3196:	af 93       	push	r26
    3198:	bf 93       	push	r27
    319a:	ef 93       	push	r30
    319c:	ff 93       	push	r31
	uartReceiveService(3);
    319e:	83 e0       	ldi	r24, 0x03	; 3
    31a0:	0e 94 82 18 	call	0x3104	; 0x3104 <uartReceiveService>
}
    31a4:	ff 91       	pop	r31
    31a6:	ef 91       	pop	r30
    31a8:	bf 91       	pop	r27
    31aa:	af 91       	pop	r26
    31ac:	9f 91       	pop	r25
    31ae:	8f 91       	pop	r24
    31b0:	7f 91       	pop	r23
    31b2:	6f 91       	pop	r22
    31b4:	5f 91       	pop	r21
    31b6:	4f 91       	pop	r20
    31b8:	3f 91       	pop	r19
    31ba:	2f 91       	pop	r18
    31bc:	0f 90       	pop	r0
    31be:	0f be       	out	0x3f, r0	; 63
    31c0:	0f 90       	pop	r0
    31c2:	1f 90       	pop	r1
    31c4:	18 95       	reti

000031c6 <__vector_51>:
{
	uartReceiveService(1);
}

UART_INTERRUPT_HANDLER(SIG_USART2_RECV)      
{
    31c6:	1f 92       	push	r1
    31c8:	0f 92       	push	r0
    31ca:	0f b6       	in	r0, 0x3f	; 63
    31cc:	0f 92       	push	r0
    31ce:	11 24       	eor	r1, r1
    31d0:	2f 93       	push	r18
    31d2:	3f 93       	push	r19
    31d4:	4f 93       	push	r20
    31d6:	5f 93       	push	r21
    31d8:	6f 93       	push	r22
    31da:	7f 93       	push	r23
    31dc:	8f 93       	push	r24
    31de:	9f 93       	push	r25
    31e0:	af 93       	push	r26
    31e2:	bf 93       	push	r27
    31e4:	ef 93       	push	r30
    31e6:	ff 93       	push	r31
	uartReceiveService(2);
    31e8:	82 e0       	ldi	r24, 0x02	; 2
    31ea:	0e 94 82 18 	call	0x3104	; 0x3104 <uartReceiveService>
}
    31ee:	ff 91       	pop	r31
    31f0:	ef 91       	pop	r30
    31f2:	bf 91       	pop	r27
    31f4:	af 91       	pop	r26
    31f6:	9f 91       	pop	r25
    31f8:	8f 91       	pop	r24
    31fa:	7f 91       	pop	r23
    31fc:	6f 91       	pop	r22
    31fe:	5f 91       	pop	r21
    3200:	4f 91       	pop	r20
    3202:	3f 91       	pop	r19
    3204:	2f 91       	pop	r18
    3206:	0f 90       	pop	r0
    3208:	0f be       	out	0x3f, r0	; 63
    320a:	0f 90       	pop	r0
    320c:	1f 90       	pop	r1
    320e:	18 95       	reti

00003210 <__vector_36>:
{
	uartReceiveService(0);
}

UART_INTERRUPT_HANDLER(SIG_USART1_RECV)      
{
    3210:	1f 92       	push	r1
    3212:	0f 92       	push	r0
    3214:	0f b6       	in	r0, 0x3f	; 63
    3216:	0f 92       	push	r0
    3218:	11 24       	eor	r1, r1
    321a:	2f 93       	push	r18
    321c:	3f 93       	push	r19
    321e:	4f 93       	push	r20
    3220:	5f 93       	push	r21
    3222:	6f 93       	push	r22
    3224:	7f 93       	push	r23
    3226:	8f 93       	push	r24
    3228:	9f 93       	push	r25
    322a:	af 93       	push	r26
    322c:	bf 93       	push	r27
    322e:	ef 93       	push	r30
    3230:	ff 93       	push	r31
	uartReceiveService(1);
    3232:	81 e0       	ldi	r24, 0x01	; 1
    3234:	0e 94 82 18 	call	0x3104	; 0x3104 <uartReceiveService>
}
    3238:	ff 91       	pop	r31
    323a:	ef 91       	pop	r30
    323c:	bf 91       	pop	r27
    323e:	af 91       	pop	r26
    3240:	9f 91       	pop	r25
    3242:	8f 91       	pop	r24
    3244:	7f 91       	pop	r23
    3246:	6f 91       	pop	r22
    3248:	5f 91       	pop	r21
    324a:	4f 91       	pop	r20
    324c:	3f 91       	pop	r19
    324e:	2f 91       	pop	r18
    3250:	0f 90       	pop	r0
    3252:	0f be       	out	0x3f, r0	; 63
    3254:	0f 90       	pop	r0
    3256:	1f 90       	pop	r1
    3258:	18 95       	reti

0000325a <__vector_25>:
	uartTransmitService(3);
}

	// service UART receive interrupt
UART_INTERRUPT_HANDLER(SIG_USART0_RECV)      
{
    325a:	1f 92       	push	r1
    325c:	0f 92       	push	r0
    325e:	0f b6       	in	r0, 0x3f	; 63
    3260:	0f 92       	push	r0
    3262:	11 24       	eor	r1, r1
    3264:	2f 93       	push	r18
    3266:	3f 93       	push	r19
    3268:	4f 93       	push	r20
    326a:	5f 93       	push	r21
    326c:	6f 93       	push	r22
    326e:	7f 93       	push	r23
    3270:	8f 93       	push	r24
    3272:	9f 93       	push	r25
    3274:	af 93       	push	r26
    3276:	bf 93       	push	r27
    3278:	ef 93       	push	r30
    327a:	ff 93       	push	r31
	uartReceiveService(0);
    327c:	80 e0       	ldi	r24, 0x00	; 0
    327e:	0e 94 82 18 	call	0x3104	; 0x3104 <uartReceiveService>
}
    3282:	ff 91       	pop	r31
    3284:	ef 91       	pop	r30
    3286:	bf 91       	pop	r27
    3288:	af 91       	pop	r26
    328a:	9f 91       	pop	r25
    328c:	8f 91       	pop	r24
    328e:	7f 91       	pop	r23
    3290:	6f 91       	pop	r22
    3292:	5f 91       	pop	r21
    3294:	4f 91       	pop	r20
    3296:	3f 91       	pop	r19
    3298:	2f 91       	pop	r18
    329a:	0f 90       	pop	r0
    329c:	0f be       	out	0x3f, r0	; 63
    329e:	0f 90       	pop	r0
    32a0:	1f 90       	pop	r1
    32a2:	18 95       	reti

000032a4 <uartSendBuffer>:
	// send the first byte to get things going by interrupts
	uartSendByte(nUart, bufferGetFromFront(&uartTxBuffer[nUart]));
}

u08 uartSendBuffer(u08 nUart, char *buffer, u16 nBytes)
{
    32a4:	8f 92       	push	r8
    32a6:	9f 92       	push	r9
    32a8:	af 92       	push	r10
    32aa:	bf 92       	push	r11
    32ac:	cf 92       	push	r12
    32ae:	df 92       	push	r13
    32b0:	ef 92       	push	r14
    32b2:	ff 92       	push	r15
    32b4:	0f 93       	push	r16
    32b6:	1f 93       	push	r17
    32b8:	cf 93       	push	r28
    32ba:	df 93       	push	r29
    32bc:	88 2e       	mov	r8, r24
    32be:	db 01       	movw	r26, r22
	register u08 first;
	register u16 i;

	// check if there's space (and that we have any bytes to send at all)
	if((uartTxBuffer[nUart].datalength + nBytes < uartTxBuffer[nUart].size) && nBytes)
    32c0:	c8 2e       	mov	r12, r24
    32c2:	dd 24       	eor	r13, r13
    32c4:	f6 01       	movw	r30, r12
    32c6:	13 e0       	ldi	r17, 0x03	; 3
    32c8:	ee 0f       	add	r30, r30
    32ca:	ff 1f       	adc	r31, r31
    32cc:	1a 95       	dec	r17
    32ce:	e1 f7       	brne	.-8      	; 0x32c8 <uartSendBuffer+0x24>
    32d0:	ea 5f       	subi	r30, 0xFA	; 250
    32d2:	fd 4e       	sbci	r31, 0xED	; 237
    32d4:	20 81       	ld	r18, Z
    32d6:	31 81       	ldd	r19, Z+1	; 0x01
    32d8:	24 0f       	add	r18, r20
    32da:	35 1f       	adc	r19, r21
    32dc:	f6 01       	movw	r30, r12
    32de:	73 e0       	ldi	r23, 0x03	; 3
    32e0:	ee 0f       	add	r30, r30
    32e2:	ff 1f       	adc	r31, r31
    32e4:	7a 95       	dec	r23
    32e6:	e1 f7       	brne	.-8      	; 0x32e0 <uartSendBuffer+0x3c>
    32e8:	ec 5f       	subi	r30, 0xFC	; 252
    32ea:	fd 4e       	sbci	r31, 0xED	; 237
    32ec:	80 81       	ld	r24, Z
    32ee:	91 81       	ldd	r25, Z+1	; 0x01
    32f0:	28 17       	cp	r18, r24
    32f2:	39 07       	cpc	r19, r25
    32f4:	70 f5       	brcc	.+92     	; 0x3352 <uartSendBuffer+0xae>
    32f6:	41 15       	cp	r20, r1
    32f8:	51 05       	cpc	r21, r1
    32fa:	59 f1       	breq	.+86     	; 0x3352 <uartSendBuffer+0xae>
	{
		// grab first character
		first = *buffer++;
    32fc:	9c 90       	ld	r9, X
		// copy user buffer to uart transmit buffer
		for(i = 0; i < nBytes-1; i++)
		{
			// put data bytes at end of buffer
			bufferAddToEnd(&uartTxBuffer[nUart], *buffer++);
    32fe:	76 01       	movw	r14, r12
    3300:	63 e0       	ldi	r22, 0x03	; 3
    3302:	ee 0c       	add	r14, r14
    3304:	ff 1c       	adc	r15, r15
    3306:	6a 95       	dec	r22
    3308:	e1 f7       	brne	.-8      	; 0x3302 <uartSendBuffer+0x5e>
    330a:	82 e0       	ldi	r24, 0x02	; 2
    330c:	92 e1       	ldi	r25, 0x12	; 18
    330e:	e8 0e       	add	r14, r24
    3310:	f9 1e       	adc	r15, r25
    3312:	8d 01       	movw	r16, r26
    3314:	c0 e0       	ldi	r28, 0x00	; 0
    3316:	d0 e0       	ldi	r29, 0x00	; 0
	if((uartTxBuffer[nUart].datalength + nBytes < uartTxBuffer[nUart].size) && nBytes)
	{
		// grab first character
		first = *buffer++;
		// copy user buffer to uart transmit buffer
		for(i = 0; i < nBytes-1; i++)
    3318:	5a 01       	movw	r10, r20
    331a:	08 94       	sec
    331c:	a1 08       	sbc	r10, r1
    331e:	b1 08       	sbc	r11, r1
    3320:	06 c0       	rjmp	.+12     	; 0x332e <uartSendBuffer+0x8a>
    3322:	c7 01       	movw	r24, r14
    3324:	f8 01       	movw	r30, r16
    3326:	60 81       	ld	r22, Z
    3328:	0e 94 8e 1c 	call	0x391c	; 0x391c <bufferAddToEnd>
    332c:	21 96       	adiw	r28, 0x01	; 1
    332e:	0f 5f       	subi	r16, 0xFF	; 255
    3330:	1f 4f       	sbci	r17, 0xFF	; 255
    3332:	ca 15       	cp	r28, r10
    3334:	db 05       	cpc	r29, r11
    3336:	a8 f3       	brcs	.-22     	; 0x3322 <uartSendBuffer+0x7e>
			// put data bytes at end of buffer
			bufferAddToEnd(&uartTxBuffer[nUart], *buffer++);
		}

		// send the first byte to get things going by interrupts
		uartBufferedTx[nUart] = TRUE;
    3338:	8e ef       	ldi	r24, 0xFE	; 254
    333a:	91 e1       	ldi	r25, 0x11	; 17
    333c:	c8 0e       	add	r12, r24
    333e:	d9 1e       	adc	r13, r25
    3340:	8f ef       	ldi	r24, 0xFF	; 255
    3342:	f6 01       	movw	r30, r12
    3344:	80 83       	st	Z, r24
		uartSendByte(nUart, first);
    3346:	88 2d       	mov	r24, r8
    3348:	69 2d       	mov	r22, r9
    334a:	0e 94 36 18 	call	0x306c	; 0x306c <uartSendByte>
    334e:	8f ef       	ldi	r24, 0xFF	; 255
    3350:	01 c0       	rjmp	.+2      	; 0x3354 <uartSendBuffer+0xb0>
		// return success
		return TRUE;
    3352:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		// return failure
		return FALSE;
	}
}
    3354:	df 91       	pop	r29
    3356:	cf 91       	pop	r28
    3358:	1f 91       	pop	r17
    335a:	0f 91       	pop	r16
    335c:	ff 90       	pop	r15
    335e:	ef 90       	pop	r14
    3360:	df 90       	pop	r13
    3362:	cf 90       	pop	r12
    3364:	bf 90       	pop	r11
    3366:	af 90       	pop	r10
    3368:	9f 90       	pop	r9
    336a:	8f 90       	pop	r8
    336c:	08 95       	ret

0000336e <uartAddToTxBuffer>:
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    336e:	90 e0       	ldi	r25, 0x00	; 0
    3370:	23 e0       	ldi	r18, 0x03	; 3
    3372:	88 0f       	add	r24, r24
    3374:	99 1f       	adc	r25, r25
    3376:	2a 95       	dec	r18
    3378:	e1 f7       	brne	.-8      	; 0x3372 <uartAddToTxBuffer+0x4>
    337a:	8e 5f       	subi	r24, 0xFE	; 254
    337c:	9d 4e       	sbci	r25, 0xED	; 237
    337e:	0e 94 8e 1c 	call	0x391c	; 0x391c <bufferAddToEnd>
}
    3382:	08 95       	ret

00003384 <uart3AddToTxBuffer>:
{
	uartAddToTxBuffer(2,data);
}

void uart3AddToTxBuffer(u08 data)
{
    3384:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    3386:	8a e1       	ldi	r24, 0x1A	; 26
    3388:	92 e1       	ldi	r25, 0x12	; 18
    338a:	0e 94 8e 1c 	call	0x391c	; 0x391c <bufferAddToEnd>
}

void uart3AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(3,data);
}
    338e:	08 95       	ret

00003390 <uart2AddToTxBuffer>:
{
	uartAddToTxBuffer(1,data);
}

void uart2AddToTxBuffer(u08 data)
{
    3390:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    3392:	82 e1       	ldi	r24, 0x12	; 18
    3394:	92 e1       	ldi	r25, 0x12	; 18
    3396:	0e 94 8e 1c 	call	0x391c	; 0x391c <bufferAddToEnd>
}

void uart2AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(2,data);
}
    339a:	08 95       	ret

0000339c <uart1AddToTxBuffer>:
{
	uartAddToTxBuffer(0,data);
}

void uart1AddToTxBuffer(u08 data)
{
    339c:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    339e:	8a e0       	ldi	r24, 0x0A	; 10
    33a0:	92 e1       	ldi	r25, 0x12	; 18
    33a2:	0e 94 8e 1c 	call	0x391c	; 0x391c <bufferAddToEnd>
}

void uart1AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(1,data);
}
    33a6:	08 95       	ret

000033a8 <uart0AddToTxBuffer>:
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
}

void uart0AddToTxBuffer(u08 data)
{
    33a8:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    33aa:	82 e0       	ldi	r24, 0x02	; 2
    33ac:	92 e1       	ldi	r25, 0x12	; 18
    33ae:	0e 94 8e 1c 	call	0x391c	; 0x391c <bufferAddToEnd>
}

void uart0AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(0,data);
}
    33b2:	08 95       	ret

000033b4 <uartTransmitService>:
	}
}

// UART Transmit Complete Interrupt Function
void uartTransmitService(u08 nUart)
{
    33b4:	cf 93       	push	r28
    33b6:	df 93       	push	r29
    33b8:	28 2f       	mov	r18, r24
	// check if buffered tx is enabled
	if(uartBufferedTx[nUart])
    33ba:	a8 2f       	mov	r26, r24
    33bc:	b0 e0       	ldi	r27, 0x00	; 0
    33be:	ed 01       	movw	r28, r26
    33c0:	c2 50       	subi	r28, 0x02	; 2
    33c2:	de 4e       	sbci	r29, 0xEE	; 238
    33c4:	88 81       	ld	r24, Y
    33c6:	88 23       	and	r24, r24
    33c8:	79 f1       	breq	.+94     	; 0x3428 <uartTransmitService+0x74>
	{
		// check if there's data left in the buffer
		if(uartTxBuffer[nUart].datalength)
    33ca:	fd 01       	movw	r30, r26
    33cc:	33 e0       	ldi	r19, 0x03	; 3
    33ce:	ee 0f       	add	r30, r30
    33d0:	ff 1f       	adc	r31, r31
    33d2:	3a 95       	dec	r19
    33d4:	e1 f7       	brne	.-8      	; 0x33ce <uartTransmitService+0x1a>
    33d6:	ea 5f       	subi	r30, 0xFA	; 250
    33d8:	fd 4e       	sbci	r31, 0xED	; 237
    33da:	80 81       	ld	r24, Z
    33dc:	91 81       	ldd	r25, Z+1	; 0x01
    33de:	89 2b       	or	r24, r25
    33e0:	11 f1       	breq	.+68     	; 0x3426 <uartTransmitService+0x72>
		{
			// send byte from top of buffer
			if(nUart==3)
    33e2:	23 30       	cpi	r18, 0x03	; 3
    33e4:	39 f4       	brne	.+14     	; 0x33f4 <uartTransmitService+0x40>
				outb(UDR3,  bufferGetFromFront(&uartTxBuffer[3]) );
    33e6:	8a e1       	ldi	r24, 0x1A	; 26
    33e8:	92 e1       	ldi	r25, 0x12	; 18
    33ea:	0e 94 25 1c 	call	0x384a	; 0x384a <bufferGetFromFront>
    33ee:	80 93 36 01 	sts	0x0136, r24
    33f2:	1e c0       	rjmp	.+60     	; 0x3430 <uartTransmitService+0x7c>
			else if(nUart==2)
    33f4:	22 30       	cpi	r18, 0x02	; 2
    33f6:	39 f4       	brne	.+14     	; 0x3406 <uartTransmitService+0x52>
				outb(UDR2,  bufferGetFromFront(&uartTxBuffer[2]) );
    33f8:	82 e1       	ldi	r24, 0x12	; 18
    33fa:	92 e1       	ldi	r25, 0x12	; 18
    33fc:	0e 94 25 1c 	call	0x384a	; 0x384a <bufferGetFromFront>
    3400:	80 93 d6 00 	sts	0x00D6, r24
    3404:	15 c0       	rjmp	.+42     	; 0x3430 <uartTransmitService+0x7c>
			else if(nUart==1)
    3406:	21 30       	cpi	r18, 0x01	; 1
    3408:	39 f4       	brne	.+14     	; 0x3418 <uartTransmitService+0x64>
				outb(UDR1,  bufferGetFromFront(&uartTxBuffer[1]) );
    340a:	8a e0       	ldi	r24, 0x0A	; 10
    340c:	92 e1       	ldi	r25, 0x12	; 18
    340e:	0e 94 25 1c 	call	0x384a	; 0x384a <bufferGetFromFront>
    3412:	80 93 ce 00 	sts	0x00CE, r24
    3416:	0c c0       	rjmp	.+24     	; 0x3430 <uartTransmitService+0x7c>
			else
				outb(UDR0,  bufferGetFromFront(&uartTxBuffer[0]) );
    3418:	82 e0       	ldi	r24, 0x02	; 2
    341a:	92 e1       	ldi	r25, 0x12	; 18
    341c:	0e 94 25 1c 	call	0x384a	; 0x384a <bufferGetFromFront>
    3420:	80 93 c6 00 	sts	0x00C6, r24
    3424:	05 c0       	rjmp	.+10     	; 0x3430 <uartTransmitService+0x7c>
		}
		else
		{
			// no data left
			uartBufferedTx[nUart] = FALSE;
    3426:	18 82       	st	Y, r1
	}
	else
	{
		// we're using single-byte tx mode
		// indicate transmit complete, back to ready
		uartReadyTx[nUart] = TRUE;
    3428:	a6 52       	subi	r26, 0x26	; 38
    342a:	be 4e       	sbci	r27, 0xEE	; 238
    342c:	8f ef       	ldi	r24, 0xFF	; 255
    342e:	8c 93       	st	X, r24
	}
}
    3430:	df 91       	pop	r29
    3432:	cf 91       	pop	r28
    3434:	08 95       	ret

00003436 <__vector_56>:
{
	uartTransmitService(2);
}

UART_INTERRUPT_HANDLER(SIG_USART3_TRANS)      
{
    3436:	1f 92       	push	r1
    3438:	0f 92       	push	r0
    343a:	0f b6       	in	r0, 0x3f	; 63
    343c:	0f 92       	push	r0
    343e:	11 24       	eor	r1, r1
    3440:	2f 93       	push	r18
    3442:	3f 93       	push	r19
    3444:	4f 93       	push	r20
    3446:	5f 93       	push	r21
    3448:	6f 93       	push	r22
    344a:	7f 93       	push	r23
    344c:	8f 93       	push	r24
    344e:	9f 93       	push	r25
    3450:	af 93       	push	r26
    3452:	bf 93       	push	r27
    3454:	ef 93       	push	r30
    3456:	ff 93       	push	r31
	uartTransmitService(3);
    3458:	83 e0       	ldi	r24, 0x03	; 3
    345a:	0e 94 da 19 	call	0x33b4	; 0x33b4 <uartTransmitService>
}
    345e:	ff 91       	pop	r31
    3460:	ef 91       	pop	r30
    3462:	bf 91       	pop	r27
    3464:	af 91       	pop	r26
    3466:	9f 91       	pop	r25
    3468:	8f 91       	pop	r24
    346a:	7f 91       	pop	r23
    346c:	6f 91       	pop	r22
    346e:	5f 91       	pop	r21
    3470:	4f 91       	pop	r20
    3472:	3f 91       	pop	r19
    3474:	2f 91       	pop	r18
    3476:	0f 90       	pop	r0
    3478:	0f be       	out	0x3f, r0	; 63
    347a:	0f 90       	pop	r0
    347c:	1f 90       	pop	r1
    347e:	18 95       	reti

00003480 <__vector_53>:
{
	uartTransmitService(1);
}

UART_INTERRUPT_HANDLER(SIG_USART2_TRANS)      
{
    3480:	1f 92       	push	r1
    3482:	0f 92       	push	r0
    3484:	0f b6       	in	r0, 0x3f	; 63
    3486:	0f 92       	push	r0
    3488:	11 24       	eor	r1, r1
    348a:	2f 93       	push	r18
    348c:	3f 93       	push	r19
    348e:	4f 93       	push	r20
    3490:	5f 93       	push	r21
    3492:	6f 93       	push	r22
    3494:	7f 93       	push	r23
    3496:	8f 93       	push	r24
    3498:	9f 93       	push	r25
    349a:	af 93       	push	r26
    349c:	bf 93       	push	r27
    349e:	ef 93       	push	r30
    34a0:	ff 93       	push	r31
	uartTransmitService(2);
    34a2:	82 e0       	ldi	r24, 0x02	; 2
    34a4:	0e 94 da 19 	call	0x33b4	; 0x33b4 <uartTransmitService>
}
    34a8:	ff 91       	pop	r31
    34aa:	ef 91       	pop	r30
    34ac:	bf 91       	pop	r27
    34ae:	af 91       	pop	r26
    34b0:	9f 91       	pop	r25
    34b2:	8f 91       	pop	r24
    34b4:	7f 91       	pop	r23
    34b6:	6f 91       	pop	r22
    34b8:	5f 91       	pop	r21
    34ba:	4f 91       	pop	r20
    34bc:	3f 91       	pop	r19
    34be:	2f 91       	pop	r18
    34c0:	0f 90       	pop	r0
    34c2:	0f be       	out	0x3f, r0	; 63
    34c4:	0f 90       	pop	r0
    34c6:	1f 90       	pop	r1
    34c8:	18 95       	reti

000034ca <__vector_38>:
{
	uartTransmitService(0);
}

UART_INTERRUPT_HANDLER(SIG_USART1_TRANS)      
{
    34ca:	1f 92       	push	r1
    34cc:	0f 92       	push	r0
    34ce:	0f b6       	in	r0, 0x3f	; 63
    34d0:	0f 92       	push	r0
    34d2:	11 24       	eor	r1, r1
    34d4:	2f 93       	push	r18
    34d6:	3f 93       	push	r19
    34d8:	4f 93       	push	r20
    34da:	5f 93       	push	r21
    34dc:	6f 93       	push	r22
    34de:	7f 93       	push	r23
    34e0:	8f 93       	push	r24
    34e2:	9f 93       	push	r25
    34e4:	af 93       	push	r26
    34e6:	bf 93       	push	r27
    34e8:	ef 93       	push	r30
    34ea:	ff 93       	push	r31
	uartTransmitService(1);
    34ec:	81 e0       	ldi	r24, 0x01	; 1
    34ee:	0e 94 da 19 	call	0x33b4	; 0x33b4 <uartTransmitService>
}
    34f2:	ff 91       	pop	r31
    34f4:	ef 91       	pop	r30
    34f6:	bf 91       	pop	r27
    34f8:	af 91       	pop	r26
    34fa:	9f 91       	pop	r25
    34fc:	8f 91       	pop	r24
    34fe:	7f 91       	pop	r23
    3500:	6f 91       	pop	r22
    3502:	5f 91       	pop	r21
    3504:	4f 91       	pop	r20
    3506:	3f 91       	pop	r19
    3508:	2f 91       	pop	r18
    350a:	0f 90       	pop	r0
    350c:	0f be       	out	0x3f, r0	; 63
    350e:	0f 90       	pop	r0
    3510:	1f 90       	pop	r1
    3512:	18 95       	reti

00003514 <__vector_27>:
	}
}

	// service UART transmit interrupt
UART_INTERRUPT_HANDLER(SIG_USART0_TRANS)      
{
    3514:	1f 92       	push	r1
    3516:	0f 92       	push	r0
    3518:	0f b6       	in	r0, 0x3f	; 63
    351a:	0f 92       	push	r0
    351c:	11 24       	eor	r1, r1
    351e:	2f 93       	push	r18
    3520:	3f 93       	push	r19
    3522:	4f 93       	push	r20
    3524:	5f 93       	push	r21
    3526:	6f 93       	push	r22
    3528:	7f 93       	push	r23
    352a:	8f 93       	push	r24
    352c:	9f 93       	push	r25
    352e:	af 93       	push	r26
    3530:	bf 93       	push	r27
    3532:	ef 93       	push	r30
    3534:	ff 93       	push	r31
	uartTransmitService(0);
    3536:	80 e0       	ldi	r24, 0x00	; 0
    3538:	0e 94 da 19 	call	0x33b4	; 0x33b4 <uartTransmitService>
}
    353c:	ff 91       	pop	r31
    353e:	ef 91       	pop	r30
    3540:	bf 91       	pop	r27
    3542:	af 91       	pop	r26
    3544:	9f 91       	pop	r25
    3546:	8f 91       	pop	r24
    3548:	7f 91       	pop	r23
    354a:	6f 91       	pop	r22
    354c:	5f 91       	pop	r21
    354e:	4f 91       	pop	r20
    3550:	3f 91       	pop	r19
    3552:	2f 91       	pop	r18
    3554:	0f 90       	pop	r0
    3556:	0f be       	out	0x3f, r0	; 63
    3558:	0f 90       	pop	r0
    355a:	1f 90       	pop	r1
    355c:	18 95       	reti

0000355e <uartSendTxBuffer>:
{
	uartAddToTxBuffer(3,data);
}

void uartSendTxBuffer(u08 nUart)
{
    355e:	1f 93       	push	r17
    3560:	18 2f       	mov	r17, r24
	// turn on buffered transmit
	uartBufferedTx[nUart] = TRUE;
    3562:	90 e0       	ldi	r25, 0x00	; 0
    3564:	fc 01       	movw	r30, r24
    3566:	e2 50       	subi	r30, 0x02	; 2
    3568:	fe 4e       	sbci	r31, 0xEE	; 238
    356a:	2f ef       	ldi	r18, 0xFF	; 255
    356c:	20 83       	st	Z, r18
	// send the first byte to get things going by interrupts
	uartSendByte(nUart, bufferGetFromFront(&uartTxBuffer[nUart]));
    356e:	43 e0       	ldi	r20, 0x03	; 3
    3570:	88 0f       	add	r24, r24
    3572:	99 1f       	adc	r25, r25
    3574:	4a 95       	dec	r20
    3576:	e1 f7       	brne	.-8      	; 0x3570 <uartSendTxBuffer+0x12>
    3578:	8e 5f       	subi	r24, 0xFE	; 254
    357a:	9d 4e       	sbci	r25, 0xED	; 237
    357c:	0e 94 25 1c 	call	0x384a	; 0x384a <bufferGetFromFront>
    3580:	68 2f       	mov	r22, r24
    3582:	81 2f       	mov	r24, r17
    3584:	0e 94 36 18 	call	0x306c	; 0x306c <uartSendByte>
}
    3588:	1f 91       	pop	r17
    358a:	08 95       	ret

0000358c <uartReceiveByte>:
		return -1;
}


u08 uartReceiveByte(u08 nUart, u08* rxData)
{
    358c:	cf 93       	push	r28
    358e:	df 93       	push	r29
    3590:	eb 01       	movw	r28, r22
	// make sure we have a receive buffer
	if(uartRxBuffer[nUart].size)
    3592:	28 2f       	mov	r18, r24
    3594:	30 e0       	ldi	r19, 0x00	; 0
    3596:	f9 01       	movw	r30, r18
    3598:	73 e0       	ldi	r23, 0x03	; 3
    359a:	ee 0f       	add	r30, r30
    359c:	ff 1f       	adc	r31, r31
    359e:	7a 95       	dec	r23
    35a0:	e1 f7       	brne	.-8      	; 0x359a <uartReceiveByte+0xe>
    35a2:	e0 52       	subi	r30, 0x20	; 32
    35a4:	fe 4e       	sbci	r31, 0xEE	; 238
    35a6:	80 81       	ld	r24, Z
    35a8:	91 81       	ldd	r25, Z+1	; 0x01
    35aa:	89 2b       	or	r24, r25
    35ac:	c9 f0       	breq	.+50     	; 0x35e0 <uartReceiveByte+0x54>
	{
		// make sure we have data
		if(uartRxBuffer[nUart].datalength)
    35ae:	f9 01       	movw	r30, r18
    35b0:	63 e0       	ldi	r22, 0x03	; 3
    35b2:	ee 0f       	add	r30, r30
    35b4:	ff 1f       	adc	r31, r31
    35b6:	6a 95       	dec	r22
    35b8:	e1 f7       	brne	.-8      	; 0x35b2 <uartReceiveByte+0x26>
    35ba:	ee 51       	subi	r30, 0x1E	; 30
    35bc:	fe 4e       	sbci	r31, 0xEE	; 238
    35be:	80 81       	ld	r24, Z
    35c0:	91 81       	ldd	r25, Z+1	; 0x01
    35c2:	89 2b       	or	r24, r25
    35c4:	69 f0       	breq	.+26     	; 0x35e0 <uartReceiveByte+0x54>
		{
			// get byte from beginning of buffer
			*rxData = bufferGetFromFront(&uartRxBuffer[nUart]);
    35c6:	53 e0       	ldi	r21, 0x03	; 3
    35c8:	22 0f       	add	r18, r18
    35ca:	33 1f       	adc	r19, r19
    35cc:	5a 95       	dec	r21
    35ce:	e1 f7       	brne	.-8      	; 0x35c8 <uartReceiveByte+0x3c>
    35d0:	c9 01       	movw	r24, r18
    35d2:	82 52       	subi	r24, 0x22	; 34
    35d4:	9e 4e       	sbci	r25, 0xEE	; 238
    35d6:	0e 94 25 1c 	call	0x384a	; 0x384a <bufferGetFromFront>
    35da:	88 83       	st	Y, r24
    35dc:	8f ef       	ldi	r24, 0xFF	; 255
    35de:	01 c0       	rjmp	.+2      	; 0x35e2 <uartReceiveByte+0x56>
			return TRUE;
    35e0:	80 e0       	ldi	r24, 0x00	; 0
		else
			return FALSE;			// no data
	}
	else
		return FALSE;				// no buffer
}
    35e2:	df 91       	pop	r29
    35e4:	cf 91       	pop	r28
    35e6:	08 95       	ret

000035e8 <uart3GetByte>:
	else
		return -1;
}

int uart3GetByte(void)
{
    35e8:	df 93       	push	r29
    35ea:	cf 93       	push	r28
    35ec:	0f 92       	push	r0
    35ee:	cd b7       	in	r28, 0x3d	; 61
    35f0:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(3,&c))
    35f2:	83 e0       	ldi	r24, 0x03	; 3
    35f4:	be 01       	movw	r22, r28
    35f6:	6f 5f       	subi	r22, 0xFF	; 255
    35f8:	7f 4f       	sbci	r23, 0xFF	; 255
    35fa:	0e 94 c6 1a 	call	0x358c	; 0x358c <uartReceiveByte>
    35fe:	88 23       	and	r24, r24
    3600:	19 f4       	brne	.+6      	; 0x3608 <uart3GetByte+0x20>
    3602:	2f ef       	ldi	r18, 0xFF	; 255
    3604:	3f ef       	ldi	r19, 0xFF	; 255
    3606:	03 c0       	rjmp	.+6      	; 0x360e <uart3GetByte+0x26>
		return c;
    3608:	89 81       	ldd	r24, Y+1	; 0x01
    360a:	28 2f       	mov	r18, r24
    360c:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    360e:	c9 01       	movw	r24, r18
    3610:	0f 90       	pop	r0
    3612:	cf 91       	pop	r28
    3614:	df 91       	pop	r29
    3616:	08 95       	ret

00003618 <uart2GetByte>:
	else
		return -1;
}

int uart2GetByte(void)
{
    3618:	df 93       	push	r29
    361a:	cf 93       	push	r28
    361c:	0f 92       	push	r0
    361e:	cd b7       	in	r28, 0x3d	; 61
    3620:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(2,&c))
    3622:	82 e0       	ldi	r24, 0x02	; 2
    3624:	be 01       	movw	r22, r28
    3626:	6f 5f       	subi	r22, 0xFF	; 255
    3628:	7f 4f       	sbci	r23, 0xFF	; 255
    362a:	0e 94 c6 1a 	call	0x358c	; 0x358c <uartReceiveByte>
    362e:	88 23       	and	r24, r24
    3630:	19 f4       	brne	.+6      	; 0x3638 <uart2GetByte+0x20>
    3632:	2f ef       	ldi	r18, 0xFF	; 255
    3634:	3f ef       	ldi	r19, 0xFF	; 255
    3636:	03 c0       	rjmp	.+6      	; 0x363e <uart2GetByte+0x26>
		return c;
    3638:	89 81       	ldd	r24, Y+1	; 0x01
    363a:	28 2f       	mov	r18, r24
    363c:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    363e:	c9 01       	movw	r24, r18
    3640:	0f 90       	pop	r0
    3642:	cf 91       	pop	r28
    3644:	df 91       	pop	r29
    3646:	08 95       	ret

00003648 <uart1GetByte>:
	else
		return -1;
}

int uart1GetByte(void)
{
    3648:	df 93       	push	r29
    364a:	cf 93       	push	r28
    364c:	0f 92       	push	r0
    364e:	cd b7       	in	r28, 0x3d	; 61
    3650:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(1,&c))
    3652:	81 e0       	ldi	r24, 0x01	; 1
    3654:	be 01       	movw	r22, r28
    3656:	6f 5f       	subi	r22, 0xFF	; 255
    3658:	7f 4f       	sbci	r23, 0xFF	; 255
    365a:	0e 94 c6 1a 	call	0x358c	; 0x358c <uartReceiveByte>
    365e:	88 23       	and	r24, r24
    3660:	19 f4       	brne	.+6      	; 0x3668 <uart1GetByte+0x20>
    3662:	2f ef       	ldi	r18, 0xFF	; 255
    3664:	3f ef       	ldi	r19, 0xFF	; 255
    3666:	03 c0       	rjmp	.+6      	; 0x366e <uart1GetByte+0x26>
		return c;
    3668:	89 81       	ldd	r24, Y+1	; 0x01
    366a:	28 2f       	mov	r18, r24
    366c:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    366e:	c9 01       	movw	r24, r18
    3670:	0f 90       	pop	r0
    3672:	cf 91       	pop	r28
    3674:	df 91       	pop	r29
    3676:	08 95       	ret

00003678 <uart0GetByte>:
	// send byte on UART3
	uartSendByte(3, data);
}

int uart0GetByte(void)
{
    3678:	df 93       	push	r29
    367a:	cf 93       	push	r28
    367c:	0f 92       	push	r0
    367e:	cd b7       	in	r28, 0x3d	; 61
    3680:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(0,&c))
    3682:	80 e0       	ldi	r24, 0x00	; 0
    3684:	be 01       	movw	r22, r28
    3686:	6f 5f       	subi	r22, 0xFF	; 255
    3688:	7f 4f       	sbci	r23, 0xFF	; 255
    368a:	0e 94 c6 1a 	call	0x358c	; 0x358c <uartReceiveByte>
    368e:	88 23       	and	r24, r24
    3690:	19 f4       	brne	.+6      	; 0x3698 <uart0GetByte+0x20>
    3692:	2f ef       	ldi	r18, 0xFF	; 255
    3694:	3f ef       	ldi	r19, 0xFF	; 255
    3696:	03 c0       	rjmp	.+6      	; 0x369e <uart0GetByte+0x26>
		return c;
    3698:	89 81       	ldd	r24, Y+1	; 0x01
    369a:	28 2f       	mov	r18, r24
    369c:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    369e:	c9 01       	movw	r24, r18
    36a0:	0f 90       	pop	r0
    36a2:	cf 91       	pop	r28
    36a4:	df 91       	pop	r29
    36a6:	08 95       	ret

000036a8 <uartFlushReceiveBuffer>:
}

void uartFlushReceiveBuffer(u08 nUart)
{
	// flush all data from receive buffer
	bufferFlush(&uartRxBuffer[nUart]);
    36a8:	90 e0       	ldi	r25, 0x00	; 0
    36aa:	e3 e0       	ldi	r30, 0x03	; 3
    36ac:	88 0f       	add	r24, r24
    36ae:	99 1f       	adc	r25, r25
    36b0:	ea 95       	dec	r30
    36b2:	e1 f7       	brne	.-8      	; 0x36ac <uartFlushReceiveBuffer+0x4>
    36b4:	82 52       	subi	r24, 0x22	; 34
    36b6:	9e 4e       	sbci	r25, 0xEE	; 238
    36b8:	0e 94 c1 1c 	call	0x3982	; 0x3982 <bufferFlush>
}
    36bc:	08 95       	ret

000036be <uart3InitBuffers>:

void uart3InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART3 buffers
		bufferInit(&uartRxBuffer[3], (u08*) uart3RxData, UART3_RX_BUFFER_SIZE);
    36be:	86 ef       	ldi	r24, 0xF6	; 246
    36c0:	91 e1       	ldi	r25, 0x11	; 17
    36c2:	6a ec       	ldi	r22, 0xCA	; 202
    36c4:	70 e1       	ldi	r23, 0x10	; 16
    36c6:	40 e8       	ldi	r20, 0x80	; 128
    36c8:	50 e0       	ldi	r21, 0x00	; 0
    36ca:	0e 94 18 1c 	call	0x3830	; 0x3830 <bufferInit>
		bufferInit(&uartTxBuffer[3], (u08*) uart3TxData, UART3_TX_BUFFER_SIZE);
    36ce:	8a e1       	ldi	r24, 0x1A	; 26
    36d0:	92 e1       	ldi	r25, 0x12	; 18
    36d2:	6a e4       	ldi	r22, 0x4A	; 74
    36d4:	71 e1       	ldi	r23, 0x11	; 17
    36d6:	40 e1       	ldi	r20, 0x10	; 16
    36d8:	50 e0       	ldi	r21, 0x00	; 0
    36da:	0e 94 18 1c 	call	0x3830	; 0x3830 <bufferInit>
	#else
		// initialize the UART3 buffers
		bufferInit(&uartRxBuffer[3], (u08*) UART3_RX_BUFFER_ADDR, UART3_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[3], (u08*) UART3_TX_BUFFER_ADDR, UART3_TX_BUFFER_SIZE);
	#endif
}
    36de:	08 95       	ret

000036e0 <uart3Init>:
}

void uart3Init(void)
{
	// initialize the buffers
	uart3InitBuffers();
    36e0:	0e 94 5f 1b 	call	0x36be	; 0x36be <uart3InitBuffers>
	// initialize user receive handlers
	UartRxFunc[3] = 0;
    36e4:	10 92 61 11 	sts	0x1161, r1
    36e8:	10 92 60 11 	sts	0x1160, r1
	// enable RxD/TxD and interrupts
	outb(UCSR3B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    36ec:	88 ed       	ldi	r24, 0xD8	; 216
    36ee:	80 93 31 01 	sts	0x0131, r24
	// set default baud rate
	uartSetBaudRate(3, UART3_DEFAULT_BAUD_RATE);
    36f2:	83 e0       	ldi	r24, 0x03	; 3
    36f4:	40 e8       	ldi	r20, 0x80	; 128
    36f6:	55 e2       	ldi	r21, 0x25	; 37
    36f8:	60 e0       	ldi	r22, 0x00	; 0
    36fa:	70 e0       	ldi	r23, 0x00	; 0
    36fc:	0e 94 e9 17 	call	0x2fd2	; 0x2fd2 <uartSetBaudRate>
	// initialize states
	uartReadyTx[3] = TRUE;
    3700:	8f ef       	ldi	r24, 0xFF	; 255
    3702:	80 93 dd 11 	sts	0x11DD, r24
	uartBufferedTx[3] = FALSE;
    3706:	10 92 01 12 	sts	0x1201, r1
	// clear overflow count
	uartRxOverflow[3] = 0;
    370a:	10 92 29 12 	sts	0x1229, r1
    370e:	10 92 28 12 	sts	0x1228, r1
	// enable interrupts
	sei();
    3712:	78 94       	sei
}
    3714:	08 95       	ret

00003716 <uart2InitBuffers>:

void uart2InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART2 buffers
		bufferInit(&uartRxBuffer[2], (u08*) uart2RxData, UART2_RX_BUFFER_SIZE);
    3716:	8e ee       	ldi	r24, 0xEE	; 238
    3718:	91 e1       	ldi	r25, 0x11	; 17
    371a:	6a e3       	ldi	r22, 0x3A	; 58
    371c:	70 e1       	ldi	r23, 0x10	; 16
    371e:	40 e8       	ldi	r20, 0x80	; 128
    3720:	50 e0       	ldi	r21, 0x00	; 0
    3722:	0e 94 18 1c 	call	0x3830	; 0x3830 <bufferInit>
		bufferInit(&uartTxBuffer[2], (u08*) uart2TxData, UART2_TX_BUFFER_SIZE);
    3726:	82 e1       	ldi	r24, 0x12	; 18
    3728:	92 e1       	ldi	r25, 0x12	; 18
    372a:	6a eb       	ldi	r22, 0xBA	; 186
    372c:	70 e1       	ldi	r23, 0x10	; 16
    372e:	40 e1       	ldi	r20, 0x10	; 16
    3730:	50 e0       	ldi	r21, 0x00	; 0
    3732:	0e 94 18 1c 	call	0x3830	; 0x3830 <bufferInit>
	#else
		// initialize the UART2 buffers
		bufferInit(&uartRxBuffer[2], (u08*) UART2_RX_BUFFER_ADDR, UART2_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[2], (u08*) UART2_TX_BUFFER_ADDR, UART2_TX_BUFFER_SIZE);
	#endif
}
    3736:	08 95       	ret

00003738 <uart2Init>:
}

void uart2Init(void)
{
	// initialize the buffers
	uart2InitBuffers();
    3738:	0e 94 8b 1b 	call	0x3716	; 0x3716 <uart2InitBuffers>
	// initialize user receive handlers
	UartRxFunc[2] = 0;
    373c:	10 92 5f 11 	sts	0x115F, r1
    3740:	10 92 5e 11 	sts	0x115E, r1
	// enable RxD/TxD and interrupts
	outb(UCSR2B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    3744:	88 ed       	ldi	r24, 0xD8	; 216
    3746:	80 93 d1 00 	sts	0x00D1, r24
	// set default baud rate
	uartSetBaudRate(2, UART2_DEFAULT_BAUD_RATE);
    374a:	82 e0       	ldi	r24, 0x02	; 2
    374c:	40 e8       	ldi	r20, 0x80	; 128
    374e:	55 e2       	ldi	r21, 0x25	; 37
    3750:	60 e0       	ldi	r22, 0x00	; 0
    3752:	70 e0       	ldi	r23, 0x00	; 0
    3754:	0e 94 e9 17 	call	0x2fd2	; 0x2fd2 <uartSetBaudRate>
	// initialize states
	uartReadyTx[2] = TRUE;
    3758:	8f ef       	ldi	r24, 0xFF	; 255
    375a:	80 93 dc 11 	sts	0x11DC, r24
	uartBufferedTx[2] = FALSE;
    375e:	10 92 00 12 	sts	0x1200, r1
	// clear overflow count
	uartRxOverflow[2] = 0;
    3762:	10 92 27 12 	sts	0x1227, r1
    3766:	10 92 26 12 	sts	0x1226, r1
	// enable interrupts
	sei();
    376a:	78 94       	sei
}
    376c:	08 95       	ret

0000376e <uart1InitBuffers>:

void uart1InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART1 buffers
		bufferInit(&uartRxBuffer[1], (u08*) uart1RxData, UART1_RX_BUFFER_SIZE);
    376e:	86 ee       	ldi	r24, 0xE6	; 230
    3770:	91 e1       	ldi	r25, 0x11	; 17
    3772:	6a ea       	ldi	r22, 0xAA	; 170
    3774:	7f e0       	ldi	r23, 0x0F	; 15
    3776:	40 e8       	ldi	r20, 0x80	; 128
    3778:	50 e0       	ldi	r21, 0x00	; 0
    377a:	0e 94 18 1c 	call	0x3830	; 0x3830 <bufferInit>
		bufferInit(&uartTxBuffer[1], (u08*) uart1TxData, UART1_TX_BUFFER_SIZE);
    377e:	8a e0       	ldi	r24, 0x0A	; 10
    3780:	92 e1       	ldi	r25, 0x12	; 18
    3782:	6a e2       	ldi	r22, 0x2A	; 42
    3784:	70 e1       	ldi	r23, 0x10	; 16
    3786:	40 e1       	ldi	r20, 0x10	; 16
    3788:	50 e0       	ldi	r21, 0x00	; 0
    378a:	0e 94 18 1c 	call	0x3830	; 0x3830 <bufferInit>
	#else
		// initialize the UART1 buffers
		bufferInit(&uartRxBuffer[1], (u08*) UART1_RX_BUFFER_ADDR, UART1_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[1], (u08*) UART1_TX_BUFFER_ADDR, UART1_TX_BUFFER_SIZE);
	#endif
}
    378e:	08 95       	ret

00003790 <uart1Init>:
}

void uart1Init(void)
{
	// initialize the buffers
	uart1InitBuffers();
    3790:	0e 94 b7 1b 	call	0x376e	; 0x376e <uart1InitBuffers>
	// initialize user receive handlers
	UartRxFunc[1] = 0;
    3794:	10 92 5d 11 	sts	0x115D, r1
    3798:	10 92 5c 11 	sts	0x115C, r1
	// enable RxD/TxD and interrupts
	outb(UCSR1B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    379c:	88 ed       	ldi	r24, 0xD8	; 216
    379e:	80 93 c9 00 	sts	0x00C9, r24
	// set default baud rate
	uartSetBaudRate(1, UART1_DEFAULT_BAUD_RATE);
    37a2:	81 e0       	ldi	r24, 0x01	; 1
    37a4:	40 e8       	ldi	r20, 0x80	; 128
    37a6:	55 e2       	ldi	r21, 0x25	; 37
    37a8:	60 e0       	ldi	r22, 0x00	; 0
    37aa:	70 e0       	ldi	r23, 0x00	; 0
    37ac:	0e 94 e9 17 	call	0x2fd2	; 0x2fd2 <uartSetBaudRate>
	// initialize states
	uartReadyTx[1] = TRUE;
    37b0:	8f ef       	ldi	r24, 0xFF	; 255
    37b2:	80 93 db 11 	sts	0x11DB, r24
	uartBufferedTx[1] = FALSE;
    37b6:	10 92 ff 11 	sts	0x11FF, r1
	// clear overflow count
	uartRxOverflow[1] = 0;
    37ba:	10 92 25 12 	sts	0x1225, r1
    37be:	10 92 24 12 	sts	0x1224, r1
	// enable interrupts
	sei();
    37c2:	78 94       	sei
}
    37c4:	08 95       	ret

000037c6 <uart0InitBuffers>:

void uart0InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART0 buffers
		bufferInit(&uartRxBuffer[0], (u08*) uart0RxData, UART0_RX_BUFFER_SIZE);
    37c6:	8e ed       	ldi	r24, 0xDE	; 222
    37c8:	91 e1       	ldi	r25, 0x11	; 17
    37ca:	6a e1       	ldi	r22, 0x1A	; 26
    37cc:	7f e0       	ldi	r23, 0x0F	; 15
    37ce:	40 e8       	ldi	r20, 0x80	; 128
    37d0:	50 e0       	ldi	r21, 0x00	; 0
    37d2:	0e 94 18 1c 	call	0x3830	; 0x3830 <bufferInit>
		bufferInit(&uartTxBuffer[0], (u08*) uart0TxData, UART0_TX_BUFFER_SIZE);
    37d6:	82 e0       	ldi	r24, 0x02	; 2
    37d8:	92 e1       	ldi	r25, 0x12	; 18
    37da:	6a e9       	ldi	r22, 0x9A	; 154
    37dc:	7f e0       	ldi	r23, 0x0F	; 15
    37de:	40 e1       	ldi	r20, 0x10	; 16
    37e0:	50 e0       	ldi	r21, 0x00	; 0
    37e2:	0e 94 18 1c 	call	0x3830	; 0x3830 <bufferInit>
	#else
		// initialize the UART0 buffers
		bufferInit(&uartRxBuffer[0], (u08*) UART0_RX_BUFFER_ADDR, UART0_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[0], (u08*) UART0_TX_BUFFER_ADDR, UART0_TX_BUFFER_SIZE);
	#endif
}
    37e6:	08 95       	ret

000037e8 <uart0Init>:
}

void uart0Init(void)
{
	// initialize the buffers
	uart0InitBuffers();
    37e8:	0e 94 e3 1b 	call	0x37c6	; 0x37c6 <uart0InitBuffers>
	// initialize user receive handlers
	UartRxFunc[0] = 0;
    37ec:	10 92 5b 11 	sts	0x115B, r1
    37f0:	10 92 5a 11 	sts	0x115A, r1
	// enable RxD/TxD and interrupts
	outb(UCSR0B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    37f4:	88 ed       	ldi	r24, 0xD8	; 216
    37f6:	80 93 c1 00 	sts	0x00C1, r24
	// set default baud rate
	uartSetBaudRate(0, UART0_DEFAULT_BAUD_RATE); 
    37fa:	80 e0       	ldi	r24, 0x00	; 0
    37fc:	40 e8       	ldi	r20, 0x80	; 128
    37fe:	55 e2       	ldi	r21, 0x25	; 37
    3800:	60 e0       	ldi	r22, 0x00	; 0
    3802:	70 e0       	ldi	r23, 0x00	; 0
    3804:	0e 94 e9 17 	call	0x2fd2	; 0x2fd2 <uartSetBaudRate>
	// initialize states
	uartReadyTx[0] = TRUE;
    3808:	8f ef       	ldi	r24, 0xFF	; 255
    380a:	80 93 da 11 	sts	0x11DA, r24
	uartBufferedTx[0] = FALSE;
    380e:	10 92 fe 11 	sts	0x11FE, r1
	// clear overflow count
	uartRxOverflow[0] = 0;
    3812:	10 92 23 12 	sts	0x1223, r1
    3816:	10 92 22 12 	sts	0x1222, r1
	// enable interrupts
	sei();
    381a:	78 94       	sei
}
    381c:	08 95       	ret

0000381e <uartInit>:
volatile static voidFuncPtru08 UartRxFunc[4];

void uartInit(void)
{
	// initialize all uarts
	uart0Init();
    381e:	0e 94 f4 1b 	call	0x37e8	; 0x37e8 <uart0Init>
	uart1Init();
    3822:	0e 94 c8 1b 	call	0x3790	; 0x3790 <uart1Init>
	uart2Init();
    3826:	0e 94 9c 1b 	call	0x3738	; 0x3738 <uart2Init>
	uart3Init();
    382a:	0e 94 70 1b 	call	0x36e0	; 0x36e0 <uart3Init>
}
    382e:	08 95       	ret

00003830 <bufferInit>:
// global variables

// initialization

void bufferInit(cBuffer* buffer, unsigned char *start, unsigned short size)
{
    3830:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    3832:	8f b7       	in	r24, 0x3f	; 63
    3834:	f8 94       	cli
	// set start pointer of the buffer
	buffer->dataptr = start;
    3836:	71 83       	std	Z+1, r23	; 0x01
    3838:	60 83       	st	Z, r22
	buffer->size = size;
    383a:	53 83       	std	Z+3, r21	; 0x03
    383c:	42 83       	std	Z+2, r20	; 0x02
	// initialize index and length
	buffer->dataindex = 0;
    383e:	17 82       	std	Z+7, r1	; 0x07
    3840:	16 82       	std	Z+6, r1	; 0x06
	buffer->datalength = 0;
    3842:	15 82       	std	Z+5, r1	; 0x05
    3844:	14 82       	std	Z+4, r1	; 0x04
	// end critical section
	CRITICAL_SECTION_END;
    3846:	8f bf       	out	0x3f, r24	; 63
}
    3848:	08 95       	ret

0000384a <bufferGetFromFront>:

// access routines
unsigned char  bufferGetFromFront(cBuffer* buffer)
{
    384a:	dc 01       	movw	r26, r24
	unsigned char data = 0;
	// begin critical section
	CRITICAL_SECTION_START;
    384c:	4f b7       	in	r20, 0x3f	; 63
    384e:	f8 94       	cli
	// check to see if there's data in the buffer
	if(buffer->datalength)
    3850:	14 96       	adiw	r26, 0x04	; 4
    3852:	8d 91       	ld	r24, X+
    3854:	9c 91       	ld	r25, X
    3856:	15 97       	sbiw	r26, 0x05	; 5
    3858:	89 2b       	or	r24, r25
    385a:	11 f4       	brne	.+4      	; 0x3860 <bufferGetFromFront+0x16>
    385c:	e0 e0       	ldi	r30, 0x00	; 0
    385e:	25 c0       	rjmp	.+74     	; 0x38aa <bufferGetFromFront+0x60>
	{
		// get the first character from buffer
		data = buffer->dataptr[buffer->dataindex];
    3860:	16 96       	adiw	r26, 0x06	; 6
    3862:	8d 91       	ld	r24, X+
    3864:	9c 91       	ld	r25, X
    3866:	17 97       	sbiw	r26, 0x07	; 7
    3868:	ed 91       	ld	r30, X+
    386a:	fc 91       	ld	r31, X
    386c:	11 97       	sbiw	r26, 0x01	; 1
    386e:	e8 0f       	add	r30, r24
    3870:	f9 1f       	adc	r31, r25
    3872:	e0 81       	ld	r30, Z
		// move index down and decrement length
		buffer->dataindex++;
    3874:	01 96       	adiw	r24, 0x01	; 1
    3876:	17 96       	adiw	r26, 0x07	; 7
    3878:	9c 93       	st	X, r25
    387a:	8e 93       	st	-X, r24
    387c:	16 97       	sbiw	r26, 0x06	; 6
		if(buffer->dataindex >= buffer->size)
    387e:	12 96       	adiw	r26, 0x02	; 2
    3880:	2d 91       	ld	r18, X+
    3882:	3c 91       	ld	r19, X
    3884:	13 97       	sbiw	r26, 0x03	; 3
    3886:	82 17       	cp	r24, r18
    3888:	93 07       	cpc	r25, r19
    388a:	30 f0       	brcs	.+12     	; 0x3898 <bufferGetFromFront+0x4e>
		{
			buffer->dataindex -= buffer->size;
    388c:	82 1b       	sub	r24, r18
    388e:	93 0b       	sbc	r25, r19
    3890:	17 96       	adiw	r26, 0x07	; 7
    3892:	9c 93       	st	X, r25
    3894:	8e 93       	st	-X, r24
    3896:	16 97       	sbiw	r26, 0x06	; 6
		}
		buffer->datalength--;
    3898:	14 96       	adiw	r26, 0x04	; 4
    389a:	8d 91       	ld	r24, X+
    389c:	9c 91       	ld	r25, X
    389e:	15 97       	sbiw	r26, 0x05	; 5
    38a0:	01 97       	sbiw	r24, 0x01	; 1
    38a2:	15 96       	adiw	r26, 0x05	; 5
    38a4:	9c 93       	st	X, r25
    38a6:	8e 93       	st	-X, r24
    38a8:	14 97       	sbiw	r26, 0x04	; 4
	}
	// end critical section
	CRITICAL_SECTION_END;
    38aa:	4f bf       	out	0x3f, r20	; 63
	// return
	return data;
}
    38ac:	8e 2f       	mov	r24, r30
    38ae:	08 95       	ret

000038b0 <bufferDumpFromFront>:

void bufferDumpFromFront(cBuffer* buffer, unsigned short numbytes)
{
    38b0:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    38b2:	4f b7       	in	r20, 0x3f	; 63
    38b4:	f8 94       	cli
	// dump numbytes from the front of the buffer
	// are we dumping less than the entire buffer?
	if(numbytes < buffer->datalength)
    38b6:	84 81       	ldd	r24, Z+4	; 0x04
    38b8:	95 81       	ldd	r25, Z+5	; 0x05
    38ba:	68 17       	cp	r22, r24
    38bc:	79 07       	cpc	r23, r25
    38be:	b0 f4       	brcc	.+44     	; 0x38ec <bufferDumpFromFront+0x3c>
	{
		// move index down by numbytes and decrement length by numbytes
		buffer->dataindex += numbytes;
    38c0:	86 81       	ldd	r24, Z+6	; 0x06
    38c2:	97 81       	ldd	r25, Z+7	; 0x07
    38c4:	86 0f       	add	r24, r22
    38c6:	97 1f       	adc	r25, r23
    38c8:	97 83       	std	Z+7, r25	; 0x07
    38ca:	86 83       	std	Z+6, r24	; 0x06
		if(buffer->dataindex >= buffer->size)
    38cc:	22 81       	ldd	r18, Z+2	; 0x02
    38ce:	33 81       	ldd	r19, Z+3	; 0x03
    38d0:	82 17       	cp	r24, r18
    38d2:	93 07       	cpc	r25, r19
    38d4:	20 f0       	brcs	.+8      	; 0x38de <bufferDumpFromFront+0x2e>
		{
			buffer->dataindex -= buffer->size;
    38d6:	82 1b       	sub	r24, r18
    38d8:	93 0b       	sbc	r25, r19
    38da:	97 83       	std	Z+7, r25	; 0x07
    38dc:	86 83       	std	Z+6, r24	; 0x06
		}
		buffer->datalength -= numbytes;
    38de:	84 81       	ldd	r24, Z+4	; 0x04
    38e0:	95 81       	ldd	r25, Z+5	; 0x05
    38e2:	86 1b       	sub	r24, r22
    38e4:	97 0b       	sbc	r25, r23
    38e6:	95 83       	std	Z+5, r25	; 0x05
    38e8:	84 83       	std	Z+4, r24	; 0x04
    38ea:	02 c0       	rjmp	.+4      	; 0x38f0 <bufferDumpFromFront+0x40>
	}
	else
	{
		// flush the whole buffer
		buffer->datalength = 0;
    38ec:	15 82       	std	Z+5, r1	; 0x05
    38ee:	14 82       	std	Z+4, r1	; 0x04
	}
	// end critical section
	CRITICAL_SECTION_END;
    38f0:	4f bf       	out	0x3f, r20	; 63
}
    38f2:	08 95       	ret

000038f4 <bufferGetAtIndex>:

unsigned char bufferGetAtIndex(cBuffer* buffer, unsigned short index)
{
    38f4:	fc 01       	movw	r30, r24
    38f6:	cb 01       	movw	r24, r22
	// begin critical section
	CRITICAL_SECTION_START;
    38f8:	2f b7       	in	r18, 0x3f	; 63
    38fa:	f8 94       	cli
	// return character at index in buffer
	unsigned char data = buffer->dataptr[(buffer->dataindex+index)%(buffer->size)];
	// end critical section
	CRITICAL_SECTION_END;
    38fc:	2f bf       	out	0x3f, r18	; 63
    38fe:	26 81       	ldd	r18, Z+6	; 0x06
    3900:	37 81       	ldd	r19, Z+7	; 0x07
    3902:	62 81       	ldd	r22, Z+2	; 0x02
    3904:	73 81       	ldd	r23, Z+3	; 0x03
    3906:	82 0f       	add	r24, r18
    3908:	93 1f       	adc	r25, r19
    390a:	0e 94 74 27 	call	0x4ee8	; 0x4ee8 <__udivmodhi4>
    390e:	01 90       	ld	r0, Z+
    3910:	f0 81       	ld	r31, Z
    3912:	e0 2d       	mov	r30, r0
    3914:	e8 0f       	add	r30, r24
    3916:	f9 1f       	adc	r31, r25
	return data;
}
    3918:	80 81       	ld	r24, Z
    391a:	08 95       	ret

0000391c <bufferAddToEnd>:

unsigned char bufferAddToEnd(cBuffer* buffer, unsigned char data)
{
    391c:	1f 93       	push	r17
    391e:	cf 93       	push	r28
    3920:	df 93       	push	r29
    3922:	ec 01       	movw	r28, r24
    3924:	16 2f       	mov	r17, r22
	// begin critical section
	CRITICAL_SECTION_START;
    3926:	4f b7       	in	r20, 0x3f	; 63
    3928:	f8 94       	cli
	// make sure the buffer has room
	if(buffer->datalength < buffer->size)
    392a:	2c 81       	ldd	r18, Y+4	; 0x04
    392c:	3d 81       	ldd	r19, Y+5	; 0x05
    392e:	6a 81       	ldd	r22, Y+2	; 0x02
    3930:	7b 81       	ldd	r23, Y+3	; 0x03
    3932:	26 17       	cp	r18, r22
    3934:	37 07       	cpc	r19, r23
    3936:	98 f4       	brcc	.+38     	; 0x395e <bufferAddToEnd+0x42>
	{
		// save data byte at end of buffer
		buffer->dataptr[(buffer->dataindex + buffer->datalength) % buffer->size] = data;
    3938:	8e 81       	ldd	r24, Y+6	; 0x06
    393a:	9f 81       	ldd	r25, Y+7	; 0x07
    393c:	82 0f       	add	r24, r18
    393e:	93 1f       	adc	r25, r19
    3940:	0e 94 74 27 	call	0x4ee8	; 0x4ee8 <__udivmodhi4>
    3944:	e8 81       	ld	r30, Y
    3946:	f9 81       	ldd	r31, Y+1	; 0x01
    3948:	e8 0f       	add	r30, r24
    394a:	f9 1f       	adc	r31, r25
    394c:	10 83       	st	Z, r17
		// increment the length
		buffer->datalength++;
    394e:	8c 81       	ldd	r24, Y+4	; 0x04
    3950:	9d 81       	ldd	r25, Y+5	; 0x05
    3952:	01 96       	adiw	r24, 0x01	; 1
    3954:	9d 83       	std	Y+5, r25	; 0x05
    3956:	8c 83       	std	Y+4, r24	; 0x04
		// end critical section
		CRITICAL_SECTION_END;
    3958:	4f bf       	out	0x3f, r20	; 63
    395a:	8f ef       	ldi	r24, 0xFF	; 255
    395c:	02 c0       	rjmp	.+4      	; 0x3962 <bufferAddToEnd+0x46>
		// return success
		return -1;
	}
	// end critical section
	CRITICAL_SECTION_END;
    395e:	4f bf       	out	0x3f, r20	; 63
    3960:	80 e0       	ldi	r24, 0x00	; 0
	// return failure
	return 0;
}
    3962:	df 91       	pop	r29
    3964:	cf 91       	pop	r28
    3966:	1f 91       	pop	r17
    3968:	08 95       	ret

0000396a <bufferIsNotFull>:

unsigned short bufferIsNotFull(cBuffer* buffer)
{
    396a:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    396c:	8f b7       	in	r24, 0x3f	; 63
    396e:	f8 94       	cli
	// check to see if the buffer has room
	// return true if there is room
	unsigned short bytesleft = (buffer->size - buffer->datalength);
	// end critical section
	CRITICAL_SECTION_END;
    3970:	8f bf       	out	0x3f, r24	; 63
    3972:	22 81       	ldd	r18, Z+2	; 0x02
    3974:	33 81       	ldd	r19, Z+3	; 0x03
    3976:	84 81       	ldd	r24, Z+4	; 0x04
    3978:	95 81       	ldd	r25, Z+5	; 0x05
    397a:	28 1b       	sub	r18, r24
    397c:	39 0b       	sbc	r19, r25
	return bytesleft;
}
    397e:	c9 01       	movw	r24, r18
    3980:	08 95       	ret

00003982 <bufferFlush>:

void bufferFlush(cBuffer* buffer)
{
    3982:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    3984:	8f b7       	in	r24, 0x3f	; 63
    3986:	f8 94       	cli
	// flush contents of the buffer
	buffer->datalength = 0;
    3988:	15 82       	std	Z+5, r1	; 0x05
    398a:	14 82       	std	Z+4, r1	; 0x04
	// end critical section
	CRITICAL_SECTION_END;
    398c:	8f bf       	out	0x3f, r24	; 63
}
    398e:	08 95       	ret

00003990 <a2dInit>:
// functions

// initialize a2d converter
void a2dInit(void)
{
	sbi(ADCSR, ADEN);				// enable ADC (turn on ADC power)
    3990:	aa e7       	ldi	r26, 0x7A	; 122
    3992:	b0 e0       	ldi	r27, 0x00	; 0
    3994:	8c 91       	ld	r24, X
    3996:	80 68       	ori	r24, 0x80	; 128
    3998:	8c 93       	st	X, r24
	cbi(ADCSR, ADFR);				// default to single sample convert mode
    399a:	8c 91       	ld	r24, X
    399c:	8f 7d       	andi	r24, 0xDF	; 223
    399e:	8c 93       	st	X, r24
}

// configure A2D converter clock division (prescaling)
void a2dSetPrescaler(unsigned char prescale)
{
	outb(ADCSR, ((inb(ADCSR) & ~ADC_PRESCALE_MASK) | prescale));
    39a0:	8c 91       	ld	r24, X
    39a2:	88 7f       	andi	r24, 0xF8	; 248
    39a4:	86 60       	ori	r24, 0x06	; 6
    39a6:	8c 93       	st	X, r24
}

// configure A2D converter voltage reference
void a2dSetReference(unsigned char ref)
{
	outb(ADMUX, ((inb(ADMUX) & ~ADC_REFERENCE_MASK) | (ref<<6)));
    39a8:	ec e7       	ldi	r30, 0x7C	; 124
    39aa:	f0 e0       	ldi	r31, 0x00	; 0
    39ac:	80 81       	ld	r24, Z
    39ae:	8f 73       	andi	r24, 0x3F	; 63
    39b0:	80 64       	ori	r24, 0x40	; 64
    39b2:	80 83       	st	Z, r24
{
	sbi(ADCSR, ADEN);				// enable ADC (turn on ADC power)
	cbi(ADCSR, ADFR);				// default to single sample convert mode
	a2dSetPrescaler(ADC_PRESCALE);	// set default prescaler
	a2dSetReference(ADC_REFERENCE);	// set default reference
	cbi(ADMUX, ADLAR);				// set to right-adjusted result
    39b4:	80 81       	ld	r24, Z
    39b6:	8f 7d       	andi	r24, 0xDF	; 223
    39b8:	80 83       	st	Z, r24

	sbi(ADCSR, ADIE);				// enable ADC interrupts
    39ba:	8c 91       	ld	r24, X
    39bc:	88 60       	ori	r24, 0x08	; 8
    39be:	8c 93       	st	X, r24

	a2dCompleteFlag = FALSE;		// clear conversion complete flag
    39c0:	10 92 2a 12 	sts	0x122A, r1
	sei();							// turn on interrupts (if not already on)
    39c4:	78 94       	sei
}
    39c6:	08 95       	ret

000039c8 <a2dOff>:

// turn off a2d converter
void a2dOff(void)
{
	cbi(ADCSR, ADIE);				// disable ADC interrupts
    39c8:	ea e7       	ldi	r30, 0x7A	; 122
    39ca:	f0 e0       	ldi	r31, 0x00	; 0
    39cc:	80 81       	ld	r24, Z
    39ce:	87 7f       	andi	r24, 0xF7	; 247
    39d0:	80 83       	st	Z, r24
	cbi(ADCSR, ADEN);				// disable ADC (turn off ADC power)
    39d2:	80 81       	ld	r24, Z
    39d4:	8f 77       	andi	r24, 0x7F	; 127
    39d6:	80 83       	st	Z, r24
}
    39d8:	08 95       	ret

000039da <a2dSetPrescaler>:

// configure A2D converter clock division (prescaling)
void a2dSetPrescaler(unsigned char prescale)
{
	outb(ADCSR, ((inb(ADCSR) & ~ADC_PRESCALE_MASK) | prescale));
    39da:	ea e7       	ldi	r30, 0x7A	; 122
    39dc:	f0 e0       	ldi	r31, 0x00	; 0
    39de:	90 81       	ld	r25, Z
    39e0:	98 7f       	andi	r25, 0xF8	; 248
    39e2:	98 2b       	or	r25, r24
    39e4:	90 83       	st	Z, r25
}
    39e6:	08 95       	ret

000039e8 <a2dSetReference>:

// configure A2D converter voltage reference
void a2dSetReference(unsigned char ref)
{
	outb(ADMUX, ((inb(ADMUX) & ~ADC_REFERENCE_MASK) | (ref<<6)));
    39e8:	ec e7       	ldi	r30, 0x7C	; 124
    39ea:	f0 e0       	ldi	r31, 0x00	; 0
    39ec:	90 81       	ld	r25, Z
    39ee:	82 95       	swap	r24
    39f0:	88 0f       	add	r24, r24
    39f2:	88 0f       	add	r24, r24
    39f4:	80 7c       	andi	r24, 0xC0	; 192
    39f6:	9f 73       	andi	r25, 0x3F	; 63
    39f8:	98 2b       	or	r25, r24
    39fa:	90 83       	st	Z, r25
}
    39fc:	08 95       	ret

000039fe <a2dSetChannel>:

// sets the a2d input channel
void a2dSetChannel(unsigned char ch)
{
	outb(ADMUX, (inb(ADMUX) & ~ADC_MUX_MASK) | (ch & ADC_MUX_MASK));	// set channel
    39fe:	ec e7       	ldi	r30, 0x7C	; 124
    3a00:	f0 e0       	ldi	r31, 0x00	; 0
    3a02:	90 81       	ld	r25, Z
    3a04:	8f 71       	andi	r24, 0x1F	; 31
    3a06:	90 7e       	andi	r25, 0xE0	; 224
    3a08:	89 2b       	or	r24, r25
    3a0a:	80 83       	st	Z, r24
}
    3a0c:	08 95       	ret

00003a0e <a2dStartConvert>:

// start a conversion on the current a2d input channel
void a2dStartConvert(void)
{
	sbi(ADCSR, ADIF);	// clear hardware "conversion complete" flag 
    3a0e:	ea e7       	ldi	r30, 0x7A	; 122
    3a10:	f0 e0       	ldi	r31, 0x00	; 0
    3a12:	80 81       	ld	r24, Z
    3a14:	80 61       	ori	r24, 0x10	; 16
    3a16:	80 83       	st	Z, r24
	sbi(ADCSR, ADSC);	// start conversion
    3a18:	80 81       	ld	r24, Z
    3a1a:	80 64       	ori	r24, 0x40	; 64
    3a1c:	80 83       	st	Z, r24
}
    3a1e:	08 95       	ret

00003a20 <a2dIsComplete>:

// return TRUE if conversion is complete
u08 a2dIsComplete(void)
{
	return bit_is_set(ADCSR, ADSC);
    3a20:	80 91 7a 00 	lds	r24, 0x007A
}
    3a24:	80 74       	andi	r24, 0x40	; 64
    3a26:	08 95       	ret

00003a28 <a2dConvert10bit>:

// Perform a 10-bit conversion
// starts conversion, waits until conversion is done, and returns result
unsigned short a2dConvert10bit(unsigned char ch)
{
    3a28:	98 2f       	mov	r25, r24
	a2dCompleteFlag = FALSE;				// clear conversion complete flag
    3a2a:	10 92 2a 12 	sts	0x122A, r1

if (ch >= 8)
    3a2e:	88 30       	cpi	r24, 0x08	; 8
    3a30:	20 f0       	brcs	.+8      	; 0x3a3a <a2dConvert10bit+0x12>
    ADCSRB |= _BV(MUX5);
    3a32:	80 91 7b 00 	lds	r24, 0x007B
    3a36:	88 60       	ori	r24, 0x08	; 8
    3a38:	03 c0       	rjmp	.+6      	; 0x3a40 <a2dConvert10bit+0x18>
else
    ADCSRB &= ~_BV(MUX5);
    3a3a:	80 91 7b 00 	lds	r24, 0x007B
    3a3e:	87 7f       	andi	r24, 0xF7	; 247
    3a40:	80 93 7b 00 	sts	0x007B, r24

   outb(ADMUX, (inb(ADMUX) & ~7) | (ch & 7));   // set channel
    3a44:	80 91 7c 00 	lds	r24, 0x007C
    3a48:	97 70       	andi	r25, 0x07	; 7
    3a4a:	88 7f       	andi	r24, 0xF8	; 248
    3a4c:	89 2b       	or	r24, r25
    3a4e:	80 93 7c 00 	sts	0x007C, r24

	//outb(ADMUX, (inb(ADMUX) & ~ADC_MUX_MASK) | (ch & ADC_MUX_MASK));	// set channel
	sbi(ADCSR, ADIF);						// clear hardware "conversion complete" flag 
    3a52:	80 91 7a 00 	lds	r24, 0x007A
    3a56:	80 61       	ori	r24, 0x10	; 16
    3a58:	80 93 7a 00 	sts	0x007A, r24
	sbi(ADCSR, ADSC);						// start conversion
    3a5c:	80 91 7a 00 	lds	r24, 0x007A
    3a60:	80 64       	ori	r24, 0x40	; 64
    3a62:	80 93 7a 00 	sts	0x007A, r24
	//while(!a2dCompleteFlag);				// wait until conversion complete
	//while( bit_is_clear(ADCSR, ADIF) );		// wait until conversion complete
	while( bit_is_set(ADCSR, ADSC) );		// wait until conversion complete
    3a66:	80 91 7a 00 	lds	r24, 0x007A
    3a6a:	86 fd       	sbrc	r24, 6
    3a6c:	fc cf       	rjmp	.-8      	; 0x3a66 <a2dConvert10bit+0x3e>

	// CAUTION: MUST READ ADCL BEFORE ADCH!!!
	//return (inb(ADCL) | (inb(ADCH)<<8));	// read ADC (full 10 bits) //old version
	return ADC;//new version code
    3a6e:	20 91 78 00 	lds	r18, 0x0078
    3a72:	30 91 79 00 	lds	r19, 0x0079
}
    3a76:	c9 01       	movw	r24, r18
    3a78:	08 95       	ret

00003a7a <a2dConvert8bit>:
// Perform a 8-bit conversion.
// starts conversion, waits until conversion is done, and returns result
unsigned char a2dConvert8bit(unsigned char ch)
{
	// do 10-bit conversion and return highest 8 bits
	return a2dConvert10bit(ch)>>2;			// return ADC MSB byte
    3a7a:	0e 94 14 1d 	call	0x3a28	; 0x3a28 <a2dConvert10bit>
    3a7e:	96 95       	lsr	r25
    3a80:	87 95       	ror	r24
    3a82:	96 95       	lsr	r25
    3a84:	87 95       	ror	r24
}
    3a86:	08 95       	ret

00003a88 <__vector_29>:

//! Interrupt handler for ADC complete interrupt.
SIGNAL(SIG_ADC)
{
    3a88:	1f 92       	push	r1
    3a8a:	0f 92       	push	r0
    3a8c:	0f b6       	in	r0, 0x3f	; 63
    3a8e:	0f 92       	push	r0
    3a90:	11 24       	eor	r1, r1
    3a92:	8f 93       	push	r24
	// set the a2d conversion flag to indicate "complete"
	a2dCompleteFlag = TRUE;
    3a94:	8f ef       	ldi	r24, 0xFF	; 255
    3a96:	80 93 2a 12 	sts	0x122A, r24
}
    3a9a:	8f 91       	pop	r24
    3a9c:	0f 90       	pop	r0
    3a9e:	0f be       	out	0x3f, r0	; 63
    3aa0:	0f 90       	pop	r0
    3aa2:	1f 90       	pop	r1
    3aa4:	18 95       	reti

00003aa6 <rprintfInit>:
// *** rprintf initialization ***
// you must call this function once and supply the character output
// routine before using other functions in this library
void rprintfInit(void (*putchar_func)(unsigned char c))
{
	rputchar = putchar_func;
    3aa6:	90 93 63 11 	sts	0x1163, r25
    3aaa:	80 93 62 11 	sts	0x1162, r24
}
    3aae:	08 95       	ret

00003ab0 <rprintfChar>:

// *** rprintfChar ***
// send a character/byte to the current output device
void rprintfChar(unsigned char c)
{
    3ab0:	1f 93       	push	r17
    3ab2:	18 2f       	mov	r17, r24
	// do LF -> CR/LF translation
	if(c == '\n')
    3ab4:	8a 30       	cpi	r24, 0x0A	; 10
    3ab6:	31 f4       	brne	.+12     	; 0x3ac4 <rprintfChar+0x14>
		rputchar('\r');
    3ab8:	e0 91 62 11 	lds	r30, 0x1162
    3abc:	f0 91 63 11 	lds	r31, 0x1163
    3ac0:	8d e0       	ldi	r24, 0x0D	; 13
    3ac2:	09 95       	icall
	// send character
	rputchar(c);
    3ac4:	e0 91 62 11 	lds	r30, 0x1162
    3ac8:	f0 91 63 11 	lds	r31, 0x1163
    3acc:	81 2f       	mov	r24, r17
    3ace:	09 95       	icall
}
    3ad0:	1f 91       	pop	r17
    3ad2:	08 95       	ret

00003ad4 <rprintfStr>:

// *** rprintfStr ***
// prints a null-terminated string stored in RAM
void rprintfStr(char str[])
{
    3ad4:	cf 93       	push	r28
    3ad6:	df 93       	push	r29
    3ad8:	ec 01       	movw	r28, r24
	// send a string stored in RAM
	// check to make sure we have a good pointer
	if (!str) return;
    3ada:	00 97       	sbiw	r24, 0x00	; 0
    3adc:	21 f4       	brne	.+8      	; 0x3ae6 <rprintfStr+0x12>
    3ade:	06 c0       	rjmp	.+12     	; 0x3aec <rprintfStr+0x18>

	// print the string until a null-terminator
	while (*str)
		rprintfChar(*str++);
    3ae0:	21 96       	adiw	r28, 0x01	; 1
    3ae2:	0e 94 58 1d 	call	0x3ab0	; 0x3ab0 <rprintfChar>
	// send a string stored in RAM
	// check to make sure we have a good pointer
	if (!str) return;

	// print the string until a null-terminator
	while (*str)
    3ae6:	88 81       	ld	r24, Y
    3ae8:	88 23       	and	r24, r24
    3aea:	d1 f7       	brne	.-12     	; 0x3ae0 <rprintfStr+0xc>
		rprintfChar(*str++);
}
    3aec:	df 91       	pop	r29
    3aee:	cf 91       	pop	r28
    3af0:	08 95       	ret

00003af2 <rprintfStrLen>:
// *** rprintfStrLen ***
// prints a section of a string stored in RAM
// begins printing at position indicated by <start>
// prints number of characters indicated by <len>
void rprintfStrLen(char str[], unsigned int start, unsigned int len)
{
    3af2:	ef 92       	push	r14
    3af4:	ff 92       	push	r15
    3af6:	0f 93       	push	r16
    3af8:	1f 93       	push	r17
    3afa:	cf 93       	push	r28
    3afc:	df 93       	push	r29
    3afe:	8c 01       	movw	r16, r24
    3b00:	7a 01       	movw	r14, r20
	register int i=0;

	// check to make sure we have a good pointer
	if (!str) return;
    3b02:	00 97       	sbiw	r24, 0x00	; 0
    3b04:	e9 f0       	breq	.+58     	; 0x3b40 <rprintfStrLen+0x4e>
    3b06:	20 e0       	ldi	r18, 0x00	; 0
    3b08:	30 e0       	ldi	r19, 0x00	; 0
	// spin through characters up to requested start
	// keep going as long as there's no null
	while((i++<start) && (*str++));
    3b0a:	26 17       	cp	r18, r22
    3b0c:	37 07       	cpc	r19, r23
    3b0e:	38 f4       	brcc	.+14     	; 0x3b1e <rprintfStrLen+0x2c>
    3b10:	f8 01       	movw	r30, r16
    3b12:	81 91       	ld	r24, Z+
    3b14:	8f 01       	movw	r16, r30
    3b16:	2f 5f       	subi	r18, 0xFF	; 255
    3b18:	3f 4f       	sbci	r19, 0xFF	; 255
    3b1a:	88 23       	and	r24, r24
    3b1c:	b1 f7       	brne	.-20     	; 0x3b0a <rprintfStrLen+0x18>
    3b1e:	c0 e0       	ldi	r28, 0x00	; 0
    3b20:	d0 e0       	ldi	r29, 0x00	; 0
    3b22:	0b c0       	rjmp	.+22     	; 0x3b3a <rprintfStrLen+0x48>
	// then print exactly len characters
	for(i=0; i<len; i++)
	{
		// print data out of the string as long as we haven't reached a null yet
		// at the null, start printing spaces
		if(*str)
    3b24:	f8 01       	movw	r30, r16
    3b26:	80 81       	ld	r24, Z
    3b28:	88 23       	and	r24, r24
    3b2a:	19 f0       	breq	.+6      	; 0x3b32 <rprintfStrLen+0x40>
			rprintfChar(*str++);
    3b2c:	0f 5f       	subi	r16, 0xFF	; 255
    3b2e:	1f 4f       	sbci	r17, 0xFF	; 255
    3b30:	01 c0       	rjmp	.+2      	; 0x3b34 <rprintfStrLen+0x42>
		else
			rprintfChar(' ');
    3b32:	80 e2       	ldi	r24, 0x20	; 32
    3b34:	0e 94 58 1d 	call	0x3ab0	; 0x3ab0 <rprintfChar>
//		// keep steping through string as long as there's no null
//		if(*str) str++;
//	}

	// then print exactly len characters
	for(i=0; i<len; i++)
    3b38:	21 96       	adiw	r28, 0x01	; 1
    3b3a:	ce 15       	cp	r28, r14
    3b3c:	df 05       	cpc	r29, r15
    3b3e:	90 f3       	brcs	.-28     	; 0x3b24 <rprintfStrLen+0x32>
			rprintfChar(*str++);
		else
			rprintfChar(' ');
	}

}
    3b40:	df 91       	pop	r29
    3b42:	cf 91       	pop	r28
    3b44:	1f 91       	pop	r17
    3b46:	0f 91       	pop	r16
    3b48:	ff 90       	pop	r15
    3b4a:	ef 90       	pop	r14
    3b4c:	08 95       	ret

00003b4e <rprintfProgStr>:

// *** rprintfProgStr ***
// prints a null-terminated string stored in program ROM
void rprintfProgStr(const prog_char str[])
{
    3b4e:	cf 93       	push	r28
    3b50:	df 93       	push	r29
    3b52:	ec 01       	movw	r28, r24
	// print a string stored in program memory
	register char c;

	// check to make sure we have a good pointer
	if (!str) return;
    3b54:	00 97       	sbiw	r24, 0x00	; 0
    3b56:	19 f4       	brne	.+6      	; 0x3b5e <rprintfProgStr+0x10>
    3b58:	07 c0       	rjmp	.+14     	; 0x3b68 <rprintfProgStr+0x1a>
	
	// print the string until the null-terminator
	while((c = pgm_read_byte(str++)))
		rprintfChar(c);
    3b5a:	0e 94 58 1d 	call	0x3ab0	; 0x3ab0 <rprintfChar>
    3b5e:	fe 01       	movw	r30, r28

	// check to make sure we have a good pointer
	if (!str) return;
	
	// print the string until the null-terminator
	while((c = pgm_read_byte(str++)))
    3b60:	21 96       	adiw	r28, 0x01	; 1
    3b62:	84 91       	lpm	r24, Z+
    3b64:	88 23       	and	r24, r24
    3b66:	c9 f7       	brne	.-14     	; 0x3b5a <rprintfProgStr+0xc>
		rprintfChar(c);
}
    3b68:	df 91       	pop	r29
    3b6a:	cf 91       	pop	r28
    3b6c:	08 95       	ret

00003b6e <rprintfCRLF>:
void rprintfCRLF(void)
{
	// print CR/LF
	//rprintfChar('\r');
	// LF -> CR/LF translation built-in to rprintfChar()
	rprintfChar('\n');
    3b6e:	8a e0       	ldi	r24, 0x0A	; 10
    3b70:	0e 94 58 1d 	call	0x3ab0	; 0x3ab0 <rprintfChar>
}
    3b74:	08 95       	ret

00003b76 <rprintfu04>:
//	char Character = data&0x0f;
//	if (Character>9)
//		Character+='A'-10;
//	else
//		Character+='0';
	rprintfChar(hexchar(data));
    3b76:	e8 2f       	mov	r30, r24
    3b78:	f0 e0       	ldi	r31, 0x00	; 0
    3b7a:	ef 70       	andi	r30, 0x0F	; 15
    3b7c:	f0 70       	andi	r31, 0x00	; 0
    3b7e:	e1 59       	subi	r30, 0x91	; 145
    3b80:	fe 4f       	sbci	r31, 0xFE	; 254
    3b82:	e4 91       	lpm	r30, Z+
    3b84:	8e 2f       	mov	r24, r30
    3b86:	0e 94 58 1d 	call	0x3ab0	; 0x3ab0 <rprintfChar>
}
    3b8a:	08 95       	ret

00003b8c <rprintfu08>:

// *** rprintfu08 ***
// prints an unsigned 8-bit number in hex (2 digits)
void rprintfu08(unsigned char data)
{
    3b8c:	1f 93       	push	r17
    3b8e:	18 2f       	mov	r17, r24
	// print 8-bit hex value
	rprintfu04(data>>4);
    3b90:	82 95       	swap	r24
    3b92:	8f 70       	andi	r24, 0x0F	; 15
    3b94:	0e 94 bb 1d 	call	0x3b76	; 0x3b76 <rprintfu04>
	rprintfu04(data);
    3b98:	81 2f       	mov	r24, r17
    3b9a:	0e 94 bb 1d 	call	0x3b76	; 0x3b76 <rprintfu04>
}
    3b9e:	1f 91       	pop	r17
    3ba0:	08 95       	ret

00003ba2 <rprintfu16>:

// *** rprintfu16 ***
// prints an unsigned 16-bit number in hex (4 digits)
void rprintfu16(unsigned short data)
{
    3ba2:	1f 93       	push	r17
    3ba4:	18 2f       	mov	r17, r24
	// print 16-bit hex value
	rprintfu08(data>>8);
    3ba6:	89 2f       	mov	r24, r25
    3ba8:	0e 94 c6 1d 	call	0x3b8c	; 0x3b8c <rprintfu08>
	rprintfu08(data);
    3bac:	81 2f       	mov	r24, r17
    3bae:	0e 94 c6 1d 	call	0x3b8c	; 0x3b8c <rprintfu08>
}
    3bb2:	1f 91       	pop	r17
    3bb4:	08 95       	ret

00003bb6 <rprintfu32>:

// *** rprintfu32 ***
// prints an unsigned 32-bit number in hex (8 digits)
void rprintfu32(unsigned long data)
{
    3bb6:	ef 92       	push	r14
    3bb8:	ff 92       	push	r15
    3bba:	0f 93       	push	r16
    3bbc:	1f 93       	push	r17
    3bbe:	7b 01       	movw	r14, r22
    3bc0:	8c 01       	movw	r16, r24
	// print 32-bit hex value
	rprintfu16(data>>16);
    3bc2:	c8 01       	movw	r24, r16
    3bc4:	aa 27       	eor	r26, r26
    3bc6:	bb 27       	eor	r27, r27
    3bc8:	0e 94 d1 1d 	call	0x3ba2	; 0x3ba2 <rprintfu16>
	rprintfu16(data);
    3bcc:	c7 01       	movw	r24, r14
    3bce:	0e 94 d1 1d 	call	0x3ba2	; 0x3ba2 <rprintfu16>
}
    3bd2:	1f 91       	pop	r17
    3bd4:	0f 91       	pop	r16
    3bd6:	ff 90       	pop	r15
    3bd8:	ef 90       	pop	r14
    3bda:	08 95       	ret

00003bdc <rprintfNum>:
//	Examples:
//	uartPrintfNum(10, 6,  TRUE, ' ',   1234);  -->  " +1234"
//	uartPrintfNum(10, 6, FALSE, '0',   1234);  -->  "001234"
//	uartPrintfNum(16, 6, FALSE, '.', 0x5AA5);  -->  "..5AA5"
void rprintfNum(char base, char numDigits, char isSigned, char padchar, long n)
{
    3bdc:	2f 92       	push	r2
    3bde:	3f 92       	push	r3
    3be0:	4f 92       	push	r4
    3be2:	5f 92       	push	r5
    3be4:	6f 92       	push	r6
    3be6:	7f 92       	push	r7
    3be8:	8f 92       	push	r8
    3bea:	9f 92       	push	r9
    3bec:	af 92       	push	r10
    3bee:	bf 92       	push	r11
    3bf0:	cf 92       	push	r12
    3bf2:	df 92       	push	r13
    3bf4:	ef 92       	push	r14
    3bf6:	ff 92       	push	r15
    3bf8:	0f 93       	push	r16
    3bfa:	1f 93       	push	r17
    3bfc:	df 93       	push	r29
    3bfe:	cf 93       	push	r28
    3c00:	cd b7       	in	r28, 0x3d	; 61
    3c02:	de b7       	in	r29, 0x3e	; 62
    3c04:	a3 97       	sbiw	r28, 0x23	; 35
    3c06:	0f b6       	in	r0, 0x3f	; 63
    3c08:	f8 94       	cli
    3c0a:	de bf       	out	0x3e, r29	; 62
    3c0c:	0f be       	out	0x3f, r0	; 63
    3c0e:	cd bf       	out	0x3d, r28	; 61
    3c10:	6a a3       	std	Y+34, r22	; 0x22
    3c12:	24 2e       	mov	r2, r20
    3c14:	2b a3       	std	Y+35, r18	; 0x23
    3c16:	37 01       	movw	r6, r14
    3c18:	48 01       	movw	r8, r16
	char *p, buf[32];
	unsigned long x;
	unsigned char count;

	// prepare negative number
	if( isSigned && (n < 0) )
    3c1a:	44 23       	and	r20, r20
    3c1c:	51 f0       	breq	.+20     	; 0x3c32 <rprintfNum+0x56>
    3c1e:	17 ff       	sbrs	r17, 7
    3c20:	08 c0       	rjmp	.+16     	; 0x3c32 <rprintfNum+0x56>
	{
		x = -n;
    3c22:	ee 24       	eor	r14, r14
    3c24:	ff 24       	eor	r15, r15
    3c26:	87 01       	movw	r16, r14
    3c28:	e6 18       	sub	r14, r6
    3c2a:	f7 08       	sbc	r15, r7
    3c2c:	08 09       	sbc	r16, r8
    3c2e:	19 09       	sbc	r17, r9
    3c30:	02 c0       	rjmp	.+4      	; 0x3c36 <rprintfNum+0x5a>
	}
	else
	{
	 	x = n;
    3c32:	84 01       	movw	r16, r8
    3c34:	73 01       	movw	r14, r6
	}

	// setup little string buffer
	count = (numDigits-1)-(isSigned?1:0);
    3c36:	2a a1       	ldd	r18, Y+34	; 0x22
    3c38:	21 50       	subi	r18, 0x01	; 1
    3c3a:	90 e0       	ldi	r25, 0x00	; 0
    3c3c:	21 10       	cpse	r2, r1
    3c3e:	91 e0       	ldi	r25, 0x01	; 1
    3c40:	29 1b       	sub	r18, r25
    3c42:	29 a3       	std	Y+33, r18	; 0x21
  	p = buf + sizeof (buf);
  	*--p = '\0';
    3c44:	18 a2       	std	Y+32, r1	; 0x20
	
	// force calculation of first digit
	// (to prevent zero from not printing at all!!!)
	*--p = hexchar(x%base); x /= base;
    3c46:	a8 2e       	mov	r10, r24
    3c48:	bb 24       	eor	r11, r11
    3c4a:	cc 24       	eor	r12, r12
    3c4c:	dd 24       	eor	r13, r13
    3c4e:	c8 01       	movw	r24, r16
    3c50:	b7 01       	movw	r22, r14
    3c52:	a6 01       	movw	r20, r12
    3c54:	95 01       	movw	r18, r10
    3c56:	0e 94 9b 27 	call	0x4f36	; 0x4f36 <__udivmodsi4>
    3c5a:	fb 01       	movw	r30, r22
    3c5c:	ef 70       	andi	r30, 0x0F	; 15
    3c5e:	f0 70       	andi	r31, 0x00	; 0
    3c60:	e1 59       	subi	r30, 0x91	; 145
    3c62:	fe 4f       	sbci	r31, 0xFE	; 254
    3c64:	64 91       	lpm	r22, Z+
    3c66:	6f 8f       	std	Y+31, r22	; 0x1f
    3c68:	c8 01       	movw	r24, r16
    3c6a:	b7 01       	movw	r22, r14
    3c6c:	a6 01       	movw	r20, r12
    3c6e:	95 01       	movw	r18, r10
    3c70:	0e 94 9b 27 	call	0x4f36	; 0x4f36 <__udivmodsi4>
    3c74:	c9 01       	movw	r24, r18
    3c76:	da 01       	movw	r26, r20
    3c78:	7c 01       	movw	r14, r24
    3c7a:	8d 01       	movw	r16, r26
    3c7c:	9e e1       	ldi	r25, 0x1E	; 30
    3c7e:	49 2e       	mov	r4, r25
    3c80:	51 2c       	mov	r5, r1
    3c82:	4c 0e       	add	r4, r28
    3c84:	5d 1e       	adc	r5, r29
    3c86:	39 a0       	ldd	r3, Y+33	; 0x21
    3c88:	25 c0       	rjmp	.+74     	; 0x3cd4 <rprintfNum+0xf8>
	// calculate remaining digits
	while(count--)
	{
		if(x != 0)
    3c8a:	e1 14       	cp	r14, r1
    3c8c:	f1 04       	cpc	r15, r1
    3c8e:	01 05       	cpc	r16, r1
    3c90:	11 05       	cpc	r17, r1
    3c92:	c9 f0       	breq	.+50     	; 0x3cc6 <rprintfNum+0xea>
		{
			// calculate next digit
			*--p = hexchar(x%base); x /= base;
    3c94:	c8 01       	movw	r24, r16
    3c96:	b7 01       	movw	r22, r14
    3c98:	a6 01       	movw	r20, r12
    3c9a:	95 01       	movw	r18, r10
    3c9c:	0e 94 9b 27 	call	0x4f36	; 0x4f36 <__udivmodsi4>
    3ca0:	fb 01       	movw	r30, r22
    3ca2:	ef 70       	andi	r30, 0x0F	; 15
    3ca4:	f0 70       	andi	r31, 0x00	; 0
    3ca6:	e1 59       	subi	r30, 0x91	; 145
    3ca8:	fe 4f       	sbci	r31, 0xFE	; 254
    3caa:	64 91       	lpm	r22, Z+
    3cac:	f2 01       	movw	r30, r4
    3cae:	60 83       	st	Z, r22
    3cb0:	c8 01       	movw	r24, r16
    3cb2:	b7 01       	movw	r22, r14
    3cb4:	a6 01       	movw	r20, r12
    3cb6:	95 01       	movw	r18, r10
    3cb8:	0e 94 9b 27 	call	0x4f36	; 0x4f36 <__udivmodsi4>
    3cbc:	c9 01       	movw	r24, r18
    3cbe:	da 01       	movw	r26, r20
    3cc0:	7c 01       	movw	r14, r24
    3cc2:	8d 01       	movw	r16, r26
    3cc4:	03 c0       	rjmp	.+6      	; 0x3ccc <rprintfNum+0xf0>
		}
		else
		{
			// no more digits left, pad out to desired length
			*--p = padchar;
    3cc6:	2b a1       	ldd	r18, Y+35	; 0x23
    3cc8:	f2 01       	movw	r30, r4
    3cca:	20 83       	st	Z, r18
    3ccc:	3a 94       	dec	r3
    3cce:	08 94       	sec
    3cd0:	41 08       	sbc	r4, r1
    3cd2:	51 08       	sbc	r5, r1
	
	// force calculation of first digit
	// (to prevent zero from not printing at all!!!)
	*--p = hexchar(x%base); x /= base;
	// calculate remaining digits
	while(count--)
    3cd4:	33 20       	and	r3, r3
    3cd6:	c9 f6       	brne	.-78     	; 0x3c8a <rprintfNum+0xae>
    3cd8:	ce 01       	movw	r24, r28
    3cda:	4f 96       	adiw	r24, 0x1f	; 31
    3cdc:	8c 01       	movw	r16, r24
    3cde:	e9 a1       	ldd	r30, Y+33	; 0x21
    3ce0:	0e 1b       	sub	r16, r30
    3ce2:	11 09       	sbc	r17, r1
			*--p = padchar;
		}
	}

	// apply signed notation if requested
	if( isSigned )
    3ce4:	22 20       	and	r2, r2
    3ce6:	f1 f0       	breq	.+60     	; 0x3d24 <rprintfNum+0x148>
	{
		if(n < 0)
    3ce8:	97 fe       	sbrs	r9, 7
    3cea:	05 c0       	rjmp	.+10     	; 0x3cf6 <rprintfNum+0x11a>
		{
   			*--p = '-';
    3cec:	8d e2       	ldi	r24, 0x2D	; 45
    3cee:	f8 01       	movw	r30, r16
    3cf0:	82 93       	st	-Z, r24
    3cf2:	8f 01       	movw	r16, r30
    3cf4:	17 c0       	rjmp	.+46     	; 0x3d24 <rprintfNum+0x148>
    3cf6:	c8 01       	movw	r24, r16
    3cf8:	01 97       	sbiw	r24, 0x01	; 1
		}
		else if(n > 0)
    3cfa:	61 14       	cp	r6, r1
    3cfc:	71 04       	cpc	r7, r1
    3cfe:	81 04       	cpc	r8, r1
    3d00:	91 04       	cpc	r9, r1
    3d02:	19 f0       	breq	.+6      	; 0x3d0a <rprintfNum+0x12e>
		{
	   		*--p = '+';
    3d04:	8c 01       	movw	r16, r24
    3d06:	8b e2       	ldi	r24, 0x2B	; 43
    3d08:	02 c0       	rjmp	.+4      	; 0x3d0e <rprintfNum+0x132>
		}
		else
		{
	   		*--p = ' ';
    3d0a:	8c 01       	movw	r16, r24
    3d0c:	80 e2       	ldi	r24, 0x20	; 32
    3d0e:	f8 01       	movw	r30, r16
    3d10:	80 83       	st	Z, r24
    3d12:	08 c0       	rjmp	.+16     	; 0x3d24 <rprintfNum+0x148>

	// print the string right-justified
	count = numDigits;
	while(count--)
	{
		rprintfChar(*p++);
    3d14:	f8 01       	movw	r30, r16
    3d16:	81 91       	ld	r24, Z+
    3d18:	8f 01       	movw	r16, r30
    3d1a:	0e 94 58 1d 	call	0x3ab0	; 0x3ab0 <rprintfChar>
    3d1e:	fa a1       	ldd	r31, Y+34	; 0x22
    3d20:	f1 50       	subi	r31, 0x01	; 1
    3d22:	fa a3       	std	Y+34, r31	; 0x22
		}
	}

	// print the string right-justified
	count = numDigits;
	while(count--)
    3d24:	2a a1       	ldd	r18, Y+34	; 0x22
    3d26:	22 23       	and	r18, r18
    3d28:	a9 f7       	brne	.-22     	; 0x3d14 <rprintfNum+0x138>
	{
		rprintfChar(*p++);
	}
}
    3d2a:	a3 96       	adiw	r28, 0x23	; 35
    3d2c:	0f b6       	in	r0, 0x3f	; 63
    3d2e:	f8 94       	cli
    3d30:	de bf       	out	0x3e, r29	; 62
    3d32:	0f be       	out	0x3f, r0	; 63
    3d34:	cd bf       	out	0x3d, r28	; 61
    3d36:	cf 91       	pop	r28
    3d38:	df 91       	pop	r29
    3d3a:	1f 91       	pop	r17
    3d3c:	0f 91       	pop	r16
    3d3e:	ff 90       	pop	r15
    3d40:	ef 90       	pop	r14
    3d42:	df 90       	pop	r13
    3d44:	cf 90       	pop	r12
    3d46:	bf 90       	pop	r11
    3d48:	af 90       	pop	r10
    3d4a:	9f 90       	pop	r9
    3d4c:	8f 90       	pop	r8
    3d4e:	7f 90       	pop	r7
    3d50:	6f 90       	pop	r6
    3d52:	5f 90       	pop	r5
    3d54:	4f 90       	pop	r4
    3d56:	3f 90       	pop	r3
    3d58:	2f 90       	pop	r2
    3d5a:	08 95       	ret

00003d5c <rprintfFloat>:

#ifdef RPRINTF_FLOAT
// *** rprintfFloat ***
// floating-point print
void rprintfFloat(char numDigits, double x)
{
    3d5c:	4f 92       	push	r4
    3d5e:	5f 92       	push	r5
    3d60:	6f 92       	push	r6
    3d62:	7f 92       	push	r7
    3d64:	8f 92       	push	r8
    3d66:	9f 92       	push	r9
    3d68:	af 92       	push	r10
    3d6a:	bf 92       	push	r11
    3d6c:	cf 92       	push	r12
    3d6e:	df 92       	push	r13
    3d70:	ef 92       	push	r14
    3d72:	ff 92       	push	r15
    3d74:	0f 93       	push	r16
    3d76:	1f 93       	push	r17
    3d78:	cf 93       	push	r28
    3d7a:	df 93       	push	r29
    3d7c:	48 2e       	mov	r4, r24
    3d7e:	5a 01       	movw	r10, r20
    3d80:	6b 01       	movw	r12, r22
	double place = 1.0;
	
	// save sign
	negative = (x<0);
	// convert to absolute value
	x = (x>0)?(x):(-x);
    3d82:	cb 01       	movw	r24, r22
    3d84:	ba 01       	movw	r22, r20
    3d86:	20 e0       	ldi	r18, 0x00	; 0
    3d88:	30 e0       	ldi	r19, 0x00	; 0
    3d8a:	40 e0       	ldi	r20, 0x00	; 0
    3d8c:	50 e0       	ldi	r21, 0x00	; 0
    3d8e:	0e 94 0d 27 	call	0x4e1a	; 0x4e1a <__gesf2>
    3d92:	18 16       	cp	r1, r24
    3d94:	1c f4       	brge	.+6      	; 0x3d9c <rprintfFloat+0x40>
    3d96:	35 01       	movw	r6, r10
    3d98:	46 01       	movw	r8, r12
    3d9a:	06 c0       	rjmp	.+12     	; 0x3da8 <rprintfFloat+0x4c>
    3d9c:	35 01       	movw	r6, r10
    3d9e:	46 01       	movw	r8, r12
    3da0:	97 fa       	bst	r9, 7
    3da2:	90 94       	com	r9
    3da4:	97 f8       	bld	r9, 7
    3da6:	90 94       	com	r9
    3da8:	0f 2e       	mov	r0, r31
    3daa:	f0 e0       	ldi	r31, 0x00	; 0
    3dac:	ef 2e       	mov	r14, r31
    3dae:	f0 e0       	ldi	r31, 0x00	; 0
    3db0:	ff 2e       	mov	r15, r31
    3db2:	f0 e8       	ldi	r31, 0x80	; 128
    3db4:	0f 2f       	mov	r16, r31
    3db6:	ff e3       	ldi	r31, 0x3F	; 63
    3db8:	1f 2f       	mov	r17, r31
    3dba:	f0 2d       	mov	r31, r0
    3dbc:	55 24       	eor	r5, r5
	
	// find starting digit place
	for(i=0; i<15; i++)
	{
		if((x/place) < 10.0)
    3dbe:	c4 01       	movw	r24, r8
    3dc0:	b3 01       	movw	r22, r6
    3dc2:	a8 01       	movw	r20, r16
    3dc4:	97 01       	movw	r18, r14
    3dc6:	0e 94 c7 25 	call	0x4b8e	; 0x4b8e <__divsf3>
    3dca:	20 e0       	ldi	r18, 0x00	; 0
    3dcc:	30 e0       	ldi	r19, 0x00	; 0
    3dce:	40 e2       	ldi	r20, 0x20	; 32
    3dd0:	51 e4       	ldi	r21, 0x41	; 65
    3dd2:	0e 94 c3 25 	call	0x4b86	; 0x4b86 <__cmpsf2>
    3dd6:	87 fd       	sbrc	r24, 7
    3dd8:	0e c0       	rjmp	.+28     	; 0x3df6 <rprintfFloat+0x9a>
			break;
		else
			place *= 10.0;
    3dda:	c8 01       	movw	r24, r16
    3ddc:	b7 01       	movw	r22, r14
    3dde:	20 e0       	ldi	r18, 0x00	; 0
    3de0:	30 e0       	ldi	r19, 0x00	; 0
    3de2:	40 e2       	ldi	r20, 0x20	; 32
    3de4:	51 e4       	ldi	r21, 0x41	; 65
    3de6:	0e 94 11 27 	call	0x4e22	; 0x4e22 <__mulsf3>
    3dea:	7b 01       	movw	r14, r22
    3dec:	8c 01       	movw	r16, r24
	negative = (x<0);
	// convert to absolute value
	x = (x>0)?(x):(-x);
	
	// find starting digit place
	for(i=0; i<15; i++)
    3dee:	53 94       	inc	r5
    3df0:	8f e0       	ldi	r24, 0x0F	; 15
    3df2:	58 16       	cp	r5, r24
    3df4:	21 f7       	brne	.-56     	; 0x3dbe <rprintfFloat+0x62>
			break;
		else
			place *= 10.0;
	}
	// print polarity character
	if(negative)
    3df6:	c6 01       	movw	r24, r12
    3df8:	b5 01       	movw	r22, r10
    3dfa:	20 e0       	ldi	r18, 0x00	; 0
    3dfc:	30 e0       	ldi	r19, 0x00	; 0
    3dfe:	40 e0       	ldi	r20, 0x00	; 0
    3e00:	50 e0       	ldi	r21, 0x00	; 0
    3e02:	0e 94 c3 25 	call	0x4b86	; 0x4b86 <__cmpsf2>
    3e06:	88 23       	and	r24, r24
    3e08:	14 f4       	brge	.+4      	; 0x3e0e <rprintfFloat+0xb2>
		rprintfChar('-');
    3e0a:	8d e2       	ldi	r24, 0x2D	; 45
    3e0c:	01 c0       	rjmp	.+2      	; 0x3e10 <rprintfFloat+0xb4>
	else
		rprintfChar('+');
    3e0e:	8b e2       	ldi	r24, 0x2B	; 43
    3e10:	0e 94 58 1d 	call	0x3ab0	; 0x3ab0 <rprintfChar>
    3e14:	dd 24       	eor	r13, r13
    3e16:	aa 24       	eor	r10, r10
    3e18:	56 c0       	rjmp	.+172    	; 0x3ec6 <rprintfFloat+0x16a>

	// print digits
	for(i=0; i<numDigits; i++)
	{
		digit = (x/place);
    3e1a:	c4 01       	movw	r24, r8
    3e1c:	b3 01       	movw	r22, r6
    3e1e:	a8 01       	movw	r20, r16
    3e20:	97 01       	movw	r18, r14
    3e22:	0e 94 c7 25 	call	0x4b8e	; 0x4b8e <__divsf3>
    3e26:	0e 94 2f 26 	call	0x4c5e	; 0x4c5e <__fixunssfsi>
    3e2a:	b6 2e       	mov	r11, r22

		if(digit | firstplace | (place == 1.0))
    3e2c:	d6 2a       	or	r13, r22
    3e2e:	cd 2d       	mov	r28, r13
    3e30:	d0 e0       	ldi	r29, 0x00	; 0
    3e32:	cc 24       	eor	r12, r12
    3e34:	dd 24       	eor	r13, r13
    3e36:	c8 01       	movw	r24, r16
    3e38:	b7 01       	movw	r22, r14
    3e3a:	20 e0       	ldi	r18, 0x00	; 0
    3e3c:	30 e0       	ldi	r19, 0x00	; 0
    3e3e:	40 e8       	ldi	r20, 0x80	; 128
    3e40:	5f e3       	ldi	r21, 0x3F	; 63
    3e42:	0e 94 c3 25 	call	0x4b86	; 0x4b86 <__cmpsf2>
    3e46:	88 23       	and	r24, r24
    3e48:	19 f4       	brne	.+6      	; 0x3e50 <rprintfFloat+0xf4>
    3e4a:	21 e0       	ldi	r18, 0x01	; 1
    3e4c:	c2 2e       	mov	r12, r18
    3e4e:	d1 2c       	mov	r13, r1
    3e50:	cc 29       	or	r28, r12
    3e52:	dd 29       	or	r29, r13
    3e54:	cd 2b       	or	r28, r29
    3e56:	39 f0       	breq	.+14     	; 0x3e66 <rprintfFloat+0x10a>
		{
			firstplace = TRUE;
			rprintfChar(digit+0x30);
    3e58:	8b 2d       	mov	r24, r11
    3e5a:	80 5d       	subi	r24, 0xD0	; 208
    3e5c:	0e 94 58 1d 	call	0x3ab0	; 0x3ab0 <rprintfChar>
    3e60:	dd 24       	eor	r13, r13
    3e62:	da 94       	dec	r13
    3e64:	04 c0       	rjmp	.+8      	; 0x3e6e <rprintfFloat+0x112>
		}
		else
			rprintfChar(' ');
    3e66:	80 e2       	ldi	r24, 0x20	; 32
    3e68:	0e 94 58 1d 	call	0x3ab0	; 0x3ab0 <rprintfChar>
    3e6c:	dd 24       	eor	r13, r13
		
		if(place == 1.0)
    3e6e:	c8 01       	movw	r24, r16
    3e70:	b7 01       	movw	r22, r14
    3e72:	20 e0       	ldi	r18, 0x00	; 0
    3e74:	30 e0       	ldi	r19, 0x00	; 0
    3e76:	40 e8       	ldi	r20, 0x80	; 128
    3e78:	5f e3       	ldi	r21, 0x3F	; 63
    3e7a:	0e 94 c3 25 	call	0x4b86	; 0x4b86 <__cmpsf2>
    3e7e:	88 23       	and	r24, r24
    3e80:	19 f4       	brne	.+6      	; 0x3e88 <rprintfFloat+0x12c>
		{
			rprintfChar('.');
    3e82:	8e e2       	ldi	r24, 0x2E	; 46
    3e84:	0e 94 58 1d 	call	0x3ab0	; 0x3ab0 <rprintfChar>
		}
		
		x -= (digit*place);
    3e88:	6b 2d       	mov	r22, r11
    3e8a:	70 e0       	ldi	r23, 0x00	; 0
    3e8c:	88 27       	eor	r24, r24
    3e8e:	77 fd       	sbrc	r23, 7
    3e90:	80 95       	com	r24
    3e92:	98 2f       	mov	r25, r24
    3e94:	0e 94 5d 26 	call	0x4cba	; 0x4cba <__floatsisf>
    3e98:	a8 01       	movw	r20, r16
    3e9a:	97 01       	movw	r18, r14
    3e9c:	0e 94 11 27 	call	0x4e22	; 0x4e22 <__mulsf3>
    3ea0:	9b 01       	movw	r18, r22
    3ea2:	ac 01       	movw	r20, r24
    3ea4:	c4 01       	movw	r24, r8
    3ea6:	b3 01       	movw	r22, r6
    3ea8:	0e 94 5e 25 	call	0x4abc	; 0x4abc <__subsf3>
    3eac:	3b 01       	movw	r6, r22
    3eae:	4c 01       	movw	r8, r24
		place /= 10.0;
    3eb0:	c8 01       	movw	r24, r16
    3eb2:	b7 01       	movw	r22, r14
    3eb4:	20 e0       	ldi	r18, 0x00	; 0
    3eb6:	30 e0       	ldi	r19, 0x00	; 0
    3eb8:	40 e2       	ldi	r20, 0x20	; 32
    3eba:	51 e4       	ldi	r21, 0x41	; 65
    3ebc:	0e 94 c7 25 	call	0x4b8e	; 0x4b8e <__divsf3>
    3ec0:	7b 01       	movw	r14, r22
    3ec2:	8c 01       	movw	r16, r24
		rprintfChar('-');
	else
		rprintfChar('+');

	// print digits
	for(i=0; i<numDigits; i++)
    3ec4:	a3 94       	inc	r10
    3ec6:	a4 14       	cp	r10, r4
    3ec8:	08 f4       	brcc	.+2      	; 0x3ecc <rprintfFloat+0x170>
    3eca:	a7 cf       	rjmp	.-178    	; 0x3e1a <rprintfFloat+0xbe>
		}
		
		x -= (digit*place);
		place /= 10.0;
	}
}
    3ecc:	df 91       	pop	r29
    3ece:	cf 91       	pop	r28
    3ed0:	1f 91       	pop	r17
    3ed2:	0f 91       	pop	r16
    3ed4:	ff 90       	pop	r15
    3ed6:	ef 90       	pop	r14
    3ed8:	df 90       	pop	r13
    3eda:	cf 90       	pop	r12
    3edc:	bf 90       	pop	r11
    3ede:	af 90       	pop	r10
    3ee0:	9f 90       	pop	r9
    3ee2:	8f 90       	pop	r8
    3ee4:	7f 90       	pop	r7
    3ee6:	6f 90       	pop	r6
    3ee8:	5f 90       	pop	r5
    3eea:	4f 90       	pop	r4
    3eec:	08 95       	ret

00003eee <rprintf1RamRom>:
// Supports:
// %d - decimal
// %x - hex
// %c - character
int rprintf1RamRom(unsigned char stringInRom, const char *format, ...)
{
    3eee:	7f 92       	push	r7
    3ef0:	8f 92       	push	r8
    3ef2:	9f 92       	push	r9
    3ef4:	af 92       	push	r10
    3ef6:	bf 92       	push	r11
    3ef8:	cf 92       	push	r12
    3efa:	df 92       	push	r13
    3efc:	ef 92       	push	r14
    3efe:	ff 92       	push	r15
    3f00:	0f 93       	push	r16
    3f02:	1f 93       	push	r17
    3f04:	df 93       	push	r29
    3f06:	cf 93       	push	r28
    3f08:	cd b7       	in	r28, 0x3d	; 61
    3f0a:	de b7       	in	r29, 0x3e	; 62
    3f0c:	78 88       	ldd	r7, Y+16	; 0x10
    3f0e:	c9 88       	ldd	r12, Y+17	; 0x11
    3f10:	da 88       	ldd	r13, Y+18	; 0x12
    3f12:	63 e1       	ldi	r22, 0x13	; 19
    3f14:	e6 2e       	mov	r14, r22
    3f16:	f1 2c       	mov	r15, r1
    3f18:	ec 0e       	add	r14, r28
    3f1a:	fd 1e       	adc	r15, r29
    3f1c:	14 c0       	rjmp	.+40     	; 0x3f46 <rprintf1RamRom+0x58>
	va_start(ap, format);
	for (;;)
	{
		while ((format_flag = READMEMBYTE(stringInRom,format++) ) != '%')
		{	// Until '%' or '\0'
			if (!format_flag)
    3f1e:	88 23       	and	r24, r24
    3f20:	81 f4       	brne	.+32     	; 0x3f42 <rprintf1RamRom+0x54>
				div_val /= base;
			} while (div_val);
		}
	}
	va_end(ap);
}
    3f22:	80 e0       	ldi	r24, 0x00	; 0
    3f24:	90 e0       	ldi	r25, 0x00	; 0
    3f26:	cf 91       	pop	r28
    3f28:	df 91       	pop	r29
    3f2a:	1f 91       	pop	r17
    3f2c:	0f 91       	pop	r16
    3f2e:	ff 90       	pop	r15
    3f30:	ef 90       	pop	r14
    3f32:	df 90       	pop	r13
    3f34:	cf 90       	pop	r12
    3f36:	bf 90       	pop	r11
    3f38:	af 90       	pop	r10
    3f3a:	9f 90       	pop	r9
    3f3c:	8f 90       	pop	r8
    3f3e:	7f 90       	pop	r7
    3f40:	08 95       	ret
			if (!format_flag)
			{
				va_end(ap);
				return(0);
			}
			rprintfChar(format_flag);
    3f42:	0e 94 58 1d 	call	0x3ab0	; 0x3ab0 <rprintfChar>
    3f46:	96 01       	movw	r18, r12
    3f48:	2f 5f       	subi	r18, 0xFF	; 255
    3f4a:	3f 4f       	sbci	r19, 0xFF	; 255
	va_list ap;

	va_start(ap, format);
	for (;;)
	{
		while ((format_flag = READMEMBYTE(stringInRom,format++) ) != '%')
    3f4c:	77 20       	and	r7, r7
    3f4e:	21 f0       	breq	.+8      	; 0x3f58 <rprintf1RamRom+0x6a>
    3f50:	f6 01       	movw	r30, r12
    3f52:	69 01       	movw	r12, r18
    3f54:	84 91       	lpm	r24, Z+
    3f56:	03 c0       	rjmp	.+6      	; 0x3f5e <rprintf1RamRom+0x70>
    3f58:	f6 01       	movw	r30, r12
    3f5a:	80 81       	ld	r24, Z
    3f5c:	69 01       	movw	r12, r18
    3f5e:	85 32       	cpi	r24, 0x25	; 37
    3f60:	f1 f6       	brne	.-68     	; 0x3f1e <rprintf1RamRom+0x30>
    3f62:	2f 5f       	subi	r18, 0xFF	; 255
    3f64:	3f 4f       	sbci	r19, 0xFF	; 255
				return(0);
			}
			rprintfChar(format_flag);
		}

		switch (format_flag = READMEMBYTE(stringInRom,format++) )
    3f66:	77 20       	and	r7, r7
    3f68:	21 f0       	breq	.+8      	; 0x3f72 <rprintf1RamRom+0x84>
    3f6a:	f6 01       	movw	r30, r12
    3f6c:	69 01       	movw	r12, r18
    3f6e:	84 91       	lpm	r24, Z+
    3f70:	03 c0       	rjmp	.+6      	; 0x3f78 <rprintf1RamRom+0x8a>
    3f72:	f6 01       	movw	r30, r12
    3f74:	80 81       	ld	r24, Z
    3f76:	69 01       	movw	r12, r18
    3f78:	84 36       	cpi	r24, 0x64	; 100
    3f7a:	29 f0       	breq	.+10     	; 0x3f86 <rprintf1RamRom+0x98>
    3f7c:	88 37       	cpi	r24, 0x78	; 120
    3f7e:	81 f0       	breq	.+32     	; 0x3fa0 <rprintf1RamRom+0xb2>
    3f80:	83 36       	cpi	r24, 0x63	; 99
    3f82:	f9 f6       	brne	.-66     	; 0x3f42 <rprintf1RamRom+0x54>
    3f84:	06 c0       	rjmp	.+12     	; 0x3f92 <rprintf1RamRom+0xa4>
    3f86:	00 e1       	ldi	r16, 0x10	; 16
    3f88:	17 e2       	ldi	r17, 0x27	; 39
    3f8a:	5a e0       	ldi	r21, 0x0A	; 10
    3f8c:	a5 2e       	mov	r10, r21
    3f8e:	b1 2c       	mov	r11, r1
    3f90:	0c c0       	rjmp	.+24     	; 0x3faa <rprintf1RamRom+0xbc>
		{
			case 'c': format_flag = va_arg(ap,int);
    3f92:	f7 01       	movw	r30, r14
    3f94:	80 81       	ld	r24, Z
    3f96:	22 e0       	ldi	r18, 0x02	; 2
    3f98:	30 e0       	ldi	r19, 0x00	; 0
    3f9a:	e2 0e       	add	r14, r18
    3f9c:	f3 1e       	adc	r15, r19
    3f9e:	d1 cf       	rjmp	.-94     	; 0x3f42 <rprintf1RamRom+0x54>
			default:  rprintfChar(format_flag); continue;
    3fa0:	00 e0       	ldi	r16, 0x00	; 0
    3fa2:	10 e1       	ldi	r17, 0x10	; 16
    3fa4:	40 e1       	ldi	r20, 0x10	; 16
    3fa6:	a4 2e       	mov	r10, r20
    3fa8:	b1 2c       	mov	r11, r1
			case 'd': base = 10; div_val = 10000; goto CONVERSION_LOOP;
//			case 'x': base = 16; div_val = 0x10;
			case 'x': base = 16; div_val = 0x1000;

			CONVERSION_LOOP:
			u_val = va_arg(ap,int);
    3faa:	32 e0       	ldi	r19, 0x02	; 2
    3fac:	83 2e       	mov	r8, r19
    3fae:	91 2c       	mov	r9, r1
    3fb0:	8e 0c       	add	r8, r14
    3fb2:	9f 1c       	adc	r9, r15
    3fb4:	f7 01       	movw	r30, r14
    3fb6:	e0 80       	ld	r14, Z
    3fb8:	f1 80       	ldd	r15, Z+1	; 0x01
			if (format_flag == 'd')
    3fba:	84 36       	cpi	r24, 0x64	; 100
    3fbc:	b1 f4       	brne	.+44     	; 0x3fea <rprintf1RamRom+0xfc>
			{
				if (((int)u_val) < 0)
    3fbe:	f7 fe       	sbrs	r15, 7
    3fc0:	11 c0       	rjmp	.+34     	; 0x3fe4 <rprintf1RamRom+0xf6>
				{
					u_val = - u_val;
    3fc2:	f0 94       	com	r15
    3fc4:	e1 94       	neg	r14
    3fc6:	f1 08       	sbc	r15, r1
    3fc8:	f3 94       	inc	r15
					rprintfChar('-');
    3fca:	8d e2       	ldi	r24, 0x2D	; 45
    3fcc:	0e 94 58 1d 	call	0x3ab0	; 0x3ab0 <rprintfChar>
    3fd0:	09 c0       	rjmp	.+18     	; 0x3fe4 <rprintf1RamRom+0xf6>
				}
				while (div_val > 1 && div_val > u_val) div_val /= 10;
    3fd2:	c8 01       	movw	r24, r16
    3fd4:	6a e0       	ldi	r22, 0x0A	; 10
    3fd6:	70 e0       	ldi	r23, 0x00	; 0
    3fd8:	0e 94 74 27 	call	0x4ee8	; 0x4ee8 <__udivmodhi4>
    3fdc:	8b 01       	movw	r16, r22
    3fde:	62 30       	cpi	r22, 0x02	; 2
    3fe0:	71 05       	cpc	r23, r1
    3fe2:	18 f0       	brcs	.+6      	; 0x3fea <rprintf1RamRom+0xfc>
    3fe4:	e0 16       	cp	r14, r16
    3fe6:	f1 06       	cpc	r15, r17
    3fe8:	a0 f3       	brcs	.-24     	; 0x3fd2 <rprintf1RamRom+0xe4>
			}
			do
			{
				//rprintfChar(pgm_read_byte(HexChars+(u_val/div_val)));
				rprintfu04(u_val/div_val);
    3fea:	c7 01       	movw	r24, r14
    3fec:	b8 01       	movw	r22, r16
    3fee:	0e 94 74 27 	call	0x4ee8	; 0x4ee8 <__udivmodhi4>
    3ff2:	86 2f       	mov	r24, r22
    3ff4:	0e 94 bb 1d 	call	0x3b76	; 0x3b76 <rprintfu04>
				u_val %= div_val;
    3ff8:	c7 01       	movw	r24, r14
    3ffa:	b8 01       	movw	r22, r16
    3ffc:	0e 94 74 27 	call	0x4ee8	; 0x4ee8 <__udivmodhi4>
    4000:	7c 01       	movw	r14, r24
				div_val /= base;
    4002:	c8 01       	movw	r24, r16
    4004:	b5 01       	movw	r22, r10
    4006:	0e 94 74 27 	call	0x4ee8	; 0x4ee8 <__udivmodhi4>
    400a:	8b 01       	movw	r16, r22
			} while (div_val);
    400c:	61 15       	cp	r22, r1
    400e:	71 05       	cpc	r23, r1
    4010:	61 f7       	brne	.-40     	; 0x3fea <rprintf1RamRom+0xfc>
    4012:	74 01       	movw	r14, r8
    4014:	98 cf       	rjmp	.-208    	; 0x3f46 <rprintf1RamRom+0x58>

00004016 <i2cSetBitrate>:
	// SCL freq = F_CPU/(16+2*TWBR))
	#ifdef TWPS0
		// for processors with additional bitrate division (mega128)
		// SCL freq = F_CPU/(16+2*TWBR*4^TWPS)
		// set TWPS to zero
		cbi(TWSR, TWPS0);
    4016:	20 91 b9 00 	lds	r18, 0x00B9
    401a:	2e 7f       	andi	r18, 0xFE	; 254
    401c:	20 93 b9 00 	sts	0x00B9, r18
		cbi(TWSR, TWPS1);
    4020:	20 91 b9 00 	lds	r18, 0x00B9
    4024:	2d 7f       	andi	r18, 0xFD	; 253
    4026:	20 93 b9 00 	sts	0x00B9, r18
	#endif
	// calculate bitrate division	
	bitrate_div = ((F_CPU/1000l)/bitrateKHz);
    402a:	9c 01       	movw	r18, r24
    402c:	40 e0       	ldi	r20, 0x00	; 0
    402e:	50 e0       	ldi	r21, 0x00	; 0
    4030:	60 e8       	ldi	r22, 0x80	; 128
    4032:	7e e3       	ldi	r23, 0x3E	; 62
    4034:	80 e0       	ldi	r24, 0x00	; 0
    4036:	90 e0       	ldi	r25, 0x00	; 0
    4038:	0e 94 bd 27 	call	0x4f7a	; 0x4f7a <__divmodsi4>
	if(bitrate_div >= 16)
    403c:	20 31       	cpi	r18, 0x10	; 16
    403e:	30 f0       	brcs	.+12     	; 0x404c <i2cSetBitrate+0x36>
		bitrate_div = (bitrate_div-16)/2;
    4040:	82 2f       	mov	r24, r18
    4042:	90 e0       	ldi	r25, 0x00	; 0
    4044:	40 97       	sbiw	r24, 0x10	; 16
    4046:	95 95       	asr	r25
    4048:	87 95       	ror	r24
    404a:	28 2f       	mov	r18, r24
	outb(TWBR, bitrate_div);
    404c:	20 93 b8 00 	sts	0x00B8, r18
}
    4050:	08 95       	ret

00004052 <i2cInit>:

// functions
void i2cInit(void)
{
	// set pull-up resistors on I2C bus pins
	sbi(PORTD, 0);	// i2c SCL on 640
    4052:	58 9a       	sbi	0x0b, 0	; 11
	sbi(PORTD, 1);	// i2c SDA on 640
    4054:	59 9a       	sbi	0x0b, 1	; 11

	// clear SlaveReceive and SlaveTransmit handler to null
	i2cSlaveReceive = 0;
    4056:	10 92 ab 11 	sts	0x11AB, r1
    405a:	10 92 aa 11 	sts	0x11AA, r1
	i2cSlaveTransmit = 0;
    405e:	10 92 ad 11 	sts	0x11AD, r1
    4062:	10 92 ac 11 	sts	0x11AC, r1
	// set i2c bit rate to 100KHz
	i2cSetBitrate(100);
    4066:	84 e6       	ldi	r24, 0x64	; 100
    4068:	90 e0       	ldi	r25, 0x00	; 0
    406a:	0e 94 0b 20 	call	0x4016	; 0x4016 <i2cSetBitrate>
	// enable TWI (two-wire interface)
	sbi(TWCR, TWEN);
    406e:	ec eb       	ldi	r30, 0xBC	; 188
    4070:	f0 e0       	ldi	r31, 0x00	; 0
    4072:	80 81       	ld	r24, Z
    4074:	84 60       	ori	r24, 0x04	; 4
    4076:	80 83       	st	Z, r24
	// set state
	I2cState = I2C_IDLE;
    4078:	10 92 64 11 	sts	0x1164, r1
	// enable TWI interrupt and slave address ACK
	sbi(TWCR, TWIE);
    407c:	80 81       	ld	r24, Z
    407e:	81 60       	ori	r24, 0x01	; 1
    4080:	80 83       	st	Z, r24
	sbi(TWCR, TWEA);
    4082:	80 81       	ld	r24, Z
    4084:	80 64       	ori	r24, 0x40	; 64
    4086:	80 83       	st	Z, r24
	//outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
	// enable interrupts
	sei();
    4088:	78 94       	sei
}
    408a:	08 95       	ret

0000408c <i2cSetLocalDeviceAddr>:
}

void i2cSetLocalDeviceAddr(u08 deviceAddr, u08 genCallEn)
{
	// set local device address (used in slave mode only)
	outb(TWAR, ((deviceAddr&0xFE) | (genCallEn?1:0)) );
    408c:	90 e0       	ldi	r25, 0x00	; 0
    408e:	61 11       	cpse	r22, r1
    4090:	91 e0       	ldi	r25, 0x01	; 1
    4092:	8e 7f       	andi	r24, 0xFE	; 254
    4094:	98 2b       	or	r25, r24
    4096:	90 93 ba 00 	sts	0x00BA, r25
}
    409a:	08 95       	ret

0000409c <i2cSetSlaveReceiveHandler>:

void i2cSetSlaveReceiveHandler(void (*i2cSlaveRx_func)(u08 receiveDataLength, u08* recieveData))
{
	i2cSlaveReceive = i2cSlaveRx_func;
    409c:	90 93 ab 11 	sts	0x11AB, r25
    40a0:	80 93 aa 11 	sts	0x11AA, r24
}
    40a4:	08 95       	ret

000040a6 <i2cSetSlaveTransmitHandler>:

void i2cSetSlaveTransmitHandler(u08 (*i2cSlaveTx_func)(u08 transmitDataLengthMax, u08* transmitData))
{
	i2cSlaveTransmit = i2cSlaveTx_func;
    40a6:	90 93 ad 11 	sts	0x11AD, r25
    40aa:	80 93 ac 11 	sts	0x11AC, r24
}
    40ae:	08 95       	ret

000040b0 <i2cSendStart>:

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    40b0:	ec eb       	ldi	r30, 0xBC	; 188
    40b2:	f0 e0       	ldi	r31, 0x00	; 0
    40b4:	80 81       	ld	r24, Z
    40b6:	8f 70       	andi	r24, 0x0F	; 15
    40b8:	80 6a       	ori	r24, 0xA0	; 160
    40ba:	80 83       	st	Z, r24
}
    40bc:	08 95       	ret

000040be <i2cSendStop>:

inline void i2cSendStop(void)
{
	// transmit stop condition
	// leave with TWEA on for slave receiving
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA)|BV(TWSTO));
    40be:	ec eb       	ldi	r30, 0xBC	; 188
    40c0:	f0 e0       	ldi	r31, 0x00	; 0
    40c2:	80 81       	ld	r24, Z
    40c4:	8f 70       	andi	r24, 0x0F	; 15
    40c6:	80 6d       	ori	r24, 0xD0	; 208
    40c8:	80 83       	st	Z, r24
}
    40ca:	08 95       	ret

000040cc <i2cWaitForComplete>:

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    40cc:	80 91 bc 00 	lds	r24, 0x00BC
    40d0:	87 ff       	sbrs	r24, 7
    40d2:	fc cf       	rjmp	.-8      	; 0x40cc <i2cWaitForComplete>
}
    40d4:	08 95       	ret

000040d6 <i2cSendByte>:

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    40d6:	80 93 bb 00 	sts	0x00BB, r24
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    40da:	ec eb       	ldi	r30, 0xBC	; 188
    40dc:	f0 e0       	ldi	r31, 0x00	; 0
    40de:	80 81       	ld	r24, Z
    40e0:	8f 70       	andi	r24, 0x0F	; 15
    40e2:	80 68       	ori	r24, 0x80	; 128
    40e4:	80 83       	st	Z, r24
}
    40e6:	08 95       	ret

000040e8 <i2cReceiveByte>:

inline void i2cReceiveByte(u08 ackFlag)
{
	// begin receive over i2c
	if( ackFlag )
    40e8:	88 23       	and	r24, r24
    40ea:	29 f0       	breq	.+10     	; 0x40f6 <i2cReceiveByte+0xe>
	{
		// ackFlag = TRUE: ACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    40ec:	80 91 bc 00 	lds	r24, 0x00BC
    40f0:	8f 70       	andi	r24, 0x0F	; 15
    40f2:	80 6c       	ori	r24, 0xC0	; 192
    40f4:	04 c0       	rjmp	.+8      	; 0x40fe <i2cReceiveByte+0x16>
	}
	else
	{
		// ackFlag = FALSE: NACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    40f6:	80 91 bc 00 	lds	r24, 0x00BC
    40fa:	8f 70       	andi	r24, 0x0F	; 15
    40fc:	80 68       	ori	r24, 0x80	; 128
    40fe:	80 93 bc 00 	sts	0x00BC, r24
    4102:	08 95       	ret

00004104 <i2cGetReceivedByte>:
}

inline u08 i2cGetReceivedByte(void)
{
	// retieve received data byte from i2c TWDR
	return( inb(TWDR) );
    4104:	80 91 bb 00 	lds	r24, 0x00BB
}
    4108:	08 95       	ret

0000410a <i2cGetStatus>:

inline u08 i2cGetStatus(void)
{
	// retieve current i2c status from i2c TWSR
	return( inb(TWSR) );
    410a:	80 91 b9 00 	lds	r24, 0x00B9
}
    410e:	08 95       	ret

00004110 <i2cMasterSend>:

void i2cMasterSend(u08 deviceAddr, u08 length, u08* data)
{
    4110:	98 2f       	mov	r25, r24
	u08 i;
	// wait for interface to be ready
	while(I2cState);
    4112:	80 91 64 11 	lds	r24, 0x1164
    4116:	88 23       	and	r24, r24
    4118:	e1 f7       	brne	.-8      	; 0x4112 <i2cMasterSend+0x2>
	// set state
	I2cState = I2C_MASTER_TX;
    411a:	82 e0       	ldi	r24, 0x02	; 2
    411c:	80 93 64 11 	sts	0x1164, r24
	// save data
	I2cDeviceAddrRW = (deviceAddr & 0xFE);	// RW cleared: write operation
    4120:	9e 7f       	andi	r25, 0xFE	; 254
    4122:	90 93 65 11 	sts	0x1165, r25
    4126:	a6 e6       	ldi	r26, 0x66	; 102
    4128:	b1 e1       	ldi	r27, 0x11	; 17
    412a:	fa 01       	movw	r30, r20
    412c:	02 c0       	rjmp	.+4      	; 0x4132 <i2cMasterSend+0x22>
	for(i=0; i<length; i++)
		I2cSendData[i] = *data++;
    412e:	81 91       	ld	r24, Z+
    4130:	8d 93       	st	X+, r24
	while(I2cState);
	// set state
	I2cState = I2C_MASTER_TX;
	// save data
	I2cDeviceAddrRW = (deviceAddr & 0xFE);	// RW cleared: write operation
	for(i=0; i<length; i++)
    4132:	8e 2f       	mov	r24, r30
    4134:	84 1b       	sub	r24, r20
    4136:	86 17       	cp	r24, r22
    4138:	d0 f3       	brcs	.-12     	; 0x412e <i2cMasterSend+0x1e>
		I2cSendData[i] = *data++;
	I2cSendDataIndex = 0;
    413a:	10 92 86 11 	sts	0x1186, r1
	I2cSendDataLength = length;
    413e:	60 93 87 11 	sts	0x1187, r22
}

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    4142:	80 91 bc 00 	lds	r24, 0x00BC
    4146:	8f 70       	andi	r24, 0x0F	; 15
    4148:	80 6a       	ori	r24, 0xA0	; 160
    414a:	80 93 bc 00 	sts	0x00BC, r24
		I2cSendData[i] = *data++;
	I2cSendDataIndex = 0;
	I2cSendDataLength = length;
	// send start condition
	i2cSendStart();
}
    414e:	08 95       	ret

00004150 <i2cMasterReceive>:

void i2cMasterReceive(u08 deviceAddr, u08 length, u08* data)
{
    4150:	98 2f       	mov	r25, r24
	u08 i;
	// wait for interface to be ready
	while(I2cState);
    4152:	80 91 64 11 	lds	r24, 0x1164
    4156:	88 23       	and	r24, r24
    4158:	e1 f7       	brne	.-8      	; 0x4152 <i2cMasterReceive+0x2>
	// set state
	I2cState = I2C_MASTER_RX;
    415a:	83 e0       	ldi	r24, 0x03	; 3
    415c:	80 93 64 11 	sts	0x1164, r24
	// save data
	I2cDeviceAddrRW = (deviceAddr|0x01);	// RW set: read operation
    4160:	91 60       	ori	r25, 0x01	; 1
    4162:	90 93 65 11 	sts	0x1165, r25
	I2cReceiveDataIndex = 0;
    4166:	10 92 a8 11 	sts	0x11A8, r1
	I2cReceiveDataLength = length;
    416a:	60 93 a9 11 	sts	0x11A9, r22
}

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    416e:	80 91 bc 00 	lds	r24, 0x00BC
    4172:	8f 70       	andi	r24, 0x0F	; 15
    4174:	80 6a       	ori	r24, 0xA0	; 160
    4176:	80 93 bc 00 	sts	0x00BC, r24
	I2cReceiveDataIndex = 0;
	I2cReceiveDataLength = length;
	// send start condition
	i2cSendStart();
	// wait for data
	while(I2cState);
    417a:	80 91 64 11 	lds	r24, 0x1164
    417e:	88 23       	and	r24, r24
    4180:	e1 f7       	brne	.-8      	; 0x417a <i2cMasterReceive+0x2a>
    4182:	a8 e8       	ldi	r26, 0x88	; 136
    4184:	b1 e1       	ldi	r27, 0x11	; 17
    4186:	fa 01       	movw	r30, r20
    4188:	02 c0       	rjmp	.+4      	; 0x418e <i2cMasterReceive+0x3e>
	// return data
	for(i=0; i<length; i++)
		*data++ = I2cReceiveData[i];
    418a:	8d 91       	ld	r24, X+
    418c:	81 93       	st	Z+, r24
	// send start condition
	i2cSendStart();
	// wait for data
	while(I2cState);
	// return data
	for(i=0; i<length; i++)
    418e:	8e 2f       	mov	r24, r30
    4190:	84 1b       	sub	r24, r20
    4192:	86 17       	cp	r24, r22
    4194:	d0 f3       	brcs	.-12     	; 0x418a <i2cMasterReceive+0x3a>
		*data++ = I2cReceiveData[i];
}
    4196:	08 95       	ret

00004198 <i2cMasterSendNI>:

u08 i2cMasterSendNI(u08 deviceAddr, u08 length, u08* data)
{
    4198:	98 2f       	mov	r25, r24
    419a:	fa 01       	movw	r30, r20
	u08 retval = I2C_OK;

	// disable TWI interrupt
	cbi(TWCR, TWIE);
    419c:	80 91 bc 00 	lds	r24, 0x00BC
    41a0:	8e 7f       	andi	r24, 0xFE	; 254
    41a2:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    41a6:	80 91 bc 00 	lds	r24, 0x00BC
    41aa:	8f 70       	andi	r24, 0x0F	; 15
    41ac:	80 6a       	ori	r24, 0xA0	; 160
    41ae:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    41b2:	80 91 bc 00 	lds	r24, 0x00BC
    41b6:	87 ff       	sbrs	r24, 7
    41b8:	fc cf       	rjmp	.-8      	; 0x41b2 <i2cMasterSendNI+0x1a>
	// send start condition
	i2cSendStart();
	i2cWaitForComplete();

	// send device address with write
	i2cSendByte( deviceAddr & 0xFE );
    41ba:	9e 7f       	andi	r25, 0xFE	; 254
}

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    41bc:	90 93 bb 00 	sts	0x00BB, r25
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    41c0:	80 91 bc 00 	lds	r24, 0x00BC
    41c4:	8f 70       	andi	r24, 0x0F	; 15
    41c6:	80 68       	ori	r24, 0x80	; 128
    41c8:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    41cc:	80 91 bc 00 	lds	r24, 0x00BC
    41d0:	87 ff       	sbrs	r24, 7
    41d2:	fc cf       	rjmp	.-8      	; 0x41cc <i2cMasterSendNI+0x34>
	// send device address with write
	i2cSendByte( deviceAddr & 0xFE );
	i2cWaitForComplete();

	// check if device is present and live
	if( inb(TWSR) == TW_MT_SLA_ACK)
    41d4:	80 91 b9 00 	lds	r24, 0x00B9
    41d8:	88 31       	cpi	r24, 0x18	; 24
    41da:	89 f0       	breq	.+34     	; 0x41fe <i2cMasterSendNI+0x66>
    41dc:	91 e0       	ldi	r25, 0x01	; 1
    41de:	12 c0       	rjmp	.+36     	; 0x4204 <i2cMasterSendNI+0x6c>
	{
		// send data
		while(length)
		{
			i2cSendByte( *data++ );
    41e0:	80 81       	ld	r24, Z
}

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    41e2:	80 93 bb 00 	sts	0x00BB, r24
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    41e6:	80 91 bc 00 	lds	r24, 0x00BC
    41ea:	8f 70       	andi	r24, 0x0F	; 15
    41ec:	80 68       	ori	r24, 0x80	; 128
    41ee:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    41f2:	80 91 bc 00 	lds	r24, 0x00BC
    41f6:	87 ff       	sbrs	r24, 7
    41f8:	fc cf       	rjmp	.-8      	; 0x41f2 <i2cMasterSendNI+0x5a>
	if( inb(TWSR) == TW_MT_SLA_ACK)
	{
		// send data
		while(length)
		{
			i2cSendByte( *data++ );
    41fa:	31 96       	adiw	r30, 0x01	; 1
			i2cWaitForComplete();
			length--;
    41fc:	61 50       	subi	r22, 0x01	; 1

	// check if device is present and live
	if( inb(TWSR) == TW_MT_SLA_ACK)
	{
		// send data
		while(length)
    41fe:	66 23       	and	r22, r22
    4200:	79 f7       	brne	.-34     	; 0x41e0 <i2cMasterSendNI+0x48>
    4202:	90 e0       	ldi	r25, 0x00	; 0

inline void i2cSendStop(void)
{
	// transmit stop condition
	// leave with TWEA on for slave receiving
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA)|BV(TWSTO));
    4204:	80 91 bc 00 	lds	r24, 0x00BC
    4208:	8f 70       	andi	r24, 0x0F	; 15
    420a:	80 6d       	ori	r24, 0xD0	; 208
    420c:	80 93 bc 00 	sts	0x00BC, r24
	}

	// transmit stop condition
	// leave with TWEA on for slave receiving
	i2cSendStop();
	while( !(inb(TWCR) & BV(TWSTO)) );
    4210:	80 91 bc 00 	lds	r24, 0x00BC
    4214:	84 ff       	sbrs	r24, 4
    4216:	fc cf       	rjmp	.-8      	; 0x4210 <i2cMasterSendNI+0x78>

	// enable TWI interrupt
	sbi(TWCR, TWIE);
    4218:	80 91 bc 00 	lds	r24, 0x00BC
    421c:	81 60       	ori	r24, 0x01	; 1
    421e:	80 93 bc 00 	sts	0x00BC, r24

	return retval;
}
    4222:	89 2f       	mov	r24, r25
    4224:	08 95       	ret

00004226 <i2cMasterReceiveNI>:

u08 i2cMasterReceiveNI(u08 deviceAddr, u08 length, u08 *data)
{
    4226:	98 2f       	mov	r25, r24
    4228:	fa 01       	movw	r30, r20
	u08 retval = I2C_OK;

	// disable TWI interrupt
	cbi(TWCR, TWIE);
    422a:	80 91 bc 00 	lds	r24, 0x00BC
    422e:	8e 7f       	andi	r24, 0xFE	; 254
    4230:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    4234:	80 91 bc 00 	lds	r24, 0x00BC
    4238:	8f 70       	andi	r24, 0x0F	; 15
    423a:	80 6a       	ori	r24, 0xA0	; 160
    423c:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    4240:	80 91 bc 00 	lds	r24, 0x00BC
    4244:	87 ff       	sbrs	r24, 7
    4246:	fc cf       	rjmp	.-8      	; 0x4240 <i2cMasterReceiveNI+0x1a>
	// send start condition
	i2cSendStart();
	i2cWaitForComplete();

	// send device address with read
	i2cSendByte( deviceAddr | 0x01 );
    4248:	91 60       	ori	r25, 0x01	; 1
}

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    424a:	90 93 bb 00 	sts	0x00BB, r25
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    424e:	80 91 bc 00 	lds	r24, 0x00BC
    4252:	8f 70       	andi	r24, 0x0F	; 15
    4254:	80 68       	ori	r24, 0x80	; 128
    4256:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    425a:	80 91 bc 00 	lds	r24, 0x00BC
    425e:	87 ff       	sbrs	r24, 7
    4260:	fc cf       	rjmp	.-8      	; 0x425a <i2cMasterReceiveNI+0x34>
	// send device address with read
	i2cSendByte( deviceAddr | 0x01 );
	i2cWaitForComplete();

	// check if device is present and live
	if( inb(TWSR) == TW_MR_SLA_ACK)
    4262:	80 91 b9 00 	lds	r24, 0x00B9
    4266:	80 34       	cpi	r24, 0x40	; 64
    4268:	81 f0       	breq	.+32     	; 0x428a <i2cMasterReceiveNI+0x64>
    426a:	91 e0       	ldi	r25, 0x01	; 1
    426c:	1e c0       	rjmp	.+60     	; 0x42aa <i2cMasterReceiveNI+0x84>
{
	// begin receive over i2c
	if( ackFlag )
	{
		// ackFlag = TRUE: ACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    426e:	80 91 bc 00 	lds	r24, 0x00BC
    4272:	8f 70       	andi	r24, 0x0F	; 15
    4274:	80 6c       	ori	r24, 0xC0	; 192
    4276:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    427a:	80 91 bc 00 	lds	r24, 0x00BC
    427e:	87 ff       	sbrs	r24, 7
    4280:	fc cf       	rjmp	.-8      	; 0x427a <i2cMasterReceiveNI+0x54>
}

inline u08 i2cGetReceivedByte(void)
{
	// retieve received data byte from i2c TWDR
	return( inb(TWDR) );
    4282:	80 91 bb 00 	lds	r24, 0x00BB
		// accept receive data and ack it
		while(length > 1)
		{
			i2cReceiveByte(TRUE);
			i2cWaitForComplete();
			*data++ = i2cGetReceivedByte();
    4286:	81 93       	st	Z+, r24
			// decrement length
			length--;
    4288:	61 50       	subi	r22, 0x01	; 1

	// check if device is present and live
	if( inb(TWSR) == TW_MR_SLA_ACK)
	{
		// accept receive data and ack it
		while(length > 1)
    428a:	62 30       	cpi	r22, 0x02	; 2
    428c:	80 f7       	brcc	.-32     	; 0x426e <i2cMasterReceiveNI+0x48>
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
	}
	else
	{
		// ackFlag = FALSE: NACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    428e:	80 91 bc 00 	lds	r24, 0x00BC
    4292:	8f 70       	andi	r24, 0x0F	; 15
    4294:	80 68       	ori	r24, 0x80	; 128
    4296:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    429a:	80 91 bc 00 	lds	r24, 0x00BC
    429e:	87 ff       	sbrs	r24, 7
    42a0:	fc cf       	rjmp	.-8      	; 0x429a <i2cMasterReceiveNI+0x74>
}

inline u08 i2cGetReceivedByte(void)
{
	// retieve received data byte from i2c TWDR
	return( inb(TWDR) );
    42a2:	80 91 bb 00 	lds	r24, 0x00BB
		}

		// accept receive data and nack it (last-byte signal)
		i2cReceiveByte(FALSE);
		i2cWaitForComplete();
		*data++ = i2cGetReceivedByte();
    42a6:	80 83       	st	Z, r24
    42a8:	90 e0       	ldi	r25, 0x00	; 0

inline void i2cSendStop(void)
{
	// transmit stop condition
	// leave with TWEA on for slave receiving
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA)|BV(TWSTO));
    42aa:	80 91 bc 00 	lds	r24, 0x00BC
    42ae:	8f 70       	andi	r24, 0x0F	; 15
    42b0:	80 6d       	ori	r24, 0xD0	; 208
    42b2:	80 93 bc 00 	sts	0x00BC, r24
	// transmit stop condition
	// leave with TWEA on for slave receiving
	i2cSendStop();

	// enable TWI interrupt
	sbi(TWCR, TWIE);
    42b6:	80 91 bc 00 	lds	r24, 0x00BC
    42ba:	81 60       	ori	r24, 0x01	; 1
    42bc:	80 93 bc 00 	sts	0x00BC, r24

	return retval;
}
    42c0:	89 2f       	mov	r24, r25
    42c2:	08 95       	ret

000042c4 <__vector_39>:
}
*/

//! I2C (TWI) interrupt service routine
SIGNAL(SIG_2WIRE_SERIAL)
{
    42c4:	1f 92       	push	r1
    42c6:	0f 92       	push	r0
    42c8:	0f b6       	in	r0, 0x3f	; 63
    42ca:	0f 92       	push	r0
    42cc:	11 24       	eor	r1, r1
    42ce:	2f 93       	push	r18
    42d0:	3f 93       	push	r19
    42d2:	4f 93       	push	r20
    42d4:	5f 93       	push	r21
    42d6:	6f 93       	push	r22
    42d8:	7f 93       	push	r23
    42da:	8f 93       	push	r24
    42dc:	9f 93       	push	r25
    42de:	af 93       	push	r26
    42e0:	bf 93       	push	r27
    42e2:	ef 93       	push	r30
    42e4:	ff 93       	push	r31
	// read status bits
	u08 status = inb(TWSR) & TWSR_STATUS_MASK;
    42e6:	80 91 b9 00 	lds	r24, 0x00B9

	switch(status)
    42ea:	88 7f       	andi	r24, 0xF8	; 248
    42ec:	80 36       	cpi	r24, 0x60	; 96
    42ee:	09 f4       	brne	.+2      	; 0x42f2 <__vector_39+0x2e>
    42f0:	a0 c0       	rjmp	.+320    	; 0x4432 <__vector_39+0x16e>
    42f2:	81 36       	cpi	r24, 0x61	; 97
    42f4:	70 f5       	brcc	.+92     	; 0x4352 <__vector_39+0x8e>
    42f6:	88 32       	cpi	r24, 0x28	; 40
    42f8:	09 f4       	brne	.+2      	; 0x42fc <__vector_39+0x38>
    42fa:	5f c0       	rjmp	.+190    	; 0x43ba <__vector_39+0xf6>
    42fc:	89 32       	cpi	r24, 0x29	; 41
    42fe:	98 f4       	brcc	.+38     	; 0x4326 <__vector_39+0x62>
    4300:	80 31       	cpi	r24, 0x10	; 16
    4302:	09 f4       	brne	.+2      	; 0x4306 <__vector_39+0x42>
    4304:	57 c0       	rjmp	.+174    	; 0x43b4 <__vector_39+0xf0>
    4306:	81 31       	cpi	r24, 0x11	; 17
    4308:	38 f4       	brcc	.+14     	; 0x4318 <__vector_39+0x54>
    430a:	88 23       	and	r24, r24
    430c:	09 f4       	brne	.+2      	; 0x4310 <__vector_39+0x4c>
    430e:	ea c0       	rjmp	.+468    	; 0x44e4 <__vector_39+0x220>
    4310:	88 30       	cpi	r24, 0x08	; 8
    4312:	09 f0       	breq	.+2      	; 0x4316 <__vector_39+0x52>
    4314:	ef c0       	rjmp	.+478    	; 0x44f4 <__vector_39+0x230>
    4316:	4e c0       	rjmp	.+156    	; 0x43b4 <__vector_39+0xf0>
    4318:	88 31       	cpi	r24, 0x18	; 24
    431a:	09 f4       	brne	.+2      	; 0x431e <__vector_39+0x5a>
    431c:	4e c0       	rjmp	.+156    	; 0x43ba <__vector_39+0xf6>
    431e:	80 32       	cpi	r24, 0x20	; 32
    4320:	09 f0       	breq	.+2      	; 0x4324 <__vector_39+0x60>
    4322:	e8 c0       	rjmp	.+464    	; 0x44f4 <__vector_39+0x230>
    4324:	df c0       	rjmp	.+446    	; 0x44e4 <__vector_39+0x220>
    4326:	80 34       	cpi	r24, 0x40	; 64
    4328:	09 f4       	brne	.+2      	; 0x432c <__vector_39+0x68>
    432a:	77 c0       	rjmp	.+238    	; 0x441a <__vector_39+0x156>
    432c:	81 34       	cpi	r24, 0x41	; 65
    432e:	38 f4       	brcc	.+14     	; 0x433e <__vector_39+0x7a>
    4330:	80 33       	cpi	r24, 0x30	; 48
    4332:	09 f4       	brne	.+2      	; 0x4336 <__vector_39+0x72>
    4334:	d7 c0       	rjmp	.+430    	; 0x44e4 <__vector_39+0x220>
    4336:	88 33       	cpi	r24, 0x38	; 56
    4338:	09 f0       	breq	.+2      	; 0x433c <__vector_39+0x78>
    433a:	dc c0       	rjmp	.+440    	; 0x44f4 <__vector_39+0x230>
    433c:	5d c0       	rjmp	.+186    	; 0x43f8 <__vector_39+0x134>
    433e:	80 35       	cpi	r24, 0x50	; 80
    4340:	09 f4       	brne	.+2      	; 0x4344 <__vector_39+0x80>
    4342:	5f c0       	rjmp	.+190    	; 0x4402 <__vector_39+0x13e>
    4344:	88 35       	cpi	r24, 0x58	; 88
    4346:	09 f4       	brne	.+2      	; 0x434a <__vector_39+0x86>
    4348:	4a c0       	rjmp	.+148    	; 0x43de <__vector_39+0x11a>
    434a:	88 34       	cpi	r24, 0x48	; 72
    434c:	09 f0       	breq	.+2      	; 0x4350 <__vector_39+0x8c>
    434e:	d2 c0       	rjmp	.+420    	; 0x44f4 <__vector_39+0x230>
    4350:	c9 c0       	rjmp	.+402    	; 0x44e4 <__vector_39+0x220>
    4352:	88 39       	cpi	r24, 0x98	; 152
    4354:	09 f4       	brne	.+2      	; 0x4358 <__vector_39+0x94>
    4356:	ba c0       	rjmp	.+372    	; 0x44cc <__vector_39+0x208>
    4358:	89 39       	cpi	r24, 0x99	; 153
    435a:	b0 f4       	brcc	.+44     	; 0x4388 <__vector_39+0xc4>
    435c:	88 37       	cpi	r24, 0x78	; 120
    435e:	09 f4       	brne	.+2      	; 0x4362 <__vector_39+0x9e>
    4360:	68 c0       	rjmp	.+208    	; 0x4432 <__vector_39+0x16e>
    4362:	89 37       	cpi	r24, 0x79	; 121
    4364:	38 f4       	brcc	.+14     	; 0x4374 <__vector_39+0xb0>
    4366:	88 36       	cpi	r24, 0x68	; 104
    4368:	09 f4       	brne	.+2      	; 0x436c <__vector_39+0xa8>
    436a:	63 c0       	rjmp	.+198    	; 0x4432 <__vector_39+0x16e>
    436c:	80 37       	cpi	r24, 0x70	; 112
    436e:	09 f0       	breq	.+2      	; 0x4372 <__vector_39+0xae>
    4370:	c1 c0       	rjmp	.+386    	; 0x44f4 <__vector_39+0x230>
    4372:	5f c0       	rjmp	.+190    	; 0x4432 <__vector_39+0x16e>
    4374:	88 38       	cpi	r24, 0x88	; 136
    4376:	09 f4       	brne	.+2      	; 0x437a <__vector_39+0xb6>
    4378:	a9 c0       	rjmp	.+338    	; 0x44cc <__vector_39+0x208>
    437a:	80 39       	cpi	r24, 0x90	; 144
    437c:	09 f4       	brne	.+2      	; 0x4380 <__vector_39+0xbc>
    437e:	5f c0       	rjmp	.+190    	; 0x443e <__vector_39+0x17a>
    4380:	80 38       	cpi	r24, 0x80	; 128
    4382:	09 f0       	breq	.+2      	; 0x4386 <__vector_39+0xc2>
    4384:	b7 c0       	rjmp	.+366    	; 0x44f4 <__vector_39+0x230>
    4386:	5b c0       	rjmp	.+182    	; 0x443e <__vector_39+0x17a>
    4388:	80 3b       	cpi	r24, 0xB0	; 176
    438a:	09 f4       	brne	.+2      	; 0x438e <__vector_39+0xca>
    438c:	79 c0       	rjmp	.+242    	; 0x4480 <__vector_39+0x1bc>
    438e:	81 3b       	cpi	r24, 0xB1	; 177
    4390:	38 f4       	brcc	.+14     	; 0x43a0 <__vector_39+0xdc>
    4392:	80 3a       	cpi	r24, 0xA0	; 160
    4394:	09 f4       	brne	.+2      	; 0x4398 <__vector_39+0xd4>
    4396:	62 c0       	rjmp	.+196    	; 0x445c <__vector_39+0x198>
    4398:	88 3a       	cpi	r24, 0xA8	; 168
    439a:	09 f0       	breq	.+2      	; 0x439e <__vector_39+0xda>
    439c:	ab c0       	rjmp	.+342    	; 0x44f4 <__vector_39+0x230>
    439e:	70 c0       	rjmp	.+224    	; 0x4480 <__vector_39+0x1bc>
    43a0:	80 3c       	cpi	r24, 0xC0	; 192
    43a2:	09 f4       	brne	.+2      	; 0x43a6 <__vector_39+0xe2>
    43a4:	9a c0       	rjmp	.+308    	; 0x44da <__vector_39+0x216>
    43a6:	88 3c       	cpi	r24, 0xC8	; 200
    43a8:	09 f4       	brne	.+2      	; 0x43ac <__vector_39+0xe8>
    43aa:	97 c0       	rjmp	.+302    	; 0x44da <__vector_39+0x216>
    43ac:	88 3b       	cpi	r24, 0xB8	; 184
    43ae:	09 f0       	breq	.+2      	; 0x43b2 <__vector_39+0xee>
    43b0:	a1 c0       	rjmp	.+322    	; 0x44f4 <__vector_39+0x230>
    43b2:	77 c0       	rjmp	.+238    	; 0x44a2 <__vector_39+0x1de>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: M->START\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// send device address
		i2cSendByte(I2cDeviceAddrRW);
    43b4:	80 91 65 11 	lds	r24, 0x1165
    43b8:	0f c0       	rjmp	.+30     	; 0x43d8 <__vector_39+0x114>
		#ifdef I2C_DEBUG
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MT->SLA_ACK or DATA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		if(I2cSendDataIndex < I2cSendDataLength)
    43ba:	90 91 86 11 	lds	r25, 0x1186
    43be:	80 91 87 11 	lds	r24, 0x1187
    43c2:	98 17       	cp	r25, r24
    43c4:	08 f0       	brcs	.+2      	; 0x43c8 <__vector_39+0x104>
    43c6:	8e c0       	rjmp	.+284    	; 0x44e4 <__vector_39+0x220>
		{
			// send data
			i2cSendByte( I2cSendData[I2cSendDataIndex++] );
    43c8:	e9 2f       	mov	r30, r25
    43ca:	f0 e0       	ldi	r31, 0x00	; 0
    43cc:	ea 59       	subi	r30, 0x9A	; 154
    43ce:	fe 4e       	sbci	r31, 0xEE	; 238
    43d0:	80 81       	ld	r24, Z
    43d2:	9f 5f       	subi	r25, 0xFF	; 255
    43d4:	90 93 86 11 	sts	0x1186, r25
}

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    43d8:	80 93 bb 00 	sts	0x00BB, r24
    43dc:	77 c0       	rjmp	.+238    	; 0x44cc <__vector_39+0x208>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MR->DATA_NACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// store final received data byte
		I2cReceiveData[I2cReceiveDataIndex++] = inb(TWDR);
    43de:	80 91 a8 11 	lds	r24, 0x11A8
    43e2:	90 91 bb 00 	lds	r25, 0x00BB
    43e6:	e8 2f       	mov	r30, r24
    43e8:	f0 e0       	ldi	r31, 0x00	; 0
    43ea:	e8 57       	subi	r30, 0x78	; 120
    43ec:	fe 4e       	sbci	r31, 0xEE	; 238
    43ee:	90 83       	st	Z, r25
    43f0:	8f 5f       	subi	r24, 0xFF	; 255
    43f2:	80 93 a8 11 	sts	0x11A8, r24
    43f6:	76 c0       	rjmp	.+236    	; 0x44e4 <__vector_39+0x220>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MT->ARB_LOST\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// release bus
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    43f8:	80 91 bc 00 	lds	r24, 0x00BC
    43fc:	8f 70       	andi	r24, 0x0F	; 15
    43fe:	80 68       	ori	r24, 0x80	; 128
    4400:	75 c0       	rjmp	.+234    	; 0x44ec <__vector_39+0x228>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MR->DATA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// store received data byte
		I2cReceiveData[I2cReceiveDataIndex++] = inb(TWDR);
    4402:	80 91 a8 11 	lds	r24, 0x11A8
    4406:	90 91 bb 00 	lds	r25, 0x00BB
    440a:	e8 2f       	mov	r30, r24
    440c:	f0 e0       	ldi	r31, 0x00	; 0
    440e:	e8 57       	subi	r30, 0x78	; 120
    4410:	fe 4e       	sbci	r31, 0xEE	; 238
    4412:	90 83       	st	Z, r25
    4414:	8f 5f       	subi	r24, 0xFF	; 255
    4416:	80 93 a8 11 	sts	0x11A8, r24
		#ifdef I2C_DEBUG
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MR->SLA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		if(I2cReceiveDataIndex < (I2cReceiveDataLength-1))
    441a:	20 91 a8 11 	lds	r18, 0x11A8
    441e:	30 e0       	ldi	r19, 0x00	; 0
    4420:	80 91 a9 11 	lds	r24, 0x11A9
    4424:	90 e0       	ldi	r25, 0x00	; 0
    4426:	01 97       	sbiw	r24, 0x01	; 1
    4428:	28 17       	cp	r18, r24
    442a:	39 07       	cpc	r19, r25
    442c:	0c f0       	brlt	.+2      	; 0x4430 <__vector_39+0x16c>
    442e:	4e c0       	rjmp	.+156    	; 0x44cc <__vector_39+0x208>
    4430:	48 c0       	rjmp	.+144    	; 0x44c2 <__vector_39+0x1fe>
		rprintf("I2C: SR->SLA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// we are being addressed as slave for writing (data will be received from master)
		// set state
		I2cState = I2C_SLAVE_RX;
    4432:	85 e0       	ldi	r24, 0x05	; 5
    4434:	80 93 64 11 	sts	0x1164, r24
		// prepare buffer
		I2cReceiveDataIndex = 0;
    4438:	10 92 a8 11 	sts	0x11A8, r1
    443c:	42 c0       	rjmp	.+132    	; 0x44c2 <__vector_39+0x1fe>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: SR->DATA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// get previously received data byte
		I2cReceiveData[I2cReceiveDataIndex++] = inb(TWDR);
    443e:	80 91 a8 11 	lds	r24, 0x11A8
    4442:	90 91 bb 00 	lds	r25, 0x00BB
    4446:	e8 2f       	mov	r30, r24
    4448:	f0 e0       	ldi	r31, 0x00	; 0
    444a:	e8 57       	subi	r30, 0x78	; 120
    444c:	fe 4e       	sbci	r31, 0xEE	; 238
    444e:	90 83       	st	Z, r25
    4450:	8f 5f       	subi	r24, 0xFF	; 255
    4452:	80 93 a8 11 	sts	0x11A8, r24
		// check receive buffer status
		if(I2cReceiveDataIndex < I2C_RECEIVE_DATA_BUFFER_SIZE)
    4456:	80 32       	cpi	r24, 0x20	; 32
    4458:	c8 f5       	brcc	.+114    	; 0x44cc <__vector_39+0x208>
    445a:	33 c0       	rjmp	.+102    	; 0x44c2 <__vector_39+0x1fe>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: SR->SR_STOP\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// switch to SR mode with SLA ACK
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    445c:	80 91 bc 00 	lds	r24, 0x00BC
    4460:	8f 70       	andi	r24, 0x0F	; 15
    4462:	80 6c       	ori	r24, 0xC0	; 192
    4464:	80 93 bc 00 	sts	0x00BC, r24
		// i2c receive is complete, call i2cSlaveReceive
		if(i2cSlaveReceive) i2cSlaveReceive(I2cReceiveDataIndex, I2cReceiveData);
    4468:	e0 91 aa 11 	lds	r30, 0x11AA
    446c:	f0 91 ab 11 	lds	r31, 0x11AB
    4470:	30 97       	sbiw	r30, 0x00	; 0
    4472:	f1 f1       	breq	.+124    	; 0x44f0 <__vector_39+0x22c>
    4474:	80 91 a8 11 	lds	r24, 0x11A8
    4478:	68 e8       	ldi	r22, 0x88	; 136
    447a:	71 e1       	ldi	r23, 0x11	; 17
    447c:	09 95       	icall
    447e:	38 c0       	rjmp	.+112    	; 0x44f0 <__vector_39+0x22c>
		rprintf("I2C: ST->SLA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// we are being addressed as slave for reading (data must be transmitted back to master)
		// set state
		I2cState = I2C_SLAVE_TX;
    4480:	84 e0       	ldi	r24, 0x04	; 4
    4482:	80 93 64 11 	sts	0x1164, r24
		// request data from application
		if(i2cSlaveTransmit) I2cSendDataLength = i2cSlaveTransmit(I2C_SEND_DATA_BUFFER_SIZE, I2cSendData);
    4486:	e0 91 ac 11 	lds	r30, 0x11AC
    448a:	f0 91 ad 11 	lds	r31, 0x11AD
    448e:	30 97       	sbiw	r30, 0x00	; 0
    4490:	31 f0       	breq	.+12     	; 0x449e <__vector_39+0x1da>
    4492:	80 e2       	ldi	r24, 0x20	; 32
    4494:	66 e6       	ldi	r22, 0x66	; 102
    4496:	71 e1       	ldi	r23, 0x11	; 17
    4498:	09 95       	icall
    449a:	80 93 87 11 	sts	0x1187, r24
		// reset data index
		I2cSendDataIndex = 0;
    449e:	10 92 86 11 	sts	0x1186, r1
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: ST->DATA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// transmit data byte
		outb(TWDR, I2cSendData[I2cSendDataIndex++]);
    44a2:	90 91 86 11 	lds	r25, 0x1186
    44a6:	e9 2f       	mov	r30, r25
    44a8:	f0 e0       	ldi	r31, 0x00	; 0
    44aa:	ea 59       	subi	r30, 0x9A	; 154
    44ac:	fe 4e       	sbci	r31, 0xEE	; 238
    44ae:	80 81       	ld	r24, Z
    44b0:	80 93 bb 00 	sts	0x00BB, r24
    44b4:	9f 5f       	subi	r25, 0xFF	; 255
    44b6:	90 93 86 11 	sts	0x1186, r25
		if(I2cSendDataIndex < I2cSendDataLength)
    44ba:	80 91 87 11 	lds	r24, 0x1187
    44be:	98 17       	cp	r25, r24
    44c0:	28 f4       	brcc	.+10     	; 0x44cc <__vector_39+0x208>
			// expect ACK to data byte
			outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    44c2:	80 91 bc 00 	lds	r24, 0x00BC
    44c6:	8f 70       	andi	r24, 0x0F	; 15
    44c8:	80 6c       	ori	r24, 0xC0	; 192
    44ca:	04 c0       	rjmp	.+8      	; 0x44d4 <__vector_39+0x210>
		else
			// expect NACK to data byte
			outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    44cc:	80 91 bc 00 	lds	r24, 0x00BC
    44d0:	8f 70       	andi	r24, 0x0F	; 15
    44d2:	80 68       	ori	r24, 0x80	; 128
    44d4:	80 93 bc 00 	sts	0x00BC, r24
    44d8:	0d c0       	rjmp	.+26     	; 0x44f4 <__vector_39+0x230>
		rprintf("I2C: ST->DATA_NACK or LAST_DATA\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// all done
		// switch to open slave
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    44da:	80 91 bc 00 	lds	r24, 0x00BC
    44de:	8f 70       	andi	r24, 0x0F	; 15
    44e0:	80 6c       	ori	r24, 0xC0	; 192
    44e2:	04 c0       	rjmp	.+8      	; 0x44ec <__vector_39+0x228>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: BUS_ERROR\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// reset internal hardware and release bus
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTO)|BV(TWEA));
    44e4:	80 91 bc 00 	lds	r24, 0x00BC
    44e8:	8f 70       	andi	r24, 0x0F	; 15
    44ea:	80 6d       	ori	r24, 0xD0	; 208
    44ec:	80 93 bc 00 	sts	0x00BC, r24
		// set state
		I2cState = I2C_IDLE;
    44f0:	10 92 64 11 	sts	0x1164, r1
		break;
	}
}
    44f4:	ff 91       	pop	r31
    44f6:	ef 91       	pop	r30
    44f8:	bf 91       	pop	r27
    44fa:	af 91       	pop	r26
    44fc:	9f 91       	pop	r25
    44fe:	8f 91       	pop	r24
    4500:	7f 91       	pop	r23
    4502:	6f 91       	pop	r22
    4504:	5f 91       	pop	r21
    4506:	4f 91       	pop	r20
    4508:	3f 91       	pop	r19
    450a:	2f 91       	pop	r18
    450c:	0f 90       	pop	r0
    450e:	0f be       	out	0x3f, r0	; 63
    4510:	0f 90       	pop	r0
    4512:	1f 90       	pop	r1
    4514:	18 95       	reti

00004516 <i2cGetState>:

eI2cStateType i2cGetState(void)
{
	return I2cState;
    4516:	80 91 64 11 	lds	r24, 0x1164
}
    451a:	08 95       	ret

0000451c <init_LDS_buffer>:
uint8_t lds_buffer[BUFFER_SIZE];
uint8_t *lds_buffer_write_ndx = NULL;
uint8_t *lds_buffer_read_ndx = NULL;

void init_LDS_buffer(){
	lds_buffer_write_ndx = lds_buffer_read_ndx = lds_buffer;
    451c:	8b e2       	ldi	r24, 0x2B	; 43
    451e:	92 e1       	ldi	r25, 0x12	; 18
    4520:	90 93 b1 11 	sts	0x11B1, r25
    4524:	80 93 b0 11 	sts	0x11B0, r24
    4528:	90 93 af 11 	sts	0x11AF, r25
    452c:	80 93 ae 11 	sts	0x11AE, r24
}
    4530:	08 95       	ret

00004532 <LDSRcv>:

void LDSRcv(unsigned char c){
	if(c != 0xff){
    4532:	8f 3f       	cpi	r24, 0xFF	; 255
    4534:	b9 f0       	breq	.+46     	; 0x4564 <LDSRcv+0x32>
		*lds_buffer_write_ndx = c;
    4536:	e0 91 ae 11 	lds	r30, 0x11AE
    453a:	f0 91 af 11 	lds	r31, 0x11AF
    453e:	80 83       	st	Z, r24
		lds_buffer_write_ndx++;		
    4540:	80 91 ae 11 	lds	r24, 0x11AE
    4544:	90 91 af 11 	lds	r25, 0x11AF
    4548:	01 96       	adiw	r24, 0x01	; 1
    454a:	90 93 af 11 	sts	0x11AF, r25
    454e:	80 93 ae 11 	sts	0x11AE, r24
		if(lds_buffer_write_ndx >= (lds_buffer + BUFFER_SIZE)){ 
    4552:	8b 52       	subi	r24, 0x2B	; 43
    4554:	93 41       	sbci	r25, 0x13	; 19
    4556:	30 f0       	brcs	.+12     	; 0x4564 <LDSRcv+0x32>
			lds_buffer_write_ndx = lds_buffer;
    4558:	8b e2       	ldi	r24, 0x2B	; 43
    455a:	92 e1       	ldi	r25, 0x12	; 18
    455c:	90 93 af 11 	sts	0x11AF, r25
    4560:	80 93 ae 11 	sts	0x11AE, r24
    4564:	08 95       	ret

00004566 <error_checker>:
		lds_buffer_read_ndx = lds_buffer;
	}
	return data;
}

uint8_t error_checker(const uint16_t chk_data[], uint16_t checksum){
    4566:	0f 93       	push	r16
    4568:	1f 93       	push	r17
    456a:	cf 93       	push	r28
    456c:	df 93       	push	r29
    456e:	ec 01       	movw	r28, r24
    4570:	8b 01       	movw	r16, r22
    4572:	20 e0       	ldi	r18, 0x00	; 0
    4574:	30 e0       	ldi	r19, 0x00	; 0
    4576:	40 e0       	ldi	r20, 0x00	; 0
    4578:	50 e0       	ldi	r21, 0x00	; 0
    457a:	60 e0       	ldi	r22, 0x00	; 0
    457c:	70 e0       	ldi	r23, 0x00	; 0
    uint32_t chk32 = 0;
    for(uint8_t ndx = 0; ndx < 10; ndx++){
      chk32 = (chk32 << 1) + chk_data[ndx];
    457e:	22 0f       	add	r18, r18
    4580:	33 1f       	adc	r19, r19
    4582:	44 1f       	adc	r20, r20
    4584:	55 1f       	adc	r21, r21
    4586:	fe 01       	movw	r30, r28
    4588:	e6 0f       	add	r30, r22
    458a:	f7 1f       	adc	r31, r23
    458c:	80 81       	ld	r24, Z
    458e:	91 81       	ldd	r25, Z+1	; 0x01
    4590:	a0 e0       	ldi	r26, 0x00	; 0
    4592:	b0 e0       	ldi	r27, 0x00	; 0
    4594:	28 0f       	add	r18, r24
    4596:	39 1f       	adc	r19, r25
    4598:	4a 1f       	adc	r20, r26
    459a:	5b 1f       	adc	r21, r27
    459c:	6e 5f       	subi	r22, 0xFE	; 254
    459e:	7f 4f       	sbci	r23, 0xFF	; 255
	return data;
}

uint8_t error_checker(const uint16_t chk_data[], uint16_t checksum){
    uint32_t chk32 = 0;
    for(uint8_t ndx = 0; ndx < 10; ndx++){
    45a0:	64 31       	cpi	r22, 0x14	; 20
    45a2:	71 05       	cpc	r23, r1
    45a4:	61 f7       	brne	.-40     	; 0x457e <error_checker+0x18>
      chk32 = (chk32 << 1) + chk_data[ndx];
    }
    uint16_t chk16 = (chk32 & 0x7FFF) + (chk32 >> 15);
    45a6:	c9 01       	movw	r24, r18
    45a8:	9f 77       	andi	r25, 0x7F	; 127
    45aa:	6f e0       	ldi	r22, 0x0F	; 15
    45ac:	56 95       	lsr	r21
    45ae:	47 95       	ror	r20
    45b0:	37 95       	ror	r19
    45b2:	27 95       	ror	r18
    45b4:	6a 95       	dec	r22
    45b6:	d1 f7       	brne	.-12     	; 0x45ac <error_checker+0x46>
    45b8:	82 0f       	add	r24, r18
    45ba:	93 1f       	adc	r25, r19
    45bc:	20 e0       	ldi	r18, 0x00	; 0
    45be:	9f 77       	andi	r25, 0x7F	; 127
    45c0:	80 17       	cp	r24, r16
    45c2:	91 07       	cpc	r25, r17
    45c4:	09 f4       	brne	.+2      	; 0x45c8 <error_checker+0x62>
    45c6:	21 e0       	ldi	r18, 0x01	; 1
    chk16 = chk16 & 0x7FFF;
    return (chk16 == checksum);
  }
    45c8:	82 2f       	mov	r24, r18
    45ca:	df 91       	pop	r29
    45cc:	cf 91       	pop	r28
    45ce:	1f 91       	pop	r17
    45d0:	0f 91       	pop	r16
    45d2:	08 95       	ret

000045d4 <conv_FrametoDist>:
			f_ndx++;
		}
	}
}

void conv_FrametoDist(const LDS_FRAME ldsf[], uint16_t ranges[]){
    45d4:	cf 93       	push	r28
    45d6:	df 93       	push	r29
    45d8:	ec 01       	movw	r28, r24
    45da:	20 e0       	ldi	r18, 0x00	; 0
	// ldsf must be of length 90
	// ranges must be of length 360
	uint16_t r_ndx;
	for(uint8_t f_ndx = 0; f_ndx < 90; f_ndx++){
		// Maps frame indicies to range indices
		r_ndx = 4*ldsf[f_ndx].index - 640;
    45dc:	e8 81       	ld	r30, Y
    45de:	f0 e0       	ldi	r31, 0x00	; 0
    45e0:	e0 5a       	subi	r30, 0xA0	; 160
    45e2:	f0 40       	sbci	r31, 0x00	; 0
    45e4:	ee 0f       	add	r30, r30
    45e6:	ff 1f       	adc	r31, r31
    45e8:	ee 0f       	add	r30, r30
    45ea:	ff 1f       	adc	r31, r31
		ranges[r_ndx]     = (ldsf[f_ndx].distance[0]);
    45ec:	df 01       	movw	r26, r30
    45ee:	aa 0f       	add	r26, r26
    45f0:	bb 1f       	adc	r27, r27
    45f2:	a6 0f       	add	r26, r22
    45f4:	b7 1f       	adc	r27, r23
    45f6:	8b 85       	ldd	r24, Y+11	; 0x0b
    45f8:	9c 85       	ldd	r25, Y+12	; 0x0c
    45fa:	8d 93       	st	X+, r24
    45fc:	9c 93       	st	X, r25
		ranges[r_ndx + 1] = (ldsf[f_ndx].distance[1]);
    45fe:	df 01       	movw	r26, r30
    4600:	11 96       	adiw	r26, 0x01	; 1
    4602:	aa 0f       	add	r26, r26
    4604:	bb 1f       	adc	r27, r27
    4606:	a6 0f       	add	r26, r22
    4608:	b7 1f       	adc	r27, r23
    460a:	8d 85       	ldd	r24, Y+13	; 0x0d
    460c:	9e 85       	ldd	r25, Y+14	; 0x0e
    460e:	8d 93       	st	X+, r24
    4610:	9c 93       	st	X, r25
		ranges[r_ndx + 2] = (ldsf[f_ndx].distance[2]);
    4612:	32 96       	adiw	r30, 0x02	; 2
    4614:	df 01       	movw	r26, r30
    4616:	aa 0f       	add	r26, r26
    4618:	bb 1f       	adc	r27, r27
    461a:	a6 0f       	add	r26, r22
    461c:	b7 1f       	adc	r27, r23
    461e:	8f 85       	ldd	r24, Y+15	; 0x0f
    4620:	98 89       	ldd	r25, Y+16	; 0x10
    4622:	8d 93       	st	X+, r24
    4624:	9c 93       	st	X, r25
		ranges[r_ndx + 3] = (ldsf[f_ndx].distance[3]);
    4626:	31 96       	adiw	r30, 0x01	; 1
    4628:	ee 0f       	add	r30, r30
    462a:	ff 1f       	adc	r31, r31
    462c:	e6 0f       	add	r30, r22
    462e:	f7 1f       	adc	r31, r23
    4630:	89 89       	ldd	r24, Y+17	; 0x11
    4632:	9a 89       	ldd	r25, Y+18	; 0x12
    4634:	91 83       	std	Z+1, r25	; 0x01
    4636:	80 83       	st	Z, r24

void conv_FrametoDist(const LDS_FRAME ldsf[], uint16_t ranges[]){
	// ldsf must be of length 90
	// ranges must be of length 360
	uint16_t r_ndx;
	for(uint8_t f_ndx = 0; f_ndx < 90; f_ndx++){
    4638:	2f 5f       	subi	r18, 0xFF	; 255
    463a:	6d 96       	adiw	r28, 0x1d	; 29
    463c:	2a 35       	cpi	r18, 0x5A	; 90
    463e:	71 f6       	brne	.-100    	; 0x45dc <conv_FrametoDist+0x8>
		ranges[r_ndx]     = (ldsf[f_ndx].distance[0]);
		ranges[r_ndx + 1] = (ldsf[f_ndx].distance[1]);
		ranges[r_ndx + 2] = (ldsf[f_ndx].distance[2]);
		ranges[r_ndx + 3] = (ldsf[f_ndx].distance[3]);
	}
}
    4640:	df 91       	pop	r29
    4642:	cf 91       	pop	r28
    4644:	08 95       	ret

00004646 <print_frame>:
	frame->checksum = (((uint16_t)read_LDS())) + (((uint16_t)read_LDS())<<8);
    
    return error_checker(chk_data, frame->checksum);
}  

void print_frame(LDS_FRAME frame){
    4646:	ef 92       	push	r14
    4648:	ff 92       	push	r15
    464a:	0f 93       	push	r16
    464c:	1f 93       	push	r17
    464e:	df 93       	push	r29
    4650:	cf 93       	push	r28
    4652:	cd b7       	in	r28, 0x3d	; 61
    4654:	de b7       	in	r29, 0x3e	; 62
    4656:	e9 84       	ldd	r14, Y+9	; 0x09
    4658:	0a 85       	ldd	r16, Y+10	; 0x0a
    465a:	1b 85       	ldd	r17, Y+11	; 0x0b
	rprintf("Index: ");
    465c:	00 d0       	rcall	.+0      	; 0x465e <print_frame+0x18>
    465e:	0f 92       	push	r0
    4660:	ff 24       	eor	r15, r15
    4662:	f3 94       	inc	r15
    4664:	ad b7       	in	r26, 0x3d	; 61
    4666:	be b7       	in	r27, 0x3e	; 62
    4668:	11 96       	adiw	r26, 0x01	; 1
    466a:	fc 92       	st	X, r15
    466c:	11 97       	sbiw	r26, 0x01	; 1
    466e:	80 ea       	ldi	r24, 0xA0	; 160
    4670:	91 e0       	ldi	r25, 0x01	; 1
    4672:	13 96       	adiw	r26, 0x03	; 3
    4674:	9c 93       	st	X, r25
    4676:	8e 93       	st	-X, r24
    4678:	12 97       	sbiw	r26, 0x02	; 2
    467a:	0e 94 77 1f 	call	0x3eee	; 0x3eee <rprintf1RamRom>
	rprintfu08(frame.index);
    467e:	0f 90       	pop	r0
    4680:	0f 90       	pop	r0
    4682:	0f 90       	pop	r0
    4684:	8e 2d       	mov	r24, r14
    4686:	0e 94 c6 1d 	call	0x3b8c	; 0x3b8c <rprintfu08>
	rprintf(" Motor Speed: ");
    468a:	00 d0       	rcall	.+0      	; 0x468c <print_frame+0x46>
    468c:	0f 92       	push	r0
    468e:	ed b7       	in	r30, 0x3d	; 61
    4690:	fe b7       	in	r31, 0x3e	; 62
    4692:	f1 82       	std	Z+1, r15	; 0x01
    4694:	81 e9       	ldi	r24, 0x91	; 145
    4696:	91 e0       	ldi	r25, 0x01	; 1
    4698:	93 83       	std	Z+3, r25	; 0x03
    469a:	82 83       	std	Z+2, r24	; 0x02
    469c:	0e 94 77 1f 	call	0x3eee	; 0x3eee <rprintf1RamRom>
	rprintfu16(frame.motor_speed);
    46a0:	0f 90       	pop	r0
    46a2:	0f 90       	pop	r0
    46a4:	0f 90       	pop	r0
    46a6:	c8 01       	movw	r24, r16
    46a8:	0e 94 d1 1d 	call	0x3ba2	; 0x3ba2 <rprintfu16>
	rprintf(" Distances: ");
    46ac:	00 d0       	rcall	.+0      	; 0x46ae <print_frame+0x68>
    46ae:	0f 92       	push	r0
    46b0:	ad b7       	in	r26, 0x3d	; 61
    46b2:	be b7       	in	r27, 0x3e	; 62
    46b4:	11 96       	adiw	r26, 0x01	; 1
    46b6:	fc 92       	st	X, r15
    46b8:	11 97       	sbiw	r26, 0x01	; 1
    46ba:	84 e8       	ldi	r24, 0x84	; 132
    46bc:	91 e0       	ldi	r25, 0x01	; 1
    46be:	13 96       	adiw	r26, 0x03	; 3
    46c0:	9c 93       	st	X, r25
    46c2:	8e 93       	st	-X, r24
    46c4:	12 97       	sbiw	r26, 0x02	; 2
    46c6:	0e 94 77 1f 	call	0x3eee	; 0x3eee <rprintf1RamRom>
	for(uint8_t ndx = 0; ndx < 4; ndx++){
		rprintf("%d ",frame.distance[ndx]);
    46ca:	00 d0       	rcall	.+0      	; 0x46cc <print_frame+0x86>
    46cc:	ed b7       	in	r30, 0x3d	; 61
    46ce:	fe b7       	in	r31, 0x3e	; 62
    46d0:	31 96       	adiw	r30, 0x01	; 1
    46d2:	ad b7       	in	r26, 0x3d	; 61
    46d4:	be b7       	in	r27, 0x3e	; 62
    46d6:	11 96       	adiw	r26, 0x01	; 1
    46d8:	fc 92       	st	X, r15
    46da:	00 e8       	ldi	r16, 0x80	; 128
    46dc:	11 e0       	ldi	r17, 0x01	; 1
    46de:	12 83       	std	Z+2, r17	; 0x02
    46e0:	01 83       	std	Z+1, r16	; 0x01
    46e2:	8c 89       	ldd	r24, Y+20	; 0x14
    46e4:	9d 89       	ldd	r25, Y+21	; 0x15
    46e6:	94 83       	std	Z+4, r25	; 0x04
    46e8:	83 83       	std	Z+3, r24	; 0x03
    46ea:	0e 94 77 1f 	call	0x3eee	; 0x3eee <rprintf1RamRom>
    46ee:	ed b7       	in	r30, 0x3d	; 61
    46f0:	fe b7       	in	r31, 0x3e	; 62
    46f2:	31 96       	adiw	r30, 0x01	; 1
    46f4:	ad b7       	in	r26, 0x3d	; 61
    46f6:	be b7       	in	r27, 0x3e	; 62
    46f8:	11 96       	adiw	r26, 0x01	; 1
    46fa:	fc 92       	st	X, r15
    46fc:	12 83       	std	Z+2, r17	; 0x02
    46fe:	01 83       	std	Z+1, r16	; 0x01
    4700:	8e 89       	ldd	r24, Y+22	; 0x16
    4702:	9f 89       	ldd	r25, Y+23	; 0x17
    4704:	94 83       	std	Z+4, r25	; 0x04
    4706:	83 83       	std	Z+3, r24	; 0x03
    4708:	0e 94 77 1f 	call	0x3eee	; 0x3eee <rprintf1RamRom>
    470c:	ed b7       	in	r30, 0x3d	; 61
    470e:	fe b7       	in	r31, 0x3e	; 62
    4710:	31 96       	adiw	r30, 0x01	; 1
    4712:	ad b7       	in	r26, 0x3d	; 61
    4714:	be b7       	in	r27, 0x3e	; 62
    4716:	11 96       	adiw	r26, 0x01	; 1
    4718:	fc 92       	st	X, r15
    471a:	12 83       	std	Z+2, r17	; 0x02
    471c:	01 83       	std	Z+1, r16	; 0x01
    471e:	88 8d       	ldd	r24, Y+24	; 0x18
    4720:	99 8d       	ldd	r25, Y+25	; 0x19
    4722:	94 83       	std	Z+4, r25	; 0x04
    4724:	83 83       	std	Z+3, r24	; 0x03
    4726:	0e 94 77 1f 	call	0x3eee	; 0x3eee <rprintf1RamRom>
    472a:	ed b7       	in	r30, 0x3d	; 61
    472c:	fe b7       	in	r31, 0x3e	; 62
    472e:	31 96       	adiw	r30, 0x01	; 1
    4730:	ad b7       	in	r26, 0x3d	; 61
    4732:	be b7       	in	r27, 0x3e	; 62
    4734:	11 96       	adiw	r26, 0x01	; 1
    4736:	fc 92       	st	X, r15
    4738:	12 83       	std	Z+2, r17	; 0x02
    473a:	01 83       	std	Z+1, r16	; 0x01
    473c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    473e:	9b 8d       	ldd	r25, Y+27	; 0x1b
    4740:	94 83       	std	Z+4, r25	; 0x04
    4742:	83 83       	std	Z+3, r24	; 0x03
    4744:	0e 94 77 1f 	call	0x3eee	; 0x3eee <rprintf1RamRom>
	}
	rprintfCRLF();
    4748:	0f 90       	pop	r0
    474a:	0f 90       	pop	r0
    474c:	0f 90       	pop	r0
    474e:	0f 90       	pop	r0
    4750:	0f 90       	pop	r0
    4752:	0e 94 b7 1d 	call	0x3b6e	; 0x3b6e <rprintfCRLF>
}
    4756:	cf 91       	pop	r28
    4758:	df 91       	pop	r29
    475a:	1f 91       	pop	r17
    475c:	0f 91       	pop	r16
    475e:	ff 90       	pop	r15
    4760:	ef 90       	pop	r14
    4762:	08 95       	ret

00004764 <read_LDS>:
			lds_buffer_write_ndx = lds_buffer;
		}
	}
}

uint8_t read_LDS(){
    4764:	04 c0       	rjmp	.+8      	; 0x476e <read_LDS+0xa>
	while(lds_buffer_read_ndx == lds_buffer_write_ndx){ delay_us(10); };
    4766:	8a e0       	ldi	r24, 0x0A	; 10
    4768:	90 e0       	ldi	r25, 0x00	; 0
    476a:	0e 94 f4 11 	call	0x23e8	; 0x23e8 <delay_us>
    476e:	e0 91 b0 11 	lds	r30, 0x11B0
    4772:	f0 91 b1 11 	lds	r31, 0x11B1
    4776:	80 91 ae 11 	lds	r24, 0x11AE
    477a:	90 91 af 11 	lds	r25, 0x11AF
    477e:	e8 17       	cp	r30, r24
    4780:	f9 07       	cpc	r31, r25
    4782:	89 f3       	breq	.-30     	; 0x4766 <read_LDS+0x2>
	uint8_t data = *lds_buffer_read_ndx;
    4784:	21 91       	ld	r18, Z+
	lds_buffer_read_ndx++;
    4786:	f0 93 b1 11 	sts	0x11B1, r31
    478a:	e0 93 b0 11 	sts	0x11B0, r30
	if(lds_buffer_read_ndx >= (lds_buffer + BUFFER_SIZE)){ 
    478e:	eb 52       	subi	r30, 0x2B	; 43
    4790:	f3 41       	sbci	r31, 0x13	; 19
    4792:	30 f0       	brcs	.+12     	; 0x47a0 <read_LDS+0x3c>
		lds_buffer_read_ndx = lds_buffer;
    4794:	8b e2       	ldi	r24, 0x2B	; 43
    4796:	92 e1       	ldi	r25, 0x12	; 18
    4798:	90 93 b1 11 	sts	0x11B1, r25
    479c:	80 93 b0 11 	sts	0x11B0, r24
	}
	return data;
}
    47a0:	82 2f       	mov	r24, r18
    47a2:	08 95       	ret

000047a4 <parse_frame>:
    uint16_t chk16 = (chk32 & 0x7FFF) + (chk32 >> 15);
    chk16 = chk16 & 0x7FFF;
    return (chk16 == checksum);
  }

uint8_t parse_frame(LDS_FRAME *frame){
    47a4:	2f 92       	push	r2
    47a6:	3f 92       	push	r3
    47a8:	4f 92       	push	r4
    47aa:	5f 92       	push	r5
    47ac:	6f 92       	push	r6
    47ae:	7f 92       	push	r7
    47b0:	8f 92       	push	r8
    47b2:	9f 92       	push	r9
    47b4:	af 92       	push	r10
    47b6:	bf 92       	push	r11
    47b8:	cf 92       	push	r12
    47ba:	df 92       	push	r13
    47bc:	ef 92       	push	r14
    47be:	ff 92       	push	r15
    47c0:	0f 93       	push	r16
    47c2:	1f 93       	push	r17
    47c4:	df 93       	push	r29
    47c6:	cf 93       	push	r28
    47c8:	cd b7       	in	r28, 0x3d	; 61
    47ca:	de b7       	in	r29, 0x3e	; 62
    47cc:	6a 97       	sbiw	r28, 0x1a	; 26
    47ce:	0f b6       	in	r0, 0x3f	; 63
    47d0:	f8 94       	cli
    47d2:	de bf       	out	0x3e, r29	; 62
    47d4:	0f be       	out	0x3f, r0	; 63
    47d6:	cd bf       	out	0x3d, r28	; 61
    47d8:	2c 01       	movw	r4, r24
    // Array for use by the error checker
    uint16_t chk_data[10];

    // Read start byte
    uint8_t start_byte = read_LDS();
    47da:	0e 94 b2 23 	call	0x4764	; 0x4764 <read_LDS>
    // If the byte read in is not the start byte (0xFA), then this is not the beginning of a frame
    if(start_byte != 0xFA) return FALSE; 
    47de:	8a 3f       	cpi	r24, 0xFA	; 250
    47e0:	09 f0       	breq	.+2      	; 0x47e4 <parse_frame+0x40>
    47e2:	ac c0       	rjmp	.+344    	; 0x493c <parse_frame+0x198>

    // Read index
	frame->index = read_LDS();
    47e4:	0e 94 b2 23 	call	0x4764	; 0x4764 <read_LDS>
    47e8:	28 2f       	mov	r18, r24
    47ea:	f2 01       	movw	r30, r4
    47ec:	80 83       	st	Z, r24
    // If the byte proceeding the start byte does not look like an index, then is is not the beginning of a frame
    if((frame->index < 0xA0)||(frame->index > 0xF9)) return FALSE;
    47ee:	80 5a       	subi	r24, 0xA0	; 160
    47f0:	8a 35       	cpi	r24, 0x5A	; 90
    47f2:	08 f0       	brcs	.+2      	; 0x47f6 <parse_frame+0x52>
    47f4:	a3 c0       	rjmp	.+326    	; 0x493c <parse_frame+0x198>

    // Add these bytes for the error checker
    chk_data[0] = (frame->index << 8) + start_byte;
    47f6:	92 2f       	mov	r25, r18
    47f8:	80 e0       	ldi	r24, 0x00	; 0
    47fa:	86 50       	subi	r24, 0x06	; 6
    47fc:	9f 4f       	sbci	r25, 0xFF	; 255
    47fe:	9e 83       	std	Y+6, r25	; 0x06
    4800:	8d 83       	std	Y+5, r24	; 0x05
    //   MSB                                                               LSB
    //   15  14  13  12  11  10  9   8   7   6    5    4    3    2    1    0
    //   512 256 128 64  32  16  8   4   2   1 .  1/2  1/4  1/8  1/16 1/32 1/64
    //
	
	frame->motor_speed = ((uint16_t)read_LDS()) + ((uint16_t)read_LDS()<<8);
    4802:	0e 94 b2 23 	call	0x4764	; 0x4764 <read_LDS>
    4806:	18 2f       	mov	r17, r24
    4808:	0e 94 b2 23 	call	0x4764	; 0x4764 <read_LDS>
    480c:	38 2f       	mov	r19, r24
    480e:	20 e0       	ldi	r18, 0x00	; 0
    4810:	21 0f       	add	r18, r17
    4812:	31 1d       	adc	r19, r1
    4814:	f2 01       	movw	r30, r4
    4816:	32 83       	std	Z+2, r19	; 0x02
    4818:	21 83       	std	Z+1, r18	; 0x01
    // Add these bytes for the error checker
    chk_data[1] = frame->motor_speed;
    481a:	38 87       	std	Y+8, r19	; 0x08
    481c:	2f 83       	std	Y+7, r18	; 0x07
    481e:	32 01       	movw	r6, r4
    4820:	09 e0       	ldi	r16, 0x09	; 9
    4822:	80 2e       	mov	r8, r16
    4824:	91 2c       	mov	r9, r1
    4826:	8c 0e       	add	r8, r28
    4828:	9d 1e       	adc	r9, r29
    482a:	62 01       	movw	r12, r4
				
    // Read distances, intensities, and flags
    for(uint8_t itr = 0; itr < 4; itr++) {
      // Read in the four distance and intensity bytes
      uint8_t di_bytes[4];
	  for(uint8_t d_ndx = 0; d_ndx < 4; d_ndx++){
    482c:	15 e0       	ldi	r17, 0x05	; 5
    482e:	21 2e       	mov	r2, r17
    4830:	31 2c       	mov	r3, r1
    4832:	2c 0e       	add	r2, r28
    4834:	3d 1e       	adc	r3, r29
    // Add these bytes for the error checker
    chk_data[1] = frame->motor_speed;
	
				
    // Read distances, intensities, and flags
    for(uint8_t itr = 0; itr < 4; itr++) {
    4836:	ae 01       	movw	r20, r28
    4838:	47 5e       	subi	r20, 0xE7	; 231
    483a:	5f 4f       	sbci	r21, 0xFF	; 255
    483c:	5a 8f       	std	Y+26, r21	; 0x1a
    483e:	49 8f       	std	Y+25, r20	; 0x19
    4840:	46 c0       	rjmp	.+140    	; 0x48ce <parse_frame+0x12a>
      // Read in the four distance and intensity bytes
      uint8_t di_bytes[4];
	  for(uint8_t d_ndx = 0; d_ndx < 4; d_ndx++){
	  	di_bytes[d_ndx] = read_LDS();
    4842:	0e 94 b2 23 	call	0x4764	; 0x4764 <read_LDS>
    4846:	f8 01       	movw	r30, r16
    4848:	81 93       	st	Z+, r24
    484a:	8f 01       	movw	r16, r30
				
    // Read distances, intensities, and flags
    for(uint8_t itr = 0; itr < 4; itr++) {
      // Read in the four distance and intensity bytes
      uint8_t di_bytes[4];
	  for(uint8_t d_ndx = 0; d_ndx < 4; d_ndx++){
    484c:	e2 15       	cp	r30, r2
    484e:	f3 05       	cpc	r31, r3
    4850:	c1 f7       	brne	.-16     	; 0x4842 <parse_frame+0x9e>
	  	di_bytes[d_ndx] = read_LDS();
      }
      // The invalid and strength flags are the MSB and adjacent bit of the second (indexwise) distance byte
      frame->invalid[itr] = (uint8_t)(di_bytes[1] & 0x80);
    4852:	4a 81       	ldd	r20, Y+2	; 0x02
    4854:	94 2f       	mov	r25, r20
    4856:	90 78       	andi	r25, 0x80	; 128
    4858:	f3 01       	movw	r30, r6
    485a:	93 83       	std	Z+3, r25	; 0x03
      frame->strength_warning[itr] = (uint8_t)(di_bytes[1] & 0x40);
    485c:	84 2f       	mov	r24, r20
    485e:	80 74       	andi	r24, 0x40	; 64
    4860:	87 83       	std	Z+7, r24	; 0x07

      // Distance and intensity bytes are read in little endian, and therefore need to be switched and concatenated
      // The second distance byte (indexwise) is masked to eliminate the invalid and strength flags from the measurement
      if(frame->invalid[itr]){ // If this measurement is invalid, set it to zero
    4862:	99 23       	and	r25, r25
    4864:	21 f0       	breq	.+8      	; 0x486e <parse_frame+0xca>
		frame->distance[itr]  = 0;
    4866:	f6 01       	movw	r30, r12
    4868:	14 86       	std	Z+12, r1	; 0x0c
    486a:	13 86       	std	Z+11, r1	; 0x0b
    486c:	0c c0       	rjmp	.+24     	; 0x4886 <parse_frame+0xe2>
      }
      else{
		frame->distance[itr]  = ((di_bytes[1] & 0x3F) << 8) + di_bytes[0];
    486e:	84 2f       	mov	r24, r20
    4870:	90 e0       	ldi	r25, 0x00	; 0
    4872:	8f 73       	andi	r24, 0x3F	; 63
    4874:	90 70       	andi	r25, 0x00	; 0
    4876:	98 2f       	mov	r25, r24
    4878:	88 27       	eor	r24, r24
    487a:	29 81       	ldd	r18, Y+1	; 0x01
    487c:	82 0f       	add	r24, r18
    487e:	91 1d       	adc	r25, r1
    4880:	f6 01       	movw	r30, r12
    4882:	94 87       	std	Z+12, r25	; 0x0c
    4884:	83 87       	std	Z+11, r24	; 0x0b
      }

      frame->intensity[itr] = (di_bytes[3] << 8) + di_bytes[2];
    4886:	bc 80       	ldd	r11, Y+4	; 0x04
    4888:	aa 24       	eor	r10, r10
    488a:	8b 81       	ldd	r24, Y+3	; 0x03
    488c:	95 01       	movw	r18, r10
    488e:	28 0f       	add	r18, r24
    4890:	31 1d       	adc	r19, r1
    4892:	f6 01       	movw	r30, r12
    4894:	34 8b       	std	Z+20, r19	; 0x14
    4896:	23 8b       	std	Z+19, r18	; 0x13
      
      // Add these bytes for the error checker
      chk_data[2*itr + 2] = (di_bytes[1] << 8) + di_bytes[0];
    4898:	f4 2e       	mov	r15, r20
    489a:	ee 24       	eor	r14, r14
    489c:	89 81       	ldd	r24, Y+1	; 0x01
    489e:	a7 01       	movw	r20, r14
    48a0:	48 0f       	add	r20, r24
    48a2:	51 1d       	adc	r21, r1
    48a4:	f4 01       	movw	r30, r8
    48a6:	51 83       	std	Z+1, r21	; 0x01
    48a8:	40 83       	st	Z, r20
      chk_data[2*itr + 3] = (di_bytes[3] << 8) + di_bytes[2];
    48aa:	33 83       	std	Z+3, r19	; 0x03
    48ac:	22 83       	std	Z+2, r18	; 0x02
    48ae:	42 e0       	ldi	r20, 0x02	; 2
    48b0:	50 e0       	ldi	r21, 0x00	; 0
    48b2:	c4 0e       	add	r12, r20
    48b4:	d5 1e       	adc	r13, r21
    48b6:	84 e0       	ldi	r24, 0x04	; 4
    48b8:	90 e0       	ldi	r25, 0x00	; 0
    48ba:	88 0e       	add	r8, r24
    48bc:	99 1e       	adc	r9, r25
    48be:	08 94       	sec
    48c0:	61 1c       	adc	r6, r1
    48c2:	71 1c       	adc	r7, r1
    // Add these bytes for the error checker
    chk_data[1] = frame->motor_speed;
	
				
    // Read distances, intensities, and flags
    for(uint8_t itr = 0; itr < 4; itr++) {
    48c4:	e9 8d       	ldd	r30, Y+25	; 0x19
    48c6:	fa 8d       	ldd	r31, Y+26	; 0x1a
    48c8:	8e 16       	cp	r8, r30
    48ca:	9f 06       	cpc	r9, r31
    48cc:	21 f0       	breq	.+8      	; 0x48d6 <parse_frame+0x132>
    48ce:	8e 01       	movw	r16, r28
    48d0:	0f 5f       	subi	r16, 0xFF	; 255
    48d2:	1f 4f       	sbci	r17, 0xFF	; 255
    48d4:	b6 cf       	rjmp	.-148    	; 0x4842 <parse_frame+0x9e>
      chk_data[2*itr + 3] = (di_bytes[3] << 8) + di_bytes[2];
    }

    // Read checksum
    // Checksum is given in little endian, but because it is read into a uint16_t, it is ordered correctly
	frame->checksum = (((uint16_t)read_LDS())) + (((uint16_t)read_LDS())<<8);
    48d6:	0e 94 b2 23 	call	0x4764	; 0x4764 <read_LDS>
    48da:	18 2f       	mov	r17, r24
    48dc:	0e 94 b2 23 	call	0x4764	; 0x4764 <read_LDS>
    48e0:	38 2f       	mov	r19, r24
    48e2:	20 e0       	ldi	r18, 0x00	; 0
    48e4:	b9 01       	movw	r22, r18
    48e6:	61 0f       	add	r22, r17
    48e8:	71 1d       	adc	r23, r1
    48ea:	f2 01       	movw	r30, r4
    48ec:	74 8f       	std	Z+28, r23	; 0x1c
    48ee:	63 8f       	std	Z+27, r22	; 0x1b
    48f0:	f1 01       	movw	r30, r2
    48f2:	20 e0       	ldi	r18, 0x00	; 0
    48f4:	30 e0       	ldi	r19, 0x00	; 0
    48f6:	40 e0       	ldi	r20, 0x00	; 0
    48f8:	50 e0       	ldi	r21, 0x00	; 0
}

uint8_t error_checker(const uint16_t chk_data[], uint16_t checksum){
    uint32_t chk32 = 0;
    for(uint8_t ndx = 0; ndx < 10; ndx++){
      chk32 = (chk32 << 1) + chk_data[ndx];
    48fa:	22 0f       	add	r18, r18
    48fc:	33 1f       	adc	r19, r19
    48fe:	44 1f       	adc	r20, r20
    4900:	55 1f       	adc	r21, r21
    4902:	81 91       	ld	r24, Z+
    4904:	91 91       	ld	r25, Z+
    4906:	a0 e0       	ldi	r26, 0x00	; 0
    4908:	b0 e0       	ldi	r27, 0x00	; 0
    490a:	28 0f       	add	r18, r24
    490c:	39 1f       	adc	r19, r25
    490e:	4a 1f       	adc	r20, r26
    4910:	5b 1f       	adc	r21, r27
	return data;
}

uint8_t error_checker(const uint16_t chk_data[], uint16_t checksum){
    uint32_t chk32 = 0;
    for(uint8_t ndx = 0; ndx < 10; ndx++){
    4912:	e8 15       	cp	r30, r8
    4914:	f9 05       	cpc	r31, r9
    4916:	89 f7       	brne	.-30     	; 0x48fa <parse_frame+0x156>
      chk32 = (chk32 << 1) + chk_data[ndx];
    }
    uint16_t chk16 = (chk32 & 0x7FFF) + (chk32 >> 15);
    4918:	c9 01       	movw	r24, r18
    491a:	9f 77       	andi	r25, 0x7F	; 127
    491c:	ef e0       	ldi	r30, 0x0F	; 15
    491e:	56 95       	lsr	r21
    4920:	47 95       	ror	r20
    4922:	37 95       	ror	r19
    4924:	27 95       	ror	r18
    4926:	ea 95       	dec	r30
    4928:	d1 f7       	brne	.-12     	; 0x491e <parse_frame+0x17a>
    492a:	82 0f       	add	r24, r18
    492c:	93 1f       	adc	r25, r19
    chk16 = chk16 & 0x7FFF;
    return (chk16 == checksum);
    492e:	20 e0       	ldi	r18, 0x00	; 0
    4930:	9f 77       	andi	r25, 0x7F	; 127
    4932:	86 17       	cp	r24, r22
    4934:	97 07       	cpc	r25, r23
    4936:	19 f4       	brne	.+6      	; 0x493e <parse_frame+0x19a>
    4938:	21 e0       	ldi	r18, 0x01	; 1
    493a:	01 c0       	rjmp	.+2      	; 0x493e <parse_frame+0x19a>

    // Read checksum
    // Checksum is given in little endian, but because it is read into a uint16_t, it is ordered correctly
	frame->checksum = (((uint16_t)read_LDS())) + (((uint16_t)read_LDS())<<8);
    
    return error_checker(chk_data, frame->checksum);
    493c:	20 e0       	ldi	r18, 0x00	; 0
}  
    493e:	82 2f       	mov	r24, r18
    4940:	6a 96       	adiw	r28, 0x1a	; 26
    4942:	0f b6       	in	r0, 0x3f	; 63
    4944:	f8 94       	cli
    4946:	de bf       	out	0x3e, r29	; 62
    4948:	0f be       	out	0x3f, r0	; 63
    494a:	cd bf       	out	0x3d, r28	; 61
    494c:	cf 91       	pop	r28
    494e:	df 91       	pop	r29
    4950:	1f 91       	pop	r17
    4952:	0f 91       	pop	r16
    4954:	ff 90       	pop	r15
    4956:	ef 90       	pop	r14
    4958:	df 90       	pop	r13
    495a:	cf 90       	pop	r12
    495c:	bf 90       	pop	r11
    495e:	af 90       	pop	r10
    4960:	9f 90       	pop	r9
    4962:	8f 90       	pop	r8
    4964:	7f 90       	pop	r7
    4966:	6f 90       	pop	r6
    4968:	5f 90       	pop	r5
    496a:	4f 90       	pop	r4
    496c:	3f 90       	pop	r3
    496e:	2f 90       	pop	r2
    4970:	08 95       	ret

00004972 <grab_frames>:
		rprintf("%d ",frame.distance[ndx]);
	}
	rprintfCRLF();
}

void grab_frames(const LDS_FRAME *frame, LDS_FRAME ldsf[]){
    4972:	af 92       	push	r10
    4974:	bf 92       	push	r11
    4976:	cf 92       	push	r12
    4978:	df 92       	push	r13
    497a:	ef 92       	push	r14
    497c:	ff 92       	push	r15
    497e:	1f 93       	push	r17
    4980:	df 93       	push	r29
    4982:	cf 93       	push	r28
    4984:	cd b7       	in	r28, 0x3d	; 61
    4986:	de b7       	in	r29, 0x3e	; 62
    4988:	6d 97       	sbiw	r28, 0x1d	; 29
    498a:	0f b6       	in	r0, 0x3f	; 63
    498c:	f8 94       	cli
    498e:	de bf       	out	0x3e, r29	; 62
    4990:	0f be       	out	0x3f, r0	; 63
    4992:	cd bf       	out	0x3d, r28	; 61
    4994:	7b 01       	movw	r14, r22
	LDS_FRAME t_frame;
	uint8_t f_ndx = 1;
	ldsf[0] = *frame;
    4996:	db 01       	movw	r26, r22
    4998:	fc 01       	movw	r30, r24
    499a:	8d e1       	ldi	r24, 0x1D	; 29
    499c:	01 90       	ld	r0, Z+
    499e:	0d 92       	st	X+, r0
    49a0:	81 50       	subi	r24, 0x01	; 1
    49a2:	e1 f7       	brne	.-8      	; 0x499c <grab_frames+0x2a>
    49a4:	11 e0       	ldi	r17, 0x01	; 1

	while(f_ndx < 90){
		if(parse_frame(&t_frame)){
    49a6:	6e 01       	movw	r12, r28
    49a8:	08 94       	sec
    49aa:	c1 1c       	adc	r12, r1
    49ac:	d1 1c       	adc	r13, r1
			ldsf[f_ndx] = t_frame;
    49ae:	8d e1       	ldi	r24, 0x1D	; 29
    49b0:	a8 2e       	mov	r10, r24
    49b2:	b1 2c       	mov	r11, r1
	LDS_FRAME t_frame;
	uint8_t f_ndx = 1;
	ldsf[0] = *frame;

	while(f_ndx < 90){
		if(parse_frame(&t_frame)){
    49b4:	c6 01       	movw	r24, r12
    49b6:	0e 94 d2 23 	call	0x47a4	; 0x47a4 <parse_frame>
    49ba:	88 23       	and	r24, r24
    49bc:	d9 f3       	breq	.-10     	; 0x49b4 <grab_frames+0x42>
			ldsf[f_ndx] = t_frame;
    49be:	81 2f       	mov	r24, r17
    49c0:	90 e0       	ldi	r25, 0x00	; 0
    49c2:	8a 9d       	mul	r24, r10
    49c4:	f0 01       	movw	r30, r0
    49c6:	8b 9d       	mul	r24, r11
    49c8:	f0 0d       	add	r31, r0
    49ca:	9a 9d       	mul	r25, r10
    49cc:	f0 0d       	add	r31, r0
    49ce:	11 24       	eor	r1, r1
    49d0:	ee 0d       	add	r30, r14
    49d2:	ff 1d       	adc	r31, r15
    49d4:	d6 01       	movw	r26, r12
    49d6:	8d e1       	ldi	r24, 0x1D	; 29
    49d8:	0d 90       	ld	r0, X+
    49da:	01 92       	st	Z+, r0
    49dc:	81 50       	subi	r24, 0x01	; 1
    49de:	e1 f7       	brne	.-8      	; 0x49d8 <grab_frames+0x66>
			f_ndx++;
    49e0:	1f 5f       	subi	r17, 0xFF	; 255
void grab_frames(const LDS_FRAME *frame, LDS_FRAME ldsf[]){
	LDS_FRAME t_frame;
	uint8_t f_ndx = 1;
	ldsf[0] = *frame;

	while(f_ndx < 90){
    49e2:	1a 35       	cpi	r17, 0x5A	; 90
    49e4:	38 f3       	brcs	.-50     	; 0x49b4 <grab_frames+0x42>
		if(parse_frame(&t_frame)){
			ldsf[f_ndx] = t_frame;
			f_ndx++;
		}
	}
}
    49e6:	6d 96       	adiw	r28, 0x1d	; 29
    49e8:	0f b6       	in	r0, 0x3f	; 63
    49ea:	f8 94       	cli
    49ec:	de bf       	out	0x3e, r29	; 62
    49ee:	0f be       	out	0x3f, r0	; 63
    49f0:	cd bf       	out	0x3d, r28	; 61
    49f2:	cf 91       	pop	r28
    49f4:	df 91       	pop	r29
    49f6:	1f 91       	pop	r17
    49f8:	ff 90       	pop	r15
    49fa:	ef 90       	pop	r14
    49fc:	df 90       	pop	r13
    49fe:	cf 90       	pop	r12
    4a00:	bf 90       	pop	r11
    4a02:	af 90       	pop	r10
    4a04:	08 95       	ret

00004a06 <get_range_scan>:
		ranges[r_ndx + 2] = (ldsf[f_ndx].distance[2]);
		ranges[r_ndx + 3] = (ldsf[f_ndx].distance[3]);
	}
}

void get_range_scan(uint16_t ranges[]){
    4a06:	cf 92       	push	r12
    4a08:	df 92       	push	r13
    4a0a:	ef 92       	push	r14
    4a0c:	ff 92       	push	r15
    4a0e:	0f 93       	push	r16
    4a10:	1f 93       	push	r17
    4a12:	df 93       	push	r29
    4a14:	cf 93       	push	r28
    4a16:	cd b7       	in	r28, 0x3d	; 61
    4a18:	de b7       	in	r29, 0x3e	; 62
    4a1a:	cf 54       	subi	r28, 0x4F	; 79
    4a1c:	da 40       	sbci	r29, 0x0A	; 10
    4a1e:	0f b6       	in	r0, 0x3f	; 63
    4a20:	f8 94       	cli
    4a22:	de bf       	out	0x3e, r29	; 62
    4a24:	0f be       	out	0x3f, r0	; 63
    4a26:	cd bf       	out	0x3d, r28	; 61
    4a28:	6c 01       	movw	r12, r24
	uint8_t first_frame = UNSET;
	LDS_FRAME frame;
	LDS_FRAME ldsf[90];
	// Grab frames
	while(!first_frame){
		if(parse_frame(&frame)){
    4a2a:	7e 01       	movw	r14, r28
    4a2c:	08 94       	sec
    4a2e:	e1 1c       	adc	r14, r1
    4a30:	f1 1c       	adc	r15, r1
    4a32:	c7 01       	movw	r24, r14
    4a34:	0e 94 d2 23 	call	0x47a4	; 0x47a4 <parse_frame>
    4a38:	88 23       	and	r24, r24
    4a3a:	d9 f3       	breq	.-10     	; 0x4a32 <get_range_scan+0x2c>
			//rprintf("Got frame.\n");
			// If you get the first frame, start reading into the frame buffer
			if(frame.index == 0xA0){
    4a3c:	89 81       	ldd	r24, Y+1	; 0x01
    4a3e:	80 3a       	cpi	r24, 0xA0	; 160
    4a40:	c1 f7       	brne	.-16     	; 0x4a32 <get_range_scan+0x2c>
				first_frame = SET;
				grab_frames(&frame,ldsf);
    4a42:	8e 01       	movw	r16, r28
    4a44:	02 5e       	subi	r16, 0xE2	; 226
    4a46:	1f 4f       	sbci	r17, 0xFF	; 255
    4a48:	c7 01       	movw	r24, r14
    4a4a:	b8 01       	movw	r22, r16
    4a4c:	0e 94 b9 24 	call	0x4972	; 0x4972 <grab_frames>
				//rprintf("Frames grabbed.\n");
				// Convert frames into distances
				conv_FrametoDist(ldsf,ranges);
    4a50:	c8 01       	movw	r24, r16
    4a52:	b6 01       	movw	r22, r12
    4a54:	0e 94 ea 22 	call	0x45d4	; 0x45d4 <conv_FrametoDist>
				rprintf("\nScan end\n\n");
				*/
			}
		}
	}
}
    4a58:	c1 5b       	subi	r28, 0xB1	; 177
    4a5a:	d5 4f       	sbci	r29, 0xF5	; 245
    4a5c:	0f b6       	in	r0, 0x3f	; 63
    4a5e:	f8 94       	cli
    4a60:	de bf       	out	0x3e, r29	; 62
    4a62:	0f be       	out	0x3f, r0	; 63
    4a64:	cd bf       	out	0x3d, r28	; 61
    4a66:	cf 91       	pop	r28
    4a68:	df 91       	pop	r29
    4a6a:	1f 91       	pop	r17
    4a6c:	0f 91       	pop	r16
    4a6e:	ff 90       	pop	r15
    4a70:	ef 90       	pop	r14
    4a72:	df 90       	pop	r13
    4a74:	cf 90       	pop	r12
    4a76:	08 95       	ret

00004a78 <exit>:
    4a78:	f8 94       	cli
    4a7a:	0c 94 d8 27 	jmp	0x4fb0	; 0x4fb0 <_exit>

00004a7e <memcpy>:
    4a7e:	fb 01       	movw	r30, r22
    4a80:	dc 01       	movw	r26, r24
    4a82:	02 c0       	rjmp	.+4      	; 0x4a88 <memcpy+0xa>
    4a84:	01 90       	ld	r0, Z+
    4a86:	0d 92       	st	X+, r0
    4a88:	41 50       	subi	r20, 0x01	; 1
    4a8a:	50 40       	sbci	r21, 0x00	; 0
    4a8c:	d8 f7       	brcc	.-10     	; 0x4a84 <memcpy+0x6>
    4a8e:	08 95       	ret

00004a90 <memset>:
    4a90:	dc 01       	movw	r26, r24
    4a92:	01 c0       	rjmp	.+2      	; 0x4a96 <memset+0x6>
    4a94:	6d 93       	st	X+, r22
    4a96:	41 50       	subi	r20, 0x01	; 1
    4a98:	50 40       	sbci	r21, 0x00	; 0
    4a9a:	e0 f7       	brcc	.-8      	; 0x4a94 <memset+0x4>
    4a9c:	08 95       	ret

00004a9e <strncpy>:
    4a9e:	fb 01       	movw	r30, r22
    4aa0:	dc 01       	movw	r26, r24
    4aa2:	41 50       	subi	r20, 0x01	; 1
    4aa4:	50 40       	sbci	r21, 0x00	; 0
    4aa6:	48 f0       	brcs	.+18     	; 0x4aba <strncpy+0x1c>
    4aa8:	01 90       	ld	r0, Z+
    4aaa:	0d 92       	st	X+, r0
    4aac:	00 20       	and	r0, r0
    4aae:	c9 f7       	brne	.-14     	; 0x4aa2 <strncpy+0x4>
    4ab0:	01 c0       	rjmp	.+2      	; 0x4ab4 <strncpy+0x16>
    4ab2:	1d 92       	st	X+, r1
    4ab4:	41 50       	subi	r20, 0x01	; 1
    4ab6:	50 40       	sbci	r21, 0x00	; 0
    4ab8:	e0 f7       	brcc	.-8      	; 0x4ab2 <strncpy+0x14>
    4aba:	08 95       	ret

00004abc <__subsf3>:
    4abc:	50 58       	subi	r21, 0x80	; 128

00004abe <__addsf3>:
    4abe:	bb 27       	eor	r27, r27
    4ac0:	aa 27       	eor	r26, r26
    4ac2:	0e d0       	rcall	.+28     	; 0x4ae0 <__addsf3x>
    4ac4:	70 c1       	rjmp	.+736    	; 0x4da6 <__fp_round>
    4ac6:	61 d1       	rcall	.+706    	; 0x4d8a <__fp_pscA>
    4ac8:	30 f0       	brcs	.+12     	; 0x4ad6 <__addsf3+0x18>
    4aca:	66 d1       	rcall	.+716    	; 0x4d98 <__fp_pscB>
    4acc:	20 f0       	brcs	.+8      	; 0x4ad6 <__addsf3+0x18>
    4ace:	31 f4       	brne	.+12     	; 0x4adc <__addsf3+0x1e>
    4ad0:	9f 3f       	cpi	r25, 0xFF	; 255
    4ad2:	11 f4       	brne	.+4      	; 0x4ad8 <__addsf3+0x1a>
    4ad4:	1e f4       	brtc	.+6      	; 0x4adc <__addsf3+0x1e>
    4ad6:	56 c1       	rjmp	.+684    	; 0x4d84 <__fp_nan>
    4ad8:	0e f4       	brtc	.+2      	; 0x4adc <__addsf3+0x1e>
    4ada:	e0 95       	com	r30
    4adc:	e7 fb       	bst	r30, 7
    4ade:	4c c1       	rjmp	.+664    	; 0x4d78 <__fp_inf>

00004ae0 <__addsf3x>:
    4ae0:	e9 2f       	mov	r30, r25
    4ae2:	72 d1       	rcall	.+740    	; 0x4dc8 <__fp_split3>
    4ae4:	80 f3       	brcs	.-32     	; 0x4ac6 <__addsf3+0x8>
    4ae6:	ba 17       	cp	r27, r26
    4ae8:	62 07       	cpc	r22, r18
    4aea:	73 07       	cpc	r23, r19
    4aec:	84 07       	cpc	r24, r20
    4aee:	95 07       	cpc	r25, r21
    4af0:	18 f0       	brcs	.+6      	; 0x4af8 <__addsf3x+0x18>
    4af2:	71 f4       	brne	.+28     	; 0x4b10 <__addsf3x+0x30>
    4af4:	9e f5       	brtc	.+102    	; 0x4b5c <__addsf3x+0x7c>
    4af6:	8a c1       	rjmp	.+788    	; 0x4e0c <__fp_zero>
    4af8:	0e f4       	brtc	.+2      	; 0x4afc <__addsf3x+0x1c>
    4afa:	e0 95       	com	r30
    4afc:	0b 2e       	mov	r0, r27
    4afe:	ba 2f       	mov	r27, r26
    4b00:	a0 2d       	mov	r26, r0
    4b02:	0b 01       	movw	r0, r22
    4b04:	b9 01       	movw	r22, r18
    4b06:	90 01       	movw	r18, r0
    4b08:	0c 01       	movw	r0, r24
    4b0a:	ca 01       	movw	r24, r20
    4b0c:	a0 01       	movw	r20, r0
    4b0e:	11 24       	eor	r1, r1
    4b10:	ff 27       	eor	r31, r31
    4b12:	59 1b       	sub	r21, r25
    4b14:	99 f0       	breq	.+38     	; 0x4b3c <__addsf3x+0x5c>
    4b16:	59 3f       	cpi	r21, 0xF9	; 249
    4b18:	50 f4       	brcc	.+20     	; 0x4b2e <__addsf3x+0x4e>
    4b1a:	50 3e       	cpi	r21, 0xE0	; 224
    4b1c:	68 f1       	brcs	.+90     	; 0x4b78 <__addsf3x+0x98>
    4b1e:	1a 16       	cp	r1, r26
    4b20:	f0 40       	sbci	r31, 0x00	; 0
    4b22:	a2 2f       	mov	r26, r18
    4b24:	23 2f       	mov	r18, r19
    4b26:	34 2f       	mov	r19, r20
    4b28:	44 27       	eor	r20, r20
    4b2a:	58 5f       	subi	r21, 0xF8	; 248
    4b2c:	f3 cf       	rjmp	.-26     	; 0x4b14 <__addsf3x+0x34>
    4b2e:	46 95       	lsr	r20
    4b30:	37 95       	ror	r19
    4b32:	27 95       	ror	r18
    4b34:	a7 95       	ror	r26
    4b36:	f0 40       	sbci	r31, 0x00	; 0
    4b38:	53 95       	inc	r21
    4b3a:	c9 f7       	brne	.-14     	; 0x4b2e <__addsf3x+0x4e>
    4b3c:	7e f4       	brtc	.+30     	; 0x4b5c <__addsf3x+0x7c>
    4b3e:	1f 16       	cp	r1, r31
    4b40:	ba 0b       	sbc	r27, r26
    4b42:	62 0b       	sbc	r22, r18
    4b44:	73 0b       	sbc	r23, r19
    4b46:	84 0b       	sbc	r24, r20
    4b48:	ba f0       	brmi	.+46     	; 0x4b78 <__addsf3x+0x98>
    4b4a:	91 50       	subi	r25, 0x01	; 1
    4b4c:	a1 f0       	breq	.+40     	; 0x4b76 <__addsf3x+0x96>
    4b4e:	ff 0f       	add	r31, r31
    4b50:	bb 1f       	adc	r27, r27
    4b52:	66 1f       	adc	r22, r22
    4b54:	77 1f       	adc	r23, r23
    4b56:	88 1f       	adc	r24, r24
    4b58:	c2 f7       	brpl	.-16     	; 0x4b4a <__addsf3x+0x6a>
    4b5a:	0e c0       	rjmp	.+28     	; 0x4b78 <__addsf3x+0x98>
    4b5c:	ba 0f       	add	r27, r26
    4b5e:	62 1f       	adc	r22, r18
    4b60:	73 1f       	adc	r23, r19
    4b62:	84 1f       	adc	r24, r20
    4b64:	48 f4       	brcc	.+18     	; 0x4b78 <__addsf3x+0x98>
    4b66:	87 95       	ror	r24
    4b68:	77 95       	ror	r23
    4b6a:	67 95       	ror	r22
    4b6c:	b7 95       	ror	r27
    4b6e:	f7 95       	ror	r31
    4b70:	9e 3f       	cpi	r25, 0xFE	; 254
    4b72:	08 f0       	brcs	.+2      	; 0x4b76 <__addsf3x+0x96>
    4b74:	b3 cf       	rjmp	.-154    	; 0x4adc <__addsf3+0x1e>
    4b76:	93 95       	inc	r25
    4b78:	88 0f       	add	r24, r24
    4b7a:	08 f0       	brcs	.+2      	; 0x4b7e <__addsf3x+0x9e>
    4b7c:	99 27       	eor	r25, r25
    4b7e:	ee 0f       	add	r30, r30
    4b80:	97 95       	ror	r25
    4b82:	87 95       	ror	r24
    4b84:	08 95       	ret

00004b86 <__cmpsf2>:
    4b86:	d4 d0       	rcall	.+424    	; 0x4d30 <__fp_cmp>
    4b88:	08 f4       	brcc	.+2      	; 0x4b8c <__cmpsf2+0x6>
    4b8a:	81 e0       	ldi	r24, 0x01	; 1
    4b8c:	08 95       	ret

00004b8e <__divsf3>:
    4b8e:	0c d0       	rcall	.+24     	; 0x4ba8 <__divsf3x>
    4b90:	0a c1       	rjmp	.+532    	; 0x4da6 <__fp_round>
    4b92:	02 d1       	rcall	.+516    	; 0x4d98 <__fp_pscB>
    4b94:	40 f0       	brcs	.+16     	; 0x4ba6 <__divsf3+0x18>
    4b96:	f9 d0       	rcall	.+498    	; 0x4d8a <__fp_pscA>
    4b98:	30 f0       	brcs	.+12     	; 0x4ba6 <__divsf3+0x18>
    4b9a:	21 f4       	brne	.+8      	; 0x4ba4 <__divsf3+0x16>
    4b9c:	5f 3f       	cpi	r21, 0xFF	; 255
    4b9e:	19 f0       	breq	.+6      	; 0x4ba6 <__divsf3+0x18>
    4ba0:	eb c0       	rjmp	.+470    	; 0x4d78 <__fp_inf>
    4ba2:	51 11       	cpse	r21, r1
    4ba4:	34 c1       	rjmp	.+616    	; 0x4e0e <__fp_szero>
    4ba6:	ee c0       	rjmp	.+476    	; 0x4d84 <__fp_nan>

00004ba8 <__divsf3x>:
    4ba8:	0f d1       	rcall	.+542    	; 0x4dc8 <__fp_split3>
    4baa:	98 f3       	brcs	.-26     	; 0x4b92 <__divsf3+0x4>

00004bac <__divsf3_pse>:
    4bac:	99 23       	and	r25, r25
    4bae:	c9 f3       	breq	.-14     	; 0x4ba2 <__divsf3+0x14>
    4bb0:	55 23       	and	r21, r21
    4bb2:	b1 f3       	breq	.-20     	; 0x4ba0 <__divsf3+0x12>
    4bb4:	95 1b       	sub	r25, r21
    4bb6:	55 0b       	sbc	r21, r21
    4bb8:	bb 27       	eor	r27, r27
    4bba:	aa 27       	eor	r26, r26
    4bbc:	62 17       	cp	r22, r18
    4bbe:	73 07       	cpc	r23, r19
    4bc0:	84 07       	cpc	r24, r20
    4bc2:	38 f0       	brcs	.+14     	; 0x4bd2 <__divsf3_pse+0x26>
    4bc4:	9f 5f       	subi	r25, 0xFF	; 255
    4bc6:	5f 4f       	sbci	r21, 0xFF	; 255
    4bc8:	22 0f       	add	r18, r18
    4bca:	33 1f       	adc	r19, r19
    4bcc:	44 1f       	adc	r20, r20
    4bce:	aa 1f       	adc	r26, r26
    4bd0:	a9 f3       	breq	.-22     	; 0x4bbc <__divsf3_pse+0x10>
    4bd2:	33 d0       	rcall	.+102    	; 0x4c3a <__divsf3_pse+0x8e>
    4bd4:	0e 2e       	mov	r0, r30
    4bd6:	3a f0       	brmi	.+14     	; 0x4be6 <__divsf3_pse+0x3a>
    4bd8:	e0 e8       	ldi	r30, 0x80	; 128
    4bda:	30 d0       	rcall	.+96     	; 0x4c3c <__divsf3_pse+0x90>
    4bdc:	91 50       	subi	r25, 0x01	; 1
    4bde:	50 40       	sbci	r21, 0x00	; 0
    4be0:	e6 95       	lsr	r30
    4be2:	00 1c       	adc	r0, r0
    4be4:	ca f7       	brpl	.-14     	; 0x4bd8 <__divsf3_pse+0x2c>
    4be6:	29 d0       	rcall	.+82     	; 0x4c3a <__divsf3_pse+0x8e>
    4be8:	fe 2f       	mov	r31, r30
    4bea:	27 d0       	rcall	.+78     	; 0x4c3a <__divsf3_pse+0x8e>
    4bec:	66 0f       	add	r22, r22
    4bee:	77 1f       	adc	r23, r23
    4bf0:	88 1f       	adc	r24, r24
    4bf2:	bb 1f       	adc	r27, r27
    4bf4:	26 17       	cp	r18, r22
    4bf6:	37 07       	cpc	r19, r23
    4bf8:	48 07       	cpc	r20, r24
    4bfa:	ab 07       	cpc	r26, r27
    4bfc:	b0 e8       	ldi	r27, 0x80	; 128
    4bfe:	09 f0       	breq	.+2      	; 0x4c02 <__divsf3_pse+0x56>
    4c00:	bb 0b       	sbc	r27, r27
    4c02:	80 2d       	mov	r24, r0
    4c04:	bf 01       	movw	r22, r30
    4c06:	ff 27       	eor	r31, r31
    4c08:	93 58       	subi	r25, 0x83	; 131
    4c0a:	5f 4f       	sbci	r21, 0xFF	; 255
    4c0c:	2a f0       	brmi	.+10     	; 0x4c18 <__divsf3_pse+0x6c>
    4c0e:	9e 3f       	cpi	r25, 0xFE	; 254
    4c10:	51 05       	cpc	r21, r1
    4c12:	68 f0       	brcs	.+26     	; 0x4c2e <__divsf3_pse+0x82>
    4c14:	b1 c0       	rjmp	.+354    	; 0x4d78 <__fp_inf>
    4c16:	fb c0       	rjmp	.+502    	; 0x4e0e <__fp_szero>
    4c18:	5f 3f       	cpi	r21, 0xFF	; 255
    4c1a:	ec f3       	brlt	.-6      	; 0x4c16 <__divsf3_pse+0x6a>
    4c1c:	98 3e       	cpi	r25, 0xE8	; 232
    4c1e:	dc f3       	brlt	.-10     	; 0x4c16 <__divsf3_pse+0x6a>
    4c20:	86 95       	lsr	r24
    4c22:	77 95       	ror	r23
    4c24:	67 95       	ror	r22
    4c26:	b7 95       	ror	r27
    4c28:	f7 95       	ror	r31
    4c2a:	9f 5f       	subi	r25, 0xFF	; 255
    4c2c:	c9 f7       	brne	.-14     	; 0x4c20 <__divsf3_pse+0x74>
    4c2e:	88 0f       	add	r24, r24
    4c30:	91 1d       	adc	r25, r1
    4c32:	96 95       	lsr	r25
    4c34:	87 95       	ror	r24
    4c36:	97 f9       	bld	r25, 7
    4c38:	08 95       	ret
    4c3a:	e1 e0       	ldi	r30, 0x01	; 1
    4c3c:	66 0f       	add	r22, r22
    4c3e:	77 1f       	adc	r23, r23
    4c40:	88 1f       	adc	r24, r24
    4c42:	bb 1f       	adc	r27, r27
    4c44:	62 17       	cp	r22, r18
    4c46:	73 07       	cpc	r23, r19
    4c48:	84 07       	cpc	r24, r20
    4c4a:	ba 07       	cpc	r27, r26
    4c4c:	20 f0       	brcs	.+8      	; 0x4c56 <__divsf3_pse+0xaa>
    4c4e:	62 1b       	sub	r22, r18
    4c50:	73 0b       	sbc	r23, r19
    4c52:	84 0b       	sbc	r24, r20
    4c54:	ba 0b       	sbc	r27, r26
    4c56:	ee 1f       	adc	r30, r30
    4c58:	88 f7       	brcc	.-30     	; 0x4c3c <__divsf3_pse+0x90>
    4c5a:	e0 95       	com	r30
    4c5c:	08 95       	ret

00004c5e <__fixunssfsi>:
    4c5e:	bc d0       	rcall	.+376    	; 0x4dd8 <__fp_splitA>
    4c60:	88 f0       	brcs	.+34     	; 0x4c84 <__fixunssfsi+0x26>
    4c62:	9f 57       	subi	r25, 0x7F	; 127
    4c64:	90 f0       	brcs	.+36     	; 0x4c8a <__fixunssfsi+0x2c>
    4c66:	b9 2f       	mov	r27, r25
    4c68:	99 27       	eor	r25, r25
    4c6a:	b7 51       	subi	r27, 0x17	; 23
    4c6c:	a0 f0       	brcs	.+40     	; 0x4c96 <__fixunssfsi+0x38>
    4c6e:	d1 f0       	breq	.+52     	; 0x4ca4 <__fixunssfsi+0x46>
    4c70:	66 0f       	add	r22, r22
    4c72:	77 1f       	adc	r23, r23
    4c74:	88 1f       	adc	r24, r24
    4c76:	99 1f       	adc	r25, r25
    4c78:	1a f0       	brmi	.+6      	; 0x4c80 <__fixunssfsi+0x22>
    4c7a:	ba 95       	dec	r27
    4c7c:	c9 f7       	brne	.-14     	; 0x4c70 <__fixunssfsi+0x12>
    4c7e:	12 c0       	rjmp	.+36     	; 0x4ca4 <__fixunssfsi+0x46>
    4c80:	b1 30       	cpi	r27, 0x01	; 1
    4c82:	81 f0       	breq	.+32     	; 0x4ca4 <__fixunssfsi+0x46>
    4c84:	c3 d0       	rcall	.+390    	; 0x4e0c <__fp_zero>
    4c86:	b1 e0       	ldi	r27, 0x01	; 1
    4c88:	08 95       	ret
    4c8a:	c0 c0       	rjmp	.+384    	; 0x4e0c <__fp_zero>
    4c8c:	67 2f       	mov	r22, r23
    4c8e:	78 2f       	mov	r23, r24
    4c90:	88 27       	eor	r24, r24
    4c92:	b8 5f       	subi	r27, 0xF8	; 248
    4c94:	39 f0       	breq	.+14     	; 0x4ca4 <__fixunssfsi+0x46>
    4c96:	b9 3f       	cpi	r27, 0xF9	; 249
    4c98:	cc f3       	brlt	.-14     	; 0x4c8c <__fixunssfsi+0x2e>
    4c9a:	86 95       	lsr	r24
    4c9c:	77 95       	ror	r23
    4c9e:	67 95       	ror	r22
    4ca0:	b3 95       	inc	r27
    4ca2:	d9 f7       	brne	.-10     	; 0x4c9a <__fixunssfsi+0x3c>
    4ca4:	3e f4       	brtc	.+14     	; 0x4cb4 <__fixunssfsi+0x56>
    4ca6:	90 95       	com	r25
    4ca8:	80 95       	com	r24
    4caa:	70 95       	com	r23
    4cac:	61 95       	neg	r22
    4cae:	7f 4f       	sbci	r23, 0xFF	; 255
    4cb0:	8f 4f       	sbci	r24, 0xFF	; 255
    4cb2:	9f 4f       	sbci	r25, 0xFF	; 255
    4cb4:	08 95       	ret

00004cb6 <__floatunsisf>:
    4cb6:	e8 94       	clt
    4cb8:	09 c0       	rjmp	.+18     	; 0x4ccc <__floatsisf+0x12>

00004cba <__floatsisf>:
    4cba:	97 fb       	bst	r25, 7
    4cbc:	3e f4       	brtc	.+14     	; 0x4ccc <__floatsisf+0x12>
    4cbe:	90 95       	com	r25
    4cc0:	80 95       	com	r24
    4cc2:	70 95       	com	r23
    4cc4:	61 95       	neg	r22
    4cc6:	7f 4f       	sbci	r23, 0xFF	; 255
    4cc8:	8f 4f       	sbci	r24, 0xFF	; 255
    4cca:	9f 4f       	sbci	r25, 0xFF	; 255
    4ccc:	99 23       	and	r25, r25
    4cce:	a9 f0       	breq	.+42     	; 0x4cfa <__floatsisf+0x40>
    4cd0:	f9 2f       	mov	r31, r25
    4cd2:	96 e9       	ldi	r25, 0x96	; 150
    4cd4:	bb 27       	eor	r27, r27
    4cd6:	93 95       	inc	r25
    4cd8:	f6 95       	lsr	r31
    4cda:	87 95       	ror	r24
    4cdc:	77 95       	ror	r23
    4cde:	67 95       	ror	r22
    4ce0:	b7 95       	ror	r27
    4ce2:	f1 11       	cpse	r31, r1
    4ce4:	f8 cf       	rjmp	.-16     	; 0x4cd6 <__floatsisf+0x1c>
    4ce6:	fa f4       	brpl	.+62     	; 0x4d26 <__floatsisf+0x6c>
    4ce8:	bb 0f       	add	r27, r27
    4cea:	11 f4       	brne	.+4      	; 0x4cf0 <__floatsisf+0x36>
    4cec:	60 ff       	sbrs	r22, 0
    4cee:	1b c0       	rjmp	.+54     	; 0x4d26 <__floatsisf+0x6c>
    4cf0:	6f 5f       	subi	r22, 0xFF	; 255
    4cf2:	7f 4f       	sbci	r23, 0xFF	; 255
    4cf4:	8f 4f       	sbci	r24, 0xFF	; 255
    4cf6:	9f 4f       	sbci	r25, 0xFF	; 255
    4cf8:	16 c0       	rjmp	.+44     	; 0x4d26 <__floatsisf+0x6c>
    4cfa:	88 23       	and	r24, r24
    4cfc:	11 f0       	breq	.+4      	; 0x4d02 <__floatsisf+0x48>
    4cfe:	96 e9       	ldi	r25, 0x96	; 150
    4d00:	11 c0       	rjmp	.+34     	; 0x4d24 <__floatsisf+0x6a>
    4d02:	77 23       	and	r23, r23
    4d04:	21 f0       	breq	.+8      	; 0x4d0e <__floatsisf+0x54>
    4d06:	9e e8       	ldi	r25, 0x8E	; 142
    4d08:	87 2f       	mov	r24, r23
    4d0a:	76 2f       	mov	r23, r22
    4d0c:	05 c0       	rjmp	.+10     	; 0x4d18 <__floatsisf+0x5e>
    4d0e:	66 23       	and	r22, r22
    4d10:	71 f0       	breq	.+28     	; 0x4d2e <__floatsisf+0x74>
    4d12:	96 e8       	ldi	r25, 0x86	; 134
    4d14:	86 2f       	mov	r24, r22
    4d16:	70 e0       	ldi	r23, 0x00	; 0
    4d18:	60 e0       	ldi	r22, 0x00	; 0
    4d1a:	2a f0       	brmi	.+10     	; 0x4d26 <__floatsisf+0x6c>
    4d1c:	9a 95       	dec	r25
    4d1e:	66 0f       	add	r22, r22
    4d20:	77 1f       	adc	r23, r23
    4d22:	88 1f       	adc	r24, r24
    4d24:	da f7       	brpl	.-10     	; 0x4d1c <__floatsisf+0x62>
    4d26:	88 0f       	add	r24, r24
    4d28:	96 95       	lsr	r25
    4d2a:	87 95       	ror	r24
    4d2c:	97 f9       	bld	r25, 7
    4d2e:	08 95       	ret

00004d30 <__fp_cmp>:
    4d30:	99 0f       	add	r25, r25
    4d32:	00 08       	sbc	r0, r0
    4d34:	55 0f       	add	r21, r21
    4d36:	aa 0b       	sbc	r26, r26
    4d38:	e0 e8       	ldi	r30, 0x80	; 128
    4d3a:	fe ef       	ldi	r31, 0xFE	; 254
    4d3c:	16 16       	cp	r1, r22
    4d3e:	17 06       	cpc	r1, r23
    4d40:	e8 07       	cpc	r30, r24
    4d42:	f9 07       	cpc	r31, r25
    4d44:	c0 f0       	brcs	.+48     	; 0x4d76 <__fp_cmp+0x46>
    4d46:	12 16       	cp	r1, r18
    4d48:	13 06       	cpc	r1, r19
    4d4a:	e4 07       	cpc	r30, r20
    4d4c:	f5 07       	cpc	r31, r21
    4d4e:	98 f0       	brcs	.+38     	; 0x4d76 <__fp_cmp+0x46>
    4d50:	62 1b       	sub	r22, r18
    4d52:	73 0b       	sbc	r23, r19
    4d54:	84 0b       	sbc	r24, r20
    4d56:	95 0b       	sbc	r25, r21
    4d58:	39 f4       	brne	.+14     	; 0x4d68 <__fp_cmp+0x38>
    4d5a:	0a 26       	eor	r0, r26
    4d5c:	61 f0       	breq	.+24     	; 0x4d76 <__fp_cmp+0x46>
    4d5e:	23 2b       	or	r18, r19
    4d60:	24 2b       	or	r18, r20
    4d62:	25 2b       	or	r18, r21
    4d64:	21 f4       	brne	.+8      	; 0x4d6e <__fp_cmp+0x3e>
    4d66:	08 95       	ret
    4d68:	0a 26       	eor	r0, r26
    4d6a:	09 f4       	brne	.+2      	; 0x4d6e <__fp_cmp+0x3e>
    4d6c:	a1 40       	sbci	r26, 0x01	; 1
    4d6e:	a6 95       	lsr	r26
    4d70:	8f ef       	ldi	r24, 0xFF	; 255
    4d72:	81 1d       	adc	r24, r1
    4d74:	81 1d       	adc	r24, r1
    4d76:	08 95       	ret

00004d78 <__fp_inf>:
    4d78:	97 f9       	bld	r25, 7
    4d7a:	9f 67       	ori	r25, 0x7F	; 127
    4d7c:	80 e8       	ldi	r24, 0x80	; 128
    4d7e:	70 e0       	ldi	r23, 0x00	; 0
    4d80:	60 e0       	ldi	r22, 0x00	; 0
    4d82:	08 95       	ret

00004d84 <__fp_nan>:
    4d84:	9f ef       	ldi	r25, 0xFF	; 255
    4d86:	80 ec       	ldi	r24, 0xC0	; 192
    4d88:	08 95       	ret

00004d8a <__fp_pscA>:
    4d8a:	00 24       	eor	r0, r0
    4d8c:	0a 94       	dec	r0
    4d8e:	16 16       	cp	r1, r22
    4d90:	17 06       	cpc	r1, r23
    4d92:	18 06       	cpc	r1, r24
    4d94:	09 06       	cpc	r0, r25
    4d96:	08 95       	ret

00004d98 <__fp_pscB>:
    4d98:	00 24       	eor	r0, r0
    4d9a:	0a 94       	dec	r0
    4d9c:	12 16       	cp	r1, r18
    4d9e:	13 06       	cpc	r1, r19
    4da0:	14 06       	cpc	r1, r20
    4da2:	05 06       	cpc	r0, r21
    4da4:	08 95       	ret

00004da6 <__fp_round>:
    4da6:	09 2e       	mov	r0, r25
    4da8:	03 94       	inc	r0
    4daa:	00 0c       	add	r0, r0
    4dac:	11 f4       	brne	.+4      	; 0x4db2 <__fp_round+0xc>
    4dae:	88 23       	and	r24, r24
    4db0:	52 f0       	brmi	.+20     	; 0x4dc6 <__fp_round+0x20>
    4db2:	bb 0f       	add	r27, r27
    4db4:	40 f4       	brcc	.+16     	; 0x4dc6 <__fp_round+0x20>
    4db6:	bf 2b       	or	r27, r31
    4db8:	11 f4       	brne	.+4      	; 0x4dbe <__fp_round+0x18>
    4dba:	60 ff       	sbrs	r22, 0
    4dbc:	04 c0       	rjmp	.+8      	; 0x4dc6 <__fp_round+0x20>
    4dbe:	6f 5f       	subi	r22, 0xFF	; 255
    4dc0:	7f 4f       	sbci	r23, 0xFF	; 255
    4dc2:	8f 4f       	sbci	r24, 0xFF	; 255
    4dc4:	9f 4f       	sbci	r25, 0xFF	; 255
    4dc6:	08 95       	ret

00004dc8 <__fp_split3>:
    4dc8:	57 fd       	sbrc	r21, 7
    4dca:	90 58       	subi	r25, 0x80	; 128
    4dcc:	44 0f       	add	r20, r20
    4dce:	55 1f       	adc	r21, r21
    4dd0:	59 f0       	breq	.+22     	; 0x4de8 <__fp_splitA+0x10>
    4dd2:	5f 3f       	cpi	r21, 0xFF	; 255
    4dd4:	71 f0       	breq	.+28     	; 0x4df2 <__fp_splitA+0x1a>
    4dd6:	47 95       	ror	r20

00004dd8 <__fp_splitA>:
    4dd8:	88 0f       	add	r24, r24
    4dda:	97 fb       	bst	r25, 7
    4ddc:	99 1f       	adc	r25, r25
    4dde:	61 f0       	breq	.+24     	; 0x4df8 <__fp_splitA+0x20>
    4de0:	9f 3f       	cpi	r25, 0xFF	; 255
    4de2:	79 f0       	breq	.+30     	; 0x4e02 <__fp_splitA+0x2a>
    4de4:	87 95       	ror	r24
    4de6:	08 95       	ret
    4de8:	12 16       	cp	r1, r18
    4dea:	13 06       	cpc	r1, r19
    4dec:	14 06       	cpc	r1, r20
    4dee:	55 1f       	adc	r21, r21
    4df0:	f2 cf       	rjmp	.-28     	; 0x4dd6 <__fp_split3+0xe>
    4df2:	46 95       	lsr	r20
    4df4:	f1 df       	rcall	.-30     	; 0x4dd8 <__fp_splitA>
    4df6:	08 c0       	rjmp	.+16     	; 0x4e08 <__fp_splitA+0x30>
    4df8:	16 16       	cp	r1, r22
    4dfa:	17 06       	cpc	r1, r23
    4dfc:	18 06       	cpc	r1, r24
    4dfe:	99 1f       	adc	r25, r25
    4e00:	f1 cf       	rjmp	.-30     	; 0x4de4 <__fp_splitA+0xc>
    4e02:	86 95       	lsr	r24
    4e04:	71 05       	cpc	r23, r1
    4e06:	61 05       	cpc	r22, r1
    4e08:	08 94       	sec
    4e0a:	08 95       	ret

00004e0c <__fp_zero>:
    4e0c:	e8 94       	clt

00004e0e <__fp_szero>:
    4e0e:	bb 27       	eor	r27, r27
    4e10:	66 27       	eor	r22, r22
    4e12:	77 27       	eor	r23, r23
    4e14:	cb 01       	movw	r24, r22
    4e16:	97 f9       	bld	r25, 7
    4e18:	08 95       	ret

00004e1a <__gesf2>:
    4e1a:	8a df       	rcall	.-236    	; 0x4d30 <__fp_cmp>
    4e1c:	08 f4       	brcc	.+2      	; 0x4e20 <__gesf2+0x6>
    4e1e:	8f ef       	ldi	r24, 0xFF	; 255
    4e20:	08 95       	ret

00004e22 <__mulsf3>:
    4e22:	0b d0       	rcall	.+22     	; 0x4e3a <__mulsf3x>
    4e24:	c0 cf       	rjmp	.-128    	; 0x4da6 <__fp_round>
    4e26:	b1 df       	rcall	.-158    	; 0x4d8a <__fp_pscA>
    4e28:	28 f0       	brcs	.+10     	; 0x4e34 <__mulsf3+0x12>
    4e2a:	b6 df       	rcall	.-148    	; 0x4d98 <__fp_pscB>
    4e2c:	18 f0       	brcs	.+6      	; 0x4e34 <__mulsf3+0x12>
    4e2e:	95 23       	and	r25, r21
    4e30:	09 f0       	breq	.+2      	; 0x4e34 <__mulsf3+0x12>
    4e32:	a2 cf       	rjmp	.-188    	; 0x4d78 <__fp_inf>
    4e34:	a7 cf       	rjmp	.-178    	; 0x4d84 <__fp_nan>
    4e36:	11 24       	eor	r1, r1
    4e38:	ea cf       	rjmp	.-44     	; 0x4e0e <__fp_szero>

00004e3a <__mulsf3x>:
    4e3a:	c6 df       	rcall	.-116    	; 0x4dc8 <__fp_split3>
    4e3c:	a0 f3       	brcs	.-24     	; 0x4e26 <__mulsf3+0x4>

00004e3e <__mulsf3_pse>:
    4e3e:	95 9f       	mul	r25, r21
    4e40:	d1 f3       	breq	.-12     	; 0x4e36 <__mulsf3+0x14>
    4e42:	95 0f       	add	r25, r21
    4e44:	50 e0       	ldi	r21, 0x00	; 0
    4e46:	55 1f       	adc	r21, r21
    4e48:	62 9f       	mul	r22, r18
    4e4a:	f0 01       	movw	r30, r0
    4e4c:	72 9f       	mul	r23, r18
    4e4e:	bb 27       	eor	r27, r27
    4e50:	f0 0d       	add	r31, r0
    4e52:	b1 1d       	adc	r27, r1
    4e54:	63 9f       	mul	r22, r19
    4e56:	aa 27       	eor	r26, r26
    4e58:	f0 0d       	add	r31, r0
    4e5a:	b1 1d       	adc	r27, r1
    4e5c:	aa 1f       	adc	r26, r26
    4e5e:	64 9f       	mul	r22, r20
    4e60:	66 27       	eor	r22, r22
    4e62:	b0 0d       	add	r27, r0
    4e64:	a1 1d       	adc	r26, r1
    4e66:	66 1f       	adc	r22, r22
    4e68:	82 9f       	mul	r24, r18
    4e6a:	22 27       	eor	r18, r18
    4e6c:	b0 0d       	add	r27, r0
    4e6e:	a1 1d       	adc	r26, r1
    4e70:	62 1f       	adc	r22, r18
    4e72:	73 9f       	mul	r23, r19
    4e74:	b0 0d       	add	r27, r0
    4e76:	a1 1d       	adc	r26, r1
    4e78:	62 1f       	adc	r22, r18
    4e7a:	83 9f       	mul	r24, r19
    4e7c:	a0 0d       	add	r26, r0
    4e7e:	61 1d       	adc	r22, r1
    4e80:	22 1f       	adc	r18, r18
    4e82:	74 9f       	mul	r23, r20
    4e84:	33 27       	eor	r19, r19
    4e86:	a0 0d       	add	r26, r0
    4e88:	61 1d       	adc	r22, r1
    4e8a:	23 1f       	adc	r18, r19
    4e8c:	84 9f       	mul	r24, r20
    4e8e:	60 0d       	add	r22, r0
    4e90:	21 1d       	adc	r18, r1
    4e92:	82 2f       	mov	r24, r18
    4e94:	76 2f       	mov	r23, r22
    4e96:	6a 2f       	mov	r22, r26
    4e98:	11 24       	eor	r1, r1
    4e9a:	9f 57       	subi	r25, 0x7F	; 127
    4e9c:	50 40       	sbci	r21, 0x00	; 0
    4e9e:	8a f0       	brmi	.+34     	; 0x4ec2 <__mulsf3_pse+0x84>
    4ea0:	e1 f0       	breq	.+56     	; 0x4eda <__mulsf3_pse+0x9c>
    4ea2:	88 23       	and	r24, r24
    4ea4:	4a f0       	brmi	.+18     	; 0x4eb8 <__mulsf3_pse+0x7a>
    4ea6:	ee 0f       	add	r30, r30
    4ea8:	ff 1f       	adc	r31, r31
    4eaa:	bb 1f       	adc	r27, r27
    4eac:	66 1f       	adc	r22, r22
    4eae:	77 1f       	adc	r23, r23
    4eb0:	88 1f       	adc	r24, r24
    4eb2:	91 50       	subi	r25, 0x01	; 1
    4eb4:	50 40       	sbci	r21, 0x00	; 0
    4eb6:	a9 f7       	brne	.-22     	; 0x4ea2 <__mulsf3_pse+0x64>
    4eb8:	9e 3f       	cpi	r25, 0xFE	; 254
    4eba:	51 05       	cpc	r21, r1
    4ebc:	70 f0       	brcs	.+28     	; 0x4eda <__mulsf3_pse+0x9c>
    4ebe:	5c cf       	rjmp	.-328    	; 0x4d78 <__fp_inf>
    4ec0:	a6 cf       	rjmp	.-180    	; 0x4e0e <__fp_szero>
    4ec2:	5f 3f       	cpi	r21, 0xFF	; 255
    4ec4:	ec f3       	brlt	.-6      	; 0x4ec0 <__mulsf3_pse+0x82>
    4ec6:	98 3e       	cpi	r25, 0xE8	; 232
    4ec8:	dc f3       	brlt	.-10     	; 0x4ec0 <__mulsf3_pse+0x82>
    4eca:	86 95       	lsr	r24
    4ecc:	77 95       	ror	r23
    4ece:	67 95       	ror	r22
    4ed0:	b7 95       	ror	r27
    4ed2:	f7 95       	ror	r31
    4ed4:	e7 95       	ror	r30
    4ed6:	9f 5f       	subi	r25, 0xFF	; 255
    4ed8:	c1 f7       	brne	.-16     	; 0x4eca <__mulsf3_pse+0x8c>
    4eda:	fe 2b       	or	r31, r30
    4edc:	88 0f       	add	r24, r24
    4ede:	91 1d       	adc	r25, r1
    4ee0:	96 95       	lsr	r25
    4ee2:	87 95       	ror	r24
    4ee4:	97 f9       	bld	r25, 7
    4ee6:	08 95       	ret

00004ee8 <__udivmodhi4>:
    4ee8:	aa 1b       	sub	r26, r26
    4eea:	bb 1b       	sub	r27, r27
    4eec:	51 e1       	ldi	r21, 0x11	; 17
    4eee:	07 c0       	rjmp	.+14     	; 0x4efe <__udivmodhi4_ep>

00004ef0 <__udivmodhi4_loop>:
    4ef0:	aa 1f       	adc	r26, r26
    4ef2:	bb 1f       	adc	r27, r27
    4ef4:	a6 17       	cp	r26, r22
    4ef6:	b7 07       	cpc	r27, r23
    4ef8:	10 f0       	brcs	.+4      	; 0x4efe <__udivmodhi4_ep>
    4efa:	a6 1b       	sub	r26, r22
    4efc:	b7 0b       	sbc	r27, r23

00004efe <__udivmodhi4_ep>:
    4efe:	88 1f       	adc	r24, r24
    4f00:	99 1f       	adc	r25, r25
    4f02:	5a 95       	dec	r21
    4f04:	a9 f7       	brne	.-22     	; 0x4ef0 <__udivmodhi4_loop>
    4f06:	80 95       	com	r24
    4f08:	90 95       	com	r25
    4f0a:	bc 01       	movw	r22, r24
    4f0c:	cd 01       	movw	r24, r26
    4f0e:	08 95       	ret

00004f10 <__divmodhi4>:
    4f10:	97 fb       	bst	r25, 7
    4f12:	09 2e       	mov	r0, r25
    4f14:	07 26       	eor	r0, r23
    4f16:	0a d0       	rcall	.+20     	; 0x4f2c <__divmodhi4_neg1>
    4f18:	77 fd       	sbrc	r23, 7
    4f1a:	04 d0       	rcall	.+8      	; 0x4f24 <__divmodhi4_neg2>
    4f1c:	e5 df       	rcall	.-54     	; 0x4ee8 <__udivmodhi4>
    4f1e:	06 d0       	rcall	.+12     	; 0x4f2c <__divmodhi4_neg1>
    4f20:	00 20       	and	r0, r0
    4f22:	1a f4       	brpl	.+6      	; 0x4f2a <__divmodhi4_exit>

00004f24 <__divmodhi4_neg2>:
    4f24:	70 95       	com	r23
    4f26:	61 95       	neg	r22
    4f28:	7f 4f       	sbci	r23, 0xFF	; 255

00004f2a <__divmodhi4_exit>:
    4f2a:	08 95       	ret

00004f2c <__divmodhi4_neg1>:
    4f2c:	f6 f7       	brtc	.-4      	; 0x4f2a <__divmodhi4_exit>
    4f2e:	90 95       	com	r25
    4f30:	81 95       	neg	r24
    4f32:	9f 4f       	sbci	r25, 0xFF	; 255
    4f34:	08 95       	ret

00004f36 <__udivmodsi4>:
    4f36:	a1 e2       	ldi	r26, 0x21	; 33
    4f38:	1a 2e       	mov	r1, r26
    4f3a:	aa 1b       	sub	r26, r26
    4f3c:	bb 1b       	sub	r27, r27
    4f3e:	fd 01       	movw	r30, r26
    4f40:	0d c0       	rjmp	.+26     	; 0x4f5c <__udivmodsi4_ep>

00004f42 <__udivmodsi4_loop>:
    4f42:	aa 1f       	adc	r26, r26
    4f44:	bb 1f       	adc	r27, r27
    4f46:	ee 1f       	adc	r30, r30
    4f48:	ff 1f       	adc	r31, r31
    4f4a:	a2 17       	cp	r26, r18
    4f4c:	b3 07       	cpc	r27, r19
    4f4e:	e4 07       	cpc	r30, r20
    4f50:	f5 07       	cpc	r31, r21
    4f52:	20 f0       	brcs	.+8      	; 0x4f5c <__udivmodsi4_ep>
    4f54:	a2 1b       	sub	r26, r18
    4f56:	b3 0b       	sbc	r27, r19
    4f58:	e4 0b       	sbc	r30, r20
    4f5a:	f5 0b       	sbc	r31, r21

00004f5c <__udivmodsi4_ep>:
    4f5c:	66 1f       	adc	r22, r22
    4f5e:	77 1f       	adc	r23, r23
    4f60:	88 1f       	adc	r24, r24
    4f62:	99 1f       	adc	r25, r25
    4f64:	1a 94       	dec	r1
    4f66:	69 f7       	brne	.-38     	; 0x4f42 <__udivmodsi4_loop>
    4f68:	60 95       	com	r22
    4f6a:	70 95       	com	r23
    4f6c:	80 95       	com	r24
    4f6e:	90 95       	com	r25
    4f70:	9b 01       	movw	r18, r22
    4f72:	ac 01       	movw	r20, r24
    4f74:	bd 01       	movw	r22, r26
    4f76:	cf 01       	movw	r24, r30
    4f78:	08 95       	ret

00004f7a <__divmodsi4>:
    4f7a:	97 fb       	bst	r25, 7
    4f7c:	09 2e       	mov	r0, r25
    4f7e:	05 26       	eor	r0, r21
    4f80:	0e d0       	rcall	.+28     	; 0x4f9e <__divmodsi4_neg1>
    4f82:	57 fd       	sbrc	r21, 7
    4f84:	04 d0       	rcall	.+8      	; 0x4f8e <__divmodsi4_neg2>
    4f86:	d7 df       	rcall	.-82     	; 0x4f36 <__udivmodsi4>
    4f88:	0a d0       	rcall	.+20     	; 0x4f9e <__divmodsi4_neg1>
    4f8a:	00 1c       	adc	r0, r0
    4f8c:	38 f4       	brcc	.+14     	; 0x4f9c <__divmodsi4_exit>

00004f8e <__divmodsi4_neg2>:
    4f8e:	50 95       	com	r21
    4f90:	40 95       	com	r20
    4f92:	30 95       	com	r19
    4f94:	21 95       	neg	r18
    4f96:	3f 4f       	sbci	r19, 0xFF	; 255
    4f98:	4f 4f       	sbci	r20, 0xFF	; 255
    4f9a:	5f 4f       	sbci	r21, 0xFF	; 255

00004f9c <__divmodsi4_exit>:
    4f9c:	08 95       	ret

00004f9e <__divmodsi4_neg1>:
    4f9e:	f6 f7       	brtc	.-4      	; 0x4f9c <__divmodsi4_exit>
    4fa0:	90 95       	com	r25
    4fa2:	80 95       	com	r24
    4fa4:	70 95       	com	r23
    4fa6:	61 95       	neg	r22
    4fa8:	7f 4f       	sbci	r23, 0xFF	; 255
    4faa:	8f 4f       	sbci	r24, 0xFF	; 255
    4fac:	9f 4f       	sbci	r25, 0xFF	; 255
    4fae:	08 95       	ret

00004fb0 <_exit>:
    4fb0:	f8 94       	cli

00004fb2 <__stop_program>:
    4fb2:	ff cf       	rjmp	.-2      	; 0x4fb2 <__stop_program>

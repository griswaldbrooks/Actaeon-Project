
lbRTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000098  00800200  00005080  00005114  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00005080  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000015d7  00800298  00800298  000051ac  2**0
                  ALLOC
  3 .debug_aranges 000001a0  00000000  00000000  000051ac  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000016ac  00000000  00000000  0000534c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000542f  00000000  00000000  000069f8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000016eb  00000000  00000000  0000be27  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000043ad  00000000  00000000  0000d512  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00001140  00000000  00000000  000118c0  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000022cf  00000000  00000000  00012a00  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000294a  00000000  00000000  00014ccf  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000048  00000000  00000000  00017619  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 d0 00 	jmp	0x1a0	; 0x1a0 <__ctors_end>
       4:	0c 94 ed 00 	jmp	0x1da	; 0x1da <__bad_interrupt>
       8:	0c 94 ed 00 	jmp	0x1da	; 0x1da <__bad_interrupt>
       c:	0c 94 ed 00 	jmp	0x1da	; 0x1da <__bad_interrupt>
      10:	0c 94 ed 00 	jmp	0x1da	; 0x1da <__bad_interrupt>
      14:	0c 94 ed 00 	jmp	0x1da	; 0x1da <__bad_interrupt>
      18:	0c 94 ed 00 	jmp	0x1da	; 0x1da <__bad_interrupt>
      1c:	0c 94 ed 00 	jmp	0x1da	; 0x1da <__bad_interrupt>
      20:	0c 94 ed 00 	jmp	0x1da	; 0x1da <__bad_interrupt>
      24:	0c 94 ed 00 	jmp	0x1da	; 0x1da <__bad_interrupt>
      28:	0c 94 ed 00 	jmp	0x1da	; 0x1da <__bad_interrupt>
      2c:	0c 94 ed 00 	jmp	0x1da	; 0x1da <__bad_interrupt>
      30:	0c 94 ed 00 	jmp	0x1da	; 0x1da <__bad_interrupt>
      34:	0c 94 4b 18 	jmp	0x3096	; 0x3096 <__vector_13>
      38:	0c 94 78 18 	jmp	0x30f0	; 0x30f0 <__vector_14>
      3c:	0c 94 6a 16 	jmp	0x2cd4	; 0x2cd4 <__vector_15>
      40:	0c 94 c4 17 	jmp	0x2f88	; 0x2f88 <__vector_16>
      44:	0c 94 98 11 	jmp	0x2330	; 0x2330 <__vector_17>
      48:	0c 94 f1 17 	jmp	0x2fe2	; 0x2fe2 <__vector_18>
      4c:	0c 94 1e 18 	jmp	0x303c	; 0x303c <__vector_19>
      50:	0c 94 2a 16 	jmp	0x2c54	; 0x2c54 <__vector_20>
      54:	0c 94 6a 17 	jmp	0x2ed4	; 0x2ed4 <__vector_21>
      58:	0c 94 97 17 	jmp	0x2f2e	; 0x2f2e <__vector_22>
      5c:	0c 94 d7 15 	jmp	0x2bae	; 0x2bae <__vector_23>
      60:	0c 94 ed 00 	jmp	0x1da	; 0x1da <__bad_interrupt>
      64:	0c 94 41 1c 	jmp	0x3882	; 0x3882 <__vector_25>
      68:	0c 94 ed 00 	jmp	0x1da	; 0x1da <__bad_interrupt>
      6c:	0c 94 9e 1d 	jmp	0x3b3c	; 0x3b3c <__vector_27>
      70:	0c 94 ed 00 	jmp	0x1da	; 0x1da <__bad_interrupt>
      74:	0c 94 58 20 	jmp	0x40b0	; 0x40b0 <__vector_29>
      78:	0c 94 ed 00 	jmp	0x1da	; 0x1da <__bad_interrupt>
      7c:	0c 94 a5 18 	jmp	0x314a	; 0x314a <__vector_31>
      80:	0c 94 d2 18 	jmp	0x31a4	; 0x31a4 <__vector_32>
      84:	0c 94 ff 18 	jmp	0x31fe	; 0x31fe <__vector_33>
      88:	0c 94 2c 19 	jmp	0x3258	; 0x3258 <__vector_34>
      8c:	0c 94 aa 16 	jmp	0x2d54	; 0x2d54 <__vector_35>
      90:	0c 94 1c 1c 	jmp	0x3838	; 0x3838 <__vector_36>
      94:	0c 94 ed 00 	jmp	0x1da	; 0x1da <__bad_interrupt>
      98:	0c 94 79 1d 	jmp	0x3af2	; 0x3af2 <__vector_38>
      9c:	0c 94 76 24 	jmp	0x48ec	; 0x48ec <__vector_39>
      a0:	0c 94 ed 00 	jmp	0x1da	; 0x1da <__bad_interrupt>
      a4:	0c 94 59 19 	jmp	0x32b2	; 0x32b2 <__vector_41>
      a8:	0c 94 86 19 	jmp	0x330c	; 0x330c <__vector_42>
      ac:	0c 94 b3 19 	jmp	0x3366	; 0x3366 <__vector_43>
      b0:	0c 94 e0 19 	jmp	0x33c0	; 0x33c0 <__vector_44>
      b4:	0c 94 ea 16 	jmp	0x2dd4	; 0x2dd4 <__vector_45>
      b8:	0c 94 0d 1a 	jmp	0x341a	; 0x341a <__vector_46>
      bc:	0c 94 3a 1a 	jmp	0x3474	; 0x3474 <__vector_47>
      c0:	0c 94 67 1a 	jmp	0x34ce	; 0x34ce <__vector_48>
      c4:	0c 94 94 1a 	jmp	0x3528	; 0x3528 <__vector_49>
      c8:	0c 94 2a 17 	jmp	0x2e54	; 0x2e54 <__vector_50>
      cc:	0c 94 f7 1b 	jmp	0x37ee	; 0x37ee <__vector_51>
      d0:	0c 94 ed 00 	jmp	0x1da	; 0x1da <__bad_interrupt>
      d4:	0c 94 54 1d 	jmp	0x3aa8	; 0x3aa8 <__vector_53>
      d8:	0c 94 d2 1b 	jmp	0x37a4	; 0x37a4 <__vector_54>
      dc:	0c 94 ed 00 	jmp	0x1da	; 0x1da <__bad_interrupt>
      e0:	0c 94 2f 1d 	jmp	0x3a5e	; 0x3a5e <__vector_56>

000000e4 <__c.2939>:
      e4:	50 72 6f 67 72 61 6d 20 74 65 72 6d 69 6e 61 74     Program terminat
      f4:	65 64 2e 00                                         ed..

000000f8 <__c.2928>:
      f8:	53 74 61 72 74 69 6e 67 20 70 72 6f 67 72 61 6d     Starting program
     108:	2e 0a 00                                            ...

0000010b <__c.2915>:
     10b:	20 00                                                .

0000010d <__c.2912>:
     10d:	20 44 69 73 74 61 6e 63 65 73 3a 20 00               Distances: .

0000011a <__c.2910>:
     11a:	20 4d 6f 74 6f 72 20 53 70 65 65 64 3a 20 00         Motor Speed: .

00000129 <__c.2908>:
     129:	49 6e 64 65 78 3a 20 00                             Index: .

00000131 <__c.2873>:
     131:	49 6e 69 74 69 61 6c 69 7a 61 74 69 6f 6e 20 43     Initialization C
     141:	6f 6d 70 6c 65 74 65 20 0d 0a 00                    omplete ...

0000014c <__c.2868>:
     14c:	2e 00                                               ..

0000014e <__c.2866>:
     14e:	0d 0a 53 79 73 74 65 6d 20 57 61 72 6d 65 64 20     ..System Warmed 
     15e:	55 70 00                                            Up.

00000161 <TimerPrescaleFactor>:
     161:	00 00 01 00 08 00 40 00 00 01 00 04                 ......@.....

0000016d <Timer2PrescaleFactor>:
     16d:	00 00 01 00 08 00 20 00 40 00 80 00 00 01 00 04     ...... .@.......

0000017d <__c.1991>:
     17d:	42 41 44 5f 76 65 63 74 20 63 61 6c 6c 65 64 21     BAD_vect called!
	...

0000018e <HexChars>:
     18e:	30 31 32 33 34 35 36 37 38 39 41 42 43 44 45 46     0123456789ABCDEF
	...

000001a0 <__ctors_end>:
     1a0:	11 24       	eor	r1, r1
     1a2:	1f be       	out	0x3f, r1	; 63
     1a4:	cf ef       	ldi	r28, 0xFF	; 255
     1a6:	d1 e2       	ldi	r29, 0x21	; 33
     1a8:	de bf       	out	0x3e, r29	; 62
     1aa:	cd bf       	out	0x3d, r28	; 61

000001ac <__do_copy_data>:
     1ac:	12 e0       	ldi	r17, 0x02	; 2
     1ae:	a0 e0       	ldi	r26, 0x00	; 0
     1b0:	b2 e0       	ldi	r27, 0x02	; 2
     1b2:	e0 e8       	ldi	r30, 0x80	; 128
     1b4:	f0 e5       	ldi	r31, 0x50	; 80
     1b6:	02 c0       	rjmp	.+4      	; 0x1bc <.do_copy_data_start>

000001b8 <.do_copy_data_loop>:
     1b8:	05 90       	lpm	r0, Z+
     1ba:	0d 92       	st	X+, r0

000001bc <.do_copy_data_start>:
     1bc:	a8 39       	cpi	r26, 0x98	; 152
     1be:	b1 07       	cpc	r27, r17
     1c0:	d9 f7       	brne	.-10     	; 0x1b8 <.do_copy_data_loop>

000001c2 <__do_clear_bss>:
     1c2:	18 e1       	ldi	r17, 0x18	; 24
     1c4:	a8 e9       	ldi	r26, 0x98	; 152
     1c6:	b2 e0       	ldi	r27, 0x02	; 2
     1c8:	01 c0       	rjmp	.+2      	; 0x1cc <.do_clear_bss_start>

000001ca <.do_clear_bss_loop>:
     1ca:	1d 92       	st	X+, r1

000001cc <.do_clear_bss_start>:
     1cc:	af 36       	cpi	r26, 0x6F	; 111
     1ce:	b1 07       	cpc	r27, r17
     1d0:	e1 f7       	brne	.-8      	; 0x1ca <.do_clear_bss_loop>
     1d2:	0e 94 22 08 	call	0x1044	; 0x1044 <main>
     1d6:	0c 94 a2 25 	jmp	0x4b44	; 0x4b44 <exit>

000001da <__bad_interrupt>:
     1da:	0c 94 c1 1a 	jmp	0x3582	; 0x3582 <__vector_default>

000001de <PWM_Init_timer1_LED>:

//OC1B  pin B6 (attached to green LED)
void PWM_Init_timer1_LED(u08 bitRes)
{
	// enable timer2 as 8,9,10bit PWM
	if(bitRes == 9)
     1de:	89 30       	cpi	r24, 0x09	; 9
     1e0:	49 f4       	brne	.+18     	; 0x1f4 <PWM_Init_timer1_LED+0x16>
	{	// 9bit mode
		sbi(TCCR1A,PWM11);
     1e2:	80 91 80 00 	lds	r24, 0x0080
     1e6:	82 60       	ori	r24, 0x02	; 2
     1e8:	80 93 80 00 	sts	0x0080, r24
		cbi(TCCR1A,PWM10);
     1ec:	80 91 80 00 	lds	r24, 0x0080
     1f0:	8e 7f       	andi	r24, 0xFE	; 254
     1f2:	0e c0       	rjmp	.+28     	; 0x210 <PWM_Init_timer1_LED+0x32>
	}
	else if( bitRes == 10 )
     1f4:	8a 30       	cpi	r24, 0x0A	; 10
     1f6:	21 f4       	brne	.+8      	; 0x200 <PWM_Init_timer1_LED+0x22>
	{	// 10bit mode
		sbi(TCCR1A,PWM11);
     1f8:	80 91 80 00 	lds	r24, 0x0080
     1fc:	82 60       	ori	r24, 0x02	; 2
     1fe:	03 c0       	rjmp	.+6      	; 0x206 <PWM_Init_timer1_LED+0x28>
		sbi(TCCR1A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR1A,PWM11);
     200:	80 91 80 00 	lds	r24, 0x0080
     204:	8d 7f       	andi	r24, 0xFD	; 253
     206:	80 93 80 00 	sts	0x0080, r24
		sbi(TCCR1A,PWM10);
     20a:	80 91 80 00 	lds	r24, 0x0080
     20e:	81 60       	ori	r24, 0x01	; 1
     210:	80 93 80 00 	sts	0x0080, r24
	}
	// clear output compare values
	OCR1B = 0;
     214:	10 92 8b 00 	sts	0x008B, r1
     218:	10 92 8a 00 	sts	0x008A, r1
}
     21c:	08 95       	ret

0000021e <PWM_Init_timer2_H6>:
//pin H6, timer2
void PWM_Init_timer2_H6(u08 bitRes)
{
	// enable timer2 as 8,9,10bit PWM
	if(bitRes == 9)
     21e:	89 30       	cpi	r24, 0x09	; 9
     220:	49 f4       	brne	.+18     	; 0x234 <PWM_Init_timer2_H6+0x16>
	{	// 9bit mode
		sbi(TCCR2A,PWM11);
     222:	80 91 b0 00 	lds	r24, 0x00B0
     226:	82 60       	ori	r24, 0x02	; 2
     228:	80 93 b0 00 	sts	0x00B0, r24
		cbi(TCCR2A,PWM10);
     22c:	80 91 b0 00 	lds	r24, 0x00B0
     230:	8e 7f       	andi	r24, 0xFE	; 254
     232:	0e c0       	rjmp	.+28     	; 0x250 <PWM_Init_timer2_H6+0x32>
	}
	else if( bitRes == 10 )
     234:	8a 30       	cpi	r24, 0x0A	; 10
     236:	21 f4       	brne	.+8      	; 0x240 <PWM_Init_timer2_H6+0x22>
	{	// 10bit mode
		sbi(TCCR2A,PWM11);
     238:	80 91 b0 00 	lds	r24, 0x00B0
     23c:	82 60       	ori	r24, 0x02	; 2
     23e:	03 c0       	rjmp	.+6      	; 0x246 <PWM_Init_timer2_H6+0x28>
		sbi(TCCR2A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR2A,PWM11);
     240:	80 91 b0 00 	lds	r24, 0x00B0
     244:	8d 7f       	andi	r24, 0xFD	; 253
     246:	80 93 b0 00 	sts	0x00B0, r24
		sbi(TCCR2A,PWM10);
     24a:	80 91 b0 00 	lds	r24, 0x00B0
     24e:	81 60       	ori	r24, 0x01	; 1
     250:	80 93 b0 00 	sts	0x00B0, r24
	}
	// clear output compare values
	OCR2B = 0;
     254:	10 92 b4 00 	sts	0x00B4, r1
}
     258:	08 95       	ret

0000025a <PWM_Init_timer3_E3>:
//pin E3
void PWM_Init_timer3_E3(u08 bitRes)
{
	// enable timer3 as 8,9,10bit PWM
	if(bitRes == 9)
     25a:	89 30       	cpi	r24, 0x09	; 9
     25c:	49 f4       	brne	.+18     	; 0x270 <PWM_Init_timer3_E3+0x16>
	{	// 9bit mode
		sbi(TCCR3A,PWM11);
     25e:	80 91 90 00 	lds	r24, 0x0090
     262:	82 60       	ori	r24, 0x02	; 2
     264:	80 93 90 00 	sts	0x0090, r24
		cbi(TCCR3A,PWM10);
     268:	80 91 90 00 	lds	r24, 0x0090
     26c:	8e 7f       	andi	r24, 0xFE	; 254
     26e:	0e c0       	rjmp	.+28     	; 0x28c <PWM_Init_timer3_E3+0x32>
	}
	else if( bitRes == 10 )
     270:	8a 30       	cpi	r24, 0x0A	; 10
     272:	21 f4       	brne	.+8      	; 0x27c <PWM_Init_timer3_E3+0x22>
	{	// 10bit mode
		sbi(TCCR3A,PWM11);
     274:	80 91 90 00 	lds	r24, 0x0090
     278:	82 60       	ori	r24, 0x02	; 2
     27a:	03 c0       	rjmp	.+6      	; 0x282 <PWM_Init_timer3_E3+0x28>
		sbi(TCCR3A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR3A,PWM11);
     27c:	80 91 90 00 	lds	r24, 0x0090
     280:	8d 7f       	andi	r24, 0xFD	; 253
     282:	80 93 90 00 	sts	0x0090, r24
		sbi(TCCR3A,PWM10);
     286:	80 91 90 00 	lds	r24, 0x0090
     28a:	81 60       	ori	r24, 0x01	; 1
     28c:	80 93 90 00 	sts	0x0090, r24
	}
	// clear output compare values
	OCR3A = 0;
     290:	10 92 99 00 	sts	0x0099, r1
     294:	10 92 98 00 	sts	0x0098, r1
	//timer3PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     298:	08 95       	ret

0000029a <PWM_Init_timer3_E4>:
//pin E4
void PWM_Init_timer3_E4(u08 bitRes)
{
	// enable timer3 as 8,9,10bit PWM
	if(bitRes == 9)
     29a:	89 30       	cpi	r24, 0x09	; 9
     29c:	49 f4       	brne	.+18     	; 0x2b0 <PWM_Init_timer3_E4+0x16>
	{	// 9bit mode
		sbi(TCCR3B,PWM11);
     29e:	80 91 91 00 	lds	r24, 0x0091
     2a2:	82 60       	ori	r24, 0x02	; 2
     2a4:	80 93 91 00 	sts	0x0091, r24
		cbi(TCCR3B,PWM10);
     2a8:	80 91 91 00 	lds	r24, 0x0091
     2ac:	8e 7f       	andi	r24, 0xFE	; 254
     2ae:	0e c0       	rjmp	.+28     	; 0x2cc <PWM_Init_timer3_E4+0x32>
	}
	else if( bitRes == 10 )
     2b0:	8a 30       	cpi	r24, 0x0A	; 10
     2b2:	21 f4       	brne	.+8      	; 0x2bc <PWM_Init_timer3_E4+0x22>
	{	// 10bit mode
		sbi(TCCR3B,PWM11);
     2b4:	80 91 91 00 	lds	r24, 0x0091
     2b8:	82 60       	ori	r24, 0x02	; 2
     2ba:	03 c0       	rjmp	.+6      	; 0x2c2 <PWM_Init_timer3_E4+0x28>
		sbi(TCCR3B,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR3B,PWM11);
     2bc:	80 91 91 00 	lds	r24, 0x0091
     2c0:	8d 7f       	andi	r24, 0xFD	; 253
     2c2:	80 93 91 00 	sts	0x0091, r24
		sbi(TCCR3B,PWM10);
     2c6:	80 91 91 00 	lds	r24, 0x0091
     2ca:	81 60       	ori	r24, 0x01	; 1
     2cc:	80 93 91 00 	sts	0x0091, r24
	}
	// clear output compare values
	OCR3B = 0;
     2d0:	10 92 9b 00 	sts	0x009B, r1
     2d4:	10 92 9a 00 	sts	0x009A, r1
	//timer3PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     2d8:	08 95       	ret

000002da <PWM_Init_timer3_E5>:
//pin E5
void PWM_Init_timer3_E5(u08 bitRes)
{
	// enable timer3 as 8,9,10bit PWM
	if(bitRes == 9)
     2da:	89 30       	cpi	r24, 0x09	; 9
     2dc:	49 f4       	brne	.+18     	; 0x2f0 <PWM_Init_timer3_E5+0x16>
	{	// 9bit mode
		sbi(TCCR3C,PWM11);
     2de:	80 91 92 00 	lds	r24, 0x0092
     2e2:	82 60       	ori	r24, 0x02	; 2
     2e4:	80 93 92 00 	sts	0x0092, r24
		cbi(TCCR3C,PWM10);
     2e8:	80 91 92 00 	lds	r24, 0x0092
     2ec:	8e 7f       	andi	r24, 0xFE	; 254
     2ee:	0e c0       	rjmp	.+28     	; 0x30c <PWM_Init_timer3_E5+0x32>
	}
	else if( bitRes == 10 )
     2f0:	8a 30       	cpi	r24, 0x0A	; 10
     2f2:	21 f4       	brne	.+8      	; 0x2fc <PWM_Init_timer3_E5+0x22>
	{	// 10bit mode
		sbi(TCCR3C,PWM11);
     2f4:	80 91 92 00 	lds	r24, 0x0092
     2f8:	82 60       	ori	r24, 0x02	; 2
     2fa:	03 c0       	rjmp	.+6      	; 0x302 <PWM_Init_timer3_E5+0x28>
		sbi(TCCR3C,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR3C,PWM11);
     2fc:	80 91 92 00 	lds	r24, 0x0092
     300:	8d 7f       	andi	r24, 0xFD	; 253
     302:	80 93 92 00 	sts	0x0092, r24
		sbi(TCCR3C,PWM10);
     306:	80 91 92 00 	lds	r24, 0x0092
     30a:	81 60       	ori	r24, 0x01	; 1
     30c:	80 93 92 00 	sts	0x0092, r24
	}
	// clear output compare values
	OCR3C = 0;
     310:	10 92 9d 00 	sts	0x009D, r1
     314:	10 92 9c 00 	sts	0x009C, r1
	//timer3PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     318:	08 95       	ret

0000031a <PWM_Init_timer4_H3>:
//pin H3, timer4
void PWM_Init_timer4_H3(u08 bitRes)
{
	// enable timer4 as 8,9,10bit PWM
	if(bitRes == 9)
     31a:	89 30       	cpi	r24, 0x09	; 9
     31c:	49 f4       	brne	.+18     	; 0x330 <PWM_Init_timer4_H3+0x16>
	{	// 9bit mode
		sbi(TCCR4A,PWM11);
     31e:	80 91 a0 00 	lds	r24, 0x00A0
     322:	82 60       	ori	r24, 0x02	; 2
     324:	80 93 a0 00 	sts	0x00A0, r24
		cbi(TCCR4A,PWM10);
     328:	80 91 a0 00 	lds	r24, 0x00A0
     32c:	8e 7f       	andi	r24, 0xFE	; 254
     32e:	0e c0       	rjmp	.+28     	; 0x34c <PWM_Init_timer4_H3+0x32>
	}
	else if( bitRes == 10 )
     330:	8a 30       	cpi	r24, 0x0A	; 10
     332:	21 f4       	brne	.+8      	; 0x33c <PWM_Init_timer4_H3+0x22>
	{	// 10bit mode
		sbi(TCCR4A,PWM11);
     334:	80 91 a0 00 	lds	r24, 0x00A0
     338:	82 60       	ori	r24, 0x02	; 2
     33a:	03 c0       	rjmp	.+6      	; 0x342 <PWM_Init_timer4_H3+0x28>
		sbi(TCCR4A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR4A,PWM11);
     33c:	80 91 a0 00 	lds	r24, 0x00A0
     340:	8d 7f       	andi	r24, 0xFD	; 253
     342:	80 93 a0 00 	sts	0x00A0, r24
		sbi(TCCR4A,PWM10);
     346:	80 91 a0 00 	lds	r24, 0x00A0
     34a:	81 60       	ori	r24, 0x01	; 1
     34c:	80 93 a0 00 	sts	0x00A0, r24
	}
	// clear output compare values
	OCR4A = 0;
     350:	10 92 a9 00 	sts	0x00A9, r1
     354:	10 92 a8 00 	sts	0x00A8, r1
	//timer4PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     358:	08 95       	ret

0000035a <PWM_Init_timer4_H4>:
//pin H4, timer4
void PWM_Init_timer4_H4(u08 bitRes)
{
	// enable timer4 as 8,9,10bit PWM
	if(bitRes == 9)
     35a:	89 30       	cpi	r24, 0x09	; 9
     35c:	49 f4       	brne	.+18     	; 0x370 <PWM_Init_timer4_H4+0x16>
	{	// 9bit mode
		sbi(TCCR4B,PWM11);
     35e:	80 91 a1 00 	lds	r24, 0x00A1
     362:	82 60       	ori	r24, 0x02	; 2
     364:	80 93 a1 00 	sts	0x00A1, r24
		cbi(TCCR4B,PWM10);
     368:	80 91 a1 00 	lds	r24, 0x00A1
     36c:	8e 7f       	andi	r24, 0xFE	; 254
     36e:	0e c0       	rjmp	.+28     	; 0x38c <PWM_Init_timer4_H4+0x32>
	}
	else if( bitRes == 10 )
     370:	8a 30       	cpi	r24, 0x0A	; 10
     372:	21 f4       	brne	.+8      	; 0x37c <PWM_Init_timer4_H4+0x22>
	{	// 10bit mode
		sbi(TCCR4B,PWM11);
     374:	80 91 a1 00 	lds	r24, 0x00A1
     378:	82 60       	ori	r24, 0x02	; 2
     37a:	03 c0       	rjmp	.+6      	; 0x382 <PWM_Init_timer4_H4+0x28>
		sbi(TCCR4B,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR4B,PWM11);
     37c:	80 91 a1 00 	lds	r24, 0x00A1
     380:	8d 7f       	andi	r24, 0xFD	; 253
     382:	80 93 a1 00 	sts	0x00A1, r24
		sbi(TCCR4B,PWM10);
     386:	80 91 a1 00 	lds	r24, 0x00A1
     38a:	81 60       	ori	r24, 0x01	; 1
     38c:	80 93 a1 00 	sts	0x00A1, r24
	}
	// clear output compare values
	OCR4B = 0;
     390:	10 92 ab 00 	sts	0x00AB, r1
     394:	10 92 aa 00 	sts	0x00AA, r1
	//timer4PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     398:	08 95       	ret

0000039a <PWM_Init_timer4_H5>:
//pin H5, timer4
void PWM_Init_timer4_H5(u08 bitRes)
{
	// enable timer4 as 8,9,10bit PWM
	if(bitRes == 9)
     39a:	89 30       	cpi	r24, 0x09	; 9
     39c:	49 f4       	brne	.+18     	; 0x3b0 <PWM_Init_timer4_H5+0x16>
	{	// 9bit mode
		sbi(TCCR4A,PWM11);
     39e:	80 91 a0 00 	lds	r24, 0x00A0
     3a2:	82 60       	ori	r24, 0x02	; 2
     3a4:	80 93 a0 00 	sts	0x00A0, r24
		cbi(TCCR4A,PWM10);
     3a8:	80 91 a0 00 	lds	r24, 0x00A0
     3ac:	8e 7f       	andi	r24, 0xFE	; 254
     3ae:	0e c0       	rjmp	.+28     	; 0x3cc <PWM_Init_timer4_H5+0x32>
	}
	else if( bitRes == 10 )
     3b0:	8a 30       	cpi	r24, 0x0A	; 10
     3b2:	21 f4       	brne	.+8      	; 0x3bc <PWM_Init_timer4_H5+0x22>
	{	// 10bit mode
		sbi(TCCR4A,PWM11);
     3b4:	80 91 a0 00 	lds	r24, 0x00A0
     3b8:	82 60       	ori	r24, 0x02	; 2
     3ba:	03 c0       	rjmp	.+6      	; 0x3c2 <PWM_Init_timer4_H5+0x28>
		sbi(TCCR4A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR4A,PWM11);
     3bc:	80 91 a0 00 	lds	r24, 0x00A0
     3c0:	8d 7f       	andi	r24, 0xFD	; 253
     3c2:	80 93 a0 00 	sts	0x00A0, r24
		sbi(TCCR4A,PWM10);
     3c6:	80 91 a0 00 	lds	r24, 0x00A0
     3ca:	81 60       	ori	r24, 0x01	; 1
     3cc:	80 93 a0 00 	sts	0x00A0, r24
	}
	// clear output compare values
	OCR4C = 0;
     3d0:	10 92 ad 00 	sts	0x00AD, r1
     3d4:	10 92 ac 00 	sts	0x00AC, r1
	//timer4PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     3d8:	08 95       	ret

000003da <timer1PWMInitICR>:
// include support for arbitrary top-count PWM
// on new AVR processors that support it
void timer1PWMInitICR(u16 topcount)
{
	// set PWM mode with ICR top-count
	cbi(TCCR1A,WGM10);
     3da:	e0 e8       	ldi	r30, 0x80	; 128
     3dc:	f0 e0       	ldi	r31, 0x00	; 0
     3de:	20 81       	ld	r18, Z
     3e0:	2e 7f       	andi	r18, 0xFE	; 254
     3e2:	20 83       	st	Z, r18
	sbi(TCCR1A,WGM11);
     3e4:	20 81       	ld	r18, Z
     3e6:	22 60       	ori	r18, 0x02	; 2
     3e8:	20 83       	st	Z, r18
	sbi(TCCR1B,WGM12);
     3ea:	e1 e8       	ldi	r30, 0x81	; 129
     3ec:	f0 e0       	ldi	r31, 0x00	; 0
     3ee:	20 81       	ld	r18, Z
     3f0:	28 60       	ori	r18, 0x08	; 8
     3f2:	20 83       	st	Z, r18
	sbi(TCCR1B,WGM13);
     3f4:	20 81       	ld	r18, Z
     3f6:	20 61       	ori	r18, 0x10	; 16
     3f8:	20 83       	st	Z, r18
	
	// set top count value
	ICR1 = topcount;
     3fa:	90 93 87 00 	sts	0x0087, r25
     3fe:	80 93 86 00 	sts	0x0086, r24
	
	// clear output compare values
	OCR1A = 0;
     402:	10 92 89 00 	sts	0x0089, r1
     406:	10 92 88 00 	sts	0x0088, r1
	OCR1B = 0;
     40a:	10 92 8b 00 	sts	0x008B, r1
     40e:	10 92 8a 00 	sts	0x008A, r1
	OCR1C = 0;
     412:	10 92 8d 00 	sts	0x008D, r1
     416:	10 92 8c 00 	sts	0x008C, r1
}
     41a:	08 95       	ret

0000041c <timer3PWMInitICR>:
void timer3PWMInitICR(u16 topcount)
{
	// set PWM mode with ICR top-count
	cbi(TCCR3A,WGM10);
     41c:	e0 e9       	ldi	r30, 0x90	; 144
     41e:	f0 e0       	ldi	r31, 0x00	; 0
     420:	20 81       	ld	r18, Z
     422:	2e 7f       	andi	r18, 0xFE	; 254
     424:	20 83       	st	Z, r18
	sbi(TCCR3A,WGM11);
     426:	20 81       	ld	r18, Z
     428:	22 60       	ori	r18, 0x02	; 2
     42a:	20 83       	st	Z, r18
	sbi(TCCR3B,WGM12);
     42c:	e1 e9       	ldi	r30, 0x91	; 145
     42e:	f0 e0       	ldi	r31, 0x00	; 0
     430:	20 81       	ld	r18, Z
     432:	28 60       	ori	r18, 0x08	; 8
     434:	20 83       	st	Z, r18
	sbi(TCCR3B,WGM13);
     436:	20 81       	ld	r18, Z
     438:	20 61       	ori	r18, 0x10	; 16
     43a:	20 83       	st	Z, r18
	
	// set top count value
	ICR3 = topcount;
     43c:	90 93 97 00 	sts	0x0097, r25
     440:	80 93 96 00 	sts	0x0096, r24
	
	// clear output compare values
	OCR3A = 0;
     444:	10 92 99 00 	sts	0x0099, r1
     448:	10 92 98 00 	sts	0x0098, r1
	OCR3B = 0;
     44c:	10 92 9b 00 	sts	0x009B, r1
     450:	10 92 9a 00 	sts	0x009A, r1
	OCR3C = 0;
     454:	10 92 9d 00 	sts	0x009D, r1
     458:	10 92 9c 00 	sts	0x009C, r1
}
     45c:	08 95       	ret

0000045e <timer4PWMInitICR>:
void timer4PWMInitICR(u16 topcount)
{
	// set PWM mode with ICR top-count
	cbi(TCCR4A,WGM10);
     45e:	e0 ea       	ldi	r30, 0xA0	; 160
     460:	f0 e0       	ldi	r31, 0x00	; 0
     462:	20 81       	ld	r18, Z
     464:	2e 7f       	andi	r18, 0xFE	; 254
     466:	20 83       	st	Z, r18
	sbi(TCCR4A,WGM11);
     468:	20 81       	ld	r18, Z
     46a:	22 60       	ori	r18, 0x02	; 2
     46c:	20 83       	st	Z, r18
	sbi(TCCR4B,WGM12);
     46e:	e1 ea       	ldi	r30, 0xA1	; 161
     470:	f0 e0       	ldi	r31, 0x00	; 0
     472:	20 81       	ld	r18, Z
     474:	28 60       	ori	r18, 0x08	; 8
     476:	20 83       	st	Z, r18
	sbi(TCCR4B,WGM13);
     478:	20 81       	ld	r18, Z
     47a:	20 61       	ori	r18, 0x10	; 16
     47c:	20 83       	st	Z, r18
	
	// set top count value
	ICR4 = topcount;
     47e:	90 93 a7 00 	sts	0x00A7, r25
     482:	80 93 a6 00 	sts	0x00A6, r24
	
	// clear output compare values
	OCR4A = 0;
     486:	10 92 a9 00 	sts	0x00A9, r1
     48a:	10 92 a8 00 	sts	0x00A8, r1
	OCR4B = 0;
     48e:	10 92 ab 00 	sts	0x00AB, r1
     492:	10 92 aa 00 	sts	0x00AA, r1
	OCR4C = 0;
     496:	10 92 ad 00 	sts	0x00AD, r1
     49a:	10 92 ac 00 	sts	0x00AC, r1
}
     49e:	08 95       	ret

000004a0 <PWM_timer1_On_LED>:
#endif

//on commands
void PWM_timer1_On_LED(void)
{
	sbi(TCCR1A,COM1B1);
     4a0:	e0 e8       	ldi	r30, 0x80	; 128
     4a2:	f0 e0       	ldi	r31, 0x00	; 0
     4a4:	80 81       	ld	r24, Z
     4a6:	80 62       	ori	r24, 0x20	; 32
     4a8:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B0);
     4aa:	80 81       	ld	r24, Z
     4ac:	8f 7e       	andi	r24, 0xEF	; 239
     4ae:	80 83       	st	Z, r24
}
     4b0:	08 95       	ret

000004b2 <PWM_timer2_On_H6>:
void PWM_timer2_On_H6(void)
{
	sbi(TCCR2A,COM2B1);
     4b2:	e0 eb       	ldi	r30, 0xB0	; 176
     4b4:	f0 e0       	ldi	r31, 0x00	; 0
     4b6:	80 81       	ld	r24, Z
     4b8:	80 62       	ori	r24, 0x20	; 32
     4ba:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B0);
     4bc:	80 81       	ld	r24, Z
     4be:	8f 7e       	andi	r24, 0xEF	; 239
     4c0:	80 83       	st	Z, r24
}
     4c2:	08 95       	ret

000004c4 <PWM_timer3_On_E3>:
void PWM_timer3_On_E3(void)
{
	sbi(TCCR3A,COM3A1);
     4c4:	e0 e9       	ldi	r30, 0x90	; 144
     4c6:	f0 e0       	ldi	r31, 0x00	; 0
     4c8:	80 81       	ld	r24, Z
     4ca:	80 68       	ori	r24, 0x80	; 128
     4cc:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3A0);
     4ce:	80 81       	ld	r24, Z
     4d0:	8f 7b       	andi	r24, 0xBF	; 191
     4d2:	80 83       	st	Z, r24
}
     4d4:	08 95       	ret

000004d6 <PWM_timer3_On_E4>:
void PWM_timer3_On_E4(void)
{
	sbi(TCCR3A,COM3B1);
     4d6:	e0 e9       	ldi	r30, 0x90	; 144
     4d8:	f0 e0       	ldi	r31, 0x00	; 0
     4da:	80 81       	ld	r24, Z
     4dc:	80 62       	ori	r24, 0x20	; 32
     4de:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3B0);
     4e0:	80 81       	ld	r24, Z
     4e2:	8f 7e       	andi	r24, 0xEF	; 239
     4e4:	80 83       	st	Z, r24
}
     4e6:	08 95       	ret

000004e8 <PWM_timer3_On_E5>:
void PWM_timer3_On_E5(void)
{
	sbi(TCCR3A,COM3C1);
     4e8:	e0 e9       	ldi	r30, 0x90	; 144
     4ea:	f0 e0       	ldi	r31, 0x00	; 0
     4ec:	80 81       	ld	r24, Z
     4ee:	88 60       	ori	r24, 0x08	; 8
     4f0:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C0);
     4f2:	80 81       	ld	r24, Z
     4f4:	8b 7f       	andi	r24, 0xFB	; 251
     4f6:	80 83       	st	Z, r24
}
     4f8:	08 95       	ret

000004fa <PWM_timer4_On_H3>:
void PWM_timer4_On_H3(void)
{
	sbi(TCCR4A,COM4A1);
     4fa:	e0 ea       	ldi	r30, 0xA0	; 160
     4fc:	f0 e0       	ldi	r31, 0x00	; 0
     4fe:	80 81       	ld	r24, Z
     500:	80 68       	ori	r24, 0x80	; 128
     502:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4A0);
     504:	80 81       	ld	r24, Z
     506:	8f 7b       	andi	r24, 0xBF	; 191
     508:	80 83       	st	Z, r24
}
     50a:	08 95       	ret

0000050c <PWM_timer4_On_H4>:
void PWM_timer4_On_H4(void)
{
	sbi(TCCR4A,COM4B1);
     50c:	e0 ea       	ldi	r30, 0xA0	; 160
     50e:	f0 e0       	ldi	r31, 0x00	; 0
     510:	80 81       	ld	r24, Z
     512:	80 62       	ori	r24, 0x20	; 32
     514:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4B0);
     516:	80 81       	ld	r24, Z
     518:	8f 7e       	andi	r24, 0xEF	; 239
     51a:	80 83       	st	Z, r24
}
     51c:	08 95       	ret

0000051e <PWM_timer4_On_H5>:
void PWM_timer4_On_H5(void)
{
	sbi(TCCR4A,COM4C1);
     51e:	e0 ea       	ldi	r30, 0xA0	; 160
     520:	f0 e0       	ldi	r31, 0x00	; 0
     522:	80 81       	ld	r24, Z
     524:	88 60       	ori	r24, 0x08	; 8
     526:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4C0);
     528:	80 81       	ld	r24, Z
     52a:	8b 7f       	andi	r24, 0xFB	; 251
     52c:	80 83       	st	Z, r24
}
     52e:	08 95       	ret

00000530 <PWM_timer1_Off_LED>:

//off commands
void PWM_timer1_Off_LED(void)
{
	cbi(TCCR1A,COM1B1);
     530:	e0 e8       	ldi	r30, 0x80	; 128
     532:	f0 e0       	ldi	r31, 0x00	; 0
     534:	80 81       	ld	r24, Z
     536:	8f 7d       	andi	r24, 0xDF	; 223
     538:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B0);
     53a:	80 81       	ld	r24, Z
     53c:	8f 7e       	andi	r24, 0xEF	; 239
     53e:	80 83       	st	Z, r24
}
     540:	08 95       	ret

00000542 <PWM_timer2_Off_H6>:
void PWM_timer2_Off_H6(void)
{
	cbi(TCCR2A,COM2B1);
     542:	e0 eb       	ldi	r30, 0xB0	; 176
     544:	f0 e0       	ldi	r31, 0x00	; 0
     546:	80 81       	ld	r24, Z
     548:	8f 7d       	andi	r24, 0xDF	; 223
     54a:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B0);
     54c:	80 81       	ld	r24, Z
     54e:	8f 7e       	andi	r24, 0xEF	; 239
     550:	80 83       	st	Z, r24
}
     552:	08 95       	ret

00000554 <PWM_timer3_Off_E3>:
void PWM_timer3_Off_E3(void)
{
	cbi(TCCR3A,COM3A1);
     554:	e0 e9       	ldi	r30, 0x90	; 144
     556:	f0 e0       	ldi	r31, 0x00	; 0
     558:	80 81       	ld	r24, Z
     55a:	8f 77       	andi	r24, 0x7F	; 127
     55c:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3A0);
     55e:	80 81       	ld	r24, Z
     560:	8f 7b       	andi	r24, 0xBF	; 191
     562:	80 83       	st	Z, r24
}
     564:	08 95       	ret

00000566 <PWM_timer3_Off_E4>:
void PWM_timer3_Off_E4(void)
{
	cbi(TCCR3A,COM3B1);
     566:	e0 e9       	ldi	r30, 0x90	; 144
     568:	f0 e0       	ldi	r31, 0x00	; 0
     56a:	80 81       	ld	r24, Z
     56c:	8f 7d       	andi	r24, 0xDF	; 223
     56e:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3B0);
     570:	80 81       	ld	r24, Z
     572:	8f 7e       	andi	r24, 0xEF	; 239
     574:	80 83       	st	Z, r24
}
     576:	08 95       	ret

00000578 <PWM_timer3_Off_E5>:
void PWM_timer3_Off_E5(void)
{
	cbi(TCCR3A,COM3C1);
     578:	e0 e9       	ldi	r30, 0x90	; 144
     57a:	f0 e0       	ldi	r31, 0x00	; 0
     57c:	80 81       	ld	r24, Z
     57e:	87 7f       	andi	r24, 0xF7	; 247
     580:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C0);
     582:	80 81       	ld	r24, Z
     584:	8b 7f       	andi	r24, 0xFB	; 251
     586:	80 83       	st	Z, r24
}
     588:	08 95       	ret

0000058a <PWM_timer4_Off_H3>:
void PWM_timer4_Off_H3(void)
{
	cbi(TCCR4A,COM4A1);
     58a:	e0 ea       	ldi	r30, 0xA0	; 160
     58c:	f0 e0       	ldi	r31, 0x00	; 0
     58e:	80 81       	ld	r24, Z
     590:	8f 77       	andi	r24, 0x7F	; 127
     592:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4A0);
     594:	80 81       	ld	r24, Z
     596:	8f 7b       	andi	r24, 0xBF	; 191
     598:	80 83       	st	Z, r24
}
     59a:	08 95       	ret

0000059c <PWM_timer4_Off_H4>:
void PWM_timer4_Off_H4(void)
{
	cbi(TCCR4A,COM4B1);
     59c:	e0 ea       	ldi	r30, 0xA0	; 160
     59e:	f0 e0       	ldi	r31, 0x00	; 0
     5a0:	80 81       	ld	r24, Z
     5a2:	8f 7d       	andi	r24, 0xDF	; 223
     5a4:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4B0);
     5a6:	80 81       	ld	r24, Z
     5a8:	8f 7e       	andi	r24, 0xEF	; 239
     5aa:	80 83       	st	Z, r24
}
     5ac:	08 95       	ret

000005ae <PWM_timer4_Off_H5>:
void PWM_timer4_Off_H5(void)
{
	cbi(TCCR4A,COM4C1);
     5ae:	e0 ea       	ldi	r30, 0xA0	; 160
     5b0:	f0 e0       	ldi	r31, 0x00	; 0
     5b2:	80 81       	ld	r24, Z
     5b4:	87 7f       	andi	r24, 0xF7	; 247
     5b6:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4C0);
     5b8:	80 81       	ld	r24, Z
     5ba:	8b 7f       	andi	r24, 0xFB	; 251
     5bc:	80 83       	st	Z, r24
}
     5be:	08 95       	ret

000005c0 <PWM_timer1_Off_All>:


void PWM_timer1_Off_All(void)
{
	cbi(TCCR1A,PWM11);
     5c0:	e0 e8       	ldi	r30, 0x80	; 128
     5c2:	f0 e0       	ldi	r31, 0x00	; 0
     5c4:	80 81       	ld	r24, Z
     5c6:	8d 7f       	andi	r24, 0xFD	; 253
     5c8:	80 83       	st	Z, r24
	cbi(TCCR1A,PWM10);
     5ca:	80 81       	ld	r24, Z
     5cc:	8e 7f       	andi	r24, 0xFE	; 254
     5ce:	80 83       	st	Z, r24
}

//off commands
void PWM_timer1_Off_LED(void)
{
	cbi(TCCR1A,COM1B1);
     5d0:	80 81       	ld	r24, Z
     5d2:	8f 7d       	andi	r24, 0xDF	; 223
     5d4:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B0);
     5d6:	80 81       	ld	r24, Z
     5d8:	8f 7e       	andi	r24, 0xEF	; 239
     5da:	80 83       	st	Z, r24
	cbi(TCCR1A,PWM11);
	cbi(TCCR1A,PWM10);
	//timer2PWMAOff();
	PWM_timer1_Off_LED();
	//timer2PWMCOff();
}
     5dc:	08 95       	ret

000005de <PWM_timer2_Off_All>:
void PWM_timer2_Off_All(void)
{
	cbi(TCCR2A,PWM11);
     5de:	e0 eb       	ldi	r30, 0xB0	; 176
     5e0:	f0 e0       	ldi	r31, 0x00	; 0
     5e2:	80 81       	ld	r24, Z
     5e4:	8d 7f       	andi	r24, 0xFD	; 253
     5e6:	80 83       	st	Z, r24
	cbi(TCCR2A,PWM10);
     5e8:	80 81       	ld	r24, Z
     5ea:	8e 7f       	andi	r24, 0xFE	; 254
     5ec:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B1);
	cbi(TCCR1A,COM1B0);
}
void PWM_timer2_Off_H6(void)
{
	cbi(TCCR2A,COM2B1);
     5ee:	80 81       	ld	r24, Z
     5f0:	8f 7d       	andi	r24, 0xDF	; 223
     5f2:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B0);
     5f4:	80 81       	ld	r24, Z
     5f6:	8f 7e       	andi	r24, 0xEF	; 239
     5f8:	80 83       	st	Z, r24
	cbi(TCCR2A,PWM11);
	cbi(TCCR2A,PWM10);
	//timer2PWMAOff();
	PWM_timer2_Off_H6();
	//timer2PWMCOff();
}
     5fa:	08 95       	ret

000005fc <PWM_timer3_Off_All>:
void PWM_timer3_Off_All(void)
{
	cbi(TCCR3A,PWM11);
     5fc:	e0 e9       	ldi	r30, 0x90	; 144
     5fe:	f0 e0       	ldi	r31, 0x00	; 0
     600:	80 81       	ld	r24, Z
     602:	8d 7f       	andi	r24, 0xFD	; 253
     604:	80 83       	st	Z, r24
	cbi(TCCR3A,PWM10);
     606:	80 81       	ld	r24, Z
     608:	8e 7f       	andi	r24, 0xFE	; 254
     60a:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B1);
	cbi(TCCR2A,COM2B0);
}
void PWM_timer3_Off_E3(void)
{
	cbi(TCCR3A,COM3A1);
     60c:	80 81       	ld	r24, Z
     60e:	8f 77       	andi	r24, 0x7F	; 127
     610:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3A0);
     612:	80 81       	ld	r24, Z
     614:	8f 7b       	andi	r24, 0xBF	; 191
     616:	80 83       	st	Z, r24
}
void PWM_timer3_Off_E4(void)
{
	cbi(TCCR3A,COM3B1);
     618:	80 81       	ld	r24, Z
     61a:	8f 7d       	andi	r24, 0xDF	; 223
     61c:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3B0);
     61e:	80 81       	ld	r24, Z
     620:	8f 7e       	andi	r24, 0xEF	; 239
     622:	80 83       	st	Z, r24
}
void PWM_timer3_Off_E5(void)
{
	cbi(TCCR3A,COM3C1);
     624:	80 81       	ld	r24, Z
     626:	87 7f       	andi	r24, 0xF7	; 247
     628:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C0);
     62a:	80 81       	ld	r24, Z
     62c:	8b 7f       	andi	r24, 0xFB	; 251
     62e:	80 83       	st	Z, r24
	//timer2PWMAOff();
	PWM_timer3_Off_E3();
	PWM_timer3_Off_E4();
	PWM_timer3_Off_E5();
	//timer2PWMCOff();
}
     630:	08 95       	ret

00000632 <PWM_timer4_Off_All>:
void PWM_timer4_Off_All(void)
{
	cbi(TCCR4A,PWM11);
     632:	e0 ea       	ldi	r30, 0xA0	; 160
     634:	f0 e0       	ldi	r31, 0x00	; 0
     636:	80 81       	ld	r24, Z
     638:	8d 7f       	andi	r24, 0xFD	; 253
     63a:	80 83       	st	Z, r24
	cbi(TCCR4A,PWM10);
     63c:	80 81       	ld	r24, Z
     63e:	8e 7f       	andi	r24, 0xFE	; 254
     640:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C1);
	cbi(TCCR3A,COM3C0);
}
void PWM_timer4_Off_H3(void)
{
	cbi(TCCR4A,COM4A1);
     642:	80 81       	ld	r24, Z
     644:	8f 77       	andi	r24, 0x7F	; 127
     646:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4A0);
     648:	80 81       	ld	r24, Z
     64a:	8f 7b       	andi	r24, 0xBF	; 191
     64c:	80 83       	st	Z, r24
}
void PWM_timer4_Off_H4(void)
{
	cbi(TCCR4A,COM4B1);
     64e:	80 81       	ld	r24, Z
     650:	8f 7d       	andi	r24, 0xDF	; 223
     652:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4B0);
     654:	80 81       	ld	r24, Z
     656:	8f 7e       	andi	r24, 0xEF	; 239
     658:	80 83       	st	Z, r24
}
void PWM_timer4_Off_H5(void)
{
	cbi(TCCR4A,COM4C1);
     65a:	80 81       	ld	r24, Z
     65c:	87 7f       	andi	r24, 0xF7	; 247
     65e:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4C0);
     660:	80 81       	ld	r24, Z
     662:	8b 7f       	andi	r24, 0xFB	; 251
     664:	80 83       	st	Z, r24
	//timer2PWMAOff();
	PWM_timer4_Off_H3();
	PWM_timer4_Off_H4();
	PWM_timer4_Off_H5();
	//timer2PWMCOff();
}
     666:	08 95       	ret

00000668 <PWM_timer1_Set_LED>:
// this PWM output is generated on OC2B pin
// NOTE:	pwmDuty should be in the range 0-255 for 8bit PWM
//			pwmDuty should be in the range 0-511 for 9bit PWM
//			pwmDuty should be in the range 0-1023 for 10bit PWM
void PWM_timer1_Set_LED(u16 pwmDuty)
	{OCR1B = pwmDuty;}
     668:	90 93 8b 00 	sts	0x008B, r25
     66c:	80 93 8a 00 	sts	0x008A, r24
     670:	08 95       	ret

00000672 <PWM_timer2_Set_H6>:
void PWM_timer2_Set_H6(u16 pwmDuty)
	{OCR2B = pwmDuty;}
     672:	80 93 b4 00 	sts	0x00B4, r24
     676:	08 95       	ret

00000678 <PWM_timer3_Set_E3>:
void PWM_timer3_Set_E3(u16 pwmDuty)
	{OCR3A = pwmDuty;}
     678:	90 93 99 00 	sts	0x0099, r25
     67c:	80 93 98 00 	sts	0x0098, r24
     680:	08 95       	ret

00000682 <PWM_timer3_Set_E4>:
void PWM_timer3_Set_E4(u16 pwmDuty)
	{OCR3B = pwmDuty;}
     682:	90 93 9b 00 	sts	0x009B, r25
     686:	80 93 9a 00 	sts	0x009A, r24
     68a:	08 95       	ret

0000068c <PWM_timer3_Set_E5>:
void PWM_timer3_Set_E5(u16 pwmDuty)
	{OCR3C = pwmDuty;}
     68c:	90 93 9d 00 	sts	0x009D, r25
     690:	80 93 9c 00 	sts	0x009C, r24
     694:	08 95       	ret

00000696 <PWM_timer4_Set_H3>:
void PWM_timer4_Set_H3(u16 pwmDuty)
	{OCR4A = pwmDuty;}
     696:	90 93 a9 00 	sts	0x00A9, r25
     69a:	80 93 a8 00 	sts	0x00A8, r24
     69e:	08 95       	ret

000006a0 <PWM_timer4_Set_H4>:
void PWM_timer4_Set_H4(u16 pwmDuty)
	{OCR4B = pwmDuty;}
     6a0:	90 93 ab 00 	sts	0x00AB, r25
     6a4:	80 93 aa 00 	sts	0x00AA, r24
     6a8:	08 95       	ret

000006aa <PWM_timer4_Set_H5>:
void PWM_timer4_Set_H5(u16 pwmDuty)
	{OCR4C = pwmDuty;}
     6aa:	90 93 ad 00 	sts	0x00AD, r25
     6ae:	80 93 ac 00 	sts	0x00AC, r24
     6b2:	08 95       	ret

000006b4 <configure_ports>:
	//cbi(DDRG, PG5);  //set G5 as input pin

	//ANALOG PORTS
	//useful for sensors, SharpIR, photoresistors, etc.
	//analog ports can be configured as digital ports if desired
	DDRF = 0b00000000;  //configure all F ports for input				0x00
     6b4:	10 ba       	out	0x10, r1	; 16
	PORTF = 0b00000000; //make sure pull-up resistors are turned off	0x00
     6b6:	11 ba       	out	0x11, r1	; 17
	DDRK = 0b00000000;  //configure all K ports for input				0x00
     6b8:	10 92 07 01 	sts	0x0107, r1
	PORTK = 0b00000000; //make sure pull-up resistors are turned off	0x00
     6bc:	10 92 08 01 	sts	0x0108, r1

	//DIGITAL PORTS
	//useful for servos, PWM, LED's, UART, interrupts, timers
	DDRA = 0b11111111;  //configure ports for output
     6c0:	9f ef       	ldi	r25, 0xFF	; 255
     6c2:	91 b9       	out	0x01, r25	; 1
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	//PORTB reserved for programmer (use programmer pins if you know what you are doing)
	DDRB = _BV (PB6);	//PB6 is LED, hold low to turn it on
     6c4:	80 e4       	ldi	r24, 0x40	; 64
     6c6:	84 b9       	out	0x04, r24	; 4
	DDRC = 0b11111111;  //configure ports for output
     6c8:	97 b9       	out	0x07, r25	; 7
	//       ||||\______3: 
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 	
	sbi(PORTD, PD0); // SCL pull-up
     6ca:	58 9a       	sbi	0x0b, 0	; 11
	sbi(PORTD, PD1); // SDA pull-up
     6cc:	59 9a       	sbi	0x0b, 1	; 11
	DDRD = 0b11110011;  //configure ports for output
     6ce:	83 ef       	ldi	r24, 0xF3	; 243
     6d0:	8a b9       	out	0x0a, r24	; 10
	//       ||||\______3: serial TXD1, output -> 1
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: timer0
	DDRE = 0b11111110;  //configure ports for output
     6d2:	8e ef       	ldi	r24, 0xFE	; 254
     6d4:	8d b9       	out	0x0d, r24	; 13
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	//cbi(PORTG, PG5);  // disable pull-up resistor for Axon v1e and earlier
	sbi(PORTG, PG5);  // enable pull-up resistor for v1f and later
     6d6:	a5 9a       	sbi	0x14, 5	; 20
	cbi(DDRG, PG5);	//PG5 is for the button, make a digital input
     6d8:	9d 98       	cbi	0x13, 5	; 19
	//note that button actions are inverted between both versions!!!
	DDRH = 0b11111110;  //configure ports for output
     6da:	80 93 01 01 	sts	0x0101, r24
	//       ||||\______3: 
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	DDRJ = 0b11111110;  //configure ports for output
     6de:	80 93 04 01 	sts	0x0104, r24
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	//PORTL has no headers
	};
     6e2:	08 95       	ret

000006e4 <delay_cycles>:
void delay_cycles(unsigned long int cycles)
	{
	cycles=cycles;//doubled frequency but too lazy to change times
	while(cycles > 0)
		cycles--;
	}
     6e4:	08 95       	ret

000006e6 <LED_off>:


//***************STATUS LED**************
//tank test
void LED_off(void)
	{PORT_ON(PORTB,6);}
     6e6:	2e 9a       	sbi	0x05, 6	; 5
     6e8:	08 95       	ret

000006ea <LED_on>:
void LED_on(void)
	{PORT_OFF(PORTB,6);}
     6ea:	2e 98       	cbi	0x05, 6	; 5
     6ec:	08 95       	ret

000006ee <button_pressed>:


//*****************BUTTON****************
int button_pressed(void)
	{
	return (bit_is_clear(PING, 5));
     6ee:	22 b3       	in	r18, 0x12	; 18
     6f0:	30 e0       	ldi	r19, 0x00	; 0
     6f2:	85 e0       	ldi	r24, 0x05	; 5
     6f4:	36 95       	lsr	r19
     6f6:	27 95       	ror	r18
     6f8:	8a 95       	dec	r24
     6fa:	e1 f7       	brne	.-8      	; 0x6f4 <button_pressed+0x6>
     6fc:	20 95       	com	r18
     6fe:	30 95       	com	r19
     700:	21 70       	andi	r18, 0x01	; 1
     702:	30 70       	andi	r19, 0x00	; 0
	//return ((PING) & (1<<PG5));//old version, went high when button pushed
	}
     704:	c9 01       	movw	r24, r18
     706:	08 95       	ret

00000708 <cos_SoR>:
signed int angtable[73]={100,100,98,97,94,91,87,82,77,71,64,57,50,42,34,26,17,9,0,-9,-17,-26,-34,-42,-50,-57,-64,-71,-77,-82,-87,-91,-94,-97,-98,-100,
						 -100,-100,-98,-97,-94,-91,-87,-82,-77,-71,-64,-57,-50,-42,-34,-26,-17,-9,0,9,17,26,34,42,50,57,64,71,77,82,87,91,94,97,98,100,100};

signed int cos_SoR(long signed int degrees)//returns cos*100
	{
	if (degrees >= 0)//positive angles
     708:	97 fd       	sbrc	r25, 7
     70a:	10 c0       	rjmp	.+32     	; 0x72c <cos_SoR+0x24>
		return angtable[degrees/5];
     70c:	25 e0       	ldi	r18, 0x05	; 5
     70e:	30 e0       	ldi	r19, 0x00	; 0
     710:	40 e0       	ldi	r20, 0x00	; 0
     712:	50 e0       	ldi	r21, 0x00	; 0
     714:	0e 94 23 28 	call	0x5046	; 0x5046 <__divmodsi4>
     718:	da 01       	movw	r26, r20
     71a:	c9 01       	movw	r24, r18
     71c:	88 0f       	add	r24, r24
     71e:	99 1f       	adc	r25, r25
     720:	80 50       	subi	r24, 0x00	; 0
     722:	9e 4f       	sbci	r25, 0xFE	; 254
     724:	fc 01       	movw	r30, r24
     726:	20 81       	ld	r18, Z
     728:	31 81       	ldd	r19, Z+1	; 0x01
     72a:	17 c0       	rjmp	.+46     	; 0x75a <cos_SoR+0x52>
	else
		return -angtable[72-(-degrees)/5];
     72c:	25 e0       	ldi	r18, 0x05	; 5
     72e:	30 e0       	ldi	r19, 0x00	; 0
     730:	40 e0       	ldi	r20, 0x00	; 0
     732:	50 e0       	ldi	r21, 0x00	; 0
     734:	0e 94 23 28 	call	0x5046	; 0x5046 <__divmodsi4>
     738:	da 01       	movw	r26, r20
     73a:	c9 01       	movw	r24, r18
     73c:	88 5b       	subi	r24, 0xB8	; 184
     73e:	9f 4f       	sbci	r25, 0xFF	; 255
     740:	af 4f       	sbci	r26, 0xFF	; 255
     742:	bf 4f       	sbci	r27, 0xFF	; 255
     744:	88 0f       	add	r24, r24
     746:	99 1f       	adc	r25, r25
     748:	80 50       	subi	r24, 0x00	; 0
     74a:	9e 4f       	sbci	r25, 0xFE	; 254
     74c:	fc 01       	movw	r30, r24
     74e:	80 81       	ld	r24, Z
     750:	91 81       	ldd	r25, Z+1	; 0x01
     752:	22 27       	eor	r18, r18
     754:	33 27       	eor	r19, r19
     756:	28 1b       	sub	r18, r24
     758:	39 0b       	sbc	r19, r25
	}
     75a:	c9 01       	movw	r24, r18
     75c:	08 95       	ret

0000075e <sin_SoR>:

signed int sin_SoR(long signed int degrees)//returns sin*100
	{
	degrees=degrees - 90;//phase shift 90 degrees
     75e:	6a 55       	subi	r22, 0x5A	; 90
     760:	70 40       	sbci	r23, 0x00	; 0
     762:	80 40       	sbci	r24, 0x00	; 0
     764:	90 40       	sbci	r25, 0x00	; 0

	if (degrees >= 0)//positive angles
     766:	97 fd       	sbrc	r25, 7
     768:	10 c0       	rjmp	.+32     	; 0x78a <sin_SoR+0x2c>
		return angtable[degrees/5];
     76a:	25 e0       	ldi	r18, 0x05	; 5
     76c:	30 e0       	ldi	r19, 0x00	; 0
     76e:	40 e0       	ldi	r20, 0x00	; 0
     770:	50 e0       	ldi	r21, 0x00	; 0
     772:	0e 94 23 28 	call	0x5046	; 0x5046 <__divmodsi4>
     776:	da 01       	movw	r26, r20
     778:	c9 01       	movw	r24, r18
     77a:	88 0f       	add	r24, r24
     77c:	99 1f       	adc	r25, r25
     77e:	80 50       	subi	r24, 0x00	; 0
     780:	9e 4f       	sbci	r25, 0xFE	; 254
     782:	fc 01       	movw	r30, r24
     784:	20 81       	ld	r18, Z
     786:	31 81       	ldd	r19, Z+1	; 0x01
     788:	17 c0       	rjmp	.+46     	; 0x7b8 <sin_SoR+0x5a>
	else
		return -angtable[72-(-degrees)/5];
     78a:	25 e0       	ldi	r18, 0x05	; 5
     78c:	30 e0       	ldi	r19, 0x00	; 0
     78e:	40 e0       	ldi	r20, 0x00	; 0
     790:	50 e0       	ldi	r21, 0x00	; 0
     792:	0e 94 23 28 	call	0x5046	; 0x5046 <__divmodsi4>
     796:	da 01       	movw	r26, r20
     798:	c9 01       	movw	r24, r18
     79a:	88 5b       	subi	r24, 0xB8	; 184
     79c:	9f 4f       	sbci	r25, 0xFF	; 255
     79e:	af 4f       	sbci	r26, 0xFF	; 255
     7a0:	bf 4f       	sbci	r27, 0xFF	; 255
     7a2:	88 0f       	add	r24, r24
     7a4:	99 1f       	adc	r25, r25
     7a6:	80 50       	subi	r24, 0x00	; 0
     7a8:	9e 4f       	sbci	r25, 0xFE	; 254
     7aa:	fc 01       	movw	r30, r24
     7ac:	80 81       	ld	r24, Z
     7ae:	91 81       	ldd	r25, Z+1	; 0x01
     7b0:	22 27       	eor	r18, r18
     7b2:	33 27       	eor	r19, r19
     7b4:	28 1b       	sub	r18, r24
     7b6:	39 0b       	sbc	r19, r25
	}
     7b8:	c9 01       	movw	r24, r18
     7ba:	08 95       	ret

000007bc <tan_SoR>:

signed int tan_SoR(long signed int degrees)//returns tan * 10
	{
     7bc:	cf 92       	push	r12
     7be:	df 92       	push	r13
     7c0:	ef 92       	push	r14
     7c2:	ff 92       	push	r15
     7c4:	0f 93       	push	r16
     7c6:	1f 93       	push	r17
     7c8:	6b 01       	movw	r12, r22
     7ca:	7c 01       	movw	r14, r24
	//tan(x) = sin(x)/cos(x)
	if (degrees == 90 || degrees == -90 || degrees == 270 || degrees == -270)//blows up
     7cc:	8a e5       	ldi	r24, 0x5A	; 90
     7ce:	c8 16       	cp	r12, r24
     7d0:	d1 04       	cpc	r13, r1
     7d2:	e1 04       	cpc	r14, r1
     7d4:	f1 04       	cpc	r15, r1
     7d6:	a1 f1       	breq	.+104    	; 0x840 <tan_SoR+0x84>
     7d8:	86 ea       	ldi	r24, 0xA6	; 166
     7da:	c8 16       	cp	r12, r24
     7dc:	8f ef       	ldi	r24, 0xFF	; 255
     7de:	d8 06       	cpc	r13, r24
     7e0:	8f ef       	ldi	r24, 0xFF	; 255
     7e2:	e8 06       	cpc	r14, r24
     7e4:	8f ef       	ldi	r24, 0xFF	; 255
     7e6:	f8 06       	cpc	r15, r24
     7e8:	59 f1       	breq	.+86     	; 0x840 <tan_SoR+0x84>
     7ea:	8e e0       	ldi	r24, 0x0E	; 14
     7ec:	c8 16       	cp	r12, r24
     7ee:	81 e0       	ldi	r24, 0x01	; 1
     7f0:	d8 06       	cpc	r13, r24
     7f2:	80 e0       	ldi	r24, 0x00	; 0
     7f4:	e8 06       	cpc	r14, r24
     7f6:	80 e0       	ldi	r24, 0x00	; 0
     7f8:	f8 06       	cpc	r15, r24
     7fa:	11 f1       	breq	.+68     	; 0x840 <tan_SoR+0x84>
     7fc:	82 ef       	ldi	r24, 0xF2	; 242
     7fe:	c8 16       	cp	r12, r24
     800:	8e ef       	ldi	r24, 0xFE	; 254
     802:	d8 06       	cpc	r13, r24
     804:	8f ef       	ldi	r24, 0xFF	; 255
     806:	e8 06       	cpc	r14, r24
     808:	8f ef       	ldi	r24, 0xFF	; 255
     80a:	f8 06       	cpc	r15, r24
     80c:	c9 f0       	breq	.+50     	; 0x840 <tan_SoR+0x84>
		return 0;//what else should I return?!?!?
	return sin_SoR(degrees)/cos_SoR(degrees)*10;
     80e:	c7 01       	movw	r24, r14
     810:	b6 01       	movw	r22, r12
     812:	0e 94 af 03 	call	0x75e	; 0x75e <sin_SoR>
     816:	8c 01       	movw	r16, r24
     818:	c7 01       	movw	r24, r14
     81a:	b6 01       	movw	r22, r12
     81c:	0e 94 84 03 	call	0x708	; 0x708 <cos_SoR>
     820:	bc 01       	movw	r22, r24
     822:	c8 01       	movw	r24, r16
     824:	0e 94 ee 27 	call	0x4fdc	; 0x4fdc <__divmodhi4>
     828:	cb 01       	movw	r24, r22
     82a:	9b 01       	movw	r18, r22
     82c:	73 e0       	ldi	r23, 0x03	; 3
     82e:	22 0f       	add	r18, r18
     830:	33 1f       	adc	r19, r19
     832:	7a 95       	dec	r23
     834:	e1 f7       	brne	.-8      	; 0x82e <tan_SoR+0x72>
     836:	88 0f       	add	r24, r24
     838:	99 1f       	adc	r25, r25
     83a:	28 0f       	add	r18, r24
     83c:	39 1f       	adc	r19, r25
     83e:	02 c0       	rjmp	.+4      	; 0x844 <tan_SoR+0x88>
     840:	20 e0       	ldi	r18, 0x00	; 0
     842:	30 e0       	ldi	r19, 0x00	; 0
	}
     844:	c9 01       	movw	r24, r18
     846:	1f 91       	pop	r17
     848:	0f 91       	pop	r16
     84a:	ff 90       	pop	r15
     84c:	ef 90       	pop	r14
     84e:	df 90       	pop	r13
     850:	cf 90       	pop	r12
     852:	08 95       	ret

00000854 <prvPWMSetup>:
//-----------------------------**&&**


void prvPWMSetup(){

	PWM_Init_timer3_E4(10); // Left wheel
     854:	8a e0       	ldi	r24, 0x0A	; 10
     856:	0e 94 4d 01 	call	0x29a	; 0x29a <PWM_Init_timer3_E4>
	PWM_Init_timer3_E3(10); // Right wheel
     85a:	8a e0       	ldi	r24, 0x0A	; 10
     85c:	0e 94 2d 01 	call	0x25a	; 0x25a <PWM_Init_timer3_E3>
	PWM_Init_timer4_H3(10);	// Left sprayer
     860:	8a e0       	ldi	r24, 0x0A	; 10
     862:	0e 94 8d 01 	call	0x31a	; 0x31a <PWM_Init_timer4_H3>
	PWM_Init_timer4_H4(10);	// Right sprayer
     866:	8a e0       	ldi	r24, 0x0A	; 10
     868:	0e 94 ad 01 	call	0x35a	; 0x35a <PWM_Init_timer4_H4>

}
     86c:	08 95       	ret

0000086e <char2hex>:

char char2hex(char c){
     86e:	98 2f       	mov	r25, r24
	
	if((c > 47) && (c <58)){
     870:	80 53       	subi	r24, 0x30	; 48
     872:	8a 30       	cpi	r24, 0x0A	; 10
     874:	38 f0       	brcs	.+14     	; 0x884 <char2hex+0x16>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     876:	81 51       	subi	r24, 0x11	; 17
     878:	86 30       	cpi	r24, 0x06	; 6
     87a:	10 f0       	brcs	.+4      	; 0x880 <char2hex+0x12>
     87c:	89 2f       	mov	r24, r25
     87e:	08 95       	ret
		c -= 55;
     880:	89 2f       	mov	r24, r25
     882:	87 53       	subi	r24, 0x37	; 55
	}
	return c;
}
     884:	08 95       	ret

00000886 <retConv_s16>:

s16 retConv_s16(char* ch_head){
     886:	fc 01       	movw	r30, r24

	s16 int_val = 0x0000;
	char iv1 = *(ch_head);
     888:	90 81       	ld	r25, Z
	char iv2 = *(ch_head + 1);
     88a:	21 81       	ldd	r18, Z+1	; 0x01
	char iv3 = *(ch_head + 2);
     88c:	42 81       	ldd	r20, Z+2	; 0x02
	char iv4 = *(ch_head + 3);
     88e:	53 81       	ldd	r21, Z+3	; 0x03

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     890:	89 2f       	mov	r24, r25
     892:	80 53       	subi	r24, 0x30	; 48
     894:	8a 30       	cpi	r24, 0x0A	; 10
     896:	10 f4       	brcc	.+4      	; 0x89c <retConv_s16+0x16>
     898:	98 2f       	mov	r25, r24
     89a:	05 c0       	rjmp	.+10     	; 0x8a6 <retConv_s16+0x20>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     89c:	89 2f       	mov	r24, r25
     89e:	81 54       	subi	r24, 0x41	; 65
     8a0:	86 30       	cpi	r24, 0x06	; 6
     8a2:	08 f4       	brcc	.+2      	; 0x8a6 <retConv_s16+0x20>
		c -= 55;
     8a4:	97 53       	subi	r25, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     8a6:	82 2f       	mov	r24, r18
     8a8:	80 53       	subi	r24, 0x30	; 48
     8aa:	8a 30       	cpi	r24, 0x0A	; 10
     8ac:	10 f4       	brcc	.+4      	; 0x8b2 <retConv_s16+0x2c>
     8ae:	28 2f       	mov	r18, r24
     8b0:	05 c0       	rjmp	.+10     	; 0x8bc <retConv_s16+0x36>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     8b2:	82 2f       	mov	r24, r18
     8b4:	81 54       	subi	r24, 0x41	; 65
     8b6:	86 30       	cpi	r24, 0x06	; 6
     8b8:	08 f4       	brcc	.+2      	; 0x8bc <retConv_s16+0x36>
		c -= 55;
     8ba:	27 53       	subi	r18, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     8bc:	84 2f       	mov	r24, r20
     8be:	80 53       	subi	r24, 0x30	; 48
     8c0:	8a 30       	cpi	r24, 0x0A	; 10
     8c2:	10 f4       	brcc	.+4      	; 0x8c8 <retConv_s16+0x42>
     8c4:	48 2f       	mov	r20, r24
     8c6:	05 c0       	rjmp	.+10     	; 0x8d2 <retConv_s16+0x4c>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     8c8:	84 2f       	mov	r24, r20
     8ca:	81 54       	subi	r24, 0x41	; 65
     8cc:	86 30       	cpi	r24, 0x06	; 6
     8ce:	08 f4       	brcc	.+2      	; 0x8d2 <retConv_s16+0x4c>
		c -= 55;
     8d0:	47 53       	subi	r20, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     8d2:	85 2f       	mov	r24, r21
     8d4:	80 53       	subi	r24, 0x30	; 48
     8d6:	8a 30       	cpi	r24, 0x0A	; 10
     8d8:	10 f4       	brcc	.+4      	; 0x8de <retConv_s16+0x58>
     8da:	58 2f       	mov	r21, r24
     8dc:	05 c0       	rjmp	.+10     	; 0x8e8 <retConv_s16+0x62>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     8de:	85 2f       	mov	r24, r21
     8e0:	81 54       	subi	r24, 0x41	; 65
     8e2:	86 30       	cpi	r24, 0x06	; 6
     8e4:	08 f4       	brcc	.+2      	; 0x8e8 <retConv_s16+0x62>
		c -= 55;
     8e6:	57 53       	subi	r21, 0x37	; 55
	iv2 = char2hex(iv2);
	iv3 = char2hex(iv3);
	iv4 = char2hex(iv4);

	int_val = (int_val | iv1);
	int_val = ((int_val<<4) | iv2);
     8e8:	30 e0       	ldi	r19, 0x00	; 0
     8ea:	89 2f       	mov	r24, r25
     8ec:	90 e0       	ldi	r25, 0x00	; 0
     8ee:	a4 e0       	ldi	r26, 0x04	; 4
     8f0:	88 0f       	add	r24, r24
     8f2:	99 1f       	adc	r25, r25
     8f4:	aa 95       	dec	r26
     8f6:	e1 f7       	brne	.-8      	; 0x8f0 <retConv_s16+0x6a>
     8f8:	28 2b       	or	r18, r24
     8fa:	39 2b       	or	r19, r25
	int_val = ((int_val<<4) | iv3);
     8fc:	f4 e0       	ldi	r31, 0x04	; 4
     8fe:	22 0f       	add	r18, r18
     900:	33 1f       	adc	r19, r19
     902:	fa 95       	dec	r31
     904:	e1 f7       	brne	.-8      	; 0x8fe <retConv_s16+0x78>
     906:	84 2f       	mov	r24, r20
     908:	90 e0       	ldi	r25, 0x00	; 0
     90a:	82 2b       	or	r24, r18
     90c:	93 2b       	or	r25, r19
	int_val = ((int_val<<4) | iv4);
     90e:	e4 e0       	ldi	r30, 0x04	; 4
     910:	88 0f       	add	r24, r24
     912:	99 1f       	adc	r25, r25
     914:	ea 95       	dec	r30
     916:	e1 f7       	brne	.-8      	; 0x910 <retConv_s16+0x8a>
     918:	25 2f       	mov	r18, r21
     91a:	30 e0       	ldi	r19, 0x00	; 0
     91c:	28 2b       	or	r18, r24
     91e:	39 2b       	or	r19, r25
	return int_val;
}
     920:	c9 01       	movw	r24, r18
     922:	08 95       	ret

00000924 <retConv_s32>:

s32 retConv_s32(char* ch_head){
     924:	ff 92       	push	r15
     926:	0f 93       	push	r16
     928:	1f 93       	push	r17
     92a:	fc 01       	movw	r30, r24

	s32 int_val = 0x00000000;
	char iv1 = *(ch_head);
     92c:	90 81       	ld	r25, Z
	char iv2 = *(ch_head + 1);
     92e:	21 81       	ldd	r18, Z+1	; 0x01
	char iv3 = *(ch_head + 2);
     930:	62 81       	ldd	r22, Z+2	; 0x02
	char iv4 = *(ch_head + 3);
     932:	73 81       	ldd	r23, Z+3	; 0x03
	char iv5 = *(ch_head + 4);
     934:	14 81       	ldd	r17, Z+4	; 0x04
	char iv6 = *(ch_head + 5);
     936:	05 81       	ldd	r16, Z+5	; 0x05
	char iv7 = *(ch_head + 6);
     938:	f6 80       	ldd	r15, Z+6	; 0x06
	char iv8 = *(ch_head + 7);
     93a:	e7 81       	ldd	r30, Z+7	; 0x07

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     93c:	89 2f       	mov	r24, r25
     93e:	80 53       	subi	r24, 0x30	; 48
     940:	8a 30       	cpi	r24, 0x0A	; 10
     942:	10 f4       	brcc	.+4      	; 0x948 <retConv_s32+0x24>
     944:	98 2f       	mov	r25, r24
     946:	05 c0       	rjmp	.+10     	; 0x952 <retConv_s32+0x2e>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     948:	89 2f       	mov	r24, r25
     94a:	81 54       	subi	r24, 0x41	; 65
     94c:	86 30       	cpi	r24, 0x06	; 6
     94e:	08 f4       	brcc	.+2      	; 0x952 <retConv_s32+0x2e>
		c -= 55;
     950:	97 53       	subi	r25, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     952:	82 2f       	mov	r24, r18
     954:	80 53       	subi	r24, 0x30	; 48
     956:	8a 30       	cpi	r24, 0x0A	; 10
     958:	10 f4       	brcc	.+4      	; 0x95e <retConv_s32+0x3a>
     95a:	28 2f       	mov	r18, r24
     95c:	05 c0       	rjmp	.+10     	; 0x968 <retConv_s32+0x44>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     95e:	82 2f       	mov	r24, r18
     960:	81 54       	subi	r24, 0x41	; 65
     962:	86 30       	cpi	r24, 0x06	; 6
     964:	08 f4       	brcc	.+2      	; 0x968 <retConv_s32+0x44>
		c -= 55;
     966:	27 53       	subi	r18, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     968:	86 2f       	mov	r24, r22
     96a:	80 53       	subi	r24, 0x30	; 48
     96c:	8a 30       	cpi	r24, 0x0A	; 10
     96e:	10 f4       	brcc	.+4      	; 0x974 <retConv_s32+0x50>
     970:	68 2f       	mov	r22, r24
     972:	05 c0       	rjmp	.+10     	; 0x97e <retConv_s32+0x5a>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     974:	86 2f       	mov	r24, r22
     976:	81 54       	subi	r24, 0x41	; 65
     978:	86 30       	cpi	r24, 0x06	; 6
     97a:	08 f4       	brcc	.+2      	; 0x97e <retConv_s32+0x5a>
		c -= 55;
     97c:	67 53       	subi	r22, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     97e:	87 2f       	mov	r24, r23
     980:	80 53       	subi	r24, 0x30	; 48
     982:	8a 30       	cpi	r24, 0x0A	; 10
     984:	10 f4       	brcc	.+4      	; 0x98a <retConv_s32+0x66>
     986:	78 2f       	mov	r23, r24
     988:	05 c0       	rjmp	.+10     	; 0x994 <retConv_s32+0x70>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     98a:	87 2f       	mov	r24, r23
     98c:	81 54       	subi	r24, 0x41	; 65
     98e:	86 30       	cpi	r24, 0x06	; 6
     990:	08 f4       	brcc	.+2      	; 0x994 <retConv_s32+0x70>
		c -= 55;
     992:	77 53       	subi	r23, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     994:	81 2f       	mov	r24, r17
     996:	80 53       	subi	r24, 0x30	; 48
     998:	8a 30       	cpi	r24, 0x0A	; 10
     99a:	10 f4       	brcc	.+4      	; 0x9a0 <retConv_s32+0x7c>
     99c:	18 2f       	mov	r17, r24
     99e:	05 c0       	rjmp	.+10     	; 0x9aa <retConv_s32+0x86>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     9a0:	81 2f       	mov	r24, r17
     9a2:	81 54       	subi	r24, 0x41	; 65
     9a4:	86 30       	cpi	r24, 0x06	; 6
     9a6:	08 f4       	brcc	.+2      	; 0x9aa <retConv_s32+0x86>
		c -= 55;
     9a8:	17 53       	subi	r17, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     9aa:	80 2f       	mov	r24, r16
     9ac:	80 53       	subi	r24, 0x30	; 48
     9ae:	8a 30       	cpi	r24, 0x0A	; 10
     9b0:	10 f4       	brcc	.+4      	; 0x9b6 <retConv_s32+0x92>
     9b2:	08 2f       	mov	r16, r24
     9b4:	05 c0       	rjmp	.+10     	; 0x9c0 <retConv_s32+0x9c>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     9b6:	80 2f       	mov	r24, r16
     9b8:	81 54       	subi	r24, 0x41	; 65
     9ba:	86 30       	cpi	r24, 0x06	; 6
     9bc:	08 f4       	brcc	.+2      	; 0x9c0 <retConv_s32+0x9c>
		c -= 55;
     9be:	07 53       	subi	r16, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     9c0:	8f 2d       	mov	r24, r15
     9c2:	80 53       	subi	r24, 0x30	; 48
     9c4:	8a 30       	cpi	r24, 0x0A	; 10
     9c6:	10 f4       	brcc	.+4      	; 0x9cc <retConv_s32+0xa8>
     9c8:	f8 2e       	mov	r15, r24
     9ca:	06 c0       	rjmp	.+12     	; 0x9d8 <retConv_s32+0xb4>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     9cc:	8f 2d       	mov	r24, r15
     9ce:	81 54       	subi	r24, 0x41	; 65
     9d0:	86 30       	cpi	r24, 0x06	; 6
     9d2:	10 f4       	brcc	.+4      	; 0x9d8 <retConv_s32+0xb4>
		c -= 55;
     9d4:	89 ec       	ldi	r24, 0xC9	; 201
     9d6:	f8 0e       	add	r15, r24

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     9d8:	8e 2f       	mov	r24, r30
     9da:	80 53       	subi	r24, 0x30	; 48
     9dc:	8a 30       	cpi	r24, 0x0A	; 10
     9de:	10 f4       	brcc	.+4      	; 0x9e4 <retConv_s32+0xc0>
     9e0:	e8 2f       	mov	r30, r24
     9e2:	05 c0       	rjmp	.+10     	; 0x9ee <retConv_s32+0xca>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     9e4:	8e 2f       	mov	r24, r30
     9e6:	81 54       	subi	r24, 0x41	; 65
     9e8:	86 30       	cpi	r24, 0x06	; 6
     9ea:	08 f4       	brcc	.+2      	; 0x9ee <retConv_s32+0xca>
		c -= 55;
     9ec:	e7 53       	subi	r30, 0x37	; 55
	iv6 = char2hex(iv6);
	iv7 = char2hex(iv7);
	iv8 = char2hex(iv8);

	int_val = (int_val | iv1);
	int_val = ((int_val<<4) | iv2);
     9ee:	30 e0       	ldi	r19, 0x00	; 0
     9f0:	40 e0       	ldi	r20, 0x00	; 0
     9f2:	50 e0       	ldi	r21, 0x00	; 0
     9f4:	89 2f       	mov	r24, r25
     9f6:	90 e0       	ldi	r25, 0x00	; 0
     9f8:	a0 e0       	ldi	r26, 0x00	; 0
     9fa:	b0 e0       	ldi	r27, 0x00	; 0
     9fc:	f4 e0       	ldi	r31, 0x04	; 4
     9fe:	88 0f       	add	r24, r24
     a00:	99 1f       	adc	r25, r25
     a02:	aa 1f       	adc	r26, r26
     a04:	bb 1f       	adc	r27, r27
     a06:	fa 95       	dec	r31
     a08:	d1 f7       	brne	.-12     	; 0x9fe <retConv_s32+0xda>
     a0a:	28 2b       	or	r18, r24
     a0c:	39 2b       	or	r19, r25
     a0e:	4a 2b       	or	r20, r26
     a10:	5b 2b       	or	r21, r27
	int_val = ((int_val<<4) | iv3);
     a12:	a4 e0       	ldi	r26, 0x04	; 4
     a14:	22 0f       	add	r18, r18
     a16:	33 1f       	adc	r19, r19
     a18:	44 1f       	adc	r20, r20
     a1a:	55 1f       	adc	r21, r21
     a1c:	aa 95       	dec	r26
     a1e:	d1 f7       	brne	.-12     	; 0xa14 <retConv_s32+0xf0>
     a20:	86 2f       	mov	r24, r22
     a22:	90 e0       	ldi	r25, 0x00	; 0
     a24:	a0 e0       	ldi	r26, 0x00	; 0
     a26:	b0 e0       	ldi	r27, 0x00	; 0
     a28:	82 2b       	or	r24, r18
     a2a:	93 2b       	or	r25, r19
     a2c:	a4 2b       	or	r26, r20
     a2e:	b5 2b       	or	r27, r21
	int_val = ((int_val<<4) | iv4);
     a30:	f4 e0       	ldi	r31, 0x04	; 4
     a32:	88 0f       	add	r24, r24
     a34:	99 1f       	adc	r25, r25
     a36:	aa 1f       	adc	r26, r26
     a38:	bb 1f       	adc	r27, r27
     a3a:	fa 95       	dec	r31
     a3c:	d1 f7       	brne	.-12     	; 0xa32 <retConv_s32+0x10e>
     a3e:	27 2f       	mov	r18, r23
     a40:	30 e0       	ldi	r19, 0x00	; 0
     a42:	40 e0       	ldi	r20, 0x00	; 0
     a44:	50 e0       	ldi	r21, 0x00	; 0
     a46:	28 2b       	or	r18, r24
     a48:	39 2b       	or	r19, r25
     a4a:	4a 2b       	or	r20, r26
     a4c:	5b 2b       	or	r21, r27
	int_val = ((int_val<<4) | iv5);
     a4e:	64 e0       	ldi	r22, 0x04	; 4
     a50:	22 0f       	add	r18, r18
     a52:	33 1f       	adc	r19, r19
     a54:	44 1f       	adc	r20, r20
     a56:	55 1f       	adc	r21, r21
     a58:	6a 95       	dec	r22
     a5a:	d1 f7       	brne	.-12     	; 0xa50 <retConv_s32+0x12c>
     a5c:	81 2f       	mov	r24, r17
     a5e:	90 e0       	ldi	r25, 0x00	; 0
     a60:	a0 e0       	ldi	r26, 0x00	; 0
     a62:	b0 e0       	ldi	r27, 0x00	; 0
     a64:	82 2b       	or	r24, r18
     a66:	93 2b       	or	r25, r19
     a68:	a4 2b       	or	r26, r20
     a6a:	b5 2b       	or	r27, r21
	int_val = ((int_val<<4) | iv6);
     a6c:	24 e0       	ldi	r18, 0x04	; 4
     a6e:	88 0f       	add	r24, r24
     a70:	99 1f       	adc	r25, r25
     a72:	aa 1f       	adc	r26, r26
     a74:	bb 1f       	adc	r27, r27
     a76:	2a 95       	dec	r18
     a78:	d1 f7       	brne	.-12     	; 0xa6e <retConv_s32+0x14a>
     a7a:	20 2f       	mov	r18, r16
     a7c:	30 e0       	ldi	r19, 0x00	; 0
     a7e:	40 e0       	ldi	r20, 0x00	; 0
     a80:	50 e0       	ldi	r21, 0x00	; 0
     a82:	28 2b       	or	r18, r24
     a84:	39 2b       	or	r19, r25
     a86:	4a 2b       	or	r20, r26
     a88:	5b 2b       	or	r21, r27
	int_val = ((int_val<<4) | iv7);
     a8a:	04 e0       	ldi	r16, 0x04	; 4
     a8c:	22 0f       	add	r18, r18
     a8e:	33 1f       	adc	r19, r19
     a90:	44 1f       	adc	r20, r20
     a92:	55 1f       	adc	r21, r21
     a94:	0a 95       	dec	r16
     a96:	d1 f7       	brne	.-12     	; 0xa8c <retConv_s32+0x168>
     a98:	8f 2d       	mov	r24, r15
     a9a:	90 e0       	ldi	r25, 0x00	; 0
     a9c:	a0 e0       	ldi	r26, 0x00	; 0
     a9e:	b0 e0       	ldi	r27, 0x00	; 0
     aa0:	82 2b       	or	r24, r18
     aa2:	93 2b       	or	r25, r19
     aa4:	a4 2b       	or	r26, r20
     aa6:	b5 2b       	or	r27, r21
	int_val = ((int_val<<4) | iv8);
     aa8:	14 e0       	ldi	r17, 0x04	; 4
     aaa:	88 0f       	add	r24, r24
     aac:	99 1f       	adc	r25, r25
     aae:	aa 1f       	adc	r26, r26
     ab0:	bb 1f       	adc	r27, r27
     ab2:	1a 95       	dec	r17
     ab4:	d1 f7       	brne	.-12     	; 0xaaa <retConv_s32+0x186>
     ab6:	2e 2f       	mov	r18, r30
     ab8:	30 e0       	ldi	r19, 0x00	; 0
     aba:	40 e0       	ldi	r20, 0x00	; 0
     abc:	50 e0       	ldi	r21, 0x00	; 0
     abe:	28 2b       	or	r18, r24
     ac0:	39 2b       	or	r19, r25
     ac2:	4a 2b       	or	r20, r26
     ac4:	5b 2b       	or	r21, r27
	return int_val;
}
     ac6:	b9 01       	movw	r22, r18
     ac8:	ca 01       	movw	r24, r20
     aca:	1f 91       	pop	r17
     acc:	0f 91       	pop	r16
     ace:	ff 90       	pop	r15
     ad0:	08 95       	ret

00000ad2 <LDSRcv>:
		
}
*/
void LDSRcv(unsigned char c){
	//if( (c != 0xff) && (lds_buffer_write_ndx != NULL) && (lds_buffer_write_ndx > lds_buffer_read_ndx)){
	if(c != 0xff){
     ad2:	8f 3f       	cpi	r24, 0xFF	; 255
     ad4:	b9 f0       	breq	.+46     	; 0xb04 <LDSRcv+0x32>
		*lds_buffer_write_ndx = c;
     ad6:	e0 91 98 02 	lds	r30, 0x0298
     ada:	f0 91 99 02 	lds	r31, 0x0299
     ade:	80 83       	st	Z, r24
		lds_buffer_write_ndx++;		
     ae0:	80 91 98 02 	lds	r24, 0x0298
     ae4:	90 91 99 02 	lds	r25, 0x0299
     ae8:	01 96       	adiw	r24, 0x01	; 1
     aea:	90 93 99 02 	sts	0x0299, r25
     aee:	80 93 98 02 	sts	0x0298, r24
		if(lds_buffer_write_ndx >= (lds_buffer + BUFFER_SIZE)){ 
     af2:	82 50       	subi	r24, 0x02	; 2
     af4:	98 41       	sbci	r25, 0x18	; 24
     af6:	30 f0       	brcs	.+12     	; 0xb04 <LDSRcv+0x32>
			lds_buffer_write_ndx = lds_buffer;
     af8:	82 e0       	ldi	r24, 0x02	; 2
     afa:	94 e1       	ldi	r25, 0x14	; 20
     afc:	90 93 99 02 	sts	0x0299, r25
     b00:	80 93 98 02 	sts	0x0298, r24
     b04:	08 95       	ret

00000b06 <error_checker>:
		lds_buffer_read_ndx = lds_buffer;
	}
	return data;
}

uint8_t error_checker(const uint16_t chk_data[], uint16_t checksum){
     b06:	0f 93       	push	r16
     b08:	1f 93       	push	r17
     b0a:	cf 93       	push	r28
     b0c:	df 93       	push	r29
     b0e:	ec 01       	movw	r28, r24
     b10:	8b 01       	movw	r16, r22
     b12:	20 e0       	ldi	r18, 0x00	; 0
     b14:	30 e0       	ldi	r19, 0x00	; 0
     b16:	40 e0       	ldi	r20, 0x00	; 0
     b18:	50 e0       	ldi	r21, 0x00	; 0
     b1a:	60 e0       	ldi	r22, 0x00	; 0
     b1c:	70 e0       	ldi	r23, 0x00	; 0
    uint32_t chk32 = 0;
    for(uint8_t ndx = 0; ndx < 10; ndx++){
      chk32 = (chk32 << 1) + chk_data[ndx];
     b1e:	22 0f       	add	r18, r18
     b20:	33 1f       	adc	r19, r19
     b22:	44 1f       	adc	r20, r20
     b24:	55 1f       	adc	r21, r21
     b26:	fe 01       	movw	r30, r28
     b28:	e6 0f       	add	r30, r22
     b2a:	f7 1f       	adc	r31, r23
     b2c:	80 81       	ld	r24, Z
     b2e:	91 81       	ldd	r25, Z+1	; 0x01
     b30:	a0 e0       	ldi	r26, 0x00	; 0
     b32:	b0 e0       	ldi	r27, 0x00	; 0
     b34:	28 0f       	add	r18, r24
     b36:	39 1f       	adc	r19, r25
     b38:	4a 1f       	adc	r20, r26
     b3a:	5b 1f       	adc	r21, r27
     b3c:	6e 5f       	subi	r22, 0xFE	; 254
     b3e:	7f 4f       	sbci	r23, 0xFF	; 255
	return data;
}

uint8_t error_checker(const uint16_t chk_data[], uint16_t checksum){
    uint32_t chk32 = 0;
    for(uint8_t ndx = 0; ndx < 10; ndx++){
     b40:	64 31       	cpi	r22, 0x14	; 20
     b42:	71 05       	cpc	r23, r1
     b44:	61 f7       	brne	.-40     	; 0xb1e <error_checker+0x18>
      chk32 = (chk32 << 1) + chk_data[ndx];
    }
    uint16_t chk16 = (chk32 & 0x7FFF) + (chk32 >> 15);
     b46:	c9 01       	movw	r24, r18
     b48:	9f 77       	andi	r25, 0x7F	; 127
     b4a:	af e0       	ldi	r26, 0x0F	; 15
     b4c:	56 95       	lsr	r21
     b4e:	47 95       	ror	r20
     b50:	37 95       	ror	r19
     b52:	27 95       	ror	r18
     b54:	aa 95       	dec	r26
     b56:	d1 f7       	brne	.-12     	; 0xb4c <error_checker+0x46>
     b58:	82 0f       	add	r24, r18
     b5a:	93 1f       	adc	r25, r19
     b5c:	20 e0       	ldi	r18, 0x00	; 0
     b5e:	9f 77       	andi	r25, 0x7F	; 127
     b60:	80 17       	cp	r24, r16
     b62:	91 07       	cpc	r25, r17
     b64:	09 f4       	brne	.+2      	; 0xb68 <error_checker+0x62>
     b66:	21 e0       	ldi	r18, 0x01	; 1
    chk16 = chk16 & 0x7FFF;
    return (chk16 == checksum);
  }
     b68:	82 2f       	mov	r24, r18
     b6a:	df 91       	pop	r29
     b6c:	cf 91       	pop	r28
     b6e:	1f 91       	pop	r17
     b70:	0f 91       	pop	r16
     b72:	08 95       	ret

00000b74 <num2char>:





char num2char(char c){
     b74:	98 2f       	mov	r25, r24
	
	if(c <10){
     b76:	8a 30       	cpi	r24, 0x0A	; 10
     b78:	10 f4       	brcc	.+4      	; 0xb7e <num2char+0xa>
		c += 48;
     b7a:	90 5d       	subi	r25, 0xD0	; 208
     b7c:	04 c0       	rjmp	.+8      	; 0xb86 <num2char+0x12>
	}
	else if((c >= 10) && (c <= 16)){
     b7e:	8a 50       	subi	r24, 0x0A	; 10
     b80:	87 30       	cpi	r24, 0x07	; 7
     b82:	08 f4       	brcc	.+2      	; 0xb86 <num2char+0x12>
		c += 55;
     b84:	99 5c       	subi	r25, 0xC9	; 201
	}
	return c;
}
     b86:	89 2f       	mov	r24, r25
     b88:	08 95       	ret

00000b8a <print_frame>:
	uart3SendByte(r1);
	uart3SendByte('\n'); //line feed
}


void print_frame(LDS_FRAME frame){
     b8a:	bf 92       	push	r11
     b8c:	cf 92       	push	r12
     b8e:	df 92       	push	r13
     b90:	ef 92       	push	r14
     b92:	ff 92       	push	r15
     b94:	0f 93       	push	r16
     b96:	1f 93       	push	r17
     b98:	df 93       	push	r29
     b9a:	cf 93       	push	r28
     b9c:	cd b7       	in	r28, 0x3d	; 61
     b9e:	de b7       	in	r29, 0x3e	; 62
     ba0:	0c 85       	ldd	r16, Y+12	; 0x0c
     ba2:	ed 84       	ldd	r14, Y+13	; 0x0d
     ba4:	fe 84       	ldd	r15, Y+14	; 0x0e
	rprintf("Index: ");
     ba6:	00 d0       	rcall	.+0      	; 0xba8 <print_frame+0x1e>
     ba8:	0f 92       	push	r0
     baa:	11 e0       	ldi	r17, 0x01	; 1
     bac:	ed b7       	in	r30, 0x3d	; 61
     bae:	fe b7       	in	r31, 0x3e	; 62
     bb0:	11 83       	std	Z+1, r17	; 0x01
     bb2:	89 e2       	ldi	r24, 0x29	; 41
     bb4:	91 e0       	ldi	r25, 0x01	; 1
     bb6:	93 83       	std	Z+3, r25	; 0x03
     bb8:	82 83       	std	Z+2, r24	; 0x02
     bba:	0e 94 8b 22 	call	0x4516	; 0x4516 <rprintf1RamRom>
	rprintfu08(frame.index);
     bbe:	0f 90       	pop	r0
     bc0:	0f 90       	pop	r0
     bc2:	0f 90       	pop	r0
     bc4:	80 2f       	mov	r24, r16
     bc6:	0e 94 da 20 	call	0x41b4	; 0x41b4 <rprintfu08>
	rprintf(" Motor Speed: ");
     bca:	00 d0       	rcall	.+0      	; 0xbcc <print_frame+0x42>
     bcc:	0f 92       	push	r0
     bce:	ed b7       	in	r30, 0x3d	; 61
     bd0:	fe b7       	in	r31, 0x3e	; 62
     bd2:	11 83       	std	Z+1, r17	; 0x01
     bd4:	8a e1       	ldi	r24, 0x1A	; 26
     bd6:	91 e0       	ldi	r25, 0x01	; 1
     bd8:	93 83       	std	Z+3, r25	; 0x03
     bda:	82 83       	std	Z+2, r24	; 0x02
     bdc:	0e 94 8b 22 	call	0x4516	; 0x4516 <rprintf1RamRom>
	rprintfu16(frame.motor_speed);
     be0:	0f 90       	pop	r0
     be2:	0f 90       	pop	r0
     be4:	0f 90       	pop	r0
     be6:	c7 01       	movw	r24, r14
     be8:	0e 94 e5 20 	call	0x41ca	; 0x41ca <rprintfu16>
	rprintf(" Distances: ");
     bec:	00 d0       	rcall	.+0      	; 0xbee <print_frame+0x64>
     bee:	0f 92       	push	r0
     bf0:	ed b7       	in	r30, 0x3d	; 61
     bf2:	fe b7       	in	r31, 0x3e	; 62
     bf4:	11 83       	std	Z+1, r17	; 0x01
     bf6:	8d e0       	ldi	r24, 0x0D	; 13
     bf8:	91 e0       	ldi	r25, 0x01	; 1
     bfa:	93 83       	std	Z+3, r25	; 0x03
     bfc:	82 83       	std	Z+2, r24	; 0x02
     bfe:	0e 94 8b 22 	call	0x4516	; 0x4516 <rprintf1RamRom>
     c02:	8e 01       	movw	r16, r28
     c04:	09 5e       	subi	r16, 0xE9	; 233
     c06:	1f 4f       	sbci	r17, 0xFF	; 255
     c08:	0f 90       	pop	r0
     c0a:	0f 90       	pop	r0
     c0c:	0f 90       	pop	r0
	for(uint8_t ndx = 0; ndx < 4; ndx++){
		rprintfu16(frame.distance[ndx]);
		rprintf(" ");
     c0e:	bb 24       	eor	r11, r11
     c10:	b3 94       	inc	r11
     c12:	9b e0       	ldi	r25, 0x0B	; 11
     c14:	c9 2e       	mov	r12, r25
     c16:	91 e0       	ldi	r25, 0x01	; 1
     c18:	d9 2e       	mov	r13, r25
	rprintf("Index: ");
	rprintfu08(frame.index);
	rprintf(" Motor Speed: ");
	rprintfu16(frame.motor_speed);
	rprintf(" Distances: ");
	for(uint8_t ndx = 0; ndx < 4; ndx++){
     c1a:	8f e1       	ldi	r24, 0x1F	; 31
     c1c:	e8 2e       	mov	r14, r24
     c1e:	f1 2c       	mov	r15, r1
     c20:	ec 0e       	add	r14, r28
     c22:	fd 1e       	adc	r15, r29
		rprintfu16(frame.distance[ndx]);
     c24:	f8 01       	movw	r30, r16
     c26:	81 91       	ld	r24, Z+
     c28:	91 91       	ld	r25, Z+
     c2a:	8f 01       	movw	r16, r30
     c2c:	0e 94 e5 20 	call	0x41ca	; 0x41ca <rprintfu16>
		rprintf(" ");
     c30:	00 d0       	rcall	.+0      	; 0xc32 <print_frame+0xa8>
     c32:	0f 92       	push	r0
     c34:	ed b7       	in	r30, 0x3d	; 61
     c36:	fe b7       	in	r31, 0x3e	; 62
     c38:	b1 82       	std	Z+1, r11	; 0x01
     c3a:	d3 82       	std	Z+3, r13	; 0x03
     c3c:	c2 82       	std	Z+2, r12	; 0x02
     c3e:	0e 94 8b 22 	call	0x4516	; 0x4516 <rprintf1RamRom>
	rprintf("Index: ");
	rprintfu08(frame.index);
	rprintf(" Motor Speed: ");
	rprintfu16(frame.motor_speed);
	rprintf(" Distances: ");
	for(uint8_t ndx = 0; ndx < 4; ndx++){
     c42:	0f 90       	pop	r0
     c44:	0f 90       	pop	r0
     c46:	0f 90       	pop	r0
     c48:	0e 15       	cp	r16, r14
     c4a:	1f 05       	cpc	r17, r15
     c4c:	59 f7       	brne	.-42     	; 0xc24 <print_frame+0x9a>
		rprintfu16(frame.distance[ndx]);
		rprintf(" ");
	}
	rprintfCRLF();
     c4e:	0e 94 cb 20 	call	0x4196	; 0x4196 <rprintfCRLF>
}
     c52:	cf 91       	pop	r28
     c54:	df 91       	pop	r29
     c56:	1f 91       	pop	r17
     c58:	0f 91       	pop	r16
     c5a:	ff 90       	pop	r15
     c5c:	ef 90       	pop	r14
     c5e:	df 90       	pop	r13
     c60:	cf 90       	pop	r12
     c62:	bf 90       	pop	r11
     c64:	08 95       	ret

00000c66 <send_frame>:
	}
	return c;
}


void send_frame(char flag, int16_t data){
     c66:	ff 92       	push	r15
     c68:	0f 93       	push	r16
     c6a:	1f 93       	push	r17
     c6c:	cf 93       	push	r28
     c6e:	df 93       	push	r29
     c70:	eb 01       	movw	r28, r22
	uint8_t r1 = 0;
	uint8_t r2 = 0;
	uint8_t r3 = 0;
	uint8_t r4 = 0;

	uart3SendByte(flag);
     c72:	0e 94 80 1b 	call	0x3700	; 0x3700 <uart3SendByte>

	r1 = num2char(0x0F & (uint8_t)data);
     c76:	5f e0       	ldi	r21, 0x0F	; 15
     c78:	f5 2e       	mov	r15, r21
     c7a:	fc 22       	and	r15, r28



char num2char(char c){
	
	if(c <10){
     c7c:	89 e0       	ldi	r24, 0x09	; 9
     c7e:	8f 15       	cp	r24, r15
     c80:	18 f0       	brcs	.+6      	; 0xc88 <send_frame+0x22>
		c += 48;
     c82:	90 e3       	ldi	r25, 0x30	; 48
     c84:	f9 0e       	add	r15, r25
     c86:	06 c0       	rjmp	.+12     	; 0xc94 <send_frame+0x2e>
	}
	else if((c >= 10) && (c <= 16)){
     c88:	8f 2d       	mov	r24, r15
     c8a:	8a 50       	subi	r24, 0x0A	; 10
     c8c:	87 30       	cpi	r24, 0x07	; 7
     c8e:	10 f4       	brcc	.+4      	; 0xc94 <send_frame+0x2e>
		c += 55;
     c90:	87 e3       	ldi	r24, 0x37	; 55
     c92:	f8 0e       	add	r15, r24
	uint8_t r4 = 0;

	uart3SendByte(flag);

	r1 = num2char(0x0F & (uint8_t)data);
	r2 = num2char(0x0F & ((uint8_t)(data >> 4)) );
     c94:	ce 01       	movw	r24, r28
     c96:	44 e0       	ldi	r20, 0x04	; 4
     c98:	95 95       	asr	r25
     c9a:	87 95       	ror	r24
     c9c:	4a 95       	dec	r20
     c9e:	e1 f7       	brne	.-8      	; 0xc98 <send_frame+0x32>
     ca0:	08 2f       	mov	r16, r24
     ca2:	0f 70       	andi	r16, 0x0F	; 15



char num2char(char c){
	
	if(c <10){
     ca4:	0a 30       	cpi	r16, 0x0A	; 10
     ca6:	10 f4       	brcc	.+4      	; 0xcac <send_frame+0x46>
		c += 48;
     ca8:	00 5d       	subi	r16, 0xD0	; 208
     caa:	05 c0       	rjmp	.+10     	; 0xcb6 <send_frame+0x50>
	}
	else if((c >= 10) && (c <= 16)){
     cac:	80 2f       	mov	r24, r16
     cae:	8a 50       	subi	r24, 0x0A	; 10
     cb0:	87 30       	cpi	r24, 0x07	; 7
     cb2:	08 f4       	brcc	.+2      	; 0xcb6 <send_frame+0x50>
		c += 55;
     cb4:	09 5c       	subi	r16, 0xC9	; 201

	uart3SendByte(flag);

	r1 = num2char(0x0F & (uint8_t)data);
	r2 = num2char(0x0F & ((uint8_t)(data >> 4)) );
	r3 = num2char(0x0F & ((uint8_t)(data >> 8)) );
     cb6:	8d 2f       	mov	r24, r29
     cb8:	99 27       	eor	r25, r25
     cba:	87 fd       	sbrc	r24, 7
     cbc:	9a 95       	dec	r25
     cbe:	18 2f       	mov	r17, r24
     cc0:	1f 70       	andi	r17, 0x0F	; 15



char num2char(char c){
	
	if(c <10){
     cc2:	1a 30       	cpi	r17, 0x0A	; 10
     cc4:	10 f4       	brcc	.+4      	; 0xcca <send_frame+0x64>
		c += 48;
     cc6:	10 5d       	subi	r17, 0xD0	; 208
     cc8:	05 c0       	rjmp	.+10     	; 0xcd4 <send_frame+0x6e>
	}
	else if((c >= 10) && (c <= 16)){
     cca:	81 2f       	mov	r24, r17
     ccc:	8a 50       	subi	r24, 0x0A	; 10
     cce:	87 30       	cpi	r24, 0x07	; 7
     cd0:	08 f4       	brcc	.+2      	; 0xcd4 <send_frame+0x6e>
		c += 55;
     cd2:	19 5c       	subi	r17, 0xC9	; 201
	uart3SendByte(flag);

	r1 = num2char(0x0F & (uint8_t)data);
	r2 = num2char(0x0F & ((uint8_t)(data >> 4)) );
	r3 = num2char(0x0F & ((uint8_t)(data >> 8)) );
	r4 = num2char(0x0F & ((uint8_t)(data >> 12)) );
     cd4:	c0 e1       	ldi	r28, 0x10	; 16
     cd6:	dc 02       	muls	r29, r28
     cd8:	c1 2d       	mov	r28, r1
     cda:	dd 0b       	sbc	r29, r29
     cdc:	11 24       	eor	r1, r1
     cde:	ce 01       	movw	r24, r28
     ce0:	8f 70       	andi	r24, 0x0F	; 15
     ce2:	68 2f       	mov	r22, r24



char num2char(char c){
	
	if(c <10){
     ce4:	8a 30       	cpi	r24, 0x0A	; 10
     ce6:	10 f4       	brcc	.+4      	; 0xcec <send_frame+0x86>
		c += 48;
     ce8:	60 5d       	subi	r22, 0xD0	; 208
     cea:	04 c0       	rjmp	.+8      	; 0xcf4 <send_frame+0x8e>
	}
	else if((c >= 10) && (c <= 16)){
     cec:	8a 50       	subi	r24, 0x0A	; 10
     cee:	87 30       	cpi	r24, 0x07	; 7
     cf0:	08 f4       	brcc	.+2      	; 0xcf4 <send_frame+0x8e>
		c += 55;
     cf2:	69 5c       	subi	r22, 0xC9	; 201
	r1 = num2char(0x0F & (uint8_t)data);
	r2 = num2char(0x0F & ((uint8_t)(data >> 4)) );
	r3 = num2char(0x0F & ((uint8_t)(data >> 8)) );
	r4 = num2char(0x0F & ((uint8_t)(data >> 12)) );

	uart3SendByte(r4);
     cf4:	86 2f       	mov	r24, r22
     cf6:	0e 94 80 1b 	call	0x3700	; 0x3700 <uart3SendByte>
	uart3SendByte(r3);
     cfa:	81 2f       	mov	r24, r17
     cfc:	0e 94 80 1b 	call	0x3700	; 0x3700 <uart3SendByte>
	uart3SendByte(r2);
     d00:	80 2f       	mov	r24, r16
     d02:	0e 94 80 1b 	call	0x3700	; 0x3700 <uart3SendByte>
	uart3SendByte(r1);
     d06:	8f 2d       	mov	r24, r15
     d08:	0e 94 80 1b 	call	0x3700	; 0x3700 <uart3SendByte>
	uart3SendByte('\n'); //line feed
     d0c:	8a e0       	ldi	r24, 0x0A	; 10
     d0e:	0e 94 80 1b 	call	0x3700	; 0x3700 <uart3SendByte>
}
     d12:	df 91       	pop	r29
     d14:	cf 91       	pop	r28
     d16:	1f 91       	pop	r17
     d18:	0f 91       	pop	r16
     d1a:	ff 90       	pop	r15
     d1c:	08 95       	ret

00000d1e <prvSetupHardware>:
    
    return error_checker(chk_data, frame->checksum);
}  


void prvSetupHardware(){
     d1e:	0f 93       	push	r16
     d20:	1f 93       	push	r17
     d22:	cf 93       	push	r28
     d24:	df 93       	push	r29
	delay_cycles(65535);
	delay_cycles(65535);
	
	

	uartInit();  // initialize the UART (serial port)
     d26:	0e 94 23 1f 	call	0x3e46	; 0x3e46 <uartInit>
    uartSetBaudRate(0, 38400); // set UARTE speed, for Bluetooth
     d2a:	80 e0       	ldi	r24, 0x00	; 0
     d2c:	40 e0       	ldi	r20, 0x00	; 0
     d2e:	56 e9       	ldi	r21, 0x96	; 150
     d30:	60 e0       	ldi	r22, 0x00	; 0
     d32:	70 e0       	ldi	r23, 0x00	; 0
     d34:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <uartSetBaudRate>
    uartSetBaudRate(1, 115200); // set UARTD speed, for USB connection, up to 500k, try 115200 if it doesn't work
     d38:	81 e0       	ldi	r24, 0x01	; 1
     d3a:	40 e0       	ldi	r20, 0x00	; 0
     d3c:	52 ec       	ldi	r21, 0xC2	; 194
     d3e:	61 e0       	ldi	r22, 0x01	; 1
     d40:	70 e0       	ldi	r23, 0x00	; 0
     d42:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <uartSetBaudRate>
    uartSetBaudRate(2, 38400); // set UARTH speed
     d46:	82 e0       	ldi	r24, 0x02	; 2
     d48:	40 e0       	ldi	r20, 0x00	; 0
     d4a:	56 e9       	ldi	r21, 0x96	; 150
     d4c:	60 e0       	ldi	r22, 0x00	; 0
     d4e:	70 e0       	ldi	r23, 0x00	; 0
     d50:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <uartSetBaudRate>
    uartSetBaudRate(3, 115200); // set UARTJ speed, for Blackfin
     d54:	83 e0       	ldi	r24, 0x03	; 3
     d56:	40 e0       	ldi	r20, 0x00	; 0
     d58:	52 ec       	ldi	r21, 0xC2	; 194
     d5a:	61 e0       	ldi	r22, 0x01	; 1
     d5c:	70 e0       	ldi	r23, 0x00	; 0
     d5e:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <uartSetBaudRate>
	//G=Ground, T=Tx (connect to external Rx), R=Rx (connect to external Tx)

	rprintfInit(uart1SendByte);// initialize rprintf system and configure uart1 (USB) for rprintf
     d62:	86 e7       	ldi	r24, 0x76	; 118
     d64:	9b e1       	ldi	r25, 0x1B	; 27
     d66:	0e 94 67 20 	call	0x40ce	; 0x40ce <rprintfInit>

	configure_ports(); // configure which ports are analog, digital, etc.
     d6a:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <configure_ports>
	
	//UART ISR *** UART ISR ***
	
//	uartSetRxHandler(2, &fwdSer_L);
//	uartSetRxHandler(0, &fwdSer_R);
	uartSetRxHandler(3, &LDSRcv);
     d6e:	83 e0       	ldi	r24, 0x03	; 3
     d70:	69 e6       	ldi	r22, 0x69	; 105
     d72:	75 e0       	ldi	r23, 0x05	; 5
     d74:	0e 94 f2 1a 	call	0x35e4	; 0x35e4 <uartSetRxHandler>
//***************STATUS LED**************
//tank test
void LED_off(void)
	{PORT_ON(PORTB,6);}
void LED_on(void)
	{PORT_OFF(PORTB,6);}
     d78:	2e 98       	cbi	0x05, 6	; 5

	//UART ISR *** UART ISR ***

	LED_on();

	rprintf("\r\nSystem Warmed Up");
     d7a:	00 d0       	rcall	.+0      	; 0xd7c <prvSetupHardware+0x5e>
     d7c:	0f 92       	push	r0
     d7e:	81 e0       	ldi	r24, 0x01	; 1
     d80:	ed b7       	in	r30, 0x3d	; 61
     d82:	fe b7       	in	r31, 0x3e	; 62
     d84:	81 83       	std	Z+1, r24	; 0x01
     d86:	8e e4       	ldi	r24, 0x4E	; 78
     d88:	91 e0       	ldi	r25, 0x01	; 1
     d8a:	93 83       	std	Z+3, r25	; 0x03
     d8c:	82 83       	std	Z+2, r24	; 0x02
     d8e:	0e 94 8b 22 	call	0x4516	; 0x4516 <rprintf1RamRom>

	// initialize the timer system
 	init_timer0(TIMER_CLK_1024);
     d92:	0f 90       	pop	r0
     d94:	0f 90       	pop	r0
     d96:	0f 90       	pop	r0
     d98:	85 e0       	ldi	r24, 0x05	; 5
     d9a:	0e 94 09 15 	call	0x2a12	; 0x2a12 <init_timer0>
// 	init_timer1(TIMER_CLK_64); // Timer 1 is initialized by FreeRTOS
 	//init_timer2(TIMER2_CLK_64);
	init_timer2(TIMER2_CLK_1024);
     d9e:	87 e0       	ldi	r24, 0x07	; 7
     da0:	0e 94 29 15 	call	0x2a52	; 0x2a52 <init_timer2>
 	init_timer3(TIMER_CLK_64);
     da4:	83 e0       	ldi	r24, 0x03	; 3
     da6:	0e 94 39 15 	call	0x2a72	; 0x2a72 <init_timer3>
 	init_timer4(TIMER_CLK_64);
     daa:	83 e0       	ldi	r24, 0x03	; 3
     dac:	0e 94 4b 15 	call	0x2a96	; 0x2a96 <init_timer4>
 	init_timer5(TIMER_CLK_64);
     db0:	83 e0       	ldi	r24, 0x03	; 3
     db2:	0e 94 5d 15 	call	0x2aba	; 0x2aba <init_timer5>

	a2dInit(); // initialize analog to digital converter (ADC)
     db6:	0e 94 dc 1f 	call	0x3fb8	; 0x3fb8 <a2dInit>
	a2dSetPrescaler(ADC_PRESCALE_DIV32); // configure ADC scaling
     dba:	85 e0       	ldi	r24, 0x05	; 5
     dbc:	0e 94 01 20 	call	0x4002	; 0x4002 <a2dSetPrescaler>
	a2dSetReference(ADC_REFERENCE_AVCC); // configure ADC reference voltage
     dc0:	81 e0       	ldi	r24, 0x01	; 1
     dc2:	0e 94 08 20 	call	0x4010	; 0x4010 <a2dSetReference>
     dc6:	10 e0       	ldi	r17, 0x00	; 0
	//let system stabelize for X time
	for(i=0;i<16;i++)
		{
		j=a2dConvert8bit(i);//read each ADC once to get it working accurately
		delay_cycles(5000); //keep LED on long enough to see Axon reseting
		rprintf(".");
     dc8:	01 e0       	ldi	r16, 0x01	; 1
     dca:	cc e4       	ldi	r28, 0x4C	; 76
     dcc:	d1 e0       	ldi	r29, 0x01	; 1
	a2dSetReference(ADC_REFERENCE_AVCC); // configure ADC reference voltage

	//let system stabelize for X time
	for(i=0;i<16;i++)
		{
		j=a2dConvert8bit(i);//read each ADC once to get it working accurately
     dce:	81 2f       	mov	r24, r17
     dd0:	0e 94 51 20 	call	0x40a2	; 0x40a2 <a2dConvert8bit>
		delay_cycles(5000); //keep LED on long enough to see Axon reseting
		rprintf(".");
     dd4:	00 d0       	rcall	.+0      	; 0xdd6 <prvSetupHardware+0xb8>
     dd6:	0f 92       	push	r0
     dd8:	ed b7       	in	r30, 0x3d	; 61
     dda:	fe b7       	in	r31, 0x3e	; 62
     ddc:	01 83       	std	Z+1, r16	; 0x01
     dde:	d3 83       	std	Z+3, r29	; 0x03
     de0:	c2 83       	std	Z+2, r28	; 0x02
     de2:	0e 94 8b 22 	call	0x4516	; 0x4516 <rprintf1RamRom>
     de6:	1f 5f       	subi	r17, 0xFF	; 255
	a2dInit(); // initialize analog to digital converter (ADC)
	a2dSetPrescaler(ADC_PRESCALE_DIV32); // configure ADC scaling
	a2dSetReference(ADC_REFERENCE_AVCC); // configure ADC reference voltage

	//let system stabelize for X time
	for(i=0;i<16;i++)
     de8:	0f 90       	pop	r0
     dea:	0f 90       	pop	r0
     dec:	0f 90       	pop	r0
     dee:	10 31       	cpi	r17, 0x10	; 16
     df0:	71 f7       	brne	.-36     	; 0xdce <prvSetupHardware+0xb0>


//***************STATUS LED**************
//tank test
void LED_off(void)
	{PORT_ON(PORTB,6);}
     df2:	2e 9a       	sbi	0x05, 6	; 5
		rprintf(".");
		}

	LED_off();

	rprintf("Initialization Complete \r\n");
     df4:	00 d0       	rcall	.+0      	; 0xdf6 <prvSetupHardware+0xd8>
     df6:	0f 92       	push	r0
     df8:	ed b7       	in	r30, 0x3d	; 61
     dfa:	fe b7       	in	r31, 0x3e	; 62
     dfc:	01 83       	std	Z+1, r16	; 0x01
     dfe:	81 e3       	ldi	r24, 0x31	; 49
     e00:	91 e0       	ldi	r25, 0x01	; 1
     e02:	93 83       	std	Z+3, r25	; 0x03
     e04:	82 83       	std	Z+2, r24	; 0x02
     e06:	0e 94 8b 22 	call	0x4516	; 0x4516 <rprintf1RamRom>

	//reset all timers to zero
	reset_timer0();
     e0a:	0f 90       	pop	r0
     e0c:	0f 90       	pop	r0
     e0e:	0f 90       	pop	r0
     e10:	0e 94 bf 14 	call	0x297e	; 0x297e <reset_timer0>
	reset_timer1();
     e14:	0e 94 c9 14 	call	0x2992	; 0x2992 <reset_timer1>
	reset_timer2();
     e18:	0e 94 d6 14 	call	0x29ac	; 0x29ac <reset_timer2>
	reset_timer3();
     e1c:	0e 94 e1 14 	call	0x29c2	; 0x29c2 <reset_timer3>
	reset_timer4();
     e20:	0e 94 ee 14 	call	0x29dc	; 0x29dc <reset_timer4>
	reset_timer5();
     e24:	0e 94 fb 14 	call	0x29f6	; 0x29f6 <reset_timer5>



	/********PWM Setup***********/
	prvPWMSetup();
     e28:	0e 94 2a 04 	call	0x854	; 0x854 <prvPWMSetup>

}
     e2c:	df 91       	pop	r29
     e2e:	cf 91       	pop	r28
     e30:	1f 91       	pop	r17
     e32:	0f 91       	pop	r16
     e34:	08 95       	ret

00000e36 <read_LDS>:
		}
	}

}

uint8_t read_LDS(){
     e36:	04 c0       	rjmp	.+8      	; 0xe40 <read_LDS+0xa>
	while(lds_buffer_read_ndx == lds_buffer_write_ndx){ delay_us(10); };
     e38:	8a e0       	ldi	r24, 0x0A	; 10
     e3a:	90 e0       	ldi	r25, 0x00	; 0
     e3c:	0e 94 08 15 	call	0x2a10	; 0x2a10 <delay_us>
     e40:	e0 91 9a 02 	lds	r30, 0x029A
     e44:	f0 91 9b 02 	lds	r31, 0x029B
     e48:	80 91 98 02 	lds	r24, 0x0298
     e4c:	90 91 99 02 	lds	r25, 0x0299
     e50:	e8 17       	cp	r30, r24
     e52:	f9 07       	cpc	r31, r25
     e54:	89 f3       	breq	.-30     	; 0xe38 <read_LDS+0x2>
	uint8_t data = *lds_buffer_read_ndx;
     e56:	21 91       	ld	r18, Z+
	lds_buffer_read_ndx++;
     e58:	f0 93 9b 02 	sts	0x029B, r31
     e5c:	e0 93 9a 02 	sts	0x029A, r30
	if(lds_buffer_read_ndx >= (lds_buffer + BUFFER_SIZE)){ 
     e60:	e2 50       	subi	r30, 0x02	; 2
     e62:	f8 41       	sbci	r31, 0x18	; 24
     e64:	30 f0       	brcs	.+12     	; 0xe72 <read_LDS+0x3c>
		lds_buffer_read_ndx = lds_buffer;
     e66:	82 e0       	ldi	r24, 0x02	; 2
     e68:	94 e1       	ldi	r25, 0x14	; 20
     e6a:	90 93 9b 02 	sts	0x029B, r25
     e6e:	80 93 9a 02 	sts	0x029A, r24
	}
	return data;
}
     e72:	82 2f       	mov	r24, r18
     e74:	08 95       	ret

00000e76 <parse_frame>:
    uint16_t chk16 = (chk32 & 0x7FFF) + (chk32 >> 15);
    chk16 = chk16 & 0x7FFF;
    return (chk16 == checksum);
  }

uint8_t parse_frame(LDS_FRAME *frame){
     e76:	2f 92       	push	r2
     e78:	3f 92       	push	r3
     e7a:	4f 92       	push	r4
     e7c:	5f 92       	push	r5
     e7e:	6f 92       	push	r6
     e80:	7f 92       	push	r7
     e82:	8f 92       	push	r8
     e84:	9f 92       	push	r9
     e86:	af 92       	push	r10
     e88:	bf 92       	push	r11
     e8a:	cf 92       	push	r12
     e8c:	df 92       	push	r13
     e8e:	ef 92       	push	r14
     e90:	ff 92       	push	r15
     e92:	0f 93       	push	r16
     e94:	1f 93       	push	r17
     e96:	df 93       	push	r29
     e98:	cf 93       	push	r28
     e9a:	cd b7       	in	r28, 0x3d	; 61
     e9c:	de b7       	in	r29, 0x3e	; 62
     e9e:	6a 97       	sbiw	r28, 0x1a	; 26
     ea0:	0f b6       	in	r0, 0x3f	; 63
     ea2:	f8 94       	cli
     ea4:	de bf       	out	0x3e, r29	; 62
     ea6:	0f be       	out	0x3f, r0	; 63
     ea8:	cd bf       	out	0x3d, r28	; 61
     eaa:	2c 01       	movw	r4, r24
    // Array for use by the error checker
    uint16_t chk_data[10];

    // Read start byte
    uint8_t start_byte = read_LDS();
     eac:	0e 94 1b 07 	call	0xe36	; 0xe36 <read_LDS>
    // If the byte read in is not the start byte (0xFA), then this is not the beginning of a frame
    if(start_byte != 0xFA) return FALSE; 
     eb0:	8a 3f       	cpi	r24, 0xFA	; 250
     eb2:	09 f0       	breq	.+2      	; 0xeb6 <parse_frame+0x40>
     eb4:	ac c0       	rjmp	.+344    	; 0x100e <parse_frame+0x198>

    // Read index
	frame->index = read_LDS();
     eb6:	0e 94 1b 07 	call	0xe36	; 0xe36 <read_LDS>
     eba:	28 2f       	mov	r18, r24
     ebc:	f2 01       	movw	r30, r4
     ebe:	80 83       	st	Z, r24
    // If the byte proceeding the start byte does not look like an index, then is is not the beginning of a frame
    if((frame->index < 0xA0)||(frame->index > 0xF9)) return FALSE;
     ec0:	80 5a       	subi	r24, 0xA0	; 160
     ec2:	8a 35       	cpi	r24, 0x5A	; 90
     ec4:	08 f0       	brcs	.+2      	; 0xec8 <parse_frame+0x52>
     ec6:	a3 c0       	rjmp	.+326    	; 0x100e <parse_frame+0x198>

    // Add these bytes for the error checker
    chk_data[0] = (frame->index << 8) + start_byte;
     ec8:	92 2f       	mov	r25, r18
     eca:	80 e0       	ldi	r24, 0x00	; 0
     ecc:	86 50       	subi	r24, 0x06	; 6
     ece:	9f 4f       	sbci	r25, 0xFF	; 255
     ed0:	9e 83       	std	Y+6, r25	; 0x06
     ed2:	8d 83       	std	Y+5, r24	; 0x05
    //   MSB                                                               LSB
    //   15  14  13  12  11  10  9   8   7   6    5    4    3    2    1    0
    //   512 256 128 64  32  16  8   4   2   1 .  1/2  1/4  1/8  1/16 1/32 1/64
    //
	//frame.motor_speed = (((uint16_t)read_LDS())<<8) + (uint16_t)read_LDS();
	frame->motor_speed = ((uint16_t)read_LDS()) + ((uint16_t)read_LDS()<<8);
     ed4:	0e 94 1b 07 	call	0xe36	; 0xe36 <read_LDS>
     ed8:	18 2f       	mov	r17, r24
     eda:	0e 94 1b 07 	call	0xe36	; 0xe36 <read_LDS>
     ede:	38 2f       	mov	r19, r24
     ee0:	20 e0       	ldi	r18, 0x00	; 0
     ee2:	21 0f       	add	r18, r17
     ee4:	31 1d       	adc	r19, r1
     ee6:	f2 01       	movw	r30, r4
     ee8:	32 83       	std	Z+2, r19	; 0x02
     eea:	21 83       	std	Z+1, r18	; 0x01
    // Add these bytes for the error checker
    chk_data[1] = frame->motor_speed;
     eec:	38 87       	std	Y+8, r19	; 0x08
     eee:	2f 83       	std	Y+7, r18	; 0x07
     ef0:	32 01       	movw	r6, r4
     ef2:	09 e0       	ldi	r16, 0x09	; 9
     ef4:	80 2e       	mov	r8, r16
     ef6:	91 2c       	mov	r9, r1
     ef8:	8c 0e       	add	r8, r28
     efa:	9d 1e       	adc	r9, r29
     efc:	62 01       	movw	r12, r4
				
    // Read distances, intensities, and flags
    for(uint8_t itr = 0; itr < 4; itr++) {
      // Read in the four distance and intensity bytes
      uint8_t di_bytes[4];
	  for(uint8_t d_ndx = 0; d_ndx < 4; d_ndx++){
     efe:	15 e0       	ldi	r17, 0x05	; 5
     f00:	21 2e       	mov	r2, r17
     f02:	31 2c       	mov	r3, r1
     f04:	2c 0e       	add	r2, r28
     f06:	3d 1e       	adc	r3, r29
    chk_data[1] = frame->motor_speed;
	//rprintfu16(frame.motor_speed);
	//rprintfCRLF();
				
    // Read distances, intensities, and flags
    for(uint8_t itr = 0; itr < 4; itr++) {
     f08:	ae 01       	movw	r20, r28
     f0a:	47 5e       	subi	r20, 0xE7	; 231
     f0c:	5f 4f       	sbci	r21, 0xFF	; 255
     f0e:	5a 8f       	std	Y+26, r21	; 0x1a
     f10:	49 8f       	std	Y+25, r20	; 0x19
     f12:	46 c0       	rjmp	.+140    	; 0xfa0 <parse_frame+0x12a>
      // Read in the four distance and intensity bytes
      uint8_t di_bytes[4];
	  for(uint8_t d_ndx = 0; d_ndx < 4; d_ndx++){
	  	di_bytes[d_ndx] = read_LDS();
     f14:	0e 94 1b 07 	call	0xe36	; 0xe36 <read_LDS>
     f18:	f8 01       	movw	r30, r16
     f1a:	81 93       	st	Z+, r24
     f1c:	8f 01       	movw	r16, r30
				
    // Read distances, intensities, and flags
    for(uint8_t itr = 0; itr < 4; itr++) {
      // Read in the four distance and intensity bytes
      uint8_t di_bytes[4];
	  for(uint8_t d_ndx = 0; d_ndx < 4; d_ndx++){
     f1e:	e2 15       	cp	r30, r2
     f20:	f3 05       	cpc	r31, r3
     f22:	c1 f7       	brne	.-16     	; 0xf14 <parse_frame+0x9e>
	  	di_bytes[d_ndx] = read_LDS();
      }
      // The invalid and strength flags are the MSB and adjacent bit of the second (indexwise) distance byte
      frame->invalid[itr] = (uint8_t)(di_bytes[1] & 0x80);
     f24:	4a 81       	ldd	r20, Y+2	; 0x02
     f26:	94 2f       	mov	r25, r20
     f28:	90 78       	andi	r25, 0x80	; 128
     f2a:	f3 01       	movw	r30, r6
     f2c:	93 83       	std	Z+3, r25	; 0x03
      frame->strength_warning[itr] = (uint8_t)(di_bytes[1] & 0x40);
     f2e:	84 2f       	mov	r24, r20
     f30:	80 74       	andi	r24, 0x40	; 64
     f32:	87 83       	std	Z+7, r24	; 0x07

      // Distance and intensity bytes are read in little endian, and therefore need to be switched and concatenated
      // The second distance byte (indexwise) is masked to eliminate the invalid and strength flags from the measurement
      if(frame->invalid[itr]){ // If this measurement is invalid, set it to zero
     f34:	99 23       	and	r25, r25
     f36:	21 f0       	breq	.+8      	; 0xf40 <parse_frame+0xca>
		frame->distance[itr]  = 0;
     f38:	f6 01       	movw	r30, r12
     f3a:	14 86       	std	Z+12, r1	; 0x0c
     f3c:	13 86       	std	Z+11, r1	; 0x0b
     f3e:	0c c0       	rjmp	.+24     	; 0xf58 <parse_frame+0xe2>
      }
      else{
		frame->distance[itr]  = ((di_bytes[1] & 0x3F) << 8) + di_bytes[0];
     f40:	84 2f       	mov	r24, r20
     f42:	90 e0       	ldi	r25, 0x00	; 0
     f44:	8f 73       	andi	r24, 0x3F	; 63
     f46:	90 70       	andi	r25, 0x00	; 0
     f48:	98 2f       	mov	r25, r24
     f4a:	88 27       	eor	r24, r24
     f4c:	29 81       	ldd	r18, Y+1	; 0x01
     f4e:	82 0f       	add	r24, r18
     f50:	91 1d       	adc	r25, r1
     f52:	f6 01       	movw	r30, r12
     f54:	94 87       	std	Z+12, r25	; 0x0c
     f56:	83 87       	std	Z+11, r24	; 0x0b
      }

      frame->intensity[itr] = (di_bytes[3] << 8) + di_bytes[2];
     f58:	bc 80       	ldd	r11, Y+4	; 0x04
     f5a:	aa 24       	eor	r10, r10
     f5c:	8b 81       	ldd	r24, Y+3	; 0x03
     f5e:	95 01       	movw	r18, r10
     f60:	28 0f       	add	r18, r24
     f62:	31 1d       	adc	r19, r1
     f64:	f6 01       	movw	r30, r12
     f66:	34 8b       	std	Z+20, r19	; 0x14
     f68:	23 8b       	std	Z+19, r18	; 0x13
      
      // Add these bytes for the error checker
      chk_data[2*itr + 2] = (di_bytes[1] << 8) + di_bytes[0];
     f6a:	f4 2e       	mov	r15, r20
     f6c:	ee 24       	eor	r14, r14
     f6e:	89 81       	ldd	r24, Y+1	; 0x01
     f70:	a7 01       	movw	r20, r14
     f72:	48 0f       	add	r20, r24
     f74:	51 1d       	adc	r21, r1
     f76:	f4 01       	movw	r30, r8
     f78:	51 83       	std	Z+1, r21	; 0x01
     f7a:	40 83       	st	Z, r20
      chk_data[2*itr + 3] = (di_bytes[3] << 8) + di_bytes[2];
     f7c:	33 83       	std	Z+3, r19	; 0x03
     f7e:	22 83       	std	Z+2, r18	; 0x02
     f80:	42 e0       	ldi	r20, 0x02	; 2
     f82:	50 e0       	ldi	r21, 0x00	; 0
     f84:	c4 0e       	add	r12, r20
     f86:	d5 1e       	adc	r13, r21
     f88:	84 e0       	ldi	r24, 0x04	; 4
     f8a:	90 e0       	ldi	r25, 0x00	; 0
     f8c:	88 0e       	add	r8, r24
     f8e:	99 1e       	adc	r9, r25
     f90:	08 94       	sec
     f92:	61 1c       	adc	r6, r1
     f94:	71 1c       	adc	r7, r1
    chk_data[1] = frame->motor_speed;
	//rprintfu16(frame.motor_speed);
	//rprintfCRLF();
				
    // Read distances, intensities, and flags
    for(uint8_t itr = 0; itr < 4; itr++) {
     f96:	e9 8d       	ldd	r30, Y+25	; 0x19
     f98:	fa 8d       	ldd	r31, Y+26	; 0x1a
     f9a:	8e 16       	cp	r8, r30
     f9c:	9f 06       	cpc	r9, r31
     f9e:	21 f0       	breq	.+8      	; 0xfa8 <parse_frame+0x132>
     fa0:	8e 01       	movw	r16, r28
     fa2:	0f 5f       	subi	r16, 0xFF	; 255
     fa4:	1f 4f       	sbci	r17, 0xFF	; 255
     fa6:	b6 cf       	rjmp	.-148    	; 0xf14 <parse_frame+0x9e>
    }

    // Read checksum
    // Checksum is given in little endian, but because it is read into a uint16_t, it is ordered correctly
	//frame->checksum = (((uint16_t)read_LDS())<<8) + (uint16_t)read_LDS();
	frame->checksum = (((uint16_t)read_LDS())) + (((uint16_t)read_LDS())<<8);
     fa8:	0e 94 1b 07 	call	0xe36	; 0xe36 <read_LDS>
     fac:	18 2f       	mov	r17, r24
     fae:	0e 94 1b 07 	call	0xe36	; 0xe36 <read_LDS>
     fb2:	38 2f       	mov	r19, r24
     fb4:	20 e0       	ldi	r18, 0x00	; 0
     fb6:	b9 01       	movw	r22, r18
     fb8:	61 0f       	add	r22, r17
     fba:	71 1d       	adc	r23, r1
     fbc:	f2 01       	movw	r30, r4
     fbe:	74 8f       	std	Z+28, r23	; 0x1c
     fc0:	63 8f       	std	Z+27, r22	; 0x1b
     fc2:	f1 01       	movw	r30, r2
     fc4:	20 e0       	ldi	r18, 0x00	; 0
     fc6:	30 e0       	ldi	r19, 0x00	; 0
     fc8:	40 e0       	ldi	r20, 0x00	; 0
     fca:	50 e0       	ldi	r21, 0x00	; 0
}

uint8_t error_checker(const uint16_t chk_data[], uint16_t checksum){
    uint32_t chk32 = 0;
    for(uint8_t ndx = 0; ndx < 10; ndx++){
      chk32 = (chk32 << 1) + chk_data[ndx];
     fcc:	22 0f       	add	r18, r18
     fce:	33 1f       	adc	r19, r19
     fd0:	44 1f       	adc	r20, r20
     fd2:	55 1f       	adc	r21, r21
     fd4:	81 91       	ld	r24, Z+
     fd6:	91 91       	ld	r25, Z+
     fd8:	a0 e0       	ldi	r26, 0x00	; 0
     fda:	b0 e0       	ldi	r27, 0x00	; 0
     fdc:	28 0f       	add	r18, r24
     fde:	39 1f       	adc	r19, r25
     fe0:	4a 1f       	adc	r20, r26
     fe2:	5b 1f       	adc	r21, r27
	return data;
}

uint8_t error_checker(const uint16_t chk_data[], uint16_t checksum){
    uint32_t chk32 = 0;
    for(uint8_t ndx = 0; ndx < 10; ndx++){
     fe4:	e8 15       	cp	r30, r8
     fe6:	f9 05       	cpc	r31, r9
     fe8:	89 f7       	brne	.-30     	; 0xfcc <parse_frame+0x156>
      chk32 = (chk32 << 1) + chk_data[ndx];
    }
    uint16_t chk16 = (chk32 & 0x7FFF) + (chk32 >> 15);
     fea:	c9 01       	movw	r24, r18
     fec:	9f 77       	andi	r25, 0x7F	; 127
     fee:	ef e0       	ldi	r30, 0x0F	; 15
     ff0:	56 95       	lsr	r21
     ff2:	47 95       	ror	r20
     ff4:	37 95       	ror	r19
     ff6:	27 95       	ror	r18
     ff8:	ea 95       	dec	r30
     ffa:	d1 f7       	brne	.-12     	; 0xff0 <parse_frame+0x17a>
     ffc:	82 0f       	add	r24, r18
     ffe:	93 1f       	adc	r25, r19
    chk16 = chk16 & 0x7FFF;
    return (chk16 == checksum);
    1000:	20 e0       	ldi	r18, 0x00	; 0
    1002:	9f 77       	andi	r25, 0x7F	; 127
    1004:	86 17       	cp	r24, r22
    1006:	97 07       	cpc	r25, r23
    1008:	19 f4       	brne	.+6      	; 0x1010 <parse_frame+0x19a>
    100a:	21 e0       	ldi	r18, 0x01	; 1
    100c:	01 c0       	rjmp	.+2      	; 0x1010 <parse_frame+0x19a>
    // Read checksum
    // Checksum is given in little endian, but because it is read into a uint16_t, it is ordered correctly
	//frame->checksum = (((uint16_t)read_LDS())<<8) + (uint16_t)read_LDS();
	frame->checksum = (((uint16_t)read_LDS())) + (((uint16_t)read_LDS())<<8);
    
    return error_checker(chk_data, frame->checksum);
    100e:	20 e0       	ldi	r18, 0x00	; 0
}  
    1010:	82 2f       	mov	r24, r18
    1012:	6a 96       	adiw	r28, 0x1a	; 26
    1014:	0f b6       	in	r0, 0x3f	; 63
    1016:	f8 94       	cli
    1018:	de bf       	out	0x3e, r29	; 62
    101a:	0f be       	out	0x3f, r0	; 63
    101c:	cd bf       	out	0x3d, r28	; 61
    101e:	cf 91       	pop	r28
    1020:	df 91       	pop	r29
    1022:	1f 91       	pop	r17
    1024:	0f 91       	pop	r16
    1026:	ff 90       	pop	r15
    1028:	ef 90       	pop	r14
    102a:	df 90       	pop	r13
    102c:	cf 90       	pop	r12
    102e:	bf 90       	pop	r11
    1030:	af 90       	pop	r10
    1032:	9f 90       	pop	r9
    1034:	8f 90       	pop	r8
    1036:	7f 90       	pop	r7
    1038:	6f 90       	pop	r6
    103a:	5f 90       	pop	r5
    103c:	4f 90       	pop	r4
    103e:	3f 90       	pop	r3
    1040:	2f 90       	pop	r2
    1042:	08 95       	ret

00001044 <main>:
}

LDS_FRAME ldsf[20];

int main(void)
{
    1044:	cf 92       	push	r12
    1046:	df 92       	push	r13
    1048:	ef 92       	push	r14
    104a:	ff 92       	push	r15
    104c:	0f 93       	push	r16
    104e:	1f 93       	push	r17
    1050:	df 93       	push	r29
    1052:	cf 93       	push	r28
    1054:	cd b7       	in	r28, 0x3d	; 61
    1056:	de b7       	in	r29, 0x3e	; 62
    1058:	6d 97       	sbiw	r28, 0x1d	; 29
    105a:	0f b6       	in	r0, 0x3f	; 63
    105c:	f8 94       	cli
    105e:	de bf       	out	0x3e, r29	; 62
    1060:	0f be       	out	0x3f, r0	; 63
    1062:	cd bf       	out	0x3d, r28	; 61
	lds_buffer_write_ndx = lds_buffer_read_ndx = lds_buffer;
    1064:	82 e0       	ldi	r24, 0x02	; 2
    1066:	94 e1       	ldi	r25, 0x14	; 20
    1068:	90 93 9b 02 	sts	0x029B, r25
    106c:	80 93 9a 02 	sts	0x029A, r24
    1070:	90 93 99 02 	sts	0x0299, r25
    1074:	80 93 98 02 	sts	0x0298, r24
	prvSetupHardware();
    1078:	0e 94 8f 06 	call	0xd1e	; 0xd1e <prvSetupHardware>

	rprintf("Starting program.\n");
    107c:	00 d0       	rcall	.+0      	; 0x107e <main+0x3a>
    107e:	0f 92       	push	r0
    1080:	81 e0       	ldi	r24, 0x01	; 1
    1082:	ed b7       	in	r30, 0x3d	; 61
    1084:	fe b7       	in	r31, 0x3e	; 62
    1086:	81 83       	std	Z+1, r24	; 0x01
    1088:	88 ef       	ldi	r24, 0xF8	; 248
    108a:	90 e0       	ldi	r25, 0x00	; 0
    108c:	93 83       	std	Z+3, r25	; 0x03
    108e:	82 83       	std	Z+2, r24	; 0x02
    1090:	0e 94 8b 22 	call	0x4516	; 0x4516 <rprintf1RamRom>
    1094:	10 e0       	ldi	r17, 0x00	; 0
    1096:	0f 90       	pop	r0
    1098:	0f 90       	pop	r0
    109a:	0f 90       	pop	r0
	LDS_FRAME frame;
	//for(uint8_t f_iter = 0; f_iter < 200; f_iter++){
	//while(1){
	uint8_t f_iter = 0;
	while(f_iter != 20){
		if(parse_frame(&frame)){
    109c:	7e 01       	movw	r14, r28
    109e:	08 94       	sec
    10a0:	e1 1c       	adc	r14, r1
    10a2:	f1 1c       	adc	r15, r1
			//print_frame(frame);
			ldsf[f_iter] = frame;
    10a4:	9d e1       	ldi	r25, 0x1D	; 29
    10a6:	c9 2e       	mov	r12, r25
    10a8:	d1 2c       	mov	r13, r1
	LDS_FRAME frame;
	//for(uint8_t f_iter = 0; f_iter < 200; f_iter++){
	//while(1){
	uint8_t f_iter = 0;
	while(f_iter != 20){
		if(parse_frame(&frame)){
    10aa:	c7 01       	movw	r24, r14
    10ac:	0e 94 3b 07 	call	0xe76	; 0xe76 <parse_frame>
    10b0:	88 23       	and	r24, r24
    10b2:	d9 f3       	breq	.-10     	; 0x10aa <main+0x66>
			//print_frame(frame);
			ldsf[f_iter] = frame;
    10b4:	81 2f       	mov	r24, r17
    10b6:	90 e0       	ldi	r25, 0x00	; 0
    10b8:	8c 9d       	mul	r24, r12
    10ba:	f0 01       	movw	r30, r0
    10bc:	8d 9d       	mul	r24, r13
    10be:	f0 0d       	add	r31, r0
    10c0:	9c 9d       	mul	r25, r12
    10c2:	f0 0d       	add	r31, r0
    10c4:	11 24       	eor	r1, r1
    10c6:	ee 54       	subi	r30, 0x4E	; 78
    10c8:	fe 4e       	sbci	r31, 0xEE	; 238
    10ca:	d7 01       	movw	r26, r14
    10cc:	8d e1       	ldi	r24, 0x1D	; 29
    10ce:	0d 90       	ld	r0, X+
    10d0:	01 92       	st	Z+, r0
    10d2:	81 50       	subi	r24, 0x01	; 1
    10d4:	e1 f7       	brne	.-8      	; 0x10ce <main+0x8a>
			f_iter++;
    10d6:	1f 5f       	subi	r17, 0xFF	; 255
	
	LDS_FRAME frame;
	//for(uint8_t f_iter = 0; f_iter < 200; f_iter++){
	//while(1){
	uint8_t f_iter = 0;
	while(f_iter != 20){
    10d8:	14 31       	cpi	r17, 0x14	; 20
    10da:	39 f7       	brne	.-50     	; 0x10aa <main+0x66>
    10dc:	00 e0       	ldi	r16, 0x00	; 0
    10de:	10 e0       	ldi	r17, 0x00	; 0
			ldsf[f_iter] = frame;
			f_iter++;
		}
	}
	for(uint8_t f_iter = 0; f_iter < 20; f_iter++){
		print_frame(ldsf[f_iter]);
    10e0:	8d e1       	ldi	r24, 0x1D	; 29
    10e2:	e8 2e       	mov	r14, r24
    10e4:	f1 2c       	mov	r15, r1
    10e6:	8d b7       	in	r24, 0x3d	; 61
    10e8:	9e b7       	in	r25, 0x3e	; 62
    10ea:	4d 97       	sbiw	r24, 0x1d	; 29
    10ec:	0f b6       	in	r0, 0x3f	; 63
    10ee:	f8 94       	cli
    10f0:	9e bf       	out	0x3e, r25	; 62
    10f2:	0f be       	out	0x3f, r0	; 63
    10f4:	8d bf       	out	0x3d, r24	; 61
    10f6:	0e 9d       	mul	r16, r14
    10f8:	f0 01       	movw	r30, r0
    10fa:	0f 9d       	mul	r16, r15
    10fc:	f0 0d       	add	r31, r0
    10fe:	1e 9d       	mul	r17, r14
    1100:	f0 0d       	add	r31, r0
    1102:	11 24       	eor	r1, r1
    1104:	ad b7       	in	r26, 0x3d	; 61
    1106:	be b7       	in	r27, 0x3e	; 62
    1108:	11 96       	adiw	r26, 0x01	; 1
    110a:	ee 54       	subi	r30, 0x4E	; 78
    110c:	fe 4e       	sbci	r31, 0xEE	; 238
    110e:	8d e1       	ldi	r24, 0x1D	; 29
    1110:	01 90       	ld	r0, Z+
    1112:	0d 92       	st	X+, r0
    1114:	81 50       	subi	r24, 0x01	; 1
    1116:	e1 f7       	brne	.-8      	; 0x1110 <main+0xcc>
    1118:	0e 94 c5 05 	call	0xb8a	; 0xb8a <print_frame>
    111c:	0f 5f       	subi	r16, 0xFF	; 255
    111e:	1f 4f       	sbci	r17, 0xFF	; 255
			//print_frame(frame);
			ldsf[f_iter] = frame;
			f_iter++;
		}
	}
	for(uint8_t f_iter = 0; f_iter < 20; f_iter++){
    1120:	ed b7       	in	r30, 0x3d	; 61
    1122:	fe b7       	in	r31, 0x3e	; 62
    1124:	7d 96       	adiw	r30, 0x1d	; 29
    1126:	0f b6       	in	r0, 0x3f	; 63
    1128:	f8 94       	cli
    112a:	fe bf       	out	0x3e, r31	; 62
    112c:	0f be       	out	0x3f, r0	; 63
    112e:	ed bf       	out	0x3d, r30	; 61
    1130:	04 31       	cpi	r16, 0x14	; 20
    1132:	11 05       	cpc	r17, r1
    1134:	c1 f6       	brne	.-80     	; 0x10e6 <main+0xa2>
		print_frame(ldsf[f_iter]);
	}
	rprintf("Program terminated.");
    1136:	00 d0       	rcall	.+0      	; 0x1138 <main+0xf4>
    1138:	0f 92       	push	r0
    113a:	81 e0       	ldi	r24, 0x01	; 1
    113c:	ed b7       	in	r30, 0x3d	; 61
    113e:	fe b7       	in	r31, 0x3e	; 62
    1140:	81 83       	std	Z+1, r24	; 0x01
    1142:	84 ee       	ldi	r24, 0xE4	; 228
    1144:	90 e0       	ldi	r25, 0x00	; 0
    1146:	93 83       	std	Z+3, r25	; 0x03
    1148:	82 83       	std	Z+2, r24	; 0x02
    114a:	0e 94 8b 22 	call	0x4516	; 0x4516 <rprintf1RamRom>
    114e:	0f 90       	pop	r0
    1150:	0f 90       	pop	r0
    1152:	0f 90       	pop	r0
	while(1){
		delay_ms(1);
    1154:	81 e0       	ldi	r24, 0x01	; 1
    1156:	90 e0       	ldi	r25, 0x00	; 0
    1158:	0e 94 84 15 	call	0x2b08	; 0x2b08 <sleep>
    115c:	fb cf       	rjmp	.-10     	; 0x1154 <main+0x110>

0000115e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    115e:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    1160:	9c 01       	movw	r18, r24
    1162:	2d 5f       	subi	r18, 0xFD	; 253
    1164:	3f 4f       	sbci	r19, 0xFF	; 255
    1166:	32 83       	std	Z+2, r19	; 0x02
    1168:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    116a:	8f ef       	ldi	r24, 0xFF	; 255
    116c:	9f ef       	ldi	r25, 0xFF	; 255
    116e:	94 83       	std	Z+4, r25	; 0x04
    1170:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1172:	36 83       	std	Z+6, r19	; 0x06
    1174:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1176:	30 87       	std	Z+8, r19	; 0x08
    1178:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = 0;
    117a:	10 82       	st	Z, r1
}
    117c:	08 95       	ret

0000117e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    117e:	fc 01       	movw	r30, r24
    1180:	11 86       	std	Z+9, r1	; 0x09
    1182:	10 86       	std	Z+8, r1	; 0x08
}
    1184:	08 95       	ret

00001186 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1186:	cf 93       	push	r28
    1188:	df 93       	push	r29
    118a:	ac 01       	movw	r20, r24
    118c:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    118e:	ec 01       	movw	r28, r24
    1190:	29 81       	ldd	r18, Y+1	; 0x01
    1192:	3a 81       	ldd	r19, Y+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    1194:	f9 01       	movw	r30, r18
    1196:	82 81       	ldd	r24, Z+2	; 0x02
    1198:	93 81       	ldd	r25, Z+3	; 0x03
    119a:	13 96       	adiw	r26, 0x03	; 3
    119c:	9c 93       	st	X, r25
    119e:	8e 93       	st	-X, r24
    11a0:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
    11a2:	89 81       	ldd	r24, Y+1	; 0x01
    11a4:	9a 81       	ldd	r25, Y+2	; 0x02
    11a6:	15 96       	adiw	r26, 0x05	; 5
    11a8:	9c 93       	st	X, r25
    11aa:	8e 93       	st	-X, r24
    11ac:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    11ae:	02 80       	ldd	r0, Z+2	; 0x02
    11b0:	f3 81       	ldd	r31, Z+3	; 0x03
    11b2:	e0 2d       	mov	r30, r0
    11b4:	75 83       	std	Z+5, r23	; 0x05
    11b6:	64 83       	std	Z+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    11b8:	e9 01       	movw	r28, r18
    11ba:	7b 83       	std	Y+3, r23	; 0x03
    11bc:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    11be:	fa 01       	movw	r30, r20
    11c0:	72 83       	std	Z+2, r23	; 0x02
    11c2:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    11c4:	19 96       	adiw	r26, 0x09	; 9
    11c6:	5c 93       	st	X, r21
    11c8:	4e 93       	st	-X, r20
    11ca:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
    11cc:	80 81       	ld	r24, Z
    11ce:	8f 5f       	subi	r24, 0xFF	; 255
    11d0:	80 83       	st	Z, r24
}
    11d2:	df 91       	pop	r29
    11d4:	cf 91       	pop	r28
    11d6:	08 95       	ret

000011d8 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    11d8:	cf 93       	push	r28
    11da:	df 93       	push	r29
    11dc:	9c 01       	movw	r18, r24
    11de:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    11e0:	48 81       	ld	r20, Y
    11e2:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as 
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the 
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    11e4:	8f ef       	ldi	r24, 0xFF	; 255
    11e6:	4f 3f       	cpi	r20, 0xFF	; 255
    11e8:	58 07       	cpc	r21, r24
    11ea:	21 f4       	brne	.+8      	; 0x11f4 <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    11ec:	f9 01       	movw	r30, r18
    11ee:	a7 81       	ldd	r26, Z+7	; 0x07
    11f0:	b0 85       	ldd	r27, Z+8	; 0x08
    11f2:	10 c0       	rjmp	.+32     	; 0x1214 <vListInsert+0x3c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips. 
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    11f4:	d9 01       	movw	r26, r18
    11f6:	13 96       	adiw	r26, 0x03	; 3
    11f8:	04 c0       	rjmp	.+8      	; 0x1202 <vListInsert+0x2a>
    11fa:	12 96       	adiw	r26, 0x02	; 2
    11fc:	0d 90       	ld	r0, X+
    11fe:	bc 91       	ld	r27, X
    1200:	a0 2d       	mov	r26, r0
    1202:	12 96       	adiw	r26, 0x02	; 2
    1204:	ed 91       	ld	r30, X+
    1206:	fc 91       	ld	r31, X
    1208:	13 97       	sbiw	r26, 0x03	; 3
    120a:	80 81       	ld	r24, Z
    120c:	91 81       	ldd	r25, Z+1	; 0x01
    120e:	48 17       	cp	r20, r24
    1210:	59 07       	cpc	r21, r25
    1212:	98 f7       	brcc	.-26     	; 0x11fa <vListInsert+0x22>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1214:	12 96       	adiw	r26, 0x02	; 2
    1216:	ed 91       	ld	r30, X+
    1218:	fc 91       	ld	r31, X
    121a:	13 97       	sbiw	r26, 0x03	; 3
    121c:	fb 83       	std	Y+3, r31	; 0x03
    121e:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1220:	d5 83       	std	Z+5, r29	; 0x05
    1222:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1224:	bd 83       	std	Y+5, r27	; 0x05
    1226:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1228:	13 96       	adiw	r26, 0x03	; 3
    122a:	dc 93       	st	X, r29
    122c:	ce 93       	st	-X, r28
    122e:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1230:	39 87       	std	Y+9, r19	; 0x09
    1232:	28 87       	std	Y+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    1234:	f9 01       	movw	r30, r18
    1236:	80 81       	ld	r24, Z
    1238:	8f 5f       	subi	r24, 0xFF	; 255
    123a:	80 83       	st	Z, r24
}
    123c:	df 91       	pop	r29
    123e:	cf 91       	pop	r28
    1240:	08 95       	ret

00001242 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    1242:	cf 93       	push	r28
    1244:	df 93       	push	r29
    1246:	dc 01       	movw	r26, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1248:	12 96       	adiw	r26, 0x02	; 2
    124a:	ed 91       	ld	r30, X+
    124c:	fc 91       	ld	r31, X
    124e:	13 97       	sbiw	r26, 0x03	; 3
    1250:	14 96       	adiw	r26, 0x04	; 4
    1252:	8d 91       	ld	r24, X+
    1254:	9c 91       	ld	r25, X
    1256:	15 97       	sbiw	r26, 0x05	; 5
    1258:	95 83       	std	Z+5, r25	; 0x05
    125a:	84 83       	std	Z+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    125c:	14 96       	adiw	r26, 0x04	; 4
    125e:	cd 91       	ld	r28, X+
    1260:	dc 91       	ld	r29, X
    1262:	15 97       	sbiw	r26, 0x05	; 5
    1264:	fb 83       	std	Y+3, r31	; 0x03
    1266:	ea 83       	std	Y+2, r30	; 0x02
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1268:	18 96       	adiw	r26, 0x08	; 8
    126a:	ed 91       	ld	r30, X+
    126c:	fc 91       	ld	r31, X
    126e:	19 97       	sbiw	r26, 0x09	; 9

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1270:	81 81       	ldd	r24, Z+1	; 0x01
    1272:	92 81       	ldd	r25, Z+2	; 0x02
    1274:	8a 17       	cp	r24, r26
    1276:	9b 07       	cpc	r25, r27
    1278:	11 f4       	brne	.+4      	; 0x127e <vListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    127a:	d2 83       	std	Z+2, r29	; 0x02
    127c:	c1 83       	std	Z+1, r28	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    127e:	19 96       	adiw	r26, 0x09	; 9
    1280:	1c 92       	st	X, r1
    1282:	1e 92       	st	-X, r1
    1284:	18 97       	sbiw	r26, 0x08	; 8
	( pxList->uxNumberOfItems )--;
    1286:	80 81       	ld	r24, Z
    1288:	81 50       	subi	r24, 0x01	; 1
    128a:	80 83       	st	Z, r24
}
    128c:	df 91       	pop	r29
    128e:	cf 91       	pop	r28
    1290:	08 95       	ret

00001292 <uxQueueMessagesWaiting>:
	return xReturn;
}
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    1292:	fc 01       	movw	r30, r24
unsigned portBASE_TYPE uxReturn;

	taskENTER_CRITICAL();
    1294:	0f b6       	in	r0, 0x3f	; 63
    1296:	f8 94       	cli
    1298:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    129a:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    129c:	0f 90       	pop	r0
    129e:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    12a0:	08 95       	ret

000012a2 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    12a2:	fc 01       	movw	r30, r24
unsigned portBASE_TYPE uxReturn;

	uxReturn = pxQueue->uxMessagesWaiting;
    12a4:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
    12a6:	08 95       	ret

000012a8 <xQueueIsQueueEmptyFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    12a8:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    12aa:	82 8d       	ldd	r24, Z+26	; 0x1a
    12ac:	90 e0       	ldi	r25, 0x00	; 0
    12ae:	88 23       	and	r24, r24
    12b0:	09 f4       	brne	.+2      	; 0x12b4 <xQueueIsQueueEmptyFromISR+0xc>
    12b2:	91 e0       	ldi	r25, 0x01	; 1

	return xReturn;
}
    12b4:	89 2f       	mov	r24, r25
    12b6:	08 95       	ret

000012b8 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    12b8:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    12ba:	92 8d       	ldd	r25, Z+26	; 0x1a
    12bc:	20 e0       	ldi	r18, 0x00	; 0
    12be:	83 8d       	ldd	r24, Z+27	; 0x1b
    12c0:	98 17       	cp	r25, r24
    12c2:	09 f4       	brne	.+2      	; 0x12c6 <xQueueIsQueueFullFromISR+0xe>
    12c4:	21 e0       	ldi	r18, 0x01	; 1

	return xReturn;
}
    12c6:	82 2f       	mov	r24, r18
    12c8:	08 95       	ret

000012ca <vQueueDelete>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    12ca:	0f 93       	push	r16
    12cc:	1f 93       	push	r17
    12ce:	8c 01       	movw	r16, r24
	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    12d0:	fc 01       	movw	r30, r24
    12d2:	80 81       	ld	r24, Z
    12d4:	91 81       	ldd	r25, Z+1	; 0x01
    12d6:	0e 94 be 13 	call	0x277c	; 0x277c <vPortFree>
	vPortFree( pxQueue );
    12da:	c8 01       	movw	r24, r16
    12dc:	0e 94 be 13 	call	0x277c	; 0x277c <vPortFree>
}
    12e0:	1f 91       	pop	r17
    12e2:	0f 91       	pop	r16
    12e4:	08 95       	ret

000012e6 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    12e6:	0f 93       	push	r16
    12e8:	1f 93       	push	r17
    12ea:	cf 93       	push	r28
    12ec:	df 93       	push	r29
    12ee:	ec 01       	movw	r28, r24
    12f0:	fb 01       	movw	r30, r22
    12f2:	8a 01       	movw	r16, r20
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    12f4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    12f6:	88 23       	and	r24, r24
    12f8:	81 f1       	breq	.+96     	; 0x135a <xQueueReceiveFromISR+0x74>
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    12fa:	48 81       	ld	r20, Y
    12fc:	59 81       	ldd	r21, Y+1	; 0x01
    12fe:	41 15       	cp	r20, r1
    1300:	51 05       	cpc	r21, r1
    1302:	a9 f0       	breq	.+42     	; 0x132e <xQueueReceiveFromISR+0x48>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    1304:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1306:	2e 81       	ldd	r18, Y+6	; 0x06
    1308:	3f 81       	ldd	r19, Y+7	; 0x07
    130a:	28 0f       	add	r18, r24
    130c:	31 1d       	adc	r19, r1
    130e:	3f 83       	std	Y+7, r19	; 0x07
    1310:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    1312:	8a 81       	ldd	r24, Y+2	; 0x02
    1314:	9b 81       	ldd	r25, Y+3	; 0x03
    1316:	28 17       	cp	r18, r24
    1318:	39 07       	cpc	r19, r25
    131a:	10 f0       	brcs	.+4      	; 0x1320 <xQueueReceiveFromISR+0x3a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    131c:	5f 83       	std	Y+7, r21	; 0x07
    131e:	4e 83       	std	Y+6, r20	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1320:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1322:	6e 81       	ldd	r22, Y+6	; 0x06
    1324:	7f 81       	ldd	r23, Y+7	; 0x07
    1326:	cf 01       	movw	r24, r30
    1328:	50 e0       	ldi	r21, 0x00	; 0
    132a:	0e 94 a5 25 	call	0x4b4a	; 0x4b4a <memcpy>
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
			--( pxQueue->uxMessagesWaiting );
    132e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1330:	81 50       	subi	r24, 0x01	; 1
    1332:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1334:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1336:	8f 3f       	cpi	r24, 0xFF	; 255
    1338:	69 f4       	brne	.+26     	; 0x1354 <xQueueReceiveFromISR+0x6e>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
    133a:	88 85       	ldd	r24, Y+8	; 0x08
    133c:	88 23       	and	r24, r24
    133e:	61 f0       	breq	.+24     	; 0x1358 <xQueueReceiveFromISR+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1340:	ce 01       	movw	r24, r28
    1342:	08 96       	adiw	r24, 0x08	; 8
    1344:	0e 94 d3 0c 	call	0x19a6	; 0x19a6 <xTaskRemoveFromEventList>
    1348:	88 23       	and	r24, r24
    134a:	31 f0       	breq	.+12     	; 0x1358 <xQueueReceiveFromISR+0x72>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    134c:	81 e0       	ldi	r24, 0x01	; 1
    134e:	f8 01       	movw	r30, r16
    1350:	80 83       	st	Z, r24
    1352:	03 c0       	rjmp	.+6      	; 0x135a <xQueueReceiveFromISR+0x74>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1354:	8f 5f       	subi	r24, 0xFF	; 255
    1356:	8d 8f       	std	Y+29, r24	; 0x1d
    1358:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    135a:	df 91       	pop	r29
    135c:	cf 91       	pop	r28
    135e:	1f 91       	pop	r17
    1360:	0f 91       	pop	r16
    1362:	08 95       	ret

00001364 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    1364:	cf 93       	push	r28
    1366:	df 93       	push	r29
    1368:	ec 01       	movw	r28, r24
    136a:	84 2f       	mov	r24, r20
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    136c:	4c 8d       	ldd	r20, Y+28	; 0x1c
    136e:	44 23       	and	r20, r20
    1370:	a1 f1       	breq	.+104    	; 0x13da <prvCopyDataToQueue+0x76>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    1372:	88 23       	and	r24, r24
    1374:	b1 f4       	brne	.+44     	; 0x13a2 <prvCopyDataToQueue+0x3e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1376:	8c 81       	ldd	r24, Y+4	; 0x04
    1378:	9d 81       	ldd	r25, Y+5	; 0x05
    137a:	50 e0       	ldi	r21, 0x00	; 0
    137c:	0e 94 a5 25 	call	0x4b4a	; 0x4b4a <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    1380:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1382:	2c 81       	ldd	r18, Y+4	; 0x04
    1384:	3d 81       	ldd	r19, Y+5	; 0x05
    1386:	28 0f       	add	r18, r24
    1388:	31 1d       	adc	r19, r1
    138a:	3d 83       	std	Y+5, r19	; 0x05
    138c:	2c 83       	std	Y+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    138e:	8a 81       	ldd	r24, Y+2	; 0x02
    1390:	9b 81       	ldd	r25, Y+3	; 0x03
    1392:	28 17       	cp	r18, r24
    1394:	39 07       	cpc	r19, r25
    1396:	08 f1       	brcs	.+66     	; 0x13da <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1398:	88 81       	ld	r24, Y
    139a:	99 81       	ldd	r25, Y+1	; 0x01
    139c:	9d 83       	std	Y+5, r25	; 0x05
    139e:	8c 83       	std	Y+4, r24	; 0x04
    13a0:	1c c0       	rjmp	.+56     	; 0x13da <prvCopyDataToQueue+0x76>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    13a2:	8e 81       	ldd	r24, Y+6	; 0x06
    13a4:	9f 81       	ldd	r25, Y+7	; 0x07
    13a6:	50 e0       	ldi	r21, 0x00	; 0
    13a8:	0e 94 a5 25 	call	0x4b4a	; 0x4b4a <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    13ac:	8c 8d       	ldd	r24, Y+28	; 0x1c
    13ae:	90 e0       	ldi	r25, 0x00	; 0
    13b0:	44 27       	eor	r20, r20
    13b2:	55 27       	eor	r21, r21
    13b4:	48 1b       	sub	r20, r24
    13b6:	59 0b       	sbc	r21, r25
    13b8:	8e 81       	ldd	r24, Y+6	; 0x06
    13ba:	9f 81       	ldd	r25, Y+7	; 0x07
    13bc:	84 0f       	add	r24, r20
    13be:	95 1f       	adc	r25, r21
    13c0:	9f 83       	std	Y+7, r25	; 0x07
    13c2:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    13c4:	28 81       	ld	r18, Y
    13c6:	39 81       	ldd	r19, Y+1	; 0x01
    13c8:	82 17       	cp	r24, r18
    13ca:	93 07       	cpc	r25, r19
    13cc:	30 f4       	brcc	.+12     	; 0x13da <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    13ce:	8a 81       	ldd	r24, Y+2	; 0x02
    13d0:	9b 81       	ldd	r25, Y+3	; 0x03
    13d2:	84 0f       	add	r24, r20
    13d4:	95 1f       	adc	r25, r21
    13d6:	9f 83       	std	Y+7, r25	; 0x07
    13d8:	8e 83       	std	Y+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    13da:	8a 8d       	ldd	r24, Y+26	; 0x1a
    13dc:	8f 5f       	subi	r24, 0xFF	; 255
    13de:	8a 8f       	std	Y+26, r24	; 0x1a
}
    13e0:	df 91       	pop	r29
    13e2:	cf 91       	pop	r28
    13e4:	08 95       	ret

000013e6 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    13e6:	0f 93       	push	r16
    13e8:	1f 93       	push	r17
    13ea:	cf 93       	push	r28
    13ec:	df 93       	push	r29
    13ee:	ec 01       	movw	r28, r24
    13f0:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    13f2:	9a 8d       	ldd	r25, Y+26	; 0x1a
    13f4:	8b 8d       	ldd	r24, Y+27	; 0x1b
    13f6:	98 17       	cp	r25, r24
    13f8:	10 f0       	brcs	.+4      	; 0x13fe <xQueueGenericSendFromISR+0x18>
    13fa:	80 e0       	ldi	r24, 0x00	; 0
    13fc:	17 c0       	rjmp	.+46     	; 0x142c <xQueueGenericSendFromISR+0x46>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    13fe:	ce 01       	movw	r24, r28
    1400:	42 2f       	mov	r20, r18
    1402:	0e 94 b2 09 	call	0x1364	; 0x1364 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1406:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1408:	8f 3f       	cpi	r24, 0xFF	; 255
    140a:	69 f4       	brne	.+26     	; 0x1426 <xQueueGenericSendFromISR+0x40>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    140c:	89 89       	ldd	r24, Y+17	; 0x11
    140e:	88 23       	and	r24, r24
    1410:	61 f0       	breq	.+24     	; 0x142a <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1412:	ce 01       	movw	r24, r28
    1414:	41 96       	adiw	r24, 0x11	; 17
    1416:	0e 94 d3 0c 	call	0x19a6	; 0x19a6 <xTaskRemoveFromEventList>
    141a:	88 23       	and	r24, r24
    141c:	31 f0       	breq	.+12     	; 0x142a <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    141e:	81 e0       	ldi	r24, 0x01	; 1
    1420:	f8 01       	movw	r30, r16
    1422:	80 83       	st	Z, r24
    1424:	03 c0       	rjmp	.+6      	; 0x142c <xQueueGenericSendFromISR+0x46>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1426:	8f 5f       	subi	r24, 0xFF	; 255
    1428:	8e 8f       	std	Y+30, r24	; 0x1e
    142a:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    142c:	df 91       	pop	r29
    142e:	cf 91       	pop	r28
    1430:	1f 91       	pop	r17
    1432:	0f 91       	pop	r16
    1434:	08 95       	ret

00001436 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    1436:	0f 93       	push	r16
    1438:	1f 93       	push	r17
    143a:	cf 93       	push	r28
    143c:	df 93       	push	r29
    143e:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1440:	0f b6       	in	r0, 0x3f	; 63
    1442:	f8 94       	cli
    1444:	0f 92       	push	r0
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1446:	8c 01       	movw	r16, r24
    1448:	0f 5e       	subi	r16, 0xEF	; 239
    144a:	1f 4f       	sbci	r17, 0xFF	; 255
    144c:	0d c0       	rjmp	.+26     	; 0x1468 <prvUnlockQueue+0x32>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    144e:	89 89       	ldd	r24, Y+17	; 0x11
    1450:	88 23       	and	r24, r24
    1452:	69 f0       	breq	.+26     	; 0x146e <prvUnlockQueue+0x38>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1454:	c8 01       	movw	r24, r16
    1456:	0e 94 d3 0c 	call	0x19a6	; 0x19a6 <xTaskRemoveFromEventList>
    145a:	88 23       	and	r24, r24
    145c:	11 f0       	breq	.+4      	; 0x1462 <prvUnlockQueue+0x2c>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    145e:	0e 94 cf 0c 	call	0x199e	; 0x199e <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    1462:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1464:	81 50       	subi	r24, 0x01	; 1
    1466:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1468:	8e 8d       	ldd	r24, Y+30	; 0x1e
    146a:	18 16       	cp	r1, r24
    146c:	84 f3       	brlt	.-32     	; 0x144e <prvUnlockQueue+0x18>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    146e:	8f ef       	ldi	r24, 0xFF	; 255
    1470:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1472:	0f 90       	pop	r0
    1474:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1476:	0f b6       	in	r0, 0x3f	; 63
    1478:	f8 94       	cli
    147a:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    147c:	8e 01       	movw	r16, r28
    147e:	08 5f       	subi	r16, 0xF8	; 248
    1480:	1f 4f       	sbci	r17, 0xFF	; 255
    1482:	0d c0       	rjmp	.+26     	; 0x149e <prvUnlockQueue+0x68>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
    1484:	88 85       	ldd	r24, Y+8	; 0x08
    1486:	88 23       	and	r24, r24
    1488:	69 f0       	breq	.+26     	; 0x14a4 <prvUnlockQueue+0x6e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    148a:	c8 01       	movw	r24, r16
    148c:	0e 94 d3 0c 	call	0x19a6	; 0x19a6 <xTaskRemoveFromEventList>
    1490:	88 23       	and	r24, r24
    1492:	11 f0       	breq	.+4      	; 0x1498 <prvUnlockQueue+0x62>
				{
					vTaskMissedYield();
    1494:	0e 94 cf 0c 	call	0x199e	; 0x199e <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    1498:	8d 8d       	ldd	r24, Y+29	; 0x1d
    149a:	81 50       	subi	r24, 0x01	; 1
    149c:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    149e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    14a0:	18 16       	cp	r1, r24
    14a2:	84 f3       	brlt	.-32     	; 0x1484 <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    14a4:	8f ef       	ldi	r24, 0xFF	; 255
    14a6:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    14a8:	0f 90       	pop	r0
    14aa:	0f be       	out	0x3f, r0	; 63
}
    14ac:	df 91       	pop	r29
    14ae:	cf 91       	pop	r28
    14b0:	1f 91       	pop	r17
    14b2:	0f 91       	pop	r16
    14b4:	08 95       	ret

000014b6 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    14b6:	7f 92       	push	r7
    14b8:	8f 92       	push	r8
    14ba:	9f 92       	push	r9
    14bc:	af 92       	push	r10
    14be:	bf 92       	push	r11
    14c0:	cf 92       	push	r12
    14c2:	df 92       	push	r13
    14c4:	ef 92       	push	r14
    14c6:	ff 92       	push	r15
    14c8:	0f 93       	push	r16
    14ca:	1f 93       	push	r17
    14cc:	df 93       	push	r29
    14ce:	cf 93       	push	r28
    14d0:	00 d0       	rcall	.+0      	; 0x14d2 <xQueueGenericReceive+0x1c>
    14d2:	00 d0       	rcall	.+0      	; 0x14d4 <xQueueGenericReceive+0x1e>
    14d4:	0f 92       	push	r0
    14d6:	cd b7       	in	r28, 0x3d	; 61
    14d8:	de b7       	in	r29, 0x3e	; 62
    14da:	8c 01       	movw	r16, r24
    14dc:	96 2e       	mov	r9, r22
    14de:	87 2e       	mov	r8, r23
    14e0:	5d 83       	std	Y+5, r21	; 0x05
    14e2:	4c 83       	std	Y+4, r20	; 0x04
    14e4:	72 2e       	mov	r7, r18
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    14e6:	91 e1       	ldi	r25, 0x11	; 17
    14e8:	c9 2e       	mov	r12, r25
    14ea:	d1 2c       	mov	r13, r1
    14ec:	c0 0e       	add	r12, r16
    14ee:	d1 1e       	adc	r13, r17
    14f0:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    14f2:	7e 01       	movw	r14, r28
    14f4:	08 94       	sec
    14f6:	e1 1c       	adc	r14, r1
    14f8:	f1 1c       	adc	r15, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    14fa:	84 e0       	ldi	r24, 0x04	; 4
    14fc:	a8 2e       	mov	r10, r24
    14fe:	b1 2c       	mov	r11, r1
    1500:	ac 0e       	add	r10, r28
    1502:	bd 1e       	adc	r11, r29
    1504:	01 c0       	rjmp	.+2      	; 0x1508 <xQueueGenericReceive+0x52>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1506:	21 e0       	ldi	r18, 0x01	; 1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1508:	0f b6       	in	r0, 0x3f	; 63
    150a:	f8 94       	cli
    150c:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    150e:	f8 01       	movw	r30, r16
    1510:	82 8d       	ldd	r24, Z+26	; 0x1a
    1512:	88 23       	and	r24, r24
    1514:	09 f4       	brne	.+2      	; 0x1518 <xQueueGenericReceive+0x62>
    1516:	3e c0       	rjmp	.+124    	; 0x1594 <xQueueGenericReceive+0xde>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1518:	e6 80       	ldd	r14, Z+6	; 0x06
    151a:	f7 80       	ldd	r15, Z+7	; 0x07
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    151c:	40 81       	ld	r20, Z
    151e:	51 81       	ldd	r21, Z+1	; 0x01
    1520:	41 15       	cp	r20, r1
    1522:	51 05       	cpc	r21, r1
    1524:	b1 f0       	breq	.+44     	; 0x1552 <xQueueGenericReceive+0x9c>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    1526:	84 8d       	ldd	r24, Z+28	; 0x1c
    1528:	97 01       	movw	r18, r14
    152a:	28 0f       	add	r18, r24
    152c:	31 1d       	adc	r19, r1
    152e:	37 83       	std	Z+7, r19	; 0x07
    1530:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    1532:	82 81       	ldd	r24, Z+2	; 0x02
    1534:	93 81       	ldd	r25, Z+3	; 0x03
    1536:	28 17       	cp	r18, r24
    1538:	39 07       	cpc	r19, r25
    153a:	10 f0       	brcs	.+4      	; 0x1540 <xQueueGenericReceive+0x8a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    153c:	57 83       	std	Z+7, r21	; 0x07
    153e:	46 83       	std	Z+6, r20	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1540:	f8 01       	movw	r30, r16
    1542:	44 8d       	ldd	r20, Z+28	; 0x1c
    1544:	66 81       	ldd	r22, Z+6	; 0x06
    1546:	77 81       	ldd	r23, Z+7	; 0x07
    1548:	89 2d       	mov	r24, r9
    154a:	98 2d       	mov	r25, r8
    154c:	50 e0       	ldi	r21, 0x00	; 0
    154e:	0e 94 a5 25 	call	0x4b4a	; 0x4b4a <memcpy>
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
    1552:	77 20       	and	r7, r7
    1554:	71 f4       	brne	.+28     	; 0x1572 <xQueueGenericReceive+0xbc>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1556:	f8 01       	movw	r30, r16
    1558:	82 8d       	ldd	r24, Z+26	; 0x1a
    155a:	81 50       	subi	r24, 0x01	; 1
    155c:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    155e:	80 85       	ldd	r24, Z+8	; 0x08
    1560:	88 23       	and	r24, r24
    1562:	a1 f0       	breq	.+40     	; 0x158c <xQueueGenericReceive+0xd6>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1564:	c8 01       	movw	r24, r16
    1566:	08 96       	adiw	r24, 0x08	; 8
    1568:	0e 94 d3 0c 	call	0x19a6	; 0x19a6 <xTaskRemoveFromEventList>
    156c:	81 30       	cpi	r24, 0x01	; 1
    156e:	71 f4       	brne	.+28     	; 0x158c <xQueueGenericReceive+0xd6>
    1570:	0b c0       	rjmp	.+22     	; 0x1588 <xQueueGenericReceive+0xd2>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    1572:	f8 01       	movw	r30, r16
    1574:	f7 82       	std	Z+7, r15	; 0x07
    1576:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    1578:	81 89       	ldd	r24, Z+17	; 0x11
    157a:	88 23       	and	r24, r24
    157c:	39 f0       	breq	.+14     	; 0x158c <xQueueGenericReceive+0xd6>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    157e:	c6 01       	movw	r24, r12
    1580:	0e 94 d3 0c 	call	0x19a6	; 0x19a6 <xTaskRemoveFromEventList>
    1584:	88 23       	and	r24, r24
    1586:	11 f0       	breq	.+4      	; 0x158c <xQueueGenericReceive+0xd6>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    1588:	0e 94 9b 11 	call	0x2336	; 0x2336 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    158c:	0f 90       	pop	r0
    158e:	0f be       	out	0x3f, r0	; 63
    1590:	81 e0       	ldi	r24, 0x01	; 1
    1592:	4a c0       	rjmp	.+148    	; 0x1628 <xQueueGenericReceive+0x172>
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1594:	8c 81       	ldd	r24, Y+4	; 0x04
    1596:	9d 81       	ldd	r25, Y+5	; 0x05
    1598:	89 2b       	or	r24, r25
    159a:	19 f4       	brne	.+6      	; 0x15a2 <xQueueGenericReceive+0xec>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    159c:	0f 90       	pop	r0
    159e:	0f be       	out	0x3f, r0	; 63
    15a0:	42 c0       	rjmp	.+132    	; 0x1626 <xQueueGenericReceive+0x170>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    15a2:	22 23       	and	r18, r18
    15a4:	19 f4       	brne	.+6      	; 0x15ac <xQueueGenericReceive+0xf6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    15a6:	c7 01       	movw	r24, r14
    15a8:	0e 94 8a 0c 	call	0x1914	; 0x1914 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    15ac:	0f 90       	pop	r0
    15ae:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    15b0:	0e 94 2e 0c 	call	0x185c	; 0x185c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    15b4:	0f b6       	in	r0, 0x3f	; 63
    15b6:	f8 94       	cli
    15b8:	0f 92       	push	r0
    15ba:	f8 01       	movw	r30, r16
    15bc:	85 8d       	ldd	r24, Z+29	; 0x1d
    15be:	8f 3f       	cpi	r24, 0xFF	; 255
    15c0:	09 f4       	brne	.+2      	; 0x15c4 <xQueueGenericReceive+0x10e>
    15c2:	15 8e       	std	Z+29, r1	; 0x1d
    15c4:	f8 01       	movw	r30, r16
    15c6:	86 8d       	ldd	r24, Z+30	; 0x1e
    15c8:	8f 3f       	cpi	r24, 0xFF	; 255
    15ca:	09 f4       	brne	.+2      	; 0x15ce <xQueueGenericReceive+0x118>
    15cc:	16 8e       	std	Z+30, r1	; 0x1e
    15ce:	0f 90       	pop	r0
    15d0:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    15d2:	c7 01       	movw	r24, r14
    15d4:	b5 01       	movw	r22, r10
    15d6:	0e 94 95 0c 	call	0x192a	; 0x192a <xTaskCheckForTimeOut>
    15da:	88 23       	and	r24, r24
    15dc:	f9 f4       	brne	.+62     	; 0x161c <xQueueGenericReceive+0x166>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    15de:	0f b6       	in	r0, 0x3f	; 63
    15e0:	f8 94       	cli
    15e2:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    15e4:	f8 01       	movw	r30, r16
    15e6:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    15e8:	0f 90       	pop	r0
    15ea:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
    15ec:	88 23       	and	r24, r24
    15ee:	81 f4       	brne	.+32     	; 0x1610 <xQueueGenericReceive+0x15a>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    15f0:	6c 81       	ldd	r22, Y+4	; 0x04
    15f2:	7d 81       	ldd	r23, Y+5	; 0x05
    15f4:	c6 01       	movw	r24, r12
    15f6:	0e 94 8c 0d 	call	0x1b18	; 0x1b18 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    15fa:	c8 01       	movw	r24, r16
    15fc:	0e 94 1b 0a 	call	0x1436	; 0x1436 <prvUnlockQueue>
				if( !xTaskResumeAll() )
    1600:	0e 94 c5 0d 	call	0x1b8a	; 0x1b8a <xTaskResumeAll>
    1604:	88 23       	and	r24, r24
    1606:	09 f0       	breq	.+2      	; 0x160a <xQueueGenericReceive+0x154>
    1608:	7e cf       	rjmp	.-260    	; 0x1506 <xQueueGenericReceive+0x50>
				{
					portYIELD_WITHIN_API();
    160a:	0e 94 9b 11 	call	0x2336	; 0x2336 <vPortYield>
    160e:	7b cf       	rjmp	.-266    	; 0x1506 <xQueueGenericReceive+0x50>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1610:	c8 01       	movw	r24, r16
    1612:	0e 94 1b 0a 	call	0x1436	; 0x1436 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1616:	0e 94 c5 0d 	call	0x1b8a	; 0x1b8a <xTaskResumeAll>
    161a:	75 cf       	rjmp	.-278    	; 0x1506 <xQueueGenericReceive+0x50>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    161c:	c8 01       	movw	r24, r16
    161e:	0e 94 1b 0a 	call	0x1436	; 0x1436 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1622:	0e 94 c5 0d 	call	0x1b8a	; 0x1b8a <xTaskResumeAll>
    1626:	80 e0       	ldi	r24, 0x00	; 0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
    1628:	0f 90       	pop	r0
    162a:	0f 90       	pop	r0
    162c:	0f 90       	pop	r0
    162e:	0f 90       	pop	r0
    1630:	0f 90       	pop	r0
    1632:	cf 91       	pop	r28
    1634:	df 91       	pop	r29
    1636:	1f 91       	pop	r17
    1638:	0f 91       	pop	r16
    163a:	ff 90       	pop	r15
    163c:	ef 90       	pop	r14
    163e:	df 90       	pop	r13
    1640:	cf 90       	pop	r12
    1642:	bf 90       	pop	r11
    1644:	af 90       	pop	r10
    1646:	9f 90       	pop	r9
    1648:	8f 90       	pop	r8
    164a:	7f 90       	pop	r7
    164c:	08 95       	ret

0000164e <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    164e:	7f 92       	push	r7
    1650:	8f 92       	push	r8
    1652:	9f 92       	push	r9
    1654:	af 92       	push	r10
    1656:	bf 92       	push	r11
    1658:	cf 92       	push	r12
    165a:	df 92       	push	r13
    165c:	ef 92       	push	r14
    165e:	ff 92       	push	r15
    1660:	0f 93       	push	r16
    1662:	1f 93       	push	r17
    1664:	df 93       	push	r29
    1666:	cf 93       	push	r28
    1668:	00 d0       	rcall	.+0      	; 0x166a <xQueueGenericSend+0x1c>
    166a:	00 d0       	rcall	.+0      	; 0x166c <xQueueGenericSend+0x1e>
    166c:	0f 92       	push	r0
    166e:	cd b7       	in	r28, 0x3d	; 61
    1670:	de b7       	in	r29, 0x3e	; 62
    1672:	8c 01       	movw	r16, r24
    1674:	6b 01       	movw	r12, r22
    1676:	5d 83       	std	Y+5, r21	; 0x05
    1678:	4c 83       	std	Y+4, r20	; 0x04
    167a:	72 2e       	mov	r7, r18
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    167c:	48 e0       	ldi	r20, 0x08	; 8
    167e:	e4 2e       	mov	r14, r20
    1680:	f1 2c       	mov	r15, r1
    1682:	e8 0e       	add	r14, r24
    1684:	f9 1e       	adc	r15, r25
    1686:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1688:	5e 01       	movw	r10, r28
    168a:	08 94       	sec
    168c:	a1 1c       	adc	r10, r1
    168e:	b1 1c       	adc	r11, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1690:	34 e0       	ldi	r19, 0x04	; 4
    1692:	83 2e       	mov	r8, r19
    1694:	91 2c       	mov	r9, r1
    1696:	8c 0e       	add	r8, r28
    1698:	9d 1e       	adc	r9, r29
    169a:	01 c0       	rjmp	.+2      	; 0x169e <xQueueGenericSend+0x50>
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    169c:	21 e0       	ldi	r18, 0x01	; 1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    169e:	0f b6       	in	r0, 0x3f	; 63
    16a0:	f8 94       	cli
    16a2:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    16a4:	f8 01       	movw	r30, r16
    16a6:	92 8d       	ldd	r25, Z+26	; 0x1a
    16a8:	83 8d       	ldd	r24, Z+27	; 0x1b
    16aa:	98 17       	cp	r25, r24
    16ac:	a8 f4       	brcc	.+42     	; 0x16d8 <xQueueGenericSend+0x8a>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    16ae:	c8 01       	movw	r24, r16
    16b0:	b6 01       	movw	r22, r12
    16b2:	47 2d       	mov	r20, r7
    16b4:	0e 94 b2 09 	call	0x1364	; 0x1364 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    16b8:	f8 01       	movw	r30, r16
    16ba:	81 89       	ldd	r24, Z+17	; 0x11
    16bc:	88 23       	and	r24, r24
    16be:	41 f0       	breq	.+16     	; 0x16d0 <xQueueGenericSend+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    16c0:	c8 01       	movw	r24, r16
    16c2:	41 96       	adiw	r24, 0x11	; 17
    16c4:	0e 94 d3 0c 	call	0x19a6	; 0x19a6 <xTaskRemoveFromEventList>
    16c8:	81 30       	cpi	r24, 0x01	; 1
    16ca:	11 f4       	brne	.+4      	; 0x16d0 <xQueueGenericSend+0x82>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    16cc:	0e 94 9b 11 	call	0x2336	; 0x2336 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    16d0:	0f 90       	pop	r0
    16d2:	0f be       	out	0x3f, r0	; 63
    16d4:	81 e0       	ldi	r24, 0x01	; 1
    16d6:	4c c0       	rjmp	.+152    	; 0x1770 <xQueueGenericSend+0x122>
				function. */
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    16d8:	8c 81       	ldd	r24, Y+4	; 0x04
    16da:	9d 81       	ldd	r25, Y+5	; 0x05
    16dc:	89 2b       	or	r24, r25
    16de:	19 f4       	brne	.+6      	; 0x16e6 <xQueueGenericSend+0x98>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    16e0:	0f 90       	pop	r0
    16e2:	0f be       	out	0x3f, r0	; 63
    16e4:	44 c0       	rjmp	.+136    	; 0x176e <xQueueGenericSend+0x120>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    16e6:	22 23       	and	r18, r18
    16e8:	19 f4       	brne	.+6      	; 0x16f0 <xQueueGenericSend+0xa2>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    16ea:	c5 01       	movw	r24, r10
    16ec:	0e 94 8a 0c 	call	0x1914	; 0x1914 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    16f0:	0f 90       	pop	r0
    16f2:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    16f4:	0e 94 2e 0c 	call	0x185c	; 0x185c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    16f8:	0f b6       	in	r0, 0x3f	; 63
    16fa:	f8 94       	cli
    16fc:	0f 92       	push	r0
    16fe:	f8 01       	movw	r30, r16
    1700:	85 8d       	ldd	r24, Z+29	; 0x1d
    1702:	8f 3f       	cpi	r24, 0xFF	; 255
    1704:	09 f4       	brne	.+2      	; 0x1708 <xQueueGenericSend+0xba>
    1706:	15 8e       	std	Z+29, r1	; 0x1d
    1708:	f8 01       	movw	r30, r16
    170a:	86 8d       	ldd	r24, Z+30	; 0x1e
    170c:	8f 3f       	cpi	r24, 0xFF	; 255
    170e:	09 f4       	brne	.+2      	; 0x1712 <xQueueGenericSend+0xc4>
    1710:	16 8e       	std	Z+30, r1	; 0x1e
    1712:	0f 90       	pop	r0
    1714:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1716:	c5 01       	movw	r24, r10
    1718:	b4 01       	movw	r22, r8
    171a:	0e 94 95 0c 	call	0x192a	; 0x192a <xTaskCheckForTimeOut>
    171e:	88 23       	and	r24, r24
    1720:	09 f5       	brne	.+66     	; 0x1764 <xQueueGenericSend+0x116>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1722:	0f b6       	in	r0, 0x3f	; 63
    1724:	f8 94       	cli
    1726:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    1728:	f8 01       	movw	r30, r16
    172a:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    172c:	0f 90       	pop	r0
    172e:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
    1730:	f8 01       	movw	r30, r16
    1732:	83 8d       	ldd	r24, Z+27	; 0x1b
    1734:	98 17       	cp	r25, r24
    1736:	81 f4       	brne	.+32     	; 0x1758 <xQueueGenericSend+0x10a>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1738:	6c 81       	ldd	r22, Y+4	; 0x04
    173a:	7d 81       	ldd	r23, Y+5	; 0x05
    173c:	c7 01       	movw	r24, r14
    173e:	0e 94 8c 0d 	call	0x1b18	; 0x1b18 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1742:	c8 01       	movw	r24, r16
    1744:	0e 94 1b 0a 	call	0x1436	; 0x1436 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
    1748:	0e 94 c5 0d 	call	0x1b8a	; 0x1b8a <xTaskResumeAll>
    174c:	88 23       	and	r24, r24
    174e:	09 f0       	breq	.+2      	; 0x1752 <xQueueGenericSend+0x104>
    1750:	a5 cf       	rjmp	.-182    	; 0x169c <xQueueGenericSend+0x4e>
				{
					portYIELD_WITHIN_API();
    1752:	0e 94 9b 11 	call	0x2336	; 0x2336 <vPortYield>
    1756:	a2 cf       	rjmp	.-188    	; 0x169c <xQueueGenericSend+0x4e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1758:	c8 01       	movw	r24, r16
    175a:	0e 94 1b 0a 	call	0x1436	; 0x1436 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    175e:	0e 94 c5 0d 	call	0x1b8a	; 0x1b8a <xTaskResumeAll>
    1762:	9c cf       	rjmp	.-200    	; 0x169c <xQueueGenericSend+0x4e>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1764:	c8 01       	movw	r24, r16
    1766:	0e 94 1b 0a 	call	0x1436	; 0x1436 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    176a:	0e 94 c5 0d 	call	0x1b8a	; 0x1b8a <xTaskResumeAll>
    176e:	80 e0       	ldi	r24, 0x00	; 0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
    1770:	0f 90       	pop	r0
    1772:	0f 90       	pop	r0
    1774:	0f 90       	pop	r0
    1776:	0f 90       	pop	r0
    1778:	0f 90       	pop	r0
    177a:	cf 91       	pop	r28
    177c:	df 91       	pop	r29
    177e:	1f 91       	pop	r17
    1780:	0f 91       	pop	r16
    1782:	ff 90       	pop	r15
    1784:	ef 90       	pop	r14
    1786:	df 90       	pop	r13
    1788:	cf 90       	pop	r12
    178a:	bf 90       	pop	r11
    178c:	af 90       	pop	r10
    178e:	9f 90       	pop	r9
    1790:	8f 90       	pop	r8
    1792:	7f 90       	pop	r7
    1794:	08 95       	ret

00001796 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    1796:	8f 92       	push	r8
    1798:	9f 92       	push	r9
    179a:	af 92       	push	r10
    179c:	bf 92       	push	r11
    179e:	cf 92       	push	r12
    17a0:	df 92       	push	r13
    17a2:	ef 92       	push	r14
    17a4:	ff 92       	push	r15
    17a6:	0f 93       	push	r16
    17a8:	1f 93       	push	r17
    17aa:	cf 93       	push	r28
    17ac:	df 93       	push	r29
    17ae:	98 2e       	mov	r9, r24
    17b0:	86 2e       	mov	r8, r22
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    17b2:	88 23       	and	r24, r24
    17b4:	09 f4       	brne	.+2      	; 0x17b8 <xQueueCreate+0x22>
    17b6:	42 c0       	rjmp	.+132    	; 0x183c <xQueueCreate+0xa6>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    17b8:	8f e1       	ldi	r24, 0x1F	; 31
    17ba:	90 e0       	ldi	r25, 0x00	; 0
    17bc:	0e 94 ce 13 	call	0x279c	; 0x279c <pvPortMalloc>
    17c0:	8c 01       	movw	r16, r24
    17c2:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    17c4:	00 97       	sbiw	r24, 0x00	; 0
    17c6:	e1 f1       	breq	.+120    	; 0x1840 <xQueueCreate+0xaa>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    17c8:	c9 2c       	mov	r12, r9
    17ca:	dd 24       	eor	r13, r13
    17cc:	a8 2c       	mov	r10, r8
    17ce:	bb 24       	eor	r11, r11
    17d0:	ac 9c       	mul	r10, r12
    17d2:	70 01       	movw	r14, r0
    17d4:	ad 9c       	mul	r10, r13
    17d6:	f0 0c       	add	r15, r0
    17d8:	bc 9c       	mul	r11, r12
    17da:	f0 0c       	add	r15, r0
    17dc:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    17de:	c7 01       	movw	r24, r14
    17e0:	01 96       	adiw	r24, 0x01	; 1
    17e2:	0e 94 ce 13 	call	0x279c	; 0x279c <pvPortMalloc>
    17e6:	9c 01       	movw	r18, r24
    17e8:	99 83       	std	Y+1, r25	; 0x01
    17ea:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    17ec:	00 97       	sbiw	r24, 0x00	; 0
    17ee:	19 f1       	breq	.+70     	; 0x1836 <xQueueCreate+0xa0>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    17f0:	e8 0e       	add	r14, r24
    17f2:	f9 1e       	adc	r15, r25
    17f4:	fb 82       	std	Y+3, r15	; 0x03
    17f6:	ea 82       	std	Y+2, r14	; 0x02
				pxNewQueue->uxMessagesWaiting = 0;
    17f8:	1a 8e       	std	Y+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    17fa:	9d 83       	std	Y+5, r25	; 0x05
    17fc:	8c 83       	std	Y+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
    17fe:	08 94       	sec
    1800:	c1 08       	sbc	r12, r1
    1802:	d1 08       	sbc	r13, r1
    1804:	ca 9c       	mul	r12, r10
    1806:	c0 01       	movw	r24, r0
    1808:	cb 9c       	mul	r12, r11
    180a:	90 0d       	add	r25, r0
    180c:	da 9c       	mul	r13, r10
    180e:	90 0d       	add	r25, r0
    1810:	11 24       	eor	r1, r1
    1812:	28 0f       	add	r18, r24
    1814:	39 1f       	adc	r19, r25
    1816:	3f 83       	std	Y+7, r19	; 0x07
    1818:	2e 83       	std	Y+6, r18	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    181a:	9b 8e       	std	Y+27, r9	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    181c:	8c 8e       	std	Y+28, r8	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    181e:	8f ef       	ldi	r24, 0xFF	; 255
    1820:	8d 8f       	std	Y+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    1822:	8e 8f       	std	Y+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    1824:	c8 01       	movw	r24, r16
    1826:	08 96       	adiw	r24, 0x08	; 8
    1828:	0e 94 af 08 	call	0x115e	; 0x115e <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    182c:	c8 01       	movw	r24, r16
    182e:	41 96       	adiw	r24, 0x11	; 17
    1830:	0e 94 af 08 	call	0x115e	; 0x115e <vListInitialise>
    1834:	05 c0       	rjmp	.+10     	; 0x1840 <xQueueCreate+0xaa>
				return  pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    1836:	c8 01       	movw	r24, r16
    1838:	0e 94 be 13 	call	0x277c	; 0x277c <vPortFree>
    183c:	c0 e0       	ldi	r28, 0x00	; 0
    183e:	d0 e0       	ldi	r29, 0x00	; 0
	}

	/* Will only reach here if we could not allocate enough memory or no memory
	was required. */
	return NULL;
}
    1840:	ce 01       	movw	r24, r28
    1842:	df 91       	pop	r29
    1844:	cf 91       	pop	r28
    1846:	1f 91       	pop	r17
    1848:	0f 91       	pop	r16
    184a:	ff 90       	pop	r15
    184c:	ef 90       	pop	r14
    184e:	df 90       	pop	r13
    1850:	cf 90       	pop	r12
    1852:	bf 90       	pop	r11
    1854:	af 90       	pop	r10
    1856:	9f 90       	pop	r9
    1858:	8f 90       	pop	r8
    185a:	08 95       	ret

0000185c <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    185c:	80 91 a2 02 	lds	r24, 0x02A2
    1860:	8f 5f       	subi	r24, 0xFF	; 255
    1862:	80 93 a2 02 	sts	0x02A2, r24
}
    1866:	08 95       	ret

00001868 <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portENTER_CRITICAL();
    1868:	0f b6       	in	r0, 0x3f	; 63
    186a:	f8 94       	cli
    186c:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    186e:	20 91 a0 02 	lds	r18, 0x02A0
    1872:	30 91 a1 02 	lds	r19, 0x02A1
	}
	portEXIT_CRITICAL();
    1876:	0f 90       	pop	r0
    1878:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    187a:	c9 01       	movw	r24, r18
    187c:	08 95       	ret

0000187e <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
	return xTickCount;
    187e:	20 91 a0 02 	lds	r18, 0x02A0
    1882:	30 91 a1 02 	lds	r19, 0x02A1
}
    1886:	c9 01       	movw	r24, r18
    1888:	08 95       	ret

0000188a <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    188a:	80 91 a5 02 	lds	r24, 0x02A5
}
    188e:	08 95       	ret

00001890 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    1890:	80 91 a2 02 	lds	r24, 0x02A2
    1894:	88 23       	and	r24, r24
    1896:	51 f0       	breq	.+20     	; 0x18ac <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    1898:	81 e0       	ldi	r24, 0x01	; 1
    189a:	80 93 9e 02 	sts	0x029E, r24
    189e:	08 95       	ret
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
	{
		--uxTopReadyPriority;
    18a0:	80 91 a3 02 	lds	r24, 0x02A3
    18a4:	81 50       	subi	r24, 0x01	; 1
    18a6:	80 93 a3 02 	sts	0x02A3, r24
    18aa:	01 c0       	rjmp	.+2      	; 0x18ae <vTaskSwitchContext+0x1e>

	taskFIRST_CHECK_FOR_STACK_OVERFLOW();
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    18ac:	99 e0       	ldi	r25, 0x09	; 9
    18ae:	e0 91 a3 02 	lds	r30, 0x02A3
    18b2:	e9 9f       	mul	r30, r25
    18b4:	f0 01       	movw	r30, r0
    18b6:	11 24       	eor	r1, r1
    18b8:	e6 55       	subi	r30, 0x56	; 86
    18ba:	fd 4f       	sbci	r31, 0xFD	; 253
    18bc:	80 81       	ld	r24, Z
    18be:	88 23       	and	r24, r24
    18c0:	79 f3       	breq	.-34     	; 0x18a0 <vTaskSwitchContext+0x10>
		--uxTopReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    18c2:	90 91 a3 02 	lds	r25, 0x02A3
    18c6:	89 e0       	ldi	r24, 0x09	; 9
    18c8:	98 9f       	mul	r25, r24
    18ca:	d0 01       	movw	r26, r0
    18cc:	11 24       	eor	r1, r1
    18ce:	a6 55       	subi	r26, 0x56	; 86
    18d0:	bd 4f       	sbci	r27, 0xFD	; 253
    18d2:	11 96       	adiw	r26, 0x01	; 1
    18d4:	ed 91       	ld	r30, X+
    18d6:	fc 91       	ld	r31, X
    18d8:	12 97       	sbiw	r26, 0x02	; 2
    18da:	02 80       	ldd	r0, Z+2	; 0x02
    18dc:	f3 81       	ldd	r31, Z+3	; 0x03
    18de:	e0 2d       	mov	r30, r0
    18e0:	12 96       	adiw	r26, 0x02	; 2
    18e2:	fc 93       	st	X, r31
    18e4:	ee 93       	st	-X, r30
    18e6:	11 97       	sbiw	r26, 0x01	; 1
    18e8:	cd 01       	movw	r24, r26
    18ea:	03 96       	adiw	r24, 0x03	; 3
    18ec:	e8 17       	cp	r30, r24
    18ee:	f9 07       	cpc	r31, r25
    18f0:	31 f4       	brne	.+12     	; 0x18fe <vTaskSwitchContext+0x6e>
    18f2:	82 81       	ldd	r24, Z+2	; 0x02
    18f4:	93 81       	ldd	r25, Z+3	; 0x03
    18f6:	12 96       	adiw	r26, 0x02	; 2
    18f8:	9c 93       	st	X, r25
    18fa:	8e 93       	st	-X, r24
    18fc:	11 97       	sbiw	r26, 0x01	; 1
    18fe:	11 96       	adiw	r26, 0x01	; 1
    1900:	ed 91       	ld	r30, X+
    1902:	fc 91       	ld	r31, X
    1904:	12 97       	sbiw	r26, 0x02	; 2
    1906:	86 81       	ldd	r24, Z+6	; 0x06
    1908:	97 81       	ldd	r25, Z+7	; 0x07
    190a:	90 93 9d 02 	sts	0x029D, r25
    190e:	80 93 9c 02 	sts	0x029C, r24
    1912:	08 95       	ret

00001914 <vTaskSetTimeOutState>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    1914:	fc 01       	movw	r30, r24
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1916:	80 91 9f 02 	lds	r24, 0x029F
    191a:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    191c:	80 91 a0 02 	lds	r24, 0x02A0
    1920:	90 91 a1 02 	lds	r25, 0x02A1
    1924:	92 83       	std	Z+2, r25	; 0x02
    1926:	81 83       	std	Z+1, r24	; 0x01
}
    1928:	08 95       	ret

0000192a <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    192a:	fc 01       	movw	r30, r24
    192c:	db 01       	movw	r26, r22
portBASE_TYPE xReturn;

	portENTER_CRITICAL();
    192e:	0f b6       	in	r0, 0x3f	; 63
    1930:	f8 94       	cli
    1932:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    1934:	90 91 9f 02 	lds	r25, 0x029F
    1938:	80 81       	ld	r24, Z
    193a:	98 17       	cp	r25, r24
    193c:	49 f0       	breq	.+18     	; 0x1950 <xTaskCheckForTimeOut+0x26>
    193e:	20 91 a0 02 	lds	r18, 0x02A0
    1942:	30 91 a1 02 	lds	r19, 0x02A1
    1946:	81 81       	ldd	r24, Z+1	; 0x01
    1948:	92 81       	ldd	r25, Z+2	; 0x02
    194a:	28 17       	cp	r18, r24
    194c:	39 07       	cpc	r19, r25
    194e:	18 f5       	brcc	.+70     	; 0x1996 <xTaskCheckForTimeOut+0x6c>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    1950:	80 91 a0 02 	lds	r24, 0x02A0
    1954:	90 91 a1 02 	lds	r25, 0x02A1
    1958:	21 81       	ldd	r18, Z+1	; 0x01
    195a:	32 81       	ldd	r19, Z+2	; 0x02
    195c:	4d 91       	ld	r20, X+
    195e:	5c 91       	ld	r21, X
    1960:	11 97       	sbiw	r26, 0x01	; 1
    1962:	82 1b       	sub	r24, r18
    1964:	93 0b       	sbc	r25, r19
    1966:	84 17       	cp	r24, r20
    1968:	95 07       	cpc	r25, r21
    196a:	a8 f4       	brcc	.+42     	; 0x1996 <xTaskCheckForTimeOut+0x6c>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    196c:	80 91 a0 02 	lds	r24, 0x02A0
    1970:	90 91 a1 02 	lds	r25, 0x02A1
    1974:	28 1b       	sub	r18, r24
    1976:	39 0b       	sbc	r19, r25
    1978:	24 0f       	add	r18, r20
    197a:	35 1f       	adc	r19, r21
    197c:	2d 93       	st	X+, r18
    197e:	3c 93       	st	X, r19
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1980:	80 91 9f 02 	lds	r24, 0x029F
    1984:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    1986:	80 91 a0 02 	lds	r24, 0x02A0
    198a:	90 91 a1 02 	lds	r25, 0x02A1
    198e:	92 83       	std	Z+2, r25	; 0x02
    1990:	81 83       	std	Z+1, r24	; 0x01
    1992:	80 e0       	ldi	r24, 0x00	; 0
    1994:	01 c0       	rjmp	.+2      	; 0x1998 <xTaskCheckForTimeOut+0x6e>
    1996:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			xReturn = pdTRUE;
		}
	}
	portEXIT_CRITICAL();
    1998:	0f 90       	pop	r0
    199a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    199c:	08 95       	ret

0000199e <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    199e:	81 e0       	ldi	r24, 0x01	; 1
    19a0:	80 93 9e 02 	sts	0x029E, r24
}
    19a4:	08 95       	ret

000019a6 <xTaskRemoveFromEventList>:
	#endif
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    19a6:	0f 93       	push	r16
    19a8:	1f 93       	push	r17
    19aa:	cf 93       	push	r28
    19ac:	df 93       	push	r29
    19ae:	fc 01       	movw	r30, r24
	it to the ready list.

	If an event is for a queue that is locked then this function will never
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    19b0:	80 81       	ld	r24, Z
    19b2:	88 23       	and	r24, r24
    19b4:	19 f4       	brne	.+6      	; 0x19bc <xTaskRemoveFromEventList+0x16>
    19b6:	c0 e0       	ldi	r28, 0x00	; 0
    19b8:	d0 e0       	ldi	r29, 0x00	; 0
    19ba:	05 c0       	rjmp	.+10     	; 0x19c6 <xTaskRemoveFromEventList+0x20>
    19bc:	05 80       	ldd	r0, Z+5	; 0x05
    19be:	f6 81       	ldd	r31, Z+6	; 0x06
    19c0:	e0 2d       	mov	r30, r0
    19c2:	c6 81       	ldd	r28, Z+6	; 0x06
    19c4:	d7 81       	ldd	r29, Z+7	; 0x07
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    19c6:	8e 01       	movw	r16, r28
    19c8:	04 5f       	subi	r16, 0xF4	; 244
    19ca:	1f 4f       	sbci	r17, 0xFF	; 255
    19cc:	c8 01       	movw	r24, r16
    19ce:	0e 94 21 09 	call	0x1242	; 0x1242 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    19d2:	80 91 a2 02 	lds	r24, 0x02A2
    19d6:	88 23       	and	r24, r24
    19d8:	a1 f4       	brne	.+40     	; 0x1a02 <xTaskRemoveFromEventList+0x5c>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    19da:	8e 01       	movw	r16, r28
    19dc:	0e 5f       	subi	r16, 0xFE	; 254
    19de:	1f 4f       	sbci	r17, 0xFF	; 255
    19e0:	c8 01       	movw	r24, r16
    19e2:	0e 94 21 09 	call	0x1242	; 0x1242 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    19e6:	9e 89       	ldd	r25, Y+22	; 0x16
    19e8:	80 91 a3 02 	lds	r24, 0x02A3
    19ec:	89 17       	cp	r24, r25
    19ee:	10 f4       	brcc	.+4      	; 0x19f4 <xTaskRemoveFromEventList+0x4e>
    19f0:	90 93 a3 02 	sts	0x02A3, r25
    19f4:	89 e0       	ldi	r24, 0x09	; 9
    19f6:	98 9f       	mul	r25, r24
    19f8:	c0 01       	movw	r24, r0
    19fa:	11 24       	eor	r1, r1
    19fc:	86 55       	subi	r24, 0x56	; 86
    19fe:	9d 4f       	sbci	r25, 0xFD	; 253
    1a00:	02 c0       	rjmp	.+4      	; 0x1a06 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    1a02:	84 ee       	ldi	r24, 0xE4	; 228
    1a04:	92 e0       	ldi	r25, 0x02	; 2
    1a06:	b8 01       	movw	r22, r16
    1a08:	0e 94 c3 08 	call	0x1186	; 0x1186 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1a0c:	e0 91 9c 02 	lds	r30, 0x029C
    1a10:	f0 91 9d 02 	lds	r31, 0x029D
    1a14:	20 e0       	ldi	r18, 0x00	; 0
    1a16:	9e 89       	ldd	r25, Y+22	; 0x16
    1a18:	86 89       	ldd	r24, Z+22	; 0x16
    1a1a:	98 17       	cp	r25, r24
    1a1c:	08 f0       	brcs	.+2      	; 0x1a20 <xTaskRemoveFromEventList+0x7a>
    1a1e:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    1a20:	82 2f       	mov	r24, r18
    1a22:	df 91       	pop	r29
    1a24:	cf 91       	pop	r28
    1a26:	1f 91       	pop	r17
    1a28:	0f 91       	pop	r16
    1a2a:	08 95       	ret

00001a2c <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
    1a2c:	ff 92       	push	r15
    1a2e:	0f 93       	push	r16
    1a30:	1f 93       	push	r17
    1a32:	cf 93       	push	r28
    1a34:	df 93       	push	r29
	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1a36:	80 91 a2 02 	lds	r24, 0x02A2
    1a3a:	88 23       	and	r24, r24
    1a3c:	09 f0       	breq	.+2      	; 0x1a40 <vTaskIncrementTick+0x14>
    1a3e:	61 c0       	rjmp	.+194    	; 0x1b02 <vTaskIncrementTick+0xd6>
	{
		++xTickCount;
    1a40:	80 91 a0 02 	lds	r24, 0x02A0
    1a44:	90 91 a1 02 	lds	r25, 0x02A1
    1a48:	01 96       	adiw	r24, 0x01	; 1
    1a4a:	90 93 a1 02 	sts	0x02A1, r25
    1a4e:	80 93 a0 02 	sts	0x02A0, r24
		if( xTickCount == ( portTickType ) 0 )
    1a52:	80 91 a0 02 	lds	r24, 0x02A0
    1a56:	90 91 a1 02 	lds	r25, 0x02A1
    1a5a:	89 2b       	or	r24, r25
    1a5c:	e9 f5       	brne	.+122    	; 0x1ad8 <vTaskIncrementTick+0xac>
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			pxTemp = pxDelayedTaskList;
    1a5e:	80 91 e0 02 	lds	r24, 0x02E0
    1a62:	90 91 e1 02 	lds	r25, 0x02E1
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    1a66:	20 91 e2 02 	lds	r18, 0x02E2
    1a6a:	30 91 e3 02 	lds	r19, 0x02E3
    1a6e:	30 93 e1 02 	sts	0x02E1, r19
    1a72:	20 93 e0 02 	sts	0x02E0, r18
			pxOverflowDelayedTaskList = pxTemp;
    1a76:	90 93 e3 02 	sts	0x02E3, r25
    1a7a:	80 93 e2 02 	sts	0x02E2, r24
			xNumOfOverflows++;
    1a7e:	80 91 9f 02 	lds	r24, 0x029F
    1a82:	8f 5f       	subi	r24, 0xFF	; 255
    1a84:	80 93 9f 02 	sts	0x029F, r24
    1a88:	27 c0       	rjmp	.+78     	; 0x1ad8 <vTaskIncrementTick+0xac>
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    1a8a:	20 91 a0 02 	lds	r18, 0x02A0
    1a8e:	30 91 a1 02 	lds	r19, 0x02A1
    1a92:	8a 81       	ldd	r24, Y+2	; 0x02
    1a94:	9b 81       	ldd	r25, Y+3	; 0x03
    1a96:	28 17       	cp	r18, r24
    1a98:	39 07       	cpc	r19, r25
    1a9a:	c0 f1       	brcs	.+112    	; 0x1b0c <vTaskIncrementTick+0xe0>
    1a9c:	8e 01       	movw	r16, r28
    1a9e:	0e 5f       	subi	r16, 0xFE	; 254
    1aa0:	1f 4f       	sbci	r17, 0xFF	; 255
    1aa2:	c8 01       	movw	r24, r16
    1aa4:	0e 94 21 09 	call	0x1242	; 0x1242 <vListRemove>
    1aa8:	8c 89       	ldd	r24, Y+20	; 0x14
    1aaa:	9d 89       	ldd	r25, Y+21	; 0x15
    1aac:	89 2b       	or	r24, r25
    1aae:	21 f0       	breq	.+8      	; 0x1ab8 <vTaskIncrementTick+0x8c>
    1ab0:	ce 01       	movw	r24, r28
    1ab2:	0c 96       	adiw	r24, 0x0c	; 12
    1ab4:	0e 94 21 09 	call	0x1242	; 0x1242 <vListRemove>
    1ab8:	9e 89       	ldd	r25, Y+22	; 0x16
    1aba:	80 91 a3 02 	lds	r24, 0x02A3
    1abe:	89 17       	cp	r24, r25
    1ac0:	10 f4       	brcc	.+4      	; 0x1ac6 <vTaskIncrementTick+0x9a>
    1ac2:	90 93 a3 02 	sts	0x02A3, r25
    1ac6:	9f 9d       	mul	r25, r15
    1ac8:	c0 01       	movw	r24, r0
    1aca:	11 24       	eor	r1, r1
    1acc:	86 55       	subi	r24, 0x56	; 86
    1ace:	9d 4f       	sbci	r25, 0xFD	; 253
    1ad0:	b8 01       	movw	r22, r16
    1ad2:	0e 94 c3 08 	call	0x1186	; 0x1186 <vListInsertEnd>
    1ad6:	02 c0       	rjmp	.+4      	; 0x1adc <vTaskIncrementTick+0xb0>
    1ad8:	89 e0       	ldi	r24, 0x09	; 9
    1ada:	f8 2e       	mov	r15, r24
    1adc:	e0 91 e0 02 	lds	r30, 0x02E0
    1ae0:	f0 91 e1 02 	lds	r31, 0x02E1
    1ae4:	80 81       	ld	r24, Z
    1ae6:	88 23       	and	r24, r24
    1ae8:	89 f0       	breq	.+34     	; 0x1b0c <vTaskIncrementTick+0xe0>
    1aea:	e0 91 e0 02 	lds	r30, 0x02E0
    1aee:	f0 91 e1 02 	lds	r31, 0x02E1
    1af2:	05 80       	ldd	r0, Z+5	; 0x05
    1af4:	f6 81       	ldd	r31, Z+6	; 0x06
    1af6:	e0 2d       	mov	r30, r0
    1af8:	c6 81       	ldd	r28, Z+6	; 0x06
    1afa:	d7 81       	ldd	r29, Z+7	; 0x07
    1afc:	20 97       	sbiw	r28, 0x00	; 0
    1afe:	29 f6       	brne	.-118    	; 0x1a8a <vTaskIncrementTick+0x5e>
    1b00:	05 c0       	rjmp	.+10     	; 0x1b0c <vTaskIncrementTick+0xe0>
	}
	else
	{
		++uxMissedTicks;
    1b02:	80 91 a4 02 	lds	r24, 0x02A4
    1b06:	8f 5f       	subi	r24, 0xFF	; 255
    1b08:	80 93 a4 02 	sts	0x02A4, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    1b0c:	df 91       	pop	r29
    1b0e:	cf 91       	pop	r28
    1b10:	1f 91       	pop	r17
    1b12:	0f 91       	pop	r16
    1b14:	ff 90       	pop	r15
    1b16:	08 95       	ret

00001b18 <vTaskPlaceOnEventList>:
	vWriteTraceToBuffer();
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    1b18:	0f 93       	push	r16
    1b1a:	1f 93       	push	r17
    1b1c:	8b 01       	movw	r16, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    1b1e:	60 91 9c 02 	lds	r22, 0x029C
    1b22:	70 91 9d 02 	lds	r23, 0x029D
    1b26:	64 5f       	subi	r22, 0xF4	; 244
    1b28:	7f 4f       	sbci	r23, 0xFF	; 255
    1b2a:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1b2e:	80 91 9c 02 	lds	r24, 0x029C
    1b32:	90 91 9d 02 	lds	r25, 0x029D
    1b36:	02 96       	adiw	r24, 0x02	; 2
    1b38:	0e 94 21 09 	call	0x1242	; 0x1242 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    1b3c:	80 91 a0 02 	lds	r24, 0x02A0
    1b40:	90 91 a1 02 	lds	r25, 0x02A1
    1b44:	80 0f       	add	r24, r16
    1b46:	91 1f       	adc	r25, r17

			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    1b48:	e0 91 9c 02 	lds	r30, 0x029C
    1b4c:	f0 91 9d 02 	lds	r31, 0x029D
    1b50:	93 83       	std	Z+3, r25	; 0x03
    1b52:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xTickCount )
    1b54:	20 91 a0 02 	lds	r18, 0x02A0
    1b58:	30 91 a1 02 	lds	r19, 0x02A1
    1b5c:	82 17       	cp	r24, r18
    1b5e:	93 07       	cpc	r25, r19
    1b60:	28 f4       	brcc	.+10     	; 0x1b6c <vTaskPlaceOnEventList+0x54>
			{
				/* Wake time has overflowed.  Place this item in the overflow list. */
				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1b62:	80 91 e2 02 	lds	r24, 0x02E2
    1b66:	90 91 e3 02 	lds	r25, 0x02E3
    1b6a:	04 c0       	rjmp	.+8      	; 0x1b74 <vTaskPlaceOnEventList+0x5c>
			}
			else
			{
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1b6c:	80 91 e0 02 	lds	r24, 0x02E0
    1b70:	90 91 e1 02 	lds	r25, 0x02E1
    1b74:	60 91 9c 02 	lds	r22, 0x029C
    1b78:	70 91 9d 02 	lds	r23, 0x029D
    1b7c:	6e 5f       	subi	r22, 0xFE	; 254
    1b7e:	7f 4f       	sbci	r23, 0xFF	; 255
    1b80:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <vListInsert>
			}
	}
	#endif
}
    1b84:	1f 91       	pop	r17
    1b86:	0f 91       	pop	r16
    1b88:	08 95       	ret

00001b8a <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    1b8a:	cf 92       	push	r12
    1b8c:	df 92       	push	r13
    1b8e:	ff 92       	push	r15
    1b90:	0f 93       	push	r16
    1b92:	1f 93       	push	r17
    1b94:	df 93       	push	r29
    1b96:	cf 93       	push	r28
    1b98:	0f 92       	push	r0
    1b9a:	cd b7       	in	r28, 0x3d	; 61
    1b9c:	de b7       	in	r29, 0x3e	; 62
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	portENTER_CRITICAL();
    1b9e:	0f b6       	in	r0, 0x3f	; 63
    1ba0:	f8 94       	cli
    1ba2:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    1ba4:	80 91 a2 02 	lds	r24, 0x02A2
    1ba8:	81 50       	subi	r24, 0x01	; 1
    1baa:	80 93 a2 02 	sts	0x02A2, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1bae:	80 91 a2 02 	lds	r24, 0x02A2
    1bb2:	88 23       	and	r24, r24
    1bb4:	09 f0       	breq	.+2      	; 0x1bb8 <xTaskResumeAll+0x2e>
    1bb6:	5b c0       	rjmp	.+182    	; 0x1c6e <xTaskResumeAll+0xe4>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
    1bb8:	80 91 a5 02 	lds	r24, 0x02A5
    1bbc:	88 23       	and	r24, r24
    1bbe:	09 f4       	brne	.+2      	; 0x1bc2 <xTaskResumeAll+0x38>
    1bc0:	56 c0       	rjmp	.+172    	; 0x1c6e <xTaskResumeAll+0xe4>
    1bc2:	19 82       	std	Y+1, r1	; 0x01
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    1bc4:	99 e0       	ldi	r25, 0x09	; 9
    1bc6:	f9 2e       	mov	r15, r25
    1bc8:	27 c0       	rjmp	.+78     	; 0x1c18 <xTaskResumeAll+0x8e>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
    1bca:	c6 01       	movw	r24, r12
    1bcc:	0c 96       	adiw	r24, 0x0c	; 12
    1bce:	0e 94 21 09 	call	0x1242	; 0x1242 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    1bd2:	86 01       	movw	r16, r12
    1bd4:	0e 5f       	subi	r16, 0xFE	; 254
    1bd6:	1f 4f       	sbci	r17, 0xFF	; 255
    1bd8:	c8 01       	movw	r24, r16
    1bda:	0e 94 21 09 	call	0x1242	; 0x1242 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1bde:	d6 01       	movw	r26, r12
    1be0:	56 96       	adiw	r26, 0x16	; 22
    1be2:	9c 91       	ld	r25, X
    1be4:	80 91 a3 02 	lds	r24, 0x02A3
    1be8:	89 17       	cp	r24, r25
    1bea:	10 f4       	brcc	.+4      	; 0x1bf0 <xTaskResumeAll+0x66>
    1bec:	90 93 a3 02 	sts	0x02A3, r25
    1bf0:	9f 9d       	mul	r25, r15
    1bf2:	c0 01       	movw	r24, r0
    1bf4:	11 24       	eor	r1, r1
    1bf6:	86 55       	subi	r24, 0x56	; 86
    1bf8:	9d 4f       	sbci	r25, 0xFD	; 253
    1bfa:	b8 01       	movw	r22, r16
    1bfc:	0e 94 c3 08 	call	0x1186	; 0x1186 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1c00:	e0 91 9c 02 	lds	r30, 0x029C
    1c04:	f0 91 9d 02 	lds	r31, 0x029D
    1c08:	d6 01       	movw	r26, r12
    1c0a:	56 96       	adiw	r26, 0x16	; 22
    1c0c:	9c 91       	ld	r25, X
    1c0e:	86 89       	ldd	r24, Z+22	; 0x16
    1c10:	98 17       	cp	r25, r24
    1c12:	10 f0       	brcs	.+4      	; 0x1c18 <xTaskResumeAll+0x8e>
    1c14:	b1 e0       	ldi	r27, 0x01	; 1
    1c16:	b9 83       	std	Y+1, r27	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
    1c18:	80 91 e4 02 	lds	r24, 0x02E4
    1c1c:	88 23       	and	r24, r24
    1c1e:	49 f0       	breq	.+18     	; 0x1c32 <xTaskResumeAll+0xa8>
    1c20:	e0 91 e9 02 	lds	r30, 0x02E9
    1c24:	f0 91 ea 02 	lds	r31, 0x02EA
    1c28:	c6 80       	ldd	r12, Z+6	; 0x06
    1c2a:	d7 80       	ldd	r13, Z+7	; 0x07
    1c2c:	c1 14       	cp	r12, r1
    1c2e:	d1 04       	cpc	r13, r1
    1c30:	61 f6       	brne	.-104    	; 0x1bca <xTaskResumeAll+0x40>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    1c32:	80 91 a4 02 	lds	r24, 0x02A4
    1c36:	88 23       	and	r24, r24
    1c38:	41 f4       	brne	.+16     	; 0x1c4a <xTaskResumeAll+0xc0>
    1c3a:	0c c0       	rjmp	.+24     	; 0x1c54 <xTaskResumeAll+0xca>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
    1c3c:	0e 94 16 0d 	call	0x1a2c	; 0x1a2c <vTaskIncrementTick>
						--uxMissedTicks;
    1c40:	80 91 a4 02 	lds	r24, 0x02A4
    1c44:	81 50       	subi	r24, 0x01	; 1
    1c46:	80 93 a4 02 	sts	0x02A4, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    1c4a:	80 91 a4 02 	lds	r24, 0x02A4
    1c4e:	88 23       	and	r24, r24
    1c50:	a9 f7       	brne	.-22     	; 0x1c3c <xTaskResumeAll+0xb2>
    1c52:	07 c0       	rjmp	.+14     	; 0x1c62 <xTaskResumeAll+0xd8>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    1c54:	e9 81       	ldd	r30, Y+1	; 0x01
    1c56:	e1 30       	cpi	r30, 0x01	; 1
    1c58:	21 f0       	breq	.+8      	; 0x1c62 <xTaskResumeAll+0xd8>
    1c5a:	80 91 9e 02 	lds	r24, 0x029E
    1c5e:	81 30       	cpi	r24, 0x01	; 1
    1c60:	31 f4       	brne	.+12     	; 0x1c6e <xTaskResumeAll+0xe4>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    1c62:	10 92 9e 02 	sts	0x029E, r1
					portYIELD_WITHIN_API();
    1c66:	0e 94 9b 11 	call	0x2336	; 0x2336 <vPortYield>
    1c6a:	81 e0       	ldi	r24, 0x01	; 1
    1c6c:	01 c0       	rjmp	.+2      	; 0x1c70 <xTaskResumeAll+0xe6>
    1c6e:	80 e0       	ldi	r24, 0x00	; 0
				}
			}
		}
	}
	portEXIT_CRITICAL();
    1c70:	0f 90       	pop	r0
    1c72:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    1c74:	0f 90       	pop	r0
    1c76:	cf 91       	pop	r28
    1c78:	df 91       	pop	r29
    1c7a:	1f 91       	pop	r17
    1c7c:	0f 91       	pop	r16
    1c7e:	ff 90       	pop	r15
    1c80:	df 90       	pop	r13
    1c82:	cf 90       	pop	r12
    1c84:	08 95       	ret

00001c86 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1c86:	0f 93       	push	r16
    1c88:	1f 93       	push	r17
    1c8a:	9c 01       	movw	r18, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
    1c8c:	00 97       	sbiw	r24, 0x00	; 0
    1c8e:	a1 f1       	breq	.+104    	; 0x1cf8 <vTaskDelay+0x72>

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    1c90:	80 91 a2 02 	lds	r24, 0x02A2
    1c94:	8f 5f       	subi	r24, 0xFF	; 255
    1c96:	80 93 a2 02 	sts	0x02A2, r24
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1c9a:	00 91 a0 02 	lds	r16, 0x02A0
    1c9e:	10 91 a1 02 	lds	r17, 0x02A1
    1ca2:	02 0f       	add	r16, r18
    1ca4:	13 1f       	adc	r17, r19

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1ca6:	80 91 9c 02 	lds	r24, 0x029C
    1caa:	90 91 9d 02 	lds	r25, 0x029D
    1cae:	02 96       	adiw	r24, 0x02	; 2
    1cb0:	0e 94 21 09 	call	0x1242	; 0x1242 <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    1cb4:	e0 91 9c 02 	lds	r30, 0x029C
    1cb8:	f0 91 9d 02 	lds	r31, 0x029D
    1cbc:	13 83       	std	Z+3, r17	; 0x03
    1cbe:	02 83       	std	Z+2, r16	; 0x02

				if( xTimeToWake < xTickCount )
    1cc0:	80 91 a0 02 	lds	r24, 0x02A0
    1cc4:	90 91 a1 02 	lds	r25, 0x02A1
    1cc8:	08 17       	cp	r16, r24
    1cca:	19 07       	cpc	r17, r25
    1ccc:	28 f4       	brcc	.+10     	; 0x1cd8 <vTaskDelay+0x52>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1cce:	80 91 e2 02 	lds	r24, 0x02E2
    1cd2:	90 91 e3 02 	lds	r25, 0x02E3
    1cd6:	04 c0       	rjmp	.+8      	; 0x1ce0 <vTaskDelay+0x5a>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1cd8:	80 91 e0 02 	lds	r24, 0x02E0
    1cdc:	90 91 e1 02 	lds	r25, 0x02E1
    1ce0:	60 91 9c 02 	lds	r22, 0x029C
    1ce4:	70 91 9d 02 	lds	r23, 0x029D
    1ce8:	6e 5f       	subi	r22, 0xFE	; 254
    1cea:	7f 4f       	sbci	r23, 0xFF	; 255
    1cec:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <vListInsert>
				}
			}
			xAlreadyYielded = xTaskResumeAll();
    1cf0:	0e 94 c5 0d 	call	0x1b8a	; 0x1b8a <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
    1cf4:	88 23       	and	r24, r24
    1cf6:	11 f4       	brne	.+4      	; 0x1cfc <vTaskDelay+0x76>
		{
			portYIELD_WITHIN_API();
    1cf8:	0e 94 9b 11 	call	0x2336	; 0x2336 <vPortYield>
		}
	}
    1cfc:	1f 91       	pop	r17
    1cfe:	0f 91       	pop	r16
    1d00:	08 95       	ret

00001d02 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    1d02:	cf 93       	push	r28
    1d04:	df 93       	push	r29
    1d06:	fc 01       	movw	r30, r24
    1d08:	eb 01       	movw	r28, r22

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    1d0a:	80 91 a2 02 	lds	r24, 0x02A2
    1d0e:	8f 5f       	subi	r24, 0xFF	; 255
    1d10:	80 93 a2 02 	sts	0x02A2, r24
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		vTaskSuspendAll();
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1d14:	20 81       	ld	r18, Z
    1d16:	31 81       	ldd	r19, Z+1	; 0x01
    1d18:	c2 0f       	add	r28, r18
    1d1a:	d3 1f       	adc	r29, r19

			if( xTickCount < *pxPreviousWakeTime )
    1d1c:	80 91 a0 02 	lds	r24, 0x02A0
    1d20:	90 91 a1 02 	lds	r25, 0x02A1
    1d24:	82 17       	cp	r24, r18
    1d26:	93 07       	cpc	r25, r19
    1d28:	28 f4       	brcc	.+10     	; 0x1d34 <vTaskDelayUntil+0x32>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    1d2a:	c2 17       	cp	r28, r18
    1d2c:	d3 07       	cpc	r29, r19
    1d2e:	28 f0       	brcs	.+10     	; 0x1d3a <vTaskDelayUntil+0x38>
    1d30:	20 e0       	ldi	r18, 0x00	; 0
    1d32:	0c c0       	rjmp	.+24     	; 0x1d4c <vTaskDelayUntil+0x4a>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    1d34:	c2 17       	cp	r28, r18
    1d36:	d3 07       	cpc	r29, r19
    1d38:	40 f0       	brcs	.+16     	; 0x1d4a <vTaskDelayUntil+0x48>
    1d3a:	80 91 a0 02 	lds	r24, 0x02A0
    1d3e:	90 91 a1 02 	lds	r25, 0x02A1
    1d42:	20 e0       	ldi	r18, 0x00	; 0
    1d44:	8c 17       	cp	r24, r28
    1d46:	9d 07       	cpc	r25, r29
    1d48:	08 f4       	brcc	.+2      	; 0x1d4c <vTaskDelayUntil+0x4a>
    1d4a:	21 e0       	ldi	r18, 0x01	; 1
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1d4c:	d1 83       	std	Z+1, r29	; 0x01
    1d4e:	c0 83       	st	Z, r28

			if( xShouldDelay )
    1d50:	22 23       	and	r18, r18
    1d52:	29 f1       	breq	.+74     	; 0x1d9e <vTaskDelayUntil+0x9c>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1d54:	80 91 9c 02 	lds	r24, 0x029C
    1d58:	90 91 9d 02 	lds	r25, 0x029D
    1d5c:	02 96       	adiw	r24, 0x02	; 2
    1d5e:	0e 94 21 09 	call	0x1242	; 0x1242 <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    1d62:	e0 91 9c 02 	lds	r30, 0x029C
    1d66:	f0 91 9d 02 	lds	r31, 0x029D
    1d6a:	d3 83       	std	Z+3, r29	; 0x03
    1d6c:	c2 83       	std	Z+2, r28	; 0x02

				if( xTimeToWake < xTickCount )
    1d6e:	80 91 a0 02 	lds	r24, 0x02A0
    1d72:	90 91 a1 02 	lds	r25, 0x02A1
    1d76:	c8 17       	cp	r28, r24
    1d78:	d9 07       	cpc	r29, r25
    1d7a:	28 f4       	brcc	.+10     	; 0x1d86 <vTaskDelayUntil+0x84>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1d7c:	80 91 e2 02 	lds	r24, 0x02E2
    1d80:	90 91 e3 02 	lds	r25, 0x02E3
    1d84:	04 c0       	rjmp	.+8      	; 0x1d8e <vTaskDelayUntil+0x8c>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1d86:	80 91 e0 02 	lds	r24, 0x02E0
    1d8a:	90 91 e1 02 	lds	r25, 0x02E1
    1d8e:	60 91 9c 02 	lds	r22, 0x029C
    1d92:	70 91 9d 02 	lds	r23, 0x029D
    1d96:	6e 5f       	subi	r22, 0xFE	; 254
    1d98:	7f 4f       	sbci	r23, 0xFF	; 255
    1d9a:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <vListInsert>
				}
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1d9e:	0e 94 c5 0d 	call	0x1b8a	; 0x1b8a <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
    1da2:	88 23       	and	r24, r24
    1da4:	11 f4       	brne	.+4      	; 0x1daa <vTaskDelayUntil+0xa8>
		{
			portYIELD_WITHIN_API();
    1da6:	0e 94 9b 11 	call	0x2336	; 0x2336 <vPortYield>
		}
	}
    1daa:	df 91       	pop	r29
    1dac:	cf 91       	pop	r28
    1dae:	08 95       	ret

00001db0 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    1db0:	ef 92       	push	r14
    1db2:	ff 92       	push	r15
    1db4:	0f 93       	push	r16
    1db6:	1f 93       	push	r17
    1db8:	cf 93       	push	r28
    1dba:	df 93       	push	r29
    1dbc:	8c 01       	movw	r16, r24
	tskTCB *pxTCB;

		portENTER_CRITICAL();
    1dbe:	0f b6       	in	r0, 0x3f	; 63
    1dc0:	f8 94       	cli
    1dc2:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    1dc4:	80 91 9c 02 	lds	r24, 0x029C
    1dc8:	90 91 9d 02 	lds	r25, 0x029D
    1dcc:	08 17       	cp	r16, r24
    1dce:	19 07       	cpc	r17, r25
    1dd0:	19 f4       	brne	.+6      	; 0x1dd8 <vTaskDelete+0x28>
    1dd2:	00 e0       	ldi	r16, 0x00	; 0
    1dd4:	10 e0       	ldi	r17, 0x00	; 0
    1dd6:	03 c0       	rjmp	.+6      	; 0x1dde <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    1dd8:	01 15       	cp	r16, r1
    1dda:	11 05       	cpc	r17, r1
    1ddc:	29 f4       	brne	.+10     	; 0x1de8 <vTaskDelete+0x38>
    1dde:	c0 91 9c 02 	lds	r28, 0x029C
    1de2:	d0 91 9d 02 	lds	r29, 0x029D
    1de6:	01 c0       	rjmp	.+2      	; 0x1dea <vTaskDelete+0x3a>
    1de8:	e8 01       	movw	r28, r16

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    1dea:	22 e0       	ldi	r18, 0x02	; 2
    1dec:	e2 2e       	mov	r14, r18
    1dee:	f1 2c       	mov	r15, r1
    1df0:	ec 0e       	add	r14, r28
    1df2:	fd 1e       	adc	r15, r29
    1df4:	c7 01       	movw	r24, r14
    1df6:	0e 94 21 09 	call	0x1242	; 0x1242 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer )
    1dfa:	8c 89       	ldd	r24, Y+20	; 0x14
    1dfc:	9d 89       	ldd	r25, Y+21	; 0x15
    1dfe:	89 2b       	or	r24, r25
    1e00:	21 f0       	breq	.+8      	; 0x1e0a <vTaskDelete+0x5a>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    1e02:	ce 01       	movw	r24, r28
    1e04:	0c 96       	adiw	r24, 0x0c	; 12
    1e06:	0e 94 21 09 	call	0x1242	; 0x1242 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    1e0a:	8d ee       	ldi	r24, 0xED	; 237
    1e0c:	92 e0       	ldi	r25, 0x02	; 2
    1e0e:	b7 01       	movw	r22, r14
    1e10:	0e 94 c3 08 	call	0x1186	; 0x1186 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    1e14:	80 91 a7 02 	lds	r24, 0x02A7
    1e18:	8f 5f       	subi	r24, 0xFF	; 255
    1e1a:	80 93 a7 02 	sts	0x02A7, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    1e1e:	80 91 a8 02 	lds	r24, 0x02A8
    1e22:	8f 5f       	subi	r24, 0xFF	; 255
    1e24:	80 93 a8 02 	sts	0x02A8, r24

			traceTASK_DELETE( pxTCB );
		}
		portEXIT_CRITICAL();
    1e28:	0f 90       	pop	r0
    1e2a:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    1e2c:	80 91 a6 02 	lds	r24, 0x02A6
    1e30:	88 23       	and	r24, r24
    1e32:	21 f0       	breq	.+8      	; 0x1e3c <vTaskDelete+0x8c>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    1e34:	01 2b       	or	r16, r17
    1e36:	11 f4       	brne	.+4      	; 0x1e3c <vTaskDelete+0x8c>
			{
				portYIELD_WITHIN_API();
    1e38:	0e 94 9b 11 	call	0x2336	; 0x2336 <vPortYield>
			}
		}
	}
    1e3c:	df 91       	pop	r29
    1e3e:	cf 91       	pop	r28
    1e40:	1f 91       	pop	r17
    1e42:	0f 91       	pop	r16
    1e44:	ff 90       	pop	r15
    1e46:	ef 90       	pop	r14
    1e48:	08 95       	ret

00001e4a <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    1e4a:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    1e4c:	10 92 a6 02 	sts	0x02A6, r1
	vPortEndScheduler();
    1e50:	0e 94 3c 11 	call	0x2278	; 0x2278 <vPortEndScheduler>
}
    1e54:	08 95       	ret

00001e56 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    1e56:	1f 93       	push	r17
    1e58:	cf 93       	push	r28
    1e5a:	df 93       	push	r29
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
    1e5c:	80 91 a7 02 	lds	r24, 0x02A7
    1e60:	88 23       	and	r24, r24
    1e62:	91 f1       	breq	.+100    	; 0x1ec8 <prvIdleTask+0x72>

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    1e64:	80 91 a2 02 	lds	r24, 0x02A2
    1e68:	8f 5f       	subi	r24, 0xFF	; 255
    1e6a:	80 93 a2 02 	sts	0x02A2, r24
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    1e6e:	10 91 ed 02 	lds	r17, 0x02ED
			xTaskResumeAll();
    1e72:	0e 94 c5 0d 	call	0x1b8a	; 0x1b8a <xTaskResumeAll>

			if( !xListIsEmpty )
    1e76:	11 23       	and	r17, r17
    1e78:	39 f1       	breq	.+78     	; 0x1ec8 <prvIdleTask+0x72>
			{
				tskTCB *pxTCB;

				portENTER_CRITICAL();
    1e7a:	0f b6       	in	r0, 0x3f	; 63
    1e7c:	f8 94       	cli
    1e7e:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    1e80:	80 91 ed 02 	lds	r24, 0x02ED
    1e84:	88 23       	and	r24, r24
    1e86:	19 f4       	brne	.+6      	; 0x1e8e <prvIdleTask+0x38>
    1e88:	c0 e0       	ldi	r28, 0x00	; 0
    1e8a:	d0 e0       	ldi	r29, 0x00	; 0
    1e8c:	06 c0       	rjmp	.+12     	; 0x1e9a <prvIdleTask+0x44>
    1e8e:	e0 91 f2 02 	lds	r30, 0x02F2
    1e92:	f0 91 f3 02 	lds	r31, 0x02F3
    1e96:	c6 81       	ldd	r28, Z+6	; 0x06
    1e98:	d7 81       	ldd	r29, Z+7	; 0x07
					vListRemove( &( pxTCB->xGenericListItem ) );
    1e9a:	ce 01       	movw	r24, r28
    1e9c:	02 96       	adiw	r24, 0x02	; 2
    1e9e:	0e 94 21 09 	call	0x1242	; 0x1242 <vListRemove>
					--uxCurrentNumberOfTasks;
    1ea2:	80 91 a5 02 	lds	r24, 0x02A5
    1ea6:	81 50       	subi	r24, 0x01	; 1
    1ea8:	80 93 a5 02 	sts	0x02A5, r24
					--uxTasksDeleted;
    1eac:	80 91 a7 02 	lds	r24, 0x02A7
    1eb0:	81 50       	subi	r24, 0x01	; 1
    1eb2:	80 93 a7 02 	sts	0x02A7, r24
				}
				portEXIT_CRITICAL();
    1eb6:	0f 90       	pop	r0
    1eb8:	0f be       	out	0x3f, r0	; 63

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    1eba:	8f 89       	ldd	r24, Y+23	; 0x17
    1ebc:	98 8d       	ldd	r25, Y+24	; 0x18
    1ebe:	0e 94 be 13 	call	0x277c	; 0x277c <vPortFree>
		vPortFree( pxTCB );
    1ec2:	ce 01       	movw	r24, r28
    1ec4:	0e 94 be 13 	call	0x277c	; 0x277c <vPortFree>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    1ec8:	80 91 aa 02 	lds	r24, 0x02AA
    1ecc:	82 30       	cpi	r24, 0x02	; 2
    1ece:	30 f2       	brcs	.-116    	; 0x1e5c <prvIdleTask+0x6>
			{
				taskYIELD();
    1ed0:	0e 94 9b 11 	call	0x2336	; 0x2336 <vPortYield>
    1ed4:	c3 cf       	rjmp	.-122    	; 0x1e5c <prvIdleTask+0x6>

00001ed6 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    1ed6:	2f 92       	push	r2
    1ed8:	3f 92       	push	r3
    1eda:	5f 92       	push	r5
    1edc:	6f 92       	push	r6
    1ede:	7f 92       	push	r7
    1ee0:	8f 92       	push	r8
    1ee2:	9f 92       	push	r9
    1ee4:	af 92       	push	r10
    1ee6:	bf 92       	push	r11
    1ee8:	cf 92       	push	r12
    1eea:	df 92       	push	r13
    1eec:	ef 92       	push	r14
    1eee:	ff 92       	push	r15
    1ef0:	0f 93       	push	r16
    1ef2:	1f 93       	push	r17
    1ef4:	df 93       	push	r29
    1ef6:	cf 93       	push	r28
    1ef8:	00 d0       	rcall	.+0      	; 0x1efa <xTaskGenericCreate+0x24>
    1efa:	00 d0       	rcall	.+0      	; 0x1efc <xTaskGenericCreate+0x26>
    1efc:	cd b7       	in	r28, 0x3d	; 61
    1efe:	de b7       	in	r29, 0x3e	; 62
    1f00:	9a 83       	std	Y+2, r25	; 0x02
    1f02:	89 83       	std	Y+1, r24	; 0x01
    1f04:	4b 01       	movw	r8, r22
    1f06:	5a 01       	movw	r10, r20
    1f08:	19 01       	movw	r2, r18
    1f0a:	50 2e       	mov	r5, r16
    1f0c:	37 01       	movw	r6, r14
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    1f0e:	81 e2       	ldi	r24, 0x21	; 33
    1f10:	90 e0       	ldi	r25, 0x00	; 0
    1f12:	0e 94 ce 13 	call	0x279c	; 0x279c <pvPortMalloc>
    1f16:	8b 83       	std	Y+3, r24	; 0x03
    1f18:	9c 83       	std	Y+4, r25	; 0x04

	if( pxNewTCB != NULL )
    1f1a:	8b 81       	ldd	r24, Y+3	; 0x03
    1f1c:	9c 81       	ldd	r25, Y+4	; 0x04
    1f1e:	89 2b       	or	r24, r25
    1f20:	89 f0       	breq	.+34     	; 0x1f44 <xTaskGenericCreate+0x6e>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    1f22:	c1 14       	cp	r12, r1
    1f24:	d1 04       	cpc	r13, r1
    1f26:	21 f4       	brne	.+8      	; 0x1f30 <xTaskGenericCreate+0x5a>
    1f28:	c5 01       	movw	r24, r10
    1f2a:	0e 94 ce 13 	call	0x279c	; 0x279c <pvPortMalloc>
    1f2e:	6c 01       	movw	r12, r24
    1f30:	eb 81       	ldd	r30, Y+3	; 0x03
    1f32:	fc 81       	ldd	r31, Y+4	; 0x04
    1f34:	d0 8e       	std	Z+24, r13	; 0x18
    1f36:	c7 8a       	std	Z+23, r12	; 0x17

		if( pxNewTCB->pxStack == NULL )
    1f38:	c1 14       	cp	r12, r1
    1f3a:	d1 04       	cpc	r13, r1
    1f3c:	29 f4       	brne	.+10     	; 0x1f48 <xTaskGenericCreate+0x72>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    1f3e:	cf 01       	movw	r24, r30
    1f40:	0e 94 be 13 	call	0x277c	; 0x277c <vPortFree>
    1f44:	8f ef       	ldi	r24, 0xFF	; 255
    1f46:	d5 c0       	rjmp	.+426    	; 0x20f2 <xTaskGenericCreate+0x21c>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
    1f48:	c6 01       	movw	r24, r12
    1f4a:	65 ea       	ldi	r22, 0xA5	; 165
    1f4c:	70 e0       	ldi	r23, 0x00	; 0
    1f4e:	a5 01       	movw	r20, r10
    1f50:	0e 94 ae 25 	call	0x4b5c	; 0x4b5c <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
    1f54:	08 94       	sec
    1f56:	a1 08       	sbc	r10, r1
    1f58:	b1 08       	sbc	r11, r1
    1f5a:	eb 81       	ldd	r30, Y+3	; 0x03
    1f5c:	fc 81       	ldd	r31, Y+4	; 0x04
    1f5e:	e7 88       	ldd	r14, Z+23	; 0x17
    1f60:	f0 8c       	ldd	r15, Z+24	; 0x18
    1f62:	ea 0c       	add	r14, r10
    1f64:	fb 1c       	adc	r15, r11
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    1f66:	cf 01       	movw	r24, r30
    1f68:	49 96       	adiw	r24, 0x19	; 25
    1f6a:	b4 01       	movw	r22, r8
    1f6c:	48 e0       	ldi	r20, 0x08	; 8
    1f6e:	50 e0       	ldi	r21, 0x00	; 0
    1f70:	0e 94 b5 25 	call	0x4b6a	; 0x4b6a <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
    1f74:	eb 81       	ldd	r30, Y+3	; 0x03
    1f76:	fc 81       	ldd	r31, Y+4	; 0x04
    1f78:	10 a2       	std	Z+32, r1	; 0x20
    1f7a:	05 2d       	mov	r16, r5
    1f7c:	f3 e0       	ldi	r31, 0x03	; 3
    1f7e:	f5 15       	cp	r31, r5
    1f80:	08 f4       	brcc	.+2      	; 0x1f84 <xTaskGenericCreate+0xae>
    1f82:	03 e0       	ldi	r16, 0x03	; 3
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - 1;
	}

	pxTCB->uxPriority = uxPriority;
    1f84:	eb 81       	ldd	r30, Y+3	; 0x03
    1f86:	fc 81       	ldd	r31, Y+4	; 0x04
    1f88:	06 8b       	std	Z+22, r16	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    1f8a:	42 e0       	ldi	r20, 0x02	; 2
    1f8c:	c4 2e       	mov	r12, r20
    1f8e:	d1 2c       	mov	r13, r1
    1f90:	ce 0e       	add	r12, r30
    1f92:	df 1e       	adc	r13, r31
    1f94:	c6 01       	movw	r24, r12
    1f96:	0e 94 bf 08 	call	0x117e	; 0x117e <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    1f9a:	8b 81       	ldd	r24, Y+3	; 0x03
    1f9c:	9c 81       	ldd	r25, Y+4	; 0x04
    1f9e:	0c 96       	adiw	r24, 0x0c	; 12
    1fa0:	0e 94 bf 08 	call	0x117e	; 0x117e <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    1fa4:	8b 81       	ldd	r24, Y+3	; 0x03
    1fa6:	9c 81       	ldd	r25, Y+4	; 0x04
    1fa8:	fc 01       	movw	r30, r24
    1faa:	91 87       	std	Z+9, r25	; 0x09
    1fac:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    1fae:	84 e0       	ldi	r24, 0x04	; 4
    1fb0:	90 e0       	ldi	r25, 0x00	; 0
    1fb2:	80 1b       	sub	r24, r16
    1fb4:	91 09       	sbc	r25, r1
    1fb6:	95 87       	std	Z+13, r25	; 0x0d
    1fb8:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    1fba:	f3 8b       	std	Z+19, r31	; 0x13
    1fbc:	e2 8b       	std	Z+18, r30	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1fbe:	c7 01       	movw	r24, r14
    1fc0:	69 81       	ldd	r22, Y+1	; 0x01
    1fc2:	7a 81       	ldd	r23, Y+2	; 0x02
    1fc4:	a1 01       	movw	r20, r2
    1fc6:	0e 94 ba 10 	call	0x2174	; 0x2174 <pxPortInitialiseStack>
    1fca:	eb 81       	ldd	r30, Y+3	; 0x03
    1fcc:	fc 81       	ldd	r31, Y+4	; 0x04
    1fce:	91 83       	std	Z+1, r25	; 0x01
    1fd0:	80 83       	st	Z, r24
		}
		#endif

		if( ( void * ) pxCreatedTask != NULL )
    1fd2:	61 14       	cp	r6, r1
    1fd4:	71 04       	cpc	r7, r1
    1fd6:	21 f0       	breq	.+8      	; 0x1fe0 <xTaskGenericCreate+0x10a>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    1fd8:	cf 01       	movw	r24, r30
    1fda:	f3 01       	movw	r30, r6
    1fdc:	91 83       	std	Z+1, r25	; 0x01
    1fde:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		portENTER_CRITICAL();
    1fe0:	0f b6       	in	r0, 0x3f	; 63
    1fe2:	f8 94       	cli
    1fe4:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    1fe6:	80 91 a5 02 	lds	r24, 0x02A5
    1fea:	8f 5f       	subi	r24, 0xFF	; 255
    1fec:	80 93 a5 02 	sts	0x02A5, r24
			if( pxCurrentTCB == NULL )
    1ff0:	80 91 9c 02 	lds	r24, 0x029C
    1ff4:	90 91 9d 02 	lds	r25, 0x029D
    1ff8:	89 2b       	or	r24, r25
    1ffa:	b9 f5       	brne	.+110    	; 0x206a <xTaskGenericCreate+0x194>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    1ffc:	eb 81       	ldd	r30, Y+3	; 0x03
    1ffe:	fc 81       	ldd	r31, Y+4	; 0x04
    2000:	f0 93 9d 02 	sts	0x029D, r31
    2004:	e0 93 9c 02 	sts	0x029C, r30

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    2008:	80 91 a5 02 	lds	r24, 0x02A5
    200c:	81 30       	cpi	r24, 0x01	; 1
    200e:	f1 f5       	brne	.+124    	; 0x208c <xTaskGenericCreate+0x1b6>
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    2010:	8a ea       	ldi	r24, 0xAA	; 170
    2012:	92 e0       	ldi	r25, 0x02	; 2
    2014:	0e 94 af 08 	call	0x115e	; 0x115e <vListInitialise>
    2018:	83 eb       	ldi	r24, 0xB3	; 179
    201a:	92 e0       	ldi	r25, 0x02	; 2
    201c:	0e 94 af 08 	call	0x115e	; 0x115e <vListInitialise>
    2020:	8c eb       	ldi	r24, 0xBC	; 188
    2022:	92 e0       	ldi	r25, 0x02	; 2
    2024:	0e 94 af 08 	call	0x115e	; 0x115e <vListInitialise>
    2028:	85 ec       	ldi	r24, 0xC5	; 197
    202a:	92 e0       	ldi	r25, 0x02	; 2
    202c:	0e 94 af 08 	call	0x115e	; 0x115e <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    2030:	3e ec       	ldi	r19, 0xCE	; 206
    2032:	e3 2e       	mov	r14, r19
    2034:	32 e0       	ldi	r19, 0x02	; 2
    2036:	f3 2e       	mov	r15, r19
    2038:	c7 01       	movw	r24, r14
    203a:	0e 94 af 08 	call	0x115e	; 0x115e <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    203e:	07 ed       	ldi	r16, 0xD7	; 215
    2040:	12 e0       	ldi	r17, 0x02	; 2
    2042:	c8 01       	movw	r24, r16
    2044:	0e 94 af 08 	call	0x115e	; 0x115e <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    2048:	84 ee       	ldi	r24, 0xE4	; 228
    204a:	92 e0       	ldi	r25, 0x02	; 2
    204c:	0e 94 af 08 	call	0x115e	; 0x115e <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    2050:	8d ee       	ldi	r24, 0xED	; 237
    2052:	92 e0       	ldi	r25, 0x02	; 2
    2054:	0e 94 af 08 	call	0x115e	; 0x115e <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    2058:	f0 92 e1 02 	sts	0x02E1, r15
    205c:	e0 92 e0 02 	sts	0x02E0, r14
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    2060:	10 93 e3 02 	sts	0x02E3, r17
    2064:	00 93 e2 02 	sts	0x02E2, r16
    2068:	11 c0       	rjmp	.+34     	; 0x208c <xTaskGenericCreate+0x1b6>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    206a:	80 91 a6 02 	lds	r24, 0x02A6
    206e:	88 23       	and	r24, r24
    2070:	69 f4       	brne	.+26     	; 0x208c <xTaskGenericCreate+0x1b6>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    2072:	e0 91 9c 02 	lds	r30, 0x029C
    2076:	f0 91 9d 02 	lds	r31, 0x029D
    207a:	86 89       	ldd	r24, Z+22	; 0x16
    207c:	58 16       	cp	r5, r24
    207e:	30 f0       	brcs	.+12     	; 0x208c <xTaskGenericCreate+0x1b6>
					{
						pxCurrentTCB = pxNewTCB;
    2080:	8b 81       	ldd	r24, Y+3	; 0x03
    2082:	9c 81       	ldd	r25, Y+4	; 0x04
    2084:	90 93 9d 02 	sts	0x029D, r25
    2088:	80 93 9c 02 	sts	0x029C, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    208c:	eb 81       	ldd	r30, Y+3	; 0x03
    208e:	fc 81       	ldd	r31, Y+4	; 0x04
    2090:	96 89       	ldd	r25, Z+22	; 0x16
    2092:	80 91 a9 02 	lds	r24, 0x02A9
    2096:	89 17       	cp	r24, r25
    2098:	10 f4       	brcc	.+4      	; 0x209e <xTaskGenericCreate+0x1c8>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    209a:	90 93 a9 02 	sts	0x02A9, r25
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    209e:	80 91 a8 02 	lds	r24, 0x02A8
    20a2:	8f 5f       	subi	r24, 0xFF	; 255
    20a4:	80 93 a8 02 	sts	0x02A8, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    20a8:	eb 81       	ldd	r30, Y+3	; 0x03
    20aa:	fc 81       	ldd	r31, Y+4	; 0x04
    20ac:	96 89       	ldd	r25, Z+22	; 0x16
    20ae:	80 91 a3 02 	lds	r24, 0x02A3
    20b2:	89 17       	cp	r24, r25
    20b4:	10 f4       	brcc	.+4      	; 0x20ba <xTaskGenericCreate+0x1e4>
    20b6:	90 93 a3 02 	sts	0x02A3, r25
    20ba:	eb 81       	ldd	r30, Y+3	; 0x03
    20bc:	fc 81       	ldd	r31, Y+4	; 0x04
    20be:	86 89       	ldd	r24, Z+22	; 0x16
    20c0:	29 e0       	ldi	r18, 0x09	; 9
    20c2:	82 9f       	mul	r24, r18
    20c4:	c0 01       	movw	r24, r0
    20c6:	11 24       	eor	r1, r1
    20c8:	86 55       	subi	r24, 0x56	; 86
    20ca:	9d 4f       	sbci	r25, 0xFD	; 253
    20cc:	b6 01       	movw	r22, r12
    20ce:	0e 94 c3 08 	call	0x1186	; 0x1186 <vListInsertEnd>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		portEXIT_CRITICAL();
    20d2:	0f 90       	pop	r0
    20d4:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED( pxNewTCB );
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    20d6:	80 91 a6 02 	lds	r24, 0x02A6
    20da:	88 23       	and	r24, r24
    20dc:	49 f0       	breq	.+18     	; 0x20f0 <xTaskGenericCreate+0x21a>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    20de:	e0 91 9c 02 	lds	r30, 0x029C
    20e2:	f0 91 9d 02 	lds	r31, 0x029D
    20e6:	86 89       	ldd	r24, Z+22	; 0x16
    20e8:	85 15       	cp	r24, r5
    20ea:	10 f4       	brcc	.+4      	; 0x20f0 <xTaskGenericCreate+0x21a>
			{
				portYIELD_WITHIN_API();
    20ec:	0e 94 9b 11 	call	0x2336	; 0x2336 <vPortYield>
    20f0:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    20f2:	0f 90       	pop	r0
    20f4:	0f 90       	pop	r0
    20f6:	0f 90       	pop	r0
    20f8:	0f 90       	pop	r0
    20fa:	cf 91       	pop	r28
    20fc:	df 91       	pop	r29
    20fe:	1f 91       	pop	r17
    2100:	0f 91       	pop	r16
    2102:	ff 90       	pop	r15
    2104:	ef 90       	pop	r14
    2106:	df 90       	pop	r13
    2108:	cf 90       	pop	r12
    210a:	bf 90       	pop	r11
    210c:	af 90       	pop	r10
    210e:	9f 90       	pop	r9
    2110:	8f 90       	pop	r8
    2112:	7f 90       	pop	r7
    2114:	6f 90       	pop	r6
    2116:	5f 90       	pop	r5
    2118:	3f 90       	pop	r3
    211a:	2f 90       	pop	r2
    211c:	08 95       	ret

0000211e <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    211e:	af 92       	push	r10
    2120:	bf 92       	push	r11
    2122:	cf 92       	push	r12
    2124:	df 92       	push	r13
    2126:	ef 92       	push	r14
    2128:	ff 92       	push	r15
    212a:	0f 93       	push	r16
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
    212c:	8b e2       	ldi	r24, 0x2B	; 43
    212e:	9f e0       	ldi	r25, 0x0F	; 15
    2130:	62 e9       	ldi	r22, 0x92	; 146
    2132:	72 e0       	ldi	r23, 0x02	; 2
    2134:	45 e5       	ldi	r20, 0x55	; 85
    2136:	50 e0       	ldi	r21, 0x00	; 0
    2138:	20 e0       	ldi	r18, 0x00	; 0
    213a:	30 e0       	ldi	r19, 0x00	; 0
    213c:	00 e0       	ldi	r16, 0x00	; 0
    213e:	ee 24       	eor	r14, r14
    2140:	ff 24       	eor	r15, r15
    2142:	cc 24       	eor	r12, r12
    2144:	dd 24       	eor	r13, r13
    2146:	aa 24       	eor	r10, r10
    2148:	bb 24       	eor	r11, r11
    214a:	0e 94 6b 0f 	call	0x1ed6	; 0x1ed6 <xTaskGenericCreate>

	if( xReturn == pdPASS )
    214e:	81 30       	cpi	r24, 0x01	; 1
    2150:	49 f4       	brne	.+18     	; 0x2164 <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    2152:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    2154:	80 93 a6 02 	sts	0x02A6, r24
		xTickCount = ( portTickType ) 0;
    2158:	10 92 a1 02 	sts	0x02A1, r1
    215c:	10 92 a0 02 	sts	0x02A0, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
    2160:	0e 94 02 11 	call	0x2204	; 0x2204 <xPortStartScheduler>
		else
		{
			/* Should only reach here if a task calls xTaskEndScheduler(). */
		}
	}
}
    2164:	0f 91       	pop	r16
    2166:	ff 90       	pop	r15
    2168:	ef 90       	pop	r14
    216a:	df 90       	pop	r13
    216c:	cf 90       	pop	r12
    216e:	bf 90       	pop	r11
    2170:	af 90       	pop	r10
    2172:	08 95       	ret

00002174 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    2174:	fc 01       	movw	r30, r24
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    2176:	91 e1       	ldi	r25, 0x11	; 17
    2178:	90 83       	st	Z, r25
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    217a:	22 e2       	ldi	r18, 0x22	; 34
    217c:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    217e:	83 e3       	ldi	r24, 0x33	; 51
    2180:	82 93       	st	-Z, r24
	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	

	usAddress = ( unsigned short ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2182:	62 93       	st	-Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2184:	72 93       	st	-Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    2186:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    2188:	80 e8       	ldi	r24, 0x80	; 128
    218a:	82 93       	st	-Z, r24
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    218c:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    218e:	82 e0       	ldi	r24, 0x02	; 2
    2190:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    2192:	83 e0       	ldi	r24, 0x03	; 3
    2194:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    2196:	84 e0       	ldi	r24, 0x04	; 4
    2198:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    219a:	85 e0       	ldi	r24, 0x05	; 5
    219c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    219e:	86 e0       	ldi	r24, 0x06	; 6
    21a0:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    21a2:	87 e0       	ldi	r24, 0x07	; 7
    21a4:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    21a6:	88 e0       	ldi	r24, 0x08	; 8
    21a8:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    21aa:	89 e0       	ldi	r24, 0x09	; 9
    21ac:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    21ae:	80 e1       	ldi	r24, 0x10	; 16
    21b0:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    21b2:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    21b4:	82 e1       	ldi	r24, 0x12	; 18
    21b6:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    21b8:	83 e1       	ldi	r24, 0x13	; 19
    21ba:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    21bc:	84 e1       	ldi	r24, 0x14	; 20
    21be:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    21c0:	85 e1       	ldi	r24, 0x15	; 21
    21c2:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    21c4:	86 e1       	ldi	r24, 0x16	; 22
    21c6:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    21c8:	87 e1       	ldi	r24, 0x17	; 23
    21ca:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    21cc:	88 e1       	ldi	r24, 0x18	; 24
    21ce:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    21d0:	89 e1       	ldi	r24, 0x19	; 25
    21d2:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    21d4:	80 e2       	ldi	r24, 0x20	; 32
    21d6:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    21d8:	81 e2       	ldi	r24, 0x21	; 33
    21da:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    21dc:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    21de:	83 e2       	ldi	r24, 0x23	; 35
    21e0:	82 93       	st	-Z, r24
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */

	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    21e2:	42 93       	st	-Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    21e4:	52 93       	st	-Z, r21
	pxTopOfStack--;


	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    21e6:	86 e2       	ldi	r24, 0x26	; 38
    21e8:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    21ea:	87 e2       	ldi	r24, 0x27	; 39
    21ec:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    21ee:	88 e2       	ldi	r24, 0x28	; 40
    21f0:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    21f2:	89 e2       	ldi	r24, 0x29	; 41
    21f4:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    21f6:	80 e3       	ldi	r24, 0x30	; 48
    21f8:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    21fa:	81 e3       	ldi	r24, 0x31	; 49
    21fc:	82 93       	st	-Z, r24
    21fe:	31 97       	sbiw	r30, 0x01	; 1
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    2200:	cf 01       	movw	r24, r30
    2202:	08 95       	ret

00002204 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	OCR1AH = ucHighByte;
    2204:	10 92 89 00 	sts	0x0089, r1
	OCR1AL = ucLowByte;
    2208:	89 ef       	ldi	r24, 0xF9	; 249
    220a:	80 93 88 00 	sts	0x0088, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    220e:	8b e0       	ldi	r24, 0x0B	; 11
    2210:	80 93 81 00 	sts	0x0081, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
    2214:	ef e6       	ldi	r30, 0x6F	; 111
    2216:	f0 e0       	ldi	r31, 0x00	; 0
    2218:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    221a:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
    221c:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    221e:	a0 91 9c 02 	lds	r26, 0x029C
    2222:	b0 91 9d 02 	lds	r27, 0x029D
    2226:	cd 91       	ld	r28, X+
    2228:	cd bf       	out	0x3d, r28	; 61
    222a:	dd 91       	ld	r29, X+
    222c:	de bf       	out	0x3e, r29	; 62
    222e:	ff 91       	pop	r31
    2230:	ef 91       	pop	r30
    2232:	df 91       	pop	r29
    2234:	cf 91       	pop	r28
    2236:	bf 91       	pop	r27
    2238:	af 91       	pop	r26
    223a:	9f 91       	pop	r25
    223c:	8f 91       	pop	r24
    223e:	7f 91       	pop	r23
    2240:	6f 91       	pop	r22
    2242:	5f 91       	pop	r21
    2244:	4f 91       	pop	r20
    2246:	3f 91       	pop	r19
    2248:	2f 91       	pop	r18
    224a:	1f 91       	pop	r17
    224c:	0f 91       	pop	r16
    224e:	ff 90       	pop	r15
    2250:	ef 90       	pop	r14
    2252:	df 90       	pop	r13
    2254:	cf 90       	pop	r12
    2256:	bf 90       	pop	r11
    2258:	af 90       	pop	r10
    225a:	9f 90       	pop	r9
    225c:	8f 90       	pop	r8
    225e:	7f 90       	pop	r7
    2260:	6f 90       	pop	r6
    2262:	5f 90       	pop	r5
    2264:	4f 90       	pop	r4
    2266:	3f 90       	pop	r3
    2268:	2f 90       	pop	r2
    226a:	1f 90       	pop	r1
    226c:	0f 90       	pop	r0
    226e:	0f be       	out	0x3f, r0	; 63
    2270:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    2272:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    2274:	81 e0       	ldi	r24, 0x01	; 1
    2276:	08 95       	ret

00002278 <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    2278:	08 95       	ret

0000227a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    227a:	0f 92       	push	r0
    227c:	0f b6       	in	r0, 0x3f	; 63
    227e:	f8 94       	cli
    2280:	0f 92       	push	r0
    2282:	1f 92       	push	r1
    2284:	11 24       	eor	r1, r1
    2286:	2f 92       	push	r2
    2288:	3f 92       	push	r3
    228a:	4f 92       	push	r4
    228c:	5f 92       	push	r5
    228e:	6f 92       	push	r6
    2290:	7f 92       	push	r7
    2292:	8f 92       	push	r8
    2294:	9f 92       	push	r9
    2296:	af 92       	push	r10
    2298:	bf 92       	push	r11
    229a:	cf 92       	push	r12
    229c:	df 92       	push	r13
    229e:	ef 92       	push	r14
    22a0:	ff 92       	push	r15
    22a2:	0f 93       	push	r16
    22a4:	1f 93       	push	r17
    22a6:	2f 93       	push	r18
    22a8:	3f 93       	push	r19
    22aa:	4f 93       	push	r20
    22ac:	5f 93       	push	r21
    22ae:	6f 93       	push	r22
    22b0:	7f 93       	push	r23
    22b2:	8f 93       	push	r24
    22b4:	9f 93       	push	r25
    22b6:	af 93       	push	r26
    22b8:	bf 93       	push	r27
    22ba:	cf 93       	push	r28
    22bc:	df 93       	push	r29
    22be:	ef 93       	push	r30
    22c0:	ff 93       	push	r31
    22c2:	a0 91 9c 02 	lds	r26, 0x029C
    22c6:	b0 91 9d 02 	lds	r27, 0x029D
    22ca:	0d b6       	in	r0, 0x3d	; 61
    22cc:	0d 92       	st	X+, r0
    22ce:	0e b6       	in	r0, 0x3e	; 62
    22d0:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    22d2:	0e 94 16 0d 	call	0x1a2c	; 0x1a2c <vTaskIncrementTick>
	vTaskSwitchContext();
    22d6:	0e 94 48 0c 	call	0x1890	; 0x1890 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    22da:	a0 91 9c 02 	lds	r26, 0x029C
    22de:	b0 91 9d 02 	lds	r27, 0x029D
    22e2:	cd 91       	ld	r28, X+
    22e4:	cd bf       	out	0x3d, r28	; 61
    22e6:	dd 91       	ld	r29, X+
    22e8:	de bf       	out	0x3e, r29	; 62
    22ea:	ff 91       	pop	r31
    22ec:	ef 91       	pop	r30
    22ee:	df 91       	pop	r29
    22f0:	cf 91       	pop	r28
    22f2:	bf 91       	pop	r27
    22f4:	af 91       	pop	r26
    22f6:	9f 91       	pop	r25
    22f8:	8f 91       	pop	r24
    22fa:	7f 91       	pop	r23
    22fc:	6f 91       	pop	r22
    22fe:	5f 91       	pop	r21
    2300:	4f 91       	pop	r20
    2302:	3f 91       	pop	r19
    2304:	2f 91       	pop	r18
    2306:	1f 91       	pop	r17
    2308:	0f 91       	pop	r16
    230a:	ff 90       	pop	r15
    230c:	ef 90       	pop	r14
    230e:	df 90       	pop	r13
    2310:	cf 90       	pop	r12
    2312:	bf 90       	pop	r11
    2314:	af 90       	pop	r10
    2316:	9f 90       	pop	r9
    2318:	8f 90       	pop	r8
    231a:	7f 90       	pop	r7
    231c:	6f 90       	pop	r6
    231e:	5f 90       	pop	r5
    2320:	4f 90       	pop	r4
    2322:	3f 90       	pop	r3
    2324:	2f 90       	pop	r2
    2326:	1f 90       	pop	r1
    2328:	0f 90       	pop	r0
    232a:	0f be       	out	0x3f, r0	; 63
    232c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    232e:	08 95       	ret

00002330 <__vector_17>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    2330:	0e 94 3d 11 	call	0x227a	; 0x227a <vPortYieldFromTick>
		asm volatile ( "reti" );
    2334:	18 95       	reti

00002336 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2336:	0f 92       	push	r0
    2338:	0f b6       	in	r0, 0x3f	; 63
    233a:	f8 94       	cli
    233c:	0f 92       	push	r0
    233e:	1f 92       	push	r1
    2340:	11 24       	eor	r1, r1
    2342:	2f 92       	push	r2
    2344:	3f 92       	push	r3
    2346:	4f 92       	push	r4
    2348:	5f 92       	push	r5
    234a:	6f 92       	push	r6
    234c:	7f 92       	push	r7
    234e:	8f 92       	push	r8
    2350:	9f 92       	push	r9
    2352:	af 92       	push	r10
    2354:	bf 92       	push	r11
    2356:	cf 92       	push	r12
    2358:	df 92       	push	r13
    235a:	ef 92       	push	r14
    235c:	ff 92       	push	r15
    235e:	0f 93       	push	r16
    2360:	1f 93       	push	r17
    2362:	2f 93       	push	r18
    2364:	3f 93       	push	r19
    2366:	4f 93       	push	r20
    2368:	5f 93       	push	r21
    236a:	6f 93       	push	r22
    236c:	7f 93       	push	r23
    236e:	8f 93       	push	r24
    2370:	9f 93       	push	r25
    2372:	af 93       	push	r26
    2374:	bf 93       	push	r27
    2376:	cf 93       	push	r28
    2378:	df 93       	push	r29
    237a:	ef 93       	push	r30
    237c:	ff 93       	push	r31
    237e:	a0 91 9c 02 	lds	r26, 0x029C
    2382:	b0 91 9d 02 	lds	r27, 0x029D
    2386:	0d b6       	in	r0, 0x3d	; 61
    2388:	0d 92       	st	X+, r0
    238a:	0e b6       	in	r0, 0x3e	; 62
    238c:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    238e:	0e 94 48 0c 	call	0x1890	; 0x1890 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2392:	a0 91 9c 02 	lds	r26, 0x029C
    2396:	b0 91 9d 02 	lds	r27, 0x029D
    239a:	cd 91       	ld	r28, X+
    239c:	cd bf       	out	0x3d, r28	; 61
    239e:	dd 91       	ld	r29, X+
    23a0:	de bf       	out	0x3e, r29	; 62
    23a2:	ff 91       	pop	r31
    23a4:	ef 91       	pop	r30
    23a6:	df 91       	pop	r29
    23a8:	cf 91       	pop	r28
    23aa:	bf 91       	pop	r27
    23ac:	af 91       	pop	r26
    23ae:	9f 91       	pop	r25
    23b0:	8f 91       	pop	r24
    23b2:	7f 91       	pop	r23
    23b4:	6f 91       	pop	r22
    23b6:	5f 91       	pop	r21
    23b8:	4f 91       	pop	r20
    23ba:	3f 91       	pop	r19
    23bc:	2f 91       	pop	r18
    23be:	1f 91       	pop	r17
    23c0:	0f 91       	pop	r16
    23c2:	ff 90       	pop	r15
    23c4:	ef 90       	pop	r14
    23c6:	df 90       	pop	r13
    23c8:	cf 90       	pop	r12
    23ca:	bf 90       	pop	r11
    23cc:	af 90       	pop	r10
    23ce:	9f 90       	pop	r9
    23d0:	8f 90       	pop	r8
    23d2:	7f 90       	pop	r7
    23d4:	6f 90       	pop	r6
    23d6:	5f 90       	pop	r5
    23d8:	4f 90       	pop	r4
    23da:	3f 90       	pop	r3
    23dc:	2f 90       	pop	r2
    23de:	1f 90       	pop	r1
    23e0:	0f 90       	pop	r0
    23e2:	0f be       	out	0x3f, r0	; 63
    23e4:	0f 90       	pop	r0

	asm volatile ( "ret" );
    23e6:	08 95       	ret

000023e8 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    23e8:	0f 93       	push	r16
    23ea:	1f 93       	push	r17
    23ec:	cf 93       	push	r28
    23ee:	df 93       	push	r29
    23f0:	fc 01       	movw	r30, r24
corCRCB *pxUnblockedCRCB;
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    23f2:	80 81       	ld	r24, Z
    23f4:	88 23       	and	r24, r24
    23f6:	19 f4       	brne	.+6      	; 0x23fe <xCoRoutineRemoveFromEventList+0x16>
    23f8:	c0 e0       	ldi	r28, 0x00	; 0
    23fa:	d0 e0       	ldi	r29, 0x00	; 0
    23fc:	05 c0       	rjmp	.+10     	; 0x2408 <xCoRoutineRemoveFromEventList+0x20>
    23fe:	05 80       	ldd	r0, Z+5	; 0x05
    2400:	f6 81       	ldd	r31, Z+6	; 0x06
    2402:	e0 2d       	mov	r30, r0
    2404:	c6 81       	ldd	r28, Z+6	; 0x06
    2406:	d7 81       	ldd	r29, Z+7	; 0x07
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2408:	8e 01       	movw	r16, r28
    240a:	04 5f       	subi	r16, 0xF4	; 244
    240c:	1f 4f       	sbci	r17, 0xFF	; 255
    240e:	c8 01       	movw	r24, r16
    2410:	0e 94 21 09 	call	0x1242	; 0x1242 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    2414:	87 e2       	ldi	r24, 0x27	; 39
    2416:	93 e0       	ldi	r25, 0x03	; 3
    2418:	b8 01       	movw	r22, r16
    241a:	0e 94 c3 08 	call	0x1186	; 0x1186 <vListInsertEnd>
    241e:	20 e0       	ldi	r18, 0x00	; 0
    2420:	e0 91 f6 02 	lds	r30, 0x02F6
    2424:	f0 91 f7 02 	lds	r31, 0x02F7
    2428:	9e 89       	ldd	r25, Y+22	; 0x16
    242a:	86 89       	ldd	r24, Z+22	; 0x16
    242c:	98 17       	cp	r25, r24
    242e:	08 f0       	brcs	.+2      	; 0x2432 <xCoRoutineRemoveFromEventList+0x4a>
    2430:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    2432:	82 2f       	mov	r24, r18
    2434:	df 91       	pop	r29
    2436:	cf 91       	pop	r28
    2438:	1f 91       	pop	r17
    243a:	0f 91       	pop	r16
    243c:	08 95       	ret

0000243e <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    243e:	ff 92       	push	r15
    2440:	0f 93       	push	r16
    2442:	1f 93       	push	r17
    2444:	cf 93       	push	r28
    2446:	df 93       	push	r29
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    2448:	99 e0       	ldi	r25, 0x09	; 9
    244a:	f9 2e       	mov	r15, r25
    244c:	28 c0       	rjmp	.+80     	; 0x249e <vCoRoutineSchedule+0x60>
	while( !listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    244e:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    2450:	80 91 27 03 	lds	r24, 0x0327
    2454:	88 23       	and	r24, r24
    2456:	19 f4       	brne	.+6      	; 0x245e <vCoRoutineSchedule+0x20>
    2458:	c0 e0       	ldi	r28, 0x00	; 0
    245a:	d0 e0       	ldi	r29, 0x00	; 0
    245c:	06 c0       	rjmp	.+12     	; 0x246a <vCoRoutineSchedule+0x2c>
    245e:	e0 91 2c 03 	lds	r30, 0x032C
    2462:	f0 91 2d 03 	lds	r31, 0x032D
    2466:	c6 81       	ldd	r28, Z+6	; 0x06
    2468:	d7 81       	ldd	r29, Z+7	; 0x07
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    246a:	ce 01       	movw	r24, r28
    246c:	0c 96       	adiw	r24, 0x0c	; 12
    246e:	0e 94 21 09 	call	0x1242	; 0x1242 <vListRemove>
		}
		portENABLE_INTERRUPTS();
    2472:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    2474:	8e 01       	movw	r16, r28
    2476:	0e 5f       	subi	r16, 0xFE	; 254
    2478:	1f 4f       	sbci	r17, 0xFF	; 255
    247a:	c8 01       	movw	r24, r16
    247c:	0e 94 21 09 	call	0x1242	; 0x1242 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    2480:	9e 89       	ldd	r25, Y+22	; 0x16
    2482:	80 91 f8 02 	lds	r24, 0x02F8
    2486:	89 17       	cp	r24, r25
    2488:	10 f4       	brcc	.+4      	; 0x248e <vCoRoutineSchedule+0x50>
    248a:	90 93 f8 02 	sts	0x02F8, r25
    248e:	9f 9d       	mul	r25, r15
    2490:	c0 01       	movw	r24, r0
    2492:	11 24       	eor	r1, r1
    2494:	81 50       	subi	r24, 0x01	; 1
    2496:	9d 4f       	sbci	r25, 0xFD	; 253
    2498:	b8 01       	movw	r22, r16
    249a:	0e 94 c3 08 	call	0x1186	; 0x1186 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( !listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) )
    249e:	80 91 27 03 	lds	r24, 0x0327
    24a2:	88 23       	and	r24, r24
    24a4:	a1 f6       	brne	.-88     	; 0x244e <vCoRoutineSchedule+0x10>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    24a6:	0e 94 34 0c 	call	0x1868	; 0x1868 <xTaskGetTickCount>
    24aa:	20 91 f9 02 	lds	r18, 0x02F9
    24ae:	30 91 fa 02 	lds	r19, 0x02FA
    24b2:	82 1b       	sub	r24, r18
    24b4:	93 0b       	sbc	r25, r19
    24b6:	90 93 fc 02 	sts	0x02FC, r25
    24ba:	80 93 fb 02 	sts	0x02FB, r24
					vListRemove( &( pxCRCB->xEventListItem ) );											
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    24be:	89 e0       	ldi	r24, 0x09	; 9
    24c0:	f8 2e       	mov	r15, r24
    24c2:	54 c0       	rjmp	.+168    	; 0x256c <vCoRoutineSchedule+0x12e>
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    24c4:	01 96       	adiw	r24, 0x01	; 1
    24c6:	90 93 fe 02 	sts	0x02FE, r25
    24ca:	80 93 fd 02 	sts	0x02FD, r24
		xPassedTicks--;
    24ce:	21 50       	subi	r18, 0x01	; 1
    24d0:	30 40       	sbci	r19, 0x00	; 0
    24d2:	30 93 fc 02 	sts	0x02FC, r19
    24d6:	20 93 fb 02 	sts	0x02FB, r18

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    24da:	89 2b       	or	r24, r25
    24dc:	c9 f5       	brne	.+114    	; 0x2550 <vCoRoutineSchedule+0x112>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    24de:	20 91 23 03 	lds	r18, 0x0323
    24e2:	30 91 24 03 	lds	r19, 0x0324
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    24e6:	80 91 25 03 	lds	r24, 0x0325
    24ea:	90 91 26 03 	lds	r25, 0x0326
    24ee:	90 93 24 03 	sts	0x0324, r25
    24f2:	80 93 23 03 	sts	0x0323, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    24f6:	30 93 26 03 	sts	0x0326, r19
    24fa:	20 93 25 03 	sts	0x0325, r18
    24fe:	28 c0       	rjmp	.+80     	; 0x2550 <vCoRoutineSchedule+0x112>
		}

		/* See if this tick has made a timeout expire. */
		while( ( pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList ) ) != NULL )
		{	
			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    2500:	20 91 fd 02 	lds	r18, 0x02FD
    2504:	30 91 fe 02 	lds	r19, 0x02FE
    2508:	8a 81       	ldd	r24, Y+2	; 0x02
    250a:	9b 81       	ldd	r25, Y+3	; 0x03
    250c:	28 17       	cp	r18, r24
    250e:	39 07       	cpc	r19, r25
    2510:	68 f1       	brcs	.+90     	; 0x256c <vCoRoutineSchedule+0x12e>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    2512:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    2514:	8e 01       	movw	r16, r28
    2516:	0e 5f       	subi	r16, 0xFE	; 254
    2518:	1f 4f       	sbci	r17, 0xFF	; 255
    251a:	c8 01       	movw	r24, r16
    251c:	0e 94 21 09 	call	0x1242	; 0x1242 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    2520:	8c 89       	ldd	r24, Y+20	; 0x14
    2522:	9d 89       	ldd	r25, Y+21	; 0x15
    2524:	89 2b       	or	r24, r25
    2526:	21 f0       	breq	.+8      	; 0x2530 <vCoRoutineSchedule+0xf2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    2528:	ce 01       	movw	r24, r28
    252a:	0c 96       	adiw	r24, 0x0c	; 12
    252c:	0e 94 21 09 	call	0x1242	; 0x1242 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    2530:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    2532:	9e 89       	ldd	r25, Y+22	; 0x16
    2534:	80 91 f8 02 	lds	r24, 0x02F8
    2538:	89 17       	cp	r24, r25
    253a:	10 f4       	brcc	.+4      	; 0x2540 <vCoRoutineSchedule+0x102>
    253c:	90 93 f8 02 	sts	0x02F8, r25
    2540:	9f 9d       	mul	r25, r15
    2542:	c0 01       	movw	r24, r0
    2544:	11 24       	eor	r1, r1
    2546:	81 50       	subi	r24, 0x01	; 1
    2548:	9d 4f       	sbci	r25, 0xFD	; 253
    254a:	b8 01       	movw	r22, r16
    254c:	0e 94 c3 08 	call	0x1186	; 0x1186 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( ( pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList ) ) != NULL )
    2550:	e0 91 23 03 	lds	r30, 0x0323
    2554:	f0 91 24 03 	lds	r31, 0x0324
    2558:	80 81       	ld	r24, Z
    255a:	88 23       	and	r24, r24
    255c:	39 f0       	breq	.+14     	; 0x256c <vCoRoutineSchedule+0x12e>
    255e:	05 80       	ldd	r0, Z+5	; 0x05
    2560:	f6 81       	ldd	r31, Z+6	; 0x06
    2562:	e0 2d       	mov	r30, r0
    2564:	c6 81       	ldd	r28, Z+6	; 0x06
    2566:	d7 81       	ldd	r29, Z+7	; 0x07
    2568:	20 97       	sbiw	r28, 0x00	; 0
    256a:	51 f6       	brne	.-108    	; 0x2500 <vCoRoutineSchedule+0xc2>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    256c:	20 91 fb 02 	lds	r18, 0x02FB
    2570:	30 91 fc 02 	lds	r19, 0x02FC
    2574:	80 91 fd 02 	lds	r24, 0x02FD
    2578:	90 91 fe 02 	lds	r25, 0x02FE
    257c:	21 15       	cp	r18, r1
    257e:	31 05       	cpc	r19, r1
    2580:	09 f0       	breq	.+2      	; 0x2584 <vCoRoutineSchedule+0x146>
    2582:	a0 cf       	rjmp	.-192    	; 0x24c4 <vCoRoutineSchedule+0x86>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    2584:	90 93 fa 02 	sts	0x02FA, r25
    2588:	80 93 f9 02 	sts	0x02F9, r24
    258c:	90 91 f8 02 	lds	r25, 0x02F8

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    2590:	29 e0       	ldi	r18, 0x09	; 9
    2592:	06 c0       	rjmp	.+12     	; 0x25a0 <vCoRoutineSchedule+0x162>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    2594:	99 23       	and	r25, r25
    2596:	19 f4       	brne	.+6      	; 0x259e <vCoRoutineSchedule+0x160>
    2598:	10 92 f8 02 	sts	0x02F8, r1
    259c:	32 c0       	rjmp	.+100    	; 0x2602 <vCoRoutineSchedule+0x1c4>
    259e:	91 50       	subi	r25, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    25a0:	92 9f       	mul	r25, r18
    25a2:	d0 01       	movw	r26, r0
    25a4:	11 24       	eor	r1, r1
    25a6:	a1 50       	subi	r26, 0x01	; 1
    25a8:	bd 4f       	sbci	r27, 0xFD	; 253
    25aa:	8c 91       	ld	r24, X
    25ac:	88 23       	and	r24, r24
    25ae:	91 f3       	breq	.-28     	; 0x2594 <vCoRoutineSchedule+0x156>
    25b0:	90 93 f8 02 	sts	0x02F8, r25
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    25b4:	11 96       	adiw	r26, 0x01	; 1
    25b6:	ed 91       	ld	r30, X+
    25b8:	fc 91       	ld	r31, X
    25ba:	12 97       	sbiw	r26, 0x02	; 2
    25bc:	02 80       	ldd	r0, Z+2	; 0x02
    25be:	f3 81       	ldd	r31, Z+3	; 0x03
    25c0:	e0 2d       	mov	r30, r0
    25c2:	12 96       	adiw	r26, 0x02	; 2
    25c4:	fc 93       	st	X, r31
    25c6:	ee 93       	st	-X, r30
    25c8:	11 97       	sbiw	r26, 0x01	; 1
    25ca:	cd 01       	movw	r24, r26
    25cc:	03 96       	adiw	r24, 0x03	; 3
    25ce:	e8 17       	cp	r30, r24
    25d0:	f9 07       	cpc	r31, r25
    25d2:	31 f4       	brne	.+12     	; 0x25e0 <vCoRoutineSchedule+0x1a2>
    25d4:	82 81       	ldd	r24, Z+2	; 0x02
    25d6:	93 81       	ldd	r25, Z+3	; 0x03
    25d8:	12 96       	adiw	r26, 0x02	; 2
    25da:	9c 93       	st	X, r25
    25dc:	8e 93       	st	-X, r24
    25de:	11 97       	sbiw	r26, 0x01	; 1
    25e0:	11 96       	adiw	r26, 0x01	; 1
    25e2:	ed 91       	ld	r30, X+
    25e4:	fc 91       	ld	r31, X
    25e6:	12 97       	sbiw	r26, 0x02	; 2
    25e8:	06 80       	ldd	r0, Z+6	; 0x06
    25ea:	f7 81       	ldd	r31, Z+7	; 0x07
    25ec:	e0 2d       	mov	r30, r0
    25ee:	f0 93 f7 02 	sts	0x02F7, r31
    25f2:	e0 93 f6 02 	sts	0x02F6, r30

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    25f6:	20 81       	ld	r18, Z
    25f8:	31 81       	ldd	r19, Z+1	; 0x01
    25fa:	cf 01       	movw	r24, r30
    25fc:	67 89       	ldd	r22, Z+23	; 0x17
    25fe:	f9 01       	movw	r30, r18
    2600:	09 95       	icall

	return;
}
    2602:	df 91       	pop	r29
    2604:	cf 91       	pop	r28
    2606:	1f 91       	pop	r17
    2608:	0f 91       	pop	r16
    260a:	ff 90       	pop	r15
    260c:	08 95       	ret

0000260e <vCoRoutineAddToDelayedList>:
	return xReturn;	
}
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    260e:	0f 93       	push	r16
    2610:	1f 93       	push	r17
    2612:	cf 93       	push	r28
    2614:	df 93       	push	r29
    2616:	eb 01       	movw	r28, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    2618:	00 91 fd 02 	lds	r16, 0x02FD
    261c:	10 91 fe 02 	lds	r17, 0x02FE
    2620:	08 0f       	add	r16, r24
    2622:	19 1f       	adc	r17, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2624:	80 91 f6 02 	lds	r24, 0x02F6
    2628:	90 91 f7 02 	lds	r25, 0x02F7
    262c:	02 96       	adiw	r24, 0x02	; 2
    262e:	0e 94 21 09 	call	0x1242	; 0x1242 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    2632:	e0 91 f6 02 	lds	r30, 0x02F6
    2636:	f0 91 f7 02 	lds	r31, 0x02F7
    263a:	13 83       	std	Z+3, r17	; 0x03
    263c:	02 83       	std	Z+2, r16	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    263e:	80 91 fd 02 	lds	r24, 0x02FD
    2642:	90 91 fe 02 	lds	r25, 0x02FE
    2646:	bf 01       	movw	r22, r30
    2648:	6e 5f       	subi	r22, 0xFE	; 254
    264a:	7f 4f       	sbci	r23, 0xFF	; 255
    264c:	08 17       	cp	r16, r24
    264e:	19 07       	cpc	r17, r25
    2650:	28 f4       	brcc	.+10     	; 0x265c <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2652:	80 91 25 03 	lds	r24, 0x0325
    2656:	90 91 26 03 	lds	r25, 0x0326
    265a:	04 c0       	rjmp	.+8      	; 0x2664 <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    265c:	80 91 23 03 	lds	r24, 0x0323
    2660:	90 91 24 03 	lds	r25, 0x0324
    2664:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <vListInsert>
	}

	if( pxEventList )
    2668:	20 97       	sbiw	r28, 0x00	; 0
    266a:	49 f0       	breq	.+18     	; 0x267e <vCoRoutineAddToDelayedList+0x70>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    266c:	60 91 f6 02 	lds	r22, 0x02F6
    2670:	70 91 f7 02 	lds	r23, 0x02F7
    2674:	64 5f       	subi	r22, 0xF4	; 244
    2676:	7f 4f       	sbci	r23, 0xFF	; 255
    2678:	ce 01       	movw	r24, r28
    267a:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <vListInsert>
	}
}
    267e:	df 91       	pop	r29
    2680:	cf 91       	pop	r28
    2682:	1f 91       	pop	r17
    2684:	0f 91       	pop	r16
    2686:	08 95       	ret

00002688 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    2688:	af 92       	push	r10
    268a:	bf 92       	push	r11
    268c:	cf 92       	push	r12
    268e:	df 92       	push	r13
    2690:	ef 92       	push	r14
    2692:	ff 92       	push	r15
    2694:	0f 93       	push	r16
    2696:	1f 93       	push	r17
    2698:	cf 93       	push	r28
    269a:	df 93       	push	r29
    269c:	6c 01       	movw	r12, r24
    269e:	b6 2e       	mov	r11, r22
    26a0:	a4 2e       	mov	r10, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    26a2:	8a e1       	ldi	r24, 0x1A	; 26
    26a4:	90 e0       	ldi	r25, 0x00	; 0
    26a6:	0e 94 ce 13 	call	0x279c	; 0x279c <pvPortMalloc>
    26aa:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
    26ac:	00 97       	sbiw	r24, 0x00	; 0
    26ae:	11 f4       	brne	.+4      	; 0x26b4 <xCoRoutineCreate+0x2c>
    26b0:	8f ef       	ldi	r24, 0xFF	; 255
    26b2:	59 c0       	rjmp	.+178    	; 0x2766 <xCoRoutineCreate+0xde>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    26b4:	80 91 f6 02 	lds	r24, 0x02F6
    26b8:	90 91 f7 02 	lds	r25, 0x02F7
    26bc:	89 2b       	or	r24, r25
    26be:	21 f5       	brne	.+72     	; 0x2708 <xCoRoutineCreate+0x80>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    26c0:	d0 93 f7 02 	sts	0x02F7, r29
    26c4:	c0 93 f6 02 	sts	0x02F6, r28
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    26c8:	8f ef       	ldi	r24, 0xFF	; 255
    26ca:	92 e0       	ldi	r25, 0x02	; 2
    26cc:	0e 94 af 08 	call	0x115e	; 0x115e <vListInitialise>
    26d0:	88 e0       	ldi	r24, 0x08	; 8
    26d2:	93 e0       	ldi	r25, 0x03	; 3
    26d4:	0e 94 af 08 	call	0x115e	; 0x115e <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    26d8:	21 e1       	ldi	r18, 0x11	; 17
    26da:	e2 2e       	mov	r14, r18
    26dc:	23 e0       	ldi	r18, 0x03	; 3
    26de:	f2 2e       	mov	r15, r18
    26e0:	c7 01       	movw	r24, r14
    26e2:	0e 94 af 08 	call	0x115e	; 0x115e <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    26e6:	0a e1       	ldi	r16, 0x1A	; 26
    26e8:	13 e0       	ldi	r17, 0x03	; 3
    26ea:	c8 01       	movw	r24, r16
    26ec:	0e 94 af 08 	call	0x115e	; 0x115e <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    26f0:	87 e2       	ldi	r24, 0x27	; 39
    26f2:	93 e0       	ldi	r25, 0x03	; 3
    26f4:	0e 94 af 08 	call	0x115e	; 0x115e <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    26f8:	f0 92 24 03 	sts	0x0324, r15
    26fc:	e0 92 23 03 	sts	0x0323, r14
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    2700:	10 93 26 03 	sts	0x0326, r17
    2704:	00 93 25 03 	sts	0x0325, r16
    2708:	eb 2c       	mov	r14, r11
    270a:	bb 20       	and	r11, r11
    270c:	11 f0       	breq	.+4      	; 0x2712 <xCoRoutineCreate+0x8a>
    270e:	ee 24       	eor	r14, r14
    2710:	e3 94       	inc	r14
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    2712:	19 8e       	std	Y+25, r1	; 0x19
    2714:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    2716:	ee 8a       	std	Y+22, r14	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    2718:	af 8a       	std	Y+23, r10	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    271a:	fe 01       	movw	r30, r28
    271c:	c1 92       	st	Z+, r12
    271e:	d1 92       	st	Z+, r13
    2720:	8f 01       	movw	r16, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    2722:	cf 01       	movw	r24, r30
    2724:	0e 94 bf 08 	call	0x117e	; 0x117e <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    2728:	ce 01       	movw	r24, r28
    272a:	0c 96       	adiw	r24, 0x0c	; 12
    272c:	0e 94 bf 08 	call	0x117e	; 0x117e <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    2730:	d9 87       	std	Y+9, r29	; 0x09
    2732:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    2734:	db 8b       	std	Y+19, r29	; 0x13
    2736:	ca 8b       	std	Y+18, r28	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    2738:	84 e0       	ldi	r24, 0x04	; 4
    273a:	90 e0       	ldi	r25, 0x00	; 0
    273c:	8e 19       	sub	r24, r14
    273e:	91 09       	sbc	r25, r1
    2740:	9d 87       	std	Y+13, r25	; 0x0d
    2742:	8c 87       	std	Y+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    2744:	9e 89       	ldd	r25, Y+22	; 0x16
    2746:	80 91 f8 02 	lds	r24, 0x02F8
    274a:	89 17       	cp	r24, r25
    274c:	10 f4       	brcc	.+4      	; 0x2752 <xCoRoutineCreate+0xca>
    274e:	90 93 f8 02 	sts	0x02F8, r25
    2752:	89 e0       	ldi	r24, 0x09	; 9
    2754:	98 9f       	mul	r25, r24
    2756:	c0 01       	movw	r24, r0
    2758:	11 24       	eor	r1, r1
    275a:	81 50       	subi	r24, 0x01	; 1
    275c:	9d 4f       	sbci	r25, 0xFD	; 253
    275e:	b8 01       	movw	r22, r16
    2760:	0e 94 c3 08 	call	0x1186	; 0x1186 <vListInsertEnd>
    2764:	81 e0       	ldi	r24, 0x01	; 1
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
	}
	
	return xReturn;	
}
    2766:	df 91       	pop	r29
    2768:	cf 91       	pop	r28
    276a:	1f 91       	pop	r17
    276c:	0f 91       	pop	r16
    276e:	ff 90       	pop	r15
    2770:	ef 90       	pop	r14
    2772:	df 90       	pop	r13
    2774:	cf 90       	pop	r12
    2776:	bf 90       	pop	r11
    2778:	af 90       	pop	r10
    277a:	08 95       	ret

0000277c <vPortFree>:
{
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    277c:	08 95       	ret

0000277e <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    277e:	10 92 31 03 	sts	0x0331, r1
    2782:	10 92 30 03 	sts	0x0330, r1
}
    2786:	08 95       	ret

00002788 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    2788:	28 eb       	ldi	r18, 0xB8	; 184
    278a:	3b e0       	ldi	r19, 0x0B	; 11
    278c:	80 91 30 03 	lds	r24, 0x0330
    2790:	90 91 31 03 	lds	r25, 0x0331
    2794:	28 1b       	sub	r18, r24
    2796:	39 0b       	sbc	r19, r25
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
}
    2798:	c9 01       	movw	r24, r18
    279a:	08 95       	ret

0000279c <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    279c:	0f 93       	push	r16
    279e:	1f 93       	push	r17
    27a0:	cf 93       	push	r28
    27a2:	df 93       	push	r29
    27a4:	8c 01       	movw	r16, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    27a6:	0e 94 2e 0c 	call	0x185c	; 0x185c <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    27aa:	80 91 30 03 	lds	r24, 0x0330
    27ae:	90 91 31 03 	lds	r25, 0x0331
    27b2:	98 01       	movw	r18, r16
    27b4:	28 0f       	add	r18, r24
    27b6:	39 1f       	adc	r19, r25
    27b8:	4b e0       	ldi	r20, 0x0B	; 11
    27ba:	28 3b       	cpi	r18, 0xB8	; 184
    27bc:	34 07       	cpc	r19, r20
    27be:	58 f4       	brcc	.+22     	; 0x27d6 <pvPortMalloc+0x3a>
    27c0:	82 17       	cp	r24, r18
    27c2:	93 07       	cpc	r25, r19
    27c4:	40 f4       	brcc	.+16     	; 0x27d6 <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    27c6:	ec 01       	movw	r28, r24
    27c8:	ce 5c       	subi	r28, 0xCE	; 206
    27ca:	dc 4f       	sbci	r29, 0xFC	; 252
			xNextFreeByte += xWantedSize;			
    27cc:	30 93 31 03 	sts	0x0331, r19
    27d0:	20 93 30 03 	sts	0x0330, r18
    27d4:	02 c0       	rjmp	.+4      	; 0x27da <pvPortMalloc+0x3e>
    27d6:	c0 e0       	ldi	r28, 0x00	; 0
    27d8:	d0 e0       	ldi	r29, 0x00	; 0
		}	
	}
	xTaskResumeAll();
    27da:	0e 94 c5 0d 	call	0x1b8a	; 0x1b8a <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
    27de:	ce 01       	movw	r24, r28
    27e0:	df 91       	pop	r29
    27e2:	cf 91       	pop	r28
    27e4:	1f 91       	pop	r17
    27e6:	0f 91       	pop	r16
    27e8:	08 95       	ret

000027ea <prescaler_hex_to_value>:
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    27ea:	e8 2f       	mov	r30, r24
    27ec:	f0 e0       	ldi	r31, 0x00	; 0
    27ee:	e7 70       	andi	r30, 0x07	; 7
    27f0:	f0 70       	andi	r31, 0x00	; 0
    27f2:	ee 0f       	add	r30, r30
    27f4:	ff 1f       	adc	r31, r31
    27f6:	ef 59       	subi	r30, 0x9F	; 159
    27f8:	fe 4f       	sbci	r31, 0xFE	; 254
    27fa:	25 91       	lpm	r18, Z+
    27fc:	34 91       	lpm	r19, Z+
}
    27fe:	c9 01       	movw	r24, r18
    2800:	08 95       	ret

00002802 <prescaler_hex_to_value_for_timer2>:
uint16_t prescaler_hex_to_value_for_timer2(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to Timer2PrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(Timer2PrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    2802:	e8 2f       	mov	r30, r24
    2804:	f0 e0       	ldi	r31, 0x00	; 0
    2806:	e7 70       	andi	r30, 0x07	; 7
    2808:	f0 70       	andi	r31, 0x00	; 0
    280a:	ee 0f       	add	r30, r30
    280c:	ff 1f       	adc	r31, r31
    280e:	e3 59       	subi	r30, 0x93	; 147
    2810:	fe 4f       	sbci	r31, 0xFE	; 254
    2812:	25 91       	lpm	r18, Z+
    2814:	34 91       	lpm	r19, Z+
}
    2816:	c9 01       	movw	r24, r18
    2818:	08 95       	ret

0000281a <get_timer0_prescaler>:

uint16_t get_timer0_prescaler(void)
{
  return prescaler_hex_to_value(TCCR0B);
    281a:	85 b5       	in	r24, 0x25	; 37
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    281c:	e8 2f       	mov	r30, r24
    281e:	f0 e0       	ldi	r31, 0x00	; 0
    2820:	e7 70       	andi	r30, 0x07	; 7
    2822:	f0 70       	andi	r31, 0x00	; 0
    2824:	ee 0f       	add	r30, r30
    2826:	ff 1f       	adc	r31, r31
    2828:	ef 59       	subi	r30, 0x9F	; 159
    282a:	fe 4f       	sbci	r31, 0xFE	; 254
    282c:	25 91       	lpm	r18, Z+
    282e:	34 91       	lpm	r19, Z+
}

uint16_t get_timer0_prescaler(void)
{
  return prescaler_hex_to_value(TCCR0B);
}
    2830:	c9 01       	movw	r24, r18
    2832:	08 95       	ret

00002834 <get_timer1_prescaler>:
uint16_t get_timer1_prescaler(void)
{
  return prescaler_hex_to_value(TCCR1B);
    2834:	80 91 81 00 	lds	r24, 0x0081
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    2838:	e8 2f       	mov	r30, r24
    283a:	f0 e0       	ldi	r31, 0x00	; 0
    283c:	e7 70       	andi	r30, 0x07	; 7
    283e:	f0 70       	andi	r31, 0x00	; 0
    2840:	ee 0f       	add	r30, r30
    2842:	ff 1f       	adc	r31, r31
    2844:	ef 59       	subi	r30, 0x9F	; 159
    2846:	fe 4f       	sbci	r31, 0xFE	; 254
    2848:	25 91       	lpm	r18, Z+
    284a:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR0B);
}
uint16_t get_timer1_prescaler(void)
{
  return prescaler_hex_to_value(TCCR1B);
}
    284c:	c9 01       	movw	r24, r18
    284e:	08 95       	ret

00002850 <get_timer2_prescaler>:
uint16_t get_timer2_prescaler(void)
{
  return prescaler_hex_to_value_for_timer2(TCCR2B);
    2850:	80 91 b1 00 	lds	r24, 0x00B1
uint16_t prescaler_hex_to_value_for_timer2(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to Timer2PrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(Timer2PrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    2854:	e8 2f       	mov	r30, r24
    2856:	f0 e0       	ldi	r31, 0x00	; 0
    2858:	e7 70       	andi	r30, 0x07	; 7
    285a:	f0 70       	andi	r31, 0x00	; 0
    285c:	ee 0f       	add	r30, r30
    285e:	ff 1f       	adc	r31, r31
    2860:	e3 59       	subi	r30, 0x93	; 147
    2862:	fe 4f       	sbci	r31, 0xFE	; 254
    2864:	25 91       	lpm	r18, Z+
    2866:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR1B);
}
uint16_t get_timer2_prescaler(void)
{
  return prescaler_hex_to_value_for_timer2(TCCR2B);
}
    2868:	c9 01       	movw	r24, r18
    286a:	08 95       	ret

0000286c <get_timer3_prescaler>:
uint16_t get_timer3_prescaler(void)
{
  return prescaler_hex_to_value(TCCR3B);
    286c:	80 91 91 00 	lds	r24, 0x0091
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    2870:	e8 2f       	mov	r30, r24
    2872:	f0 e0       	ldi	r31, 0x00	; 0
    2874:	e7 70       	andi	r30, 0x07	; 7
    2876:	f0 70       	andi	r31, 0x00	; 0
    2878:	ee 0f       	add	r30, r30
    287a:	ff 1f       	adc	r31, r31
    287c:	ef 59       	subi	r30, 0x9F	; 159
    287e:	fe 4f       	sbci	r31, 0xFE	; 254
    2880:	25 91       	lpm	r18, Z+
    2882:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value_for_timer2(TCCR2B);
}
uint16_t get_timer3_prescaler(void)
{
  return prescaler_hex_to_value(TCCR3B);
}
    2884:	c9 01       	movw	r24, r18
    2886:	08 95       	ret

00002888 <get_timer4_prescaler>:
uint16_t get_timer4_prescaler(void)
{
  return prescaler_hex_to_value(TCCR4B);
    2888:	80 91 a1 00 	lds	r24, 0x00A1
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    288c:	e8 2f       	mov	r30, r24
    288e:	f0 e0       	ldi	r31, 0x00	; 0
    2890:	e7 70       	andi	r30, 0x07	; 7
    2892:	f0 70       	andi	r31, 0x00	; 0
    2894:	ee 0f       	add	r30, r30
    2896:	ff 1f       	adc	r31, r31
    2898:	ef 59       	subi	r30, 0x9F	; 159
    289a:	fe 4f       	sbci	r31, 0xFE	; 254
    289c:	25 91       	lpm	r18, Z+
    289e:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR3B);
}
uint16_t get_timer4_prescaler(void)
{
  return prescaler_hex_to_value(TCCR4B);
}
    28a0:	c9 01       	movw	r24, r18
    28a2:	08 95       	ret

000028a4 <get_timer5_prescaler>:
uint16_t get_timer5_prescaler(void)
{
  return prescaler_hex_to_value(TCCR5B);
    28a4:	80 91 21 01 	lds	r24, 0x0121
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    28a8:	e8 2f       	mov	r30, r24
    28aa:	f0 e0       	ldi	r31, 0x00	; 0
    28ac:	e7 70       	andi	r30, 0x07	; 7
    28ae:	f0 70       	andi	r31, 0x00	; 0
    28b0:	ee 0f       	add	r30, r30
    28b2:	ff 1f       	adc	r31, r31
    28b4:	ef 59       	subi	r30, 0x9F	; 159
    28b6:	fe 4f       	sbci	r31, 0xFE	; 254
    28b8:	25 91       	lpm	r18, Z+
    28ba:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR4B);
}
uint16_t get_timer5_prescaler(void)
{
  return prescaler_hex_to_value(TCCR5B);
}
    28bc:	c9 01       	movw	r24, r18
    28be:	08 95       	ret

000028c0 <get_timer0_overflow>:

const uint32_t get_timer0_overflow(void)
{
    return timer0_ovrflow_cnt;
    28c0:	20 91 0a 18 	lds	r18, 0x180A
    28c4:	30 91 0b 18 	lds	r19, 0x180B
    28c8:	40 91 0c 18 	lds	r20, 0x180C
    28cc:	50 91 0d 18 	lds	r21, 0x180D
}
    28d0:	b9 01       	movw	r22, r18
    28d2:	ca 01       	movw	r24, r20
    28d4:	08 95       	ret

000028d6 <get_timer1_overflow>:
const uint32_t get_timer1_overflow(void)
{
    return timer1_ovrflow_cnt;
    28d6:	20 91 06 18 	lds	r18, 0x1806
    28da:	30 91 07 18 	lds	r19, 0x1807
    28de:	40 91 08 18 	lds	r20, 0x1808
    28e2:	50 91 09 18 	lds	r21, 0x1809
}
    28e6:	b9 01       	movw	r22, r18
    28e8:	ca 01       	movw	r24, r20
    28ea:	08 95       	ret

000028ec <get_timer2_overflow>:
const uint32_t get_timer2_overflow(void)
{
    return timer2_ovrflow_cnt;
    28ec:	20 91 0e 18 	lds	r18, 0x180E
    28f0:	30 91 0f 18 	lds	r19, 0x180F
    28f4:	40 91 10 18 	lds	r20, 0x1810
    28f8:	50 91 11 18 	lds	r21, 0x1811
}
    28fc:	b9 01       	movw	r22, r18
    28fe:	ca 01       	movw	r24, r20
    2900:	08 95       	ret

00002902 <get_timer3_overflow>:
const uint32_t get_timer3_overflow(void)
{
    return timer3_ovrflow_cnt;
    2902:	20 91 16 18 	lds	r18, 0x1816
    2906:	30 91 17 18 	lds	r19, 0x1817
    290a:	40 91 18 18 	lds	r20, 0x1818
    290e:	50 91 19 18 	lds	r21, 0x1819
}
    2912:	b9 01       	movw	r22, r18
    2914:	ca 01       	movw	r24, r20
    2916:	08 95       	ret

00002918 <get_timer4_overflow>:
const uint32_t get_timer4_overflow(void)
{
    return timer4_ovrflow_cnt;
    2918:	20 91 02 18 	lds	r18, 0x1802
    291c:	30 91 03 18 	lds	r19, 0x1803
    2920:	40 91 04 18 	lds	r20, 0x1804
    2924:	50 91 05 18 	lds	r21, 0x1805
}
    2928:	b9 01       	movw	r22, r18
    292a:	ca 01       	movw	r24, r20
    292c:	08 95       	ret

0000292e <get_timer5_overflow>:
const uint32_t get_timer5_overflow(void)
{
    return timer5_ovrflow_cnt;
    292e:	20 91 1a 18 	lds	r18, 0x181A
    2932:	30 91 1b 18 	lds	r19, 0x181B
    2936:	40 91 1c 18 	lds	r20, 0x181C
    293a:	50 91 1d 18 	lds	r21, 0x181D
}
    293e:	b9 01       	movw	r22, r18
    2940:	ca 01       	movw	r24, r20
    2942:	08 95       	ret

00002944 <get_timer0_counter>:

const uint8_t get_timer0_counter(void)
{
    return TCNT0;
    2944:	86 b5       	in	r24, 0x26	; 38
}
    2946:	08 95       	ret

00002948 <get_timer1_counter>:
const uint16_t get_timer1_counter(void)
{
    return TCNT1;
    2948:	20 91 84 00 	lds	r18, 0x0084
    294c:	30 91 85 00 	lds	r19, 0x0085
}
    2950:	c9 01       	movw	r24, r18
    2952:	08 95       	ret

00002954 <get_timer2_counter>:
const uint8_t get_timer2_counter(void)
{
    return TCNT2;
    2954:	80 91 b2 00 	lds	r24, 0x00B2
}
    2958:	08 95       	ret

0000295a <get_timer3_counter>:
const uint16_t get_timer3_counter(void)
{
    return TCNT3;
    295a:	20 91 94 00 	lds	r18, 0x0094
    295e:	30 91 95 00 	lds	r19, 0x0095
}
    2962:	c9 01       	movw	r24, r18
    2964:	08 95       	ret

00002966 <get_timer4_counter>:
const uint16_t get_timer4_counter(void)
{
    return TCNT4;
    2966:	20 91 a4 00 	lds	r18, 0x00A4
    296a:	30 91 a5 00 	lds	r19, 0x00A5
}
    296e:	c9 01       	movw	r24, r18
    2970:	08 95       	ret

00002972 <get_timer5_counter>:
const uint16_t get_timer5_counter(void)
{
    return TCNT5;
    2972:	20 91 24 01 	lds	r18, 0x0124
    2976:	30 91 25 01 	lds	r19, 0x0125
}
    297a:	c9 01       	movw	r24, r18
    297c:	08 95       	ret

0000297e <reset_timer0>:

void reset_timer0(void)
{
    TCNT0 = timer0_ovrflow_cnt = 0;
    297e:	10 92 0a 18 	sts	0x180A, r1
    2982:	10 92 0b 18 	sts	0x180B, r1
    2986:	10 92 0c 18 	sts	0x180C, r1
    298a:	10 92 0d 18 	sts	0x180D, r1
    298e:	16 bc       	out	0x26, r1	; 38
}
    2990:	08 95       	ret

00002992 <reset_timer1>:
void reset_timer1(void)
{
    TCNT1 = timer1_ovrflow_cnt = 0;
    2992:	10 92 06 18 	sts	0x1806, r1
    2996:	10 92 07 18 	sts	0x1807, r1
    299a:	10 92 08 18 	sts	0x1808, r1
    299e:	10 92 09 18 	sts	0x1809, r1
    29a2:	10 92 85 00 	sts	0x0085, r1
    29a6:	10 92 84 00 	sts	0x0084, r1
}
    29aa:	08 95       	ret

000029ac <reset_timer2>:
void reset_timer2(void)
{
    TCNT2 = timer2_ovrflow_cnt = 0;
    29ac:	10 92 0e 18 	sts	0x180E, r1
    29b0:	10 92 0f 18 	sts	0x180F, r1
    29b4:	10 92 10 18 	sts	0x1810, r1
    29b8:	10 92 11 18 	sts	0x1811, r1
    29bc:	10 92 b2 00 	sts	0x00B2, r1
}
    29c0:	08 95       	ret

000029c2 <reset_timer3>:
void reset_timer3(void)
{
    TCNT3 = timer3_ovrflow_cnt = 0;
    29c2:	10 92 16 18 	sts	0x1816, r1
    29c6:	10 92 17 18 	sts	0x1817, r1
    29ca:	10 92 18 18 	sts	0x1818, r1
    29ce:	10 92 19 18 	sts	0x1819, r1
    29d2:	10 92 95 00 	sts	0x0095, r1
    29d6:	10 92 94 00 	sts	0x0094, r1
}
    29da:	08 95       	ret

000029dc <reset_timer4>:
void reset_timer4(void)
{
    TCNT4 = timer4_ovrflow_cnt = 0;
    29dc:	10 92 02 18 	sts	0x1802, r1
    29e0:	10 92 03 18 	sts	0x1803, r1
    29e4:	10 92 04 18 	sts	0x1804, r1
    29e8:	10 92 05 18 	sts	0x1805, r1
    29ec:	10 92 a5 00 	sts	0x00A5, r1
    29f0:	10 92 a4 00 	sts	0x00A4, r1
}
    29f4:	08 95       	ret

000029f6 <reset_timer5>:
void reset_timer5(void)
{
    TCNT5 = timer5_ovrflow_cnt = 0;
    29f6:	10 92 1a 18 	sts	0x181A, r1
    29fa:	10 92 1b 18 	sts	0x181B, r1
    29fe:	10 92 1c 18 	sts	0x181C, r1
    2a02:	10 92 1d 18 	sts	0x181D, r1
    2a06:	10 92 25 01 	sts	0x0125, r1
    2a0a:	10 92 24 01 	sts	0x0124, r1
}
    2a0e:	08 95       	ret

00002a10 <delay_us>:

	delay_loops = ((time_us * CYCLES_PER_US)+3) / 5; // +3 for rounding up (dirty) 

	// one loop takes 5 cpu cycles 
	for (i=0; i < delay_loops; i++) {};
}
    2a10:	08 95       	ret

00002a12 <init_timer0>:

void init_timer0(const uint8_t prescaler)
{
  TCCR0B = prescaler;
    2a12:	85 bd       	out	0x25, r24	; 37
  TIMSK0 = _BV(TOIE0); // enable interrupts
    2a14:	81 e0       	ldi	r24, 0x01	; 1
    2a16:	80 93 6e 00 	sts	0x006E, r24
    return TCNT5;
}

void reset_timer0(void)
{
    TCNT0 = timer0_ovrflow_cnt = 0;
    2a1a:	10 92 0a 18 	sts	0x180A, r1
    2a1e:	10 92 0b 18 	sts	0x180B, r1
    2a22:	10 92 0c 18 	sts	0x180C, r1
    2a26:	10 92 0d 18 	sts	0x180D, r1
    2a2a:	16 bc       	out	0x26, r1	; 38
void init_timer0(const uint8_t prescaler)
{
  TCCR0B = prescaler;
  TIMSK0 = _BV(TOIE0); // enable interrupts
  reset_timer0(); // reset counter
}
    2a2c:	08 95       	ret

00002a2e <init_timer1>:
void init_timer1(const uint8_t prescaler)
{
  TCCR1B = prescaler;
    2a2e:	80 93 81 00 	sts	0x0081, r24
  TIMSK1 = _BV(TOIE1); // enable interrupts
    2a32:	81 e0       	ldi	r24, 0x01	; 1
    2a34:	80 93 6f 00 	sts	0x006F, r24
{
    TCNT0 = timer0_ovrflow_cnt = 0;
}
void reset_timer1(void)
{
    TCNT1 = timer1_ovrflow_cnt = 0;
    2a38:	10 92 06 18 	sts	0x1806, r1
    2a3c:	10 92 07 18 	sts	0x1807, r1
    2a40:	10 92 08 18 	sts	0x1808, r1
    2a44:	10 92 09 18 	sts	0x1809, r1
    2a48:	10 92 85 00 	sts	0x0085, r1
    2a4c:	10 92 84 00 	sts	0x0084, r1
void init_timer1(const uint8_t prescaler)
{
  TCCR1B = prescaler;
  TIMSK1 = _BV(TOIE1); // enable interrupts
  reset_timer1(); // reset counter
}
    2a50:	08 95       	ret

00002a52 <init_timer2>:
void init_timer2(const uint8_t prescaler)
{
  TCCR2B = prescaler;
    2a52:	80 93 b1 00 	sts	0x00B1, r24
  TIMSK2 = _BV(TOIE2); // enable interrupts
    2a56:	81 e0       	ldi	r24, 0x01	; 1
    2a58:	80 93 70 00 	sts	0x0070, r24
{
    TCNT1 = timer1_ovrflow_cnt = 0;
}
void reset_timer2(void)
{
    TCNT2 = timer2_ovrflow_cnt = 0;
    2a5c:	10 92 0e 18 	sts	0x180E, r1
    2a60:	10 92 0f 18 	sts	0x180F, r1
    2a64:	10 92 10 18 	sts	0x1810, r1
    2a68:	10 92 11 18 	sts	0x1811, r1
    2a6c:	10 92 b2 00 	sts	0x00B2, r1
void init_timer2(const uint8_t prescaler)
{
  TCCR2B = prescaler;
  TIMSK2 = _BV(TOIE2); // enable interrupts
  reset_timer2(); // reset counter
}
    2a70:	08 95       	ret

00002a72 <init_timer3>:
void init_timer3(const uint8_t prescaler)
{
  TCCR3B = prescaler;
    2a72:	80 93 91 00 	sts	0x0091, r24
  TIMSK3 = _BV(TOIE3); // enable interrupts
    2a76:	81 e0       	ldi	r24, 0x01	; 1
    2a78:	80 93 71 00 	sts	0x0071, r24
{
    TCNT2 = timer2_ovrflow_cnt = 0;
}
void reset_timer3(void)
{
    TCNT3 = timer3_ovrflow_cnt = 0;
    2a7c:	10 92 16 18 	sts	0x1816, r1
    2a80:	10 92 17 18 	sts	0x1817, r1
    2a84:	10 92 18 18 	sts	0x1818, r1
    2a88:	10 92 19 18 	sts	0x1819, r1
    2a8c:	10 92 95 00 	sts	0x0095, r1
    2a90:	10 92 94 00 	sts	0x0094, r1
void init_timer3(const uint8_t prescaler)
{
  TCCR3B = prescaler;
  TIMSK3 = _BV(TOIE3); // enable interrupts
  reset_timer3(); // reset counter
}
    2a94:	08 95       	ret

00002a96 <init_timer4>:
void init_timer4(const uint8_t prescaler)
{
  TCCR4B = prescaler;
    2a96:	80 93 a1 00 	sts	0x00A1, r24
  TIMSK4 = _BV(TOIE4); // enable interrupts
    2a9a:	81 e0       	ldi	r24, 0x01	; 1
    2a9c:	80 93 72 00 	sts	0x0072, r24
{
    TCNT3 = timer3_ovrflow_cnt = 0;
}
void reset_timer4(void)
{
    TCNT4 = timer4_ovrflow_cnt = 0;
    2aa0:	10 92 02 18 	sts	0x1802, r1
    2aa4:	10 92 03 18 	sts	0x1803, r1
    2aa8:	10 92 04 18 	sts	0x1804, r1
    2aac:	10 92 05 18 	sts	0x1805, r1
    2ab0:	10 92 a5 00 	sts	0x00A5, r1
    2ab4:	10 92 a4 00 	sts	0x00A4, r1
void init_timer4(const uint8_t prescaler)
{
  TCCR4B = prescaler;
  TIMSK4 = _BV(TOIE4); // enable interrupts
  reset_timer4(); // reset counter
}
    2ab8:	08 95       	ret

00002aba <init_timer5>:
void init_timer5(const uint8_t prescaler)
{
  TCCR5B = prescaler;
    2aba:	80 93 21 01 	sts	0x0121, r24
  TIMSK5 = _BV(TOIE5); // enable interrupts
    2abe:	81 e0       	ldi	r24, 0x01	; 1
    2ac0:	80 93 73 00 	sts	0x0073, r24
{
    TCNT4 = timer4_ovrflow_cnt = 0;
}
void reset_timer5(void)
{
    TCNT5 = timer5_ovrflow_cnt = 0;
    2ac4:	10 92 1a 18 	sts	0x181A, r1
    2ac8:	10 92 1b 18 	sts	0x181B, r1
    2acc:	10 92 1c 18 	sts	0x181C, r1
    2ad0:	10 92 1d 18 	sts	0x181D, r1
    2ad4:	10 92 25 01 	sts	0x0125, r1
    2ad8:	10 92 24 01 	sts	0x0124, r1
void init_timer5(const uint8_t prescaler)
{
  TCCR5B = prescaler;
  TIMSK5 = _BV(TOIE5); // enable interrupts
  reset_timer5(); // reset counter
}
    2adc:	08 95       	ret

00002ade <timer_attach>:

void timer_attach(TimerInterrupt_t interrupt, void (*user_func)(void) )
{
  // set the interrupt function to run
  // the supplied user's function
  TimerIntFunc[interrupt] = user_func;
    2ade:	e8 2f       	mov	r30, r24
    2ae0:	f0 e0       	ldi	r31, 0x00	; 0
    2ae2:	ee 0f       	add	r30, r30
    2ae4:	ff 1f       	adc	r31, r31
    2ae6:	e6 51       	subi	r30, 0x16	; 22
    2ae8:	f1 4f       	sbci	r31, 0xF1	; 241
    2aea:	71 83       	std	Z+1, r23	; 0x01
    2aec:	60 83       	st	Z, r22
}
    2aee:	08 95       	ret

00002af0 <timer_detach>:

void timer_detach(TimerInterrupt_t interrupt)
{
  // clear the user defined interrupt function
  TimerIntFunc[interrupt] = NULL;
    2af0:	e8 2f       	mov	r30, r24
    2af2:	f0 e0       	ldi	r31, 0x00	; 0
    2af4:	ee 0f       	add	r30, r30
    2af6:	ff 1f       	adc	r31, r31
    2af8:	e6 51       	subi	r30, 0x16	; 22
    2afa:	f1 4f       	sbci	r31, 0xF1	; 241
    2afc:	11 82       	std	Z+1, r1	; 0x01
    2afe:	10 82       	st	Z, r1
}
    2b00:	08 95       	ret

00002b02 <_delay_loop_2>:

void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    2b02:	01 97       	sbiw	r24, 0x01	; 1
    2b04:	f1 f7       	brne	.-4      	; 0x2b02 <_delay_loop_2>
		"1: sbiw %0,1" "\n\t"
		"brne 1b"
		: "=w" (__count)
		: "0" (__count)
	);
}
    2b06:	08 95       	ret

00002b08 <sleep>:

void sleep(uint16_t time_ms)
{
    2b08:	af 92       	push	r10
    2b0a:	bf 92       	push	r11
    2b0c:	cf 92       	push	r12
    2b0e:	df 92       	push	r13
    2b10:	ef 92       	push	r14
    2b12:	ff 92       	push	r15
    2b14:	0f 93       	push	r16
    2b16:	1f 93       	push	r17
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * time_ms;
    2b18:	a0 e0       	ldi	r26, 0x00	; 0
    2b1a:	b0 e0       	ldi	r27, 0x00	; 0
    2b1c:	bc 01       	movw	r22, r24
    2b1e:	cd 01       	movw	r24, r26
    2b20:	0e 94 c1 26 	call	0x4d82	; 0x4d82 <__floatunsisf>
    2b24:	5b 01       	movw	r10, r22
    2b26:	6c 01       	movw	r12, r24
    2b28:	20 e0       	ldi	r18, 0x00	; 0
    2b2a:	30 e0       	ldi	r19, 0x00	; 0
    2b2c:	4a e7       	ldi	r20, 0x7A	; 122
    2b2e:	55 e4       	ldi	r21, 0x45	; 69
    2b30:	0e 94 77 27 	call	0x4eee	; 0x4eee <__mulsf3>
    2b34:	7b 01       	movw	r14, r22
    2b36:	8c 01       	movw	r16, r24
	if (__tmp < 1.0)
    2b38:	20 e0       	ldi	r18, 0x00	; 0
    2b3a:	30 e0       	ldi	r19, 0x00	; 0
    2b3c:	40 e8       	ldi	r20, 0x80	; 128
    2b3e:	5f e3       	ldi	r21, 0x3F	; 63
    2b40:	0e 94 29 26 	call	0x4c52	; 0x4c52 <__cmpsf2>
    2b44:	88 23       	and	r24, r24
    2b46:	1c f4       	brge	.+6      	; 0x2b4e <sleep+0x46>
    2b48:	61 e0       	ldi	r22, 0x01	; 1
    2b4a:	70 e0       	ldi	r23, 0x00	; 0
    2b4c:	24 c0       	rjmp	.+72     	; 0x2b96 <sleep+0x8e>
		__ticks = 1;
	else if (__tmp > 65535)
    2b4e:	c8 01       	movw	r24, r16
    2b50:	b7 01       	movw	r22, r14
    2b52:	20 e0       	ldi	r18, 0x00	; 0
    2b54:	3f ef       	ldi	r19, 0xFF	; 255
    2b56:	4f e7       	ldi	r20, 0x7F	; 127
    2b58:	57 e4       	ldi	r21, 0x47	; 71
    2b5a:	0e 94 73 27 	call	0x4ee6	; 0x4ee6 <__gesf2>
    2b5e:	18 16       	cp	r1, r24
    2b60:	b4 f4       	brge	.+44     	; 0x2b8e <sleep+0x86>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (time_ms * 10.0);
    2b62:	c6 01       	movw	r24, r12
    2b64:	b5 01       	movw	r22, r10
    2b66:	20 e0       	ldi	r18, 0x00	; 0
    2b68:	30 e0       	ldi	r19, 0x00	; 0
    2b6a:	40 e2       	ldi	r20, 0x20	; 32
    2b6c:	51 e4       	ldi	r21, 0x41	; 65
    2b6e:	0e 94 77 27 	call	0x4eee	; 0x4eee <__mulsf3>
    2b72:	0e 94 95 26 	call	0x4d2a	; 0x4d2a <__fixunssfsi>
}

void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    2b76:	80 e9       	ldi	r24, 0x90	; 144
    2b78:	91 e0       	ldi	r25, 0x01	; 1
    2b7a:	05 c0       	rjmp	.+10     	; 0x2b86 <sleep+0x7e>
    2b7c:	fc 01       	movw	r30, r24
    2b7e:	31 97       	sbiw	r30, 0x01	; 1
    2b80:	f1 f7       	brne	.-4      	; 0x2b7e <sleep+0x76>
		__ticks = (uint16_t) (time_ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2b82:	61 50       	subi	r22, 0x01	; 1
    2b84:	70 40       	sbci	r23, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (time_ms * 10.0);
		while(__ticks)
    2b86:	61 15       	cp	r22, r1
    2b88:	71 05       	cpc	r23, r1
    2b8a:	c1 f7       	brne	.-16     	; 0x2b7c <sleep+0x74>
    2b8c:	07 c0       	rjmp	.+14     	; 0x2b9c <sleep+0x94>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2b8e:	c8 01       	movw	r24, r16
    2b90:	b7 01       	movw	r22, r14
    2b92:	0e 94 95 26 	call	0x4d2a	; 0x4d2a <__fixunssfsi>
}

void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    2b96:	cb 01       	movw	r24, r22
    2b98:	01 97       	sbiw	r24, 0x01	; 1
    2b9a:	f1 f7       	brne	.-4      	; 0x2b98 <sleep+0x90>
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
	_delay_loop_2(__ticks);
}
    2b9c:	1f 91       	pop	r17
    2b9e:	0f 91       	pop	r16
    2ba0:	ff 90       	pop	r15
    2ba2:	ef 90       	pop	r14
    2ba4:	df 90       	pop	r13
    2ba6:	cf 90       	pop	r12
    2ba8:	bf 90       	pop	r11
    2baa:	af 90       	pop	r10
    2bac:	08 95       	ret

00002bae <__vector_23>:
    }
  }
}*/

ISR(TIMER0_OVF_vect) 
{
    2bae:	1f 92       	push	r1
    2bb0:	0f 92       	push	r0
    2bb2:	0f b6       	in	r0, 0x3f	; 63
    2bb4:	0f 92       	push	r0
    2bb6:	11 24       	eor	r1, r1
    2bb8:	2f 93       	push	r18
    2bba:	3f 93       	push	r19
    2bbc:	4f 93       	push	r20
    2bbe:	5f 93       	push	r21
    2bc0:	6f 93       	push	r22
    2bc2:	7f 93       	push	r23
    2bc4:	8f 93       	push	r24
    2bc6:	9f 93       	push	r25
    2bc8:	af 93       	push	r26
    2bca:	bf 93       	push	r27
    2bcc:	ef 93       	push	r30
    2bce:	ff 93       	push	r31
  timer0_ovrflow_cnt++;
    2bd0:	80 91 0a 18 	lds	r24, 0x180A
    2bd4:	90 91 0b 18 	lds	r25, 0x180B
    2bd8:	a0 91 0c 18 	lds	r26, 0x180C
    2bdc:	b0 91 0d 18 	lds	r27, 0x180D
    2be0:	01 96       	adiw	r24, 0x01	; 1
    2be2:	a1 1d       	adc	r26, r1
    2be4:	b1 1d       	adc	r27, r1
    2be6:	80 93 0a 18 	sts	0x180A, r24
    2bea:	90 93 0b 18 	sts	0x180B, r25
    2bee:	a0 93 0c 18 	sts	0x180C, r26
    2bf2:	b0 93 0d 18 	sts	0x180D, r27
  timer_sleep_cnt++;
    2bf6:	80 91 12 18 	lds	r24, 0x1812
    2bfa:	90 91 13 18 	lds	r25, 0x1813
    2bfe:	a0 91 14 18 	lds	r26, 0x1814
    2c02:	b0 91 15 18 	lds	r27, 0x1815
    2c06:	01 96       	adiw	r24, 0x01	; 1
    2c08:	a1 1d       	adc	r26, r1
    2c0a:	b1 1d       	adc	r27, r1
    2c0c:	80 93 12 18 	sts	0x1812, r24
    2c10:	90 93 13 18 	sts	0x1813, r25
    2c14:	a0 93 14 18 	sts	0x1814, r26
    2c18:	b0 93 15 18 	sts	0x1815, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER0_OVF_interrupt);
    2c1c:	80 91 ee 0e 	lds	r24, 0x0EEE
    2c20:	90 91 ef 0e 	lds	r25, 0x0EEF
    2c24:	89 2b       	or	r24, r25
    2c26:	29 f0       	breq	.+10     	; 0x2c32 <__vector_23+0x84>
    2c28:	e0 91 ee 0e 	lds	r30, 0x0EEE
    2c2c:	f0 91 ef 0e 	lds	r31, 0x0EEF
    2c30:	09 95       	icall
}
    2c32:	ff 91       	pop	r31
    2c34:	ef 91       	pop	r30
    2c36:	bf 91       	pop	r27
    2c38:	af 91       	pop	r26
    2c3a:	9f 91       	pop	r25
    2c3c:	8f 91       	pop	r24
    2c3e:	7f 91       	pop	r23
    2c40:	6f 91       	pop	r22
    2c42:	5f 91       	pop	r21
    2c44:	4f 91       	pop	r20
    2c46:	3f 91       	pop	r19
    2c48:	2f 91       	pop	r18
    2c4a:	0f 90       	pop	r0
    2c4c:	0f be       	out	0x3f, r0	; 63
    2c4e:	0f 90       	pop	r0
    2c50:	1f 90       	pop	r1
    2c52:	18 95       	reti

00002c54 <__vector_20>:
ISR(TIMER1_OVF_vect) 
{
    2c54:	1f 92       	push	r1
    2c56:	0f 92       	push	r0
    2c58:	0f b6       	in	r0, 0x3f	; 63
    2c5a:	0f 92       	push	r0
    2c5c:	11 24       	eor	r1, r1
    2c5e:	2f 93       	push	r18
    2c60:	3f 93       	push	r19
    2c62:	4f 93       	push	r20
    2c64:	5f 93       	push	r21
    2c66:	6f 93       	push	r22
    2c68:	7f 93       	push	r23
    2c6a:	8f 93       	push	r24
    2c6c:	9f 93       	push	r25
    2c6e:	af 93       	push	r26
    2c70:	bf 93       	push	r27
    2c72:	ef 93       	push	r30
    2c74:	ff 93       	push	r31
  timer1_ovrflow_cnt++;
    2c76:	80 91 06 18 	lds	r24, 0x1806
    2c7a:	90 91 07 18 	lds	r25, 0x1807
    2c7e:	a0 91 08 18 	lds	r26, 0x1808
    2c82:	b0 91 09 18 	lds	r27, 0x1809
    2c86:	01 96       	adiw	r24, 0x01	; 1
    2c88:	a1 1d       	adc	r26, r1
    2c8a:	b1 1d       	adc	r27, r1
    2c8c:	80 93 06 18 	sts	0x1806, r24
    2c90:	90 93 07 18 	sts	0x1807, r25
    2c94:	a0 93 08 18 	sts	0x1808, r26
    2c98:	b0 93 09 18 	sts	0x1809, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER1_OVF_interrupt);
    2c9c:	80 91 f8 0e 	lds	r24, 0x0EF8
    2ca0:	90 91 f9 0e 	lds	r25, 0x0EF9
    2ca4:	89 2b       	or	r24, r25
    2ca6:	29 f0       	breq	.+10     	; 0x2cb2 <__vector_20+0x5e>
    2ca8:	e0 91 f8 0e 	lds	r30, 0x0EF8
    2cac:	f0 91 f9 0e 	lds	r31, 0x0EF9
    2cb0:	09 95       	icall
}
    2cb2:	ff 91       	pop	r31
    2cb4:	ef 91       	pop	r30
    2cb6:	bf 91       	pop	r27
    2cb8:	af 91       	pop	r26
    2cba:	9f 91       	pop	r25
    2cbc:	8f 91       	pop	r24
    2cbe:	7f 91       	pop	r23
    2cc0:	6f 91       	pop	r22
    2cc2:	5f 91       	pop	r21
    2cc4:	4f 91       	pop	r20
    2cc6:	3f 91       	pop	r19
    2cc8:	2f 91       	pop	r18
    2cca:	0f 90       	pop	r0
    2ccc:	0f be       	out	0x3f, r0	; 63
    2cce:	0f 90       	pop	r0
    2cd0:	1f 90       	pop	r1
    2cd2:	18 95       	reti

00002cd4 <__vector_15>:
ISR(TIMER2_OVF_vect) 
{
    2cd4:	1f 92       	push	r1
    2cd6:	0f 92       	push	r0
    2cd8:	0f b6       	in	r0, 0x3f	; 63
    2cda:	0f 92       	push	r0
    2cdc:	11 24       	eor	r1, r1
    2cde:	2f 93       	push	r18
    2ce0:	3f 93       	push	r19
    2ce2:	4f 93       	push	r20
    2ce4:	5f 93       	push	r21
    2ce6:	6f 93       	push	r22
    2ce8:	7f 93       	push	r23
    2cea:	8f 93       	push	r24
    2cec:	9f 93       	push	r25
    2cee:	af 93       	push	r26
    2cf0:	bf 93       	push	r27
    2cf2:	ef 93       	push	r30
    2cf4:	ff 93       	push	r31
  timer2_ovrflow_cnt++;
    2cf6:	80 91 0e 18 	lds	r24, 0x180E
    2cfa:	90 91 0f 18 	lds	r25, 0x180F
    2cfe:	a0 91 10 18 	lds	r26, 0x1810
    2d02:	b0 91 11 18 	lds	r27, 0x1811
    2d06:	01 96       	adiw	r24, 0x01	; 1
    2d08:	a1 1d       	adc	r26, r1
    2d0a:	b1 1d       	adc	r27, r1
    2d0c:	80 93 0e 18 	sts	0x180E, r24
    2d10:	90 93 0f 18 	sts	0x180F, r25
    2d14:	a0 93 10 18 	sts	0x1810, r26
    2d18:	b0 93 11 18 	sts	0x1811, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER2_OVF_interrupt);
    2d1c:	80 91 fe 0e 	lds	r24, 0x0EFE
    2d20:	90 91 ff 0e 	lds	r25, 0x0EFF
    2d24:	89 2b       	or	r24, r25
    2d26:	29 f0       	breq	.+10     	; 0x2d32 <__vector_15+0x5e>
    2d28:	e0 91 fe 0e 	lds	r30, 0x0EFE
    2d2c:	f0 91 ff 0e 	lds	r31, 0x0EFF
    2d30:	09 95       	icall
}
    2d32:	ff 91       	pop	r31
    2d34:	ef 91       	pop	r30
    2d36:	bf 91       	pop	r27
    2d38:	af 91       	pop	r26
    2d3a:	9f 91       	pop	r25
    2d3c:	8f 91       	pop	r24
    2d3e:	7f 91       	pop	r23
    2d40:	6f 91       	pop	r22
    2d42:	5f 91       	pop	r21
    2d44:	4f 91       	pop	r20
    2d46:	3f 91       	pop	r19
    2d48:	2f 91       	pop	r18
    2d4a:	0f 90       	pop	r0
    2d4c:	0f be       	out	0x3f, r0	; 63
    2d4e:	0f 90       	pop	r0
    2d50:	1f 90       	pop	r1
    2d52:	18 95       	reti

00002d54 <__vector_35>:
ISR(TIMER3_OVF_vect) 
{
    2d54:	1f 92       	push	r1
    2d56:	0f 92       	push	r0
    2d58:	0f b6       	in	r0, 0x3f	; 63
    2d5a:	0f 92       	push	r0
    2d5c:	11 24       	eor	r1, r1
    2d5e:	2f 93       	push	r18
    2d60:	3f 93       	push	r19
    2d62:	4f 93       	push	r20
    2d64:	5f 93       	push	r21
    2d66:	6f 93       	push	r22
    2d68:	7f 93       	push	r23
    2d6a:	8f 93       	push	r24
    2d6c:	9f 93       	push	r25
    2d6e:	af 93       	push	r26
    2d70:	bf 93       	push	r27
    2d72:	ef 93       	push	r30
    2d74:	ff 93       	push	r31
  timer3_ovrflow_cnt++;
    2d76:	80 91 16 18 	lds	r24, 0x1816
    2d7a:	90 91 17 18 	lds	r25, 0x1817
    2d7e:	a0 91 18 18 	lds	r26, 0x1818
    2d82:	b0 91 19 18 	lds	r27, 0x1819
    2d86:	01 96       	adiw	r24, 0x01	; 1
    2d88:	a1 1d       	adc	r26, r1
    2d8a:	b1 1d       	adc	r27, r1
    2d8c:	80 93 16 18 	sts	0x1816, r24
    2d90:	90 93 17 18 	sts	0x1817, r25
    2d94:	a0 93 18 18 	sts	0x1818, r26
    2d98:	b0 93 19 18 	sts	0x1819, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER3_OVF_interrupt);
    2d9c:	80 91 08 0f 	lds	r24, 0x0F08
    2da0:	90 91 09 0f 	lds	r25, 0x0F09
    2da4:	89 2b       	or	r24, r25
    2da6:	29 f0       	breq	.+10     	; 0x2db2 <__vector_35+0x5e>
    2da8:	e0 91 08 0f 	lds	r30, 0x0F08
    2dac:	f0 91 09 0f 	lds	r31, 0x0F09
    2db0:	09 95       	icall
}
    2db2:	ff 91       	pop	r31
    2db4:	ef 91       	pop	r30
    2db6:	bf 91       	pop	r27
    2db8:	af 91       	pop	r26
    2dba:	9f 91       	pop	r25
    2dbc:	8f 91       	pop	r24
    2dbe:	7f 91       	pop	r23
    2dc0:	6f 91       	pop	r22
    2dc2:	5f 91       	pop	r21
    2dc4:	4f 91       	pop	r20
    2dc6:	3f 91       	pop	r19
    2dc8:	2f 91       	pop	r18
    2dca:	0f 90       	pop	r0
    2dcc:	0f be       	out	0x3f, r0	; 63
    2dce:	0f 90       	pop	r0
    2dd0:	1f 90       	pop	r1
    2dd2:	18 95       	reti

00002dd4 <__vector_45>:
ISR(TIMER4_OVF_vect) 
{
    2dd4:	1f 92       	push	r1
    2dd6:	0f 92       	push	r0
    2dd8:	0f b6       	in	r0, 0x3f	; 63
    2dda:	0f 92       	push	r0
    2ddc:	11 24       	eor	r1, r1
    2dde:	2f 93       	push	r18
    2de0:	3f 93       	push	r19
    2de2:	4f 93       	push	r20
    2de4:	5f 93       	push	r21
    2de6:	6f 93       	push	r22
    2de8:	7f 93       	push	r23
    2dea:	8f 93       	push	r24
    2dec:	9f 93       	push	r25
    2dee:	af 93       	push	r26
    2df0:	bf 93       	push	r27
    2df2:	ef 93       	push	r30
    2df4:	ff 93       	push	r31
  timer4_ovrflow_cnt++;
    2df6:	80 91 02 18 	lds	r24, 0x1802
    2dfa:	90 91 03 18 	lds	r25, 0x1803
    2dfe:	a0 91 04 18 	lds	r26, 0x1804
    2e02:	b0 91 05 18 	lds	r27, 0x1805
    2e06:	01 96       	adiw	r24, 0x01	; 1
    2e08:	a1 1d       	adc	r26, r1
    2e0a:	b1 1d       	adc	r27, r1
    2e0c:	80 93 02 18 	sts	0x1802, r24
    2e10:	90 93 03 18 	sts	0x1803, r25
    2e14:	a0 93 04 18 	sts	0x1804, r26
    2e18:	b0 93 05 18 	sts	0x1805, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER4_OVF_interrupt);
    2e1c:	80 91 12 0f 	lds	r24, 0x0F12
    2e20:	90 91 13 0f 	lds	r25, 0x0F13
    2e24:	89 2b       	or	r24, r25
    2e26:	29 f0       	breq	.+10     	; 0x2e32 <__vector_45+0x5e>
    2e28:	e0 91 12 0f 	lds	r30, 0x0F12
    2e2c:	f0 91 13 0f 	lds	r31, 0x0F13
    2e30:	09 95       	icall
}
    2e32:	ff 91       	pop	r31
    2e34:	ef 91       	pop	r30
    2e36:	bf 91       	pop	r27
    2e38:	af 91       	pop	r26
    2e3a:	9f 91       	pop	r25
    2e3c:	8f 91       	pop	r24
    2e3e:	7f 91       	pop	r23
    2e40:	6f 91       	pop	r22
    2e42:	5f 91       	pop	r21
    2e44:	4f 91       	pop	r20
    2e46:	3f 91       	pop	r19
    2e48:	2f 91       	pop	r18
    2e4a:	0f 90       	pop	r0
    2e4c:	0f be       	out	0x3f, r0	; 63
    2e4e:	0f 90       	pop	r0
    2e50:	1f 90       	pop	r1
    2e52:	18 95       	reti

00002e54 <__vector_50>:
ISR(TIMER5_OVF_vect) 
{
    2e54:	1f 92       	push	r1
    2e56:	0f 92       	push	r0
    2e58:	0f b6       	in	r0, 0x3f	; 63
    2e5a:	0f 92       	push	r0
    2e5c:	11 24       	eor	r1, r1
    2e5e:	2f 93       	push	r18
    2e60:	3f 93       	push	r19
    2e62:	4f 93       	push	r20
    2e64:	5f 93       	push	r21
    2e66:	6f 93       	push	r22
    2e68:	7f 93       	push	r23
    2e6a:	8f 93       	push	r24
    2e6c:	9f 93       	push	r25
    2e6e:	af 93       	push	r26
    2e70:	bf 93       	push	r27
    2e72:	ef 93       	push	r30
    2e74:	ff 93       	push	r31
  timer5_ovrflow_cnt++;
    2e76:	80 91 1a 18 	lds	r24, 0x181A
    2e7a:	90 91 1b 18 	lds	r25, 0x181B
    2e7e:	a0 91 1c 18 	lds	r26, 0x181C
    2e82:	b0 91 1d 18 	lds	r27, 0x181D
    2e86:	01 96       	adiw	r24, 0x01	; 1
    2e88:	a1 1d       	adc	r26, r1
    2e8a:	b1 1d       	adc	r27, r1
    2e8c:	80 93 1a 18 	sts	0x181A, r24
    2e90:	90 93 1b 18 	sts	0x181B, r25
    2e94:	a0 93 1c 18 	sts	0x181C, r26
    2e98:	b0 93 1d 18 	sts	0x181D, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER5_OVF_interrupt);
    2e9c:	80 91 1c 0f 	lds	r24, 0x0F1C
    2ea0:	90 91 1d 0f 	lds	r25, 0x0F1D
    2ea4:	89 2b       	or	r24, r25
    2ea6:	29 f0       	breq	.+10     	; 0x2eb2 <__vector_50+0x5e>
    2ea8:	e0 91 1c 0f 	lds	r30, 0x0F1C
    2eac:	f0 91 1d 0f 	lds	r31, 0x0F1D
    2eb0:	09 95       	icall
}
    2eb2:	ff 91       	pop	r31
    2eb4:	ef 91       	pop	r30
    2eb6:	bf 91       	pop	r27
    2eb8:	af 91       	pop	r26
    2eba:	9f 91       	pop	r25
    2ebc:	8f 91       	pop	r24
    2ebe:	7f 91       	pop	r23
    2ec0:	6f 91       	pop	r22
    2ec2:	5f 91       	pop	r21
    2ec4:	4f 91       	pop	r20
    2ec6:	3f 91       	pop	r19
    2ec8:	2f 91       	pop	r18
    2eca:	0f 90       	pop	r0
    2ecc:	0f be       	out	0x3f, r0	; 63
    2ece:	0f 90       	pop	r0
    2ed0:	1f 90       	pop	r1
    2ed2:	18 95       	reti

00002ed4 <__vector_21>:
ISR(TIMER0_COMPA_vect)
{
    2ed4:	1f 92       	push	r1
    2ed6:	0f 92       	push	r0
    2ed8:	0f b6       	in	r0, 0x3f	; 63
    2eda:	0f 92       	push	r0
    2edc:	11 24       	eor	r1, r1
    2ede:	2f 93       	push	r18
    2ee0:	3f 93       	push	r19
    2ee2:	4f 93       	push	r20
    2ee4:	5f 93       	push	r21
    2ee6:	6f 93       	push	r22
    2ee8:	7f 93       	push	r23
    2eea:	8f 93       	push	r24
    2eec:	9f 93       	push	r25
    2eee:	af 93       	push	r26
    2ef0:	bf 93       	push	r27
    2ef2:	ef 93       	push	r30
    2ef4:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER0_COMPA_interrupt);
    2ef6:	80 91 ea 0e 	lds	r24, 0x0EEA
    2efa:	90 91 eb 0e 	lds	r25, 0x0EEB
    2efe:	89 2b       	or	r24, r25
    2f00:	29 f0       	breq	.+10     	; 0x2f0c <__vector_21+0x38>
    2f02:	e0 91 ea 0e 	lds	r30, 0x0EEA
    2f06:	f0 91 eb 0e 	lds	r31, 0x0EEB
    2f0a:	09 95       	icall
}
    2f0c:	ff 91       	pop	r31
    2f0e:	ef 91       	pop	r30
    2f10:	bf 91       	pop	r27
    2f12:	af 91       	pop	r26
    2f14:	9f 91       	pop	r25
    2f16:	8f 91       	pop	r24
    2f18:	7f 91       	pop	r23
    2f1a:	6f 91       	pop	r22
    2f1c:	5f 91       	pop	r21
    2f1e:	4f 91       	pop	r20
    2f20:	3f 91       	pop	r19
    2f22:	2f 91       	pop	r18
    2f24:	0f 90       	pop	r0
    2f26:	0f be       	out	0x3f, r0	; 63
    2f28:	0f 90       	pop	r0
    2f2a:	1f 90       	pop	r1
    2f2c:	18 95       	reti

00002f2e <__vector_22>:
ISR(TIMER0_COMPB_vect)
{
    2f2e:	1f 92       	push	r1
    2f30:	0f 92       	push	r0
    2f32:	0f b6       	in	r0, 0x3f	; 63
    2f34:	0f 92       	push	r0
    2f36:	11 24       	eor	r1, r1
    2f38:	2f 93       	push	r18
    2f3a:	3f 93       	push	r19
    2f3c:	4f 93       	push	r20
    2f3e:	5f 93       	push	r21
    2f40:	6f 93       	push	r22
    2f42:	7f 93       	push	r23
    2f44:	8f 93       	push	r24
    2f46:	9f 93       	push	r25
    2f48:	af 93       	push	r26
    2f4a:	bf 93       	push	r27
    2f4c:	ef 93       	push	r30
    2f4e:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER0_COMPB_interrupt);
    2f50:	80 91 ec 0e 	lds	r24, 0x0EEC
    2f54:	90 91 ed 0e 	lds	r25, 0x0EED
    2f58:	89 2b       	or	r24, r25
    2f5a:	29 f0       	breq	.+10     	; 0x2f66 <__vector_22+0x38>
    2f5c:	e0 91 ec 0e 	lds	r30, 0x0EEC
    2f60:	f0 91 ed 0e 	lds	r31, 0x0EED
    2f64:	09 95       	icall
}
    2f66:	ff 91       	pop	r31
    2f68:	ef 91       	pop	r30
    2f6a:	bf 91       	pop	r27
    2f6c:	af 91       	pop	r26
    2f6e:	9f 91       	pop	r25
    2f70:	8f 91       	pop	r24
    2f72:	7f 91       	pop	r23
    2f74:	6f 91       	pop	r22
    2f76:	5f 91       	pop	r21
    2f78:	4f 91       	pop	r20
    2f7a:	3f 91       	pop	r19
    2f7c:	2f 91       	pop	r18
    2f7e:	0f 90       	pop	r0
    2f80:	0f be       	out	0x3f, r0	; 63
    2f82:	0f 90       	pop	r0
    2f84:	1f 90       	pop	r1
    2f86:	18 95       	reti

00002f88 <__vector_16>:
ISR(TIMER1_CAPT_vect)
{
    2f88:	1f 92       	push	r1
    2f8a:	0f 92       	push	r0
    2f8c:	0f b6       	in	r0, 0x3f	; 63
    2f8e:	0f 92       	push	r0
    2f90:	11 24       	eor	r1, r1
    2f92:	2f 93       	push	r18
    2f94:	3f 93       	push	r19
    2f96:	4f 93       	push	r20
    2f98:	5f 93       	push	r21
    2f9a:	6f 93       	push	r22
    2f9c:	7f 93       	push	r23
    2f9e:	8f 93       	push	r24
    2fa0:	9f 93       	push	r25
    2fa2:	af 93       	push	r26
    2fa4:	bf 93       	push	r27
    2fa6:	ef 93       	push	r30
    2fa8:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER1_CAPT_interrupt);
    2faa:	80 91 f0 0e 	lds	r24, 0x0EF0
    2fae:	90 91 f1 0e 	lds	r25, 0x0EF1
    2fb2:	89 2b       	or	r24, r25
    2fb4:	29 f0       	breq	.+10     	; 0x2fc0 <__vector_16+0x38>
    2fb6:	e0 91 f0 0e 	lds	r30, 0x0EF0
    2fba:	f0 91 f1 0e 	lds	r31, 0x0EF1
    2fbe:	09 95       	icall
}
    2fc0:	ff 91       	pop	r31
    2fc2:	ef 91       	pop	r30
    2fc4:	bf 91       	pop	r27
    2fc6:	af 91       	pop	r26
    2fc8:	9f 91       	pop	r25
    2fca:	8f 91       	pop	r24
    2fcc:	7f 91       	pop	r23
    2fce:	6f 91       	pop	r22
    2fd0:	5f 91       	pop	r21
    2fd2:	4f 91       	pop	r20
    2fd4:	3f 91       	pop	r19
    2fd6:	2f 91       	pop	r18
    2fd8:	0f 90       	pop	r0
    2fda:	0f be       	out	0x3f, r0	; 63
    2fdc:	0f 90       	pop	r0
    2fde:	1f 90       	pop	r1
    2fe0:	18 95       	reti

00002fe2 <__vector_18>:
{
  RUN_USER_DEFINE_INTERRUPT(TIMER1_COMPA_interrupt);
}
*/
ISR(TIMER1_COMPB_vect)
{
    2fe2:	1f 92       	push	r1
    2fe4:	0f 92       	push	r0
    2fe6:	0f b6       	in	r0, 0x3f	; 63
    2fe8:	0f 92       	push	r0
    2fea:	11 24       	eor	r1, r1
    2fec:	2f 93       	push	r18
    2fee:	3f 93       	push	r19
    2ff0:	4f 93       	push	r20
    2ff2:	5f 93       	push	r21
    2ff4:	6f 93       	push	r22
    2ff6:	7f 93       	push	r23
    2ff8:	8f 93       	push	r24
    2ffa:	9f 93       	push	r25
    2ffc:	af 93       	push	r26
    2ffe:	bf 93       	push	r27
    3000:	ef 93       	push	r30
    3002:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER1_COMPB_interrupt);
    3004:	80 91 f4 0e 	lds	r24, 0x0EF4
    3008:	90 91 f5 0e 	lds	r25, 0x0EF5
    300c:	89 2b       	or	r24, r25
    300e:	29 f0       	breq	.+10     	; 0x301a <__vector_18+0x38>
    3010:	e0 91 f4 0e 	lds	r30, 0x0EF4
    3014:	f0 91 f5 0e 	lds	r31, 0x0EF5
    3018:	09 95       	icall
}
    301a:	ff 91       	pop	r31
    301c:	ef 91       	pop	r30
    301e:	bf 91       	pop	r27
    3020:	af 91       	pop	r26
    3022:	9f 91       	pop	r25
    3024:	8f 91       	pop	r24
    3026:	7f 91       	pop	r23
    3028:	6f 91       	pop	r22
    302a:	5f 91       	pop	r21
    302c:	4f 91       	pop	r20
    302e:	3f 91       	pop	r19
    3030:	2f 91       	pop	r18
    3032:	0f 90       	pop	r0
    3034:	0f be       	out	0x3f, r0	; 63
    3036:	0f 90       	pop	r0
    3038:	1f 90       	pop	r1
    303a:	18 95       	reti

0000303c <__vector_19>:
ISR(TIMER1_COMPC_vect)
{
    303c:	1f 92       	push	r1
    303e:	0f 92       	push	r0
    3040:	0f b6       	in	r0, 0x3f	; 63
    3042:	0f 92       	push	r0
    3044:	11 24       	eor	r1, r1
    3046:	2f 93       	push	r18
    3048:	3f 93       	push	r19
    304a:	4f 93       	push	r20
    304c:	5f 93       	push	r21
    304e:	6f 93       	push	r22
    3050:	7f 93       	push	r23
    3052:	8f 93       	push	r24
    3054:	9f 93       	push	r25
    3056:	af 93       	push	r26
    3058:	bf 93       	push	r27
    305a:	ef 93       	push	r30
    305c:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER1_COMPC_interrupt);
    305e:	80 91 f6 0e 	lds	r24, 0x0EF6
    3062:	90 91 f7 0e 	lds	r25, 0x0EF7
    3066:	89 2b       	or	r24, r25
    3068:	29 f0       	breq	.+10     	; 0x3074 <__vector_19+0x38>
    306a:	e0 91 f6 0e 	lds	r30, 0x0EF6
    306e:	f0 91 f7 0e 	lds	r31, 0x0EF7
    3072:	09 95       	icall
}
    3074:	ff 91       	pop	r31
    3076:	ef 91       	pop	r30
    3078:	bf 91       	pop	r27
    307a:	af 91       	pop	r26
    307c:	9f 91       	pop	r25
    307e:	8f 91       	pop	r24
    3080:	7f 91       	pop	r23
    3082:	6f 91       	pop	r22
    3084:	5f 91       	pop	r21
    3086:	4f 91       	pop	r20
    3088:	3f 91       	pop	r19
    308a:	2f 91       	pop	r18
    308c:	0f 90       	pop	r0
    308e:	0f be       	out	0x3f, r0	; 63
    3090:	0f 90       	pop	r0
    3092:	1f 90       	pop	r1
    3094:	18 95       	reti

00003096 <__vector_13>:
ISR(TIMER2_COMPA_vect)
{
    3096:	1f 92       	push	r1
    3098:	0f 92       	push	r0
    309a:	0f b6       	in	r0, 0x3f	; 63
    309c:	0f 92       	push	r0
    309e:	11 24       	eor	r1, r1
    30a0:	2f 93       	push	r18
    30a2:	3f 93       	push	r19
    30a4:	4f 93       	push	r20
    30a6:	5f 93       	push	r21
    30a8:	6f 93       	push	r22
    30aa:	7f 93       	push	r23
    30ac:	8f 93       	push	r24
    30ae:	9f 93       	push	r25
    30b0:	af 93       	push	r26
    30b2:	bf 93       	push	r27
    30b4:	ef 93       	push	r30
    30b6:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER2_COMPA_interrupt);
    30b8:	80 91 fa 0e 	lds	r24, 0x0EFA
    30bc:	90 91 fb 0e 	lds	r25, 0x0EFB
    30c0:	89 2b       	or	r24, r25
    30c2:	29 f0       	breq	.+10     	; 0x30ce <__vector_13+0x38>
    30c4:	e0 91 fa 0e 	lds	r30, 0x0EFA
    30c8:	f0 91 fb 0e 	lds	r31, 0x0EFB
    30cc:	09 95       	icall
}
    30ce:	ff 91       	pop	r31
    30d0:	ef 91       	pop	r30
    30d2:	bf 91       	pop	r27
    30d4:	af 91       	pop	r26
    30d6:	9f 91       	pop	r25
    30d8:	8f 91       	pop	r24
    30da:	7f 91       	pop	r23
    30dc:	6f 91       	pop	r22
    30de:	5f 91       	pop	r21
    30e0:	4f 91       	pop	r20
    30e2:	3f 91       	pop	r19
    30e4:	2f 91       	pop	r18
    30e6:	0f 90       	pop	r0
    30e8:	0f be       	out	0x3f, r0	; 63
    30ea:	0f 90       	pop	r0
    30ec:	1f 90       	pop	r1
    30ee:	18 95       	reti

000030f0 <__vector_14>:
ISR(TIMER2_COMPB_vect)
{
    30f0:	1f 92       	push	r1
    30f2:	0f 92       	push	r0
    30f4:	0f b6       	in	r0, 0x3f	; 63
    30f6:	0f 92       	push	r0
    30f8:	11 24       	eor	r1, r1
    30fa:	2f 93       	push	r18
    30fc:	3f 93       	push	r19
    30fe:	4f 93       	push	r20
    3100:	5f 93       	push	r21
    3102:	6f 93       	push	r22
    3104:	7f 93       	push	r23
    3106:	8f 93       	push	r24
    3108:	9f 93       	push	r25
    310a:	af 93       	push	r26
    310c:	bf 93       	push	r27
    310e:	ef 93       	push	r30
    3110:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER2_COMPB_interrupt);
    3112:	80 91 fc 0e 	lds	r24, 0x0EFC
    3116:	90 91 fd 0e 	lds	r25, 0x0EFD
    311a:	89 2b       	or	r24, r25
    311c:	29 f0       	breq	.+10     	; 0x3128 <__vector_14+0x38>
    311e:	e0 91 fc 0e 	lds	r30, 0x0EFC
    3122:	f0 91 fd 0e 	lds	r31, 0x0EFD
    3126:	09 95       	icall
}
    3128:	ff 91       	pop	r31
    312a:	ef 91       	pop	r30
    312c:	bf 91       	pop	r27
    312e:	af 91       	pop	r26
    3130:	9f 91       	pop	r25
    3132:	8f 91       	pop	r24
    3134:	7f 91       	pop	r23
    3136:	6f 91       	pop	r22
    3138:	5f 91       	pop	r21
    313a:	4f 91       	pop	r20
    313c:	3f 91       	pop	r19
    313e:	2f 91       	pop	r18
    3140:	0f 90       	pop	r0
    3142:	0f be       	out	0x3f, r0	; 63
    3144:	0f 90       	pop	r0
    3146:	1f 90       	pop	r1
    3148:	18 95       	reti

0000314a <__vector_31>:
ISR(TIMER3_CAPT_vect)
{
    314a:	1f 92       	push	r1
    314c:	0f 92       	push	r0
    314e:	0f b6       	in	r0, 0x3f	; 63
    3150:	0f 92       	push	r0
    3152:	11 24       	eor	r1, r1
    3154:	2f 93       	push	r18
    3156:	3f 93       	push	r19
    3158:	4f 93       	push	r20
    315a:	5f 93       	push	r21
    315c:	6f 93       	push	r22
    315e:	7f 93       	push	r23
    3160:	8f 93       	push	r24
    3162:	9f 93       	push	r25
    3164:	af 93       	push	r26
    3166:	bf 93       	push	r27
    3168:	ef 93       	push	r30
    316a:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_CAPT_interrupt);
    316c:	80 91 00 0f 	lds	r24, 0x0F00
    3170:	90 91 01 0f 	lds	r25, 0x0F01
    3174:	89 2b       	or	r24, r25
    3176:	29 f0       	breq	.+10     	; 0x3182 <__vector_31+0x38>
    3178:	e0 91 00 0f 	lds	r30, 0x0F00
    317c:	f0 91 01 0f 	lds	r31, 0x0F01
    3180:	09 95       	icall
}
    3182:	ff 91       	pop	r31
    3184:	ef 91       	pop	r30
    3186:	bf 91       	pop	r27
    3188:	af 91       	pop	r26
    318a:	9f 91       	pop	r25
    318c:	8f 91       	pop	r24
    318e:	7f 91       	pop	r23
    3190:	6f 91       	pop	r22
    3192:	5f 91       	pop	r21
    3194:	4f 91       	pop	r20
    3196:	3f 91       	pop	r19
    3198:	2f 91       	pop	r18
    319a:	0f 90       	pop	r0
    319c:	0f be       	out	0x3f, r0	; 63
    319e:	0f 90       	pop	r0
    31a0:	1f 90       	pop	r1
    31a2:	18 95       	reti

000031a4 <__vector_32>:
ISR(TIMER3_COMPA_vect)
{
    31a4:	1f 92       	push	r1
    31a6:	0f 92       	push	r0
    31a8:	0f b6       	in	r0, 0x3f	; 63
    31aa:	0f 92       	push	r0
    31ac:	11 24       	eor	r1, r1
    31ae:	2f 93       	push	r18
    31b0:	3f 93       	push	r19
    31b2:	4f 93       	push	r20
    31b4:	5f 93       	push	r21
    31b6:	6f 93       	push	r22
    31b8:	7f 93       	push	r23
    31ba:	8f 93       	push	r24
    31bc:	9f 93       	push	r25
    31be:	af 93       	push	r26
    31c0:	bf 93       	push	r27
    31c2:	ef 93       	push	r30
    31c4:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_COMPA_interrupt);
    31c6:	80 91 02 0f 	lds	r24, 0x0F02
    31ca:	90 91 03 0f 	lds	r25, 0x0F03
    31ce:	89 2b       	or	r24, r25
    31d0:	29 f0       	breq	.+10     	; 0x31dc <__vector_32+0x38>
    31d2:	e0 91 02 0f 	lds	r30, 0x0F02
    31d6:	f0 91 03 0f 	lds	r31, 0x0F03
    31da:	09 95       	icall
}
    31dc:	ff 91       	pop	r31
    31de:	ef 91       	pop	r30
    31e0:	bf 91       	pop	r27
    31e2:	af 91       	pop	r26
    31e4:	9f 91       	pop	r25
    31e6:	8f 91       	pop	r24
    31e8:	7f 91       	pop	r23
    31ea:	6f 91       	pop	r22
    31ec:	5f 91       	pop	r21
    31ee:	4f 91       	pop	r20
    31f0:	3f 91       	pop	r19
    31f2:	2f 91       	pop	r18
    31f4:	0f 90       	pop	r0
    31f6:	0f be       	out	0x3f, r0	; 63
    31f8:	0f 90       	pop	r0
    31fa:	1f 90       	pop	r1
    31fc:	18 95       	reti

000031fe <__vector_33>:
ISR(TIMER3_COMPB_vect)
{
    31fe:	1f 92       	push	r1
    3200:	0f 92       	push	r0
    3202:	0f b6       	in	r0, 0x3f	; 63
    3204:	0f 92       	push	r0
    3206:	11 24       	eor	r1, r1
    3208:	2f 93       	push	r18
    320a:	3f 93       	push	r19
    320c:	4f 93       	push	r20
    320e:	5f 93       	push	r21
    3210:	6f 93       	push	r22
    3212:	7f 93       	push	r23
    3214:	8f 93       	push	r24
    3216:	9f 93       	push	r25
    3218:	af 93       	push	r26
    321a:	bf 93       	push	r27
    321c:	ef 93       	push	r30
    321e:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_COMPB_interrupt);
    3220:	80 91 04 0f 	lds	r24, 0x0F04
    3224:	90 91 05 0f 	lds	r25, 0x0F05
    3228:	89 2b       	or	r24, r25
    322a:	29 f0       	breq	.+10     	; 0x3236 <__vector_33+0x38>
    322c:	e0 91 04 0f 	lds	r30, 0x0F04
    3230:	f0 91 05 0f 	lds	r31, 0x0F05
    3234:	09 95       	icall
}
    3236:	ff 91       	pop	r31
    3238:	ef 91       	pop	r30
    323a:	bf 91       	pop	r27
    323c:	af 91       	pop	r26
    323e:	9f 91       	pop	r25
    3240:	8f 91       	pop	r24
    3242:	7f 91       	pop	r23
    3244:	6f 91       	pop	r22
    3246:	5f 91       	pop	r21
    3248:	4f 91       	pop	r20
    324a:	3f 91       	pop	r19
    324c:	2f 91       	pop	r18
    324e:	0f 90       	pop	r0
    3250:	0f be       	out	0x3f, r0	; 63
    3252:	0f 90       	pop	r0
    3254:	1f 90       	pop	r1
    3256:	18 95       	reti

00003258 <__vector_34>:
ISR(TIMER3_COMPC_vect)
{
    3258:	1f 92       	push	r1
    325a:	0f 92       	push	r0
    325c:	0f b6       	in	r0, 0x3f	; 63
    325e:	0f 92       	push	r0
    3260:	11 24       	eor	r1, r1
    3262:	2f 93       	push	r18
    3264:	3f 93       	push	r19
    3266:	4f 93       	push	r20
    3268:	5f 93       	push	r21
    326a:	6f 93       	push	r22
    326c:	7f 93       	push	r23
    326e:	8f 93       	push	r24
    3270:	9f 93       	push	r25
    3272:	af 93       	push	r26
    3274:	bf 93       	push	r27
    3276:	ef 93       	push	r30
    3278:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_COMPC_interrupt);
    327a:	80 91 06 0f 	lds	r24, 0x0F06
    327e:	90 91 07 0f 	lds	r25, 0x0F07
    3282:	89 2b       	or	r24, r25
    3284:	29 f0       	breq	.+10     	; 0x3290 <__vector_34+0x38>
    3286:	e0 91 06 0f 	lds	r30, 0x0F06
    328a:	f0 91 07 0f 	lds	r31, 0x0F07
    328e:	09 95       	icall
}
    3290:	ff 91       	pop	r31
    3292:	ef 91       	pop	r30
    3294:	bf 91       	pop	r27
    3296:	af 91       	pop	r26
    3298:	9f 91       	pop	r25
    329a:	8f 91       	pop	r24
    329c:	7f 91       	pop	r23
    329e:	6f 91       	pop	r22
    32a0:	5f 91       	pop	r21
    32a2:	4f 91       	pop	r20
    32a4:	3f 91       	pop	r19
    32a6:	2f 91       	pop	r18
    32a8:	0f 90       	pop	r0
    32aa:	0f be       	out	0x3f, r0	; 63
    32ac:	0f 90       	pop	r0
    32ae:	1f 90       	pop	r1
    32b0:	18 95       	reti

000032b2 <__vector_41>:
ISR(TIMER4_CAPT_vect)
{
    32b2:	1f 92       	push	r1
    32b4:	0f 92       	push	r0
    32b6:	0f b6       	in	r0, 0x3f	; 63
    32b8:	0f 92       	push	r0
    32ba:	11 24       	eor	r1, r1
    32bc:	2f 93       	push	r18
    32be:	3f 93       	push	r19
    32c0:	4f 93       	push	r20
    32c2:	5f 93       	push	r21
    32c4:	6f 93       	push	r22
    32c6:	7f 93       	push	r23
    32c8:	8f 93       	push	r24
    32ca:	9f 93       	push	r25
    32cc:	af 93       	push	r26
    32ce:	bf 93       	push	r27
    32d0:	ef 93       	push	r30
    32d2:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_CAPT_interrupt);
    32d4:	80 91 0a 0f 	lds	r24, 0x0F0A
    32d8:	90 91 0b 0f 	lds	r25, 0x0F0B
    32dc:	89 2b       	or	r24, r25
    32de:	29 f0       	breq	.+10     	; 0x32ea <__vector_41+0x38>
    32e0:	e0 91 0a 0f 	lds	r30, 0x0F0A
    32e4:	f0 91 0b 0f 	lds	r31, 0x0F0B
    32e8:	09 95       	icall
}
    32ea:	ff 91       	pop	r31
    32ec:	ef 91       	pop	r30
    32ee:	bf 91       	pop	r27
    32f0:	af 91       	pop	r26
    32f2:	9f 91       	pop	r25
    32f4:	8f 91       	pop	r24
    32f6:	7f 91       	pop	r23
    32f8:	6f 91       	pop	r22
    32fa:	5f 91       	pop	r21
    32fc:	4f 91       	pop	r20
    32fe:	3f 91       	pop	r19
    3300:	2f 91       	pop	r18
    3302:	0f 90       	pop	r0
    3304:	0f be       	out	0x3f, r0	; 63
    3306:	0f 90       	pop	r0
    3308:	1f 90       	pop	r1
    330a:	18 95       	reti

0000330c <__vector_42>:
ISR(TIMER4_COMPA_vect)
{
    330c:	1f 92       	push	r1
    330e:	0f 92       	push	r0
    3310:	0f b6       	in	r0, 0x3f	; 63
    3312:	0f 92       	push	r0
    3314:	11 24       	eor	r1, r1
    3316:	2f 93       	push	r18
    3318:	3f 93       	push	r19
    331a:	4f 93       	push	r20
    331c:	5f 93       	push	r21
    331e:	6f 93       	push	r22
    3320:	7f 93       	push	r23
    3322:	8f 93       	push	r24
    3324:	9f 93       	push	r25
    3326:	af 93       	push	r26
    3328:	bf 93       	push	r27
    332a:	ef 93       	push	r30
    332c:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_COMPA_interrupt);
    332e:	80 91 0c 0f 	lds	r24, 0x0F0C
    3332:	90 91 0d 0f 	lds	r25, 0x0F0D
    3336:	89 2b       	or	r24, r25
    3338:	29 f0       	breq	.+10     	; 0x3344 <__vector_42+0x38>
    333a:	e0 91 0c 0f 	lds	r30, 0x0F0C
    333e:	f0 91 0d 0f 	lds	r31, 0x0F0D
    3342:	09 95       	icall
}
    3344:	ff 91       	pop	r31
    3346:	ef 91       	pop	r30
    3348:	bf 91       	pop	r27
    334a:	af 91       	pop	r26
    334c:	9f 91       	pop	r25
    334e:	8f 91       	pop	r24
    3350:	7f 91       	pop	r23
    3352:	6f 91       	pop	r22
    3354:	5f 91       	pop	r21
    3356:	4f 91       	pop	r20
    3358:	3f 91       	pop	r19
    335a:	2f 91       	pop	r18
    335c:	0f 90       	pop	r0
    335e:	0f be       	out	0x3f, r0	; 63
    3360:	0f 90       	pop	r0
    3362:	1f 90       	pop	r1
    3364:	18 95       	reti

00003366 <__vector_43>:
ISR(TIMER4_COMPB_vect)
{
    3366:	1f 92       	push	r1
    3368:	0f 92       	push	r0
    336a:	0f b6       	in	r0, 0x3f	; 63
    336c:	0f 92       	push	r0
    336e:	11 24       	eor	r1, r1
    3370:	2f 93       	push	r18
    3372:	3f 93       	push	r19
    3374:	4f 93       	push	r20
    3376:	5f 93       	push	r21
    3378:	6f 93       	push	r22
    337a:	7f 93       	push	r23
    337c:	8f 93       	push	r24
    337e:	9f 93       	push	r25
    3380:	af 93       	push	r26
    3382:	bf 93       	push	r27
    3384:	ef 93       	push	r30
    3386:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_COMPB_interrupt);
    3388:	80 91 0e 0f 	lds	r24, 0x0F0E
    338c:	90 91 0f 0f 	lds	r25, 0x0F0F
    3390:	89 2b       	or	r24, r25
    3392:	29 f0       	breq	.+10     	; 0x339e <__vector_43+0x38>
    3394:	e0 91 0e 0f 	lds	r30, 0x0F0E
    3398:	f0 91 0f 0f 	lds	r31, 0x0F0F
    339c:	09 95       	icall
}
    339e:	ff 91       	pop	r31
    33a0:	ef 91       	pop	r30
    33a2:	bf 91       	pop	r27
    33a4:	af 91       	pop	r26
    33a6:	9f 91       	pop	r25
    33a8:	8f 91       	pop	r24
    33aa:	7f 91       	pop	r23
    33ac:	6f 91       	pop	r22
    33ae:	5f 91       	pop	r21
    33b0:	4f 91       	pop	r20
    33b2:	3f 91       	pop	r19
    33b4:	2f 91       	pop	r18
    33b6:	0f 90       	pop	r0
    33b8:	0f be       	out	0x3f, r0	; 63
    33ba:	0f 90       	pop	r0
    33bc:	1f 90       	pop	r1
    33be:	18 95       	reti

000033c0 <__vector_44>:
ISR(TIMER4_COMPC_vect)
{
    33c0:	1f 92       	push	r1
    33c2:	0f 92       	push	r0
    33c4:	0f b6       	in	r0, 0x3f	; 63
    33c6:	0f 92       	push	r0
    33c8:	11 24       	eor	r1, r1
    33ca:	2f 93       	push	r18
    33cc:	3f 93       	push	r19
    33ce:	4f 93       	push	r20
    33d0:	5f 93       	push	r21
    33d2:	6f 93       	push	r22
    33d4:	7f 93       	push	r23
    33d6:	8f 93       	push	r24
    33d8:	9f 93       	push	r25
    33da:	af 93       	push	r26
    33dc:	bf 93       	push	r27
    33de:	ef 93       	push	r30
    33e0:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_COMPC_interrupt);
    33e2:	80 91 10 0f 	lds	r24, 0x0F10
    33e6:	90 91 11 0f 	lds	r25, 0x0F11
    33ea:	89 2b       	or	r24, r25
    33ec:	29 f0       	breq	.+10     	; 0x33f8 <__vector_44+0x38>
    33ee:	e0 91 10 0f 	lds	r30, 0x0F10
    33f2:	f0 91 11 0f 	lds	r31, 0x0F11
    33f6:	09 95       	icall
}
    33f8:	ff 91       	pop	r31
    33fa:	ef 91       	pop	r30
    33fc:	bf 91       	pop	r27
    33fe:	af 91       	pop	r26
    3400:	9f 91       	pop	r25
    3402:	8f 91       	pop	r24
    3404:	7f 91       	pop	r23
    3406:	6f 91       	pop	r22
    3408:	5f 91       	pop	r21
    340a:	4f 91       	pop	r20
    340c:	3f 91       	pop	r19
    340e:	2f 91       	pop	r18
    3410:	0f 90       	pop	r0
    3412:	0f be       	out	0x3f, r0	; 63
    3414:	0f 90       	pop	r0
    3416:	1f 90       	pop	r1
    3418:	18 95       	reti

0000341a <__vector_46>:
ISR(TIMER5_CAPT_vect)
{
    341a:	1f 92       	push	r1
    341c:	0f 92       	push	r0
    341e:	0f b6       	in	r0, 0x3f	; 63
    3420:	0f 92       	push	r0
    3422:	11 24       	eor	r1, r1
    3424:	2f 93       	push	r18
    3426:	3f 93       	push	r19
    3428:	4f 93       	push	r20
    342a:	5f 93       	push	r21
    342c:	6f 93       	push	r22
    342e:	7f 93       	push	r23
    3430:	8f 93       	push	r24
    3432:	9f 93       	push	r25
    3434:	af 93       	push	r26
    3436:	bf 93       	push	r27
    3438:	ef 93       	push	r30
    343a:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_CAPT_interrupt);
    343c:	80 91 14 0f 	lds	r24, 0x0F14
    3440:	90 91 15 0f 	lds	r25, 0x0F15
    3444:	89 2b       	or	r24, r25
    3446:	29 f0       	breq	.+10     	; 0x3452 <__vector_46+0x38>
    3448:	e0 91 14 0f 	lds	r30, 0x0F14
    344c:	f0 91 15 0f 	lds	r31, 0x0F15
    3450:	09 95       	icall
}
    3452:	ff 91       	pop	r31
    3454:	ef 91       	pop	r30
    3456:	bf 91       	pop	r27
    3458:	af 91       	pop	r26
    345a:	9f 91       	pop	r25
    345c:	8f 91       	pop	r24
    345e:	7f 91       	pop	r23
    3460:	6f 91       	pop	r22
    3462:	5f 91       	pop	r21
    3464:	4f 91       	pop	r20
    3466:	3f 91       	pop	r19
    3468:	2f 91       	pop	r18
    346a:	0f 90       	pop	r0
    346c:	0f be       	out	0x3f, r0	; 63
    346e:	0f 90       	pop	r0
    3470:	1f 90       	pop	r1
    3472:	18 95       	reti

00003474 <__vector_47>:
ISR(TIMER5_COMPA_vect)
{
    3474:	1f 92       	push	r1
    3476:	0f 92       	push	r0
    3478:	0f b6       	in	r0, 0x3f	; 63
    347a:	0f 92       	push	r0
    347c:	11 24       	eor	r1, r1
    347e:	2f 93       	push	r18
    3480:	3f 93       	push	r19
    3482:	4f 93       	push	r20
    3484:	5f 93       	push	r21
    3486:	6f 93       	push	r22
    3488:	7f 93       	push	r23
    348a:	8f 93       	push	r24
    348c:	9f 93       	push	r25
    348e:	af 93       	push	r26
    3490:	bf 93       	push	r27
    3492:	ef 93       	push	r30
    3494:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_COMPA_interrupt);
    3496:	80 91 16 0f 	lds	r24, 0x0F16
    349a:	90 91 17 0f 	lds	r25, 0x0F17
    349e:	89 2b       	or	r24, r25
    34a0:	29 f0       	breq	.+10     	; 0x34ac <__vector_47+0x38>
    34a2:	e0 91 16 0f 	lds	r30, 0x0F16
    34a6:	f0 91 17 0f 	lds	r31, 0x0F17
    34aa:	09 95       	icall
}
    34ac:	ff 91       	pop	r31
    34ae:	ef 91       	pop	r30
    34b0:	bf 91       	pop	r27
    34b2:	af 91       	pop	r26
    34b4:	9f 91       	pop	r25
    34b6:	8f 91       	pop	r24
    34b8:	7f 91       	pop	r23
    34ba:	6f 91       	pop	r22
    34bc:	5f 91       	pop	r21
    34be:	4f 91       	pop	r20
    34c0:	3f 91       	pop	r19
    34c2:	2f 91       	pop	r18
    34c4:	0f 90       	pop	r0
    34c6:	0f be       	out	0x3f, r0	; 63
    34c8:	0f 90       	pop	r0
    34ca:	1f 90       	pop	r1
    34cc:	18 95       	reti

000034ce <__vector_48>:
ISR(TIMER5_COMPB_vect)
{
    34ce:	1f 92       	push	r1
    34d0:	0f 92       	push	r0
    34d2:	0f b6       	in	r0, 0x3f	; 63
    34d4:	0f 92       	push	r0
    34d6:	11 24       	eor	r1, r1
    34d8:	2f 93       	push	r18
    34da:	3f 93       	push	r19
    34dc:	4f 93       	push	r20
    34de:	5f 93       	push	r21
    34e0:	6f 93       	push	r22
    34e2:	7f 93       	push	r23
    34e4:	8f 93       	push	r24
    34e6:	9f 93       	push	r25
    34e8:	af 93       	push	r26
    34ea:	bf 93       	push	r27
    34ec:	ef 93       	push	r30
    34ee:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_COMPB_interrupt);
    34f0:	80 91 18 0f 	lds	r24, 0x0F18
    34f4:	90 91 19 0f 	lds	r25, 0x0F19
    34f8:	89 2b       	or	r24, r25
    34fa:	29 f0       	breq	.+10     	; 0x3506 <__vector_48+0x38>
    34fc:	e0 91 18 0f 	lds	r30, 0x0F18
    3500:	f0 91 19 0f 	lds	r31, 0x0F19
    3504:	09 95       	icall
}
    3506:	ff 91       	pop	r31
    3508:	ef 91       	pop	r30
    350a:	bf 91       	pop	r27
    350c:	af 91       	pop	r26
    350e:	9f 91       	pop	r25
    3510:	8f 91       	pop	r24
    3512:	7f 91       	pop	r23
    3514:	6f 91       	pop	r22
    3516:	5f 91       	pop	r21
    3518:	4f 91       	pop	r20
    351a:	3f 91       	pop	r19
    351c:	2f 91       	pop	r18
    351e:	0f 90       	pop	r0
    3520:	0f be       	out	0x3f, r0	; 63
    3522:	0f 90       	pop	r0
    3524:	1f 90       	pop	r1
    3526:	18 95       	reti

00003528 <__vector_49>:
ISR(TIMER5_COMPC_vect)
{
    3528:	1f 92       	push	r1
    352a:	0f 92       	push	r0
    352c:	0f b6       	in	r0, 0x3f	; 63
    352e:	0f 92       	push	r0
    3530:	11 24       	eor	r1, r1
    3532:	2f 93       	push	r18
    3534:	3f 93       	push	r19
    3536:	4f 93       	push	r20
    3538:	5f 93       	push	r21
    353a:	6f 93       	push	r22
    353c:	7f 93       	push	r23
    353e:	8f 93       	push	r24
    3540:	9f 93       	push	r25
    3542:	af 93       	push	r26
    3544:	bf 93       	push	r27
    3546:	ef 93       	push	r30
    3548:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_COMPC_interrupt);
    354a:	80 91 1a 0f 	lds	r24, 0x0F1A
    354e:	90 91 1b 0f 	lds	r25, 0x0F1B
    3552:	89 2b       	or	r24, r25
    3554:	29 f0       	breq	.+10     	; 0x3560 <__vector_49+0x38>
    3556:	e0 91 1a 0f 	lds	r30, 0x0F1A
    355a:	f0 91 1b 0f 	lds	r31, 0x0F1B
    355e:	09 95       	icall
}
    3560:	ff 91       	pop	r31
    3562:	ef 91       	pop	r30
    3564:	bf 91       	pop	r27
    3566:	af 91       	pop	r26
    3568:	9f 91       	pop	r25
    356a:	8f 91       	pop	r24
    356c:	7f 91       	pop	r23
    356e:	6f 91       	pop	r22
    3570:	5f 91       	pop	r21
    3572:	4f 91       	pop	r20
    3574:	3f 91       	pop	r19
    3576:	2f 91       	pop	r18
    3578:	0f 90       	pop	r0
    357a:	0f be       	out	0x3f, r0	; 63
    357c:	0f 90       	pop	r0
    357e:	1f 90       	pop	r1
    3580:	18 95       	reti

00003582 <__vector_default>:

ISR(BADISR_vect)
{
    3582:	1f 92       	push	r1
    3584:	0f 92       	push	r0
    3586:	0f b6       	in	r0, 0x3f	; 63
    3588:	0f 92       	push	r0
    358a:	11 24       	eor	r1, r1
    358c:	2f 93       	push	r18
    358e:	3f 93       	push	r19
    3590:	4f 93       	push	r20
    3592:	5f 93       	push	r21
    3594:	6f 93       	push	r22
    3596:	7f 93       	push	r23
    3598:	8f 93       	push	r24
    359a:	9f 93       	push	r25
    359c:	af 93       	push	r26
    359e:	bf 93       	push	r27
    35a0:	ef 93       	push	r30
    35a2:	ff 93       	push	r31
  rprintf("BAD_vect called!");
    35a4:	00 d0       	rcall	.+0      	; 0x35a6 <__vector_default+0x24>
    35a6:	0f 92       	push	r0
    35a8:	81 e0       	ldi	r24, 0x01	; 1
    35aa:	ed b7       	in	r30, 0x3d	; 61
    35ac:	fe b7       	in	r31, 0x3e	; 62
    35ae:	81 83       	std	Z+1, r24	; 0x01
    35b0:	8d e7       	ldi	r24, 0x7D	; 125
    35b2:	91 e0       	ldi	r25, 0x01	; 1
    35b4:	93 83       	std	Z+3, r25	; 0x03
    35b6:	82 83       	std	Z+2, r24	; 0x02
    35b8:	0e 94 8b 22 	call	0x4516	; 0x4516 <rprintf1RamRom>
    35bc:	0f 90       	pop	r0
    35be:	0f 90       	pop	r0
    35c0:	0f 90       	pop	r0
}
    35c2:	ff 91       	pop	r31
    35c4:	ef 91       	pop	r30
    35c6:	bf 91       	pop	r27
    35c8:	af 91       	pop	r26
    35ca:	9f 91       	pop	r25
    35cc:	8f 91       	pop	r24
    35ce:	7f 91       	pop	r23
    35d0:	6f 91       	pop	r22
    35d2:	5f 91       	pop	r21
    35d4:	4f 91       	pop	r20
    35d6:	3f 91       	pop	r19
    35d8:	2f 91       	pop	r18
    35da:	0f 90       	pop	r0
    35dc:	0f be       	out	0x3f, r0	; 63
    35de:	0f 90       	pop	r0
    35e0:	1f 90       	pop	r1
    35e2:	18 95       	reti

000035e4 <uartSetRxHandler>:
}

void uartSetRxHandler(u08 nUart, void (*rx_func)(unsigned char c))
{
	// make sure the uart number is within bounds
	if(nUart < 4)
    35e4:	84 30       	cpi	r24, 0x04	; 4
    35e6:	40 f4       	brcc	.+16     	; 0x35f8 <uartSetRxHandler+0x14>
	{
		// set the receive interrupt to run the supplied user function
		UartRxFunc[nUart] = rx_func;
    35e8:	e8 2f       	mov	r30, r24
    35ea:	f0 e0       	ldi	r31, 0x00	; 0
    35ec:	ee 0f       	add	r30, r30
    35ee:	ff 1f       	adc	r31, r31
    35f0:	e2 5a       	subi	r30, 0xA2	; 162
    35f2:	fe 4e       	sbci	r31, 0xEE	; 238
    35f4:	71 83       	std	Z+1, r23	; 0x01
    35f6:	60 83       	st	Z, r22
    35f8:	08 95       	ret

000035fa <uartSetBaudRate>:
	}
}

void uartSetBaudRate(u08 nUart, u32 baudrate)
{
    35fa:	1f 93       	push	r17
    35fc:	18 2f       	mov	r17, r24
    35fe:	9a 01       	movw	r18, r20
    3600:	ab 01       	movw	r20, r22
	// calculate division factor for requested baud rate, and set it
	u16 bauddiv = ((F_CPU+(baudrate*8L))/(baudrate*16L)-1);
    3602:	ca 01       	movw	r24, r20
    3604:	b9 01       	movw	r22, r18
    3606:	60 58       	subi	r22, 0x80	; 128
    3608:	7b 47       	sbci	r23, 0x7B	; 123
    360a:	81 4e       	sbci	r24, 0xE1	; 225
    360c:	9f 4f       	sbci	r25, 0xFF	; 255
    360e:	f3 e0       	ldi	r31, 0x03	; 3
    3610:	66 0f       	add	r22, r22
    3612:	77 1f       	adc	r23, r23
    3614:	88 1f       	adc	r24, r24
    3616:	99 1f       	adc	r25, r25
    3618:	fa 95       	dec	r31
    361a:	d1 f7       	brne	.-12     	; 0x3610 <uartSetBaudRate+0x16>
    361c:	e4 e0       	ldi	r30, 0x04	; 4
    361e:	22 0f       	add	r18, r18
    3620:	33 1f       	adc	r19, r19
    3622:	44 1f       	adc	r20, r20
    3624:	55 1f       	adc	r21, r21
    3626:	ea 95       	dec	r30
    3628:	d1 f7       	brne	.-12     	; 0x361e <uartSetBaudRate+0x24>
    362a:	0e 94 01 28 	call	0x5002	; 0x5002 <__udivmodsi4>
    362e:	21 50       	subi	r18, 0x01	; 1
    3630:	30 40       	sbci	r19, 0x00	; 0
	if(nUart==3)
    3632:	13 30       	cpi	r17, 0x03	; 3
    3634:	29 f4       	brne	.+10     	; 0x3640 <uartSetBaudRate+0x46>
	{
		outb(UBRR3L, bauddiv);
    3636:	20 93 34 01 	sts	0x0134, r18
		#ifdef UBRR3H
		outb(UBRR3H, bauddiv>>8);
    363a:	30 93 35 01 	sts	0x0135, r19
    363e:	12 c0       	rjmp	.+36     	; 0x3664 <uartSetBaudRate+0x6a>
		#endif
	}
	else if(nUart==2)
    3640:	12 30       	cpi	r17, 0x02	; 2
    3642:	29 f4       	brne	.+10     	; 0x364e <uartSetBaudRate+0x54>
	{
		outb(UBRR2L, bauddiv);
    3644:	20 93 d4 00 	sts	0x00D4, r18
		#ifdef UBRR2H
		outb(UBRR2H, bauddiv>>8);
    3648:	30 93 d5 00 	sts	0x00D5, r19
    364c:	0b c0       	rjmp	.+22     	; 0x3664 <uartSetBaudRate+0x6a>
		#endif
	}
	else if(nUart==1)
    364e:	11 30       	cpi	r17, 0x01	; 1
    3650:	29 f4       	brne	.+10     	; 0x365c <uartSetBaudRate+0x62>
	{
		outb(UBRR1L, bauddiv);
    3652:	20 93 cc 00 	sts	0x00CC, r18
		#ifdef UBRR1H
		outb(UBRR1H, bauddiv>>8);
    3656:	30 93 cd 00 	sts	0x00CD, r19
    365a:	04 c0       	rjmp	.+8      	; 0x3664 <uartSetBaudRate+0x6a>
		#endif
	}
	else
	{
		outb(UBRR0L, bauddiv);
    365c:	20 93 c4 00 	sts	0x00C4, r18
		#ifdef UBRR0H
		outb(UBRR0H, bauddiv>>8);
    3660:	30 93 c5 00 	sts	0x00C5, r19
		#endif
	}
}
    3664:	1f 91       	pop	r17
    3666:	08 95       	ret

00003668 <uartGetRxBuffer>:

cBuffer* uartGetRxBuffer(u08 nUart)
{
    3668:	28 2f       	mov	r18, r24
    366a:	30 e0       	ldi	r19, 0x00	; 0
    366c:	a3 e0       	ldi	r26, 0x03	; 3
    366e:	22 0f       	add	r18, r18
    3670:	33 1f       	adc	r19, r19
    3672:	aa 95       	dec	r26
    3674:	e1 f7       	brne	.-8      	; 0x366e <uartGetRxBuffer+0x6>
    3676:	2e 5d       	subi	r18, 0xDE	; 222
    3678:	37 4e       	sbci	r19, 0xE7	; 231
	// return rx buffer pointer
	return &uartRxBuffer[nUart];
}
    367a:	c9 01       	movw	r24, r18
    367c:	08 95       	ret

0000367e <uartGetTxBuffer>:

cBuffer* uartGetTxBuffer(u08 nUart)
{
    367e:	28 2f       	mov	r18, r24
    3680:	30 e0       	ldi	r19, 0x00	; 0
    3682:	b3 e0       	ldi	r27, 0x03	; 3
    3684:	22 0f       	add	r18, r18
    3686:	33 1f       	adc	r19, r19
    3688:	ba 95       	dec	r27
    368a:	e1 f7       	brne	.-8      	; 0x3684 <uartGetTxBuffer+0x6>
    368c:	2a 5b       	subi	r18, 0xBA	; 186
    368e:	37 4e       	sbci	r19, 0xE7	; 231
	// return tx buffer pointer
	return &uartTxBuffer[nUart];
}
    3690:	c9 01       	movw	r24, r18
    3692:	08 95       	ret

00003694 <uartSendByte>:

void uartSendByte(u08 nUart, u08 txData)
{
    3694:	e8 2f       	mov	r30, r24
	// wait for the transmitter to be ready
//	while(!uartReadyTx[nUart]);
	// send byte
	if(nUart==3)
    3696:	83 30       	cpi	r24, 0x03	; 3
    3698:	39 f4       	brne	.+14     	; 0x36a8 <uartSendByte+0x14>
	{
		while(!(UCSR3A & (1<<UDRE3)));
    369a:	80 91 30 01 	lds	r24, 0x0130
    369e:	85 ff       	sbrs	r24, 5
    36a0:	fc cf       	rjmp	.-8      	; 0x369a <uartSendByte+0x6>
		outb(UDR3, txData);
    36a2:	60 93 36 01 	sts	0x0136, r22
    36a6:	18 c0       	rjmp	.+48     	; 0x36d8 <uartSendByte+0x44>
	}
	else if(nUart==2)
    36a8:	82 30       	cpi	r24, 0x02	; 2
    36aa:	39 f4       	brne	.+14     	; 0x36ba <uartSendByte+0x26>
	{
		while(!(UCSR2A & (1<<UDRE2)));
    36ac:	80 91 d0 00 	lds	r24, 0x00D0
    36b0:	85 ff       	sbrs	r24, 5
    36b2:	fc cf       	rjmp	.-8      	; 0x36ac <uartSendByte+0x18>
		outb(UDR2, txData);
    36b4:	60 93 d6 00 	sts	0x00D6, r22
    36b8:	0f c0       	rjmp	.+30     	; 0x36d8 <uartSendByte+0x44>
	}
	else if(nUart==1)
    36ba:	81 30       	cpi	r24, 0x01	; 1
    36bc:	39 f4       	brne	.+14     	; 0x36cc <uartSendByte+0x38>
	{
		while(!(UCSR1A & (1<<UDRE1)));
    36be:	80 91 c8 00 	lds	r24, 0x00C8
    36c2:	85 ff       	sbrs	r24, 5
    36c4:	fc cf       	rjmp	.-8      	; 0x36be <uartSendByte+0x2a>
		outb(UDR1, txData);
    36c6:	60 93 ce 00 	sts	0x00CE, r22
    36ca:	06 c0       	rjmp	.+12     	; 0x36d8 <uartSendByte+0x44>
	}
	else
	{
		while(!(UCSR0A & (1<<UDRE0)));
    36cc:	80 91 c0 00 	lds	r24, 0x00C0
    36d0:	85 ff       	sbrs	r24, 5
    36d2:	fc cf       	rjmp	.-8      	; 0x36cc <uartSendByte+0x38>
		outb(UDR0, txData);
    36d4:	60 93 c6 00 	sts	0x00C6, r22
	}
	// set ready state to FALSE
	uartReadyTx[nUart] = FALSE;
    36d8:	f0 e0       	ldi	r31, 0x00	; 0
    36da:	e2 5e       	subi	r30, 0xE2	; 226
    36dc:	f7 4e       	sbci	r31, 0xE7	; 231
    36de:	10 82       	st	Z, r1
}
    36e0:	08 95       	ret

000036e2 <uart0SendByte>:

void uart0SendByte(u08 data)
{
    36e2:	68 2f       	mov	r22, r24
	// send byte on UART0
	uartSendByte(0, data);
    36e4:	80 e0       	ldi	r24, 0x00	; 0
    36e6:	0e 94 4a 1b 	call	0x3694	; 0x3694 <uartSendByte>
}
    36ea:	08 95       	ret

000036ec <uart1SendByte>:

void uart1SendByte(u08 data)
{
    36ec:	68 2f       	mov	r22, r24
	// send byte on UART1
	uartSendByte(1, data);
    36ee:	81 e0       	ldi	r24, 0x01	; 1
    36f0:	0e 94 4a 1b 	call	0x3694	; 0x3694 <uartSendByte>
}
    36f4:	08 95       	ret

000036f6 <uart2SendByte>:

void uart2SendByte(u08 data)
{
    36f6:	68 2f       	mov	r22, r24
	// send byte on UART2
	uartSendByte(2, data);
    36f8:	82 e0       	ldi	r24, 0x02	; 2
    36fa:	0e 94 4a 1b 	call	0x3694	; 0x3694 <uartSendByte>
}
    36fe:	08 95       	ret

00003700 <uart3SendByte>:

void uart3SendByte(u08 data)
{
    3700:	68 2f       	mov	r22, r24
	// send byte on UART3
	uartSendByte(3, data);
    3702:	83 e0       	ldi	r24, 0x03	; 3
    3704:	0e 94 4a 1b 	call	0x3694	; 0x3694 <uartSendByte>
}
    3708:	08 95       	ret

0000370a <uartReceiveBufferIsEmpty>:
	// flush all data from receive buffer
	bufferFlush(&uartRxBuffer[nUart]);
}

u08 uartReceiveBufferIsEmpty(u08 nUart)
{
    370a:	20 e0       	ldi	r18, 0x00	; 0
    370c:	e8 2f       	mov	r30, r24
    370e:	f0 e0       	ldi	r31, 0x00	; 0
    3710:	83 e0       	ldi	r24, 0x03	; 3
    3712:	ee 0f       	add	r30, r30
    3714:	ff 1f       	adc	r31, r31
    3716:	8a 95       	dec	r24
    3718:	e1 f7       	brne	.-8      	; 0x3712 <uartReceiveBufferIsEmpty+0x8>
    371a:	ea 5d       	subi	r30, 0xDA	; 218
    371c:	f7 4e       	sbci	r31, 0xE7	; 231
    371e:	80 81       	ld	r24, Z
    3720:	91 81       	ldd	r25, Z+1	; 0x01
    3722:	89 2b       	or	r24, r25
    3724:	09 f4       	brne	.+2      	; 0x3728 <uartReceiveBufferIsEmpty+0x1e>
    3726:	21 e0       	ldi	r18, 0x01	; 1
	return (uartRxBuffer[nUart].datalength == 0);
}
    3728:	82 2f       	mov	r24, r18
    372a:	08 95       	ret

0000372c <uartReceiveService>:
	}
}

// UART Receive Complete Interrupt Function
void uartReceiveService(u08 nUart)
{
    372c:	cf 93       	push	r28
    372e:	df 93       	push	r29
	u08 c;
	// get received char
	if(nUart==3)
    3730:	83 30       	cpi	r24, 0x03	; 3
    3732:	19 f4       	brne	.+6      	; 0x373a <uartReceiveService+0xe>
		c = inb(UDR3);
    3734:	60 91 36 01 	lds	r22, 0x0136
    3738:	0c c0       	rjmp	.+24     	; 0x3752 <uartReceiveService+0x26>
	else if(nUart==2)
    373a:	82 30       	cpi	r24, 0x02	; 2
    373c:	19 f4       	brne	.+6      	; 0x3744 <uartReceiveService+0x18>
		c = inb(UDR2);
    373e:	60 91 d6 00 	lds	r22, 0x00D6
    3742:	07 c0       	rjmp	.+14     	; 0x3752 <uartReceiveService+0x26>
	else if(nUart==1)
    3744:	81 30       	cpi	r24, 0x01	; 1
    3746:	19 f4       	brne	.+6      	; 0x374e <uartReceiveService+0x22>
		c = inb(UDR1);
    3748:	60 91 ce 00 	lds	r22, 0x00CE
    374c:	02 c0       	rjmp	.+4      	; 0x3752 <uartReceiveService+0x26>
	else
		c = inb(UDR0);
    374e:	60 91 c6 00 	lds	r22, 0x00C6

	// if there's a user function to handle this receive event
	if(UartRxFunc[nUart])
    3752:	28 2f       	mov	r18, r24
    3754:	30 e0       	ldi	r19, 0x00	; 0
    3756:	e9 01       	movw	r28, r18
    3758:	cc 0f       	add	r28, r28
    375a:	dd 1f       	adc	r29, r29
    375c:	fe 01       	movw	r30, r28
    375e:	e2 5a       	subi	r30, 0xA2	; 162
    3760:	fe 4e       	sbci	r31, 0xEE	; 238
    3762:	80 81       	ld	r24, Z
    3764:	91 81       	ldd	r25, Z+1	; 0x01
    3766:	89 2b       	or	r24, r25
    3768:	31 f0       	breq	.+12     	; 0x3776 <uartReceiveService+0x4a>
	{
		// call it and pass the received data
		UartRxFunc[nUart](c);
    376a:	01 90       	ld	r0, Z+
    376c:	f0 81       	ld	r31, Z
    376e:	e0 2d       	mov	r30, r0
    3770:	86 2f       	mov	r24, r22
    3772:	09 95       	icall
    3774:	14 c0       	rjmp	.+40     	; 0x379e <uartReceiveService+0x72>
	else
	{
		// otherwise do default processing
		// put received char in buffer
		// check if there's space
		if( !bufferAddToEnd(&uartRxBuffer[nUart], c) )
    3776:	93 e0       	ldi	r25, 0x03	; 3
    3778:	22 0f       	add	r18, r18
    377a:	33 1f       	adc	r19, r19
    377c:	9a 95       	dec	r25
    377e:	e1 f7       	brne	.-8      	; 0x3778 <uartReceiveService+0x4c>
    3780:	c9 01       	movw	r24, r18
    3782:	8e 5d       	subi	r24, 0xDE	; 222
    3784:	97 4e       	sbci	r25, 0xE7	; 231
    3786:	0e 94 a2 1f 	call	0x3f44	; 0x3f44 <bufferAddToEnd>
    378a:	88 23       	and	r24, r24
    378c:	41 f4       	brne	.+16     	; 0x379e <uartReceiveService+0x72>
		{
			// no space in buffer
			// count overflow
			uartRxOverflow[nUart]++;
    378e:	fe 01       	movw	r30, r28
    3790:	ea 59       	subi	r30, 0x9A	; 154
    3792:	f7 4e       	sbci	r31, 0xE7	; 231
    3794:	80 81       	ld	r24, Z
    3796:	91 81       	ldd	r25, Z+1	; 0x01
    3798:	01 96       	adiw	r24, 0x01	; 1
    379a:	91 83       	std	Z+1, r25	; 0x01
    379c:	80 83       	st	Z, r24
		}
	}
}
    379e:	df 91       	pop	r29
    37a0:	cf 91       	pop	r28
    37a2:	08 95       	ret

000037a4 <__vector_54>:
{
	uartReceiveService(2);
}

UART_INTERRUPT_HANDLER(SIG_USART3_RECV)      
{
    37a4:	1f 92       	push	r1
    37a6:	0f 92       	push	r0
    37a8:	0f b6       	in	r0, 0x3f	; 63
    37aa:	0f 92       	push	r0
    37ac:	11 24       	eor	r1, r1
    37ae:	2f 93       	push	r18
    37b0:	3f 93       	push	r19
    37b2:	4f 93       	push	r20
    37b4:	5f 93       	push	r21
    37b6:	6f 93       	push	r22
    37b8:	7f 93       	push	r23
    37ba:	8f 93       	push	r24
    37bc:	9f 93       	push	r25
    37be:	af 93       	push	r26
    37c0:	bf 93       	push	r27
    37c2:	ef 93       	push	r30
    37c4:	ff 93       	push	r31
	uartReceiveService(3);
    37c6:	83 e0       	ldi	r24, 0x03	; 3
    37c8:	0e 94 96 1b 	call	0x372c	; 0x372c <uartReceiveService>
}
    37cc:	ff 91       	pop	r31
    37ce:	ef 91       	pop	r30
    37d0:	bf 91       	pop	r27
    37d2:	af 91       	pop	r26
    37d4:	9f 91       	pop	r25
    37d6:	8f 91       	pop	r24
    37d8:	7f 91       	pop	r23
    37da:	6f 91       	pop	r22
    37dc:	5f 91       	pop	r21
    37de:	4f 91       	pop	r20
    37e0:	3f 91       	pop	r19
    37e2:	2f 91       	pop	r18
    37e4:	0f 90       	pop	r0
    37e6:	0f be       	out	0x3f, r0	; 63
    37e8:	0f 90       	pop	r0
    37ea:	1f 90       	pop	r1
    37ec:	18 95       	reti

000037ee <__vector_51>:
{
	uartReceiveService(1);
}

UART_INTERRUPT_HANDLER(SIG_USART2_RECV)      
{
    37ee:	1f 92       	push	r1
    37f0:	0f 92       	push	r0
    37f2:	0f b6       	in	r0, 0x3f	; 63
    37f4:	0f 92       	push	r0
    37f6:	11 24       	eor	r1, r1
    37f8:	2f 93       	push	r18
    37fa:	3f 93       	push	r19
    37fc:	4f 93       	push	r20
    37fe:	5f 93       	push	r21
    3800:	6f 93       	push	r22
    3802:	7f 93       	push	r23
    3804:	8f 93       	push	r24
    3806:	9f 93       	push	r25
    3808:	af 93       	push	r26
    380a:	bf 93       	push	r27
    380c:	ef 93       	push	r30
    380e:	ff 93       	push	r31
	uartReceiveService(2);
    3810:	82 e0       	ldi	r24, 0x02	; 2
    3812:	0e 94 96 1b 	call	0x372c	; 0x372c <uartReceiveService>
}
    3816:	ff 91       	pop	r31
    3818:	ef 91       	pop	r30
    381a:	bf 91       	pop	r27
    381c:	af 91       	pop	r26
    381e:	9f 91       	pop	r25
    3820:	8f 91       	pop	r24
    3822:	7f 91       	pop	r23
    3824:	6f 91       	pop	r22
    3826:	5f 91       	pop	r21
    3828:	4f 91       	pop	r20
    382a:	3f 91       	pop	r19
    382c:	2f 91       	pop	r18
    382e:	0f 90       	pop	r0
    3830:	0f be       	out	0x3f, r0	; 63
    3832:	0f 90       	pop	r0
    3834:	1f 90       	pop	r1
    3836:	18 95       	reti

00003838 <__vector_36>:
{
	uartReceiveService(0);
}

UART_INTERRUPT_HANDLER(SIG_USART1_RECV)      
{
    3838:	1f 92       	push	r1
    383a:	0f 92       	push	r0
    383c:	0f b6       	in	r0, 0x3f	; 63
    383e:	0f 92       	push	r0
    3840:	11 24       	eor	r1, r1
    3842:	2f 93       	push	r18
    3844:	3f 93       	push	r19
    3846:	4f 93       	push	r20
    3848:	5f 93       	push	r21
    384a:	6f 93       	push	r22
    384c:	7f 93       	push	r23
    384e:	8f 93       	push	r24
    3850:	9f 93       	push	r25
    3852:	af 93       	push	r26
    3854:	bf 93       	push	r27
    3856:	ef 93       	push	r30
    3858:	ff 93       	push	r31
	uartReceiveService(1);
    385a:	81 e0       	ldi	r24, 0x01	; 1
    385c:	0e 94 96 1b 	call	0x372c	; 0x372c <uartReceiveService>
}
    3860:	ff 91       	pop	r31
    3862:	ef 91       	pop	r30
    3864:	bf 91       	pop	r27
    3866:	af 91       	pop	r26
    3868:	9f 91       	pop	r25
    386a:	8f 91       	pop	r24
    386c:	7f 91       	pop	r23
    386e:	6f 91       	pop	r22
    3870:	5f 91       	pop	r21
    3872:	4f 91       	pop	r20
    3874:	3f 91       	pop	r19
    3876:	2f 91       	pop	r18
    3878:	0f 90       	pop	r0
    387a:	0f be       	out	0x3f, r0	; 63
    387c:	0f 90       	pop	r0
    387e:	1f 90       	pop	r1
    3880:	18 95       	reti

00003882 <__vector_25>:
	uartTransmitService(3);
}

	// service UART receive interrupt
UART_INTERRUPT_HANDLER(SIG_USART0_RECV)      
{
    3882:	1f 92       	push	r1
    3884:	0f 92       	push	r0
    3886:	0f b6       	in	r0, 0x3f	; 63
    3888:	0f 92       	push	r0
    388a:	11 24       	eor	r1, r1
    388c:	2f 93       	push	r18
    388e:	3f 93       	push	r19
    3890:	4f 93       	push	r20
    3892:	5f 93       	push	r21
    3894:	6f 93       	push	r22
    3896:	7f 93       	push	r23
    3898:	8f 93       	push	r24
    389a:	9f 93       	push	r25
    389c:	af 93       	push	r26
    389e:	bf 93       	push	r27
    38a0:	ef 93       	push	r30
    38a2:	ff 93       	push	r31
	uartReceiveService(0);
    38a4:	80 e0       	ldi	r24, 0x00	; 0
    38a6:	0e 94 96 1b 	call	0x372c	; 0x372c <uartReceiveService>
}
    38aa:	ff 91       	pop	r31
    38ac:	ef 91       	pop	r30
    38ae:	bf 91       	pop	r27
    38b0:	af 91       	pop	r26
    38b2:	9f 91       	pop	r25
    38b4:	8f 91       	pop	r24
    38b6:	7f 91       	pop	r23
    38b8:	6f 91       	pop	r22
    38ba:	5f 91       	pop	r21
    38bc:	4f 91       	pop	r20
    38be:	3f 91       	pop	r19
    38c0:	2f 91       	pop	r18
    38c2:	0f 90       	pop	r0
    38c4:	0f be       	out	0x3f, r0	; 63
    38c6:	0f 90       	pop	r0
    38c8:	1f 90       	pop	r1
    38ca:	18 95       	reti

000038cc <uartSendBuffer>:
	// send the first byte to get things going by interrupts
	uartSendByte(nUart, bufferGetFromFront(&uartTxBuffer[nUart]));
}

u08 uartSendBuffer(u08 nUart, char *buffer, u16 nBytes)
{
    38cc:	8f 92       	push	r8
    38ce:	9f 92       	push	r9
    38d0:	af 92       	push	r10
    38d2:	bf 92       	push	r11
    38d4:	cf 92       	push	r12
    38d6:	df 92       	push	r13
    38d8:	ef 92       	push	r14
    38da:	ff 92       	push	r15
    38dc:	0f 93       	push	r16
    38de:	1f 93       	push	r17
    38e0:	cf 93       	push	r28
    38e2:	df 93       	push	r29
    38e4:	88 2e       	mov	r8, r24
    38e6:	db 01       	movw	r26, r22
	register u08 first;
	register u16 i;

	// check if there's space (and that we have any bytes to send at all)
	if((uartTxBuffer[nUart].datalength + nBytes < uartTxBuffer[nUart].size) && nBytes)
    38e8:	c8 2e       	mov	r12, r24
    38ea:	dd 24       	eor	r13, r13
    38ec:	f6 01       	movw	r30, r12
    38ee:	13 e0       	ldi	r17, 0x03	; 3
    38f0:	ee 0f       	add	r30, r30
    38f2:	ff 1f       	adc	r31, r31
    38f4:	1a 95       	dec	r17
    38f6:	e1 f7       	brne	.-8      	; 0x38f0 <uartSendBuffer+0x24>
    38f8:	e6 5b       	subi	r30, 0xB6	; 182
    38fa:	f7 4e       	sbci	r31, 0xE7	; 231
    38fc:	20 81       	ld	r18, Z
    38fe:	31 81       	ldd	r19, Z+1	; 0x01
    3900:	24 0f       	add	r18, r20
    3902:	35 1f       	adc	r19, r21
    3904:	f6 01       	movw	r30, r12
    3906:	73 e0       	ldi	r23, 0x03	; 3
    3908:	ee 0f       	add	r30, r30
    390a:	ff 1f       	adc	r31, r31
    390c:	7a 95       	dec	r23
    390e:	e1 f7       	brne	.-8      	; 0x3908 <uartSendBuffer+0x3c>
    3910:	e8 5b       	subi	r30, 0xB8	; 184
    3912:	f7 4e       	sbci	r31, 0xE7	; 231
    3914:	80 81       	ld	r24, Z
    3916:	91 81       	ldd	r25, Z+1	; 0x01
    3918:	28 17       	cp	r18, r24
    391a:	39 07       	cpc	r19, r25
    391c:	70 f5       	brcc	.+92     	; 0x397a <uartSendBuffer+0xae>
    391e:	41 15       	cp	r20, r1
    3920:	51 05       	cpc	r21, r1
    3922:	59 f1       	breq	.+86     	; 0x397a <uartSendBuffer+0xae>
	{
		// grab first character
		first = *buffer++;
    3924:	9c 90       	ld	r9, X
		// copy user buffer to uart transmit buffer
		for(i = 0; i < nBytes-1; i++)
		{
			// put data bytes at end of buffer
			bufferAddToEnd(&uartTxBuffer[nUart], *buffer++);
    3926:	76 01       	movw	r14, r12
    3928:	63 e0       	ldi	r22, 0x03	; 3
    392a:	ee 0c       	add	r14, r14
    392c:	ff 1c       	adc	r15, r15
    392e:	6a 95       	dec	r22
    3930:	e1 f7       	brne	.-8      	; 0x392a <uartSendBuffer+0x5e>
    3932:	86 e4       	ldi	r24, 0x46	; 70
    3934:	98 e1       	ldi	r25, 0x18	; 24
    3936:	e8 0e       	add	r14, r24
    3938:	f9 1e       	adc	r15, r25
    393a:	8d 01       	movw	r16, r26
    393c:	c0 e0       	ldi	r28, 0x00	; 0
    393e:	d0 e0       	ldi	r29, 0x00	; 0
	if((uartTxBuffer[nUart].datalength + nBytes < uartTxBuffer[nUart].size) && nBytes)
	{
		// grab first character
		first = *buffer++;
		// copy user buffer to uart transmit buffer
		for(i = 0; i < nBytes-1; i++)
    3940:	5a 01       	movw	r10, r20
    3942:	08 94       	sec
    3944:	a1 08       	sbc	r10, r1
    3946:	b1 08       	sbc	r11, r1
    3948:	06 c0       	rjmp	.+12     	; 0x3956 <uartSendBuffer+0x8a>
    394a:	c7 01       	movw	r24, r14
    394c:	f8 01       	movw	r30, r16
    394e:	60 81       	ld	r22, Z
    3950:	0e 94 a2 1f 	call	0x3f44	; 0x3f44 <bufferAddToEnd>
    3954:	21 96       	adiw	r28, 0x01	; 1
    3956:	0f 5f       	subi	r16, 0xFF	; 255
    3958:	1f 4f       	sbci	r17, 0xFF	; 255
    395a:	ca 15       	cp	r28, r10
    395c:	db 05       	cpc	r29, r11
    395e:	a8 f3       	brcs	.-22     	; 0x394a <uartSendBuffer+0x7e>
			// put data bytes at end of buffer
			bufferAddToEnd(&uartTxBuffer[nUart], *buffer++);
		}

		// send the first byte to get things going by interrupts
		uartBufferedTx[nUart] = TRUE;
    3960:	82 e4       	ldi	r24, 0x42	; 66
    3962:	98 e1       	ldi	r25, 0x18	; 24
    3964:	c8 0e       	add	r12, r24
    3966:	d9 1e       	adc	r13, r25
    3968:	8f ef       	ldi	r24, 0xFF	; 255
    396a:	f6 01       	movw	r30, r12
    396c:	80 83       	st	Z, r24
		uartSendByte(nUart, first);
    396e:	88 2d       	mov	r24, r8
    3970:	69 2d       	mov	r22, r9
    3972:	0e 94 4a 1b 	call	0x3694	; 0x3694 <uartSendByte>
    3976:	8f ef       	ldi	r24, 0xFF	; 255
    3978:	01 c0       	rjmp	.+2      	; 0x397c <uartSendBuffer+0xb0>
		// return success
		return TRUE;
    397a:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		// return failure
		return FALSE;
	}
}
    397c:	df 91       	pop	r29
    397e:	cf 91       	pop	r28
    3980:	1f 91       	pop	r17
    3982:	0f 91       	pop	r16
    3984:	ff 90       	pop	r15
    3986:	ef 90       	pop	r14
    3988:	df 90       	pop	r13
    398a:	cf 90       	pop	r12
    398c:	bf 90       	pop	r11
    398e:	af 90       	pop	r10
    3990:	9f 90       	pop	r9
    3992:	8f 90       	pop	r8
    3994:	08 95       	ret

00003996 <uartAddToTxBuffer>:
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    3996:	90 e0       	ldi	r25, 0x00	; 0
    3998:	23 e0       	ldi	r18, 0x03	; 3
    399a:	88 0f       	add	r24, r24
    399c:	99 1f       	adc	r25, r25
    399e:	2a 95       	dec	r18
    39a0:	e1 f7       	brne	.-8      	; 0x399a <uartAddToTxBuffer+0x4>
    39a2:	8a 5b       	subi	r24, 0xBA	; 186
    39a4:	97 4e       	sbci	r25, 0xE7	; 231
    39a6:	0e 94 a2 1f 	call	0x3f44	; 0x3f44 <bufferAddToEnd>
}
    39aa:	08 95       	ret

000039ac <uart3AddToTxBuffer>:
{
	uartAddToTxBuffer(2,data);
}

void uart3AddToTxBuffer(u08 data)
{
    39ac:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    39ae:	8e e5       	ldi	r24, 0x5E	; 94
    39b0:	98 e1       	ldi	r25, 0x18	; 24
    39b2:	0e 94 a2 1f 	call	0x3f44	; 0x3f44 <bufferAddToEnd>
}

void uart3AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(3,data);
}
    39b6:	08 95       	ret

000039b8 <uart2AddToTxBuffer>:
{
	uartAddToTxBuffer(1,data);
}

void uart2AddToTxBuffer(u08 data)
{
    39b8:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    39ba:	86 e5       	ldi	r24, 0x56	; 86
    39bc:	98 e1       	ldi	r25, 0x18	; 24
    39be:	0e 94 a2 1f 	call	0x3f44	; 0x3f44 <bufferAddToEnd>
}

void uart2AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(2,data);
}
    39c2:	08 95       	ret

000039c4 <uart1AddToTxBuffer>:
{
	uartAddToTxBuffer(0,data);
}

void uart1AddToTxBuffer(u08 data)
{
    39c4:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    39c6:	8e e4       	ldi	r24, 0x4E	; 78
    39c8:	98 e1       	ldi	r25, 0x18	; 24
    39ca:	0e 94 a2 1f 	call	0x3f44	; 0x3f44 <bufferAddToEnd>
}

void uart1AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(1,data);
}
    39ce:	08 95       	ret

000039d0 <uart0AddToTxBuffer>:
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
}

void uart0AddToTxBuffer(u08 data)
{
    39d0:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    39d2:	86 e4       	ldi	r24, 0x46	; 70
    39d4:	98 e1       	ldi	r25, 0x18	; 24
    39d6:	0e 94 a2 1f 	call	0x3f44	; 0x3f44 <bufferAddToEnd>
}

void uart0AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(0,data);
}
    39da:	08 95       	ret

000039dc <uartTransmitService>:
	}
}

// UART Transmit Complete Interrupt Function
void uartTransmitService(u08 nUart)
{
    39dc:	cf 93       	push	r28
    39de:	df 93       	push	r29
    39e0:	28 2f       	mov	r18, r24
	// check if buffered tx is enabled
	if(uartBufferedTx[nUart])
    39e2:	a8 2f       	mov	r26, r24
    39e4:	b0 e0       	ldi	r27, 0x00	; 0
    39e6:	ed 01       	movw	r28, r26
    39e8:	ce 5b       	subi	r28, 0xBE	; 190
    39ea:	d7 4e       	sbci	r29, 0xE7	; 231
    39ec:	88 81       	ld	r24, Y
    39ee:	88 23       	and	r24, r24
    39f0:	79 f1       	breq	.+94     	; 0x3a50 <uartTransmitService+0x74>
	{
		// check if there's data left in the buffer
		if(uartTxBuffer[nUart].datalength)
    39f2:	fd 01       	movw	r30, r26
    39f4:	33 e0       	ldi	r19, 0x03	; 3
    39f6:	ee 0f       	add	r30, r30
    39f8:	ff 1f       	adc	r31, r31
    39fa:	3a 95       	dec	r19
    39fc:	e1 f7       	brne	.-8      	; 0x39f6 <uartTransmitService+0x1a>
    39fe:	e6 5b       	subi	r30, 0xB6	; 182
    3a00:	f7 4e       	sbci	r31, 0xE7	; 231
    3a02:	80 81       	ld	r24, Z
    3a04:	91 81       	ldd	r25, Z+1	; 0x01
    3a06:	89 2b       	or	r24, r25
    3a08:	11 f1       	breq	.+68     	; 0x3a4e <uartTransmitService+0x72>
		{
			// send byte from top of buffer
			if(nUart==3)
    3a0a:	23 30       	cpi	r18, 0x03	; 3
    3a0c:	39 f4       	brne	.+14     	; 0x3a1c <uartTransmitService+0x40>
				outb(UDR3,  bufferGetFromFront(&uartTxBuffer[3]) );
    3a0e:	8e e5       	ldi	r24, 0x5E	; 94
    3a10:	98 e1       	ldi	r25, 0x18	; 24
    3a12:	0e 94 39 1f 	call	0x3e72	; 0x3e72 <bufferGetFromFront>
    3a16:	80 93 36 01 	sts	0x0136, r24
    3a1a:	1e c0       	rjmp	.+60     	; 0x3a58 <uartTransmitService+0x7c>
			else if(nUart==2)
    3a1c:	22 30       	cpi	r18, 0x02	; 2
    3a1e:	39 f4       	brne	.+14     	; 0x3a2e <uartTransmitService+0x52>
				outb(UDR2,  bufferGetFromFront(&uartTxBuffer[2]) );
    3a20:	86 e5       	ldi	r24, 0x56	; 86
    3a22:	98 e1       	ldi	r25, 0x18	; 24
    3a24:	0e 94 39 1f 	call	0x3e72	; 0x3e72 <bufferGetFromFront>
    3a28:	80 93 d6 00 	sts	0x00D6, r24
    3a2c:	15 c0       	rjmp	.+42     	; 0x3a58 <uartTransmitService+0x7c>
			else if(nUart==1)
    3a2e:	21 30       	cpi	r18, 0x01	; 1
    3a30:	39 f4       	brne	.+14     	; 0x3a40 <uartTransmitService+0x64>
				outb(UDR1,  bufferGetFromFront(&uartTxBuffer[1]) );
    3a32:	8e e4       	ldi	r24, 0x4E	; 78
    3a34:	98 e1       	ldi	r25, 0x18	; 24
    3a36:	0e 94 39 1f 	call	0x3e72	; 0x3e72 <bufferGetFromFront>
    3a3a:	80 93 ce 00 	sts	0x00CE, r24
    3a3e:	0c c0       	rjmp	.+24     	; 0x3a58 <uartTransmitService+0x7c>
			else
				outb(UDR0,  bufferGetFromFront(&uartTxBuffer[0]) );
    3a40:	86 e4       	ldi	r24, 0x46	; 70
    3a42:	98 e1       	ldi	r25, 0x18	; 24
    3a44:	0e 94 39 1f 	call	0x3e72	; 0x3e72 <bufferGetFromFront>
    3a48:	80 93 c6 00 	sts	0x00C6, r24
    3a4c:	05 c0       	rjmp	.+10     	; 0x3a58 <uartTransmitService+0x7c>
		}
		else
		{
			// no data left
			uartBufferedTx[nUart] = FALSE;
    3a4e:	18 82       	st	Y, r1
	}
	else
	{
		// we're using single-byte tx mode
		// indicate transmit complete, back to ready
		uartReadyTx[nUart] = TRUE;
    3a50:	a2 5e       	subi	r26, 0xE2	; 226
    3a52:	b7 4e       	sbci	r27, 0xE7	; 231
    3a54:	8f ef       	ldi	r24, 0xFF	; 255
    3a56:	8c 93       	st	X, r24
	}
}
    3a58:	df 91       	pop	r29
    3a5a:	cf 91       	pop	r28
    3a5c:	08 95       	ret

00003a5e <__vector_56>:
{
	uartTransmitService(2);
}

UART_INTERRUPT_HANDLER(SIG_USART3_TRANS)      
{
    3a5e:	1f 92       	push	r1
    3a60:	0f 92       	push	r0
    3a62:	0f b6       	in	r0, 0x3f	; 63
    3a64:	0f 92       	push	r0
    3a66:	11 24       	eor	r1, r1
    3a68:	2f 93       	push	r18
    3a6a:	3f 93       	push	r19
    3a6c:	4f 93       	push	r20
    3a6e:	5f 93       	push	r21
    3a70:	6f 93       	push	r22
    3a72:	7f 93       	push	r23
    3a74:	8f 93       	push	r24
    3a76:	9f 93       	push	r25
    3a78:	af 93       	push	r26
    3a7a:	bf 93       	push	r27
    3a7c:	ef 93       	push	r30
    3a7e:	ff 93       	push	r31
	uartTransmitService(3);
    3a80:	83 e0       	ldi	r24, 0x03	; 3
    3a82:	0e 94 ee 1c 	call	0x39dc	; 0x39dc <uartTransmitService>
}
    3a86:	ff 91       	pop	r31
    3a88:	ef 91       	pop	r30
    3a8a:	bf 91       	pop	r27
    3a8c:	af 91       	pop	r26
    3a8e:	9f 91       	pop	r25
    3a90:	8f 91       	pop	r24
    3a92:	7f 91       	pop	r23
    3a94:	6f 91       	pop	r22
    3a96:	5f 91       	pop	r21
    3a98:	4f 91       	pop	r20
    3a9a:	3f 91       	pop	r19
    3a9c:	2f 91       	pop	r18
    3a9e:	0f 90       	pop	r0
    3aa0:	0f be       	out	0x3f, r0	; 63
    3aa2:	0f 90       	pop	r0
    3aa4:	1f 90       	pop	r1
    3aa6:	18 95       	reti

00003aa8 <__vector_53>:
{
	uartTransmitService(1);
}

UART_INTERRUPT_HANDLER(SIG_USART2_TRANS)      
{
    3aa8:	1f 92       	push	r1
    3aaa:	0f 92       	push	r0
    3aac:	0f b6       	in	r0, 0x3f	; 63
    3aae:	0f 92       	push	r0
    3ab0:	11 24       	eor	r1, r1
    3ab2:	2f 93       	push	r18
    3ab4:	3f 93       	push	r19
    3ab6:	4f 93       	push	r20
    3ab8:	5f 93       	push	r21
    3aba:	6f 93       	push	r22
    3abc:	7f 93       	push	r23
    3abe:	8f 93       	push	r24
    3ac0:	9f 93       	push	r25
    3ac2:	af 93       	push	r26
    3ac4:	bf 93       	push	r27
    3ac6:	ef 93       	push	r30
    3ac8:	ff 93       	push	r31
	uartTransmitService(2);
    3aca:	82 e0       	ldi	r24, 0x02	; 2
    3acc:	0e 94 ee 1c 	call	0x39dc	; 0x39dc <uartTransmitService>
}
    3ad0:	ff 91       	pop	r31
    3ad2:	ef 91       	pop	r30
    3ad4:	bf 91       	pop	r27
    3ad6:	af 91       	pop	r26
    3ad8:	9f 91       	pop	r25
    3ada:	8f 91       	pop	r24
    3adc:	7f 91       	pop	r23
    3ade:	6f 91       	pop	r22
    3ae0:	5f 91       	pop	r21
    3ae2:	4f 91       	pop	r20
    3ae4:	3f 91       	pop	r19
    3ae6:	2f 91       	pop	r18
    3ae8:	0f 90       	pop	r0
    3aea:	0f be       	out	0x3f, r0	; 63
    3aec:	0f 90       	pop	r0
    3aee:	1f 90       	pop	r1
    3af0:	18 95       	reti

00003af2 <__vector_38>:
{
	uartTransmitService(0);
}

UART_INTERRUPT_HANDLER(SIG_USART1_TRANS)      
{
    3af2:	1f 92       	push	r1
    3af4:	0f 92       	push	r0
    3af6:	0f b6       	in	r0, 0x3f	; 63
    3af8:	0f 92       	push	r0
    3afa:	11 24       	eor	r1, r1
    3afc:	2f 93       	push	r18
    3afe:	3f 93       	push	r19
    3b00:	4f 93       	push	r20
    3b02:	5f 93       	push	r21
    3b04:	6f 93       	push	r22
    3b06:	7f 93       	push	r23
    3b08:	8f 93       	push	r24
    3b0a:	9f 93       	push	r25
    3b0c:	af 93       	push	r26
    3b0e:	bf 93       	push	r27
    3b10:	ef 93       	push	r30
    3b12:	ff 93       	push	r31
	uartTransmitService(1);
    3b14:	81 e0       	ldi	r24, 0x01	; 1
    3b16:	0e 94 ee 1c 	call	0x39dc	; 0x39dc <uartTransmitService>
}
    3b1a:	ff 91       	pop	r31
    3b1c:	ef 91       	pop	r30
    3b1e:	bf 91       	pop	r27
    3b20:	af 91       	pop	r26
    3b22:	9f 91       	pop	r25
    3b24:	8f 91       	pop	r24
    3b26:	7f 91       	pop	r23
    3b28:	6f 91       	pop	r22
    3b2a:	5f 91       	pop	r21
    3b2c:	4f 91       	pop	r20
    3b2e:	3f 91       	pop	r19
    3b30:	2f 91       	pop	r18
    3b32:	0f 90       	pop	r0
    3b34:	0f be       	out	0x3f, r0	; 63
    3b36:	0f 90       	pop	r0
    3b38:	1f 90       	pop	r1
    3b3a:	18 95       	reti

00003b3c <__vector_27>:
	}
}

	// service UART transmit interrupt
UART_INTERRUPT_HANDLER(SIG_USART0_TRANS)      
{
    3b3c:	1f 92       	push	r1
    3b3e:	0f 92       	push	r0
    3b40:	0f b6       	in	r0, 0x3f	; 63
    3b42:	0f 92       	push	r0
    3b44:	11 24       	eor	r1, r1
    3b46:	2f 93       	push	r18
    3b48:	3f 93       	push	r19
    3b4a:	4f 93       	push	r20
    3b4c:	5f 93       	push	r21
    3b4e:	6f 93       	push	r22
    3b50:	7f 93       	push	r23
    3b52:	8f 93       	push	r24
    3b54:	9f 93       	push	r25
    3b56:	af 93       	push	r26
    3b58:	bf 93       	push	r27
    3b5a:	ef 93       	push	r30
    3b5c:	ff 93       	push	r31
	uartTransmitService(0);
    3b5e:	80 e0       	ldi	r24, 0x00	; 0
    3b60:	0e 94 ee 1c 	call	0x39dc	; 0x39dc <uartTransmitService>
}
    3b64:	ff 91       	pop	r31
    3b66:	ef 91       	pop	r30
    3b68:	bf 91       	pop	r27
    3b6a:	af 91       	pop	r26
    3b6c:	9f 91       	pop	r25
    3b6e:	8f 91       	pop	r24
    3b70:	7f 91       	pop	r23
    3b72:	6f 91       	pop	r22
    3b74:	5f 91       	pop	r21
    3b76:	4f 91       	pop	r20
    3b78:	3f 91       	pop	r19
    3b7a:	2f 91       	pop	r18
    3b7c:	0f 90       	pop	r0
    3b7e:	0f be       	out	0x3f, r0	; 63
    3b80:	0f 90       	pop	r0
    3b82:	1f 90       	pop	r1
    3b84:	18 95       	reti

00003b86 <uartSendTxBuffer>:
{
	uartAddToTxBuffer(3,data);
}

void uartSendTxBuffer(u08 nUart)
{
    3b86:	1f 93       	push	r17
    3b88:	18 2f       	mov	r17, r24
	// turn on buffered transmit
	uartBufferedTx[nUart] = TRUE;
    3b8a:	90 e0       	ldi	r25, 0x00	; 0
    3b8c:	fc 01       	movw	r30, r24
    3b8e:	ee 5b       	subi	r30, 0xBE	; 190
    3b90:	f7 4e       	sbci	r31, 0xE7	; 231
    3b92:	2f ef       	ldi	r18, 0xFF	; 255
    3b94:	20 83       	st	Z, r18
	// send the first byte to get things going by interrupts
	uartSendByte(nUart, bufferGetFromFront(&uartTxBuffer[nUart]));
    3b96:	43 e0       	ldi	r20, 0x03	; 3
    3b98:	88 0f       	add	r24, r24
    3b9a:	99 1f       	adc	r25, r25
    3b9c:	4a 95       	dec	r20
    3b9e:	e1 f7       	brne	.-8      	; 0x3b98 <uartSendTxBuffer+0x12>
    3ba0:	8a 5b       	subi	r24, 0xBA	; 186
    3ba2:	97 4e       	sbci	r25, 0xE7	; 231
    3ba4:	0e 94 39 1f 	call	0x3e72	; 0x3e72 <bufferGetFromFront>
    3ba8:	68 2f       	mov	r22, r24
    3baa:	81 2f       	mov	r24, r17
    3bac:	0e 94 4a 1b 	call	0x3694	; 0x3694 <uartSendByte>
}
    3bb0:	1f 91       	pop	r17
    3bb2:	08 95       	ret

00003bb4 <uartReceiveByte>:
		return -1;
}


u08 uartReceiveByte(u08 nUart, u08* rxData)
{
    3bb4:	cf 93       	push	r28
    3bb6:	df 93       	push	r29
    3bb8:	eb 01       	movw	r28, r22
	// make sure we have a receive buffer
	if(uartRxBuffer[nUart].size)
    3bba:	28 2f       	mov	r18, r24
    3bbc:	30 e0       	ldi	r19, 0x00	; 0
    3bbe:	f9 01       	movw	r30, r18
    3bc0:	73 e0       	ldi	r23, 0x03	; 3
    3bc2:	ee 0f       	add	r30, r30
    3bc4:	ff 1f       	adc	r31, r31
    3bc6:	7a 95       	dec	r23
    3bc8:	e1 f7       	brne	.-8      	; 0x3bc2 <uartReceiveByte+0xe>
    3bca:	ec 5d       	subi	r30, 0xDC	; 220
    3bcc:	f7 4e       	sbci	r31, 0xE7	; 231
    3bce:	80 81       	ld	r24, Z
    3bd0:	91 81       	ldd	r25, Z+1	; 0x01
    3bd2:	89 2b       	or	r24, r25
    3bd4:	c9 f0       	breq	.+50     	; 0x3c08 <uartReceiveByte+0x54>
	{
		// make sure we have data
		if(uartRxBuffer[nUart].datalength)
    3bd6:	f9 01       	movw	r30, r18
    3bd8:	63 e0       	ldi	r22, 0x03	; 3
    3bda:	ee 0f       	add	r30, r30
    3bdc:	ff 1f       	adc	r31, r31
    3bde:	6a 95       	dec	r22
    3be0:	e1 f7       	brne	.-8      	; 0x3bda <uartReceiveByte+0x26>
    3be2:	ea 5d       	subi	r30, 0xDA	; 218
    3be4:	f7 4e       	sbci	r31, 0xE7	; 231
    3be6:	80 81       	ld	r24, Z
    3be8:	91 81       	ldd	r25, Z+1	; 0x01
    3bea:	89 2b       	or	r24, r25
    3bec:	69 f0       	breq	.+26     	; 0x3c08 <uartReceiveByte+0x54>
		{
			// get byte from beginning of buffer
			*rxData = bufferGetFromFront(&uartRxBuffer[nUart]);
    3bee:	53 e0       	ldi	r21, 0x03	; 3
    3bf0:	22 0f       	add	r18, r18
    3bf2:	33 1f       	adc	r19, r19
    3bf4:	5a 95       	dec	r21
    3bf6:	e1 f7       	brne	.-8      	; 0x3bf0 <uartReceiveByte+0x3c>
    3bf8:	c9 01       	movw	r24, r18
    3bfa:	8e 5d       	subi	r24, 0xDE	; 222
    3bfc:	97 4e       	sbci	r25, 0xE7	; 231
    3bfe:	0e 94 39 1f 	call	0x3e72	; 0x3e72 <bufferGetFromFront>
    3c02:	88 83       	st	Y, r24
    3c04:	8f ef       	ldi	r24, 0xFF	; 255
    3c06:	01 c0       	rjmp	.+2      	; 0x3c0a <uartReceiveByte+0x56>
			return TRUE;
    3c08:	80 e0       	ldi	r24, 0x00	; 0
		else
			return FALSE;			// no data
	}
	else
		return FALSE;				// no buffer
}
    3c0a:	df 91       	pop	r29
    3c0c:	cf 91       	pop	r28
    3c0e:	08 95       	ret

00003c10 <uart3GetByte>:
	else
		return -1;
}

int uart3GetByte(void)
{
    3c10:	df 93       	push	r29
    3c12:	cf 93       	push	r28
    3c14:	0f 92       	push	r0
    3c16:	cd b7       	in	r28, 0x3d	; 61
    3c18:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(3,&c))
    3c1a:	83 e0       	ldi	r24, 0x03	; 3
    3c1c:	be 01       	movw	r22, r28
    3c1e:	6f 5f       	subi	r22, 0xFF	; 255
    3c20:	7f 4f       	sbci	r23, 0xFF	; 255
    3c22:	0e 94 da 1d 	call	0x3bb4	; 0x3bb4 <uartReceiveByte>
    3c26:	88 23       	and	r24, r24
    3c28:	19 f4       	brne	.+6      	; 0x3c30 <uart3GetByte+0x20>
    3c2a:	2f ef       	ldi	r18, 0xFF	; 255
    3c2c:	3f ef       	ldi	r19, 0xFF	; 255
    3c2e:	03 c0       	rjmp	.+6      	; 0x3c36 <uart3GetByte+0x26>
		return c;
    3c30:	89 81       	ldd	r24, Y+1	; 0x01
    3c32:	28 2f       	mov	r18, r24
    3c34:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    3c36:	c9 01       	movw	r24, r18
    3c38:	0f 90       	pop	r0
    3c3a:	cf 91       	pop	r28
    3c3c:	df 91       	pop	r29
    3c3e:	08 95       	ret

00003c40 <uart2GetByte>:
	else
		return -1;
}

int uart2GetByte(void)
{
    3c40:	df 93       	push	r29
    3c42:	cf 93       	push	r28
    3c44:	0f 92       	push	r0
    3c46:	cd b7       	in	r28, 0x3d	; 61
    3c48:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(2,&c))
    3c4a:	82 e0       	ldi	r24, 0x02	; 2
    3c4c:	be 01       	movw	r22, r28
    3c4e:	6f 5f       	subi	r22, 0xFF	; 255
    3c50:	7f 4f       	sbci	r23, 0xFF	; 255
    3c52:	0e 94 da 1d 	call	0x3bb4	; 0x3bb4 <uartReceiveByte>
    3c56:	88 23       	and	r24, r24
    3c58:	19 f4       	brne	.+6      	; 0x3c60 <uart2GetByte+0x20>
    3c5a:	2f ef       	ldi	r18, 0xFF	; 255
    3c5c:	3f ef       	ldi	r19, 0xFF	; 255
    3c5e:	03 c0       	rjmp	.+6      	; 0x3c66 <uart2GetByte+0x26>
		return c;
    3c60:	89 81       	ldd	r24, Y+1	; 0x01
    3c62:	28 2f       	mov	r18, r24
    3c64:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    3c66:	c9 01       	movw	r24, r18
    3c68:	0f 90       	pop	r0
    3c6a:	cf 91       	pop	r28
    3c6c:	df 91       	pop	r29
    3c6e:	08 95       	ret

00003c70 <uart1GetByte>:
	else
		return -1;
}

int uart1GetByte(void)
{
    3c70:	df 93       	push	r29
    3c72:	cf 93       	push	r28
    3c74:	0f 92       	push	r0
    3c76:	cd b7       	in	r28, 0x3d	; 61
    3c78:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(1,&c))
    3c7a:	81 e0       	ldi	r24, 0x01	; 1
    3c7c:	be 01       	movw	r22, r28
    3c7e:	6f 5f       	subi	r22, 0xFF	; 255
    3c80:	7f 4f       	sbci	r23, 0xFF	; 255
    3c82:	0e 94 da 1d 	call	0x3bb4	; 0x3bb4 <uartReceiveByte>
    3c86:	88 23       	and	r24, r24
    3c88:	19 f4       	brne	.+6      	; 0x3c90 <uart1GetByte+0x20>
    3c8a:	2f ef       	ldi	r18, 0xFF	; 255
    3c8c:	3f ef       	ldi	r19, 0xFF	; 255
    3c8e:	03 c0       	rjmp	.+6      	; 0x3c96 <uart1GetByte+0x26>
		return c;
    3c90:	89 81       	ldd	r24, Y+1	; 0x01
    3c92:	28 2f       	mov	r18, r24
    3c94:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    3c96:	c9 01       	movw	r24, r18
    3c98:	0f 90       	pop	r0
    3c9a:	cf 91       	pop	r28
    3c9c:	df 91       	pop	r29
    3c9e:	08 95       	ret

00003ca0 <uart0GetByte>:
	// send byte on UART3
	uartSendByte(3, data);
}

int uart0GetByte(void)
{
    3ca0:	df 93       	push	r29
    3ca2:	cf 93       	push	r28
    3ca4:	0f 92       	push	r0
    3ca6:	cd b7       	in	r28, 0x3d	; 61
    3ca8:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(0,&c))
    3caa:	80 e0       	ldi	r24, 0x00	; 0
    3cac:	be 01       	movw	r22, r28
    3cae:	6f 5f       	subi	r22, 0xFF	; 255
    3cb0:	7f 4f       	sbci	r23, 0xFF	; 255
    3cb2:	0e 94 da 1d 	call	0x3bb4	; 0x3bb4 <uartReceiveByte>
    3cb6:	88 23       	and	r24, r24
    3cb8:	19 f4       	brne	.+6      	; 0x3cc0 <uart0GetByte+0x20>
    3cba:	2f ef       	ldi	r18, 0xFF	; 255
    3cbc:	3f ef       	ldi	r19, 0xFF	; 255
    3cbe:	03 c0       	rjmp	.+6      	; 0x3cc6 <uart0GetByte+0x26>
		return c;
    3cc0:	89 81       	ldd	r24, Y+1	; 0x01
    3cc2:	28 2f       	mov	r18, r24
    3cc4:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    3cc6:	c9 01       	movw	r24, r18
    3cc8:	0f 90       	pop	r0
    3cca:	cf 91       	pop	r28
    3ccc:	df 91       	pop	r29
    3cce:	08 95       	ret

00003cd0 <uartFlushReceiveBuffer>:
}

void uartFlushReceiveBuffer(u08 nUart)
{
	// flush all data from receive buffer
	bufferFlush(&uartRxBuffer[nUart]);
    3cd0:	90 e0       	ldi	r25, 0x00	; 0
    3cd2:	e3 e0       	ldi	r30, 0x03	; 3
    3cd4:	88 0f       	add	r24, r24
    3cd6:	99 1f       	adc	r25, r25
    3cd8:	ea 95       	dec	r30
    3cda:	e1 f7       	brne	.-8      	; 0x3cd4 <uartFlushReceiveBuffer+0x4>
    3cdc:	8e 5d       	subi	r24, 0xDE	; 222
    3cde:	97 4e       	sbci	r25, 0xE7	; 231
    3ce0:	0e 94 d5 1f 	call	0x3faa	; 0x3faa <bufferFlush>
}
    3ce4:	08 95       	ret

00003ce6 <uart3InitBuffers>:

void uart3InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART3 buffers
		bufferInit(&uartRxBuffer[3], (u08*) uart3RxData, UART3_RX_BUFFER_SIZE);
    3ce6:	8a e3       	ldi	r24, 0x3A	; 58
    3ce8:	98 e1       	ldi	r25, 0x18	; 24
    3cea:	6e ec       	ldi	r22, 0xCE	; 206
    3cec:	70 e1       	ldi	r23, 0x10	; 16
    3cee:	40 e8       	ldi	r20, 0x80	; 128
    3cf0:	50 e0       	ldi	r21, 0x00	; 0
    3cf2:	0e 94 2c 1f 	call	0x3e58	; 0x3e58 <bufferInit>
		bufferInit(&uartTxBuffer[3], (u08*) uart3TxData, UART3_TX_BUFFER_SIZE);
    3cf6:	8e e5       	ldi	r24, 0x5E	; 94
    3cf8:	98 e1       	ldi	r25, 0x18	; 24
    3cfa:	6e e4       	ldi	r22, 0x4E	; 78
    3cfc:	71 e1       	ldi	r23, 0x11	; 17
    3cfe:	40 e1       	ldi	r20, 0x10	; 16
    3d00:	50 e0       	ldi	r21, 0x00	; 0
    3d02:	0e 94 2c 1f 	call	0x3e58	; 0x3e58 <bufferInit>
	#else
		// initialize the UART3 buffers
		bufferInit(&uartRxBuffer[3], (u08*) UART3_RX_BUFFER_ADDR, UART3_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[3], (u08*) UART3_TX_BUFFER_ADDR, UART3_TX_BUFFER_SIZE);
	#endif
}
    3d06:	08 95       	ret

00003d08 <uart3Init>:
}

void uart3Init(void)
{
	// initialize the buffers
	uart3InitBuffers();
    3d08:	0e 94 73 1e 	call	0x3ce6	; 0x3ce6 <uart3InitBuffers>
	// initialize user receive handlers
	UartRxFunc[3] = 0;
    3d0c:	10 92 65 11 	sts	0x1165, r1
    3d10:	10 92 64 11 	sts	0x1164, r1
	// enable RxD/TxD and interrupts
	outb(UCSR3B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    3d14:	88 ed       	ldi	r24, 0xD8	; 216
    3d16:	80 93 31 01 	sts	0x0131, r24
	// set default baud rate
	uartSetBaudRate(3, UART3_DEFAULT_BAUD_RATE);
    3d1a:	83 e0       	ldi	r24, 0x03	; 3
    3d1c:	40 e8       	ldi	r20, 0x80	; 128
    3d1e:	55 e2       	ldi	r21, 0x25	; 37
    3d20:	60 e0       	ldi	r22, 0x00	; 0
    3d22:	70 e0       	ldi	r23, 0x00	; 0
    3d24:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <uartSetBaudRate>
	// initialize states
	uartReadyTx[3] = TRUE;
    3d28:	8f ef       	ldi	r24, 0xFF	; 255
    3d2a:	80 93 21 18 	sts	0x1821, r24
	uartBufferedTx[3] = FALSE;
    3d2e:	10 92 45 18 	sts	0x1845, r1
	// clear overflow count
	uartRxOverflow[3] = 0;
    3d32:	10 92 6d 18 	sts	0x186D, r1
    3d36:	10 92 6c 18 	sts	0x186C, r1
	// enable interrupts
	sei();
    3d3a:	78 94       	sei
}
    3d3c:	08 95       	ret

00003d3e <uart2InitBuffers>:

void uart2InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART2 buffers
		bufferInit(&uartRxBuffer[2], (u08*) uart2RxData, UART2_RX_BUFFER_SIZE);
    3d3e:	82 e3       	ldi	r24, 0x32	; 50
    3d40:	98 e1       	ldi	r25, 0x18	; 24
    3d42:	6e e3       	ldi	r22, 0x3E	; 62
    3d44:	70 e1       	ldi	r23, 0x10	; 16
    3d46:	40 e8       	ldi	r20, 0x80	; 128
    3d48:	50 e0       	ldi	r21, 0x00	; 0
    3d4a:	0e 94 2c 1f 	call	0x3e58	; 0x3e58 <bufferInit>
		bufferInit(&uartTxBuffer[2], (u08*) uart2TxData, UART2_TX_BUFFER_SIZE);
    3d4e:	86 e5       	ldi	r24, 0x56	; 86
    3d50:	98 e1       	ldi	r25, 0x18	; 24
    3d52:	6e eb       	ldi	r22, 0xBE	; 190
    3d54:	70 e1       	ldi	r23, 0x10	; 16
    3d56:	40 e1       	ldi	r20, 0x10	; 16
    3d58:	50 e0       	ldi	r21, 0x00	; 0
    3d5a:	0e 94 2c 1f 	call	0x3e58	; 0x3e58 <bufferInit>
	#else
		// initialize the UART2 buffers
		bufferInit(&uartRxBuffer[2], (u08*) UART2_RX_BUFFER_ADDR, UART2_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[2], (u08*) UART2_TX_BUFFER_ADDR, UART2_TX_BUFFER_SIZE);
	#endif
}
    3d5e:	08 95       	ret

00003d60 <uart2Init>:
}

void uart2Init(void)
{
	// initialize the buffers
	uart2InitBuffers();
    3d60:	0e 94 9f 1e 	call	0x3d3e	; 0x3d3e <uart2InitBuffers>
	// initialize user receive handlers
	UartRxFunc[2] = 0;
    3d64:	10 92 63 11 	sts	0x1163, r1
    3d68:	10 92 62 11 	sts	0x1162, r1
	// enable RxD/TxD and interrupts
	outb(UCSR2B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    3d6c:	88 ed       	ldi	r24, 0xD8	; 216
    3d6e:	80 93 d1 00 	sts	0x00D1, r24
	// set default baud rate
	uartSetBaudRate(2, UART2_DEFAULT_BAUD_RATE);
    3d72:	82 e0       	ldi	r24, 0x02	; 2
    3d74:	40 e8       	ldi	r20, 0x80	; 128
    3d76:	55 e2       	ldi	r21, 0x25	; 37
    3d78:	60 e0       	ldi	r22, 0x00	; 0
    3d7a:	70 e0       	ldi	r23, 0x00	; 0
    3d7c:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <uartSetBaudRate>
	// initialize states
	uartReadyTx[2] = TRUE;
    3d80:	8f ef       	ldi	r24, 0xFF	; 255
    3d82:	80 93 20 18 	sts	0x1820, r24
	uartBufferedTx[2] = FALSE;
    3d86:	10 92 44 18 	sts	0x1844, r1
	// clear overflow count
	uartRxOverflow[2] = 0;
    3d8a:	10 92 6b 18 	sts	0x186B, r1
    3d8e:	10 92 6a 18 	sts	0x186A, r1
	// enable interrupts
	sei();
    3d92:	78 94       	sei
}
    3d94:	08 95       	ret

00003d96 <uart1InitBuffers>:

void uart1InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART1 buffers
		bufferInit(&uartRxBuffer[1], (u08*) uart1RxData, UART1_RX_BUFFER_SIZE);
    3d96:	8a e2       	ldi	r24, 0x2A	; 42
    3d98:	98 e1       	ldi	r25, 0x18	; 24
    3d9a:	6e ea       	ldi	r22, 0xAE	; 174
    3d9c:	7f e0       	ldi	r23, 0x0F	; 15
    3d9e:	40 e8       	ldi	r20, 0x80	; 128
    3da0:	50 e0       	ldi	r21, 0x00	; 0
    3da2:	0e 94 2c 1f 	call	0x3e58	; 0x3e58 <bufferInit>
		bufferInit(&uartTxBuffer[1], (u08*) uart1TxData, UART1_TX_BUFFER_SIZE);
    3da6:	8e e4       	ldi	r24, 0x4E	; 78
    3da8:	98 e1       	ldi	r25, 0x18	; 24
    3daa:	6e e2       	ldi	r22, 0x2E	; 46
    3dac:	70 e1       	ldi	r23, 0x10	; 16
    3dae:	40 e1       	ldi	r20, 0x10	; 16
    3db0:	50 e0       	ldi	r21, 0x00	; 0
    3db2:	0e 94 2c 1f 	call	0x3e58	; 0x3e58 <bufferInit>
	#else
		// initialize the UART1 buffers
		bufferInit(&uartRxBuffer[1], (u08*) UART1_RX_BUFFER_ADDR, UART1_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[1], (u08*) UART1_TX_BUFFER_ADDR, UART1_TX_BUFFER_SIZE);
	#endif
}
    3db6:	08 95       	ret

00003db8 <uart1Init>:
}

void uart1Init(void)
{
	// initialize the buffers
	uart1InitBuffers();
    3db8:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <uart1InitBuffers>
	// initialize user receive handlers
	UartRxFunc[1] = 0;
    3dbc:	10 92 61 11 	sts	0x1161, r1
    3dc0:	10 92 60 11 	sts	0x1160, r1
	// enable RxD/TxD and interrupts
	outb(UCSR1B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    3dc4:	88 ed       	ldi	r24, 0xD8	; 216
    3dc6:	80 93 c9 00 	sts	0x00C9, r24
	// set default baud rate
	uartSetBaudRate(1, UART1_DEFAULT_BAUD_RATE);
    3dca:	81 e0       	ldi	r24, 0x01	; 1
    3dcc:	40 e8       	ldi	r20, 0x80	; 128
    3dce:	55 e2       	ldi	r21, 0x25	; 37
    3dd0:	60 e0       	ldi	r22, 0x00	; 0
    3dd2:	70 e0       	ldi	r23, 0x00	; 0
    3dd4:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <uartSetBaudRate>
	// initialize states
	uartReadyTx[1] = TRUE;
    3dd8:	8f ef       	ldi	r24, 0xFF	; 255
    3dda:	80 93 1f 18 	sts	0x181F, r24
	uartBufferedTx[1] = FALSE;
    3dde:	10 92 43 18 	sts	0x1843, r1
	// clear overflow count
	uartRxOverflow[1] = 0;
    3de2:	10 92 69 18 	sts	0x1869, r1
    3de6:	10 92 68 18 	sts	0x1868, r1
	// enable interrupts
	sei();
    3dea:	78 94       	sei
}
    3dec:	08 95       	ret

00003dee <uart0InitBuffers>:

void uart0InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART0 buffers
		bufferInit(&uartRxBuffer[0], (u08*) uart0RxData, UART0_RX_BUFFER_SIZE);
    3dee:	82 e2       	ldi	r24, 0x22	; 34
    3df0:	98 e1       	ldi	r25, 0x18	; 24
    3df2:	6e e1       	ldi	r22, 0x1E	; 30
    3df4:	7f e0       	ldi	r23, 0x0F	; 15
    3df6:	40 e8       	ldi	r20, 0x80	; 128
    3df8:	50 e0       	ldi	r21, 0x00	; 0
    3dfa:	0e 94 2c 1f 	call	0x3e58	; 0x3e58 <bufferInit>
		bufferInit(&uartTxBuffer[0], (u08*) uart0TxData, UART0_TX_BUFFER_SIZE);
    3dfe:	86 e4       	ldi	r24, 0x46	; 70
    3e00:	98 e1       	ldi	r25, 0x18	; 24
    3e02:	6e e9       	ldi	r22, 0x9E	; 158
    3e04:	7f e0       	ldi	r23, 0x0F	; 15
    3e06:	40 e1       	ldi	r20, 0x10	; 16
    3e08:	50 e0       	ldi	r21, 0x00	; 0
    3e0a:	0e 94 2c 1f 	call	0x3e58	; 0x3e58 <bufferInit>
	#else
		// initialize the UART0 buffers
		bufferInit(&uartRxBuffer[0], (u08*) UART0_RX_BUFFER_ADDR, UART0_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[0], (u08*) UART0_TX_BUFFER_ADDR, UART0_TX_BUFFER_SIZE);
	#endif
}
    3e0e:	08 95       	ret

00003e10 <uart0Init>:
}

void uart0Init(void)
{
	// initialize the buffers
	uart0InitBuffers();
    3e10:	0e 94 f7 1e 	call	0x3dee	; 0x3dee <uart0InitBuffers>
	// initialize user receive handlers
	UartRxFunc[0] = 0;
    3e14:	10 92 5f 11 	sts	0x115F, r1
    3e18:	10 92 5e 11 	sts	0x115E, r1
	// enable RxD/TxD and interrupts
	outb(UCSR0B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    3e1c:	88 ed       	ldi	r24, 0xD8	; 216
    3e1e:	80 93 c1 00 	sts	0x00C1, r24
	// set default baud rate
	uartSetBaudRate(0, UART0_DEFAULT_BAUD_RATE); 
    3e22:	80 e0       	ldi	r24, 0x00	; 0
    3e24:	40 e8       	ldi	r20, 0x80	; 128
    3e26:	55 e2       	ldi	r21, 0x25	; 37
    3e28:	60 e0       	ldi	r22, 0x00	; 0
    3e2a:	70 e0       	ldi	r23, 0x00	; 0
    3e2c:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <uartSetBaudRate>
	// initialize states
	uartReadyTx[0] = TRUE;
    3e30:	8f ef       	ldi	r24, 0xFF	; 255
    3e32:	80 93 1e 18 	sts	0x181E, r24
	uartBufferedTx[0] = FALSE;
    3e36:	10 92 42 18 	sts	0x1842, r1
	// clear overflow count
	uartRxOverflow[0] = 0;
    3e3a:	10 92 67 18 	sts	0x1867, r1
    3e3e:	10 92 66 18 	sts	0x1866, r1
	// enable interrupts
	sei();
    3e42:	78 94       	sei
}
    3e44:	08 95       	ret

00003e46 <uartInit>:
volatile static voidFuncPtru08 UartRxFunc[4];

void uartInit(void)
{
	// initialize all uarts
	uart0Init();
    3e46:	0e 94 08 1f 	call	0x3e10	; 0x3e10 <uart0Init>
	uart1Init();
    3e4a:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <uart1Init>
	uart2Init();
    3e4e:	0e 94 b0 1e 	call	0x3d60	; 0x3d60 <uart2Init>
	uart3Init();
    3e52:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <uart3Init>
}
    3e56:	08 95       	ret

00003e58 <bufferInit>:
// global variables

// initialization

void bufferInit(cBuffer* buffer, unsigned char *start, unsigned short size)
{
    3e58:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    3e5a:	8f b7       	in	r24, 0x3f	; 63
    3e5c:	f8 94       	cli
	// set start pointer of the buffer
	buffer->dataptr = start;
    3e5e:	71 83       	std	Z+1, r23	; 0x01
    3e60:	60 83       	st	Z, r22
	buffer->size = size;
    3e62:	53 83       	std	Z+3, r21	; 0x03
    3e64:	42 83       	std	Z+2, r20	; 0x02
	// initialize index and length
	buffer->dataindex = 0;
    3e66:	17 82       	std	Z+7, r1	; 0x07
    3e68:	16 82       	std	Z+6, r1	; 0x06
	buffer->datalength = 0;
    3e6a:	15 82       	std	Z+5, r1	; 0x05
    3e6c:	14 82       	std	Z+4, r1	; 0x04
	// end critical section
	CRITICAL_SECTION_END;
    3e6e:	8f bf       	out	0x3f, r24	; 63
}
    3e70:	08 95       	ret

00003e72 <bufferGetFromFront>:

// access routines
unsigned char  bufferGetFromFront(cBuffer* buffer)
{
    3e72:	dc 01       	movw	r26, r24
	unsigned char data = 0;
	// begin critical section
	CRITICAL_SECTION_START;
    3e74:	4f b7       	in	r20, 0x3f	; 63
    3e76:	f8 94       	cli
	// check to see if there's data in the buffer
	if(buffer->datalength)
    3e78:	14 96       	adiw	r26, 0x04	; 4
    3e7a:	8d 91       	ld	r24, X+
    3e7c:	9c 91       	ld	r25, X
    3e7e:	15 97       	sbiw	r26, 0x05	; 5
    3e80:	89 2b       	or	r24, r25
    3e82:	11 f4       	brne	.+4      	; 0x3e88 <bufferGetFromFront+0x16>
    3e84:	e0 e0       	ldi	r30, 0x00	; 0
    3e86:	25 c0       	rjmp	.+74     	; 0x3ed2 <bufferGetFromFront+0x60>
	{
		// get the first character from buffer
		data = buffer->dataptr[buffer->dataindex];
    3e88:	16 96       	adiw	r26, 0x06	; 6
    3e8a:	8d 91       	ld	r24, X+
    3e8c:	9c 91       	ld	r25, X
    3e8e:	17 97       	sbiw	r26, 0x07	; 7
    3e90:	ed 91       	ld	r30, X+
    3e92:	fc 91       	ld	r31, X
    3e94:	11 97       	sbiw	r26, 0x01	; 1
    3e96:	e8 0f       	add	r30, r24
    3e98:	f9 1f       	adc	r31, r25
    3e9a:	e0 81       	ld	r30, Z
		// move index down and decrement length
		buffer->dataindex++;
    3e9c:	01 96       	adiw	r24, 0x01	; 1
    3e9e:	17 96       	adiw	r26, 0x07	; 7
    3ea0:	9c 93       	st	X, r25
    3ea2:	8e 93       	st	-X, r24
    3ea4:	16 97       	sbiw	r26, 0x06	; 6
		if(buffer->dataindex >= buffer->size)
    3ea6:	12 96       	adiw	r26, 0x02	; 2
    3ea8:	2d 91       	ld	r18, X+
    3eaa:	3c 91       	ld	r19, X
    3eac:	13 97       	sbiw	r26, 0x03	; 3
    3eae:	82 17       	cp	r24, r18
    3eb0:	93 07       	cpc	r25, r19
    3eb2:	30 f0       	brcs	.+12     	; 0x3ec0 <bufferGetFromFront+0x4e>
		{
			buffer->dataindex -= buffer->size;
    3eb4:	82 1b       	sub	r24, r18
    3eb6:	93 0b       	sbc	r25, r19
    3eb8:	17 96       	adiw	r26, 0x07	; 7
    3eba:	9c 93       	st	X, r25
    3ebc:	8e 93       	st	-X, r24
    3ebe:	16 97       	sbiw	r26, 0x06	; 6
		}
		buffer->datalength--;
    3ec0:	14 96       	adiw	r26, 0x04	; 4
    3ec2:	8d 91       	ld	r24, X+
    3ec4:	9c 91       	ld	r25, X
    3ec6:	15 97       	sbiw	r26, 0x05	; 5
    3ec8:	01 97       	sbiw	r24, 0x01	; 1
    3eca:	15 96       	adiw	r26, 0x05	; 5
    3ecc:	9c 93       	st	X, r25
    3ece:	8e 93       	st	-X, r24
    3ed0:	14 97       	sbiw	r26, 0x04	; 4
	}
	// end critical section
	CRITICAL_SECTION_END;
    3ed2:	4f bf       	out	0x3f, r20	; 63
	// return
	return data;
}
    3ed4:	8e 2f       	mov	r24, r30
    3ed6:	08 95       	ret

00003ed8 <bufferDumpFromFront>:

void bufferDumpFromFront(cBuffer* buffer, unsigned short numbytes)
{
    3ed8:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    3eda:	4f b7       	in	r20, 0x3f	; 63
    3edc:	f8 94       	cli
	// dump numbytes from the front of the buffer
	// are we dumping less than the entire buffer?
	if(numbytes < buffer->datalength)
    3ede:	84 81       	ldd	r24, Z+4	; 0x04
    3ee0:	95 81       	ldd	r25, Z+5	; 0x05
    3ee2:	68 17       	cp	r22, r24
    3ee4:	79 07       	cpc	r23, r25
    3ee6:	b0 f4       	brcc	.+44     	; 0x3f14 <bufferDumpFromFront+0x3c>
	{
		// move index down by numbytes and decrement length by numbytes
		buffer->dataindex += numbytes;
    3ee8:	86 81       	ldd	r24, Z+6	; 0x06
    3eea:	97 81       	ldd	r25, Z+7	; 0x07
    3eec:	86 0f       	add	r24, r22
    3eee:	97 1f       	adc	r25, r23
    3ef0:	97 83       	std	Z+7, r25	; 0x07
    3ef2:	86 83       	std	Z+6, r24	; 0x06
		if(buffer->dataindex >= buffer->size)
    3ef4:	22 81       	ldd	r18, Z+2	; 0x02
    3ef6:	33 81       	ldd	r19, Z+3	; 0x03
    3ef8:	82 17       	cp	r24, r18
    3efa:	93 07       	cpc	r25, r19
    3efc:	20 f0       	brcs	.+8      	; 0x3f06 <bufferDumpFromFront+0x2e>
		{
			buffer->dataindex -= buffer->size;
    3efe:	82 1b       	sub	r24, r18
    3f00:	93 0b       	sbc	r25, r19
    3f02:	97 83       	std	Z+7, r25	; 0x07
    3f04:	86 83       	std	Z+6, r24	; 0x06
		}
		buffer->datalength -= numbytes;
    3f06:	84 81       	ldd	r24, Z+4	; 0x04
    3f08:	95 81       	ldd	r25, Z+5	; 0x05
    3f0a:	86 1b       	sub	r24, r22
    3f0c:	97 0b       	sbc	r25, r23
    3f0e:	95 83       	std	Z+5, r25	; 0x05
    3f10:	84 83       	std	Z+4, r24	; 0x04
    3f12:	02 c0       	rjmp	.+4      	; 0x3f18 <bufferDumpFromFront+0x40>
	}
	else
	{
		// flush the whole buffer
		buffer->datalength = 0;
    3f14:	15 82       	std	Z+5, r1	; 0x05
    3f16:	14 82       	std	Z+4, r1	; 0x04
	}
	// end critical section
	CRITICAL_SECTION_END;
    3f18:	4f bf       	out	0x3f, r20	; 63
}
    3f1a:	08 95       	ret

00003f1c <bufferGetAtIndex>:

unsigned char bufferGetAtIndex(cBuffer* buffer, unsigned short index)
{
    3f1c:	fc 01       	movw	r30, r24
    3f1e:	cb 01       	movw	r24, r22
	// begin critical section
	CRITICAL_SECTION_START;
    3f20:	2f b7       	in	r18, 0x3f	; 63
    3f22:	f8 94       	cli
	// return character at index in buffer
	unsigned char data = buffer->dataptr[(buffer->dataindex+index)%(buffer->size)];
	// end critical section
	CRITICAL_SECTION_END;
    3f24:	2f bf       	out	0x3f, r18	; 63
    3f26:	26 81       	ldd	r18, Z+6	; 0x06
    3f28:	37 81       	ldd	r19, Z+7	; 0x07
    3f2a:	62 81       	ldd	r22, Z+2	; 0x02
    3f2c:	73 81       	ldd	r23, Z+3	; 0x03
    3f2e:	82 0f       	add	r24, r18
    3f30:	93 1f       	adc	r25, r19
    3f32:	0e 94 da 27 	call	0x4fb4	; 0x4fb4 <__udivmodhi4>
    3f36:	01 90       	ld	r0, Z+
    3f38:	f0 81       	ld	r31, Z
    3f3a:	e0 2d       	mov	r30, r0
    3f3c:	e8 0f       	add	r30, r24
    3f3e:	f9 1f       	adc	r31, r25
	return data;
}
    3f40:	80 81       	ld	r24, Z
    3f42:	08 95       	ret

00003f44 <bufferAddToEnd>:

unsigned char bufferAddToEnd(cBuffer* buffer, unsigned char data)
{
    3f44:	1f 93       	push	r17
    3f46:	cf 93       	push	r28
    3f48:	df 93       	push	r29
    3f4a:	ec 01       	movw	r28, r24
    3f4c:	16 2f       	mov	r17, r22
	// begin critical section
	CRITICAL_SECTION_START;
    3f4e:	4f b7       	in	r20, 0x3f	; 63
    3f50:	f8 94       	cli
	// make sure the buffer has room
	if(buffer->datalength < buffer->size)
    3f52:	2c 81       	ldd	r18, Y+4	; 0x04
    3f54:	3d 81       	ldd	r19, Y+5	; 0x05
    3f56:	6a 81       	ldd	r22, Y+2	; 0x02
    3f58:	7b 81       	ldd	r23, Y+3	; 0x03
    3f5a:	26 17       	cp	r18, r22
    3f5c:	37 07       	cpc	r19, r23
    3f5e:	98 f4       	brcc	.+38     	; 0x3f86 <bufferAddToEnd+0x42>
	{
		// save data byte at end of buffer
		buffer->dataptr[(buffer->dataindex + buffer->datalength) % buffer->size] = data;
    3f60:	8e 81       	ldd	r24, Y+6	; 0x06
    3f62:	9f 81       	ldd	r25, Y+7	; 0x07
    3f64:	82 0f       	add	r24, r18
    3f66:	93 1f       	adc	r25, r19
    3f68:	0e 94 da 27 	call	0x4fb4	; 0x4fb4 <__udivmodhi4>
    3f6c:	e8 81       	ld	r30, Y
    3f6e:	f9 81       	ldd	r31, Y+1	; 0x01
    3f70:	e8 0f       	add	r30, r24
    3f72:	f9 1f       	adc	r31, r25
    3f74:	10 83       	st	Z, r17
		// increment the length
		buffer->datalength++;
    3f76:	8c 81       	ldd	r24, Y+4	; 0x04
    3f78:	9d 81       	ldd	r25, Y+5	; 0x05
    3f7a:	01 96       	adiw	r24, 0x01	; 1
    3f7c:	9d 83       	std	Y+5, r25	; 0x05
    3f7e:	8c 83       	std	Y+4, r24	; 0x04
		// end critical section
		CRITICAL_SECTION_END;
    3f80:	4f bf       	out	0x3f, r20	; 63
    3f82:	8f ef       	ldi	r24, 0xFF	; 255
    3f84:	02 c0       	rjmp	.+4      	; 0x3f8a <bufferAddToEnd+0x46>
		// return success
		return -1;
	}
	// end critical section
	CRITICAL_SECTION_END;
    3f86:	4f bf       	out	0x3f, r20	; 63
    3f88:	80 e0       	ldi	r24, 0x00	; 0
	// return failure
	return 0;
}
    3f8a:	df 91       	pop	r29
    3f8c:	cf 91       	pop	r28
    3f8e:	1f 91       	pop	r17
    3f90:	08 95       	ret

00003f92 <bufferIsNotFull>:

unsigned short bufferIsNotFull(cBuffer* buffer)
{
    3f92:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    3f94:	8f b7       	in	r24, 0x3f	; 63
    3f96:	f8 94       	cli
	// check to see if the buffer has room
	// return true if there is room
	unsigned short bytesleft = (buffer->size - buffer->datalength);
	// end critical section
	CRITICAL_SECTION_END;
    3f98:	8f bf       	out	0x3f, r24	; 63
    3f9a:	22 81       	ldd	r18, Z+2	; 0x02
    3f9c:	33 81       	ldd	r19, Z+3	; 0x03
    3f9e:	84 81       	ldd	r24, Z+4	; 0x04
    3fa0:	95 81       	ldd	r25, Z+5	; 0x05
    3fa2:	28 1b       	sub	r18, r24
    3fa4:	39 0b       	sbc	r19, r25
	return bytesleft;
}
    3fa6:	c9 01       	movw	r24, r18
    3fa8:	08 95       	ret

00003faa <bufferFlush>:

void bufferFlush(cBuffer* buffer)
{
    3faa:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    3fac:	8f b7       	in	r24, 0x3f	; 63
    3fae:	f8 94       	cli
	// flush contents of the buffer
	buffer->datalength = 0;
    3fb0:	15 82       	std	Z+5, r1	; 0x05
    3fb2:	14 82       	std	Z+4, r1	; 0x04
	// end critical section
	CRITICAL_SECTION_END;
    3fb4:	8f bf       	out	0x3f, r24	; 63
}
    3fb6:	08 95       	ret

00003fb8 <a2dInit>:
// functions

// initialize a2d converter
void a2dInit(void)
{
	sbi(ADCSR, ADEN);				// enable ADC (turn on ADC power)
    3fb8:	aa e7       	ldi	r26, 0x7A	; 122
    3fba:	b0 e0       	ldi	r27, 0x00	; 0
    3fbc:	8c 91       	ld	r24, X
    3fbe:	80 68       	ori	r24, 0x80	; 128
    3fc0:	8c 93       	st	X, r24
	cbi(ADCSR, ADFR);				// default to single sample convert mode
    3fc2:	8c 91       	ld	r24, X
    3fc4:	8f 7d       	andi	r24, 0xDF	; 223
    3fc6:	8c 93       	st	X, r24
}

// configure A2D converter clock division (prescaling)
void a2dSetPrescaler(unsigned char prescale)
{
	outb(ADCSR, ((inb(ADCSR) & ~ADC_PRESCALE_MASK) | prescale));
    3fc8:	8c 91       	ld	r24, X
    3fca:	88 7f       	andi	r24, 0xF8	; 248
    3fcc:	86 60       	ori	r24, 0x06	; 6
    3fce:	8c 93       	st	X, r24
}

// configure A2D converter voltage reference
void a2dSetReference(unsigned char ref)
{
	outb(ADMUX, ((inb(ADMUX) & ~ADC_REFERENCE_MASK) | (ref<<6)));
    3fd0:	ec e7       	ldi	r30, 0x7C	; 124
    3fd2:	f0 e0       	ldi	r31, 0x00	; 0
    3fd4:	80 81       	ld	r24, Z
    3fd6:	8f 73       	andi	r24, 0x3F	; 63
    3fd8:	80 64       	ori	r24, 0x40	; 64
    3fda:	80 83       	st	Z, r24
{
	sbi(ADCSR, ADEN);				// enable ADC (turn on ADC power)
	cbi(ADCSR, ADFR);				// default to single sample convert mode
	a2dSetPrescaler(ADC_PRESCALE);	// set default prescaler
	a2dSetReference(ADC_REFERENCE);	// set default reference
	cbi(ADMUX, ADLAR);				// set to right-adjusted result
    3fdc:	80 81       	ld	r24, Z
    3fde:	8f 7d       	andi	r24, 0xDF	; 223
    3fe0:	80 83       	st	Z, r24

	sbi(ADCSR, ADIE);				// enable ADC interrupts
    3fe2:	8c 91       	ld	r24, X
    3fe4:	88 60       	ori	r24, 0x08	; 8
    3fe6:	8c 93       	st	X, r24

	a2dCompleteFlag = FALSE;		// clear conversion complete flag
    3fe8:	10 92 6e 18 	sts	0x186E, r1
	sei();							// turn on interrupts (if not already on)
    3fec:	78 94       	sei
}
    3fee:	08 95       	ret

00003ff0 <a2dOff>:

// turn off a2d converter
void a2dOff(void)
{
	cbi(ADCSR, ADIE);				// disable ADC interrupts
    3ff0:	ea e7       	ldi	r30, 0x7A	; 122
    3ff2:	f0 e0       	ldi	r31, 0x00	; 0
    3ff4:	80 81       	ld	r24, Z
    3ff6:	87 7f       	andi	r24, 0xF7	; 247
    3ff8:	80 83       	st	Z, r24
	cbi(ADCSR, ADEN);				// disable ADC (turn off ADC power)
    3ffa:	80 81       	ld	r24, Z
    3ffc:	8f 77       	andi	r24, 0x7F	; 127
    3ffe:	80 83       	st	Z, r24
}
    4000:	08 95       	ret

00004002 <a2dSetPrescaler>:

// configure A2D converter clock division (prescaling)
void a2dSetPrescaler(unsigned char prescale)
{
	outb(ADCSR, ((inb(ADCSR) & ~ADC_PRESCALE_MASK) | prescale));
    4002:	ea e7       	ldi	r30, 0x7A	; 122
    4004:	f0 e0       	ldi	r31, 0x00	; 0
    4006:	90 81       	ld	r25, Z
    4008:	98 7f       	andi	r25, 0xF8	; 248
    400a:	98 2b       	or	r25, r24
    400c:	90 83       	st	Z, r25
}
    400e:	08 95       	ret

00004010 <a2dSetReference>:

// configure A2D converter voltage reference
void a2dSetReference(unsigned char ref)
{
	outb(ADMUX, ((inb(ADMUX) & ~ADC_REFERENCE_MASK) | (ref<<6)));
    4010:	ec e7       	ldi	r30, 0x7C	; 124
    4012:	f0 e0       	ldi	r31, 0x00	; 0
    4014:	90 81       	ld	r25, Z
    4016:	82 95       	swap	r24
    4018:	88 0f       	add	r24, r24
    401a:	88 0f       	add	r24, r24
    401c:	80 7c       	andi	r24, 0xC0	; 192
    401e:	9f 73       	andi	r25, 0x3F	; 63
    4020:	98 2b       	or	r25, r24
    4022:	90 83       	st	Z, r25
}
    4024:	08 95       	ret

00004026 <a2dSetChannel>:

// sets the a2d input channel
void a2dSetChannel(unsigned char ch)
{
	outb(ADMUX, (inb(ADMUX) & ~ADC_MUX_MASK) | (ch & ADC_MUX_MASK));	// set channel
    4026:	ec e7       	ldi	r30, 0x7C	; 124
    4028:	f0 e0       	ldi	r31, 0x00	; 0
    402a:	90 81       	ld	r25, Z
    402c:	8f 71       	andi	r24, 0x1F	; 31
    402e:	90 7e       	andi	r25, 0xE0	; 224
    4030:	89 2b       	or	r24, r25
    4032:	80 83       	st	Z, r24
}
    4034:	08 95       	ret

00004036 <a2dStartConvert>:

// start a conversion on the current a2d input channel
void a2dStartConvert(void)
{
	sbi(ADCSR, ADIF);	// clear hardware "conversion complete" flag 
    4036:	ea e7       	ldi	r30, 0x7A	; 122
    4038:	f0 e0       	ldi	r31, 0x00	; 0
    403a:	80 81       	ld	r24, Z
    403c:	80 61       	ori	r24, 0x10	; 16
    403e:	80 83       	st	Z, r24
	sbi(ADCSR, ADSC);	// start conversion
    4040:	80 81       	ld	r24, Z
    4042:	80 64       	ori	r24, 0x40	; 64
    4044:	80 83       	st	Z, r24
}
    4046:	08 95       	ret

00004048 <a2dIsComplete>:

// return TRUE if conversion is complete
u08 a2dIsComplete(void)
{
	return bit_is_set(ADCSR, ADSC);
    4048:	80 91 7a 00 	lds	r24, 0x007A
}
    404c:	80 74       	andi	r24, 0x40	; 64
    404e:	08 95       	ret

00004050 <a2dConvert10bit>:

// Perform a 10-bit conversion
// starts conversion, waits until conversion is done, and returns result
unsigned short a2dConvert10bit(unsigned char ch)
{
    4050:	98 2f       	mov	r25, r24
	a2dCompleteFlag = FALSE;				// clear conversion complete flag
    4052:	10 92 6e 18 	sts	0x186E, r1

if (ch >= 8)
    4056:	88 30       	cpi	r24, 0x08	; 8
    4058:	20 f0       	brcs	.+8      	; 0x4062 <a2dConvert10bit+0x12>
    ADCSRB |= _BV(MUX5);
    405a:	80 91 7b 00 	lds	r24, 0x007B
    405e:	88 60       	ori	r24, 0x08	; 8
    4060:	03 c0       	rjmp	.+6      	; 0x4068 <a2dConvert10bit+0x18>
else
    ADCSRB &= ~_BV(MUX5);
    4062:	80 91 7b 00 	lds	r24, 0x007B
    4066:	87 7f       	andi	r24, 0xF7	; 247
    4068:	80 93 7b 00 	sts	0x007B, r24

   outb(ADMUX, (inb(ADMUX) & ~7) | (ch & 7));   // set channel
    406c:	80 91 7c 00 	lds	r24, 0x007C
    4070:	97 70       	andi	r25, 0x07	; 7
    4072:	88 7f       	andi	r24, 0xF8	; 248
    4074:	89 2b       	or	r24, r25
    4076:	80 93 7c 00 	sts	0x007C, r24

	//outb(ADMUX, (inb(ADMUX) & ~ADC_MUX_MASK) | (ch & ADC_MUX_MASK));	// set channel
	sbi(ADCSR, ADIF);						// clear hardware "conversion complete" flag 
    407a:	80 91 7a 00 	lds	r24, 0x007A
    407e:	80 61       	ori	r24, 0x10	; 16
    4080:	80 93 7a 00 	sts	0x007A, r24
	sbi(ADCSR, ADSC);						// start conversion
    4084:	80 91 7a 00 	lds	r24, 0x007A
    4088:	80 64       	ori	r24, 0x40	; 64
    408a:	80 93 7a 00 	sts	0x007A, r24
	//while(!a2dCompleteFlag);				// wait until conversion complete
	//while( bit_is_clear(ADCSR, ADIF) );		// wait until conversion complete
	while( bit_is_set(ADCSR, ADSC) );		// wait until conversion complete
    408e:	80 91 7a 00 	lds	r24, 0x007A
    4092:	86 fd       	sbrc	r24, 6
    4094:	fc cf       	rjmp	.-8      	; 0x408e <a2dConvert10bit+0x3e>

	// CAUTION: MUST READ ADCL BEFORE ADCH!!!
	//return (inb(ADCL) | (inb(ADCH)<<8));	// read ADC (full 10 bits) //old version
	return ADC;//new version code
    4096:	20 91 78 00 	lds	r18, 0x0078
    409a:	30 91 79 00 	lds	r19, 0x0079
}
    409e:	c9 01       	movw	r24, r18
    40a0:	08 95       	ret

000040a2 <a2dConvert8bit>:
// Perform a 8-bit conversion.
// starts conversion, waits until conversion is done, and returns result
unsigned char a2dConvert8bit(unsigned char ch)
{
	// do 10-bit conversion and return highest 8 bits
	return a2dConvert10bit(ch)>>2;			// return ADC MSB byte
    40a2:	0e 94 28 20 	call	0x4050	; 0x4050 <a2dConvert10bit>
    40a6:	96 95       	lsr	r25
    40a8:	87 95       	ror	r24
    40aa:	96 95       	lsr	r25
    40ac:	87 95       	ror	r24
}
    40ae:	08 95       	ret

000040b0 <__vector_29>:

//! Interrupt handler for ADC complete interrupt.
SIGNAL(SIG_ADC)
{
    40b0:	1f 92       	push	r1
    40b2:	0f 92       	push	r0
    40b4:	0f b6       	in	r0, 0x3f	; 63
    40b6:	0f 92       	push	r0
    40b8:	11 24       	eor	r1, r1
    40ba:	8f 93       	push	r24
	// set the a2d conversion flag to indicate "complete"
	a2dCompleteFlag = TRUE;
    40bc:	8f ef       	ldi	r24, 0xFF	; 255
    40be:	80 93 6e 18 	sts	0x186E, r24
}
    40c2:	8f 91       	pop	r24
    40c4:	0f 90       	pop	r0
    40c6:	0f be       	out	0x3f, r0	; 63
    40c8:	0f 90       	pop	r0
    40ca:	1f 90       	pop	r1
    40cc:	18 95       	reti

000040ce <rprintfInit>:
// *** rprintf initialization ***
// you must call this function once and supply the character output
// routine before using other functions in this library
void rprintfInit(void (*putchar_func)(unsigned char c))
{
	rputchar = putchar_func;
    40ce:	90 93 67 11 	sts	0x1167, r25
    40d2:	80 93 66 11 	sts	0x1166, r24
}
    40d6:	08 95       	ret

000040d8 <rprintfChar>:

// *** rprintfChar ***
// send a character/byte to the current output device
void rprintfChar(unsigned char c)
{
    40d8:	1f 93       	push	r17
    40da:	18 2f       	mov	r17, r24
	// do LF -> CR/LF translation
	if(c == '\n')
    40dc:	8a 30       	cpi	r24, 0x0A	; 10
    40de:	31 f4       	brne	.+12     	; 0x40ec <rprintfChar+0x14>
		rputchar('\r');
    40e0:	e0 91 66 11 	lds	r30, 0x1166
    40e4:	f0 91 67 11 	lds	r31, 0x1167
    40e8:	8d e0       	ldi	r24, 0x0D	; 13
    40ea:	09 95       	icall
	// send character
	rputchar(c);
    40ec:	e0 91 66 11 	lds	r30, 0x1166
    40f0:	f0 91 67 11 	lds	r31, 0x1167
    40f4:	81 2f       	mov	r24, r17
    40f6:	09 95       	icall
}
    40f8:	1f 91       	pop	r17
    40fa:	08 95       	ret

000040fc <rprintfStr>:

// *** rprintfStr ***
// prints a null-terminated string stored in RAM
void rprintfStr(char str[])
{
    40fc:	cf 93       	push	r28
    40fe:	df 93       	push	r29
    4100:	ec 01       	movw	r28, r24
	// send a string stored in RAM
	// check to make sure we have a good pointer
	if (!str) return;
    4102:	00 97       	sbiw	r24, 0x00	; 0
    4104:	21 f4       	brne	.+8      	; 0x410e <rprintfStr+0x12>
    4106:	06 c0       	rjmp	.+12     	; 0x4114 <rprintfStr+0x18>

	// print the string until a null-terminator
	while (*str)
		rprintfChar(*str++);
    4108:	21 96       	adiw	r28, 0x01	; 1
    410a:	0e 94 6c 20 	call	0x40d8	; 0x40d8 <rprintfChar>
	// send a string stored in RAM
	// check to make sure we have a good pointer
	if (!str) return;

	// print the string until a null-terminator
	while (*str)
    410e:	88 81       	ld	r24, Y
    4110:	88 23       	and	r24, r24
    4112:	d1 f7       	brne	.-12     	; 0x4108 <rprintfStr+0xc>
		rprintfChar(*str++);
}
    4114:	df 91       	pop	r29
    4116:	cf 91       	pop	r28
    4118:	08 95       	ret

0000411a <rprintfStrLen>:
// *** rprintfStrLen ***
// prints a section of a string stored in RAM
// begins printing at position indicated by <start>
// prints number of characters indicated by <len>
void rprintfStrLen(char str[], unsigned int start, unsigned int len)
{
    411a:	ef 92       	push	r14
    411c:	ff 92       	push	r15
    411e:	0f 93       	push	r16
    4120:	1f 93       	push	r17
    4122:	cf 93       	push	r28
    4124:	df 93       	push	r29
    4126:	8c 01       	movw	r16, r24
    4128:	7a 01       	movw	r14, r20
	register int i=0;

	// check to make sure we have a good pointer
	if (!str) return;
    412a:	00 97       	sbiw	r24, 0x00	; 0
    412c:	e9 f0       	breq	.+58     	; 0x4168 <rprintfStrLen+0x4e>
    412e:	20 e0       	ldi	r18, 0x00	; 0
    4130:	30 e0       	ldi	r19, 0x00	; 0
	// spin through characters up to requested start
	// keep going as long as there's no null
	while((i++<start) && (*str++));
    4132:	26 17       	cp	r18, r22
    4134:	37 07       	cpc	r19, r23
    4136:	38 f4       	brcc	.+14     	; 0x4146 <rprintfStrLen+0x2c>
    4138:	f8 01       	movw	r30, r16
    413a:	81 91       	ld	r24, Z+
    413c:	8f 01       	movw	r16, r30
    413e:	2f 5f       	subi	r18, 0xFF	; 255
    4140:	3f 4f       	sbci	r19, 0xFF	; 255
    4142:	88 23       	and	r24, r24
    4144:	b1 f7       	brne	.-20     	; 0x4132 <rprintfStrLen+0x18>
    4146:	c0 e0       	ldi	r28, 0x00	; 0
    4148:	d0 e0       	ldi	r29, 0x00	; 0
    414a:	0b c0       	rjmp	.+22     	; 0x4162 <rprintfStrLen+0x48>
	// then print exactly len characters
	for(i=0; i<len; i++)
	{
		// print data out of the string as long as we haven't reached a null yet
		// at the null, start printing spaces
		if(*str)
    414c:	f8 01       	movw	r30, r16
    414e:	80 81       	ld	r24, Z
    4150:	88 23       	and	r24, r24
    4152:	19 f0       	breq	.+6      	; 0x415a <rprintfStrLen+0x40>
			rprintfChar(*str++);
    4154:	0f 5f       	subi	r16, 0xFF	; 255
    4156:	1f 4f       	sbci	r17, 0xFF	; 255
    4158:	01 c0       	rjmp	.+2      	; 0x415c <rprintfStrLen+0x42>
		else
			rprintfChar(' ');
    415a:	80 e2       	ldi	r24, 0x20	; 32
    415c:	0e 94 6c 20 	call	0x40d8	; 0x40d8 <rprintfChar>
//		// keep steping through string as long as there's no null
//		if(*str) str++;
//	}

	// then print exactly len characters
	for(i=0; i<len; i++)
    4160:	21 96       	adiw	r28, 0x01	; 1
    4162:	ce 15       	cp	r28, r14
    4164:	df 05       	cpc	r29, r15
    4166:	90 f3       	brcs	.-28     	; 0x414c <rprintfStrLen+0x32>
			rprintfChar(*str++);
		else
			rprintfChar(' ');
	}

}
    4168:	df 91       	pop	r29
    416a:	cf 91       	pop	r28
    416c:	1f 91       	pop	r17
    416e:	0f 91       	pop	r16
    4170:	ff 90       	pop	r15
    4172:	ef 90       	pop	r14
    4174:	08 95       	ret

00004176 <rprintfProgStr>:

// *** rprintfProgStr ***
// prints a null-terminated string stored in program ROM
void rprintfProgStr(const prog_char str[])
{
    4176:	cf 93       	push	r28
    4178:	df 93       	push	r29
    417a:	ec 01       	movw	r28, r24
	// print a string stored in program memory
	register char c;

	// check to make sure we have a good pointer
	if (!str) return;
    417c:	00 97       	sbiw	r24, 0x00	; 0
    417e:	19 f4       	brne	.+6      	; 0x4186 <rprintfProgStr+0x10>
    4180:	07 c0       	rjmp	.+14     	; 0x4190 <rprintfProgStr+0x1a>
	
	// print the string until the null-terminator
	while((c = pgm_read_byte(str++)))
		rprintfChar(c);
    4182:	0e 94 6c 20 	call	0x40d8	; 0x40d8 <rprintfChar>
    4186:	fe 01       	movw	r30, r28

	// check to make sure we have a good pointer
	if (!str) return;
	
	// print the string until the null-terminator
	while((c = pgm_read_byte(str++)))
    4188:	21 96       	adiw	r28, 0x01	; 1
    418a:	84 91       	lpm	r24, Z+
    418c:	88 23       	and	r24, r24
    418e:	c9 f7       	brne	.-14     	; 0x4182 <rprintfProgStr+0xc>
		rprintfChar(c);
}
    4190:	df 91       	pop	r29
    4192:	cf 91       	pop	r28
    4194:	08 95       	ret

00004196 <rprintfCRLF>:
void rprintfCRLF(void)
{
	// print CR/LF
	//rprintfChar('\r');
	// LF -> CR/LF translation built-in to rprintfChar()
	rprintfChar('\n');
    4196:	8a e0       	ldi	r24, 0x0A	; 10
    4198:	0e 94 6c 20 	call	0x40d8	; 0x40d8 <rprintfChar>
}
    419c:	08 95       	ret

0000419e <rprintfu04>:
//	char Character = data&0x0f;
//	if (Character>9)
//		Character+='A'-10;
//	else
//		Character+='0';
	rprintfChar(hexchar(data));
    419e:	e8 2f       	mov	r30, r24
    41a0:	f0 e0       	ldi	r31, 0x00	; 0
    41a2:	ef 70       	andi	r30, 0x0F	; 15
    41a4:	f0 70       	andi	r31, 0x00	; 0
    41a6:	e2 57       	subi	r30, 0x72	; 114
    41a8:	fe 4f       	sbci	r31, 0xFE	; 254
    41aa:	e4 91       	lpm	r30, Z+
    41ac:	8e 2f       	mov	r24, r30
    41ae:	0e 94 6c 20 	call	0x40d8	; 0x40d8 <rprintfChar>
}
    41b2:	08 95       	ret

000041b4 <rprintfu08>:

// *** rprintfu08 ***
// prints an unsigned 8-bit number in hex (2 digits)
void rprintfu08(unsigned char data)
{
    41b4:	1f 93       	push	r17
    41b6:	18 2f       	mov	r17, r24
	// print 8-bit hex value
	rprintfu04(data>>4);
    41b8:	82 95       	swap	r24
    41ba:	8f 70       	andi	r24, 0x0F	; 15
    41bc:	0e 94 cf 20 	call	0x419e	; 0x419e <rprintfu04>
	rprintfu04(data);
    41c0:	81 2f       	mov	r24, r17
    41c2:	0e 94 cf 20 	call	0x419e	; 0x419e <rprintfu04>
}
    41c6:	1f 91       	pop	r17
    41c8:	08 95       	ret

000041ca <rprintfu16>:

// *** rprintfu16 ***
// prints an unsigned 16-bit number in hex (4 digits)
void rprintfu16(unsigned short data)
{
    41ca:	1f 93       	push	r17
    41cc:	18 2f       	mov	r17, r24
	// print 16-bit hex value
	rprintfu08(data>>8);
    41ce:	89 2f       	mov	r24, r25
    41d0:	0e 94 da 20 	call	0x41b4	; 0x41b4 <rprintfu08>
	rprintfu08(data);
    41d4:	81 2f       	mov	r24, r17
    41d6:	0e 94 da 20 	call	0x41b4	; 0x41b4 <rprintfu08>
}
    41da:	1f 91       	pop	r17
    41dc:	08 95       	ret

000041de <rprintfu32>:

// *** rprintfu32 ***
// prints an unsigned 32-bit number in hex (8 digits)
void rprintfu32(unsigned long data)
{
    41de:	ef 92       	push	r14
    41e0:	ff 92       	push	r15
    41e2:	0f 93       	push	r16
    41e4:	1f 93       	push	r17
    41e6:	7b 01       	movw	r14, r22
    41e8:	8c 01       	movw	r16, r24
	// print 32-bit hex value
	rprintfu16(data>>16);
    41ea:	c8 01       	movw	r24, r16
    41ec:	aa 27       	eor	r26, r26
    41ee:	bb 27       	eor	r27, r27
    41f0:	0e 94 e5 20 	call	0x41ca	; 0x41ca <rprintfu16>
	rprintfu16(data);
    41f4:	c7 01       	movw	r24, r14
    41f6:	0e 94 e5 20 	call	0x41ca	; 0x41ca <rprintfu16>
}
    41fa:	1f 91       	pop	r17
    41fc:	0f 91       	pop	r16
    41fe:	ff 90       	pop	r15
    4200:	ef 90       	pop	r14
    4202:	08 95       	ret

00004204 <rprintfNum>:
//	Examples:
//	uartPrintfNum(10, 6,  TRUE, ' ',   1234);  -->  " +1234"
//	uartPrintfNum(10, 6, FALSE, '0',   1234);  -->  "001234"
//	uartPrintfNum(16, 6, FALSE, '.', 0x5AA5);  -->  "..5AA5"
void rprintfNum(char base, char numDigits, char isSigned, char padchar, long n)
{
    4204:	2f 92       	push	r2
    4206:	3f 92       	push	r3
    4208:	4f 92       	push	r4
    420a:	5f 92       	push	r5
    420c:	6f 92       	push	r6
    420e:	7f 92       	push	r7
    4210:	8f 92       	push	r8
    4212:	9f 92       	push	r9
    4214:	af 92       	push	r10
    4216:	bf 92       	push	r11
    4218:	cf 92       	push	r12
    421a:	df 92       	push	r13
    421c:	ef 92       	push	r14
    421e:	ff 92       	push	r15
    4220:	0f 93       	push	r16
    4222:	1f 93       	push	r17
    4224:	df 93       	push	r29
    4226:	cf 93       	push	r28
    4228:	cd b7       	in	r28, 0x3d	; 61
    422a:	de b7       	in	r29, 0x3e	; 62
    422c:	a3 97       	sbiw	r28, 0x23	; 35
    422e:	0f b6       	in	r0, 0x3f	; 63
    4230:	f8 94       	cli
    4232:	de bf       	out	0x3e, r29	; 62
    4234:	0f be       	out	0x3f, r0	; 63
    4236:	cd bf       	out	0x3d, r28	; 61
    4238:	6a a3       	std	Y+34, r22	; 0x22
    423a:	24 2e       	mov	r2, r20
    423c:	2b a3       	std	Y+35, r18	; 0x23
    423e:	37 01       	movw	r6, r14
    4240:	48 01       	movw	r8, r16
	char *p, buf[32];
	unsigned long x;
	unsigned char count;

	// prepare negative number
	if( isSigned && (n < 0) )
    4242:	44 23       	and	r20, r20
    4244:	51 f0       	breq	.+20     	; 0x425a <rprintfNum+0x56>
    4246:	17 ff       	sbrs	r17, 7
    4248:	08 c0       	rjmp	.+16     	; 0x425a <rprintfNum+0x56>
	{
		x = -n;
    424a:	ee 24       	eor	r14, r14
    424c:	ff 24       	eor	r15, r15
    424e:	87 01       	movw	r16, r14
    4250:	e6 18       	sub	r14, r6
    4252:	f7 08       	sbc	r15, r7
    4254:	08 09       	sbc	r16, r8
    4256:	19 09       	sbc	r17, r9
    4258:	02 c0       	rjmp	.+4      	; 0x425e <rprintfNum+0x5a>
	}
	else
	{
	 	x = n;
    425a:	84 01       	movw	r16, r8
    425c:	73 01       	movw	r14, r6
	}

	// setup little string buffer
	count = (numDigits-1)-(isSigned?1:0);
    425e:	2a a1       	ldd	r18, Y+34	; 0x22
    4260:	21 50       	subi	r18, 0x01	; 1
    4262:	90 e0       	ldi	r25, 0x00	; 0
    4264:	21 10       	cpse	r2, r1
    4266:	91 e0       	ldi	r25, 0x01	; 1
    4268:	29 1b       	sub	r18, r25
    426a:	29 a3       	std	Y+33, r18	; 0x21
  	p = buf + sizeof (buf);
  	*--p = '\0';
    426c:	18 a2       	std	Y+32, r1	; 0x20
	
	// force calculation of first digit
	// (to prevent zero from not printing at all!!!)
	*--p = hexchar(x%base); x /= base;
    426e:	a8 2e       	mov	r10, r24
    4270:	bb 24       	eor	r11, r11
    4272:	cc 24       	eor	r12, r12
    4274:	dd 24       	eor	r13, r13
    4276:	c8 01       	movw	r24, r16
    4278:	b7 01       	movw	r22, r14
    427a:	a6 01       	movw	r20, r12
    427c:	95 01       	movw	r18, r10
    427e:	0e 94 01 28 	call	0x5002	; 0x5002 <__udivmodsi4>
    4282:	fb 01       	movw	r30, r22
    4284:	ef 70       	andi	r30, 0x0F	; 15
    4286:	f0 70       	andi	r31, 0x00	; 0
    4288:	e2 57       	subi	r30, 0x72	; 114
    428a:	fe 4f       	sbci	r31, 0xFE	; 254
    428c:	64 91       	lpm	r22, Z+
    428e:	6f 8f       	std	Y+31, r22	; 0x1f
    4290:	c8 01       	movw	r24, r16
    4292:	b7 01       	movw	r22, r14
    4294:	a6 01       	movw	r20, r12
    4296:	95 01       	movw	r18, r10
    4298:	0e 94 01 28 	call	0x5002	; 0x5002 <__udivmodsi4>
    429c:	c9 01       	movw	r24, r18
    429e:	da 01       	movw	r26, r20
    42a0:	7c 01       	movw	r14, r24
    42a2:	8d 01       	movw	r16, r26
    42a4:	9e e1       	ldi	r25, 0x1E	; 30
    42a6:	49 2e       	mov	r4, r25
    42a8:	51 2c       	mov	r5, r1
    42aa:	4c 0e       	add	r4, r28
    42ac:	5d 1e       	adc	r5, r29
    42ae:	39 a0       	ldd	r3, Y+33	; 0x21
    42b0:	25 c0       	rjmp	.+74     	; 0x42fc <rprintfNum+0xf8>
	// calculate remaining digits
	while(count--)
	{
		if(x != 0)
    42b2:	e1 14       	cp	r14, r1
    42b4:	f1 04       	cpc	r15, r1
    42b6:	01 05       	cpc	r16, r1
    42b8:	11 05       	cpc	r17, r1
    42ba:	c9 f0       	breq	.+50     	; 0x42ee <rprintfNum+0xea>
		{
			// calculate next digit
			*--p = hexchar(x%base); x /= base;
    42bc:	c8 01       	movw	r24, r16
    42be:	b7 01       	movw	r22, r14
    42c0:	a6 01       	movw	r20, r12
    42c2:	95 01       	movw	r18, r10
    42c4:	0e 94 01 28 	call	0x5002	; 0x5002 <__udivmodsi4>
    42c8:	fb 01       	movw	r30, r22
    42ca:	ef 70       	andi	r30, 0x0F	; 15
    42cc:	f0 70       	andi	r31, 0x00	; 0
    42ce:	e2 57       	subi	r30, 0x72	; 114
    42d0:	fe 4f       	sbci	r31, 0xFE	; 254
    42d2:	64 91       	lpm	r22, Z+
    42d4:	f2 01       	movw	r30, r4
    42d6:	60 83       	st	Z, r22
    42d8:	c8 01       	movw	r24, r16
    42da:	b7 01       	movw	r22, r14
    42dc:	a6 01       	movw	r20, r12
    42de:	95 01       	movw	r18, r10
    42e0:	0e 94 01 28 	call	0x5002	; 0x5002 <__udivmodsi4>
    42e4:	c9 01       	movw	r24, r18
    42e6:	da 01       	movw	r26, r20
    42e8:	7c 01       	movw	r14, r24
    42ea:	8d 01       	movw	r16, r26
    42ec:	03 c0       	rjmp	.+6      	; 0x42f4 <rprintfNum+0xf0>
		}
		else
		{
			// no more digits left, pad out to desired length
			*--p = padchar;
    42ee:	2b a1       	ldd	r18, Y+35	; 0x23
    42f0:	f2 01       	movw	r30, r4
    42f2:	20 83       	st	Z, r18
    42f4:	3a 94       	dec	r3
    42f6:	08 94       	sec
    42f8:	41 08       	sbc	r4, r1
    42fa:	51 08       	sbc	r5, r1
	
	// force calculation of first digit
	// (to prevent zero from not printing at all!!!)
	*--p = hexchar(x%base); x /= base;
	// calculate remaining digits
	while(count--)
    42fc:	33 20       	and	r3, r3
    42fe:	c9 f6       	brne	.-78     	; 0x42b2 <rprintfNum+0xae>
    4300:	ce 01       	movw	r24, r28
    4302:	4f 96       	adiw	r24, 0x1f	; 31
    4304:	8c 01       	movw	r16, r24
    4306:	e9 a1       	ldd	r30, Y+33	; 0x21
    4308:	0e 1b       	sub	r16, r30
    430a:	11 09       	sbc	r17, r1
			*--p = padchar;
		}
	}

	// apply signed notation if requested
	if( isSigned )
    430c:	22 20       	and	r2, r2
    430e:	f1 f0       	breq	.+60     	; 0x434c <rprintfNum+0x148>
	{
		if(n < 0)
    4310:	97 fe       	sbrs	r9, 7
    4312:	05 c0       	rjmp	.+10     	; 0x431e <rprintfNum+0x11a>
		{
   			*--p = '-';
    4314:	8d e2       	ldi	r24, 0x2D	; 45
    4316:	f8 01       	movw	r30, r16
    4318:	82 93       	st	-Z, r24
    431a:	8f 01       	movw	r16, r30
    431c:	17 c0       	rjmp	.+46     	; 0x434c <rprintfNum+0x148>
    431e:	c8 01       	movw	r24, r16
    4320:	01 97       	sbiw	r24, 0x01	; 1
		}
		else if(n > 0)
    4322:	61 14       	cp	r6, r1
    4324:	71 04       	cpc	r7, r1
    4326:	81 04       	cpc	r8, r1
    4328:	91 04       	cpc	r9, r1
    432a:	19 f0       	breq	.+6      	; 0x4332 <rprintfNum+0x12e>
		{
	   		*--p = '+';
    432c:	8c 01       	movw	r16, r24
    432e:	8b e2       	ldi	r24, 0x2B	; 43
    4330:	02 c0       	rjmp	.+4      	; 0x4336 <rprintfNum+0x132>
		}
		else
		{
	   		*--p = ' ';
    4332:	8c 01       	movw	r16, r24
    4334:	80 e2       	ldi	r24, 0x20	; 32
    4336:	f8 01       	movw	r30, r16
    4338:	80 83       	st	Z, r24
    433a:	08 c0       	rjmp	.+16     	; 0x434c <rprintfNum+0x148>

	// print the string right-justified
	count = numDigits;
	while(count--)
	{
		rprintfChar(*p++);
    433c:	f8 01       	movw	r30, r16
    433e:	81 91       	ld	r24, Z+
    4340:	8f 01       	movw	r16, r30
    4342:	0e 94 6c 20 	call	0x40d8	; 0x40d8 <rprintfChar>
    4346:	fa a1       	ldd	r31, Y+34	; 0x22
    4348:	f1 50       	subi	r31, 0x01	; 1
    434a:	fa a3       	std	Y+34, r31	; 0x22
		}
	}

	// print the string right-justified
	count = numDigits;
	while(count--)
    434c:	2a a1       	ldd	r18, Y+34	; 0x22
    434e:	22 23       	and	r18, r18
    4350:	a9 f7       	brne	.-22     	; 0x433c <rprintfNum+0x138>
	{
		rprintfChar(*p++);
	}
}
    4352:	a3 96       	adiw	r28, 0x23	; 35
    4354:	0f b6       	in	r0, 0x3f	; 63
    4356:	f8 94       	cli
    4358:	de bf       	out	0x3e, r29	; 62
    435a:	0f be       	out	0x3f, r0	; 63
    435c:	cd bf       	out	0x3d, r28	; 61
    435e:	cf 91       	pop	r28
    4360:	df 91       	pop	r29
    4362:	1f 91       	pop	r17
    4364:	0f 91       	pop	r16
    4366:	ff 90       	pop	r15
    4368:	ef 90       	pop	r14
    436a:	df 90       	pop	r13
    436c:	cf 90       	pop	r12
    436e:	bf 90       	pop	r11
    4370:	af 90       	pop	r10
    4372:	9f 90       	pop	r9
    4374:	8f 90       	pop	r8
    4376:	7f 90       	pop	r7
    4378:	6f 90       	pop	r6
    437a:	5f 90       	pop	r5
    437c:	4f 90       	pop	r4
    437e:	3f 90       	pop	r3
    4380:	2f 90       	pop	r2
    4382:	08 95       	ret

00004384 <rprintfFloat>:

#ifdef RPRINTF_FLOAT
// *** rprintfFloat ***
// floating-point print
void rprintfFloat(char numDigits, double x)
{
    4384:	4f 92       	push	r4
    4386:	5f 92       	push	r5
    4388:	6f 92       	push	r6
    438a:	7f 92       	push	r7
    438c:	8f 92       	push	r8
    438e:	9f 92       	push	r9
    4390:	af 92       	push	r10
    4392:	bf 92       	push	r11
    4394:	cf 92       	push	r12
    4396:	df 92       	push	r13
    4398:	ef 92       	push	r14
    439a:	ff 92       	push	r15
    439c:	0f 93       	push	r16
    439e:	1f 93       	push	r17
    43a0:	cf 93       	push	r28
    43a2:	df 93       	push	r29
    43a4:	48 2e       	mov	r4, r24
    43a6:	5a 01       	movw	r10, r20
    43a8:	6b 01       	movw	r12, r22
	double place = 1.0;
	
	// save sign
	negative = (x<0);
	// convert to absolute value
	x = (x>0)?(x):(-x);
    43aa:	cb 01       	movw	r24, r22
    43ac:	ba 01       	movw	r22, r20
    43ae:	20 e0       	ldi	r18, 0x00	; 0
    43b0:	30 e0       	ldi	r19, 0x00	; 0
    43b2:	40 e0       	ldi	r20, 0x00	; 0
    43b4:	50 e0       	ldi	r21, 0x00	; 0
    43b6:	0e 94 73 27 	call	0x4ee6	; 0x4ee6 <__gesf2>
    43ba:	18 16       	cp	r1, r24
    43bc:	1c f4       	brge	.+6      	; 0x43c4 <rprintfFloat+0x40>
    43be:	35 01       	movw	r6, r10
    43c0:	46 01       	movw	r8, r12
    43c2:	06 c0       	rjmp	.+12     	; 0x43d0 <rprintfFloat+0x4c>
    43c4:	35 01       	movw	r6, r10
    43c6:	46 01       	movw	r8, r12
    43c8:	97 fa       	bst	r9, 7
    43ca:	90 94       	com	r9
    43cc:	97 f8       	bld	r9, 7
    43ce:	90 94       	com	r9
    43d0:	0f 2e       	mov	r0, r31
    43d2:	f0 e0       	ldi	r31, 0x00	; 0
    43d4:	ef 2e       	mov	r14, r31
    43d6:	f0 e0       	ldi	r31, 0x00	; 0
    43d8:	ff 2e       	mov	r15, r31
    43da:	f0 e8       	ldi	r31, 0x80	; 128
    43dc:	0f 2f       	mov	r16, r31
    43de:	ff e3       	ldi	r31, 0x3F	; 63
    43e0:	1f 2f       	mov	r17, r31
    43e2:	f0 2d       	mov	r31, r0
    43e4:	55 24       	eor	r5, r5
	
	// find starting digit place
	for(i=0; i<15; i++)
	{
		if((x/place) < 10.0)
    43e6:	c4 01       	movw	r24, r8
    43e8:	b3 01       	movw	r22, r6
    43ea:	a8 01       	movw	r20, r16
    43ec:	97 01       	movw	r18, r14
    43ee:	0e 94 2d 26 	call	0x4c5a	; 0x4c5a <__divsf3>
    43f2:	20 e0       	ldi	r18, 0x00	; 0
    43f4:	30 e0       	ldi	r19, 0x00	; 0
    43f6:	40 e2       	ldi	r20, 0x20	; 32
    43f8:	51 e4       	ldi	r21, 0x41	; 65
    43fa:	0e 94 29 26 	call	0x4c52	; 0x4c52 <__cmpsf2>
    43fe:	87 fd       	sbrc	r24, 7
    4400:	0e c0       	rjmp	.+28     	; 0x441e <rprintfFloat+0x9a>
			break;
		else
			place *= 10.0;
    4402:	c8 01       	movw	r24, r16
    4404:	b7 01       	movw	r22, r14
    4406:	20 e0       	ldi	r18, 0x00	; 0
    4408:	30 e0       	ldi	r19, 0x00	; 0
    440a:	40 e2       	ldi	r20, 0x20	; 32
    440c:	51 e4       	ldi	r21, 0x41	; 65
    440e:	0e 94 77 27 	call	0x4eee	; 0x4eee <__mulsf3>
    4412:	7b 01       	movw	r14, r22
    4414:	8c 01       	movw	r16, r24
	negative = (x<0);
	// convert to absolute value
	x = (x>0)?(x):(-x);
	
	// find starting digit place
	for(i=0; i<15; i++)
    4416:	53 94       	inc	r5
    4418:	8f e0       	ldi	r24, 0x0F	; 15
    441a:	58 16       	cp	r5, r24
    441c:	21 f7       	brne	.-56     	; 0x43e6 <rprintfFloat+0x62>
			break;
		else
			place *= 10.0;
	}
	// print polarity character
	if(negative)
    441e:	c6 01       	movw	r24, r12
    4420:	b5 01       	movw	r22, r10
    4422:	20 e0       	ldi	r18, 0x00	; 0
    4424:	30 e0       	ldi	r19, 0x00	; 0
    4426:	40 e0       	ldi	r20, 0x00	; 0
    4428:	50 e0       	ldi	r21, 0x00	; 0
    442a:	0e 94 29 26 	call	0x4c52	; 0x4c52 <__cmpsf2>
    442e:	88 23       	and	r24, r24
    4430:	14 f4       	brge	.+4      	; 0x4436 <rprintfFloat+0xb2>
		rprintfChar('-');
    4432:	8d e2       	ldi	r24, 0x2D	; 45
    4434:	01 c0       	rjmp	.+2      	; 0x4438 <rprintfFloat+0xb4>
	else
		rprintfChar('+');
    4436:	8b e2       	ldi	r24, 0x2B	; 43
    4438:	0e 94 6c 20 	call	0x40d8	; 0x40d8 <rprintfChar>
    443c:	dd 24       	eor	r13, r13
    443e:	aa 24       	eor	r10, r10
    4440:	56 c0       	rjmp	.+172    	; 0x44ee <rprintfFloat+0x16a>

	// print digits
	for(i=0; i<numDigits; i++)
	{
		digit = (x/place);
    4442:	c4 01       	movw	r24, r8
    4444:	b3 01       	movw	r22, r6
    4446:	a8 01       	movw	r20, r16
    4448:	97 01       	movw	r18, r14
    444a:	0e 94 2d 26 	call	0x4c5a	; 0x4c5a <__divsf3>
    444e:	0e 94 95 26 	call	0x4d2a	; 0x4d2a <__fixunssfsi>
    4452:	b6 2e       	mov	r11, r22

		if(digit | firstplace | (place == 1.0))
    4454:	d6 2a       	or	r13, r22
    4456:	cd 2d       	mov	r28, r13
    4458:	d0 e0       	ldi	r29, 0x00	; 0
    445a:	cc 24       	eor	r12, r12
    445c:	dd 24       	eor	r13, r13
    445e:	c8 01       	movw	r24, r16
    4460:	b7 01       	movw	r22, r14
    4462:	20 e0       	ldi	r18, 0x00	; 0
    4464:	30 e0       	ldi	r19, 0x00	; 0
    4466:	40 e8       	ldi	r20, 0x80	; 128
    4468:	5f e3       	ldi	r21, 0x3F	; 63
    446a:	0e 94 29 26 	call	0x4c52	; 0x4c52 <__cmpsf2>
    446e:	88 23       	and	r24, r24
    4470:	19 f4       	brne	.+6      	; 0x4478 <rprintfFloat+0xf4>
    4472:	21 e0       	ldi	r18, 0x01	; 1
    4474:	c2 2e       	mov	r12, r18
    4476:	d1 2c       	mov	r13, r1
    4478:	cc 29       	or	r28, r12
    447a:	dd 29       	or	r29, r13
    447c:	cd 2b       	or	r28, r29
    447e:	39 f0       	breq	.+14     	; 0x448e <rprintfFloat+0x10a>
		{
			firstplace = TRUE;
			rprintfChar(digit+0x30);
    4480:	8b 2d       	mov	r24, r11
    4482:	80 5d       	subi	r24, 0xD0	; 208
    4484:	0e 94 6c 20 	call	0x40d8	; 0x40d8 <rprintfChar>
    4488:	dd 24       	eor	r13, r13
    448a:	da 94       	dec	r13
    448c:	04 c0       	rjmp	.+8      	; 0x4496 <rprintfFloat+0x112>
		}
		else
			rprintfChar(' ');
    448e:	80 e2       	ldi	r24, 0x20	; 32
    4490:	0e 94 6c 20 	call	0x40d8	; 0x40d8 <rprintfChar>
    4494:	dd 24       	eor	r13, r13
		
		if(place == 1.0)
    4496:	c8 01       	movw	r24, r16
    4498:	b7 01       	movw	r22, r14
    449a:	20 e0       	ldi	r18, 0x00	; 0
    449c:	30 e0       	ldi	r19, 0x00	; 0
    449e:	40 e8       	ldi	r20, 0x80	; 128
    44a0:	5f e3       	ldi	r21, 0x3F	; 63
    44a2:	0e 94 29 26 	call	0x4c52	; 0x4c52 <__cmpsf2>
    44a6:	88 23       	and	r24, r24
    44a8:	19 f4       	brne	.+6      	; 0x44b0 <rprintfFloat+0x12c>
		{
			rprintfChar('.');
    44aa:	8e e2       	ldi	r24, 0x2E	; 46
    44ac:	0e 94 6c 20 	call	0x40d8	; 0x40d8 <rprintfChar>
		}
		
		x -= (digit*place);
    44b0:	6b 2d       	mov	r22, r11
    44b2:	70 e0       	ldi	r23, 0x00	; 0
    44b4:	88 27       	eor	r24, r24
    44b6:	77 fd       	sbrc	r23, 7
    44b8:	80 95       	com	r24
    44ba:	98 2f       	mov	r25, r24
    44bc:	0e 94 c3 26 	call	0x4d86	; 0x4d86 <__floatsisf>
    44c0:	a8 01       	movw	r20, r16
    44c2:	97 01       	movw	r18, r14
    44c4:	0e 94 77 27 	call	0x4eee	; 0x4eee <__mulsf3>
    44c8:	9b 01       	movw	r18, r22
    44ca:	ac 01       	movw	r20, r24
    44cc:	c4 01       	movw	r24, r8
    44ce:	b3 01       	movw	r22, r6
    44d0:	0e 94 c4 25 	call	0x4b88	; 0x4b88 <__subsf3>
    44d4:	3b 01       	movw	r6, r22
    44d6:	4c 01       	movw	r8, r24
		place /= 10.0;
    44d8:	c8 01       	movw	r24, r16
    44da:	b7 01       	movw	r22, r14
    44dc:	20 e0       	ldi	r18, 0x00	; 0
    44de:	30 e0       	ldi	r19, 0x00	; 0
    44e0:	40 e2       	ldi	r20, 0x20	; 32
    44e2:	51 e4       	ldi	r21, 0x41	; 65
    44e4:	0e 94 2d 26 	call	0x4c5a	; 0x4c5a <__divsf3>
    44e8:	7b 01       	movw	r14, r22
    44ea:	8c 01       	movw	r16, r24
		rprintfChar('-');
	else
		rprintfChar('+');

	// print digits
	for(i=0; i<numDigits; i++)
    44ec:	a3 94       	inc	r10
    44ee:	a4 14       	cp	r10, r4
    44f0:	08 f4       	brcc	.+2      	; 0x44f4 <rprintfFloat+0x170>
    44f2:	a7 cf       	rjmp	.-178    	; 0x4442 <rprintfFloat+0xbe>
		}
		
		x -= (digit*place);
		place /= 10.0;
	}
}
    44f4:	df 91       	pop	r29
    44f6:	cf 91       	pop	r28
    44f8:	1f 91       	pop	r17
    44fa:	0f 91       	pop	r16
    44fc:	ff 90       	pop	r15
    44fe:	ef 90       	pop	r14
    4500:	df 90       	pop	r13
    4502:	cf 90       	pop	r12
    4504:	bf 90       	pop	r11
    4506:	af 90       	pop	r10
    4508:	9f 90       	pop	r9
    450a:	8f 90       	pop	r8
    450c:	7f 90       	pop	r7
    450e:	6f 90       	pop	r6
    4510:	5f 90       	pop	r5
    4512:	4f 90       	pop	r4
    4514:	08 95       	ret

00004516 <rprintf1RamRom>:
// Supports:
// %d - decimal
// %x - hex
// %c - character
int rprintf1RamRom(unsigned char stringInRom, const char *format, ...)
{
    4516:	7f 92       	push	r7
    4518:	8f 92       	push	r8
    451a:	9f 92       	push	r9
    451c:	af 92       	push	r10
    451e:	bf 92       	push	r11
    4520:	cf 92       	push	r12
    4522:	df 92       	push	r13
    4524:	ef 92       	push	r14
    4526:	ff 92       	push	r15
    4528:	0f 93       	push	r16
    452a:	1f 93       	push	r17
    452c:	df 93       	push	r29
    452e:	cf 93       	push	r28
    4530:	cd b7       	in	r28, 0x3d	; 61
    4532:	de b7       	in	r29, 0x3e	; 62
    4534:	78 88       	ldd	r7, Y+16	; 0x10
    4536:	c9 88       	ldd	r12, Y+17	; 0x11
    4538:	da 88       	ldd	r13, Y+18	; 0x12
    453a:	63 e1       	ldi	r22, 0x13	; 19
    453c:	e6 2e       	mov	r14, r22
    453e:	f1 2c       	mov	r15, r1
    4540:	ec 0e       	add	r14, r28
    4542:	fd 1e       	adc	r15, r29
    4544:	14 c0       	rjmp	.+40     	; 0x456e <rprintf1RamRom+0x58>
	va_start(ap, format);
	for (;;)
	{
		while ((format_flag = READMEMBYTE(stringInRom,format++) ) != '%')
		{	// Until '%' or '\0'
			if (!format_flag)
    4546:	88 23       	and	r24, r24
    4548:	81 f4       	brne	.+32     	; 0x456a <rprintf1RamRom+0x54>
				div_val /= base;
			} while (div_val);
		}
	}
	va_end(ap);
}
    454a:	80 e0       	ldi	r24, 0x00	; 0
    454c:	90 e0       	ldi	r25, 0x00	; 0
    454e:	cf 91       	pop	r28
    4550:	df 91       	pop	r29
    4552:	1f 91       	pop	r17
    4554:	0f 91       	pop	r16
    4556:	ff 90       	pop	r15
    4558:	ef 90       	pop	r14
    455a:	df 90       	pop	r13
    455c:	cf 90       	pop	r12
    455e:	bf 90       	pop	r11
    4560:	af 90       	pop	r10
    4562:	9f 90       	pop	r9
    4564:	8f 90       	pop	r8
    4566:	7f 90       	pop	r7
    4568:	08 95       	ret
			if (!format_flag)
			{
				va_end(ap);
				return(0);
			}
			rprintfChar(format_flag);
    456a:	0e 94 6c 20 	call	0x40d8	; 0x40d8 <rprintfChar>
    456e:	96 01       	movw	r18, r12
    4570:	2f 5f       	subi	r18, 0xFF	; 255
    4572:	3f 4f       	sbci	r19, 0xFF	; 255
	va_list ap;

	va_start(ap, format);
	for (;;)
	{
		while ((format_flag = READMEMBYTE(stringInRom,format++) ) != '%')
    4574:	77 20       	and	r7, r7
    4576:	21 f0       	breq	.+8      	; 0x4580 <rprintf1RamRom+0x6a>
    4578:	f6 01       	movw	r30, r12
    457a:	69 01       	movw	r12, r18
    457c:	84 91       	lpm	r24, Z+
    457e:	03 c0       	rjmp	.+6      	; 0x4586 <rprintf1RamRom+0x70>
    4580:	f6 01       	movw	r30, r12
    4582:	80 81       	ld	r24, Z
    4584:	69 01       	movw	r12, r18
    4586:	85 32       	cpi	r24, 0x25	; 37
    4588:	f1 f6       	brne	.-68     	; 0x4546 <rprintf1RamRom+0x30>
    458a:	2f 5f       	subi	r18, 0xFF	; 255
    458c:	3f 4f       	sbci	r19, 0xFF	; 255
				return(0);
			}
			rprintfChar(format_flag);
		}

		switch (format_flag = READMEMBYTE(stringInRom,format++) )
    458e:	77 20       	and	r7, r7
    4590:	21 f0       	breq	.+8      	; 0x459a <rprintf1RamRom+0x84>
    4592:	f6 01       	movw	r30, r12
    4594:	69 01       	movw	r12, r18
    4596:	84 91       	lpm	r24, Z+
    4598:	03 c0       	rjmp	.+6      	; 0x45a0 <rprintf1RamRom+0x8a>
    459a:	f6 01       	movw	r30, r12
    459c:	80 81       	ld	r24, Z
    459e:	69 01       	movw	r12, r18
    45a0:	84 36       	cpi	r24, 0x64	; 100
    45a2:	29 f0       	breq	.+10     	; 0x45ae <rprintf1RamRom+0x98>
    45a4:	88 37       	cpi	r24, 0x78	; 120
    45a6:	81 f0       	breq	.+32     	; 0x45c8 <rprintf1RamRom+0xb2>
    45a8:	83 36       	cpi	r24, 0x63	; 99
    45aa:	f9 f6       	brne	.-66     	; 0x456a <rprintf1RamRom+0x54>
    45ac:	06 c0       	rjmp	.+12     	; 0x45ba <rprintf1RamRom+0xa4>
    45ae:	00 e1       	ldi	r16, 0x10	; 16
    45b0:	17 e2       	ldi	r17, 0x27	; 39
    45b2:	5a e0       	ldi	r21, 0x0A	; 10
    45b4:	a5 2e       	mov	r10, r21
    45b6:	b1 2c       	mov	r11, r1
    45b8:	0c c0       	rjmp	.+24     	; 0x45d2 <rprintf1RamRom+0xbc>
		{
			case 'c': format_flag = va_arg(ap,int);
    45ba:	f7 01       	movw	r30, r14
    45bc:	80 81       	ld	r24, Z
    45be:	22 e0       	ldi	r18, 0x02	; 2
    45c0:	30 e0       	ldi	r19, 0x00	; 0
    45c2:	e2 0e       	add	r14, r18
    45c4:	f3 1e       	adc	r15, r19
    45c6:	d1 cf       	rjmp	.-94     	; 0x456a <rprintf1RamRom+0x54>
			default:  rprintfChar(format_flag); continue;
    45c8:	00 e0       	ldi	r16, 0x00	; 0
    45ca:	10 e1       	ldi	r17, 0x10	; 16
    45cc:	40 e1       	ldi	r20, 0x10	; 16
    45ce:	a4 2e       	mov	r10, r20
    45d0:	b1 2c       	mov	r11, r1
			case 'd': base = 10; div_val = 10000; goto CONVERSION_LOOP;
//			case 'x': base = 16; div_val = 0x10;
			case 'x': base = 16; div_val = 0x1000;

			CONVERSION_LOOP:
			u_val = va_arg(ap,int);
    45d2:	32 e0       	ldi	r19, 0x02	; 2
    45d4:	83 2e       	mov	r8, r19
    45d6:	91 2c       	mov	r9, r1
    45d8:	8e 0c       	add	r8, r14
    45da:	9f 1c       	adc	r9, r15
    45dc:	f7 01       	movw	r30, r14
    45de:	e0 80       	ld	r14, Z
    45e0:	f1 80       	ldd	r15, Z+1	; 0x01
			if (format_flag == 'd')
    45e2:	84 36       	cpi	r24, 0x64	; 100
    45e4:	b1 f4       	brne	.+44     	; 0x4612 <rprintf1RamRom+0xfc>
			{
				if (((int)u_val) < 0)
    45e6:	f7 fe       	sbrs	r15, 7
    45e8:	11 c0       	rjmp	.+34     	; 0x460c <rprintf1RamRom+0xf6>
				{
					u_val = - u_val;
    45ea:	f0 94       	com	r15
    45ec:	e1 94       	neg	r14
    45ee:	f1 08       	sbc	r15, r1
    45f0:	f3 94       	inc	r15
					rprintfChar('-');
    45f2:	8d e2       	ldi	r24, 0x2D	; 45
    45f4:	0e 94 6c 20 	call	0x40d8	; 0x40d8 <rprintfChar>
    45f8:	09 c0       	rjmp	.+18     	; 0x460c <rprintf1RamRom+0xf6>
				}
				while (div_val > 1 && div_val > u_val) div_val /= 10;
    45fa:	c8 01       	movw	r24, r16
    45fc:	6a e0       	ldi	r22, 0x0A	; 10
    45fe:	70 e0       	ldi	r23, 0x00	; 0
    4600:	0e 94 da 27 	call	0x4fb4	; 0x4fb4 <__udivmodhi4>
    4604:	8b 01       	movw	r16, r22
    4606:	62 30       	cpi	r22, 0x02	; 2
    4608:	71 05       	cpc	r23, r1
    460a:	18 f0       	brcs	.+6      	; 0x4612 <rprintf1RamRom+0xfc>
    460c:	e0 16       	cp	r14, r16
    460e:	f1 06       	cpc	r15, r17
    4610:	a0 f3       	brcs	.-24     	; 0x45fa <rprintf1RamRom+0xe4>
			}
			do
			{
				//rprintfChar(pgm_read_byte(HexChars+(u_val/div_val)));
				rprintfu04(u_val/div_val);
    4612:	c7 01       	movw	r24, r14
    4614:	b8 01       	movw	r22, r16
    4616:	0e 94 da 27 	call	0x4fb4	; 0x4fb4 <__udivmodhi4>
    461a:	86 2f       	mov	r24, r22
    461c:	0e 94 cf 20 	call	0x419e	; 0x419e <rprintfu04>
				u_val %= div_val;
    4620:	c7 01       	movw	r24, r14
    4622:	b8 01       	movw	r22, r16
    4624:	0e 94 da 27 	call	0x4fb4	; 0x4fb4 <__udivmodhi4>
    4628:	7c 01       	movw	r14, r24
				div_val /= base;
    462a:	c8 01       	movw	r24, r16
    462c:	b5 01       	movw	r22, r10
    462e:	0e 94 da 27 	call	0x4fb4	; 0x4fb4 <__udivmodhi4>
    4632:	8b 01       	movw	r16, r22
			} while (div_val);
    4634:	61 15       	cp	r22, r1
    4636:	71 05       	cpc	r23, r1
    4638:	61 f7       	brne	.-40     	; 0x4612 <rprintf1RamRom+0xfc>
    463a:	74 01       	movw	r14, r8
    463c:	98 cf       	rjmp	.-208    	; 0x456e <rprintf1RamRom+0x58>

0000463e <i2cSetBitrate>:
	// SCL freq = F_CPU/(16+2*TWBR))
	#ifdef TWPS0
		// for processors with additional bitrate division (mega128)
		// SCL freq = F_CPU/(16+2*TWBR*4^TWPS)
		// set TWPS to zero
		cbi(TWSR, TWPS0);
    463e:	20 91 b9 00 	lds	r18, 0x00B9
    4642:	2e 7f       	andi	r18, 0xFE	; 254
    4644:	20 93 b9 00 	sts	0x00B9, r18
		cbi(TWSR, TWPS1);
    4648:	20 91 b9 00 	lds	r18, 0x00B9
    464c:	2d 7f       	andi	r18, 0xFD	; 253
    464e:	20 93 b9 00 	sts	0x00B9, r18
	#endif
	// calculate bitrate division	
	bitrate_div = ((F_CPU/1000l)/bitrateKHz);
    4652:	9c 01       	movw	r18, r24
    4654:	40 e0       	ldi	r20, 0x00	; 0
    4656:	50 e0       	ldi	r21, 0x00	; 0
    4658:	60 e8       	ldi	r22, 0x80	; 128
    465a:	7e e3       	ldi	r23, 0x3E	; 62
    465c:	80 e0       	ldi	r24, 0x00	; 0
    465e:	90 e0       	ldi	r25, 0x00	; 0
    4660:	0e 94 23 28 	call	0x5046	; 0x5046 <__divmodsi4>
	if(bitrate_div >= 16)
    4664:	20 31       	cpi	r18, 0x10	; 16
    4666:	30 f0       	brcs	.+12     	; 0x4674 <i2cSetBitrate+0x36>
		bitrate_div = (bitrate_div-16)/2;
    4668:	82 2f       	mov	r24, r18
    466a:	90 e0       	ldi	r25, 0x00	; 0
    466c:	40 97       	sbiw	r24, 0x10	; 16
    466e:	95 95       	asr	r25
    4670:	87 95       	ror	r24
    4672:	28 2f       	mov	r18, r24
	outb(TWBR, bitrate_div);
    4674:	20 93 b8 00 	sts	0x00B8, r18
}
    4678:	08 95       	ret

0000467a <i2cInit>:

// functions
void i2cInit(void)
{
	// set pull-up resistors on I2C bus pins
	sbi(PORTD, 0);	// i2c SCL on 640
    467a:	58 9a       	sbi	0x0b, 0	; 11
	sbi(PORTD, 1);	// i2c SDA on 640
    467c:	59 9a       	sbi	0x0b, 1	; 11

	// clear SlaveReceive and SlaveTransmit handler to null
	i2cSlaveReceive = 0;
    467e:	10 92 af 11 	sts	0x11AF, r1
    4682:	10 92 ae 11 	sts	0x11AE, r1
	i2cSlaveTransmit = 0;
    4686:	10 92 b1 11 	sts	0x11B1, r1
    468a:	10 92 b0 11 	sts	0x11B0, r1
	// set i2c bit rate to 100KHz
	i2cSetBitrate(100);
    468e:	84 e6       	ldi	r24, 0x64	; 100
    4690:	90 e0       	ldi	r25, 0x00	; 0
    4692:	0e 94 1f 23 	call	0x463e	; 0x463e <i2cSetBitrate>
	// enable TWI (two-wire interface)
	sbi(TWCR, TWEN);
    4696:	ec eb       	ldi	r30, 0xBC	; 188
    4698:	f0 e0       	ldi	r31, 0x00	; 0
    469a:	80 81       	ld	r24, Z
    469c:	84 60       	ori	r24, 0x04	; 4
    469e:	80 83       	st	Z, r24
	// set state
	I2cState = I2C_IDLE;
    46a0:	10 92 68 11 	sts	0x1168, r1
	// enable TWI interrupt and slave address ACK
	sbi(TWCR, TWIE);
    46a4:	80 81       	ld	r24, Z
    46a6:	81 60       	ori	r24, 0x01	; 1
    46a8:	80 83       	st	Z, r24
	sbi(TWCR, TWEA);
    46aa:	80 81       	ld	r24, Z
    46ac:	80 64       	ori	r24, 0x40	; 64
    46ae:	80 83       	st	Z, r24
	//outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
	// enable interrupts
	sei();
    46b0:	78 94       	sei
}
    46b2:	08 95       	ret

000046b4 <i2cSetLocalDeviceAddr>:
}

void i2cSetLocalDeviceAddr(u08 deviceAddr, u08 genCallEn)
{
	// set local device address (used in slave mode only)
	outb(TWAR, ((deviceAddr&0xFE) | (genCallEn?1:0)) );
    46b4:	90 e0       	ldi	r25, 0x00	; 0
    46b6:	61 11       	cpse	r22, r1
    46b8:	91 e0       	ldi	r25, 0x01	; 1
    46ba:	8e 7f       	andi	r24, 0xFE	; 254
    46bc:	98 2b       	or	r25, r24
    46be:	90 93 ba 00 	sts	0x00BA, r25
}
    46c2:	08 95       	ret

000046c4 <i2cSetSlaveReceiveHandler>:

void i2cSetSlaveReceiveHandler(void (*i2cSlaveRx_func)(u08 receiveDataLength, u08* recieveData))
{
	i2cSlaveReceive = i2cSlaveRx_func;
    46c4:	90 93 af 11 	sts	0x11AF, r25
    46c8:	80 93 ae 11 	sts	0x11AE, r24
}
    46cc:	08 95       	ret

000046ce <i2cSetSlaveTransmitHandler>:

void i2cSetSlaveTransmitHandler(u08 (*i2cSlaveTx_func)(u08 transmitDataLengthMax, u08* transmitData))
{
	i2cSlaveTransmit = i2cSlaveTx_func;
    46ce:	90 93 b1 11 	sts	0x11B1, r25
    46d2:	80 93 b0 11 	sts	0x11B0, r24
}
    46d6:	08 95       	ret

000046d8 <i2cSendStart>:

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    46d8:	ec eb       	ldi	r30, 0xBC	; 188
    46da:	f0 e0       	ldi	r31, 0x00	; 0
    46dc:	80 81       	ld	r24, Z
    46de:	8f 70       	andi	r24, 0x0F	; 15
    46e0:	80 6a       	ori	r24, 0xA0	; 160
    46e2:	80 83       	st	Z, r24
}
    46e4:	08 95       	ret

000046e6 <i2cSendStop>:

inline void i2cSendStop(void)
{
	// transmit stop condition
	// leave with TWEA on for slave receiving
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA)|BV(TWSTO));
    46e6:	ec eb       	ldi	r30, 0xBC	; 188
    46e8:	f0 e0       	ldi	r31, 0x00	; 0
    46ea:	80 81       	ld	r24, Z
    46ec:	8f 70       	andi	r24, 0x0F	; 15
    46ee:	80 6d       	ori	r24, 0xD0	; 208
    46f0:	80 83       	st	Z, r24
}
    46f2:	08 95       	ret

000046f4 <i2cWaitForComplete>:

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    46f4:	80 91 bc 00 	lds	r24, 0x00BC
    46f8:	87 ff       	sbrs	r24, 7
    46fa:	fc cf       	rjmp	.-8      	; 0x46f4 <i2cWaitForComplete>
}
    46fc:	08 95       	ret

000046fe <i2cSendByte>:

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    46fe:	80 93 bb 00 	sts	0x00BB, r24
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    4702:	ec eb       	ldi	r30, 0xBC	; 188
    4704:	f0 e0       	ldi	r31, 0x00	; 0
    4706:	80 81       	ld	r24, Z
    4708:	8f 70       	andi	r24, 0x0F	; 15
    470a:	80 68       	ori	r24, 0x80	; 128
    470c:	80 83       	st	Z, r24
}
    470e:	08 95       	ret

00004710 <i2cReceiveByte>:

inline void i2cReceiveByte(u08 ackFlag)
{
	// begin receive over i2c
	if( ackFlag )
    4710:	88 23       	and	r24, r24
    4712:	29 f0       	breq	.+10     	; 0x471e <i2cReceiveByte+0xe>
	{
		// ackFlag = TRUE: ACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    4714:	80 91 bc 00 	lds	r24, 0x00BC
    4718:	8f 70       	andi	r24, 0x0F	; 15
    471a:	80 6c       	ori	r24, 0xC0	; 192
    471c:	04 c0       	rjmp	.+8      	; 0x4726 <i2cReceiveByte+0x16>
	}
	else
	{
		// ackFlag = FALSE: NACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    471e:	80 91 bc 00 	lds	r24, 0x00BC
    4722:	8f 70       	andi	r24, 0x0F	; 15
    4724:	80 68       	ori	r24, 0x80	; 128
    4726:	80 93 bc 00 	sts	0x00BC, r24
    472a:	08 95       	ret

0000472c <i2cGetReceivedByte>:
}

inline u08 i2cGetReceivedByte(void)
{
	// retieve received data byte from i2c TWDR
	return( inb(TWDR) );
    472c:	80 91 bb 00 	lds	r24, 0x00BB
}
    4730:	08 95       	ret

00004732 <i2cGetStatus>:

inline u08 i2cGetStatus(void)
{
	// retieve current i2c status from i2c TWSR
	return( inb(TWSR) );
    4732:	80 91 b9 00 	lds	r24, 0x00B9
}
    4736:	08 95       	ret

00004738 <i2cMasterSend>:

void i2cMasterSend(u08 deviceAddr, u08 length, u08* data)
{
    4738:	98 2f       	mov	r25, r24
	u08 i;
	// wait for interface to be ready
	while(I2cState);
    473a:	80 91 68 11 	lds	r24, 0x1168
    473e:	88 23       	and	r24, r24
    4740:	e1 f7       	brne	.-8      	; 0x473a <i2cMasterSend+0x2>
	// set state
	I2cState = I2C_MASTER_TX;
    4742:	82 e0       	ldi	r24, 0x02	; 2
    4744:	80 93 68 11 	sts	0x1168, r24
	// save data
	I2cDeviceAddrRW = (deviceAddr & 0xFE);	// RW cleared: write operation
    4748:	9e 7f       	andi	r25, 0xFE	; 254
    474a:	90 93 69 11 	sts	0x1169, r25
    474e:	aa e6       	ldi	r26, 0x6A	; 106
    4750:	b1 e1       	ldi	r27, 0x11	; 17
    4752:	fa 01       	movw	r30, r20
    4754:	02 c0       	rjmp	.+4      	; 0x475a <i2cMasterSend+0x22>
	for(i=0; i<length; i++)
		I2cSendData[i] = *data++;
    4756:	81 91       	ld	r24, Z+
    4758:	8d 93       	st	X+, r24
	while(I2cState);
	// set state
	I2cState = I2C_MASTER_TX;
	// save data
	I2cDeviceAddrRW = (deviceAddr & 0xFE);	// RW cleared: write operation
	for(i=0; i<length; i++)
    475a:	8e 2f       	mov	r24, r30
    475c:	84 1b       	sub	r24, r20
    475e:	86 17       	cp	r24, r22
    4760:	d0 f3       	brcs	.-12     	; 0x4756 <i2cMasterSend+0x1e>
		I2cSendData[i] = *data++;
	I2cSendDataIndex = 0;
    4762:	10 92 8a 11 	sts	0x118A, r1
	I2cSendDataLength = length;
    4766:	60 93 8b 11 	sts	0x118B, r22
}

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    476a:	80 91 bc 00 	lds	r24, 0x00BC
    476e:	8f 70       	andi	r24, 0x0F	; 15
    4770:	80 6a       	ori	r24, 0xA0	; 160
    4772:	80 93 bc 00 	sts	0x00BC, r24
		I2cSendData[i] = *data++;
	I2cSendDataIndex = 0;
	I2cSendDataLength = length;
	// send start condition
	i2cSendStart();
}
    4776:	08 95       	ret

00004778 <i2cMasterReceive>:

void i2cMasterReceive(u08 deviceAddr, u08 length, u08* data)
{
    4778:	98 2f       	mov	r25, r24
	u08 i;
	// wait for interface to be ready
	while(I2cState);
    477a:	80 91 68 11 	lds	r24, 0x1168
    477e:	88 23       	and	r24, r24
    4780:	e1 f7       	brne	.-8      	; 0x477a <i2cMasterReceive+0x2>
	// set state
	I2cState = I2C_MASTER_RX;
    4782:	83 e0       	ldi	r24, 0x03	; 3
    4784:	80 93 68 11 	sts	0x1168, r24
	// save data
	I2cDeviceAddrRW = (deviceAddr|0x01);	// RW set: read operation
    4788:	91 60       	ori	r25, 0x01	; 1
    478a:	90 93 69 11 	sts	0x1169, r25
	I2cReceiveDataIndex = 0;
    478e:	10 92 ac 11 	sts	0x11AC, r1
	I2cReceiveDataLength = length;
    4792:	60 93 ad 11 	sts	0x11AD, r22
}

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    4796:	80 91 bc 00 	lds	r24, 0x00BC
    479a:	8f 70       	andi	r24, 0x0F	; 15
    479c:	80 6a       	ori	r24, 0xA0	; 160
    479e:	80 93 bc 00 	sts	0x00BC, r24
	I2cReceiveDataIndex = 0;
	I2cReceiveDataLength = length;
	// send start condition
	i2cSendStart();
	// wait for data
	while(I2cState);
    47a2:	80 91 68 11 	lds	r24, 0x1168
    47a6:	88 23       	and	r24, r24
    47a8:	e1 f7       	brne	.-8      	; 0x47a2 <i2cMasterReceive+0x2a>
    47aa:	ac e8       	ldi	r26, 0x8C	; 140
    47ac:	b1 e1       	ldi	r27, 0x11	; 17
    47ae:	fa 01       	movw	r30, r20
    47b0:	02 c0       	rjmp	.+4      	; 0x47b6 <i2cMasterReceive+0x3e>
	// return data
	for(i=0; i<length; i++)
		*data++ = I2cReceiveData[i];
    47b2:	8d 91       	ld	r24, X+
    47b4:	81 93       	st	Z+, r24
	// send start condition
	i2cSendStart();
	// wait for data
	while(I2cState);
	// return data
	for(i=0; i<length; i++)
    47b6:	8e 2f       	mov	r24, r30
    47b8:	84 1b       	sub	r24, r20
    47ba:	86 17       	cp	r24, r22
    47bc:	d0 f3       	brcs	.-12     	; 0x47b2 <i2cMasterReceive+0x3a>
		*data++ = I2cReceiveData[i];
}
    47be:	08 95       	ret

000047c0 <i2cMasterSendNI>:

u08 i2cMasterSendNI(u08 deviceAddr, u08 length, u08* data)
{
    47c0:	98 2f       	mov	r25, r24
    47c2:	fa 01       	movw	r30, r20
	u08 retval = I2C_OK;

	// disable TWI interrupt
	cbi(TWCR, TWIE);
    47c4:	80 91 bc 00 	lds	r24, 0x00BC
    47c8:	8e 7f       	andi	r24, 0xFE	; 254
    47ca:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    47ce:	80 91 bc 00 	lds	r24, 0x00BC
    47d2:	8f 70       	andi	r24, 0x0F	; 15
    47d4:	80 6a       	ori	r24, 0xA0	; 160
    47d6:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    47da:	80 91 bc 00 	lds	r24, 0x00BC
    47de:	87 ff       	sbrs	r24, 7
    47e0:	fc cf       	rjmp	.-8      	; 0x47da <i2cMasterSendNI+0x1a>
	// send start condition
	i2cSendStart();
	i2cWaitForComplete();

	// send device address with write
	i2cSendByte( deviceAddr & 0xFE );
    47e2:	9e 7f       	andi	r25, 0xFE	; 254
}

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    47e4:	90 93 bb 00 	sts	0x00BB, r25
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    47e8:	80 91 bc 00 	lds	r24, 0x00BC
    47ec:	8f 70       	andi	r24, 0x0F	; 15
    47ee:	80 68       	ori	r24, 0x80	; 128
    47f0:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    47f4:	80 91 bc 00 	lds	r24, 0x00BC
    47f8:	87 ff       	sbrs	r24, 7
    47fa:	fc cf       	rjmp	.-8      	; 0x47f4 <i2cMasterSendNI+0x34>
	// send device address with write
	i2cSendByte( deviceAddr & 0xFE );
	i2cWaitForComplete();

	// check if device is present and live
	if( inb(TWSR) == TW_MT_SLA_ACK)
    47fc:	80 91 b9 00 	lds	r24, 0x00B9
    4800:	88 31       	cpi	r24, 0x18	; 24
    4802:	89 f0       	breq	.+34     	; 0x4826 <i2cMasterSendNI+0x66>
    4804:	91 e0       	ldi	r25, 0x01	; 1
    4806:	12 c0       	rjmp	.+36     	; 0x482c <i2cMasterSendNI+0x6c>
	{
		// send data
		while(length)
		{
			i2cSendByte( *data++ );
    4808:	80 81       	ld	r24, Z
}

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    480a:	80 93 bb 00 	sts	0x00BB, r24
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    480e:	80 91 bc 00 	lds	r24, 0x00BC
    4812:	8f 70       	andi	r24, 0x0F	; 15
    4814:	80 68       	ori	r24, 0x80	; 128
    4816:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    481a:	80 91 bc 00 	lds	r24, 0x00BC
    481e:	87 ff       	sbrs	r24, 7
    4820:	fc cf       	rjmp	.-8      	; 0x481a <i2cMasterSendNI+0x5a>
	if( inb(TWSR) == TW_MT_SLA_ACK)
	{
		// send data
		while(length)
		{
			i2cSendByte( *data++ );
    4822:	31 96       	adiw	r30, 0x01	; 1
			i2cWaitForComplete();
			length--;
    4824:	61 50       	subi	r22, 0x01	; 1

	// check if device is present and live
	if( inb(TWSR) == TW_MT_SLA_ACK)
	{
		// send data
		while(length)
    4826:	66 23       	and	r22, r22
    4828:	79 f7       	brne	.-34     	; 0x4808 <i2cMasterSendNI+0x48>
    482a:	90 e0       	ldi	r25, 0x00	; 0

inline void i2cSendStop(void)
{
	// transmit stop condition
	// leave with TWEA on for slave receiving
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA)|BV(TWSTO));
    482c:	80 91 bc 00 	lds	r24, 0x00BC
    4830:	8f 70       	andi	r24, 0x0F	; 15
    4832:	80 6d       	ori	r24, 0xD0	; 208
    4834:	80 93 bc 00 	sts	0x00BC, r24
	}

	// transmit stop condition
	// leave with TWEA on for slave receiving
	i2cSendStop();
	while( !(inb(TWCR) & BV(TWSTO)) );
    4838:	80 91 bc 00 	lds	r24, 0x00BC
    483c:	84 ff       	sbrs	r24, 4
    483e:	fc cf       	rjmp	.-8      	; 0x4838 <i2cMasterSendNI+0x78>

	// enable TWI interrupt
	sbi(TWCR, TWIE);
    4840:	80 91 bc 00 	lds	r24, 0x00BC
    4844:	81 60       	ori	r24, 0x01	; 1
    4846:	80 93 bc 00 	sts	0x00BC, r24

	return retval;
}
    484a:	89 2f       	mov	r24, r25
    484c:	08 95       	ret

0000484e <i2cMasterReceiveNI>:

u08 i2cMasterReceiveNI(u08 deviceAddr, u08 length, u08 *data)
{
    484e:	98 2f       	mov	r25, r24
    4850:	fa 01       	movw	r30, r20
	u08 retval = I2C_OK;

	// disable TWI interrupt
	cbi(TWCR, TWIE);
    4852:	80 91 bc 00 	lds	r24, 0x00BC
    4856:	8e 7f       	andi	r24, 0xFE	; 254
    4858:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    485c:	80 91 bc 00 	lds	r24, 0x00BC
    4860:	8f 70       	andi	r24, 0x0F	; 15
    4862:	80 6a       	ori	r24, 0xA0	; 160
    4864:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    4868:	80 91 bc 00 	lds	r24, 0x00BC
    486c:	87 ff       	sbrs	r24, 7
    486e:	fc cf       	rjmp	.-8      	; 0x4868 <i2cMasterReceiveNI+0x1a>
	// send start condition
	i2cSendStart();
	i2cWaitForComplete();

	// send device address with read
	i2cSendByte( deviceAddr | 0x01 );
    4870:	91 60       	ori	r25, 0x01	; 1
}

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    4872:	90 93 bb 00 	sts	0x00BB, r25
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    4876:	80 91 bc 00 	lds	r24, 0x00BC
    487a:	8f 70       	andi	r24, 0x0F	; 15
    487c:	80 68       	ori	r24, 0x80	; 128
    487e:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    4882:	80 91 bc 00 	lds	r24, 0x00BC
    4886:	87 ff       	sbrs	r24, 7
    4888:	fc cf       	rjmp	.-8      	; 0x4882 <i2cMasterReceiveNI+0x34>
	// send device address with read
	i2cSendByte( deviceAddr | 0x01 );
	i2cWaitForComplete();

	// check if device is present and live
	if( inb(TWSR) == TW_MR_SLA_ACK)
    488a:	80 91 b9 00 	lds	r24, 0x00B9
    488e:	80 34       	cpi	r24, 0x40	; 64
    4890:	81 f0       	breq	.+32     	; 0x48b2 <i2cMasterReceiveNI+0x64>
    4892:	91 e0       	ldi	r25, 0x01	; 1
    4894:	1e c0       	rjmp	.+60     	; 0x48d2 <i2cMasterReceiveNI+0x84>
{
	// begin receive over i2c
	if( ackFlag )
	{
		// ackFlag = TRUE: ACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    4896:	80 91 bc 00 	lds	r24, 0x00BC
    489a:	8f 70       	andi	r24, 0x0F	; 15
    489c:	80 6c       	ori	r24, 0xC0	; 192
    489e:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    48a2:	80 91 bc 00 	lds	r24, 0x00BC
    48a6:	87 ff       	sbrs	r24, 7
    48a8:	fc cf       	rjmp	.-8      	; 0x48a2 <i2cMasterReceiveNI+0x54>
}

inline u08 i2cGetReceivedByte(void)
{
	// retieve received data byte from i2c TWDR
	return( inb(TWDR) );
    48aa:	80 91 bb 00 	lds	r24, 0x00BB
		// accept receive data and ack it
		while(length > 1)
		{
			i2cReceiveByte(TRUE);
			i2cWaitForComplete();
			*data++ = i2cGetReceivedByte();
    48ae:	81 93       	st	Z+, r24
			// decrement length
			length--;
    48b0:	61 50       	subi	r22, 0x01	; 1

	// check if device is present and live
	if( inb(TWSR) == TW_MR_SLA_ACK)
	{
		// accept receive data and ack it
		while(length > 1)
    48b2:	62 30       	cpi	r22, 0x02	; 2
    48b4:	80 f7       	brcc	.-32     	; 0x4896 <i2cMasterReceiveNI+0x48>
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
	}
	else
	{
		// ackFlag = FALSE: NACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    48b6:	80 91 bc 00 	lds	r24, 0x00BC
    48ba:	8f 70       	andi	r24, 0x0F	; 15
    48bc:	80 68       	ori	r24, 0x80	; 128
    48be:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    48c2:	80 91 bc 00 	lds	r24, 0x00BC
    48c6:	87 ff       	sbrs	r24, 7
    48c8:	fc cf       	rjmp	.-8      	; 0x48c2 <i2cMasterReceiveNI+0x74>
}

inline u08 i2cGetReceivedByte(void)
{
	// retieve received data byte from i2c TWDR
	return( inb(TWDR) );
    48ca:	80 91 bb 00 	lds	r24, 0x00BB
		}

		// accept receive data and nack it (last-byte signal)
		i2cReceiveByte(FALSE);
		i2cWaitForComplete();
		*data++ = i2cGetReceivedByte();
    48ce:	80 83       	st	Z, r24
    48d0:	90 e0       	ldi	r25, 0x00	; 0

inline void i2cSendStop(void)
{
	// transmit stop condition
	// leave with TWEA on for slave receiving
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA)|BV(TWSTO));
    48d2:	80 91 bc 00 	lds	r24, 0x00BC
    48d6:	8f 70       	andi	r24, 0x0F	; 15
    48d8:	80 6d       	ori	r24, 0xD0	; 208
    48da:	80 93 bc 00 	sts	0x00BC, r24
	// transmit stop condition
	// leave with TWEA on for slave receiving
	i2cSendStop();

	// enable TWI interrupt
	sbi(TWCR, TWIE);
    48de:	80 91 bc 00 	lds	r24, 0x00BC
    48e2:	81 60       	ori	r24, 0x01	; 1
    48e4:	80 93 bc 00 	sts	0x00BC, r24

	return retval;
}
    48e8:	89 2f       	mov	r24, r25
    48ea:	08 95       	ret

000048ec <__vector_39>:
}
*/

//! I2C (TWI) interrupt service routine
SIGNAL(SIG_2WIRE_SERIAL)
{
    48ec:	1f 92       	push	r1
    48ee:	0f 92       	push	r0
    48f0:	0f b6       	in	r0, 0x3f	; 63
    48f2:	0f 92       	push	r0
    48f4:	11 24       	eor	r1, r1
    48f6:	2f 93       	push	r18
    48f8:	3f 93       	push	r19
    48fa:	4f 93       	push	r20
    48fc:	5f 93       	push	r21
    48fe:	6f 93       	push	r22
    4900:	7f 93       	push	r23
    4902:	8f 93       	push	r24
    4904:	9f 93       	push	r25
    4906:	af 93       	push	r26
    4908:	bf 93       	push	r27
    490a:	ef 93       	push	r30
    490c:	ff 93       	push	r31
	// read status bits
	u08 status = inb(TWSR) & TWSR_STATUS_MASK;
    490e:	80 91 b9 00 	lds	r24, 0x00B9

	switch(status)
    4912:	88 7f       	andi	r24, 0xF8	; 248
    4914:	80 36       	cpi	r24, 0x60	; 96
    4916:	09 f4       	brne	.+2      	; 0x491a <__vector_39+0x2e>
    4918:	a0 c0       	rjmp	.+320    	; 0x4a5a <__vector_39+0x16e>
    491a:	81 36       	cpi	r24, 0x61	; 97
    491c:	70 f5       	brcc	.+92     	; 0x497a <__vector_39+0x8e>
    491e:	88 32       	cpi	r24, 0x28	; 40
    4920:	09 f4       	brne	.+2      	; 0x4924 <__vector_39+0x38>
    4922:	5f c0       	rjmp	.+190    	; 0x49e2 <__vector_39+0xf6>
    4924:	89 32       	cpi	r24, 0x29	; 41
    4926:	98 f4       	brcc	.+38     	; 0x494e <__vector_39+0x62>
    4928:	80 31       	cpi	r24, 0x10	; 16
    492a:	09 f4       	brne	.+2      	; 0x492e <__vector_39+0x42>
    492c:	57 c0       	rjmp	.+174    	; 0x49dc <__vector_39+0xf0>
    492e:	81 31       	cpi	r24, 0x11	; 17
    4930:	38 f4       	brcc	.+14     	; 0x4940 <__vector_39+0x54>
    4932:	88 23       	and	r24, r24
    4934:	09 f4       	brne	.+2      	; 0x4938 <__vector_39+0x4c>
    4936:	ea c0       	rjmp	.+468    	; 0x4b0c <__vector_39+0x220>
    4938:	88 30       	cpi	r24, 0x08	; 8
    493a:	09 f0       	breq	.+2      	; 0x493e <__vector_39+0x52>
    493c:	ef c0       	rjmp	.+478    	; 0x4b1c <__vector_39+0x230>
    493e:	4e c0       	rjmp	.+156    	; 0x49dc <__vector_39+0xf0>
    4940:	88 31       	cpi	r24, 0x18	; 24
    4942:	09 f4       	brne	.+2      	; 0x4946 <__vector_39+0x5a>
    4944:	4e c0       	rjmp	.+156    	; 0x49e2 <__vector_39+0xf6>
    4946:	80 32       	cpi	r24, 0x20	; 32
    4948:	09 f0       	breq	.+2      	; 0x494c <__vector_39+0x60>
    494a:	e8 c0       	rjmp	.+464    	; 0x4b1c <__vector_39+0x230>
    494c:	df c0       	rjmp	.+446    	; 0x4b0c <__vector_39+0x220>
    494e:	80 34       	cpi	r24, 0x40	; 64
    4950:	09 f4       	brne	.+2      	; 0x4954 <__vector_39+0x68>
    4952:	77 c0       	rjmp	.+238    	; 0x4a42 <__vector_39+0x156>
    4954:	81 34       	cpi	r24, 0x41	; 65
    4956:	38 f4       	brcc	.+14     	; 0x4966 <__vector_39+0x7a>
    4958:	80 33       	cpi	r24, 0x30	; 48
    495a:	09 f4       	brne	.+2      	; 0x495e <__vector_39+0x72>
    495c:	d7 c0       	rjmp	.+430    	; 0x4b0c <__vector_39+0x220>
    495e:	88 33       	cpi	r24, 0x38	; 56
    4960:	09 f0       	breq	.+2      	; 0x4964 <__vector_39+0x78>
    4962:	dc c0       	rjmp	.+440    	; 0x4b1c <__vector_39+0x230>
    4964:	5d c0       	rjmp	.+186    	; 0x4a20 <__vector_39+0x134>
    4966:	80 35       	cpi	r24, 0x50	; 80
    4968:	09 f4       	brne	.+2      	; 0x496c <__vector_39+0x80>
    496a:	5f c0       	rjmp	.+190    	; 0x4a2a <__vector_39+0x13e>
    496c:	88 35       	cpi	r24, 0x58	; 88
    496e:	09 f4       	brne	.+2      	; 0x4972 <__vector_39+0x86>
    4970:	4a c0       	rjmp	.+148    	; 0x4a06 <__vector_39+0x11a>
    4972:	88 34       	cpi	r24, 0x48	; 72
    4974:	09 f0       	breq	.+2      	; 0x4978 <__vector_39+0x8c>
    4976:	d2 c0       	rjmp	.+420    	; 0x4b1c <__vector_39+0x230>
    4978:	c9 c0       	rjmp	.+402    	; 0x4b0c <__vector_39+0x220>
    497a:	88 39       	cpi	r24, 0x98	; 152
    497c:	09 f4       	brne	.+2      	; 0x4980 <__vector_39+0x94>
    497e:	ba c0       	rjmp	.+372    	; 0x4af4 <__vector_39+0x208>
    4980:	89 39       	cpi	r24, 0x99	; 153
    4982:	b0 f4       	brcc	.+44     	; 0x49b0 <__vector_39+0xc4>
    4984:	88 37       	cpi	r24, 0x78	; 120
    4986:	09 f4       	brne	.+2      	; 0x498a <__vector_39+0x9e>
    4988:	68 c0       	rjmp	.+208    	; 0x4a5a <__vector_39+0x16e>
    498a:	89 37       	cpi	r24, 0x79	; 121
    498c:	38 f4       	brcc	.+14     	; 0x499c <__vector_39+0xb0>
    498e:	88 36       	cpi	r24, 0x68	; 104
    4990:	09 f4       	brne	.+2      	; 0x4994 <__vector_39+0xa8>
    4992:	63 c0       	rjmp	.+198    	; 0x4a5a <__vector_39+0x16e>
    4994:	80 37       	cpi	r24, 0x70	; 112
    4996:	09 f0       	breq	.+2      	; 0x499a <__vector_39+0xae>
    4998:	c1 c0       	rjmp	.+386    	; 0x4b1c <__vector_39+0x230>
    499a:	5f c0       	rjmp	.+190    	; 0x4a5a <__vector_39+0x16e>
    499c:	88 38       	cpi	r24, 0x88	; 136
    499e:	09 f4       	brne	.+2      	; 0x49a2 <__vector_39+0xb6>
    49a0:	a9 c0       	rjmp	.+338    	; 0x4af4 <__vector_39+0x208>
    49a2:	80 39       	cpi	r24, 0x90	; 144
    49a4:	09 f4       	brne	.+2      	; 0x49a8 <__vector_39+0xbc>
    49a6:	5f c0       	rjmp	.+190    	; 0x4a66 <__vector_39+0x17a>
    49a8:	80 38       	cpi	r24, 0x80	; 128
    49aa:	09 f0       	breq	.+2      	; 0x49ae <__vector_39+0xc2>
    49ac:	b7 c0       	rjmp	.+366    	; 0x4b1c <__vector_39+0x230>
    49ae:	5b c0       	rjmp	.+182    	; 0x4a66 <__vector_39+0x17a>
    49b0:	80 3b       	cpi	r24, 0xB0	; 176
    49b2:	09 f4       	brne	.+2      	; 0x49b6 <__vector_39+0xca>
    49b4:	79 c0       	rjmp	.+242    	; 0x4aa8 <__vector_39+0x1bc>
    49b6:	81 3b       	cpi	r24, 0xB1	; 177
    49b8:	38 f4       	brcc	.+14     	; 0x49c8 <__vector_39+0xdc>
    49ba:	80 3a       	cpi	r24, 0xA0	; 160
    49bc:	09 f4       	brne	.+2      	; 0x49c0 <__vector_39+0xd4>
    49be:	62 c0       	rjmp	.+196    	; 0x4a84 <__vector_39+0x198>
    49c0:	88 3a       	cpi	r24, 0xA8	; 168
    49c2:	09 f0       	breq	.+2      	; 0x49c6 <__vector_39+0xda>
    49c4:	ab c0       	rjmp	.+342    	; 0x4b1c <__vector_39+0x230>
    49c6:	70 c0       	rjmp	.+224    	; 0x4aa8 <__vector_39+0x1bc>
    49c8:	80 3c       	cpi	r24, 0xC0	; 192
    49ca:	09 f4       	brne	.+2      	; 0x49ce <__vector_39+0xe2>
    49cc:	9a c0       	rjmp	.+308    	; 0x4b02 <__vector_39+0x216>
    49ce:	88 3c       	cpi	r24, 0xC8	; 200
    49d0:	09 f4       	brne	.+2      	; 0x49d4 <__vector_39+0xe8>
    49d2:	97 c0       	rjmp	.+302    	; 0x4b02 <__vector_39+0x216>
    49d4:	88 3b       	cpi	r24, 0xB8	; 184
    49d6:	09 f0       	breq	.+2      	; 0x49da <__vector_39+0xee>
    49d8:	a1 c0       	rjmp	.+322    	; 0x4b1c <__vector_39+0x230>
    49da:	77 c0       	rjmp	.+238    	; 0x4aca <__vector_39+0x1de>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: M->START\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// send device address
		i2cSendByte(I2cDeviceAddrRW);
    49dc:	80 91 69 11 	lds	r24, 0x1169
    49e0:	0f c0       	rjmp	.+30     	; 0x4a00 <__vector_39+0x114>
		#ifdef I2C_DEBUG
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MT->SLA_ACK or DATA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		if(I2cSendDataIndex < I2cSendDataLength)
    49e2:	90 91 8a 11 	lds	r25, 0x118A
    49e6:	80 91 8b 11 	lds	r24, 0x118B
    49ea:	98 17       	cp	r25, r24
    49ec:	08 f0       	brcs	.+2      	; 0x49f0 <__vector_39+0x104>
    49ee:	8e c0       	rjmp	.+284    	; 0x4b0c <__vector_39+0x220>
		{
			// send data
			i2cSendByte( I2cSendData[I2cSendDataIndex++] );
    49f0:	e9 2f       	mov	r30, r25
    49f2:	f0 e0       	ldi	r31, 0x00	; 0
    49f4:	e6 59       	subi	r30, 0x96	; 150
    49f6:	fe 4e       	sbci	r31, 0xEE	; 238
    49f8:	80 81       	ld	r24, Z
    49fa:	9f 5f       	subi	r25, 0xFF	; 255
    49fc:	90 93 8a 11 	sts	0x118A, r25
}

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    4a00:	80 93 bb 00 	sts	0x00BB, r24
    4a04:	77 c0       	rjmp	.+238    	; 0x4af4 <__vector_39+0x208>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MR->DATA_NACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// store final received data byte
		I2cReceiveData[I2cReceiveDataIndex++] = inb(TWDR);
    4a06:	80 91 ac 11 	lds	r24, 0x11AC
    4a0a:	90 91 bb 00 	lds	r25, 0x00BB
    4a0e:	e8 2f       	mov	r30, r24
    4a10:	f0 e0       	ldi	r31, 0x00	; 0
    4a12:	e4 57       	subi	r30, 0x74	; 116
    4a14:	fe 4e       	sbci	r31, 0xEE	; 238
    4a16:	90 83       	st	Z, r25
    4a18:	8f 5f       	subi	r24, 0xFF	; 255
    4a1a:	80 93 ac 11 	sts	0x11AC, r24
    4a1e:	76 c0       	rjmp	.+236    	; 0x4b0c <__vector_39+0x220>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MT->ARB_LOST\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// release bus
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    4a20:	80 91 bc 00 	lds	r24, 0x00BC
    4a24:	8f 70       	andi	r24, 0x0F	; 15
    4a26:	80 68       	ori	r24, 0x80	; 128
    4a28:	75 c0       	rjmp	.+234    	; 0x4b14 <__vector_39+0x228>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MR->DATA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// store received data byte
		I2cReceiveData[I2cReceiveDataIndex++] = inb(TWDR);
    4a2a:	80 91 ac 11 	lds	r24, 0x11AC
    4a2e:	90 91 bb 00 	lds	r25, 0x00BB
    4a32:	e8 2f       	mov	r30, r24
    4a34:	f0 e0       	ldi	r31, 0x00	; 0
    4a36:	e4 57       	subi	r30, 0x74	; 116
    4a38:	fe 4e       	sbci	r31, 0xEE	; 238
    4a3a:	90 83       	st	Z, r25
    4a3c:	8f 5f       	subi	r24, 0xFF	; 255
    4a3e:	80 93 ac 11 	sts	0x11AC, r24
		#ifdef I2C_DEBUG
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MR->SLA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		if(I2cReceiveDataIndex < (I2cReceiveDataLength-1))
    4a42:	20 91 ac 11 	lds	r18, 0x11AC
    4a46:	30 e0       	ldi	r19, 0x00	; 0
    4a48:	80 91 ad 11 	lds	r24, 0x11AD
    4a4c:	90 e0       	ldi	r25, 0x00	; 0
    4a4e:	01 97       	sbiw	r24, 0x01	; 1
    4a50:	28 17       	cp	r18, r24
    4a52:	39 07       	cpc	r19, r25
    4a54:	0c f0       	brlt	.+2      	; 0x4a58 <__vector_39+0x16c>
    4a56:	4e c0       	rjmp	.+156    	; 0x4af4 <__vector_39+0x208>
    4a58:	48 c0       	rjmp	.+144    	; 0x4aea <__vector_39+0x1fe>
		rprintf("I2C: SR->SLA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// we are being addressed as slave for writing (data will be received from master)
		// set state
		I2cState = I2C_SLAVE_RX;
    4a5a:	85 e0       	ldi	r24, 0x05	; 5
    4a5c:	80 93 68 11 	sts	0x1168, r24
		// prepare buffer
		I2cReceiveDataIndex = 0;
    4a60:	10 92 ac 11 	sts	0x11AC, r1
    4a64:	42 c0       	rjmp	.+132    	; 0x4aea <__vector_39+0x1fe>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: SR->DATA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// get previously received data byte
		I2cReceiveData[I2cReceiveDataIndex++] = inb(TWDR);
    4a66:	80 91 ac 11 	lds	r24, 0x11AC
    4a6a:	90 91 bb 00 	lds	r25, 0x00BB
    4a6e:	e8 2f       	mov	r30, r24
    4a70:	f0 e0       	ldi	r31, 0x00	; 0
    4a72:	e4 57       	subi	r30, 0x74	; 116
    4a74:	fe 4e       	sbci	r31, 0xEE	; 238
    4a76:	90 83       	st	Z, r25
    4a78:	8f 5f       	subi	r24, 0xFF	; 255
    4a7a:	80 93 ac 11 	sts	0x11AC, r24
		// check receive buffer status
		if(I2cReceiveDataIndex < I2C_RECEIVE_DATA_BUFFER_SIZE)
    4a7e:	80 32       	cpi	r24, 0x20	; 32
    4a80:	c8 f5       	brcc	.+114    	; 0x4af4 <__vector_39+0x208>
    4a82:	33 c0       	rjmp	.+102    	; 0x4aea <__vector_39+0x1fe>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: SR->SR_STOP\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// switch to SR mode with SLA ACK
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    4a84:	80 91 bc 00 	lds	r24, 0x00BC
    4a88:	8f 70       	andi	r24, 0x0F	; 15
    4a8a:	80 6c       	ori	r24, 0xC0	; 192
    4a8c:	80 93 bc 00 	sts	0x00BC, r24
		// i2c receive is complete, call i2cSlaveReceive
		if(i2cSlaveReceive) i2cSlaveReceive(I2cReceiveDataIndex, I2cReceiveData);
    4a90:	e0 91 ae 11 	lds	r30, 0x11AE
    4a94:	f0 91 af 11 	lds	r31, 0x11AF
    4a98:	30 97       	sbiw	r30, 0x00	; 0
    4a9a:	f1 f1       	breq	.+124    	; 0x4b18 <__vector_39+0x22c>
    4a9c:	80 91 ac 11 	lds	r24, 0x11AC
    4aa0:	6c e8       	ldi	r22, 0x8C	; 140
    4aa2:	71 e1       	ldi	r23, 0x11	; 17
    4aa4:	09 95       	icall
    4aa6:	38 c0       	rjmp	.+112    	; 0x4b18 <__vector_39+0x22c>
		rprintf("I2C: ST->SLA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// we are being addressed as slave for reading (data must be transmitted back to master)
		// set state
		I2cState = I2C_SLAVE_TX;
    4aa8:	84 e0       	ldi	r24, 0x04	; 4
    4aaa:	80 93 68 11 	sts	0x1168, r24
		// request data from application
		if(i2cSlaveTransmit) I2cSendDataLength = i2cSlaveTransmit(I2C_SEND_DATA_BUFFER_SIZE, I2cSendData);
    4aae:	e0 91 b0 11 	lds	r30, 0x11B0
    4ab2:	f0 91 b1 11 	lds	r31, 0x11B1
    4ab6:	30 97       	sbiw	r30, 0x00	; 0
    4ab8:	31 f0       	breq	.+12     	; 0x4ac6 <__vector_39+0x1da>
    4aba:	80 e2       	ldi	r24, 0x20	; 32
    4abc:	6a e6       	ldi	r22, 0x6A	; 106
    4abe:	71 e1       	ldi	r23, 0x11	; 17
    4ac0:	09 95       	icall
    4ac2:	80 93 8b 11 	sts	0x118B, r24
		// reset data index
		I2cSendDataIndex = 0;
    4ac6:	10 92 8a 11 	sts	0x118A, r1
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: ST->DATA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// transmit data byte
		outb(TWDR, I2cSendData[I2cSendDataIndex++]);
    4aca:	90 91 8a 11 	lds	r25, 0x118A
    4ace:	e9 2f       	mov	r30, r25
    4ad0:	f0 e0       	ldi	r31, 0x00	; 0
    4ad2:	e6 59       	subi	r30, 0x96	; 150
    4ad4:	fe 4e       	sbci	r31, 0xEE	; 238
    4ad6:	80 81       	ld	r24, Z
    4ad8:	80 93 bb 00 	sts	0x00BB, r24
    4adc:	9f 5f       	subi	r25, 0xFF	; 255
    4ade:	90 93 8a 11 	sts	0x118A, r25
		if(I2cSendDataIndex < I2cSendDataLength)
    4ae2:	80 91 8b 11 	lds	r24, 0x118B
    4ae6:	98 17       	cp	r25, r24
    4ae8:	28 f4       	brcc	.+10     	; 0x4af4 <__vector_39+0x208>
			// expect ACK to data byte
			outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    4aea:	80 91 bc 00 	lds	r24, 0x00BC
    4aee:	8f 70       	andi	r24, 0x0F	; 15
    4af0:	80 6c       	ori	r24, 0xC0	; 192
    4af2:	04 c0       	rjmp	.+8      	; 0x4afc <__vector_39+0x210>
		else
			// expect NACK to data byte
			outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    4af4:	80 91 bc 00 	lds	r24, 0x00BC
    4af8:	8f 70       	andi	r24, 0x0F	; 15
    4afa:	80 68       	ori	r24, 0x80	; 128
    4afc:	80 93 bc 00 	sts	0x00BC, r24
    4b00:	0d c0       	rjmp	.+26     	; 0x4b1c <__vector_39+0x230>
		rprintf("I2C: ST->DATA_NACK or LAST_DATA\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// all done
		// switch to open slave
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    4b02:	80 91 bc 00 	lds	r24, 0x00BC
    4b06:	8f 70       	andi	r24, 0x0F	; 15
    4b08:	80 6c       	ori	r24, 0xC0	; 192
    4b0a:	04 c0       	rjmp	.+8      	; 0x4b14 <__vector_39+0x228>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: BUS_ERROR\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// reset internal hardware and release bus
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTO)|BV(TWEA));
    4b0c:	80 91 bc 00 	lds	r24, 0x00BC
    4b10:	8f 70       	andi	r24, 0x0F	; 15
    4b12:	80 6d       	ori	r24, 0xD0	; 208
    4b14:	80 93 bc 00 	sts	0x00BC, r24
		// set state
		I2cState = I2C_IDLE;
    4b18:	10 92 68 11 	sts	0x1168, r1
		break;
	}
}
    4b1c:	ff 91       	pop	r31
    4b1e:	ef 91       	pop	r30
    4b20:	bf 91       	pop	r27
    4b22:	af 91       	pop	r26
    4b24:	9f 91       	pop	r25
    4b26:	8f 91       	pop	r24
    4b28:	7f 91       	pop	r23
    4b2a:	6f 91       	pop	r22
    4b2c:	5f 91       	pop	r21
    4b2e:	4f 91       	pop	r20
    4b30:	3f 91       	pop	r19
    4b32:	2f 91       	pop	r18
    4b34:	0f 90       	pop	r0
    4b36:	0f be       	out	0x3f, r0	; 63
    4b38:	0f 90       	pop	r0
    4b3a:	1f 90       	pop	r1
    4b3c:	18 95       	reti

00004b3e <i2cGetState>:

eI2cStateType i2cGetState(void)
{
	return I2cState;
    4b3e:	80 91 68 11 	lds	r24, 0x1168
}
    4b42:	08 95       	ret

00004b44 <exit>:
    4b44:	f8 94       	cli
    4b46:	0c 94 3e 28 	jmp	0x507c	; 0x507c <_exit>

00004b4a <memcpy>:
    4b4a:	fb 01       	movw	r30, r22
    4b4c:	dc 01       	movw	r26, r24
    4b4e:	02 c0       	rjmp	.+4      	; 0x4b54 <memcpy+0xa>
    4b50:	01 90       	ld	r0, Z+
    4b52:	0d 92       	st	X+, r0
    4b54:	41 50       	subi	r20, 0x01	; 1
    4b56:	50 40       	sbci	r21, 0x00	; 0
    4b58:	d8 f7       	brcc	.-10     	; 0x4b50 <memcpy+0x6>
    4b5a:	08 95       	ret

00004b5c <memset>:
    4b5c:	dc 01       	movw	r26, r24
    4b5e:	01 c0       	rjmp	.+2      	; 0x4b62 <memset+0x6>
    4b60:	6d 93       	st	X+, r22
    4b62:	41 50       	subi	r20, 0x01	; 1
    4b64:	50 40       	sbci	r21, 0x00	; 0
    4b66:	e0 f7       	brcc	.-8      	; 0x4b60 <memset+0x4>
    4b68:	08 95       	ret

00004b6a <strncpy>:
    4b6a:	fb 01       	movw	r30, r22
    4b6c:	dc 01       	movw	r26, r24
    4b6e:	41 50       	subi	r20, 0x01	; 1
    4b70:	50 40       	sbci	r21, 0x00	; 0
    4b72:	48 f0       	brcs	.+18     	; 0x4b86 <strncpy+0x1c>
    4b74:	01 90       	ld	r0, Z+
    4b76:	0d 92       	st	X+, r0
    4b78:	00 20       	and	r0, r0
    4b7a:	c9 f7       	brne	.-14     	; 0x4b6e <strncpy+0x4>
    4b7c:	01 c0       	rjmp	.+2      	; 0x4b80 <strncpy+0x16>
    4b7e:	1d 92       	st	X+, r1
    4b80:	41 50       	subi	r20, 0x01	; 1
    4b82:	50 40       	sbci	r21, 0x00	; 0
    4b84:	e0 f7       	brcc	.-8      	; 0x4b7e <strncpy+0x14>
    4b86:	08 95       	ret

00004b88 <__subsf3>:
    4b88:	50 58       	subi	r21, 0x80	; 128

00004b8a <__addsf3>:
    4b8a:	bb 27       	eor	r27, r27
    4b8c:	aa 27       	eor	r26, r26
    4b8e:	0e d0       	rcall	.+28     	; 0x4bac <__addsf3x>
    4b90:	70 c1       	rjmp	.+736    	; 0x4e72 <__fp_round>
    4b92:	61 d1       	rcall	.+706    	; 0x4e56 <__fp_pscA>
    4b94:	30 f0       	brcs	.+12     	; 0x4ba2 <__addsf3+0x18>
    4b96:	66 d1       	rcall	.+716    	; 0x4e64 <__fp_pscB>
    4b98:	20 f0       	brcs	.+8      	; 0x4ba2 <__addsf3+0x18>
    4b9a:	31 f4       	brne	.+12     	; 0x4ba8 <__addsf3+0x1e>
    4b9c:	9f 3f       	cpi	r25, 0xFF	; 255
    4b9e:	11 f4       	brne	.+4      	; 0x4ba4 <__addsf3+0x1a>
    4ba0:	1e f4       	brtc	.+6      	; 0x4ba8 <__addsf3+0x1e>
    4ba2:	56 c1       	rjmp	.+684    	; 0x4e50 <__fp_nan>
    4ba4:	0e f4       	brtc	.+2      	; 0x4ba8 <__addsf3+0x1e>
    4ba6:	e0 95       	com	r30
    4ba8:	e7 fb       	bst	r30, 7
    4baa:	4c c1       	rjmp	.+664    	; 0x4e44 <__fp_inf>

00004bac <__addsf3x>:
    4bac:	e9 2f       	mov	r30, r25
    4bae:	72 d1       	rcall	.+740    	; 0x4e94 <__fp_split3>
    4bb0:	80 f3       	brcs	.-32     	; 0x4b92 <__addsf3+0x8>
    4bb2:	ba 17       	cp	r27, r26
    4bb4:	62 07       	cpc	r22, r18
    4bb6:	73 07       	cpc	r23, r19
    4bb8:	84 07       	cpc	r24, r20
    4bba:	95 07       	cpc	r25, r21
    4bbc:	18 f0       	brcs	.+6      	; 0x4bc4 <__addsf3x+0x18>
    4bbe:	71 f4       	brne	.+28     	; 0x4bdc <__addsf3x+0x30>
    4bc0:	9e f5       	brtc	.+102    	; 0x4c28 <__addsf3x+0x7c>
    4bc2:	8a c1       	rjmp	.+788    	; 0x4ed8 <__fp_zero>
    4bc4:	0e f4       	brtc	.+2      	; 0x4bc8 <__addsf3x+0x1c>
    4bc6:	e0 95       	com	r30
    4bc8:	0b 2e       	mov	r0, r27
    4bca:	ba 2f       	mov	r27, r26
    4bcc:	a0 2d       	mov	r26, r0
    4bce:	0b 01       	movw	r0, r22
    4bd0:	b9 01       	movw	r22, r18
    4bd2:	90 01       	movw	r18, r0
    4bd4:	0c 01       	movw	r0, r24
    4bd6:	ca 01       	movw	r24, r20
    4bd8:	a0 01       	movw	r20, r0
    4bda:	11 24       	eor	r1, r1
    4bdc:	ff 27       	eor	r31, r31
    4bde:	59 1b       	sub	r21, r25
    4be0:	99 f0       	breq	.+38     	; 0x4c08 <__addsf3x+0x5c>
    4be2:	59 3f       	cpi	r21, 0xF9	; 249
    4be4:	50 f4       	brcc	.+20     	; 0x4bfa <__addsf3x+0x4e>
    4be6:	50 3e       	cpi	r21, 0xE0	; 224
    4be8:	68 f1       	brcs	.+90     	; 0x4c44 <__addsf3x+0x98>
    4bea:	1a 16       	cp	r1, r26
    4bec:	f0 40       	sbci	r31, 0x00	; 0
    4bee:	a2 2f       	mov	r26, r18
    4bf0:	23 2f       	mov	r18, r19
    4bf2:	34 2f       	mov	r19, r20
    4bf4:	44 27       	eor	r20, r20
    4bf6:	58 5f       	subi	r21, 0xF8	; 248
    4bf8:	f3 cf       	rjmp	.-26     	; 0x4be0 <__addsf3x+0x34>
    4bfa:	46 95       	lsr	r20
    4bfc:	37 95       	ror	r19
    4bfe:	27 95       	ror	r18
    4c00:	a7 95       	ror	r26
    4c02:	f0 40       	sbci	r31, 0x00	; 0
    4c04:	53 95       	inc	r21
    4c06:	c9 f7       	brne	.-14     	; 0x4bfa <__addsf3x+0x4e>
    4c08:	7e f4       	brtc	.+30     	; 0x4c28 <__addsf3x+0x7c>
    4c0a:	1f 16       	cp	r1, r31
    4c0c:	ba 0b       	sbc	r27, r26
    4c0e:	62 0b       	sbc	r22, r18
    4c10:	73 0b       	sbc	r23, r19
    4c12:	84 0b       	sbc	r24, r20
    4c14:	ba f0       	brmi	.+46     	; 0x4c44 <__addsf3x+0x98>
    4c16:	91 50       	subi	r25, 0x01	; 1
    4c18:	a1 f0       	breq	.+40     	; 0x4c42 <__addsf3x+0x96>
    4c1a:	ff 0f       	add	r31, r31
    4c1c:	bb 1f       	adc	r27, r27
    4c1e:	66 1f       	adc	r22, r22
    4c20:	77 1f       	adc	r23, r23
    4c22:	88 1f       	adc	r24, r24
    4c24:	c2 f7       	brpl	.-16     	; 0x4c16 <__addsf3x+0x6a>
    4c26:	0e c0       	rjmp	.+28     	; 0x4c44 <__addsf3x+0x98>
    4c28:	ba 0f       	add	r27, r26
    4c2a:	62 1f       	adc	r22, r18
    4c2c:	73 1f       	adc	r23, r19
    4c2e:	84 1f       	adc	r24, r20
    4c30:	48 f4       	brcc	.+18     	; 0x4c44 <__addsf3x+0x98>
    4c32:	87 95       	ror	r24
    4c34:	77 95       	ror	r23
    4c36:	67 95       	ror	r22
    4c38:	b7 95       	ror	r27
    4c3a:	f7 95       	ror	r31
    4c3c:	9e 3f       	cpi	r25, 0xFE	; 254
    4c3e:	08 f0       	brcs	.+2      	; 0x4c42 <__addsf3x+0x96>
    4c40:	b3 cf       	rjmp	.-154    	; 0x4ba8 <__addsf3+0x1e>
    4c42:	93 95       	inc	r25
    4c44:	88 0f       	add	r24, r24
    4c46:	08 f0       	brcs	.+2      	; 0x4c4a <__addsf3x+0x9e>
    4c48:	99 27       	eor	r25, r25
    4c4a:	ee 0f       	add	r30, r30
    4c4c:	97 95       	ror	r25
    4c4e:	87 95       	ror	r24
    4c50:	08 95       	ret

00004c52 <__cmpsf2>:
    4c52:	d4 d0       	rcall	.+424    	; 0x4dfc <__fp_cmp>
    4c54:	08 f4       	brcc	.+2      	; 0x4c58 <__cmpsf2+0x6>
    4c56:	81 e0       	ldi	r24, 0x01	; 1
    4c58:	08 95       	ret

00004c5a <__divsf3>:
    4c5a:	0c d0       	rcall	.+24     	; 0x4c74 <__divsf3x>
    4c5c:	0a c1       	rjmp	.+532    	; 0x4e72 <__fp_round>
    4c5e:	02 d1       	rcall	.+516    	; 0x4e64 <__fp_pscB>
    4c60:	40 f0       	brcs	.+16     	; 0x4c72 <__divsf3+0x18>
    4c62:	f9 d0       	rcall	.+498    	; 0x4e56 <__fp_pscA>
    4c64:	30 f0       	brcs	.+12     	; 0x4c72 <__divsf3+0x18>
    4c66:	21 f4       	brne	.+8      	; 0x4c70 <__divsf3+0x16>
    4c68:	5f 3f       	cpi	r21, 0xFF	; 255
    4c6a:	19 f0       	breq	.+6      	; 0x4c72 <__divsf3+0x18>
    4c6c:	eb c0       	rjmp	.+470    	; 0x4e44 <__fp_inf>
    4c6e:	51 11       	cpse	r21, r1
    4c70:	34 c1       	rjmp	.+616    	; 0x4eda <__fp_szero>
    4c72:	ee c0       	rjmp	.+476    	; 0x4e50 <__fp_nan>

00004c74 <__divsf3x>:
    4c74:	0f d1       	rcall	.+542    	; 0x4e94 <__fp_split3>
    4c76:	98 f3       	brcs	.-26     	; 0x4c5e <__divsf3+0x4>

00004c78 <__divsf3_pse>:
    4c78:	99 23       	and	r25, r25
    4c7a:	c9 f3       	breq	.-14     	; 0x4c6e <__divsf3+0x14>
    4c7c:	55 23       	and	r21, r21
    4c7e:	b1 f3       	breq	.-20     	; 0x4c6c <__divsf3+0x12>
    4c80:	95 1b       	sub	r25, r21
    4c82:	55 0b       	sbc	r21, r21
    4c84:	bb 27       	eor	r27, r27
    4c86:	aa 27       	eor	r26, r26
    4c88:	62 17       	cp	r22, r18
    4c8a:	73 07       	cpc	r23, r19
    4c8c:	84 07       	cpc	r24, r20
    4c8e:	38 f0       	brcs	.+14     	; 0x4c9e <__divsf3_pse+0x26>
    4c90:	9f 5f       	subi	r25, 0xFF	; 255
    4c92:	5f 4f       	sbci	r21, 0xFF	; 255
    4c94:	22 0f       	add	r18, r18
    4c96:	33 1f       	adc	r19, r19
    4c98:	44 1f       	adc	r20, r20
    4c9a:	aa 1f       	adc	r26, r26
    4c9c:	a9 f3       	breq	.-22     	; 0x4c88 <__divsf3_pse+0x10>
    4c9e:	33 d0       	rcall	.+102    	; 0x4d06 <__divsf3_pse+0x8e>
    4ca0:	0e 2e       	mov	r0, r30
    4ca2:	3a f0       	brmi	.+14     	; 0x4cb2 <__divsf3_pse+0x3a>
    4ca4:	e0 e8       	ldi	r30, 0x80	; 128
    4ca6:	30 d0       	rcall	.+96     	; 0x4d08 <__divsf3_pse+0x90>
    4ca8:	91 50       	subi	r25, 0x01	; 1
    4caa:	50 40       	sbci	r21, 0x00	; 0
    4cac:	e6 95       	lsr	r30
    4cae:	00 1c       	adc	r0, r0
    4cb0:	ca f7       	brpl	.-14     	; 0x4ca4 <__divsf3_pse+0x2c>
    4cb2:	29 d0       	rcall	.+82     	; 0x4d06 <__divsf3_pse+0x8e>
    4cb4:	fe 2f       	mov	r31, r30
    4cb6:	27 d0       	rcall	.+78     	; 0x4d06 <__divsf3_pse+0x8e>
    4cb8:	66 0f       	add	r22, r22
    4cba:	77 1f       	adc	r23, r23
    4cbc:	88 1f       	adc	r24, r24
    4cbe:	bb 1f       	adc	r27, r27
    4cc0:	26 17       	cp	r18, r22
    4cc2:	37 07       	cpc	r19, r23
    4cc4:	48 07       	cpc	r20, r24
    4cc6:	ab 07       	cpc	r26, r27
    4cc8:	b0 e8       	ldi	r27, 0x80	; 128
    4cca:	09 f0       	breq	.+2      	; 0x4cce <__divsf3_pse+0x56>
    4ccc:	bb 0b       	sbc	r27, r27
    4cce:	80 2d       	mov	r24, r0
    4cd0:	bf 01       	movw	r22, r30
    4cd2:	ff 27       	eor	r31, r31
    4cd4:	93 58       	subi	r25, 0x83	; 131
    4cd6:	5f 4f       	sbci	r21, 0xFF	; 255
    4cd8:	2a f0       	brmi	.+10     	; 0x4ce4 <__divsf3_pse+0x6c>
    4cda:	9e 3f       	cpi	r25, 0xFE	; 254
    4cdc:	51 05       	cpc	r21, r1
    4cde:	68 f0       	brcs	.+26     	; 0x4cfa <__divsf3_pse+0x82>
    4ce0:	b1 c0       	rjmp	.+354    	; 0x4e44 <__fp_inf>
    4ce2:	fb c0       	rjmp	.+502    	; 0x4eda <__fp_szero>
    4ce4:	5f 3f       	cpi	r21, 0xFF	; 255
    4ce6:	ec f3       	brlt	.-6      	; 0x4ce2 <__divsf3_pse+0x6a>
    4ce8:	98 3e       	cpi	r25, 0xE8	; 232
    4cea:	dc f3       	brlt	.-10     	; 0x4ce2 <__divsf3_pse+0x6a>
    4cec:	86 95       	lsr	r24
    4cee:	77 95       	ror	r23
    4cf0:	67 95       	ror	r22
    4cf2:	b7 95       	ror	r27
    4cf4:	f7 95       	ror	r31
    4cf6:	9f 5f       	subi	r25, 0xFF	; 255
    4cf8:	c9 f7       	brne	.-14     	; 0x4cec <__divsf3_pse+0x74>
    4cfa:	88 0f       	add	r24, r24
    4cfc:	91 1d       	adc	r25, r1
    4cfe:	96 95       	lsr	r25
    4d00:	87 95       	ror	r24
    4d02:	97 f9       	bld	r25, 7
    4d04:	08 95       	ret
    4d06:	e1 e0       	ldi	r30, 0x01	; 1
    4d08:	66 0f       	add	r22, r22
    4d0a:	77 1f       	adc	r23, r23
    4d0c:	88 1f       	adc	r24, r24
    4d0e:	bb 1f       	adc	r27, r27
    4d10:	62 17       	cp	r22, r18
    4d12:	73 07       	cpc	r23, r19
    4d14:	84 07       	cpc	r24, r20
    4d16:	ba 07       	cpc	r27, r26
    4d18:	20 f0       	brcs	.+8      	; 0x4d22 <__divsf3_pse+0xaa>
    4d1a:	62 1b       	sub	r22, r18
    4d1c:	73 0b       	sbc	r23, r19
    4d1e:	84 0b       	sbc	r24, r20
    4d20:	ba 0b       	sbc	r27, r26
    4d22:	ee 1f       	adc	r30, r30
    4d24:	88 f7       	brcc	.-30     	; 0x4d08 <__divsf3_pse+0x90>
    4d26:	e0 95       	com	r30
    4d28:	08 95       	ret

00004d2a <__fixunssfsi>:
    4d2a:	bc d0       	rcall	.+376    	; 0x4ea4 <__fp_splitA>
    4d2c:	88 f0       	brcs	.+34     	; 0x4d50 <__fixunssfsi+0x26>
    4d2e:	9f 57       	subi	r25, 0x7F	; 127
    4d30:	90 f0       	brcs	.+36     	; 0x4d56 <__fixunssfsi+0x2c>
    4d32:	b9 2f       	mov	r27, r25
    4d34:	99 27       	eor	r25, r25
    4d36:	b7 51       	subi	r27, 0x17	; 23
    4d38:	a0 f0       	brcs	.+40     	; 0x4d62 <__fixunssfsi+0x38>
    4d3a:	d1 f0       	breq	.+52     	; 0x4d70 <__fixunssfsi+0x46>
    4d3c:	66 0f       	add	r22, r22
    4d3e:	77 1f       	adc	r23, r23
    4d40:	88 1f       	adc	r24, r24
    4d42:	99 1f       	adc	r25, r25
    4d44:	1a f0       	brmi	.+6      	; 0x4d4c <__fixunssfsi+0x22>
    4d46:	ba 95       	dec	r27
    4d48:	c9 f7       	brne	.-14     	; 0x4d3c <__fixunssfsi+0x12>
    4d4a:	12 c0       	rjmp	.+36     	; 0x4d70 <__fixunssfsi+0x46>
    4d4c:	b1 30       	cpi	r27, 0x01	; 1
    4d4e:	81 f0       	breq	.+32     	; 0x4d70 <__fixunssfsi+0x46>
    4d50:	c3 d0       	rcall	.+390    	; 0x4ed8 <__fp_zero>
    4d52:	b1 e0       	ldi	r27, 0x01	; 1
    4d54:	08 95       	ret
    4d56:	c0 c0       	rjmp	.+384    	; 0x4ed8 <__fp_zero>
    4d58:	67 2f       	mov	r22, r23
    4d5a:	78 2f       	mov	r23, r24
    4d5c:	88 27       	eor	r24, r24
    4d5e:	b8 5f       	subi	r27, 0xF8	; 248
    4d60:	39 f0       	breq	.+14     	; 0x4d70 <__fixunssfsi+0x46>
    4d62:	b9 3f       	cpi	r27, 0xF9	; 249
    4d64:	cc f3       	brlt	.-14     	; 0x4d58 <__fixunssfsi+0x2e>
    4d66:	86 95       	lsr	r24
    4d68:	77 95       	ror	r23
    4d6a:	67 95       	ror	r22
    4d6c:	b3 95       	inc	r27
    4d6e:	d9 f7       	brne	.-10     	; 0x4d66 <__fixunssfsi+0x3c>
    4d70:	3e f4       	brtc	.+14     	; 0x4d80 <__fixunssfsi+0x56>
    4d72:	90 95       	com	r25
    4d74:	80 95       	com	r24
    4d76:	70 95       	com	r23
    4d78:	61 95       	neg	r22
    4d7a:	7f 4f       	sbci	r23, 0xFF	; 255
    4d7c:	8f 4f       	sbci	r24, 0xFF	; 255
    4d7e:	9f 4f       	sbci	r25, 0xFF	; 255
    4d80:	08 95       	ret

00004d82 <__floatunsisf>:
    4d82:	e8 94       	clt
    4d84:	09 c0       	rjmp	.+18     	; 0x4d98 <__floatsisf+0x12>

00004d86 <__floatsisf>:
    4d86:	97 fb       	bst	r25, 7
    4d88:	3e f4       	brtc	.+14     	; 0x4d98 <__floatsisf+0x12>
    4d8a:	90 95       	com	r25
    4d8c:	80 95       	com	r24
    4d8e:	70 95       	com	r23
    4d90:	61 95       	neg	r22
    4d92:	7f 4f       	sbci	r23, 0xFF	; 255
    4d94:	8f 4f       	sbci	r24, 0xFF	; 255
    4d96:	9f 4f       	sbci	r25, 0xFF	; 255
    4d98:	99 23       	and	r25, r25
    4d9a:	a9 f0       	breq	.+42     	; 0x4dc6 <__floatsisf+0x40>
    4d9c:	f9 2f       	mov	r31, r25
    4d9e:	96 e9       	ldi	r25, 0x96	; 150
    4da0:	bb 27       	eor	r27, r27
    4da2:	93 95       	inc	r25
    4da4:	f6 95       	lsr	r31
    4da6:	87 95       	ror	r24
    4da8:	77 95       	ror	r23
    4daa:	67 95       	ror	r22
    4dac:	b7 95       	ror	r27
    4dae:	f1 11       	cpse	r31, r1
    4db0:	f8 cf       	rjmp	.-16     	; 0x4da2 <__floatsisf+0x1c>
    4db2:	fa f4       	brpl	.+62     	; 0x4df2 <__floatsisf+0x6c>
    4db4:	bb 0f       	add	r27, r27
    4db6:	11 f4       	brne	.+4      	; 0x4dbc <__floatsisf+0x36>
    4db8:	60 ff       	sbrs	r22, 0
    4dba:	1b c0       	rjmp	.+54     	; 0x4df2 <__floatsisf+0x6c>
    4dbc:	6f 5f       	subi	r22, 0xFF	; 255
    4dbe:	7f 4f       	sbci	r23, 0xFF	; 255
    4dc0:	8f 4f       	sbci	r24, 0xFF	; 255
    4dc2:	9f 4f       	sbci	r25, 0xFF	; 255
    4dc4:	16 c0       	rjmp	.+44     	; 0x4df2 <__floatsisf+0x6c>
    4dc6:	88 23       	and	r24, r24
    4dc8:	11 f0       	breq	.+4      	; 0x4dce <__floatsisf+0x48>
    4dca:	96 e9       	ldi	r25, 0x96	; 150
    4dcc:	11 c0       	rjmp	.+34     	; 0x4df0 <__floatsisf+0x6a>
    4dce:	77 23       	and	r23, r23
    4dd0:	21 f0       	breq	.+8      	; 0x4dda <__floatsisf+0x54>
    4dd2:	9e e8       	ldi	r25, 0x8E	; 142
    4dd4:	87 2f       	mov	r24, r23
    4dd6:	76 2f       	mov	r23, r22
    4dd8:	05 c0       	rjmp	.+10     	; 0x4de4 <__floatsisf+0x5e>
    4dda:	66 23       	and	r22, r22
    4ddc:	71 f0       	breq	.+28     	; 0x4dfa <__floatsisf+0x74>
    4dde:	96 e8       	ldi	r25, 0x86	; 134
    4de0:	86 2f       	mov	r24, r22
    4de2:	70 e0       	ldi	r23, 0x00	; 0
    4de4:	60 e0       	ldi	r22, 0x00	; 0
    4de6:	2a f0       	brmi	.+10     	; 0x4df2 <__floatsisf+0x6c>
    4de8:	9a 95       	dec	r25
    4dea:	66 0f       	add	r22, r22
    4dec:	77 1f       	adc	r23, r23
    4dee:	88 1f       	adc	r24, r24
    4df0:	da f7       	brpl	.-10     	; 0x4de8 <__floatsisf+0x62>
    4df2:	88 0f       	add	r24, r24
    4df4:	96 95       	lsr	r25
    4df6:	87 95       	ror	r24
    4df8:	97 f9       	bld	r25, 7
    4dfa:	08 95       	ret

00004dfc <__fp_cmp>:
    4dfc:	99 0f       	add	r25, r25
    4dfe:	00 08       	sbc	r0, r0
    4e00:	55 0f       	add	r21, r21
    4e02:	aa 0b       	sbc	r26, r26
    4e04:	e0 e8       	ldi	r30, 0x80	; 128
    4e06:	fe ef       	ldi	r31, 0xFE	; 254
    4e08:	16 16       	cp	r1, r22
    4e0a:	17 06       	cpc	r1, r23
    4e0c:	e8 07       	cpc	r30, r24
    4e0e:	f9 07       	cpc	r31, r25
    4e10:	c0 f0       	brcs	.+48     	; 0x4e42 <__fp_cmp+0x46>
    4e12:	12 16       	cp	r1, r18
    4e14:	13 06       	cpc	r1, r19
    4e16:	e4 07       	cpc	r30, r20
    4e18:	f5 07       	cpc	r31, r21
    4e1a:	98 f0       	brcs	.+38     	; 0x4e42 <__fp_cmp+0x46>
    4e1c:	62 1b       	sub	r22, r18
    4e1e:	73 0b       	sbc	r23, r19
    4e20:	84 0b       	sbc	r24, r20
    4e22:	95 0b       	sbc	r25, r21
    4e24:	39 f4       	brne	.+14     	; 0x4e34 <__fp_cmp+0x38>
    4e26:	0a 26       	eor	r0, r26
    4e28:	61 f0       	breq	.+24     	; 0x4e42 <__fp_cmp+0x46>
    4e2a:	23 2b       	or	r18, r19
    4e2c:	24 2b       	or	r18, r20
    4e2e:	25 2b       	or	r18, r21
    4e30:	21 f4       	brne	.+8      	; 0x4e3a <__fp_cmp+0x3e>
    4e32:	08 95       	ret
    4e34:	0a 26       	eor	r0, r26
    4e36:	09 f4       	brne	.+2      	; 0x4e3a <__fp_cmp+0x3e>
    4e38:	a1 40       	sbci	r26, 0x01	; 1
    4e3a:	a6 95       	lsr	r26
    4e3c:	8f ef       	ldi	r24, 0xFF	; 255
    4e3e:	81 1d       	adc	r24, r1
    4e40:	81 1d       	adc	r24, r1
    4e42:	08 95       	ret

00004e44 <__fp_inf>:
    4e44:	97 f9       	bld	r25, 7
    4e46:	9f 67       	ori	r25, 0x7F	; 127
    4e48:	80 e8       	ldi	r24, 0x80	; 128
    4e4a:	70 e0       	ldi	r23, 0x00	; 0
    4e4c:	60 e0       	ldi	r22, 0x00	; 0
    4e4e:	08 95       	ret

00004e50 <__fp_nan>:
    4e50:	9f ef       	ldi	r25, 0xFF	; 255
    4e52:	80 ec       	ldi	r24, 0xC0	; 192
    4e54:	08 95       	ret

00004e56 <__fp_pscA>:
    4e56:	00 24       	eor	r0, r0
    4e58:	0a 94       	dec	r0
    4e5a:	16 16       	cp	r1, r22
    4e5c:	17 06       	cpc	r1, r23
    4e5e:	18 06       	cpc	r1, r24
    4e60:	09 06       	cpc	r0, r25
    4e62:	08 95       	ret

00004e64 <__fp_pscB>:
    4e64:	00 24       	eor	r0, r0
    4e66:	0a 94       	dec	r0
    4e68:	12 16       	cp	r1, r18
    4e6a:	13 06       	cpc	r1, r19
    4e6c:	14 06       	cpc	r1, r20
    4e6e:	05 06       	cpc	r0, r21
    4e70:	08 95       	ret

00004e72 <__fp_round>:
    4e72:	09 2e       	mov	r0, r25
    4e74:	03 94       	inc	r0
    4e76:	00 0c       	add	r0, r0
    4e78:	11 f4       	brne	.+4      	; 0x4e7e <__fp_round+0xc>
    4e7a:	88 23       	and	r24, r24
    4e7c:	52 f0       	brmi	.+20     	; 0x4e92 <__fp_round+0x20>
    4e7e:	bb 0f       	add	r27, r27
    4e80:	40 f4       	brcc	.+16     	; 0x4e92 <__fp_round+0x20>
    4e82:	bf 2b       	or	r27, r31
    4e84:	11 f4       	brne	.+4      	; 0x4e8a <__fp_round+0x18>
    4e86:	60 ff       	sbrs	r22, 0
    4e88:	04 c0       	rjmp	.+8      	; 0x4e92 <__fp_round+0x20>
    4e8a:	6f 5f       	subi	r22, 0xFF	; 255
    4e8c:	7f 4f       	sbci	r23, 0xFF	; 255
    4e8e:	8f 4f       	sbci	r24, 0xFF	; 255
    4e90:	9f 4f       	sbci	r25, 0xFF	; 255
    4e92:	08 95       	ret

00004e94 <__fp_split3>:
    4e94:	57 fd       	sbrc	r21, 7
    4e96:	90 58       	subi	r25, 0x80	; 128
    4e98:	44 0f       	add	r20, r20
    4e9a:	55 1f       	adc	r21, r21
    4e9c:	59 f0       	breq	.+22     	; 0x4eb4 <__fp_splitA+0x10>
    4e9e:	5f 3f       	cpi	r21, 0xFF	; 255
    4ea0:	71 f0       	breq	.+28     	; 0x4ebe <__fp_splitA+0x1a>
    4ea2:	47 95       	ror	r20

00004ea4 <__fp_splitA>:
    4ea4:	88 0f       	add	r24, r24
    4ea6:	97 fb       	bst	r25, 7
    4ea8:	99 1f       	adc	r25, r25
    4eaa:	61 f0       	breq	.+24     	; 0x4ec4 <__fp_splitA+0x20>
    4eac:	9f 3f       	cpi	r25, 0xFF	; 255
    4eae:	79 f0       	breq	.+30     	; 0x4ece <__fp_splitA+0x2a>
    4eb0:	87 95       	ror	r24
    4eb2:	08 95       	ret
    4eb4:	12 16       	cp	r1, r18
    4eb6:	13 06       	cpc	r1, r19
    4eb8:	14 06       	cpc	r1, r20
    4eba:	55 1f       	adc	r21, r21
    4ebc:	f2 cf       	rjmp	.-28     	; 0x4ea2 <__fp_split3+0xe>
    4ebe:	46 95       	lsr	r20
    4ec0:	f1 df       	rcall	.-30     	; 0x4ea4 <__fp_splitA>
    4ec2:	08 c0       	rjmp	.+16     	; 0x4ed4 <__fp_splitA+0x30>
    4ec4:	16 16       	cp	r1, r22
    4ec6:	17 06       	cpc	r1, r23
    4ec8:	18 06       	cpc	r1, r24
    4eca:	99 1f       	adc	r25, r25
    4ecc:	f1 cf       	rjmp	.-30     	; 0x4eb0 <__fp_splitA+0xc>
    4ece:	86 95       	lsr	r24
    4ed0:	71 05       	cpc	r23, r1
    4ed2:	61 05       	cpc	r22, r1
    4ed4:	08 94       	sec
    4ed6:	08 95       	ret

00004ed8 <__fp_zero>:
    4ed8:	e8 94       	clt

00004eda <__fp_szero>:
    4eda:	bb 27       	eor	r27, r27
    4edc:	66 27       	eor	r22, r22
    4ede:	77 27       	eor	r23, r23
    4ee0:	cb 01       	movw	r24, r22
    4ee2:	97 f9       	bld	r25, 7
    4ee4:	08 95       	ret

00004ee6 <__gesf2>:
    4ee6:	8a df       	rcall	.-236    	; 0x4dfc <__fp_cmp>
    4ee8:	08 f4       	brcc	.+2      	; 0x4eec <__gesf2+0x6>
    4eea:	8f ef       	ldi	r24, 0xFF	; 255
    4eec:	08 95       	ret

00004eee <__mulsf3>:
    4eee:	0b d0       	rcall	.+22     	; 0x4f06 <__mulsf3x>
    4ef0:	c0 cf       	rjmp	.-128    	; 0x4e72 <__fp_round>
    4ef2:	b1 df       	rcall	.-158    	; 0x4e56 <__fp_pscA>
    4ef4:	28 f0       	brcs	.+10     	; 0x4f00 <__mulsf3+0x12>
    4ef6:	b6 df       	rcall	.-148    	; 0x4e64 <__fp_pscB>
    4ef8:	18 f0       	brcs	.+6      	; 0x4f00 <__mulsf3+0x12>
    4efa:	95 23       	and	r25, r21
    4efc:	09 f0       	breq	.+2      	; 0x4f00 <__mulsf3+0x12>
    4efe:	a2 cf       	rjmp	.-188    	; 0x4e44 <__fp_inf>
    4f00:	a7 cf       	rjmp	.-178    	; 0x4e50 <__fp_nan>
    4f02:	11 24       	eor	r1, r1
    4f04:	ea cf       	rjmp	.-44     	; 0x4eda <__fp_szero>

00004f06 <__mulsf3x>:
    4f06:	c6 df       	rcall	.-116    	; 0x4e94 <__fp_split3>
    4f08:	a0 f3       	brcs	.-24     	; 0x4ef2 <__mulsf3+0x4>

00004f0a <__mulsf3_pse>:
    4f0a:	95 9f       	mul	r25, r21
    4f0c:	d1 f3       	breq	.-12     	; 0x4f02 <__mulsf3+0x14>
    4f0e:	95 0f       	add	r25, r21
    4f10:	50 e0       	ldi	r21, 0x00	; 0
    4f12:	55 1f       	adc	r21, r21
    4f14:	62 9f       	mul	r22, r18
    4f16:	f0 01       	movw	r30, r0
    4f18:	72 9f       	mul	r23, r18
    4f1a:	bb 27       	eor	r27, r27
    4f1c:	f0 0d       	add	r31, r0
    4f1e:	b1 1d       	adc	r27, r1
    4f20:	63 9f       	mul	r22, r19
    4f22:	aa 27       	eor	r26, r26
    4f24:	f0 0d       	add	r31, r0
    4f26:	b1 1d       	adc	r27, r1
    4f28:	aa 1f       	adc	r26, r26
    4f2a:	64 9f       	mul	r22, r20
    4f2c:	66 27       	eor	r22, r22
    4f2e:	b0 0d       	add	r27, r0
    4f30:	a1 1d       	adc	r26, r1
    4f32:	66 1f       	adc	r22, r22
    4f34:	82 9f       	mul	r24, r18
    4f36:	22 27       	eor	r18, r18
    4f38:	b0 0d       	add	r27, r0
    4f3a:	a1 1d       	adc	r26, r1
    4f3c:	62 1f       	adc	r22, r18
    4f3e:	73 9f       	mul	r23, r19
    4f40:	b0 0d       	add	r27, r0
    4f42:	a1 1d       	adc	r26, r1
    4f44:	62 1f       	adc	r22, r18
    4f46:	83 9f       	mul	r24, r19
    4f48:	a0 0d       	add	r26, r0
    4f4a:	61 1d       	adc	r22, r1
    4f4c:	22 1f       	adc	r18, r18
    4f4e:	74 9f       	mul	r23, r20
    4f50:	33 27       	eor	r19, r19
    4f52:	a0 0d       	add	r26, r0
    4f54:	61 1d       	adc	r22, r1
    4f56:	23 1f       	adc	r18, r19
    4f58:	84 9f       	mul	r24, r20
    4f5a:	60 0d       	add	r22, r0
    4f5c:	21 1d       	adc	r18, r1
    4f5e:	82 2f       	mov	r24, r18
    4f60:	76 2f       	mov	r23, r22
    4f62:	6a 2f       	mov	r22, r26
    4f64:	11 24       	eor	r1, r1
    4f66:	9f 57       	subi	r25, 0x7F	; 127
    4f68:	50 40       	sbci	r21, 0x00	; 0
    4f6a:	8a f0       	brmi	.+34     	; 0x4f8e <__mulsf3_pse+0x84>
    4f6c:	e1 f0       	breq	.+56     	; 0x4fa6 <__mulsf3_pse+0x9c>
    4f6e:	88 23       	and	r24, r24
    4f70:	4a f0       	brmi	.+18     	; 0x4f84 <__mulsf3_pse+0x7a>
    4f72:	ee 0f       	add	r30, r30
    4f74:	ff 1f       	adc	r31, r31
    4f76:	bb 1f       	adc	r27, r27
    4f78:	66 1f       	adc	r22, r22
    4f7a:	77 1f       	adc	r23, r23
    4f7c:	88 1f       	adc	r24, r24
    4f7e:	91 50       	subi	r25, 0x01	; 1
    4f80:	50 40       	sbci	r21, 0x00	; 0
    4f82:	a9 f7       	brne	.-22     	; 0x4f6e <__mulsf3_pse+0x64>
    4f84:	9e 3f       	cpi	r25, 0xFE	; 254
    4f86:	51 05       	cpc	r21, r1
    4f88:	70 f0       	brcs	.+28     	; 0x4fa6 <__mulsf3_pse+0x9c>
    4f8a:	5c cf       	rjmp	.-328    	; 0x4e44 <__fp_inf>
    4f8c:	a6 cf       	rjmp	.-180    	; 0x4eda <__fp_szero>
    4f8e:	5f 3f       	cpi	r21, 0xFF	; 255
    4f90:	ec f3       	brlt	.-6      	; 0x4f8c <__mulsf3_pse+0x82>
    4f92:	98 3e       	cpi	r25, 0xE8	; 232
    4f94:	dc f3       	brlt	.-10     	; 0x4f8c <__mulsf3_pse+0x82>
    4f96:	86 95       	lsr	r24
    4f98:	77 95       	ror	r23
    4f9a:	67 95       	ror	r22
    4f9c:	b7 95       	ror	r27
    4f9e:	f7 95       	ror	r31
    4fa0:	e7 95       	ror	r30
    4fa2:	9f 5f       	subi	r25, 0xFF	; 255
    4fa4:	c1 f7       	brne	.-16     	; 0x4f96 <__mulsf3_pse+0x8c>
    4fa6:	fe 2b       	or	r31, r30
    4fa8:	88 0f       	add	r24, r24
    4faa:	91 1d       	adc	r25, r1
    4fac:	96 95       	lsr	r25
    4fae:	87 95       	ror	r24
    4fb0:	97 f9       	bld	r25, 7
    4fb2:	08 95       	ret

00004fb4 <__udivmodhi4>:
    4fb4:	aa 1b       	sub	r26, r26
    4fb6:	bb 1b       	sub	r27, r27
    4fb8:	51 e1       	ldi	r21, 0x11	; 17
    4fba:	07 c0       	rjmp	.+14     	; 0x4fca <__udivmodhi4_ep>

00004fbc <__udivmodhi4_loop>:
    4fbc:	aa 1f       	adc	r26, r26
    4fbe:	bb 1f       	adc	r27, r27
    4fc0:	a6 17       	cp	r26, r22
    4fc2:	b7 07       	cpc	r27, r23
    4fc4:	10 f0       	brcs	.+4      	; 0x4fca <__udivmodhi4_ep>
    4fc6:	a6 1b       	sub	r26, r22
    4fc8:	b7 0b       	sbc	r27, r23

00004fca <__udivmodhi4_ep>:
    4fca:	88 1f       	adc	r24, r24
    4fcc:	99 1f       	adc	r25, r25
    4fce:	5a 95       	dec	r21
    4fd0:	a9 f7       	brne	.-22     	; 0x4fbc <__udivmodhi4_loop>
    4fd2:	80 95       	com	r24
    4fd4:	90 95       	com	r25
    4fd6:	bc 01       	movw	r22, r24
    4fd8:	cd 01       	movw	r24, r26
    4fda:	08 95       	ret

00004fdc <__divmodhi4>:
    4fdc:	97 fb       	bst	r25, 7
    4fde:	09 2e       	mov	r0, r25
    4fe0:	07 26       	eor	r0, r23
    4fe2:	0a d0       	rcall	.+20     	; 0x4ff8 <__divmodhi4_neg1>
    4fe4:	77 fd       	sbrc	r23, 7
    4fe6:	04 d0       	rcall	.+8      	; 0x4ff0 <__divmodhi4_neg2>
    4fe8:	e5 df       	rcall	.-54     	; 0x4fb4 <__udivmodhi4>
    4fea:	06 d0       	rcall	.+12     	; 0x4ff8 <__divmodhi4_neg1>
    4fec:	00 20       	and	r0, r0
    4fee:	1a f4       	brpl	.+6      	; 0x4ff6 <__divmodhi4_exit>

00004ff0 <__divmodhi4_neg2>:
    4ff0:	70 95       	com	r23
    4ff2:	61 95       	neg	r22
    4ff4:	7f 4f       	sbci	r23, 0xFF	; 255

00004ff6 <__divmodhi4_exit>:
    4ff6:	08 95       	ret

00004ff8 <__divmodhi4_neg1>:
    4ff8:	f6 f7       	brtc	.-4      	; 0x4ff6 <__divmodhi4_exit>
    4ffa:	90 95       	com	r25
    4ffc:	81 95       	neg	r24
    4ffe:	9f 4f       	sbci	r25, 0xFF	; 255
    5000:	08 95       	ret

00005002 <__udivmodsi4>:
    5002:	a1 e2       	ldi	r26, 0x21	; 33
    5004:	1a 2e       	mov	r1, r26
    5006:	aa 1b       	sub	r26, r26
    5008:	bb 1b       	sub	r27, r27
    500a:	fd 01       	movw	r30, r26
    500c:	0d c0       	rjmp	.+26     	; 0x5028 <__udivmodsi4_ep>

0000500e <__udivmodsi4_loop>:
    500e:	aa 1f       	adc	r26, r26
    5010:	bb 1f       	adc	r27, r27
    5012:	ee 1f       	adc	r30, r30
    5014:	ff 1f       	adc	r31, r31
    5016:	a2 17       	cp	r26, r18
    5018:	b3 07       	cpc	r27, r19
    501a:	e4 07       	cpc	r30, r20
    501c:	f5 07       	cpc	r31, r21
    501e:	20 f0       	brcs	.+8      	; 0x5028 <__udivmodsi4_ep>
    5020:	a2 1b       	sub	r26, r18
    5022:	b3 0b       	sbc	r27, r19
    5024:	e4 0b       	sbc	r30, r20
    5026:	f5 0b       	sbc	r31, r21

00005028 <__udivmodsi4_ep>:
    5028:	66 1f       	adc	r22, r22
    502a:	77 1f       	adc	r23, r23
    502c:	88 1f       	adc	r24, r24
    502e:	99 1f       	adc	r25, r25
    5030:	1a 94       	dec	r1
    5032:	69 f7       	brne	.-38     	; 0x500e <__udivmodsi4_loop>
    5034:	60 95       	com	r22
    5036:	70 95       	com	r23
    5038:	80 95       	com	r24
    503a:	90 95       	com	r25
    503c:	9b 01       	movw	r18, r22
    503e:	ac 01       	movw	r20, r24
    5040:	bd 01       	movw	r22, r26
    5042:	cf 01       	movw	r24, r30
    5044:	08 95       	ret

00005046 <__divmodsi4>:
    5046:	97 fb       	bst	r25, 7
    5048:	09 2e       	mov	r0, r25
    504a:	05 26       	eor	r0, r21
    504c:	0e d0       	rcall	.+28     	; 0x506a <__divmodsi4_neg1>
    504e:	57 fd       	sbrc	r21, 7
    5050:	04 d0       	rcall	.+8      	; 0x505a <__divmodsi4_neg2>
    5052:	d7 df       	rcall	.-82     	; 0x5002 <__udivmodsi4>
    5054:	0a d0       	rcall	.+20     	; 0x506a <__divmodsi4_neg1>
    5056:	00 1c       	adc	r0, r0
    5058:	38 f4       	brcc	.+14     	; 0x5068 <__divmodsi4_exit>

0000505a <__divmodsi4_neg2>:
    505a:	50 95       	com	r21
    505c:	40 95       	com	r20
    505e:	30 95       	com	r19
    5060:	21 95       	neg	r18
    5062:	3f 4f       	sbci	r19, 0xFF	; 255
    5064:	4f 4f       	sbci	r20, 0xFF	; 255
    5066:	5f 4f       	sbci	r21, 0xFF	; 255

00005068 <__divmodsi4_exit>:
    5068:	08 95       	ret

0000506a <__divmodsi4_neg1>:
    506a:	f6 f7       	brtc	.-4      	; 0x5068 <__divmodsi4_exit>
    506c:	90 95       	com	r25
    506e:	80 95       	com	r24
    5070:	70 95       	com	r23
    5072:	61 95       	neg	r22
    5074:	7f 4f       	sbci	r23, 0xFF	; 255
    5076:	8f 4f       	sbci	r24, 0xFF	; 255
    5078:	9f 4f       	sbci	r25, 0xFF	; 255
    507a:	08 95       	ret

0000507c <_exit>:
    507c:	f8 94       	cli

0000507e <__stop_program>:
    507e:	ff cf       	rjmp	.-2      	; 0x507e <__stop_program>

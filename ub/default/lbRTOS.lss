
lbRTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000098  00800200  00005236  000052ca  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00005236  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00001093  00800298  00800298  00005362  2**0
                  ALLOC
  3 .debug_aranges 000001a0  00000000  00000000  00005362  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000016c8  00000000  00000000  00005502  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00005584  00000000  00000000  00006bca  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000016e3  00000000  00000000  0000c14e  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00004461  00000000  00000000  0000d831  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00001160  00000000  00000000  00011c94  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000022f8  00000000  00000000  00012df4  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000029cf  00000000  00000000  000150ec  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000060  00000000  00000000  00017abb  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 e6 00 	jmp	0x1cc	; 0x1cc <__ctors_end>
       4:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
       8:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
       c:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      10:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      14:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      18:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      1c:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      20:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      24:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      28:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      2c:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      30:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      34:	0c 94 26 19 	jmp	0x324c	; 0x324c <__vector_13>
      38:	0c 94 53 19 	jmp	0x32a6	; 0x32a6 <__vector_14>
      3c:	0c 94 45 17 	jmp	0x2e8a	; 0x2e8a <__vector_15>
      40:	0c 94 9f 18 	jmp	0x313e	; 0x313e <__vector_16>
      44:	0c 94 73 12 	jmp	0x24e6	; 0x24e6 <__vector_17>
      48:	0c 94 cc 18 	jmp	0x3198	; 0x3198 <__vector_18>
      4c:	0c 94 f9 18 	jmp	0x31f2	; 0x31f2 <__vector_19>
      50:	0c 94 05 17 	jmp	0x2e0a	; 0x2e0a <__vector_20>
      54:	0c 94 45 18 	jmp	0x308a	; 0x308a <__vector_21>
      58:	0c 94 72 18 	jmp	0x30e4	; 0x30e4 <__vector_22>
      5c:	0c 94 b2 16 	jmp	0x2d64	; 0x2d64 <__vector_23>
      60:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      64:	0c 94 1c 1d 	jmp	0x3a38	; 0x3a38 <__vector_25>
      68:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      6c:	0c 94 79 1e 	jmp	0x3cf2	; 0x3cf2 <__vector_27>
      70:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      74:	0c 94 33 21 	jmp	0x4266	; 0x4266 <__vector_29>
      78:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      7c:	0c 94 80 19 	jmp	0x3300	; 0x3300 <__vector_31>
      80:	0c 94 ad 19 	jmp	0x335a	; 0x335a <__vector_32>
      84:	0c 94 da 19 	jmp	0x33b4	; 0x33b4 <__vector_33>
      88:	0c 94 07 1a 	jmp	0x340e	; 0x340e <__vector_34>
      8c:	0c 94 85 17 	jmp	0x2f0a	; 0x2f0a <__vector_35>
      90:	0c 94 f7 1c 	jmp	0x39ee	; 0x39ee <__vector_36>
      94:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      98:	0c 94 54 1e 	jmp	0x3ca8	; 0x3ca8 <__vector_38>
      9c:	0c 94 51 25 	jmp	0x4aa2	; 0x4aa2 <__vector_39>
      a0:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      a4:	0c 94 34 1a 	jmp	0x3468	; 0x3468 <__vector_41>
      a8:	0c 94 61 1a 	jmp	0x34c2	; 0x34c2 <__vector_42>
      ac:	0c 94 8e 1a 	jmp	0x351c	; 0x351c <__vector_43>
      b0:	0c 94 bb 1a 	jmp	0x3576	; 0x3576 <__vector_44>
      b4:	0c 94 c5 17 	jmp	0x2f8a	; 0x2f8a <__vector_45>
      b8:	0c 94 e8 1a 	jmp	0x35d0	; 0x35d0 <__vector_46>
      bc:	0c 94 15 1b 	jmp	0x362a	; 0x362a <__vector_47>
      c0:	0c 94 42 1b 	jmp	0x3684	; 0x3684 <__vector_48>
      c4:	0c 94 6f 1b 	jmp	0x36de	; 0x36de <__vector_49>
      c8:	0c 94 05 18 	jmp	0x300a	; 0x300a <__vector_50>
      cc:	0c 94 d2 1c 	jmp	0x39a4	; 0x39a4 <__vector_51>
      d0:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      d4:	0c 94 2f 1e 	jmp	0x3c5e	; 0x3c5e <__vector_53>
      d8:	0c 94 ad 1c 	jmp	0x395a	; 0x395a <__vector_54>
      dc:	0c 94 03 01 	jmp	0x206	; 0x206 <__bad_interrupt>
      e0:	0c 94 0a 1e 	jmp	0x3c14	; 0x3c14 <__vector_56>

000000e4 <__c.2983>:
      e4:	0a 53 63 61 6e 20 65 6e 64 0a 0a 00                 .Scan end...

000000f0 <__c.2978>:
      f0:	25 64 00                                            %d.

000000f3 <__c.2975>:
      f3:	53 63 61 6e 20 73 74 61 72 74 0a 00                 Scan start..

000000ff <__c.2973>:
      ff:	46 72 61 6d 65 73 20 43 6f 6e 76 65 72 74 65 64     Frames Converted
     10f:	2e 0a 00                                            ...

00000112 <__c.2971>:
     112:	46 72 61 6d 65 73 20 67 72 61 62 62 65 64 2e 0a     Frames grabbed..
	...

00000123 <__c.2969>:
     123:	53 74 61 72 74 69 6e 67 20 70 72 6f 67 72 61 6d     Starting program
     133:	2e 0a 00                                            ...

00000136 <__c.2915>:
     136:	25 64 20 00                                         %d .

0000013a <__c.2912>:
     13a:	20 44 69 73 74 61 6e 63 65 73 3a 20 00               Distances: .

00000147 <__c.2910>:
     147:	20 4d 6f 74 6f 72 20 53 70 65 65 64 3a 20 00         Motor Speed: .

00000156 <__c.2908>:
     156:	49 6e 64 65 78 3a 20 00                             Index: .

0000015e <__c.2873>:
     15e:	49 6e 69 74 69 61 6c 69 7a 61 74 69 6f 6e 20 43     Initialization C
     16e:	6f 6d 70 6c 65 74 65 20 0d 0a 00                    omplete ...

00000179 <__c.2868>:
     179:	2e 00                                               ..

0000017b <__c.2866>:
     17b:	0d 0a 53 79 73 74 65 6d 20 57 61 72 6d 65 64 20     ..System Warmed 
     18b:	55 70 00                                            Up.

0000018e <TimerPrescaleFactor>:
     18e:	00 00 01 00 08 00 40 00 00 01 00 04                 ......@.....

0000019a <Timer2PrescaleFactor>:
     19a:	00 00 01 00 08 00 20 00 40 00 80 00 00 01 00 04     ...... .@.......

000001aa <__c.1991>:
     1aa:	42 41 44 5f 76 65 63 74 20 63 61 6c 6c 65 64 21     BAD_vect called!
	...

000001bb <HexChars>:
     1bb:	30 31 32 33 34 35 36 37 38 39 41 42 43 44 45 46     0123456789ABCDEF
	...

000001cc <__ctors_end>:
     1cc:	11 24       	eor	r1, r1
     1ce:	1f be       	out	0x3f, r1	; 63
     1d0:	cf ef       	ldi	r28, 0xFF	; 255
     1d2:	d1 e2       	ldi	r29, 0x21	; 33
     1d4:	de bf       	out	0x3e, r29	; 62
     1d6:	cd bf       	out	0x3d, r28	; 61

000001d8 <__do_copy_data>:
     1d8:	12 e0       	ldi	r17, 0x02	; 2
     1da:	a0 e0       	ldi	r26, 0x00	; 0
     1dc:	b2 e0       	ldi	r27, 0x02	; 2
     1de:	e6 e3       	ldi	r30, 0x36	; 54
     1e0:	f2 e5       	ldi	r31, 0x52	; 82
     1e2:	02 c0       	rjmp	.+4      	; 0x1e8 <.do_copy_data_start>

000001e4 <.do_copy_data_loop>:
     1e4:	05 90       	lpm	r0, Z+
     1e6:	0d 92       	st	X+, r0

000001e8 <.do_copy_data_start>:
     1e8:	a8 39       	cpi	r26, 0x98	; 152
     1ea:	b1 07       	cpc	r27, r17
     1ec:	d9 f7       	brne	.-10     	; 0x1e4 <.do_copy_data_loop>

000001ee <__do_clear_bss>:
     1ee:	13 e1       	ldi	r17, 0x13	; 19
     1f0:	a8 e9       	ldi	r26, 0x98	; 152
     1f2:	b2 e0       	ldi	r27, 0x02	; 2
     1f4:	01 c0       	rjmp	.+2      	; 0x1f8 <.do_clear_bss_start>

000001f6 <.do_clear_bss_loop>:
     1f6:	1d 92       	st	X+, r1

000001f8 <.do_clear_bss_start>:
     1f8:	ab 32       	cpi	r26, 0x2B	; 43
     1fa:	b1 07       	cpc	r27, r17
     1fc:	e1 f7       	brne	.-8      	; 0x1f6 <.do_clear_bss_loop>
     1fe:	0e 94 ca 08 	call	0x1194	; 0x1194 <main>
     202:	0c 94 7d 26 	jmp	0x4cfa	; 0x4cfa <exit>

00000206 <__bad_interrupt>:
     206:	0c 94 9c 1b 	jmp	0x3738	; 0x3738 <__vector_default>

0000020a <PWM_Init_timer1_LED>:

//OC1B  pin B6 (attached to green LED)
void PWM_Init_timer1_LED(u08 bitRes)
{
	// enable timer2 as 8,9,10bit PWM
	if(bitRes == 9)
     20a:	89 30       	cpi	r24, 0x09	; 9
     20c:	49 f4       	brne	.+18     	; 0x220 <PWM_Init_timer1_LED+0x16>
	{	// 9bit mode
		sbi(TCCR1A,PWM11);
     20e:	80 91 80 00 	lds	r24, 0x0080
     212:	82 60       	ori	r24, 0x02	; 2
     214:	80 93 80 00 	sts	0x0080, r24
		cbi(TCCR1A,PWM10);
     218:	80 91 80 00 	lds	r24, 0x0080
     21c:	8e 7f       	andi	r24, 0xFE	; 254
     21e:	0e c0       	rjmp	.+28     	; 0x23c <PWM_Init_timer1_LED+0x32>
	}
	else if( bitRes == 10 )
     220:	8a 30       	cpi	r24, 0x0A	; 10
     222:	21 f4       	brne	.+8      	; 0x22c <PWM_Init_timer1_LED+0x22>
	{	// 10bit mode
		sbi(TCCR1A,PWM11);
     224:	80 91 80 00 	lds	r24, 0x0080
     228:	82 60       	ori	r24, 0x02	; 2
     22a:	03 c0       	rjmp	.+6      	; 0x232 <PWM_Init_timer1_LED+0x28>
		sbi(TCCR1A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR1A,PWM11);
     22c:	80 91 80 00 	lds	r24, 0x0080
     230:	8d 7f       	andi	r24, 0xFD	; 253
     232:	80 93 80 00 	sts	0x0080, r24
		sbi(TCCR1A,PWM10);
     236:	80 91 80 00 	lds	r24, 0x0080
     23a:	81 60       	ori	r24, 0x01	; 1
     23c:	80 93 80 00 	sts	0x0080, r24
	}
	// clear output compare values
	OCR1B = 0;
     240:	10 92 8b 00 	sts	0x008B, r1
     244:	10 92 8a 00 	sts	0x008A, r1
}
     248:	08 95       	ret

0000024a <PWM_Init_timer2_H6>:
//pin H6, timer2
void PWM_Init_timer2_H6(u08 bitRes)
{
	// enable timer2 as 8,9,10bit PWM
	if(bitRes == 9)
     24a:	89 30       	cpi	r24, 0x09	; 9
     24c:	49 f4       	brne	.+18     	; 0x260 <PWM_Init_timer2_H6+0x16>
	{	// 9bit mode
		sbi(TCCR2A,PWM11);
     24e:	80 91 b0 00 	lds	r24, 0x00B0
     252:	82 60       	ori	r24, 0x02	; 2
     254:	80 93 b0 00 	sts	0x00B0, r24
		cbi(TCCR2A,PWM10);
     258:	80 91 b0 00 	lds	r24, 0x00B0
     25c:	8e 7f       	andi	r24, 0xFE	; 254
     25e:	0e c0       	rjmp	.+28     	; 0x27c <PWM_Init_timer2_H6+0x32>
	}
	else if( bitRes == 10 )
     260:	8a 30       	cpi	r24, 0x0A	; 10
     262:	21 f4       	brne	.+8      	; 0x26c <PWM_Init_timer2_H6+0x22>
	{	// 10bit mode
		sbi(TCCR2A,PWM11);
     264:	80 91 b0 00 	lds	r24, 0x00B0
     268:	82 60       	ori	r24, 0x02	; 2
     26a:	03 c0       	rjmp	.+6      	; 0x272 <PWM_Init_timer2_H6+0x28>
		sbi(TCCR2A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR2A,PWM11);
     26c:	80 91 b0 00 	lds	r24, 0x00B0
     270:	8d 7f       	andi	r24, 0xFD	; 253
     272:	80 93 b0 00 	sts	0x00B0, r24
		sbi(TCCR2A,PWM10);
     276:	80 91 b0 00 	lds	r24, 0x00B0
     27a:	81 60       	ori	r24, 0x01	; 1
     27c:	80 93 b0 00 	sts	0x00B0, r24
	}
	// clear output compare values
	OCR2B = 0;
     280:	10 92 b4 00 	sts	0x00B4, r1
}
     284:	08 95       	ret

00000286 <PWM_Init_timer3_E3>:
//pin E3
void PWM_Init_timer3_E3(u08 bitRes)
{
	// enable timer3 as 8,9,10bit PWM
	if(bitRes == 9)
     286:	89 30       	cpi	r24, 0x09	; 9
     288:	49 f4       	brne	.+18     	; 0x29c <PWM_Init_timer3_E3+0x16>
	{	// 9bit mode
		sbi(TCCR3A,PWM11);
     28a:	80 91 90 00 	lds	r24, 0x0090
     28e:	82 60       	ori	r24, 0x02	; 2
     290:	80 93 90 00 	sts	0x0090, r24
		cbi(TCCR3A,PWM10);
     294:	80 91 90 00 	lds	r24, 0x0090
     298:	8e 7f       	andi	r24, 0xFE	; 254
     29a:	0e c0       	rjmp	.+28     	; 0x2b8 <PWM_Init_timer3_E3+0x32>
	}
	else if( bitRes == 10 )
     29c:	8a 30       	cpi	r24, 0x0A	; 10
     29e:	21 f4       	brne	.+8      	; 0x2a8 <PWM_Init_timer3_E3+0x22>
	{	// 10bit mode
		sbi(TCCR3A,PWM11);
     2a0:	80 91 90 00 	lds	r24, 0x0090
     2a4:	82 60       	ori	r24, 0x02	; 2
     2a6:	03 c0       	rjmp	.+6      	; 0x2ae <PWM_Init_timer3_E3+0x28>
		sbi(TCCR3A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR3A,PWM11);
     2a8:	80 91 90 00 	lds	r24, 0x0090
     2ac:	8d 7f       	andi	r24, 0xFD	; 253
     2ae:	80 93 90 00 	sts	0x0090, r24
		sbi(TCCR3A,PWM10);
     2b2:	80 91 90 00 	lds	r24, 0x0090
     2b6:	81 60       	ori	r24, 0x01	; 1
     2b8:	80 93 90 00 	sts	0x0090, r24
	}
	// clear output compare values
	OCR3A = 0;
     2bc:	10 92 99 00 	sts	0x0099, r1
     2c0:	10 92 98 00 	sts	0x0098, r1
	//timer3PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     2c4:	08 95       	ret

000002c6 <PWM_Init_timer3_E4>:
//pin E4
void PWM_Init_timer3_E4(u08 bitRes)
{
	// enable timer3 as 8,9,10bit PWM
	if(bitRes == 9)
     2c6:	89 30       	cpi	r24, 0x09	; 9
     2c8:	49 f4       	brne	.+18     	; 0x2dc <PWM_Init_timer3_E4+0x16>
	{	// 9bit mode
		sbi(TCCR3B,PWM11);
     2ca:	80 91 91 00 	lds	r24, 0x0091
     2ce:	82 60       	ori	r24, 0x02	; 2
     2d0:	80 93 91 00 	sts	0x0091, r24
		cbi(TCCR3B,PWM10);
     2d4:	80 91 91 00 	lds	r24, 0x0091
     2d8:	8e 7f       	andi	r24, 0xFE	; 254
     2da:	0e c0       	rjmp	.+28     	; 0x2f8 <PWM_Init_timer3_E4+0x32>
	}
	else if( bitRes == 10 )
     2dc:	8a 30       	cpi	r24, 0x0A	; 10
     2de:	21 f4       	brne	.+8      	; 0x2e8 <PWM_Init_timer3_E4+0x22>
	{	// 10bit mode
		sbi(TCCR3B,PWM11);
     2e0:	80 91 91 00 	lds	r24, 0x0091
     2e4:	82 60       	ori	r24, 0x02	; 2
     2e6:	03 c0       	rjmp	.+6      	; 0x2ee <PWM_Init_timer3_E4+0x28>
		sbi(TCCR3B,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR3B,PWM11);
     2e8:	80 91 91 00 	lds	r24, 0x0091
     2ec:	8d 7f       	andi	r24, 0xFD	; 253
     2ee:	80 93 91 00 	sts	0x0091, r24
		sbi(TCCR3B,PWM10);
     2f2:	80 91 91 00 	lds	r24, 0x0091
     2f6:	81 60       	ori	r24, 0x01	; 1
     2f8:	80 93 91 00 	sts	0x0091, r24
	}
	// clear output compare values
	OCR3B = 0;
     2fc:	10 92 9b 00 	sts	0x009B, r1
     300:	10 92 9a 00 	sts	0x009A, r1
	//timer3PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     304:	08 95       	ret

00000306 <PWM_Init_timer3_E5>:
//pin E5
void PWM_Init_timer3_E5(u08 bitRes)
{
	// enable timer3 as 8,9,10bit PWM
	if(bitRes == 9)
     306:	89 30       	cpi	r24, 0x09	; 9
     308:	49 f4       	brne	.+18     	; 0x31c <PWM_Init_timer3_E5+0x16>
	{	// 9bit mode
		sbi(TCCR3C,PWM11);
     30a:	80 91 92 00 	lds	r24, 0x0092
     30e:	82 60       	ori	r24, 0x02	; 2
     310:	80 93 92 00 	sts	0x0092, r24
		cbi(TCCR3C,PWM10);
     314:	80 91 92 00 	lds	r24, 0x0092
     318:	8e 7f       	andi	r24, 0xFE	; 254
     31a:	0e c0       	rjmp	.+28     	; 0x338 <PWM_Init_timer3_E5+0x32>
	}
	else if( bitRes == 10 )
     31c:	8a 30       	cpi	r24, 0x0A	; 10
     31e:	21 f4       	brne	.+8      	; 0x328 <PWM_Init_timer3_E5+0x22>
	{	// 10bit mode
		sbi(TCCR3C,PWM11);
     320:	80 91 92 00 	lds	r24, 0x0092
     324:	82 60       	ori	r24, 0x02	; 2
     326:	03 c0       	rjmp	.+6      	; 0x32e <PWM_Init_timer3_E5+0x28>
		sbi(TCCR3C,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR3C,PWM11);
     328:	80 91 92 00 	lds	r24, 0x0092
     32c:	8d 7f       	andi	r24, 0xFD	; 253
     32e:	80 93 92 00 	sts	0x0092, r24
		sbi(TCCR3C,PWM10);
     332:	80 91 92 00 	lds	r24, 0x0092
     336:	81 60       	ori	r24, 0x01	; 1
     338:	80 93 92 00 	sts	0x0092, r24
	}
	// clear output compare values
	OCR3C = 0;
     33c:	10 92 9d 00 	sts	0x009D, r1
     340:	10 92 9c 00 	sts	0x009C, r1
	//timer3PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     344:	08 95       	ret

00000346 <PWM_Init_timer4_H3>:
//pin H3, timer4
void PWM_Init_timer4_H3(u08 bitRes)
{
	// enable timer4 as 8,9,10bit PWM
	if(bitRes == 9)
     346:	89 30       	cpi	r24, 0x09	; 9
     348:	49 f4       	brne	.+18     	; 0x35c <PWM_Init_timer4_H3+0x16>
	{	// 9bit mode
		sbi(TCCR4A,PWM11);
     34a:	80 91 a0 00 	lds	r24, 0x00A0
     34e:	82 60       	ori	r24, 0x02	; 2
     350:	80 93 a0 00 	sts	0x00A0, r24
		cbi(TCCR4A,PWM10);
     354:	80 91 a0 00 	lds	r24, 0x00A0
     358:	8e 7f       	andi	r24, 0xFE	; 254
     35a:	0e c0       	rjmp	.+28     	; 0x378 <PWM_Init_timer4_H3+0x32>
	}
	else if( bitRes == 10 )
     35c:	8a 30       	cpi	r24, 0x0A	; 10
     35e:	21 f4       	brne	.+8      	; 0x368 <PWM_Init_timer4_H3+0x22>
	{	// 10bit mode
		sbi(TCCR4A,PWM11);
     360:	80 91 a0 00 	lds	r24, 0x00A0
     364:	82 60       	ori	r24, 0x02	; 2
     366:	03 c0       	rjmp	.+6      	; 0x36e <PWM_Init_timer4_H3+0x28>
		sbi(TCCR4A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR4A,PWM11);
     368:	80 91 a0 00 	lds	r24, 0x00A0
     36c:	8d 7f       	andi	r24, 0xFD	; 253
     36e:	80 93 a0 00 	sts	0x00A0, r24
		sbi(TCCR4A,PWM10);
     372:	80 91 a0 00 	lds	r24, 0x00A0
     376:	81 60       	ori	r24, 0x01	; 1
     378:	80 93 a0 00 	sts	0x00A0, r24
	}
	// clear output compare values
	OCR4A = 0;
     37c:	10 92 a9 00 	sts	0x00A9, r1
     380:	10 92 a8 00 	sts	0x00A8, r1
	//timer4PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     384:	08 95       	ret

00000386 <PWM_Init_timer4_H4>:
//pin H4, timer4
void PWM_Init_timer4_H4(u08 bitRes)
{
	// enable timer4 as 8,9,10bit PWM
	if(bitRes == 9)
     386:	89 30       	cpi	r24, 0x09	; 9
     388:	49 f4       	brne	.+18     	; 0x39c <PWM_Init_timer4_H4+0x16>
	{	// 9bit mode
		sbi(TCCR4B,PWM11);
     38a:	80 91 a1 00 	lds	r24, 0x00A1
     38e:	82 60       	ori	r24, 0x02	; 2
     390:	80 93 a1 00 	sts	0x00A1, r24
		cbi(TCCR4B,PWM10);
     394:	80 91 a1 00 	lds	r24, 0x00A1
     398:	8e 7f       	andi	r24, 0xFE	; 254
     39a:	0e c0       	rjmp	.+28     	; 0x3b8 <PWM_Init_timer4_H4+0x32>
	}
	else if( bitRes == 10 )
     39c:	8a 30       	cpi	r24, 0x0A	; 10
     39e:	21 f4       	brne	.+8      	; 0x3a8 <PWM_Init_timer4_H4+0x22>
	{	// 10bit mode
		sbi(TCCR4B,PWM11);
     3a0:	80 91 a1 00 	lds	r24, 0x00A1
     3a4:	82 60       	ori	r24, 0x02	; 2
     3a6:	03 c0       	rjmp	.+6      	; 0x3ae <PWM_Init_timer4_H4+0x28>
		sbi(TCCR4B,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR4B,PWM11);
     3a8:	80 91 a1 00 	lds	r24, 0x00A1
     3ac:	8d 7f       	andi	r24, 0xFD	; 253
     3ae:	80 93 a1 00 	sts	0x00A1, r24
		sbi(TCCR4B,PWM10);
     3b2:	80 91 a1 00 	lds	r24, 0x00A1
     3b6:	81 60       	ori	r24, 0x01	; 1
     3b8:	80 93 a1 00 	sts	0x00A1, r24
	}
	// clear output compare values
	OCR4B = 0;
     3bc:	10 92 ab 00 	sts	0x00AB, r1
     3c0:	10 92 aa 00 	sts	0x00AA, r1
	//timer4PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     3c4:	08 95       	ret

000003c6 <PWM_Init_timer4_H5>:
//pin H5, timer4
void PWM_Init_timer4_H5(u08 bitRes)
{
	// enable timer4 as 8,9,10bit PWM
	if(bitRes == 9)
     3c6:	89 30       	cpi	r24, 0x09	; 9
     3c8:	49 f4       	brne	.+18     	; 0x3dc <PWM_Init_timer4_H5+0x16>
	{	// 9bit mode
		sbi(TCCR4A,PWM11);
     3ca:	80 91 a0 00 	lds	r24, 0x00A0
     3ce:	82 60       	ori	r24, 0x02	; 2
     3d0:	80 93 a0 00 	sts	0x00A0, r24
		cbi(TCCR4A,PWM10);
     3d4:	80 91 a0 00 	lds	r24, 0x00A0
     3d8:	8e 7f       	andi	r24, 0xFE	; 254
     3da:	0e c0       	rjmp	.+28     	; 0x3f8 <PWM_Init_timer4_H5+0x32>
	}
	else if( bitRes == 10 )
     3dc:	8a 30       	cpi	r24, 0x0A	; 10
     3de:	21 f4       	brne	.+8      	; 0x3e8 <PWM_Init_timer4_H5+0x22>
	{	// 10bit mode
		sbi(TCCR4A,PWM11);
     3e0:	80 91 a0 00 	lds	r24, 0x00A0
     3e4:	82 60       	ori	r24, 0x02	; 2
     3e6:	03 c0       	rjmp	.+6      	; 0x3ee <PWM_Init_timer4_H5+0x28>
		sbi(TCCR4A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR4A,PWM11);
     3e8:	80 91 a0 00 	lds	r24, 0x00A0
     3ec:	8d 7f       	andi	r24, 0xFD	; 253
     3ee:	80 93 a0 00 	sts	0x00A0, r24
		sbi(TCCR4A,PWM10);
     3f2:	80 91 a0 00 	lds	r24, 0x00A0
     3f6:	81 60       	ori	r24, 0x01	; 1
     3f8:	80 93 a0 00 	sts	0x00A0, r24
	}
	// clear output compare values
	OCR4C = 0;
     3fc:	10 92 ad 00 	sts	0x00AD, r1
     400:	10 92 ac 00 	sts	0x00AC, r1
	//timer4PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     404:	08 95       	ret

00000406 <timer1PWMInitICR>:
// include support for arbitrary top-count PWM
// on new AVR processors that support it
void timer1PWMInitICR(u16 topcount)
{
	// set PWM mode with ICR top-count
	cbi(TCCR1A,WGM10);
     406:	e0 e8       	ldi	r30, 0x80	; 128
     408:	f0 e0       	ldi	r31, 0x00	; 0
     40a:	20 81       	ld	r18, Z
     40c:	2e 7f       	andi	r18, 0xFE	; 254
     40e:	20 83       	st	Z, r18
	sbi(TCCR1A,WGM11);
     410:	20 81       	ld	r18, Z
     412:	22 60       	ori	r18, 0x02	; 2
     414:	20 83       	st	Z, r18
	sbi(TCCR1B,WGM12);
     416:	e1 e8       	ldi	r30, 0x81	; 129
     418:	f0 e0       	ldi	r31, 0x00	; 0
     41a:	20 81       	ld	r18, Z
     41c:	28 60       	ori	r18, 0x08	; 8
     41e:	20 83       	st	Z, r18
	sbi(TCCR1B,WGM13);
     420:	20 81       	ld	r18, Z
     422:	20 61       	ori	r18, 0x10	; 16
     424:	20 83       	st	Z, r18
	
	// set top count value
	ICR1 = topcount;
     426:	90 93 87 00 	sts	0x0087, r25
     42a:	80 93 86 00 	sts	0x0086, r24
	
	// clear output compare values
	OCR1A = 0;
     42e:	10 92 89 00 	sts	0x0089, r1
     432:	10 92 88 00 	sts	0x0088, r1
	OCR1B = 0;
     436:	10 92 8b 00 	sts	0x008B, r1
     43a:	10 92 8a 00 	sts	0x008A, r1
	OCR1C = 0;
     43e:	10 92 8d 00 	sts	0x008D, r1
     442:	10 92 8c 00 	sts	0x008C, r1
}
     446:	08 95       	ret

00000448 <timer3PWMInitICR>:
void timer3PWMInitICR(u16 topcount)
{
	// set PWM mode with ICR top-count
	cbi(TCCR3A,WGM10);
     448:	e0 e9       	ldi	r30, 0x90	; 144
     44a:	f0 e0       	ldi	r31, 0x00	; 0
     44c:	20 81       	ld	r18, Z
     44e:	2e 7f       	andi	r18, 0xFE	; 254
     450:	20 83       	st	Z, r18
	sbi(TCCR3A,WGM11);
     452:	20 81       	ld	r18, Z
     454:	22 60       	ori	r18, 0x02	; 2
     456:	20 83       	st	Z, r18
	sbi(TCCR3B,WGM12);
     458:	e1 e9       	ldi	r30, 0x91	; 145
     45a:	f0 e0       	ldi	r31, 0x00	; 0
     45c:	20 81       	ld	r18, Z
     45e:	28 60       	ori	r18, 0x08	; 8
     460:	20 83       	st	Z, r18
	sbi(TCCR3B,WGM13);
     462:	20 81       	ld	r18, Z
     464:	20 61       	ori	r18, 0x10	; 16
     466:	20 83       	st	Z, r18
	
	// set top count value
	ICR3 = topcount;
     468:	90 93 97 00 	sts	0x0097, r25
     46c:	80 93 96 00 	sts	0x0096, r24
	
	// clear output compare values
	OCR3A = 0;
     470:	10 92 99 00 	sts	0x0099, r1
     474:	10 92 98 00 	sts	0x0098, r1
	OCR3B = 0;
     478:	10 92 9b 00 	sts	0x009B, r1
     47c:	10 92 9a 00 	sts	0x009A, r1
	OCR3C = 0;
     480:	10 92 9d 00 	sts	0x009D, r1
     484:	10 92 9c 00 	sts	0x009C, r1
}
     488:	08 95       	ret

0000048a <timer4PWMInitICR>:
void timer4PWMInitICR(u16 topcount)
{
	// set PWM mode with ICR top-count
	cbi(TCCR4A,WGM10);
     48a:	e0 ea       	ldi	r30, 0xA0	; 160
     48c:	f0 e0       	ldi	r31, 0x00	; 0
     48e:	20 81       	ld	r18, Z
     490:	2e 7f       	andi	r18, 0xFE	; 254
     492:	20 83       	st	Z, r18
	sbi(TCCR4A,WGM11);
     494:	20 81       	ld	r18, Z
     496:	22 60       	ori	r18, 0x02	; 2
     498:	20 83       	st	Z, r18
	sbi(TCCR4B,WGM12);
     49a:	e1 ea       	ldi	r30, 0xA1	; 161
     49c:	f0 e0       	ldi	r31, 0x00	; 0
     49e:	20 81       	ld	r18, Z
     4a0:	28 60       	ori	r18, 0x08	; 8
     4a2:	20 83       	st	Z, r18
	sbi(TCCR4B,WGM13);
     4a4:	20 81       	ld	r18, Z
     4a6:	20 61       	ori	r18, 0x10	; 16
     4a8:	20 83       	st	Z, r18
	
	// set top count value
	ICR4 = topcount;
     4aa:	90 93 a7 00 	sts	0x00A7, r25
     4ae:	80 93 a6 00 	sts	0x00A6, r24
	
	// clear output compare values
	OCR4A = 0;
     4b2:	10 92 a9 00 	sts	0x00A9, r1
     4b6:	10 92 a8 00 	sts	0x00A8, r1
	OCR4B = 0;
     4ba:	10 92 ab 00 	sts	0x00AB, r1
     4be:	10 92 aa 00 	sts	0x00AA, r1
	OCR4C = 0;
     4c2:	10 92 ad 00 	sts	0x00AD, r1
     4c6:	10 92 ac 00 	sts	0x00AC, r1
}
     4ca:	08 95       	ret

000004cc <PWM_timer1_On_LED>:
#endif

//on commands
void PWM_timer1_On_LED(void)
{
	sbi(TCCR1A,COM1B1);
     4cc:	e0 e8       	ldi	r30, 0x80	; 128
     4ce:	f0 e0       	ldi	r31, 0x00	; 0
     4d0:	80 81       	ld	r24, Z
     4d2:	80 62       	ori	r24, 0x20	; 32
     4d4:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B0);
     4d6:	80 81       	ld	r24, Z
     4d8:	8f 7e       	andi	r24, 0xEF	; 239
     4da:	80 83       	st	Z, r24
}
     4dc:	08 95       	ret

000004de <PWM_timer2_On_H6>:
void PWM_timer2_On_H6(void)
{
	sbi(TCCR2A,COM2B1);
     4de:	e0 eb       	ldi	r30, 0xB0	; 176
     4e0:	f0 e0       	ldi	r31, 0x00	; 0
     4e2:	80 81       	ld	r24, Z
     4e4:	80 62       	ori	r24, 0x20	; 32
     4e6:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B0);
     4e8:	80 81       	ld	r24, Z
     4ea:	8f 7e       	andi	r24, 0xEF	; 239
     4ec:	80 83       	st	Z, r24
}
     4ee:	08 95       	ret

000004f0 <PWM_timer3_On_E3>:
void PWM_timer3_On_E3(void)
{
	sbi(TCCR3A,COM3A1);
     4f0:	e0 e9       	ldi	r30, 0x90	; 144
     4f2:	f0 e0       	ldi	r31, 0x00	; 0
     4f4:	80 81       	ld	r24, Z
     4f6:	80 68       	ori	r24, 0x80	; 128
     4f8:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3A0);
     4fa:	80 81       	ld	r24, Z
     4fc:	8f 7b       	andi	r24, 0xBF	; 191
     4fe:	80 83       	st	Z, r24
}
     500:	08 95       	ret

00000502 <PWM_timer3_On_E4>:
void PWM_timer3_On_E4(void)
{
	sbi(TCCR3A,COM3B1);
     502:	e0 e9       	ldi	r30, 0x90	; 144
     504:	f0 e0       	ldi	r31, 0x00	; 0
     506:	80 81       	ld	r24, Z
     508:	80 62       	ori	r24, 0x20	; 32
     50a:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3B0);
     50c:	80 81       	ld	r24, Z
     50e:	8f 7e       	andi	r24, 0xEF	; 239
     510:	80 83       	st	Z, r24
}
     512:	08 95       	ret

00000514 <PWM_timer3_On_E5>:
void PWM_timer3_On_E5(void)
{
	sbi(TCCR3A,COM3C1);
     514:	e0 e9       	ldi	r30, 0x90	; 144
     516:	f0 e0       	ldi	r31, 0x00	; 0
     518:	80 81       	ld	r24, Z
     51a:	88 60       	ori	r24, 0x08	; 8
     51c:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C0);
     51e:	80 81       	ld	r24, Z
     520:	8b 7f       	andi	r24, 0xFB	; 251
     522:	80 83       	st	Z, r24
}
     524:	08 95       	ret

00000526 <PWM_timer4_On_H3>:
void PWM_timer4_On_H3(void)
{
	sbi(TCCR4A,COM4A1);
     526:	e0 ea       	ldi	r30, 0xA0	; 160
     528:	f0 e0       	ldi	r31, 0x00	; 0
     52a:	80 81       	ld	r24, Z
     52c:	80 68       	ori	r24, 0x80	; 128
     52e:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4A0);
     530:	80 81       	ld	r24, Z
     532:	8f 7b       	andi	r24, 0xBF	; 191
     534:	80 83       	st	Z, r24
}
     536:	08 95       	ret

00000538 <PWM_timer4_On_H4>:
void PWM_timer4_On_H4(void)
{
	sbi(TCCR4A,COM4B1);
     538:	e0 ea       	ldi	r30, 0xA0	; 160
     53a:	f0 e0       	ldi	r31, 0x00	; 0
     53c:	80 81       	ld	r24, Z
     53e:	80 62       	ori	r24, 0x20	; 32
     540:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4B0);
     542:	80 81       	ld	r24, Z
     544:	8f 7e       	andi	r24, 0xEF	; 239
     546:	80 83       	st	Z, r24
}
     548:	08 95       	ret

0000054a <PWM_timer4_On_H5>:
void PWM_timer4_On_H5(void)
{
	sbi(TCCR4A,COM4C1);
     54a:	e0 ea       	ldi	r30, 0xA0	; 160
     54c:	f0 e0       	ldi	r31, 0x00	; 0
     54e:	80 81       	ld	r24, Z
     550:	88 60       	ori	r24, 0x08	; 8
     552:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4C0);
     554:	80 81       	ld	r24, Z
     556:	8b 7f       	andi	r24, 0xFB	; 251
     558:	80 83       	st	Z, r24
}
     55a:	08 95       	ret

0000055c <PWM_timer1_Off_LED>:

//off commands
void PWM_timer1_Off_LED(void)
{
	cbi(TCCR1A,COM1B1);
     55c:	e0 e8       	ldi	r30, 0x80	; 128
     55e:	f0 e0       	ldi	r31, 0x00	; 0
     560:	80 81       	ld	r24, Z
     562:	8f 7d       	andi	r24, 0xDF	; 223
     564:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B0);
     566:	80 81       	ld	r24, Z
     568:	8f 7e       	andi	r24, 0xEF	; 239
     56a:	80 83       	st	Z, r24
}
     56c:	08 95       	ret

0000056e <PWM_timer2_Off_H6>:
void PWM_timer2_Off_H6(void)
{
	cbi(TCCR2A,COM2B1);
     56e:	e0 eb       	ldi	r30, 0xB0	; 176
     570:	f0 e0       	ldi	r31, 0x00	; 0
     572:	80 81       	ld	r24, Z
     574:	8f 7d       	andi	r24, 0xDF	; 223
     576:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B0);
     578:	80 81       	ld	r24, Z
     57a:	8f 7e       	andi	r24, 0xEF	; 239
     57c:	80 83       	st	Z, r24
}
     57e:	08 95       	ret

00000580 <PWM_timer3_Off_E3>:
void PWM_timer3_Off_E3(void)
{
	cbi(TCCR3A,COM3A1);
     580:	e0 e9       	ldi	r30, 0x90	; 144
     582:	f0 e0       	ldi	r31, 0x00	; 0
     584:	80 81       	ld	r24, Z
     586:	8f 77       	andi	r24, 0x7F	; 127
     588:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3A0);
     58a:	80 81       	ld	r24, Z
     58c:	8f 7b       	andi	r24, 0xBF	; 191
     58e:	80 83       	st	Z, r24
}
     590:	08 95       	ret

00000592 <PWM_timer3_Off_E4>:
void PWM_timer3_Off_E4(void)
{
	cbi(TCCR3A,COM3B1);
     592:	e0 e9       	ldi	r30, 0x90	; 144
     594:	f0 e0       	ldi	r31, 0x00	; 0
     596:	80 81       	ld	r24, Z
     598:	8f 7d       	andi	r24, 0xDF	; 223
     59a:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3B0);
     59c:	80 81       	ld	r24, Z
     59e:	8f 7e       	andi	r24, 0xEF	; 239
     5a0:	80 83       	st	Z, r24
}
     5a2:	08 95       	ret

000005a4 <PWM_timer3_Off_E5>:
void PWM_timer3_Off_E5(void)
{
	cbi(TCCR3A,COM3C1);
     5a4:	e0 e9       	ldi	r30, 0x90	; 144
     5a6:	f0 e0       	ldi	r31, 0x00	; 0
     5a8:	80 81       	ld	r24, Z
     5aa:	87 7f       	andi	r24, 0xF7	; 247
     5ac:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C0);
     5ae:	80 81       	ld	r24, Z
     5b0:	8b 7f       	andi	r24, 0xFB	; 251
     5b2:	80 83       	st	Z, r24
}
     5b4:	08 95       	ret

000005b6 <PWM_timer4_Off_H3>:
void PWM_timer4_Off_H3(void)
{
	cbi(TCCR4A,COM4A1);
     5b6:	e0 ea       	ldi	r30, 0xA0	; 160
     5b8:	f0 e0       	ldi	r31, 0x00	; 0
     5ba:	80 81       	ld	r24, Z
     5bc:	8f 77       	andi	r24, 0x7F	; 127
     5be:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4A0);
     5c0:	80 81       	ld	r24, Z
     5c2:	8f 7b       	andi	r24, 0xBF	; 191
     5c4:	80 83       	st	Z, r24
}
     5c6:	08 95       	ret

000005c8 <PWM_timer4_Off_H4>:
void PWM_timer4_Off_H4(void)
{
	cbi(TCCR4A,COM4B1);
     5c8:	e0 ea       	ldi	r30, 0xA0	; 160
     5ca:	f0 e0       	ldi	r31, 0x00	; 0
     5cc:	80 81       	ld	r24, Z
     5ce:	8f 7d       	andi	r24, 0xDF	; 223
     5d0:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4B0);
     5d2:	80 81       	ld	r24, Z
     5d4:	8f 7e       	andi	r24, 0xEF	; 239
     5d6:	80 83       	st	Z, r24
}
     5d8:	08 95       	ret

000005da <PWM_timer4_Off_H5>:
void PWM_timer4_Off_H5(void)
{
	cbi(TCCR4A,COM4C1);
     5da:	e0 ea       	ldi	r30, 0xA0	; 160
     5dc:	f0 e0       	ldi	r31, 0x00	; 0
     5de:	80 81       	ld	r24, Z
     5e0:	87 7f       	andi	r24, 0xF7	; 247
     5e2:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4C0);
     5e4:	80 81       	ld	r24, Z
     5e6:	8b 7f       	andi	r24, 0xFB	; 251
     5e8:	80 83       	st	Z, r24
}
     5ea:	08 95       	ret

000005ec <PWM_timer1_Off_All>:


void PWM_timer1_Off_All(void)
{
	cbi(TCCR1A,PWM11);
     5ec:	e0 e8       	ldi	r30, 0x80	; 128
     5ee:	f0 e0       	ldi	r31, 0x00	; 0
     5f0:	80 81       	ld	r24, Z
     5f2:	8d 7f       	andi	r24, 0xFD	; 253
     5f4:	80 83       	st	Z, r24
	cbi(TCCR1A,PWM10);
     5f6:	80 81       	ld	r24, Z
     5f8:	8e 7f       	andi	r24, 0xFE	; 254
     5fa:	80 83       	st	Z, r24
}

//off commands
void PWM_timer1_Off_LED(void)
{
	cbi(TCCR1A,COM1B1);
     5fc:	80 81       	ld	r24, Z
     5fe:	8f 7d       	andi	r24, 0xDF	; 223
     600:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B0);
     602:	80 81       	ld	r24, Z
     604:	8f 7e       	andi	r24, 0xEF	; 239
     606:	80 83       	st	Z, r24
	cbi(TCCR1A,PWM11);
	cbi(TCCR1A,PWM10);
	//timer2PWMAOff();
	PWM_timer1_Off_LED();
	//timer2PWMCOff();
}
     608:	08 95       	ret

0000060a <PWM_timer2_Off_All>:
void PWM_timer2_Off_All(void)
{
	cbi(TCCR2A,PWM11);
     60a:	e0 eb       	ldi	r30, 0xB0	; 176
     60c:	f0 e0       	ldi	r31, 0x00	; 0
     60e:	80 81       	ld	r24, Z
     610:	8d 7f       	andi	r24, 0xFD	; 253
     612:	80 83       	st	Z, r24
	cbi(TCCR2A,PWM10);
     614:	80 81       	ld	r24, Z
     616:	8e 7f       	andi	r24, 0xFE	; 254
     618:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B1);
	cbi(TCCR1A,COM1B0);
}
void PWM_timer2_Off_H6(void)
{
	cbi(TCCR2A,COM2B1);
     61a:	80 81       	ld	r24, Z
     61c:	8f 7d       	andi	r24, 0xDF	; 223
     61e:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B0);
     620:	80 81       	ld	r24, Z
     622:	8f 7e       	andi	r24, 0xEF	; 239
     624:	80 83       	st	Z, r24
	cbi(TCCR2A,PWM11);
	cbi(TCCR2A,PWM10);
	//timer2PWMAOff();
	PWM_timer2_Off_H6();
	//timer2PWMCOff();
}
     626:	08 95       	ret

00000628 <PWM_timer3_Off_All>:
void PWM_timer3_Off_All(void)
{
	cbi(TCCR3A,PWM11);
     628:	e0 e9       	ldi	r30, 0x90	; 144
     62a:	f0 e0       	ldi	r31, 0x00	; 0
     62c:	80 81       	ld	r24, Z
     62e:	8d 7f       	andi	r24, 0xFD	; 253
     630:	80 83       	st	Z, r24
	cbi(TCCR3A,PWM10);
     632:	80 81       	ld	r24, Z
     634:	8e 7f       	andi	r24, 0xFE	; 254
     636:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B1);
	cbi(TCCR2A,COM2B0);
}
void PWM_timer3_Off_E3(void)
{
	cbi(TCCR3A,COM3A1);
     638:	80 81       	ld	r24, Z
     63a:	8f 77       	andi	r24, 0x7F	; 127
     63c:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3A0);
     63e:	80 81       	ld	r24, Z
     640:	8f 7b       	andi	r24, 0xBF	; 191
     642:	80 83       	st	Z, r24
}
void PWM_timer3_Off_E4(void)
{
	cbi(TCCR3A,COM3B1);
     644:	80 81       	ld	r24, Z
     646:	8f 7d       	andi	r24, 0xDF	; 223
     648:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3B0);
     64a:	80 81       	ld	r24, Z
     64c:	8f 7e       	andi	r24, 0xEF	; 239
     64e:	80 83       	st	Z, r24
}
void PWM_timer3_Off_E5(void)
{
	cbi(TCCR3A,COM3C1);
     650:	80 81       	ld	r24, Z
     652:	87 7f       	andi	r24, 0xF7	; 247
     654:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C0);
     656:	80 81       	ld	r24, Z
     658:	8b 7f       	andi	r24, 0xFB	; 251
     65a:	80 83       	st	Z, r24
	//timer2PWMAOff();
	PWM_timer3_Off_E3();
	PWM_timer3_Off_E4();
	PWM_timer3_Off_E5();
	//timer2PWMCOff();
}
     65c:	08 95       	ret

0000065e <PWM_timer4_Off_All>:
void PWM_timer4_Off_All(void)
{
	cbi(TCCR4A,PWM11);
     65e:	e0 ea       	ldi	r30, 0xA0	; 160
     660:	f0 e0       	ldi	r31, 0x00	; 0
     662:	80 81       	ld	r24, Z
     664:	8d 7f       	andi	r24, 0xFD	; 253
     666:	80 83       	st	Z, r24
	cbi(TCCR4A,PWM10);
     668:	80 81       	ld	r24, Z
     66a:	8e 7f       	andi	r24, 0xFE	; 254
     66c:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C1);
	cbi(TCCR3A,COM3C0);
}
void PWM_timer4_Off_H3(void)
{
	cbi(TCCR4A,COM4A1);
     66e:	80 81       	ld	r24, Z
     670:	8f 77       	andi	r24, 0x7F	; 127
     672:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4A0);
     674:	80 81       	ld	r24, Z
     676:	8f 7b       	andi	r24, 0xBF	; 191
     678:	80 83       	st	Z, r24
}
void PWM_timer4_Off_H4(void)
{
	cbi(TCCR4A,COM4B1);
     67a:	80 81       	ld	r24, Z
     67c:	8f 7d       	andi	r24, 0xDF	; 223
     67e:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4B0);
     680:	80 81       	ld	r24, Z
     682:	8f 7e       	andi	r24, 0xEF	; 239
     684:	80 83       	st	Z, r24
}
void PWM_timer4_Off_H5(void)
{
	cbi(TCCR4A,COM4C1);
     686:	80 81       	ld	r24, Z
     688:	87 7f       	andi	r24, 0xF7	; 247
     68a:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4C0);
     68c:	80 81       	ld	r24, Z
     68e:	8b 7f       	andi	r24, 0xFB	; 251
     690:	80 83       	st	Z, r24
	//timer2PWMAOff();
	PWM_timer4_Off_H3();
	PWM_timer4_Off_H4();
	PWM_timer4_Off_H5();
	//timer2PWMCOff();
}
     692:	08 95       	ret

00000694 <PWM_timer1_Set_LED>:
// this PWM output is generated on OC2B pin
// NOTE:	pwmDuty should be in the range 0-255 for 8bit PWM
//			pwmDuty should be in the range 0-511 for 9bit PWM
//			pwmDuty should be in the range 0-1023 for 10bit PWM
void PWM_timer1_Set_LED(u16 pwmDuty)
	{OCR1B = pwmDuty;}
     694:	90 93 8b 00 	sts	0x008B, r25
     698:	80 93 8a 00 	sts	0x008A, r24
     69c:	08 95       	ret

0000069e <PWM_timer2_Set_H6>:
void PWM_timer2_Set_H6(u16 pwmDuty)
	{OCR2B = pwmDuty;}
     69e:	80 93 b4 00 	sts	0x00B4, r24
     6a2:	08 95       	ret

000006a4 <PWM_timer3_Set_E3>:
void PWM_timer3_Set_E3(u16 pwmDuty)
	{OCR3A = pwmDuty;}
     6a4:	90 93 99 00 	sts	0x0099, r25
     6a8:	80 93 98 00 	sts	0x0098, r24
     6ac:	08 95       	ret

000006ae <PWM_timer3_Set_E4>:
void PWM_timer3_Set_E4(u16 pwmDuty)
	{OCR3B = pwmDuty;}
     6ae:	90 93 9b 00 	sts	0x009B, r25
     6b2:	80 93 9a 00 	sts	0x009A, r24
     6b6:	08 95       	ret

000006b8 <PWM_timer3_Set_E5>:
void PWM_timer3_Set_E5(u16 pwmDuty)
	{OCR3C = pwmDuty;}
     6b8:	90 93 9d 00 	sts	0x009D, r25
     6bc:	80 93 9c 00 	sts	0x009C, r24
     6c0:	08 95       	ret

000006c2 <PWM_timer4_Set_H3>:
void PWM_timer4_Set_H3(u16 pwmDuty)
	{OCR4A = pwmDuty;}
     6c2:	90 93 a9 00 	sts	0x00A9, r25
     6c6:	80 93 a8 00 	sts	0x00A8, r24
     6ca:	08 95       	ret

000006cc <PWM_timer4_Set_H4>:
void PWM_timer4_Set_H4(u16 pwmDuty)
	{OCR4B = pwmDuty;}
     6cc:	90 93 ab 00 	sts	0x00AB, r25
     6d0:	80 93 aa 00 	sts	0x00AA, r24
     6d4:	08 95       	ret

000006d6 <PWM_timer4_Set_H5>:
void PWM_timer4_Set_H5(u16 pwmDuty)
	{OCR4C = pwmDuty;}
     6d6:	90 93 ad 00 	sts	0x00AD, r25
     6da:	80 93 ac 00 	sts	0x00AC, r24
     6de:	08 95       	ret

000006e0 <configure_ports>:
	//cbi(DDRG, PG5);  //set G5 as input pin

	//ANALOG PORTS
	//useful for sensors, SharpIR, photoresistors, etc.
	//analog ports can be configured as digital ports if desired
	DDRF = 0b00000000;  //configure all F ports for input				0x00
     6e0:	10 ba       	out	0x10, r1	; 16
	PORTF = 0b00000000; //make sure pull-up resistors are turned off	0x00
     6e2:	11 ba       	out	0x11, r1	; 17
	DDRK = 0b00000000;  //configure all K ports for input				0x00
     6e4:	10 92 07 01 	sts	0x0107, r1
	PORTK = 0b00000000; //make sure pull-up resistors are turned off	0x00
     6e8:	10 92 08 01 	sts	0x0108, r1

	//DIGITAL PORTS
	//useful for servos, PWM, LED's, UART, interrupts, timers
	DDRA = 0b11111111;  //configure ports for output
     6ec:	9f ef       	ldi	r25, 0xFF	; 255
     6ee:	91 b9       	out	0x01, r25	; 1
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	//PORTB reserved for programmer (use programmer pins if you know what you are doing)
	DDRB = _BV (PB6);	//PB6 is LED, hold low to turn it on
     6f0:	80 e4       	ldi	r24, 0x40	; 64
     6f2:	84 b9       	out	0x04, r24	; 4
	DDRC = 0b11111111;  //configure ports for output
     6f4:	97 b9       	out	0x07, r25	; 7
	//       ||||\______3: 
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 	
	sbi(PORTD, PD0); // SCL pull-up
     6f6:	58 9a       	sbi	0x0b, 0	; 11
	sbi(PORTD, PD1); // SDA pull-up
     6f8:	59 9a       	sbi	0x0b, 1	; 11
	DDRD = 0b11110011;  //configure ports for output
     6fa:	83 ef       	ldi	r24, 0xF3	; 243
     6fc:	8a b9       	out	0x0a, r24	; 10
	//       ||||\______3: serial TXD1, output -> 1
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: timer0
	DDRE = 0b11111110;  //configure ports for output
     6fe:	8e ef       	ldi	r24, 0xFE	; 254
     700:	8d b9       	out	0x0d, r24	; 13
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	//cbi(PORTG, PG5);  // disable pull-up resistor for Axon v1e and earlier
	sbi(PORTG, PG5);  // enable pull-up resistor for v1f and later
     702:	a5 9a       	sbi	0x14, 5	; 20
	cbi(DDRG, PG5);	//PG5 is for the button, make a digital input
     704:	9d 98       	cbi	0x13, 5	; 19
	//note that button actions are inverted between both versions!!!
	DDRH = 0b11111110;  //configure ports for output
     706:	80 93 01 01 	sts	0x0101, r24
	//       ||||\______3: 
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	DDRJ = 0b11111110;  //configure ports for output
     70a:	80 93 04 01 	sts	0x0104, r24
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	//PORTL has no headers
	};
     70e:	08 95       	ret

00000710 <delay_cycles>:
void delay_cycles(unsigned long int cycles)
	{
	cycles=cycles;//doubled frequency but too lazy to change times
	while(cycles > 0)
		cycles--;
	}
     710:	08 95       	ret

00000712 <LED_off>:


//***************STATUS LED**************
//tank test
void LED_off(void)
	{PORT_ON(PORTB,6);}
     712:	2e 9a       	sbi	0x05, 6	; 5
     714:	08 95       	ret

00000716 <LED_on>:
void LED_on(void)
	{PORT_OFF(PORTB,6);}
     716:	2e 98       	cbi	0x05, 6	; 5
     718:	08 95       	ret

0000071a <button_pressed>:


//*****************BUTTON****************
int button_pressed(void)
	{
	return (bit_is_clear(PING, 5));
     71a:	22 b3       	in	r18, 0x12	; 18
     71c:	30 e0       	ldi	r19, 0x00	; 0
     71e:	85 e0       	ldi	r24, 0x05	; 5
     720:	36 95       	lsr	r19
     722:	27 95       	ror	r18
     724:	8a 95       	dec	r24
     726:	e1 f7       	brne	.-8      	; 0x720 <button_pressed+0x6>
     728:	20 95       	com	r18
     72a:	30 95       	com	r19
     72c:	21 70       	andi	r18, 0x01	; 1
     72e:	30 70       	andi	r19, 0x00	; 0
	//return ((PING) & (1<<PG5));//old version, went high when button pushed
	}
     730:	c9 01       	movw	r24, r18
     732:	08 95       	ret

00000734 <cos_SoR>:
signed int angtable[73]={100,100,98,97,94,91,87,82,77,71,64,57,50,42,34,26,17,9,0,-9,-17,-26,-34,-42,-50,-57,-64,-71,-77,-82,-87,-91,-94,-97,-98,-100,
						 -100,-100,-98,-97,-94,-91,-87,-82,-77,-71,-64,-57,-50,-42,-34,-26,-17,-9,0,9,17,26,34,42,50,57,64,71,77,82,87,91,94,97,98,100,100};

signed int cos_SoR(long signed int degrees)//returns cos*100
	{
	if (degrees >= 0)//positive angles
     734:	97 fd       	sbrc	r25, 7
     736:	10 c0       	rjmp	.+32     	; 0x758 <cos_SoR+0x24>
		return angtable[degrees/5];
     738:	25 e0       	ldi	r18, 0x05	; 5
     73a:	30 e0       	ldi	r19, 0x00	; 0
     73c:	40 e0       	ldi	r20, 0x00	; 0
     73e:	50 e0       	ldi	r21, 0x00	; 0
     740:	0e 94 fe 28 	call	0x51fc	; 0x51fc <__divmodsi4>
     744:	da 01       	movw	r26, r20
     746:	c9 01       	movw	r24, r18
     748:	88 0f       	add	r24, r24
     74a:	99 1f       	adc	r25, r25
     74c:	80 50       	subi	r24, 0x00	; 0
     74e:	9e 4f       	sbci	r25, 0xFE	; 254
     750:	fc 01       	movw	r30, r24
     752:	20 81       	ld	r18, Z
     754:	31 81       	ldd	r19, Z+1	; 0x01
     756:	17 c0       	rjmp	.+46     	; 0x786 <cos_SoR+0x52>
	else
		return -angtable[72-(-degrees)/5];
     758:	25 e0       	ldi	r18, 0x05	; 5
     75a:	30 e0       	ldi	r19, 0x00	; 0
     75c:	40 e0       	ldi	r20, 0x00	; 0
     75e:	50 e0       	ldi	r21, 0x00	; 0
     760:	0e 94 fe 28 	call	0x51fc	; 0x51fc <__divmodsi4>
     764:	da 01       	movw	r26, r20
     766:	c9 01       	movw	r24, r18
     768:	88 5b       	subi	r24, 0xB8	; 184
     76a:	9f 4f       	sbci	r25, 0xFF	; 255
     76c:	af 4f       	sbci	r26, 0xFF	; 255
     76e:	bf 4f       	sbci	r27, 0xFF	; 255
     770:	88 0f       	add	r24, r24
     772:	99 1f       	adc	r25, r25
     774:	80 50       	subi	r24, 0x00	; 0
     776:	9e 4f       	sbci	r25, 0xFE	; 254
     778:	fc 01       	movw	r30, r24
     77a:	80 81       	ld	r24, Z
     77c:	91 81       	ldd	r25, Z+1	; 0x01
     77e:	22 27       	eor	r18, r18
     780:	33 27       	eor	r19, r19
     782:	28 1b       	sub	r18, r24
     784:	39 0b       	sbc	r19, r25
	}
     786:	c9 01       	movw	r24, r18
     788:	08 95       	ret

0000078a <sin_SoR>:

signed int sin_SoR(long signed int degrees)//returns sin*100
	{
	degrees=degrees - 90;//phase shift 90 degrees
     78a:	6a 55       	subi	r22, 0x5A	; 90
     78c:	70 40       	sbci	r23, 0x00	; 0
     78e:	80 40       	sbci	r24, 0x00	; 0
     790:	90 40       	sbci	r25, 0x00	; 0

	if (degrees >= 0)//positive angles
     792:	97 fd       	sbrc	r25, 7
     794:	10 c0       	rjmp	.+32     	; 0x7b6 <sin_SoR+0x2c>
		return angtable[degrees/5];
     796:	25 e0       	ldi	r18, 0x05	; 5
     798:	30 e0       	ldi	r19, 0x00	; 0
     79a:	40 e0       	ldi	r20, 0x00	; 0
     79c:	50 e0       	ldi	r21, 0x00	; 0
     79e:	0e 94 fe 28 	call	0x51fc	; 0x51fc <__divmodsi4>
     7a2:	da 01       	movw	r26, r20
     7a4:	c9 01       	movw	r24, r18
     7a6:	88 0f       	add	r24, r24
     7a8:	99 1f       	adc	r25, r25
     7aa:	80 50       	subi	r24, 0x00	; 0
     7ac:	9e 4f       	sbci	r25, 0xFE	; 254
     7ae:	fc 01       	movw	r30, r24
     7b0:	20 81       	ld	r18, Z
     7b2:	31 81       	ldd	r19, Z+1	; 0x01
     7b4:	17 c0       	rjmp	.+46     	; 0x7e4 <sin_SoR+0x5a>
	else
		return -angtable[72-(-degrees)/5];
     7b6:	25 e0       	ldi	r18, 0x05	; 5
     7b8:	30 e0       	ldi	r19, 0x00	; 0
     7ba:	40 e0       	ldi	r20, 0x00	; 0
     7bc:	50 e0       	ldi	r21, 0x00	; 0
     7be:	0e 94 fe 28 	call	0x51fc	; 0x51fc <__divmodsi4>
     7c2:	da 01       	movw	r26, r20
     7c4:	c9 01       	movw	r24, r18
     7c6:	88 5b       	subi	r24, 0xB8	; 184
     7c8:	9f 4f       	sbci	r25, 0xFF	; 255
     7ca:	af 4f       	sbci	r26, 0xFF	; 255
     7cc:	bf 4f       	sbci	r27, 0xFF	; 255
     7ce:	88 0f       	add	r24, r24
     7d0:	99 1f       	adc	r25, r25
     7d2:	80 50       	subi	r24, 0x00	; 0
     7d4:	9e 4f       	sbci	r25, 0xFE	; 254
     7d6:	fc 01       	movw	r30, r24
     7d8:	80 81       	ld	r24, Z
     7da:	91 81       	ldd	r25, Z+1	; 0x01
     7dc:	22 27       	eor	r18, r18
     7de:	33 27       	eor	r19, r19
     7e0:	28 1b       	sub	r18, r24
     7e2:	39 0b       	sbc	r19, r25
	}
     7e4:	c9 01       	movw	r24, r18
     7e6:	08 95       	ret

000007e8 <tan_SoR>:

signed int tan_SoR(long signed int degrees)//returns tan * 10
	{
     7e8:	cf 92       	push	r12
     7ea:	df 92       	push	r13
     7ec:	ef 92       	push	r14
     7ee:	ff 92       	push	r15
     7f0:	0f 93       	push	r16
     7f2:	1f 93       	push	r17
     7f4:	6b 01       	movw	r12, r22
     7f6:	7c 01       	movw	r14, r24
	//tan(x) = sin(x)/cos(x)
	if (degrees == 90 || degrees == -90 || degrees == 270 || degrees == -270)//blows up
     7f8:	8a e5       	ldi	r24, 0x5A	; 90
     7fa:	c8 16       	cp	r12, r24
     7fc:	d1 04       	cpc	r13, r1
     7fe:	e1 04       	cpc	r14, r1
     800:	f1 04       	cpc	r15, r1
     802:	a1 f1       	breq	.+104    	; 0x86c <tan_SoR+0x84>
     804:	86 ea       	ldi	r24, 0xA6	; 166
     806:	c8 16       	cp	r12, r24
     808:	8f ef       	ldi	r24, 0xFF	; 255
     80a:	d8 06       	cpc	r13, r24
     80c:	8f ef       	ldi	r24, 0xFF	; 255
     80e:	e8 06       	cpc	r14, r24
     810:	8f ef       	ldi	r24, 0xFF	; 255
     812:	f8 06       	cpc	r15, r24
     814:	59 f1       	breq	.+86     	; 0x86c <tan_SoR+0x84>
     816:	8e e0       	ldi	r24, 0x0E	; 14
     818:	c8 16       	cp	r12, r24
     81a:	81 e0       	ldi	r24, 0x01	; 1
     81c:	d8 06       	cpc	r13, r24
     81e:	80 e0       	ldi	r24, 0x00	; 0
     820:	e8 06       	cpc	r14, r24
     822:	80 e0       	ldi	r24, 0x00	; 0
     824:	f8 06       	cpc	r15, r24
     826:	11 f1       	breq	.+68     	; 0x86c <tan_SoR+0x84>
     828:	82 ef       	ldi	r24, 0xF2	; 242
     82a:	c8 16       	cp	r12, r24
     82c:	8e ef       	ldi	r24, 0xFE	; 254
     82e:	d8 06       	cpc	r13, r24
     830:	8f ef       	ldi	r24, 0xFF	; 255
     832:	e8 06       	cpc	r14, r24
     834:	8f ef       	ldi	r24, 0xFF	; 255
     836:	f8 06       	cpc	r15, r24
     838:	c9 f0       	breq	.+50     	; 0x86c <tan_SoR+0x84>
		return 0;//what else should I return?!?!?
	return sin_SoR(degrees)/cos_SoR(degrees)*10;
     83a:	c7 01       	movw	r24, r14
     83c:	b6 01       	movw	r22, r12
     83e:	0e 94 c5 03 	call	0x78a	; 0x78a <sin_SoR>
     842:	8c 01       	movw	r16, r24
     844:	c7 01       	movw	r24, r14
     846:	b6 01       	movw	r22, r12
     848:	0e 94 9a 03 	call	0x734	; 0x734 <cos_SoR>
     84c:	bc 01       	movw	r22, r24
     84e:	c8 01       	movw	r24, r16
     850:	0e 94 c9 28 	call	0x5192	; 0x5192 <__divmodhi4>
     854:	cb 01       	movw	r24, r22
     856:	9b 01       	movw	r18, r22
     858:	73 e0       	ldi	r23, 0x03	; 3
     85a:	22 0f       	add	r18, r18
     85c:	33 1f       	adc	r19, r19
     85e:	7a 95       	dec	r23
     860:	e1 f7       	brne	.-8      	; 0x85a <tan_SoR+0x72>
     862:	88 0f       	add	r24, r24
     864:	99 1f       	adc	r25, r25
     866:	28 0f       	add	r18, r24
     868:	39 1f       	adc	r19, r25
     86a:	02 c0       	rjmp	.+4      	; 0x870 <tan_SoR+0x88>
     86c:	20 e0       	ldi	r18, 0x00	; 0
     86e:	30 e0       	ldi	r19, 0x00	; 0
	}
     870:	c9 01       	movw	r24, r18
     872:	1f 91       	pop	r17
     874:	0f 91       	pop	r16
     876:	ff 90       	pop	r15
     878:	ef 90       	pop	r14
     87a:	df 90       	pop	r13
     87c:	cf 90       	pop	r12
     87e:	08 95       	ret

00000880 <prvPWMSetup>:
//-----------------------------**&&**


void prvPWMSetup(){

	PWM_Init_timer3_E4(10); // Left wheel
     880:	8a e0       	ldi	r24, 0x0A	; 10
     882:	0e 94 63 01 	call	0x2c6	; 0x2c6 <PWM_Init_timer3_E4>
	PWM_Init_timer3_E3(10); // Right wheel
     886:	8a e0       	ldi	r24, 0x0A	; 10
     888:	0e 94 43 01 	call	0x286	; 0x286 <PWM_Init_timer3_E3>
	PWM_Init_timer4_H3(10);	// Left sprayer
     88c:	8a e0       	ldi	r24, 0x0A	; 10
     88e:	0e 94 a3 01 	call	0x346	; 0x346 <PWM_Init_timer4_H3>
	PWM_Init_timer4_H4(10);	// Right sprayer
     892:	8a e0       	ldi	r24, 0x0A	; 10
     894:	0e 94 c3 01 	call	0x386	; 0x386 <PWM_Init_timer4_H4>

}
     898:	08 95       	ret

0000089a <char2hex>:

char char2hex(char c){
     89a:	98 2f       	mov	r25, r24
	
	if((c > 47) && (c <58)){
     89c:	80 53       	subi	r24, 0x30	; 48
     89e:	8a 30       	cpi	r24, 0x0A	; 10
     8a0:	38 f0       	brcs	.+14     	; 0x8b0 <char2hex+0x16>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     8a2:	81 51       	subi	r24, 0x11	; 17
     8a4:	86 30       	cpi	r24, 0x06	; 6
     8a6:	10 f0       	brcs	.+4      	; 0x8ac <char2hex+0x12>
     8a8:	89 2f       	mov	r24, r25
     8aa:	08 95       	ret
		c -= 55;
     8ac:	89 2f       	mov	r24, r25
     8ae:	87 53       	subi	r24, 0x37	; 55
	}
	return c;
}
     8b0:	08 95       	ret

000008b2 <retConv_s16>:

s16 retConv_s16(char* ch_head){
     8b2:	fc 01       	movw	r30, r24

	s16 int_val = 0x0000;
	char iv1 = *(ch_head);
     8b4:	90 81       	ld	r25, Z
	char iv2 = *(ch_head + 1);
     8b6:	21 81       	ldd	r18, Z+1	; 0x01
	char iv3 = *(ch_head + 2);
     8b8:	42 81       	ldd	r20, Z+2	; 0x02
	char iv4 = *(ch_head + 3);
     8ba:	53 81       	ldd	r21, Z+3	; 0x03

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     8bc:	89 2f       	mov	r24, r25
     8be:	80 53       	subi	r24, 0x30	; 48
     8c0:	8a 30       	cpi	r24, 0x0A	; 10
     8c2:	10 f4       	brcc	.+4      	; 0x8c8 <retConv_s16+0x16>
     8c4:	98 2f       	mov	r25, r24
     8c6:	05 c0       	rjmp	.+10     	; 0x8d2 <retConv_s16+0x20>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     8c8:	89 2f       	mov	r24, r25
     8ca:	81 54       	subi	r24, 0x41	; 65
     8cc:	86 30       	cpi	r24, 0x06	; 6
     8ce:	08 f4       	brcc	.+2      	; 0x8d2 <retConv_s16+0x20>
		c -= 55;
     8d0:	97 53       	subi	r25, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     8d2:	82 2f       	mov	r24, r18
     8d4:	80 53       	subi	r24, 0x30	; 48
     8d6:	8a 30       	cpi	r24, 0x0A	; 10
     8d8:	10 f4       	brcc	.+4      	; 0x8de <retConv_s16+0x2c>
     8da:	28 2f       	mov	r18, r24
     8dc:	05 c0       	rjmp	.+10     	; 0x8e8 <retConv_s16+0x36>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     8de:	82 2f       	mov	r24, r18
     8e0:	81 54       	subi	r24, 0x41	; 65
     8e2:	86 30       	cpi	r24, 0x06	; 6
     8e4:	08 f4       	brcc	.+2      	; 0x8e8 <retConv_s16+0x36>
		c -= 55;
     8e6:	27 53       	subi	r18, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     8e8:	84 2f       	mov	r24, r20
     8ea:	80 53       	subi	r24, 0x30	; 48
     8ec:	8a 30       	cpi	r24, 0x0A	; 10
     8ee:	10 f4       	brcc	.+4      	; 0x8f4 <retConv_s16+0x42>
     8f0:	48 2f       	mov	r20, r24
     8f2:	05 c0       	rjmp	.+10     	; 0x8fe <retConv_s16+0x4c>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     8f4:	84 2f       	mov	r24, r20
     8f6:	81 54       	subi	r24, 0x41	; 65
     8f8:	86 30       	cpi	r24, 0x06	; 6
     8fa:	08 f4       	brcc	.+2      	; 0x8fe <retConv_s16+0x4c>
		c -= 55;
     8fc:	47 53       	subi	r20, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     8fe:	85 2f       	mov	r24, r21
     900:	80 53       	subi	r24, 0x30	; 48
     902:	8a 30       	cpi	r24, 0x0A	; 10
     904:	10 f4       	brcc	.+4      	; 0x90a <retConv_s16+0x58>
     906:	58 2f       	mov	r21, r24
     908:	05 c0       	rjmp	.+10     	; 0x914 <retConv_s16+0x62>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     90a:	85 2f       	mov	r24, r21
     90c:	81 54       	subi	r24, 0x41	; 65
     90e:	86 30       	cpi	r24, 0x06	; 6
     910:	08 f4       	brcc	.+2      	; 0x914 <retConv_s16+0x62>
		c -= 55;
     912:	57 53       	subi	r21, 0x37	; 55
	iv2 = char2hex(iv2);
	iv3 = char2hex(iv3);
	iv4 = char2hex(iv4);

	int_val = (int_val | iv1);
	int_val = ((int_val<<4) | iv2);
     914:	30 e0       	ldi	r19, 0x00	; 0
     916:	89 2f       	mov	r24, r25
     918:	90 e0       	ldi	r25, 0x00	; 0
     91a:	a4 e0       	ldi	r26, 0x04	; 4
     91c:	88 0f       	add	r24, r24
     91e:	99 1f       	adc	r25, r25
     920:	aa 95       	dec	r26
     922:	e1 f7       	brne	.-8      	; 0x91c <retConv_s16+0x6a>
     924:	28 2b       	or	r18, r24
     926:	39 2b       	or	r19, r25
	int_val = ((int_val<<4) | iv3);
     928:	f4 e0       	ldi	r31, 0x04	; 4
     92a:	22 0f       	add	r18, r18
     92c:	33 1f       	adc	r19, r19
     92e:	fa 95       	dec	r31
     930:	e1 f7       	brne	.-8      	; 0x92a <retConv_s16+0x78>
     932:	84 2f       	mov	r24, r20
     934:	90 e0       	ldi	r25, 0x00	; 0
     936:	82 2b       	or	r24, r18
     938:	93 2b       	or	r25, r19
	int_val = ((int_val<<4) | iv4);
     93a:	e4 e0       	ldi	r30, 0x04	; 4
     93c:	88 0f       	add	r24, r24
     93e:	99 1f       	adc	r25, r25
     940:	ea 95       	dec	r30
     942:	e1 f7       	brne	.-8      	; 0x93c <retConv_s16+0x8a>
     944:	25 2f       	mov	r18, r21
     946:	30 e0       	ldi	r19, 0x00	; 0
     948:	28 2b       	or	r18, r24
     94a:	39 2b       	or	r19, r25
	return int_val;
}
     94c:	c9 01       	movw	r24, r18
     94e:	08 95       	ret

00000950 <retConv_s32>:

s32 retConv_s32(char* ch_head){
     950:	ff 92       	push	r15
     952:	0f 93       	push	r16
     954:	1f 93       	push	r17
     956:	fc 01       	movw	r30, r24

	s32 int_val = 0x00000000;
	char iv1 = *(ch_head);
     958:	90 81       	ld	r25, Z
	char iv2 = *(ch_head + 1);
     95a:	21 81       	ldd	r18, Z+1	; 0x01
	char iv3 = *(ch_head + 2);
     95c:	62 81       	ldd	r22, Z+2	; 0x02
	char iv4 = *(ch_head + 3);
     95e:	73 81       	ldd	r23, Z+3	; 0x03
	char iv5 = *(ch_head + 4);
     960:	14 81       	ldd	r17, Z+4	; 0x04
	char iv6 = *(ch_head + 5);
     962:	05 81       	ldd	r16, Z+5	; 0x05
	char iv7 = *(ch_head + 6);
     964:	f6 80       	ldd	r15, Z+6	; 0x06
	char iv8 = *(ch_head + 7);
     966:	e7 81       	ldd	r30, Z+7	; 0x07

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     968:	89 2f       	mov	r24, r25
     96a:	80 53       	subi	r24, 0x30	; 48
     96c:	8a 30       	cpi	r24, 0x0A	; 10
     96e:	10 f4       	brcc	.+4      	; 0x974 <retConv_s32+0x24>
     970:	98 2f       	mov	r25, r24
     972:	05 c0       	rjmp	.+10     	; 0x97e <retConv_s32+0x2e>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     974:	89 2f       	mov	r24, r25
     976:	81 54       	subi	r24, 0x41	; 65
     978:	86 30       	cpi	r24, 0x06	; 6
     97a:	08 f4       	brcc	.+2      	; 0x97e <retConv_s32+0x2e>
		c -= 55;
     97c:	97 53       	subi	r25, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     97e:	82 2f       	mov	r24, r18
     980:	80 53       	subi	r24, 0x30	; 48
     982:	8a 30       	cpi	r24, 0x0A	; 10
     984:	10 f4       	brcc	.+4      	; 0x98a <retConv_s32+0x3a>
     986:	28 2f       	mov	r18, r24
     988:	05 c0       	rjmp	.+10     	; 0x994 <retConv_s32+0x44>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     98a:	82 2f       	mov	r24, r18
     98c:	81 54       	subi	r24, 0x41	; 65
     98e:	86 30       	cpi	r24, 0x06	; 6
     990:	08 f4       	brcc	.+2      	; 0x994 <retConv_s32+0x44>
		c -= 55;
     992:	27 53       	subi	r18, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     994:	86 2f       	mov	r24, r22
     996:	80 53       	subi	r24, 0x30	; 48
     998:	8a 30       	cpi	r24, 0x0A	; 10
     99a:	10 f4       	brcc	.+4      	; 0x9a0 <retConv_s32+0x50>
     99c:	68 2f       	mov	r22, r24
     99e:	05 c0       	rjmp	.+10     	; 0x9aa <retConv_s32+0x5a>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     9a0:	86 2f       	mov	r24, r22
     9a2:	81 54       	subi	r24, 0x41	; 65
     9a4:	86 30       	cpi	r24, 0x06	; 6
     9a6:	08 f4       	brcc	.+2      	; 0x9aa <retConv_s32+0x5a>
		c -= 55;
     9a8:	67 53       	subi	r22, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     9aa:	87 2f       	mov	r24, r23
     9ac:	80 53       	subi	r24, 0x30	; 48
     9ae:	8a 30       	cpi	r24, 0x0A	; 10
     9b0:	10 f4       	brcc	.+4      	; 0x9b6 <retConv_s32+0x66>
     9b2:	78 2f       	mov	r23, r24
     9b4:	05 c0       	rjmp	.+10     	; 0x9c0 <retConv_s32+0x70>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     9b6:	87 2f       	mov	r24, r23
     9b8:	81 54       	subi	r24, 0x41	; 65
     9ba:	86 30       	cpi	r24, 0x06	; 6
     9bc:	08 f4       	brcc	.+2      	; 0x9c0 <retConv_s32+0x70>
		c -= 55;
     9be:	77 53       	subi	r23, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     9c0:	81 2f       	mov	r24, r17
     9c2:	80 53       	subi	r24, 0x30	; 48
     9c4:	8a 30       	cpi	r24, 0x0A	; 10
     9c6:	10 f4       	brcc	.+4      	; 0x9cc <retConv_s32+0x7c>
     9c8:	18 2f       	mov	r17, r24
     9ca:	05 c0       	rjmp	.+10     	; 0x9d6 <retConv_s32+0x86>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     9cc:	81 2f       	mov	r24, r17
     9ce:	81 54       	subi	r24, 0x41	; 65
     9d0:	86 30       	cpi	r24, 0x06	; 6
     9d2:	08 f4       	brcc	.+2      	; 0x9d6 <retConv_s32+0x86>
		c -= 55;
     9d4:	17 53       	subi	r17, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     9d6:	80 2f       	mov	r24, r16
     9d8:	80 53       	subi	r24, 0x30	; 48
     9da:	8a 30       	cpi	r24, 0x0A	; 10
     9dc:	10 f4       	brcc	.+4      	; 0x9e2 <retConv_s32+0x92>
     9de:	08 2f       	mov	r16, r24
     9e0:	05 c0       	rjmp	.+10     	; 0x9ec <retConv_s32+0x9c>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     9e2:	80 2f       	mov	r24, r16
     9e4:	81 54       	subi	r24, 0x41	; 65
     9e6:	86 30       	cpi	r24, 0x06	; 6
     9e8:	08 f4       	brcc	.+2      	; 0x9ec <retConv_s32+0x9c>
		c -= 55;
     9ea:	07 53       	subi	r16, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     9ec:	8f 2d       	mov	r24, r15
     9ee:	80 53       	subi	r24, 0x30	; 48
     9f0:	8a 30       	cpi	r24, 0x0A	; 10
     9f2:	10 f4       	brcc	.+4      	; 0x9f8 <retConv_s32+0xa8>
     9f4:	f8 2e       	mov	r15, r24
     9f6:	06 c0       	rjmp	.+12     	; 0xa04 <retConv_s32+0xb4>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     9f8:	8f 2d       	mov	r24, r15
     9fa:	81 54       	subi	r24, 0x41	; 65
     9fc:	86 30       	cpi	r24, 0x06	; 6
     9fe:	10 f4       	brcc	.+4      	; 0xa04 <retConv_s32+0xb4>
		c -= 55;
     a00:	89 ec       	ldi	r24, 0xC9	; 201
     a02:	f8 0e       	add	r15, r24

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     a04:	8e 2f       	mov	r24, r30
     a06:	80 53       	subi	r24, 0x30	; 48
     a08:	8a 30       	cpi	r24, 0x0A	; 10
     a0a:	10 f4       	brcc	.+4      	; 0xa10 <retConv_s32+0xc0>
     a0c:	e8 2f       	mov	r30, r24
     a0e:	05 c0       	rjmp	.+10     	; 0xa1a <retConv_s32+0xca>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     a10:	8e 2f       	mov	r24, r30
     a12:	81 54       	subi	r24, 0x41	; 65
     a14:	86 30       	cpi	r24, 0x06	; 6
     a16:	08 f4       	brcc	.+2      	; 0xa1a <retConv_s32+0xca>
		c -= 55;
     a18:	e7 53       	subi	r30, 0x37	; 55
	iv6 = char2hex(iv6);
	iv7 = char2hex(iv7);
	iv8 = char2hex(iv8);

	int_val = (int_val | iv1);
	int_val = ((int_val<<4) | iv2);
     a1a:	30 e0       	ldi	r19, 0x00	; 0
     a1c:	40 e0       	ldi	r20, 0x00	; 0
     a1e:	50 e0       	ldi	r21, 0x00	; 0
     a20:	89 2f       	mov	r24, r25
     a22:	90 e0       	ldi	r25, 0x00	; 0
     a24:	a0 e0       	ldi	r26, 0x00	; 0
     a26:	b0 e0       	ldi	r27, 0x00	; 0
     a28:	f4 e0       	ldi	r31, 0x04	; 4
     a2a:	88 0f       	add	r24, r24
     a2c:	99 1f       	adc	r25, r25
     a2e:	aa 1f       	adc	r26, r26
     a30:	bb 1f       	adc	r27, r27
     a32:	fa 95       	dec	r31
     a34:	d1 f7       	brne	.-12     	; 0xa2a <retConv_s32+0xda>
     a36:	28 2b       	or	r18, r24
     a38:	39 2b       	or	r19, r25
     a3a:	4a 2b       	or	r20, r26
     a3c:	5b 2b       	or	r21, r27
	int_val = ((int_val<<4) | iv3);
     a3e:	a4 e0       	ldi	r26, 0x04	; 4
     a40:	22 0f       	add	r18, r18
     a42:	33 1f       	adc	r19, r19
     a44:	44 1f       	adc	r20, r20
     a46:	55 1f       	adc	r21, r21
     a48:	aa 95       	dec	r26
     a4a:	d1 f7       	brne	.-12     	; 0xa40 <retConv_s32+0xf0>
     a4c:	86 2f       	mov	r24, r22
     a4e:	90 e0       	ldi	r25, 0x00	; 0
     a50:	a0 e0       	ldi	r26, 0x00	; 0
     a52:	b0 e0       	ldi	r27, 0x00	; 0
     a54:	82 2b       	or	r24, r18
     a56:	93 2b       	or	r25, r19
     a58:	a4 2b       	or	r26, r20
     a5a:	b5 2b       	or	r27, r21
	int_val = ((int_val<<4) | iv4);
     a5c:	f4 e0       	ldi	r31, 0x04	; 4
     a5e:	88 0f       	add	r24, r24
     a60:	99 1f       	adc	r25, r25
     a62:	aa 1f       	adc	r26, r26
     a64:	bb 1f       	adc	r27, r27
     a66:	fa 95       	dec	r31
     a68:	d1 f7       	brne	.-12     	; 0xa5e <retConv_s32+0x10e>
     a6a:	27 2f       	mov	r18, r23
     a6c:	30 e0       	ldi	r19, 0x00	; 0
     a6e:	40 e0       	ldi	r20, 0x00	; 0
     a70:	50 e0       	ldi	r21, 0x00	; 0
     a72:	28 2b       	or	r18, r24
     a74:	39 2b       	or	r19, r25
     a76:	4a 2b       	or	r20, r26
     a78:	5b 2b       	or	r21, r27
	int_val = ((int_val<<4) | iv5);
     a7a:	64 e0       	ldi	r22, 0x04	; 4
     a7c:	22 0f       	add	r18, r18
     a7e:	33 1f       	adc	r19, r19
     a80:	44 1f       	adc	r20, r20
     a82:	55 1f       	adc	r21, r21
     a84:	6a 95       	dec	r22
     a86:	d1 f7       	brne	.-12     	; 0xa7c <retConv_s32+0x12c>
     a88:	81 2f       	mov	r24, r17
     a8a:	90 e0       	ldi	r25, 0x00	; 0
     a8c:	a0 e0       	ldi	r26, 0x00	; 0
     a8e:	b0 e0       	ldi	r27, 0x00	; 0
     a90:	82 2b       	or	r24, r18
     a92:	93 2b       	or	r25, r19
     a94:	a4 2b       	or	r26, r20
     a96:	b5 2b       	or	r27, r21
	int_val = ((int_val<<4) | iv6);
     a98:	24 e0       	ldi	r18, 0x04	; 4
     a9a:	88 0f       	add	r24, r24
     a9c:	99 1f       	adc	r25, r25
     a9e:	aa 1f       	adc	r26, r26
     aa0:	bb 1f       	adc	r27, r27
     aa2:	2a 95       	dec	r18
     aa4:	d1 f7       	brne	.-12     	; 0xa9a <retConv_s32+0x14a>
     aa6:	20 2f       	mov	r18, r16
     aa8:	30 e0       	ldi	r19, 0x00	; 0
     aaa:	40 e0       	ldi	r20, 0x00	; 0
     aac:	50 e0       	ldi	r21, 0x00	; 0
     aae:	28 2b       	or	r18, r24
     ab0:	39 2b       	or	r19, r25
     ab2:	4a 2b       	or	r20, r26
     ab4:	5b 2b       	or	r21, r27
	int_val = ((int_val<<4) | iv7);
     ab6:	04 e0       	ldi	r16, 0x04	; 4
     ab8:	22 0f       	add	r18, r18
     aba:	33 1f       	adc	r19, r19
     abc:	44 1f       	adc	r20, r20
     abe:	55 1f       	adc	r21, r21
     ac0:	0a 95       	dec	r16
     ac2:	d1 f7       	brne	.-12     	; 0xab8 <retConv_s32+0x168>
     ac4:	8f 2d       	mov	r24, r15
     ac6:	90 e0       	ldi	r25, 0x00	; 0
     ac8:	a0 e0       	ldi	r26, 0x00	; 0
     aca:	b0 e0       	ldi	r27, 0x00	; 0
     acc:	82 2b       	or	r24, r18
     ace:	93 2b       	or	r25, r19
     ad0:	a4 2b       	or	r26, r20
     ad2:	b5 2b       	or	r27, r21
	int_val = ((int_val<<4) | iv8);
     ad4:	14 e0       	ldi	r17, 0x04	; 4
     ad6:	88 0f       	add	r24, r24
     ad8:	99 1f       	adc	r25, r25
     ada:	aa 1f       	adc	r26, r26
     adc:	bb 1f       	adc	r27, r27
     ade:	1a 95       	dec	r17
     ae0:	d1 f7       	brne	.-12     	; 0xad6 <retConv_s32+0x186>
     ae2:	2e 2f       	mov	r18, r30
     ae4:	30 e0       	ldi	r19, 0x00	; 0
     ae6:	40 e0       	ldi	r20, 0x00	; 0
     ae8:	50 e0       	ldi	r21, 0x00	; 0
     aea:	28 2b       	or	r18, r24
     aec:	39 2b       	or	r19, r25
     aee:	4a 2b       	or	r20, r26
     af0:	5b 2b       	or	r21, r27
	return int_val;
}
     af2:	b9 01       	movw	r22, r18
     af4:	ca 01       	movw	r24, r20
     af6:	1f 91       	pop	r17
     af8:	0f 91       	pop	r16
     afa:	ff 90       	pop	r15
     afc:	08 95       	ret

00000afe <LDSRcv>:
		
}
*/
void LDSRcv(unsigned char c){
	//if( (c != 0xff) && (lds_buffer_write_ndx != NULL) && (lds_buffer_write_ndx > lds_buffer_read_ndx)){
	if(c != 0xff){
     afe:	8f 3f       	cpi	r24, 0xFF	; 255
     b00:	b9 f0       	breq	.+46     	; 0xb30 <LDSRcv+0x32>
		*lds_buffer_write_ndx = c;
     b02:	e0 91 98 02 	lds	r30, 0x0298
     b06:	f0 91 99 02 	lds	r31, 0x0299
     b0a:	80 83       	st	Z, r24
		lds_buffer_write_ndx++;		
     b0c:	80 91 98 02 	lds	r24, 0x0298
     b10:	90 91 99 02 	lds	r25, 0x0299
     b14:	01 96       	adiw	r24, 0x01	; 1
     b16:	90 93 99 02 	sts	0x0299, r25
     b1a:	80 93 98 02 	sts	0x0298, r24
		if(lds_buffer_write_ndx >= (lds_buffer + BUFFER_SIZE)){ 
     b1e:	8e 5b       	subi	r24, 0xBE	; 190
     b20:	92 41       	sbci	r25, 0x12	; 18
     b22:	30 f0       	brcs	.+12     	; 0xb30 <LDSRcv+0x32>
			lds_buffer_write_ndx = lds_buffer;
     b24:	8e eb       	ldi	r24, 0xBE	; 190
     b26:	91 e1       	ldi	r25, 0x11	; 17
     b28:	90 93 99 02 	sts	0x0299, r25
     b2c:	80 93 98 02 	sts	0x0298, r24
     b30:	08 95       	ret

00000b32 <error_checker>:
		lds_buffer_read_ndx = lds_buffer;
	}
	return data;
}

uint8_t error_checker(const uint16_t chk_data[], uint16_t checksum){
     b32:	0f 93       	push	r16
     b34:	1f 93       	push	r17
     b36:	cf 93       	push	r28
     b38:	df 93       	push	r29
     b3a:	ec 01       	movw	r28, r24
     b3c:	8b 01       	movw	r16, r22
     b3e:	20 e0       	ldi	r18, 0x00	; 0
     b40:	30 e0       	ldi	r19, 0x00	; 0
     b42:	40 e0       	ldi	r20, 0x00	; 0
     b44:	50 e0       	ldi	r21, 0x00	; 0
     b46:	60 e0       	ldi	r22, 0x00	; 0
     b48:	70 e0       	ldi	r23, 0x00	; 0
    uint32_t chk32 = 0;
    for(uint8_t ndx = 0; ndx < 10; ndx++){
      chk32 = (chk32 << 1) + chk_data[ndx];
     b4a:	22 0f       	add	r18, r18
     b4c:	33 1f       	adc	r19, r19
     b4e:	44 1f       	adc	r20, r20
     b50:	55 1f       	adc	r21, r21
     b52:	fe 01       	movw	r30, r28
     b54:	e6 0f       	add	r30, r22
     b56:	f7 1f       	adc	r31, r23
     b58:	80 81       	ld	r24, Z
     b5a:	91 81       	ldd	r25, Z+1	; 0x01
     b5c:	a0 e0       	ldi	r26, 0x00	; 0
     b5e:	b0 e0       	ldi	r27, 0x00	; 0
     b60:	28 0f       	add	r18, r24
     b62:	39 1f       	adc	r19, r25
     b64:	4a 1f       	adc	r20, r26
     b66:	5b 1f       	adc	r21, r27
     b68:	6e 5f       	subi	r22, 0xFE	; 254
     b6a:	7f 4f       	sbci	r23, 0xFF	; 255
	return data;
}

uint8_t error_checker(const uint16_t chk_data[], uint16_t checksum){
    uint32_t chk32 = 0;
    for(uint8_t ndx = 0; ndx < 10; ndx++){
     b6c:	64 31       	cpi	r22, 0x14	; 20
     b6e:	71 05       	cpc	r23, r1
     b70:	61 f7       	brne	.-40     	; 0xb4a <error_checker+0x18>
      chk32 = (chk32 << 1) + chk_data[ndx];
    }
    uint16_t chk16 = (chk32 & 0x7FFF) + (chk32 >> 15);
     b72:	c9 01       	movw	r24, r18
     b74:	9f 77       	andi	r25, 0x7F	; 127
     b76:	af e0       	ldi	r26, 0x0F	; 15
     b78:	56 95       	lsr	r21
     b7a:	47 95       	ror	r20
     b7c:	37 95       	ror	r19
     b7e:	27 95       	ror	r18
     b80:	aa 95       	dec	r26
     b82:	d1 f7       	brne	.-12     	; 0xb78 <error_checker+0x46>
     b84:	82 0f       	add	r24, r18
     b86:	93 1f       	adc	r25, r19
     b88:	20 e0       	ldi	r18, 0x00	; 0
     b8a:	9f 77       	andi	r25, 0x7F	; 127
     b8c:	80 17       	cp	r24, r16
     b8e:	91 07       	cpc	r25, r17
     b90:	09 f4       	brne	.+2      	; 0xb94 <error_checker+0x62>
     b92:	21 e0       	ldi	r18, 0x01	; 1
    chk16 = chk16 & 0x7FFF;
    return (chk16 == checksum);
  }
     b94:	82 2f       	mov	r24, r18
     b96:	df 91       	pop	r29
     b98:	cf 91       	pop	r28
     b9a:	1f 91       	pop	r17
     b9c:	0f 91       	pop	r16
     b9e:	08 95       	ret

00000ba0 <num2char>:





char num2char(char c){
     ba0:	98 2f       	mov	r25, r24
	
	if(c <10){
     ba2:	8a 30       	cpi	r24, 0x0A	; 10
     ba4:	10 f4       	brcc	.+4      	; 0xbaa <num2char+0xa>
		c += 48;
     ba6:	90 5d       	subi	r25, 0xD0	; 208
     ba8:	04 c0       	rjmp	.+8      	; 0xbb2 <num2char+0x12>
	}
	else if((c >= 10) && (c <= 16)){
     baa:	8a 50       	subi	r24, 0x0A	; 10
     bac:	87 30       	cpi	r24, 0x07	; 7
     bae:	08 f4       	brcc	.+2      	; 0xbb2 <num2char+0x12>
		c += 55;
     bb0:	99 5c       	subi	r25, 0xC9	; 201
	}
	return c;
}
     bb2:	89 2f       	mov	r24, r25
     bb4:	08 95       	ret

00000bb6 <conv_FrametoDist>:
			f_ndx++;
		}
	}
}

void conv_FrametoDist(const LDS_FRAME ldsf[], uint16_t ranges[]){
     bb6:	dc 01       	movw	r26, r24
     bb8:	fb 01       	movw	r30, r22
     bba:	20 e0       	ldi	r18, 0x00	; 0
     bbc:	30 e0       	ldi	r19, 0x00	; 0
	// ldsf must be of length 90
	// ranges must be of length 360
	for(uint16_t f_ndx = 0; f_ndx < 90; f_ndx++){
		ranges[4*f_ndx]     = (ldsf[f_ndx].distance[0]);
     bbe:	1b 96       	adiw	r26, 0x0b	; 11
     bc0:	8d 91       	ld	r24, X+
     bc2:	9c 91       	ld	r25, X
     bc4:	1c 97       	sbiw	r26, 0x0c	; 12
     bc6:	91 83       	std	Z+1, r25	; 0x01
     bc8:	80 83       	st	Z, r24
		ranges[4*f_ndx + 1] = (ldsf[f_ndx].distance[1]);
     bca:	1d 96       	adiw	r26, 0x0d	; 13
     bcc:	8d 91       	ld	r24, X+
     bce:	9c 91       	ld	r25, X
     bd0:	1e 97       	sbiw	r26, 0x0e	; 14
     bd2:	93 83       	std	Z+3, r25	; 0x03
     bd4:	82 83       	std	Z+2, r24	; 0x02
		ranges[4*f_ndx + 2] = (ldsf[f_ndx].distance[2]);
     bd6:	1f 96       	adiw	r26, 0x0f	; 15
     bd8:	8d 91       	ld	r24, X+
     bda:	9c 91       	ld	r25, X
     bdc:	50 97       	sbiw	r26, 0x10	; 16
     bde:	95 83       	std	Z+5, r25	; 0x05
     be0:	84 83       	std	Z+4, r24	; 0x04
		ranges[4*f_ndx + 3] = (ldsf[f_ndx].distance[3]);
     be2:	51 96       	adiw	r26, 0x11	; 17
     be4:	8d 91       	ld	r24, X+
     be6:	9c 91       	ld	r25, X
     be8:	52 97       	sbiw	r26, 0x12	; 18
     bea:	97 83       	std	Z+7, r25	; 0x07
     bec:	86 83       	std	Z+6, r24	; 0x06
}

void conv_FrametoDist(const LDS_FRAME ldsf[], uint16_t ranges[]){
	// ldsf must be of length 90
	// ranges must be of length 360
	for(uint16_t f_ndx = 0; f_ndx < 90; f_ndx++){
     bee:	2f 5f       	subi	r18, 0xFF	; 255
     bf0:	3f 4f       	sbci	r19, 0xFF	; 255
     bf2:	5d 96       	adiw	r26, 0x1d	; 29
     bf4:	38 96       	adiw	r30, 0x08	; 8
     bf6:	2a 35       	cpi	r18, 0x5A	; 90
     bf8:	31 05       	cpc	r19, r1
     bfa:	09 f7       	brne	.-62     	; 0xbbe <conv_FrametoDist+0x8>
		ranges[4*f_ndx]     = (ldsf[f_ndx].distance[0]);
		ranges[4*f_ndx + 1] = (ldsf[f_ndx].distance[1]);
		ranges[4*f_ndx + 2] = (ldsf[f_ndx].distance[2]);
		ranges[4*f_ndx + 3] = (ldsf[f_ndx].distance[3]);
	}
}
     bfc:	08 95       	ret

00000bfe <print_frame>:
	uart3SendByte(r1);
	uart3SendByte('\n'); //line feed
}


void print_frame(LDS_FRAME frame){
     bfe:	ef 92       	push	r14
     c00:	ff 92       	push	r15
     c02:	0f 93       	push	r16
     c04:	1f 93       	push	r17
     c06:	df 93       	push	r29
     c08:	cf 93       	push	r28
     c0a:	cd b7       	in	r28, 0x3d	; 61
     c0c:	de b7       	in	r29, 0x3e	; 62
     c0e:	e9 84       	ldd	r14, Y+9	; 0x09
     c10:	0a 85       	ldd	r16, Y+10	; 0x0a
     c12:	1b 85       	ldd	r17, Y+11	; 0x0b
	rprintf("Index: ");
     c14:	00 d0       	rcall	.+0      	; 0xc16 <print_frame+0x18>
     c16:	0f 92       	push	r0
     c18:	ff 24       	eor	r15, r15
     c1a:	f3 94       	inc	r15
     c1c:	ad b7       	in	r26, 0x3d	; 61
     c1e:	be b7       	in	r27, 0x3e	; 62
     c20:	11 96       	adiw	r26, 0x01	; 1
     c22:	fc 92       	st	X, r15
     c24:	11 97       	sbiw	r26, 0x01	; 1
     c26:	86 e5       	ldi	r24, 0x56	; 86
     c28:	91 e0       	ldi	r25, 0x01	; 1
     c2a:	13 96       	adiw	r26, 0x03	; 3
     c2c:	9c 93       	st	X, r25
     c2e:	8e 93       	st	-X, r24
     c30:	12 97       	sbiw	r26, 0x02	; 2
     c32:	0e 94 66 23 	call	0x46cc	; 0x46cc <rprintf1RamRom>
	rprintfu08(frame.index);
     c36:	0f 90       	pop	r0
     c38:	0f 90       	pop	r0
     c3a:	0f 90       	pop	r0
     c3c:	8e 2d       	mov	r24, r14
     c3e:	0e 94 b5 21 	call	0x436a	; 0x436a <rprintfu08>
	rprintf(" Motor Speed: ");
     c42:	00 d0       	rcall	.+0      	; 0xc44 <print_frame+0x46>
     c44:	0f 92       	push	r0
     c46:	ed b7       	in	r30, 0x3d	; 61
     c48:	fe b7       	in	r31, 0x3e	; 62
     c4a:	f1 82       	std	Z+1, r15	; 0x01
     c4c:	87 e4       	ldi	r24, 0x47	; 71
     c4e:	91 e0       	ldi	r25, 0x01	; 1
     c50:	93 83       	std	Z+3, r25	; 0x03
     c52:	82 83       	std	Z+2, r24	; 0x02
     c54:	0e 94 66 23 	call	0x46cc	; 0x46cc <rprintf1RamRom>
	rprintfu16(frame.motor_speed);
     c58:	0f 90       	pop	r0
     c5a:	0f 90       	pop	r0
     c5c:	0f 90       	pop	r0
     c5e:	c8 01       	movw	r24, r16
     c60:	0e 94 c0 21 	call	0x4380	; 0x4380 <rprintfu16>
	rprintf(" Distances: ");
     c64:	00 d0       	rcall	.+0      	; 0xc66 <print_frame+0x68>
     c66:	0f 92       	push	r0
     c68:	ad b7       	in	r26, 0x3d	; 61
     c6a:	be b7       	in	r27, 0x3e	; 62
     c6c:	11 96       	adiw	r26, 0x01	; 1
     c6e:	fc 92       	st	X, r15
     c70:	11 97       	sbiw	r26, 0x01	; 1
     c72:	8a e3       	ldi	r24, 0x3A	; 58
     c74:	91 e0       	ldi	r25, 0x01	; 1
     c76:	13 96       	adiw	r26, 0x03	; 3
     c78:	9c 93       	st	X, r25
     c7a:	8e 93       	st	-X, r24
     c7c:	12 97       	sbiw	r26, 0x02	; 2
     c7e:	0e 94 66 23 	call	0x46cc	; 0x46cc <rprintf1RamRom>
	for(uint8_t ndx = 0; ndx < 4; ndx++){
		rprintf("%d ",frame.distance[ndx]);
     c82:	00 d0       	rcall	.+0      	; 0xc84 <print_frame+0x86>
     c84:	ed b7       	in	r30, 0x3d	; 61
     c86:	fe b7       	in	r31, 0x3e	; 62
     c88:	31 96       	adiw	r30, 0x01	; 1
     c8a:	ad b7       	in	r26, 0x3d	; 61
     c8c:	be b7       	in	r27, 0x3e	; 62
     c8e:	11 96       	adiw	r26, 0x01	; 1
     c90:	fc 92       	st	X, r15
     c92:	06 e3       	ldi	r16, 0x36	; 54
     c94:	11 e0       	ldi	r17, 0x01	; 1
     c96:	12 83       	std	Z+2, r17	; 0x02
     c98:	01 83       	std	Z+1, r16	; 0x01
     c9a:	8c 89       	ldd	r24, Y+20	; 0x14
     c9c:	9d 89       	ldd	r25, Y+21	; 0x15
     c9e:	94 83       	std	Z+4, r25	; 0x04
     ca0:	83 83       	std	Z+3, r24	; 0x03
     ca2:	0e 94 66 23 	call	0x46cc	; 0x46cc <rprintf1RamRom>
     ca6:	ed b7       	in	r30, 0x3d	; 61
     ca8:	fe b7       	in	r31, 0x3e	; 62
     caa:	31 96       	adiw	r30, 0x01	; 1
     cac:	ad b7       	in	r26, 0x3d	; 61
     cae:	be b7       	in	r27, 0x3e	; 62
     cb0:	11 96       	adiw	r26, 0x01	; 1
     cb2:	fc 92       	st	X, r15
     cb4:	12 83       	std	Z+2, r17	; 0x02
     cb6:	01 83       	std	Z+1, r16	; 0x01
     cb8:	8e 89       	ldd	r24, Y+22	; 0x16
     cba:	9f 89       	ldd	r25, Y+23	; 0x17
     cbc:	94 83       	std	Z+4, r25	; 0x04
     cbe:	83 83       	std	Z+3, r24	; 0x03
     cc0:	0e 94 66 23 	call	0x46cc	; 0x46cc <rprintf1RamRom>
     cc4:	ed b7       	in	r30, 0x3d	; 61
     cc6:	fe b7       	in	r31, 0x3e	; 62
     cc8:	31 96       	adiw	r30, 0x01	; 1
     cca:	ad b7       	in	r26, 0x3d	; 61
     ccc:	be b7       	in	r27, 0x3e	; 62
     cce:	11 96       	adiw	r26, 0x01	; 1
     cd0:	fc 92       	st	X, r15
     cd2:	12 83       	std	Z+2, r17	; 0x02
     cd4:	01 83       	std	Z+1, r16	; 0x01
     cd6:	88 8d       	ldd	r24, Y+24	; 0x18
     cd8:	99 8d       	ldd	r25, Y+25	; 0x19
     cda:	94 83       	std	Z+4, r25	; 0x04
     cdc:	83 83       	std	Z+3, r24	; 0x03
     cde:	0e 94 66 23 	call	0x46cc	; 0x46cc <rprintf1RamRom>
     ce2:	ed b7       	in	r30, 0x3d	; 61
     ce4:	fe b7       	in	r31, 0x3e	; 62
     ce6:	31 96       	adiw	r30, 0x01	; 1
     ce8:	ad b7       	in	r26, 0x3d	; 61
     cea:	be b7       	in	r27, 0x3e	; 62
     cec:	11 96       	adiw	r26, 0x01	; 1
     cee:	fc 92       	st	X, r15
     cf0:	12 83       	std	Z+2, r17	; 0x02
     cf2:	01 83       	std	Z+1, r16	; 0x01
     cf4:	8a 8d       	ldd	r24, Y+26	; 0x1a
     cf6:	9b 8d       	ldd	r25, Y+27	; 0x1b
     cf8:	94 83       	std	Z+4, r25	; 0x04
     cfa:	83 83       	std	Z+3, r24	; 0x03
     cfc:	0e 94 66 23 	call	0x46cc	; 0x46cc <rprintf1RamRom>
	}
	rprintfCRLF();
     d00:	0f 90       	pop	r0
     d02:	0f 90       	pop	r0
     d04:	0f 90       	pop	r0
     d06:	0f 90       	pop	r0
     d08:	0f 90       	pop	r0
     d0a:	0e 94 a6 21 	call	0x434c	; 0x434c <rprintfCRLF>
}
     d0e:	cf 91       	pop	r28
     d10:	df 91       	pop	r29
     d12:	1f 91       	pop	r17
     d14:	0f 91       	pop	r16
     d16:	ff 90       	pop	r15
     d18:	ef 90       	pop	r14
     d1a:	08 95       	ret

00000d1c <send_frame>:
	}
	return c;
}


void send_frame(char flag, int16_t data){
     d1c:	ff 92       	push	r15
     d1e:	0f 93       	push	r16
     d20:	1f 93       	push	r17
     d22:	cf 93       	push	r28
     d24:	df 93       	push	r29
     d26:	eb 01       	movw	r28, r22
	uint8_t r1 = 0;
	uint8_t r2 = 0;
	uint8_t r3 = 0;
	uint8_t r4 = 0;

	uart3SendByte(flag);
     d28:	0e 94 5b 1c 	call	0x38b6	; 0x38b6 <uart3SendByte>

	r1 = num2char(0x0F & (uint8_t)data);
     d2c:	3f e0       	ldi	r19, 0x0F	; 15
     d2e:	f3 2e       	mov	r15, r19
     d30:	fc 22       	and	r15, r28



char num2char(char c){
	
	if(c <10){
     d32:	89 e0       	ldi	r24, 0x09	; 9
     d34:	8f 15       	cp	r24, r15
     d36:	18 f0       	brcs	.+6      	; 0xd3e <send_frame+0x22>
		c += 48;
     d38:	90 e3       	ldi	r25, 0x30	; 48
     d3a:	f9 0e       	add	r15, r25
     d3c:	06 c0       	rjmp	.+12     	; 0xd4a <send_frame+0x2e>
	}
	else if((c >= 10) && (c <= 16)){
     d3e:	8f 2d       	mov	r24, r15
     d40:	8a 50       	subi	r24, 0x0A	; 10
     d42:	87 30       	cpi	r24, 0x07	; 7
     d44:	10 f4       	brcc	.+4      	; 0xd4a <send_frame+0x2e>
		c += 55;
     d46:	87 e3       	ldi	r24, 0x37	; 55
     d48:	f8 0e       	add	r15, r24
	uint8_t r4 = 0;

	uart3SendByte(flag);

	r1 = num2char(0x0F & (uint8_t)data);
	r2 = num2char(0x0F & ((uint8_t)(data >> 4)) );
     d4a:	ce 01       	movw	r24, r28
     d4c:	24 e0       	ldi	r18, 0x04	; 4
     d4e:	95 95       	asr	r25
     d50:	87 95       	ror	r24
     d52:	2a 95       	dec	r18
     d54:	e1 f7       	brne	.-8      	; 0xd4e <send_frame+0x32>
     d56:	08 2f       	mov	r16, r24
     d58:	0f 70       	andi	r16, 0x0F	; 15



char num2char(char c){
	
	if(c <10){
     d5a:	0a 30       	cpi	r16, 0x0A	; 10
     d5c:	10 f4       	brcc	.+4      	; 0xd62 <send_frame+0x46>
		c += 48;
     d5e:	00 5d       	subi	r16, 0xD0	; 208
     d60:	05 c0       	rjmp	.+10     	; 0xd6c <send_frame+0x50>
	}
	else if((c >= 10) && (c <= 16)){
     d62:	80 2f       	mov	r24, r16
     d64:	8a 50       	subi	r24, 0x0A	; 10
     d66:	87 30       	cpi	r24, 0x07	; 7
     d68:	08 f4       	brcc	.+2      	; 0xd6c <send_frame+0x50>
		c += 55;
     d6a:	09 5c       	subi	r16, 0xC9	; 201

	uart3SendByte(flag);

	r1 = num2char(0x0F & (uint8_t)data);
	r2 = num2char(0x0F & ((uint8_t)(data >> 4)) );
	r3 = num2char(0x0F & ((uint8_t)(data >> 8)) );
     d6c:	8d 2f       	mov	r24, r29
     d6e:	99 27       	eor	r25, r25
     d70:	87 fd       	sbrc	r24, 7
     d72:	9a 95       	dec	r25
     d74:	18 2f       	mov	r17, r24
     d76:	1f 70       	andi	r17, 0x0F	; 15



char num2char(char c){
	
	if(c <10){
     d78:	1a 30       	cpi	r17, 0x0A	; 10
     d7a:	10 f4       	brcc	.+4      	; 0xd80 <send_frame+0x64>
		c += 48;
     d7c:	10 5d       	subi	r17, 0xD0	; 208
     d7e:	05 c0       	rjmp	.+10     	; 0xd8a <send_frame+0x6e>
	}
	else if((c >= 10) && (c <= 16)){
     d80:	81 2f       	mov	r24, r17
     d82:	8a 50       	subi	r24, 0x0A	; 10
     d84:	87 30       	cpi	r24, 0x07	; 7
     d86:	08 f4       	brcc	.+2      	; 0xd8a <send_frame+0x6e>
		c += 55;
     d88:	19 5c       	subi	r17, 0xC9	; 201
	uart3SendByte(flag);

	r1 = num2char(0x0F & (uint8_t)data);
	r2 = num2char(0x0F & ((uint8_t)(data >> 4)) );
	r3 = num2char(0x0F & ((uint8_t)(data >> 8)) );
	r4 = num2char(0x0F & ((uint8_t)(data >> 12)) );
     d8a:	c0 e1       	ldi	r28, 0x10	; 16
     d8c:	dc 02       	muls	r29, r28
     d8e:	c1 2d       	mov	r28, r1
     d90:	dd 0b       	sbc	r29, r29
     d92:	11 24       	eor	r1, r1
     d94:	ce 01       	movw	r24, r28
     d96:	8f 70       	andi	r24, 0x0F	; 15
     d98:	68 2f       	mov	r22, r24



char num2char(char c){
	
	if(c <10){
     d9a:	8a 30       	cpi	r24, 0x0A	; 10
     d9c:	10 f4       	brcc	.+4      	; 0xda2 <send_frame+0x86>
		c += 48;
     d9e:	60 5d       	subi	r22, 0xD0	; 208
     da0:	04 c0       	rjmp	.+8      	; 0xdaa <send_frame+0x8e>
	}
	else if((c >= 10) && (c <= 16)){
     da2:	8a 50       	subi	r24, 0x0A	; 10
     da4:	87 30       	cpi	r24, 0x07	; 7
     da6:	08 f4       	brcc	.+2      	; 0xdaa <send_frame+0x8e>
		c += 55;
     da8:	69 5c       	subi	r22, 0xC9	; 201
	r1 = num2char(0x0F & (uint8_t)data);
	r2 = num2char(0x0F & ((uint8_t)(data >> 4)) );
	r3 = num2char(0x0F & ((uint8_t)(data >> 8)) );
	r4 = num2char(0x0F & ((uint8_t)(data >> 12)) );

	uart3SendByte(r4);
     daa:	86 2f       	mov	r24, r22
     dac:	0e 94 5b 1c 	call	0x38b6	; 0x38b6 <uart3SendByte>
	uart3SendByte(r3);
     db0:	81 2f       	mov	r24, r17
     db2:	0e 94 5b 1c 	call	0x38b6	; 0x38b6 <uart3SendByte>
	uart3SendByte(r2);
     db6:	80 2f       	mov	r24, r16
     db8:	0e 94 5b 1c 	call	0x38b6	; 0x38b6 <uart3SendByte>
	uart3SendByte(r1);
     dbc:	8f 2d       	mov	r24, r15
     dbe:	0e 94 5b 1c 	call	0x38b6	; 0x38b6 <uart3SendByte>
	uart3SendByte('\n'); //line feed
     dc2:	8a e0       	ldi	r24, 0x0A	; 10
     dc4:	0e 94 5b 1c 	call	0x38b6	; 0x38b6 <uart3SendByte>
}
     dc8:	df 91       	pop	r29
     dca:	cf 91       	pop	r28
     dcc:	1f 91       	pop	r17
     dce:	0f 91       	pop	r16
     dd0:	ff 90       	pop	r15
     dd2:	08 95       	ret

00000dd4 <prvSetupHardware>:
    
    return error_checker(chk_data, frame->checksum);
}  


void prvSetupHardware(){
     dd4:	0f 93       	push	r16
     dd6:	1f 93       	push	r17
     dd8:	cf 93       	push	r28
     dda:	df 93       	push	r29
	delay_cycles(65535);
	delay_cycles(65535);
	
	

	uartInit();  // initialize the UART (serial port)
     ddc:	0e 94 fe 1f 	call	0x3ffc	; 0x3ffc <uartInit>
    uartSetBaudRate(0, 38400); // set UARTE speed, for Bluetooth
     de0:	80 e0       	ldi	r24, 0x00	; 0
     de2:	40 e0       	ldi	r20, 0x00	; 0
     de4:	56 e9       	ldi	r21, 0x96	; 150
     de6:	60 e0       	ldi	r22, 0x00	; 0
     de8:	70 e0       	ldi	r23, 0x00	; 0
     dea:	0e 94 d8 1b 	call	0x37b0	; 0x37b0 <uartSetBaudRate>
    uartSetBaudRate(1, 115200); // set UARTD speed, for USB connection, up to 500k, try 115200 if it doesn't work
     dee:	81 e0       	ldi	r24, 0x01	; 1
     df0:	40 e0       	ldi	r20, 0x00	; 0
     df2:	52 ec       	ldi	r21, 0xC2	; 194
     df4:	61 e0       	ldi	r22, 0x01	; 1
     df6:	70 e0       	ldi	r23, 0x00	; 0
     df8:	0e 94 d8 1b 	call	0x37b0	; 0x37b0 <uartSetBaudRate>
    uartSetBaudRate(2, 38400); // set UARTH speed
     dfc:	82 e0       	ldi	r24, 0x02	; 2
     dfe:	40 e0       	ldi	r20, 0x00	; 0
     e00:	56 e9       	ldi	r21, 0x96	; 150
     e02:	60 e0       	ldi	r22, 0x00	; 0
     e04:	70 e0       	ldi	r23, 0x00	; 0
     e06:	0e 94 d8 1b 	call	0x37b0	; 0x37b0 <uartSetBaudRate>
    uartSetBaudRate(3, 115200); // set UARTJ speed, for Blackfin
     e0a:	83 e0       	ldi	r24, 0x03	; 3
     e0c:	40 e0       	ldi	r20, 0x00	; 0
     e0e:	52 ec       	ldi	r21, 0xC2	; 194
     e10:	61 e0       	ldi	r22, 0x01	; 1
     e12:	70 e0       	ldi	r23, 0x00	; 0
     e14:	0e 94 d8 1b 	call	0x37b0	; 0x37b0 <uartSetBaudRate>
	//G=Ground, T=Tx (connect to external Rx), R=Rx (connect to external Tx)

	rprintfInit(uart1SendByte);// initialize rprintf system and configure uart1 (USB) for rprintf
     e18:	81 e5       	ldi	r24, 0x51	; 81
     e1a:	9c e1       	ldi	r25, 0x1C	; 28
     e1c:	0e 94 42 21 	call	0x4284	; 0x4284 <rprintfInit>

	configure_ports(); // configure which ports are analog, digital, etc.
     e20:	0e 94 70 03 	call	0x6e0	; 0x6e0 <configure_ports>
	
	//UART ISR *** UART ISR ***
	
//	uartSetRxHandler(2, &fwdSer_L);
//	uartSetRxHandler(0, &fwdSer_R);
	uartSetRxHandler(3, &LDSRcv);
     e24:	83 e0       	ldi	r24, 0x03	; 3
     e26:	6f e7       	ldi	r22, 0x7F	; 127
     e28:	75 e0       	ldi	r23, 0x05	; 5
     e2a:	0e 94 cd 1b 	call	0x379a	; 0x379a <uartSetRxHandler>
//***************STATUS LED**************
//tank test
void LED_off(void)
	{PORT_ON(PORTB,6);}
void LED_on(void)
	{PORT_OFF(PORTB,6);}
     e2e:	2e 98       	cbi	0x05, 6	; 5

	//UART ISR *** UART ISR ***

	LED_on();

	rprintf("\r\nSystem Warmed Up");
     e30:	00 d0       	rcall	.+0      	; 0xe32 <prvSetupHardware+0x5e>
     e32:	0f 92       	push	r0
     e34:	81 e0       	ldi	r24, 0x01	; 1
     e36:	ed b7       	in	r30, 0x3d	; 61
     e38:	fe b7       	in	r31, 0x3e	; 62
     e3a:	81 83       	std	Z+1, r24	; 0x01
     e3c:	8b e7       	ldi	r24, 0x7B	; 123
     e3e:	91 e0       	ldi	r25, 0x01	; 1
     e40:	93 83       	std	Z+3, r25	; 0x03
     e42:	82 83       	std	Z+2, r24	; 0x02
     e44:	0e 94 66 23 	call	0x46cc	; 0x46cc <rprintf1RamRom>

	// initialize the timer system
 	init_timer0(TIMER_CLK_1024);
     e48:	0f 90       	pop	r0
     e4a:	0f 90       	pop	r0
     e4c:	0f 90       	pop	r0
     e4e:	85 e0       	ldi	r24, 0x05	; 5
     e50:	0e 94 e4 15 	call	0x2bc8	; 0x2bc8 <init_timer0>
 	init_timer1(TIMER_CLK_64); // Timer 1 is initialized by FreeRTOS
     e54:	83 e0       	ldi	r24, 0x03	; 3
     e56:	0e 94 f2 15 	call	0x2be4	; 0x2be4 <init_timer1>
 	//init_timer2(TIMER2_CLK_64);
	init_timer2(TIMER2_CLK_1024);
     e5a:	87 e0       	ldi	r24, 0x07	; 7
     e5c:	0e 94 04 16 	call	0x2c08	; 0x2c08 <init_timer2>
 	init_timer3(TIMER_CLK_64);
     e60:	83 e0       	ldi	r24, 0x03	; 3
     e62:	0e 94 14 16 	call	0x2c28	; 0x2c28 <init_timer3>
 	init_timer4(TIMER_CLK_64);
     e66:	83 e0       	ldi	r24, 0x03	; 3
     e68:	0e 94 26 16 	call	0x2c4c	; 0x2c4c <init_timer4>
 	init_timer5(TIMER_CLK_64);
     e6c:	83 e0       	ldi	r24, 0x03	; 3
     e6e:	0e 94 38 16 	call	0x2c70	; 0x2c70 <init_timer5>

	a2dInit(); // initialize analog to digital converter (ADC)
     e72:	0e 94 b7 20 	call	0x416e	; 0x416e <a2dInit>
	a2dSetPrescaler(ADC_PRESCALE_DIV32); // configure ADC scaling
     e76:	85 e0       	ldi	r24, 0x05	; 5
     e78:	0e 94 dc 20 	call	0x41b8	; 0x41b8 <a2dSetPrescaler>
	a2dSetReference(ADC_REFERENCE_AVCC); // configure ADC reference voltage
     e7c:	81 e0       	ldi	r24, 0x01	; 1
     e7e:	0e 94 e3 20 	call	0x41c6	; 0x41c6 <a2dSetReference>
     e82:	10 e0       	ldi	r17, 0x00	; 0
	//let system stabelize for X time
	for(i=0;i<16;i++)
		{
		j=a2dConvert8bit(i);//read each ADC once to get it working accurately
		delay_cycles(5000); //keep LED on long enough to see Axon reseting
		rprintf(".");
     e84:	01 e0       	ldi	r16, 0x01	; 1
     e86:	c9 e7       	ldi	r28, 0x79	; 121
     e88:	d1 e0       	ldi	r29, 0x01	; 1
	a2dSetReference(ADC_REFERENCE_AVCC); // configure ADC reference voltage

	//let system stabelize for X time
	for(i=0;i<16;i++)
		{
		j=a2dConvert8bit(i);//read each ADC once to get it working accurately
     e8a:	81 2f       	mov	r24, r17
     e8c:	0e 94 2c 21 	call	0x4258	; 0x4258 <a2dConvert8bit>
		delay_cycles(5000); //keep LED on long enough to see Axon reseting
		rprintf(".");
     e90:	00 d0       	rcall	.+0      	; 0xe92 <prvSetupHardware+0xbe>
     e92:	0f 92       	push	r0
     e94:	ed b7       	in	r30, 0x3d	; 61
     e96:	fe b7       	in	r31, 0x3e	; 62
     e98:	01 83       	std	Z+1, r16	; 0x01
     e9a:	d3 83       	std	Z+3, r29	; 0x03
     e9c:	c2 83       	std	Z+2, r28	; 0x02
     e9e:	0e 94 66 23 	call	0x46cc	; 0x46cc <rprintf1RamRom>
     ea2:	1f 5f       	subi	r17, 0xFF	; 255
	a2dInit(); // initialize analog to digital converter (ADC)
	a2dSetPrescaler(ADC_PRESCALE_DIV32); // configure ADC scaling
	a2dSetReference(ADC_REFERENCE_AVCC); // configure ADC reference voltage

	//let system stabelize for X time
	for(i=0;i<16;i++)
     ea4:	0f 90       	pop	r0
     ea6:	0f 90       	pop	r0
     ea8:	0f 90       	pop	r0
     eaa:	10 31       	cpi	r17, 0x10	; 16
     eac:	71 f7       	brne	.-36     	; 0xe8a <prvSetupHardware+0xb6>


//***************STATUS LED**************
//tank test
void LED_off(void)
	{PORT_ON(PORTB,6);}
     eae:	2e 9a       	sbi	0x05, 6	; 5
		rprintf(".");
		}

	LED_off();

	rprintf("Initialization Complete \r\n");
     eb0:	00 d0       	rcall	.+0      	; 0xeb2 <prvSetupHardware+0xde>
     eb2:	0f 92       	push	r0
     eb4:	ed b7       	in	r30, 0x3d	; 61
     eb6:	fe b7       	in	r31, 0x3e	; 62
     eb8:	01 83       	std	Z+1, r16	; 0x01
     eba:	8e e5       	ldi	r24, 0x5E	; 94
     ebc:	91 e0       	ldi	r25, 0x01	; 1
     ebe:	93 83       	std	Z+3, r25	; 0x03
     ec0:	82 83       	std	Z+2, r24	; 0x02
     ec2:	0e 94 66 23 	call	0x46cc	; 0x46cc <rprintf1RamRom>

	//reset all timers to zero
	reset_timer0();
     ec6:	0f 90       	pop	r0
     ec8:	0f 90       	pop	r0
     eca:	0f 90       	pop	r0
     ecc:	0e 94 9a 15 	call	0x2b34	; 0x2b34 <reset_timer0>
	reset_timer1();
     ed0:	0e 94 a4 15 	call	0x2b48	; 0x2b48 <reset_timer1>
	reset_timer2();
     ed4:	0e 94 b1 15 	call	0x2b62	; 0x2b62 <reset_timer2>
	reset_timer3();
     ed8:	0e 94 bc 15 	call	0x2b78	; 0x2b78 <reset_timer3>
	reset_timer4();
     edc:	0e 94 c9 15 	call	0x2b92	; 0x2b92 <reset_timer4>
	reset_timer5();
     ee0:	0e 94 d6 15 	call	0x2bac	; 0x2bac <reset_timer5>



	/********PWM Setup***********/
	prvPWMSetup();
     ee4:	0e 94 40 04 	call	0x880	; 0x880 <prvPWMSetup>

}
     ee8:	df 91       	pop	r29
     eea:	cf 91       	pop	r28
     eec:	1f 91       	pop	r17
     eee:	0f 91       	pop	r16
     ef0:	08 95       	ret

00000ef2 <read_LDS>:
		}
	}

}

uint8_t read_LDS(){
     ef2:	04 c0       	rjmp	.+8      	; 0xefc <read_LDS+0xa>
	while(lds_buffer_read_ndx == lds_buffer_write_ndx){ delay_us(10); };
     ef4:	8a e0       	ldi	r24, 0x0A	; 10
     ef6:	90 e0       	ldi	r25, 0x00	; 0
     ef8:	0e 94 e3 15 	call	0x2bc6	; 0x2bc6 <delay_us>
     efc:	e0 91 9a 02 	lds	r30, 0x029A
     f00:	f0 91 9b 02 	lds	r31, 0x029B
     f04:	80 91 98 02 	lds	r24, 0x0298
     f08:	90 91 99 02 	lds	r25, 0x0299
     f0c:	e8 17       	cp	r30, r24
     f0e:	f9 07       	cpc	r31, r25
     f10:	89 f3       	breq	.-30     	; 0xef4 <read_LDS+0x2>
	uint8_t data = *lds_buffer_read_ndx;
     f12:	21 91       	ld	r18, Z+
	lds_buffer_read_ndx++;
     f14:	f0 93 9b 02 	sts	0x029B, r31
     f18:	e0 93 9a 02 	sts	0x029A, r30
	if(lds_buffer_read_ndx >= (lds_buffer + BUFFER_SIZE)){ 
     f1c:	ee 5b       	subi	r30, 0xBE	; 190
     f1e:	f2 41       	sbci	r31, 0x12	; 18
     f20:	30 f0       	brcs	.+12     	; 0xf2e <read_LDS+0x3c>
		lds_buffer_read_ndx = lds_buffer;
     f22:	8e eb       	ldi	r24, 0xBE	; 190
     f24:	91 e1       	ldi	r25, 0x11	; 17
     f26:	90 93 9b 02 	sts	0x029B, r25
     f2a:	80 93 9a 02 	sts	0x029A, r24
	}
	return data;
}
     f2e:	82 2f       	mov	r24, r18
     f30:	08 95       	ret

00000f32 <parse_frame>:
    uint16_t chk16 = (chk32 & 0x7FFF) + (chk32 >> 15);
    chk16 = chk16 & 0x7FFF;
    return (chk16 == checksum);
  }

uint8_t parse_frame(LDS_FRAME *frame){
     f32:	2f 92       	push	r2
     f34:	3f 92       	push	r3
     f36:	4f 92       	push	r4
     f38:	5f 92       	push	r5
     f3a:	6f 92       	push	r6
     f3c:	7f 92       	push	r7
     f3e:	8f 92       	push	r8
     f40:	9f 92       	push	r9
     f42:	af 92       	push	r10
     f44:	bf 92       	push	r11
     f46:	cf 92       	push	r12
     f48:	df 92       	push	r13
     f4a:	ef 92       	push	r14
     f4c:	ff 92       	push	r15
     f4e:	0f 93       	push	r16
     f50:	1f 93       	push	r17
     f52:	df 93       	push	r29
     f54:	cf 93       	push	r28
     f56:	cd b7       	in	r28, 0x3d	; 61
     f58:	de b7       	in	r29, 0x3e	; 62
     f5a:	6a 97       	sbiw	r28, 0x1a	; 26
     f5c:	0f b6       	in	r0, 0x3f	; 63
     f5e:	f8 94       	cli
     f60:	de bf       	out	0x3e, r29	; 62
     f62:	0f be       	out	0x3f, r0	; 63
     f64:	cd bf       	out	0x3d, r28	; 61
     f66:	2c 01       	movw	r4, r24
    // Array for use by the error checker
    uint16_t chk_data[10];

    // Read start byte
    uint8_t start_byte = read_LDS();
     f68:	0e 94 79 07 	call	0xef2	; 0xef2 <read_LDS>
    // If the byte read in is not the start byte (0xFA), then this is not the beginning of a frame
    if(start_byte != 0xFA) return FALSE; 
     f6c:	8a 3f       	cpi	r24, 0xFA	; 250
     f6e:	09 f0       	breq	.+2      	; 0xf72 <parse_frame+0x40>
     f70:	ac c0       	rjmp	.+344    	; 0x10ca <parse_frame+0x198>

    // Read index
	frame->index = read_LDS();
     f72:	0e 94 79 07 	call	0xef2	; 0xef2 <read_LDS>
     f76:	28 2f       	mov	r18, r24
     f78:	f2 01       	movw	r30, r4
     f7a:	80 83       	st	Z, r24
    // If the byte proceeding the start byte does not look like an index, then is is not the beginning of a frame
    if((frame->index < 0xA0)||(frame->index > 0xF9)) return FALSE;
     f7c:	80 5a       	subi	r24, 0xA0	; 160
     f7e:	8a 35       	cpi	r24, 0x5A	; 90
     f80:	08 f0       	brcs	.+2      	; 0xf84 <parse_frame+0x52>
     f82:	a3 c0       	rjmp	.+326    	; 0x10ca <parse_frame+0x198>

    // Add these bytes for the error checker
    chk_data[0] = (frame->index << 8) + start_byte;
     f84:	92 2f       	mov	r25, r18
     f86:	80 e0       	ldi	r24, 0x00	; 0
     f88:	86 50       	subi	r24, 0x06	; 6
     f8a:	9f 4f       	sbci	r25, 0xFF	; 255
     f8c:	9e 83       	std	Y+6, r25	; 0x06
     f8e:	8d 83       	std	Y+5, r24	; 0x05
    //   MSB                                                               LSB
    //   15  14  13  12  11  10  9   8   7   6    5    4    3    2    1    0
    //   512 256 128 64  32  16  8   4   2   1 .  1/2  1/4  1/8  1/16 1/32 1/64
    //
	
	frame->motor_speed = ((uint16_t)read_LDS()) + ((uint16_t)read_LDS()<<8);
     f90:	0e 94 79 07 	call	0xef2	; 0xef2 <read_LDS>
     f94:	18 2f       	mov	r17, r24
     f96:	0e 94 79 07 	call	0xef2	; 0xef2 <read_LDS>
     f9a:	38 2f       	mov	r19, r24
     f9c:	20 e0       	ldi	r18, 0x00	; 0
     f9e:	21 0f       	add	r18, r17
     fa0:	31 1d       	adc	r19, r1
     fa2:	f2 01       	movw	r30, r4
     fa4:	32 83       	std	Z+2, r19	; 0x02
     fa6:	21 83       	std	Z+1, r18	; 0x01
    // Add these bytes for the error checker
    chk_data[1] = frame->motor_speed;
     fa8:	38 87       	std	Y+8, r19	; 0x08
     faa:	2f 83       	std	Y+7, r18	; 0x07
     fac:	32 01       	movw	r6, r4
     fae:	09 e0       	ldi	r16, 0x09	; 9
     fb0:	80 2e       	mov	r8, r16
     fb2:	91 2c       	mov	r9, r1
     fb4:	8c 0e       	add	r8, r28
     fb6:	9d 1e       	adc	r9, r29
     fb8:	62 01       	movw	r12, r4
				
    // Read distances, intensities, and flags
    for(uint8_t itr = 0; itr < 4; itr++) {
      // Read in the four distance and intensity bytes
      uint8_t di_bytes[4];
	  for(uint8_t d_ndx = 0; d_ndx < 4; d_ndx++){
     fba:	15 e0       	ldi	r17, 0x05	; 5
     fbc:	21 2e       	mov	r2, r17
     fbe:	31 2c       	mov	r3, r1
     fc0:	2c 0e       	add	r2, r28
     fc2:	3d 1e       	adc	r3, r29
    // Add these bytes for the error checker
    chk_data[1] = frame->motor_speed;
	
				
    // Read distances, intensities, and flags
    for(uint8_t itr = 0; itr < 4; itr++) {
     fc4:	ae 01       	movw	r20, r28
     fc6:	47 5e       	subi	r20, 0xE7	; 231
     fc8:	5f 4f       	sbci	r21, 0xFF	; 255
     fca:	5a 8f       	std	Y+26, r21	; 0x1a
     fcc:	49 8f       	std	Y+25, r20	; 0x19
     fce:	46 c0       	rjmp	.+140    	; 0x105c <parse_frame+0x12a>
      // Read in the four distance and intensity bytes
      uint8_t di_bytes[4];
	  for(uint8_t d_ndx = 0; d_ndx < 4; d_ndx++){
	  	di_bytes[d_ndx] = read_LDS();
     fd0:	0e 94 79 07 	call	0xef2	; 0xef2 <read_LDS>
     fd4:	f8 01       	movw	r30, r16
     fd6:	81 93       	st	Z+, r24
     fd8:	8f 01       	movw	r16, r30
				
    // Read distances, intensities, and flags
    for(uint8_t itr = 0; itr < 4; itr++) {
      // Read in the four distance and intensity bytes
      uint8_t di_bytes[4];
	  for(uint8_t d_ndx = 0; d_ndx < 4; d_ndx++){
     fda:	e2 15       	cp	r30, r2
     fdc:	f3 05       	cpc	r31, r3
     fde:	c1 f7       	brne	.-16     	; 0xfd0 <parse_frame+0x9e>
	  	di_bytes[d_ndx] = read_LDS();
      }
      // The invalid and strength flags are the MSB and adjacent bit of the second (indexwise) distance byte
      frame->invalid[itr] = (uint8_t)(di_bytes[1] & 0x80);
     fe0:	4a 81       	ldd	r20, Y+2	; 0x02
     fe2:	94 2f       	mov	r25, r20
     fe4:	90 78       	andi	r25, 0x80	; 128
     fe6:	f3 01       	movw	r30, r6
     fe8:	93 83       	std	Z+3, r25	; 0x03
      frame->strength_warning[itr] = (uint8_t)(di_bytes[1] & 0x40);
     fea:	84 2f       	mov	r24, r20
     fec:	80 74       	andi	r24, 0x40	; 64
     fee:	87 83       	std	Z+7, r24	; 0x07

      // Distance and intensity bytes are read in little endian, and therefore need to be switched and concatenated
      // The second distance byte (indexwise) is masked to eliminate the invalid and strength flags from the measurement
      if(frame->invalid[itr]){ // If this measurement is invalid, set it to zero
     ff0:	99 23       	and	r25, r25
     ff2:	21 f0       	breq	.+8      	; 0xffc <parse_frame+0xca>
		frame->distance[itr]  = 0;
     ff4:	f6 01       	movw	r30, r12
     ff6:	14 86       	std	Z+12, r1	; 0x0c
     ff8:	13 86       	std	Z+11, r1	; 0x0b
     ffa:	0c c0       	rjmp	.+24     	; 0x1014 <parse_frame+0xe2>
      }
      else{
		frame->distance[itr]  = ((di_bytes[1] & 0x3F) << 8) + di_bytes[0];
     ffc:	84 2f       	mov	r24, r20
     ffe:	90 e0       	ldi	r25, 0x00	; 0
    1000:	8f 73       	andi	r24, 0x3F	; 63
    1002:	90 70       	andi	r25, 0x00	; 0
    1004:	98 2f       	mov	r25, r24
    1006:	88 27       	eor	r24, r24
    1008:	29 81       	ldd	r18, Y+1	; 0x01
    100a:	82 0f       	add	r24, r18
    100c:	91 1d       	adc	r25, r1
    100e:	f6 01       	movw	r30, r12
    1010:	94 87       	std	Z+12, r25	; 0x0c
    1012:	83 87       	std	Z+11, r24	; 0x0b
      }

      frame->intensity[itr] = (di_bytes[3] << 8) + di_bytes[2];
    1014:	bc 80       	ldd	r11, Y+4	; 0x04
    1016:	aa 24       	eor	r10, r10
    1018:	8b 81       	ldd	r24, Y+3	; 0x03
    101a:	95 01       	movw	r18, r10
    101c:	28 0f       	add	r18, r24
    101e:	31 1d       	adc	r19, r1
    1020:	f6 01       	movw	r30, r12
    1022:	34 8b       	std	Z+20, r19	; 0x14
    1024:	23 8b       	std	Z+19, r18	; 0x13
      
      // Add these bytes for the error checker
      chk_data[2*itr + 2] = (di_bytes[1] << 8) + di_bytes[0];
    1026:	f4 2e       	mov	r15, r20
    1028:	ee 24       	eor	r14, r14
    102a:	89 81       	ldd	r24, Y+1	; 0x01
    102c:	a7 01       	movw	r20, r14
    102e:	48 0f       	add	r20, r24
    1030:	51 1d       	adc	r21, r1
    1032:	f4 01       	movw	r30, r8
    1034:	51 83       	std	Z+1, r21	; 0x01
    1036:	40 83       	st	Z, r20
      chk_data[2*itr + 3] = (di_bytes[3] << 8) + di_bytes[2];
    1038:	33 83       	std	Z+3, r19	; 0x03
    103a:	22 83       	std	Z+2, r18	; 0x02
    103c:	42 e0       	ldi	r20, 0x02	; 2
    103e:	50 e0       	ldi	r21, 0x00	; 0
    1040:	c4 0e       	add	r12, r20
    1042:	d5 1e       	adc	r13, r21
    1044:	84 e0       	ldi	r24, 0x04	; 4
    1046:	90 e0       	ldi	r25, 0x00	; 0
    1048:	88 0e       	add	r8, r24
    104a:	99 1e       	adc	r9, r25
    104c:	08 94       	sec
    104e:	61 1c       	adc	r6, r1
    1050:	71 1c       	adc	r7, r1
    // Add these bytes for the error checker
    chk_data[1] = frame->motor_speed;
	
				
    // Read distances, intensities, and flags
    for(uint8_t itr = 0; itr < 4; itr++) {
    1052:	e9 8d       	ldd	r30, Y+25	; 0x19
    1054:	fa 8d       	ldd	r31, Y+26	; 0x1a
    1056:	8e 16       	cp	r8, r30
    1058:	9f 06       	cpc	r9, r31
    105a:	21 f0       	breq	.+8      	; 0x1064 <parse_frame+0x132>
    105c:	8e 01       	movw	r16, r28
    105e:	0f 5f       	subi	r16, 0xFF	; 255
    1060:	1f 4f       	sbci	r17, 0xFF	; 255
    1062:	b6 cf       	rjmp	.-148    	; 0xfd0 <parse_frame+0x9e>
      chk_data[2*itr + 3] = (di_bytes[3] << 8) + di_bytes[2];
    }

    // Read checksum
    // Checksum is given in little endian, but because it is read into a uint16_t, it is ordered correctly
	frame->checksum = (((uint16_t)read_LDS())) + (((uint16_t)read_LDS())<<8);
    1064:	0e 94 79 07 	call	0xef2	; 0xef2 <read_LDS>
    1068:	18 2f       	mov	r17, r24
    106a:	0e 94 79 07 	call	0xef2	; 0xef2 <read_LDS>
    106e:	38 2f       	mov	r19, r24
    1070:	20 e0       	ldi	r18, 0x00	; 0
    1072:	b9 01       	movw	r22, r18
    1074:	61 0f       	add	r22, r17
    1076:	71 1d       	adc	r23, r1
    1078:	f2 01       	movw	r30, r4
    107a:	74 8f       	std	Z+28, r23	; 0x1c
    107c:	63 8f       	std	Z+27, r22	; 0x1b
    107e:	f1 01       	movw	r30, r2
    1080:	20 e0       	ldi	r18, 0x00	; 0
    1082:	30 e0       	ldi	r19, 0x00	; 0
    1084:	40 e0       	ldi	r20, 0x00	; 0
    1086:	50 e0       	ldi	r21, 0x00	; 0
}

uint8_t error_checker(const uint16_t chk_data[], uint16_t checksum){
    uint32_t chk32 = 0;
    for(uint8_t ndx = 0; ndx < 10; ndx++){
      chk32 = (chk32 << 1) + chk_data[ndx];
    1088:	22 0f       	add	r18, r18
    108a:	33 1f       	adc	r19, r19
    108c:	44 1f       	adc	r20, r20
    108e:	55 1f       	adc	r21, r21
    1090:	81 91       	ld	r24, Z+
    1092:	91 91       	ld	r25, Z+
    1094:	a0 e0       	ldi	r26, 0x00	; 0
    1096:	b0 e0       	ldi	r27, 0x00	; 0
    1098:	28 0f       	add	r18, r24
    109a:	39 1f       	adc	r19, r25
    109c:	4a 1f       	adc	r20, r26
    109e:	5b 1f       	adc	r21, r27
	return data;
}

uint8_t error_checker(const uint16_t chk_data[], uint16_t checksum){
    uint32_t chk32 = 0;
    for(uint8_t ndx = 0; ndx < 10; ndx++){
    10a0:	e8 15       	cp	r30, r8
    10a2:	f9 05       	cpc	r31, r9
    10a4:	89 f7       	brne	.-30     	; 0x1088 <parse_frame+0x156>
      chk32 = (chk32 << 1) + chk_data[ndx];
    }
    uint16_t chk16 = (chk32 & 0x7FFF) + (chk32 >> 15);
    10a6:	c9 01       	movw	r24, r18
    10a8:	9f 77       	andi	r25, 0x7F	; 127
    10aa:	ef e0       	ldi	r30, 0x0F	; 15
    10ac:	56 95       	lsr	r21
    10ae:	47 95       	ror	r20
    10b0:	37 95       	ror	r19
    10b2:	27 95       	ror	r18
    10b4:	ea 95       	dec	r30
    10b6:	d1 f7       	brne	.-12     	; 0x10ac <parse_frame+0x17a>
    10b8:	82 0f       	add	r24, r18
    10ba:	93 1f       	adc	r25, r19
    chk16 = chk16 & 0x7FFF;
    return (chk16 == checksum);
    10bc:	20 e0       	ldi	r18, 0x00	; 0
    10be:	9f 77       	andi	r25, 0x7F	; 127
    10c0:	86 17       	cp	r24, r22
    10c2:	97 07       	cpc	r25, r23
    10c4:	19 f4       	brne	.+6      	; 0x10cc <parse_frame+0x19a>
    10c6:	21 e0       	ldi	r18, 0x01	; 1
    10c8:	01 c0       	rjmp	.+2      	; 0x10cc <parse_frame+0x19a>

    // Read checksum
    // Checksum is given in little endian, but because it is read into a uint16_t, it is ordered correctly
	frame->checksum = (((uint16_t)read_LDS())) + (((uint16_t)read_LDS())<<8);
    
    return error_checker(chk_data, frame->checksum);
    10ca:	20 e0       	ldi	r18, 0x00	; 0
}  
    10cc:	82 2f       	mov	r24, r18
    10ce:	6a 96       	adiw	r28, 0x1a	; 26
    10d0:	0f b6       	in	r0, 0x3f	; 63
    10d2:	f8 94       	cli
    10d4:	de bf       	out	0x3e, r29	; 62
    10d6:	0f be       	out	0x3f, r0	; 63
    10d8:	cd bf       	out	0x3d, r28	; 61
    10da:	cf 91       	pop	r28
    10dc:	df 91       	pop	r29
    10de:	1f 91       	pop	r17
    10e0:	0f 91       	pop	r16
    10e2:	ff 90       	pop	r15
    10e4:	ef 90       	pop	r14
    10e6:	df 90       	pop	r13
    10e8:	cf 90       	pop	r12
    10ea:	bf 90       	pop	r11
    10ec:	af 90       	pop	r10
    10ee:	9f 90       	pop	r9
    10f0:	8f 90       	pop	r8
    10f2:	7f 90       	pop	r7
    10f4:	6f 90       	pop	r6
    10f6:	5f 90       	pop	r5
    10f8:	4f 90       	pop	r4
    10fa:	3f 90       	pop	r3
    10fc:	2f 90       	pop	r2
    10fe:	08 95       	ret

00001100 <grab_frames>:
		rprintf("%d ",frame.distance[ndx]);
	}
	rprintfCRLF();
}

void grab_frames(const LDS_FRAME *frame, LDS_FRAME ldsf[]){
    1100:	af 92       	push	r10
    1102:	bf 92       	push	r11
    1104:	cf 92       	push	r12
    1106:	df 92       	push	r13
    1108:	ef 92       	push	r14
    110a:	ff 92       	push	r15
    110c:	1f 93       	push	r17
    110e:	df 93       	push	r29
    1110:	cf 93       	push	r28
    1112:	cd b7       	in	r28, 0x3d	; 61
    1114:	de b7       	in	r29, 0x3e	; 62
    1116:	6d 97       	sbiw	r28, 0x1d	; 29
    1118:	0f b6       	in	r0, 0x3f	; 63
    111a:	f8 94       	cli
    111c:	de bf       	out	0x3e, r29	; 62
    111e:	0f be       	out	0x3f, r0	; 63
    1120:	cd bf       	out	0x3d, r28	; 61
    1122:	7b 01       	movw	r14, r22
	LDS_FRAME t_frame;
	uint8_t f_ndx = 1;
	ldsf[0] = *frame;
    1124:	db 01       	movw	r26, r22
    1126:	fc 01       	movw	r30, r24
    1128:	8d e1       	ldi	r24, 0x1D	; 29
    112a:	01 90       	ld	r0, Z+
    112c:	0d 92       	st	X+, r0
    112e:	81 50       	subi	r24, 0x01	; 1
    1130:	e1 f7       	brne	.-8      	; 0x112a <grab_frames+0x2a>
    1132:	11 e0       	ldi	r17, 0x01	; 1

	while(f_ndx < 90){
		if(parse_frame(&t_frame)){
    1134:	6e 01       	movw	r12, r28
    1136:	08 94       	sec
    1138:	c1 1c       	adc	r12, r1
    113a:	d1 1c       	adc	r13, r1
			ldsf[f_ndx] = t_frame;
    113c:	8d e1       	ldi	r24, 0x1D	; 29
    113e:	a8 2e       	mov	r10, r24
    1140:	b1 2c       	mov	r11, r1
	LDS_FRAME t_frame;
	uint8_t f_ndx = 1;
	ldsf[0] = *frame;

	while(f_ndx < 90){
		if(parse_frame(&t_frame)){
    1142:	c6 01       	movw	r24, r12
    1144:	0e 94 99 07 	call	0xf32	; 0xf32 <parse_frame>
    1148:	88 23       	and	r24, r24
    114a:	d9 f3       	breq	.-10     	; 0x1142 <grab_frames+0x42>
			ldsf[f_ndx] = t_frame;
    114c:	81 2f       	mov	r24, r17
    114e:	90 e0       	ldi	r25, 0x00	; 0
    1150:	8a 9d       	mul	r24, r10
    1152:	f0 01       	movw	r30, r0
    1154:	8b 9d       	mul	r24, r11
    1156:	f0 0d       	add	r31, r0
    1158:	9a 9d       	mul	r25, r10
    115a:	f0 0d       	add	r31, r0
    115c:	11 24       	eor	r1, r1
    115e:	ee 0d       	add	r30, r14
    1160:	ff 1d       	adc	r31, r15
    1162:	d6 01       	movw	r26, r12
    1164:	8d e1       	ldi	r24, 0x1D	; 29
    1166:	0d 90       	ld	r0, X+
    1168:	01 92       	st	Z+, r0
    116a:	81 50       	subi	r24, 0x01	; 1
    116c:	e1 f7       	brne	.-8      	; 0x1166 <grab_frames+0x66>
			f_ndx++;
    116e:	1f 5f       	subi	r17, 0xFF	; 255
void grab_frames(const LDS_FRAME *frame, LDS_FRAME ldsf[]){
	LDS_FRAME t_frame;
	uint8_t f_ndx = 1;
	ldsf[0] = *frame;

	while(f_ndx < 90){
    1170:	1a 35       	cpi	r17, 0x5A	; 90
    1172:	38 f3       	brcs	.-50     	; 0x1142 <grab_frames+0x42>
		if(parse_frame(&t_frame)){
			ldsf[f_ndx] = t_frame;
			f_ndx++;
		}
	}
}
    1174:	6d 96       	adiw	r28, 0x1d	; 29
    1176:	0f b6       	in	r0, 0x3f	; 63
    1178:	f8 94       	cli
    117a:	de bf       	out	0x3e, r29	; 62
    117c:	0f be       	out	0x3f, r0	; 63
    117e:	cd bf       	out	0x3d, r28	; 61
    1180:	cf 91       	pop	r28
    1182:	df 91       	pop	r29
    1184:	1f 91       	pop	r17
    1186:	ff 90       	pop	r15
    1188:	ef 90       	pop	r14
    118a:	df 90       	pop	r13
    118c:	cf 90       	pop	r12
    118e:	bf 90       	pop	r11
    1190:	af 90       	pop	r10
    1192:	08 95       	ret

00001194 <main>:
}



int main(void)
{
    1194:	2f 92       	push	r2
    1196:	3f 92       	push	r3
    1198:	4f 92       	push	r4
    119a:	5f 92       	push	r5
    119c:	6f 92       	push	r6
    119e:	7f 92       	push	r7
    11a0:	8f 92       	push	r8
    11a2:	9f 92       	push	r9
    11a4:	af 92       	push	r10
    11a6:	bf 92       	push	r11
    11a8:	cf 92       	push	r12
    11aa:	df 92       	push	r13
    11ac:	ef 92       	push	r14
    11ae:	ff 92       	push	r15
    11b0:	0f 93       	push	r16
    11b2:	1f 93       	push	r17
    11b4:	df 93       	push	r29
    11b6:	cf 93       	push	r28
    11b8:	cd b7       	in	r28, 0x3d	; 61
    11ba:	de b7       	in	r29, 0x3e	; 62
    11bc:	cf 51       	subi	r28, 0x1F	; 31
    11be:	dd 40       	sbci	r29, 0x0D	; 13
    11c0:	0f b6       	in	r0, 0x3f	; 63
    11c2:	f8 94       	cli
    11c4:	de bf       	out	0x3e, r29	; 62
    11c6:	0f be       	out	0x3f, r0	; 63
    11c8:	cd bf       	out	0x3d, r28	; 61
	LDS_FRAME frame;
	LDS_FRAME ldsf[90];
	uint16_t ranges[360];

	lds_buffer_write_ndx = lds_buffer_read_ndx = lds_buffer;
    11ca:	8e eb       	ldi	r24, 0xBE	; 190
    11cc:	91 e1       	ldi	r25, 0x11	; 17
    11ce:	90 93 9b 02 	sts	0x029B, r25
    11d2:	80 93 9a 02 	sts	0x029A, r24
    11d6:	90 93 99 02 	sts	0x0299, r25
    11da:	80 93 98 02 	sts	0x0298, r24
	prvSetupHardware();
    11de:	0e 94 ea 06 	call	0xdd4	; 0xdd4 <prvSetupHardware>
	rprintf("Starting program.\n");
    11e2:	00 d0       	rcall	.+0      	; 0x11e4 <main+0x50>
    11e4:	0f 92       	push	r0
    11e6:	81 e0       	ldi	r24, 0x01	; 1
    11e8:	ad b7       	in	r26, 0x3d	; 61
    11ea:	be b7       	in	r27, 0x3e	; 62
    11ec:	11 96       	adiw	r26, 0x01	; 1
    11ee:	8c 93       	st	X, r24
    11f0:	11 97       	sbiw	r26, 0x01	; 1
    11f2:	83 e2       	ldi	r24, 0x23	; 35
    11f4:	91 e0       	ldi	r25, 0x01	; 1
    11f6:	13 96       	adiw	r26, 0x03	; 3
    11f8:	9c 93       	st	X, r25
    11fa:	8e 93       	st	-X, r24
    11fc:	12 97       	sbiw	r26, 0x02	; 2
    11fe:	0e 94 66 23 	call	0x46cc	; 0x46cc <rprintf1RamRom>
    1202:	0f 90       	pop	r0
    1204:	0f 90       	pop	r0
    1206:	0f 90       	pop	r0

	while(1){
	// Grab frames
		if(parse_frame(&frame)){
    1208:	4e 01       	movw	r8, r28
    120a:	08 94       	sec
    120c:	81 1c       	adc	r8, r1
    120e:	91 1c       	adc	r9, r1
			//rprintf("Got frame.\n");
			// If you get the first frame, start reading into the frame buffer
			if(frame.index == 0xA0){
				grab_frames(&frame,ldsf);
    1210:	5e ee       	ldi	r21, 0xEE	; 238
    1212:	e5 2e       	mov	r14, r21
    1214:	52 e0       	ldi	r21, 0x02	; 2
    1216:	f5 2e       	mov	r15, r21
    1218:	ec 0e       	add	r14, r28
    121a:	fd 1e       	adc	r15, r29
				rprintf("Frames grabbed.\n");
    121c:	dd 24       	eor	r13, r13
    121e:	d3 94       	inc	r13
				// Convert frames into distances
				conv_FrametoDist(ldsf,ranges);
    1220:	4e e1       	ldi	r20, 0x1E	; 30
    1222:	a4 2e       	mov	r10, r20
    1224:	b1 2c       	mov	r11, r1
    1226:	ac 0e       	add	r10, r28
    1228:	bd 1e       	adc	r11, r29
				rprintf("Frames Converted.\n");
				// Print ranges
				rprintf("Scan start\n");
    122a:	33 ef       	ldi	r19, 0xF3	; 243
    122c:	23 2e       	mov	r2, r19
    122e:	30 e0       	ldi	r19, 0x00	; 0
    1230:	33 2e       	mov	r3, r19
				for(uint16_t r_ndx = 0; r_ndx < 360; r_ndx++){
					rprintf("%d",ranges[r_ndx]);
    1232:	20 ef       	ldi	r18, 0xF0	; 240
    1234:	42 2e       	mov	r4, r18
    1236:	20 e0       	ldi	r18, 0x00	; 0
    1238:	52 2e       	mov	r5, r18
    123a:	cc 24       	eor	r12, r12
    123c:	c3 94       	inc	r12
					rprintfCRLF();
				}
				rprintf("\nScan end\n\n");
    123e:	94 ee       	ldi	r25, 0xE4	; 228
    1240:	69 2e       	mov	r6, r25
    1242:	90 e0       	ldi	r25, 0x00	; 0
    1244:	79 2e       	mov	r7, r25
	prvSetupHardware();
	rprintf("Starting program.\n");

	while(1){
	// Grab frames
		if(parse_frame(&frame)){
    1246:	c4 01       	movw	r24, r8
    1248:	0e 94 99 07 	call	0xf32	; 0xf32 <parse_frame>
    124c:	88 23       	and	r24, r24
    124e:	d9 f3       	breq	.-10     	; 0x1246 <main+0xb2>
			//rprintf("Got frame.\n");
			// If you get the first frame, start reading into the frame buffer
			if(frame.index == 0xA0){
    1250:	89 81       	ldd	r24, Y+1	; 0x01
    1252:	80 3a       	cpi	r24, 0xA0	; 160
    1254:	c1 f7       	brne	.-16     	; 0x1246 <main+0xb2>
				grab_frames(&frame,ldsf);
    1256:	c4 01       	movw	r24, r8
    1258:	b7 01       	movw	r22, r14
    125a:	0e 94 80 08 	call	0x1100	; 0x1100 <grab_frames>
				rprintf("Frames grabbed.\n");
    125e:	00 d0       	rcall	.+0      	; 0x1260 <main+0xcc>
    1260:	0f 92       	push	r0
    1262:	ed b7       	in	r30, 0x3d	; 61
    1264:	fe b7       	in	r31, 0x3e	; 62
    1266:	d1 82       	std	Z+1, r13	; 0x01
    1268:	82 e1       	ldi	r24, 0x12	; 18
    126a:	91 e0       	ldi	r25, 0x01	; 1
    126c:	93 83       	std	Z+3, r25	; 0x03
    126e:	82 83       	std	Z+2, r24	; 0x02
    1270:	0e 94 66 23 	call	0x46cc	; 0x46cc <rprintf1RamRom>
				// Convert frames into distances
				conv_FrametoDist(ldsf,ranges);
    1274:	0f 90       	pop	r0
    1276:	0f 90       	pop	r0
    1278:	0f 90       	pop	r0
    127a:	c7 01       	movw	r24, r14
    127c:	b5 01       	movw	r22, r10
    127e:	0e 94 db 05 	call	0xbb6	; 0xbb6 <conv_FrametoDist>
				rprintf("Frames Converted.\n");
    1282:	00 d0       	rcall	.+0      	; 0x1284 <main+0xf0>
    1284:	0f 92       	push	r0
    1286:	ad b7       	in	r26, 0x3d	; 61
    1288:	be b7       	in	r27, 0x3e	; 62
    128a:	11 96       	adiw	r26, 0x01	; 1
    128c:	dc 92       	st	X, r13
    128e:	11 97       	sbiw	r26, 0x01	; 1
    1290:	ef ef       	ldi	r30, 0xFF	; 255
    1292:	f0 e0       	ldi	r31, 0x00	; 0
    1294:	13 96       	adiw	r26, 0x03	; 3
    1296:	fc 93       	st	X, r31
    1298:	ee 93       	st	-X, r30
    129a:	12 97       	sbiw	r26, 0x02	; 2
    129c:	0e 94 66 23 	call	0x46cc	; 0x46cc <rprintf1RamRom>
				// Print ranges
				rprintf("Scan start\n");
    12a0:	ad b7       	in	r26, 0x3d	; 61
    12a2:	be b7       	in	r27, 0x3e	; 62
    12a4:	11 96       	adiw	r26, 0x01	; 1
    12a6:	dc 92       	st	X, r13
    12a8:	11 97       	sbiw	r26, 0x01	; 1
    12aa:	13 96       	adiw	r26, 0x03	; 3
    12ac:	3c 92       	st	X, r3
    12ae:	2e 92       	st	-X, r2
    12b0:	12 97       	sbiw	r26, 0x02	; 2
    12b2:	0e 94 66 23 	call	0x46cc	; 0x46cc <rprintf1RamRom>
    12b6:	85 01       	movw	r16, r10
    12b8:	0f 90       	pop	r0
    12ba:	0f 90       	pop	r0
    12bc:	0f 90       	pop	r0
				for(uint16_t r_ndx = 0; r_ndx < 360; r_ndx++){
					rprintf("%d",ranges[r_ndx]);
    12be:	00 d0       	rcall	.+0      	; 0x12c0 <main+0x12c>
    12c0:	00 d0       	rcall	.+0      	; 0x12c2 <main+0x12e>
    12c2:	0f 92       	push	r0
    12c4:	ed b7       	in	r30, 0x3d	; 61
    12c6:	fe b7       	in	r31, 0x3e	; 62
    12c8:	31 96       	adiw	r30, 0x01	; 1
    12ca:	ad b7       	in	r26, 0x3d	; 61
    12cc:	be b7       	in	r27, 0x3e	; 62
    12ce:	11 96       	adiw	r26, 0x01	; 1
    12d0:	dc 92       	st	X, r13
    12d2:	52 82       	std	Z+2, r5	; 0x02
    12d4:	41 82       	std	Z+1, r4	; 0x01
    12d6:	d8 01       	movw	r26, r16
    12d8:	8d 91       	ld	r24, X+
    12da:	9d 91       	ld	r25, X+
    12dc:	8d 01       	movw	r16, r26
    12de:	94 83       	std	Z+4, r25	; 0x04
    12e0:	83 83       	std	Z+3, r24	; 0x03
    12e2:	0e 94 66 23 	call	0x46cc	; 0x46cc <rprintf1RamRom>
					rprintfCRLF();
    12e6:	0f 90       	pop	r0
    12e8:	0f 90       	pop	r0
    12ea:	0f 90       	pop	r0
    12ec:	0f 90       	pop	r0
    12ee:	0f 90       	pop	r0
    12f0:	0e 94 a6 21 	call	0x434c	; 0x434c <rprintfCRLF>
				// Convert frames into distances
				conv_FrametoDist(ldsf,ranges);
				rprintf("Frames Converted.\n");
				// Print ranges
				rprintf("Scan start\n");
				for(uint16_t r_ndx = 0; r_ndx < 360; r_ndx++){
    12f4:	0e 15       	cp	r16, r14
    12f6:	1f 05       	cpc	r17, r15
    12f8:	11 f7       	brne	.-60     	; 0x12be <main+0x12a>
					rprintf("%d",ranges[r_ndx]);
					rprintfCRLF();
				}
				rprintf("\nScan end\n\n");
    12fa:	00 d0       	rcall	.+0      	; 0x12fc <main+0x168>
    12fc:	0f 92       	push	r0
    12fe:	ed b7       	in	r30, 0x3d	; 61
    1300:	fe b7       	in	r31, 0x3e	; 62
    1302:	c1 82       	std	Z+1, r12	; 0x01
    1304:	73 82       	std	Z+3, r7	; 0x03
    1306:	62 82       	std	Z+2, r6	; 0x02
    1308:	0e 94 66 23 	call	0x46cc	; 0x46cc <rprintf1RamRom>
    130c:	0f 90       	pop	r0
    130e:	0f 90       	pop	r0
    1310:	0f 90       	pop	r0
    1312:	99 cf       	rjmp	.-206    	; 0x1246 <main+0xb2>

00001314 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1314:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    1316:	9c 01       	movw	r18, r24
    1318:	2d 5f       	subi	r18, 0xFD	; 253
    131a:	3f 4f       	sbci	r19, 0xFF	; 255
    131c:	32 83       	std	Z+2, r19	; 0x02
    131e:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1320:	8f ef       	ldi	r24, 0xFF	; 255
    1322:	9f ef       	ldi	r25, 0xFF	; 255
    1324:	94 83       	std	Z+4, r25	; 0x04
    1326:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1328:	36 83       	std	Z+6, r19	; 0x06
    132a:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    132c:	30 87       	std	Z+8, r19	; 0x08
    132e:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = 0;
    1330:	10 82       	st	Z, r1
}
    1332:	08 95       	ret

00001334 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1334:	fc 01       	movw	r30, r24
    1336:	11 86       	std	Z+9, r1	; 0x09
    1338:	10 86       	std	Z+8, r1	; 0x08
}
    133a:	08 95       	ret

0000133c <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    133c:	cf 93       	push	r28
    133e:	df 93       	push	r29
    1340:	ac 01       	movw	r20, r24
    1342:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1344:	ec 01       	movw	r28, r24
    1346:	29 81       	ldd	r18, Y+1	; 0x01
    1348:	3a 81       	ldd	r19, Y+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    134a:	f9 01       	movw	r30, r18
    134c:	82 81       	ldd	r24, Z+2	; 0x02
    134e:	93 81       	ldd	r25, Z+3	; 0x03
    1350:	13 96       	adiw	r26, 0x03	; 3
    1352:	9c 93       	st	X, r25
    1354:	8e 93       	st	-X, r24
    1356:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1358:	89 81       	ldd	r24, Y+1	; 0x01
    135a:	9a 81       	ldd	r25, Y+2	; 0x02
    135c:	15 96       	adiw	r26, 0x05	; 5
    135e:	9c 93       	st	X, r25
    1360:	8e 93       	st	-X, r24
    1362:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1364:	02 80       	ldd	r0, Z+2	; 0x02
    1366:	f3 81       	ldd	r31, Z+3	; 0x03
    1368:	e0 2d       	mov	r30, r0
    136a:	75 83       	std	Z+5, r23	; 0x05
    136c:	64 83       	std	Z+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    136e:	e9 01       	movw	r28, r18
    1370:	7b 83       	std	Y+3, r23	; 0x03
    1372:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    1374:	fa 01       	movw	r30, r20
    1376:	72 83       	std	Z+2, r23	; 0x02
    1378:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    137a:	19 96       	adiw	r26, 0x09	; 9
    137c:	5c 93       	st	X, r21
    137e:	4e 93       	st	-X, r20
    1380:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
    1382:	80 81       	ld	r24, Z
    1384:	8f 5f       	subi	r24, 0xFF	; 255
    1386:	80 83       	st	Z, r24
}
    1388:	df 91       	pop	r29
    138a:	cf 91       	pop	r28
    138c:	08 95       	ret

0000138e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    138e:	cf 93       	push	r28
    1390:	df 93       	push	r29
    1392:	9c 01       	movw	r18, r24
    1394:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    1396:	48 81       	ld	r20, Y
    1398:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as 
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the 
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    139a:	8f ef       	ldi	r24, 0xFF	; 255
    139c:	4f 3f       	cpi	r20, 0xFF	; 255
    139e:	58 07       	cpc	r21, r24
    13a0:	21 f4       	brne	.+8      	; 0x13aa <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    13a2:	f9 01       	movw	r30, r18
    13a4:	a7 81       	ldd	r26, Z+7	; 0x07
    13a6:	b0 85       	ldd	r27, Z+8	; 0x08
    13a8:	10 c0       	rjmp	.+32     	; 0x13ca <vListInsert+0x3c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips. 
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    13aa:	d9 01       	movw	r26, r18
    13ac:	13 96       	adiw	r26, 0x03	; 3
    13ae:	04 c0       	rjmp	.+8      	; 0x13b8 <vListInsert+0x2a>
    13b0:	12 96       	adiw	r26, 0x02	; 2
    13b2:	0d 90       	ld	r0, X+
    13b4:	bc 91       	ld	r27, X
    13b6:	a0 2d       	mov	r26, r0
    13b8:	12 96       	adiw	r26, 0x02	; 2
    13ba:	ed 91       	ld	r30, X+
    13bc:	fc 91       	ld	r31, X
    13be:	13 97       	sbiw	r26, 0x03	; 3
    13c0:	80 81       	ld	r24, Z
    13c2:	91 81       	ldd	r25, Z+1	; 0x01
    13c4:	48 17       	cp	r20, r24
    13c6:	59 07       	cpc	r21, r25
    13c8:	98 f7       	brcc	.-26     	; 0x13b0 <vListInsert+0x22>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    13ca:	12 96       	adiw	r26, 0x02	; 2
    13cc:	ed 91       	ld	r30, X+
    13ce:	fc 91       	ld	r31, X
    13d0:	13 97       	sbiw	r26, 0x03	; 3
    13d2:	fb 83       	std	Y+3, r31	; 0x03
    13d4:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    13d6:	d5 83       	std	Z+5, r29	; 0x05
    13d8:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    13da:	bd 83       	std	Y+5, r27	; 0x05
    13dc:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    13de:	13 96       	adiw	r26, 0x03	; 3
    13e0:	dc 93       	st	X, r29
    13e2:	ce 93       	st	-X, r28
    13e4:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    13e6:	39 87       	std	Y+9, r19	; 0x09
    13e8:	28 87       	std	Y+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    13ea:	f9 01       	movw	r30, r18
    13ec:	80 81       	ld	r24, Z
    13ee:	8f 5f       	subi	r24, 0xFF	; 255
    13f0:	80 83       	st	Z, r24
}
    13f2:	df 91       	pop	r29
    13f4:	cf 91       	pop	r28
    13f6:	08 95       	ret

000013f8 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    13f8:	cf 93       	push	r28
    13fa:	df 93       	push	r29
    13fc:	dc 01       	movw	r26, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    13fe:	12 96       	adiw	r26, 0x02	; 2
    1400:	ed 91       	ld	r30, X+
    1402:	fc 91       	ld	r31, X
    1404:	13 97       	sbiw	r26, 0x03	; 3
    1406:	14 96       	adiw	r26, 0x04	; 4
    1408:	8d 91       	ld	r24, X+
    140a:	9c 91       	ld	r25, X
    140c:	15 97       	sbiw	r26, 0x05	; 5
    140e:	95 83       	std	Z+5, r25	; 0x05
    1410:	84 83       	std	Z+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1412:	14 96       	adiw	r26, 0x04	; 4
    1414:	cd 91       	ld	r28, X+
    1416:	dc 91       	ld	r29, X
    1418:	15 97       	sbiw	r26, 0x05	; 5
    141a:	fb 83       	std	Y+3, r31	; 0x03
    141c:	ea 83       	std	Y+2, r30	; 0x02
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    141e:	18 96       	adiw	r26, 0x08	; 8
    1420:	ed 91       	ld	r30, X+
    1422:	fc 91       	ld	r31, X
    1424:	19 97       	sbiw	r26, 0x09	; 9

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1426:	81 81       	ldd	r24, Z+1	; 0x01
    1428:	92 81       	ldd	r25, Z+2	; 0x02
    142a:	8a 17       	cp	r24, r26
    142c:	9b 07       	cpc	r25, r27
    142e:	11 f4       	brne	.+4      	; 0x1434 <vListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1430:	d2 83       	std	Z+2, r29	; 0x02
    1432:	c1 83       	std	Z+1, r28	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    1434:	19 96       	adiw	r26, 0x09	; 9
    1436:	1c 92       	st	X, r1
    1438:	1e 92       	st	-X, r1
    143a:	18 97       	sbiw	r26, 0x08	; 8
	( pxList->uxNumberOfItems )--;
    143c:	80 81       	ld	r24, Z
    143e:	81 50       	subi	r24, 0x01	; 1
    1440:	80 83       	st	Z, r24
}
    1442:	df 91       	pop	r29
    1444:	cf 91       	pop	r28
    1446:	08 95       	ret

00001448 <uxQueueMessagesWaiting>:
	return xReturn;
}
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    1448:	fc 01       	movw	r30, r24
unsigned portBASE_TYPE uxReturn;

	taskENTER_CRITICAL();
    144a:	0f b6       	in	r0, 0x3f	; 63
    144c:	f8 94       	cli
    144e:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1450:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    1452:	0f 90       	pop	r0
    1454:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    1456:	08 95       	ret

00001458 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    1458:	fc 01       	movw	r30, r24
unsigned portBASE_TYPE uxReturn;

	uxReturn = pxQueue->uxMessagesWaiting;
    145a:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
    145c:	08 95       	ret

0000145e <xQueueIsQueueEmptyFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    145e:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1460:	82 8d       	ldd	r24, Z+26	; 0x1a
    1462:	90 e0       	ldi	r25, 0x00	; 0
    1464:	88 23       	and	r24, r24
    1466:	09 f4       	brne	.+2      	; 0x146a <xQueueIsQueueEmptyFromISR+0xc>
    1468:	91 e0       	ldi	r25, 0x01	; 1

	return xReturn;
}
    146a:	89 2f       	mov	r24, r25
    146c:	08 95       	ret

0000146e <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    146e:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    1470:	92 8d       	ldd	r25, Z+26	; 0x1a
    1472:	20 e0       	ldi	r18, 0x00	; 0
    1474:	83 8d       	ldd	r24, Z+27	; 0x1b
    1476:	98 17       	cp	r25, r24
    1478:	09 f4       	brne	.+2      	; 0x147c <xQueueIsQueueFullFromISR+0xe>
    147a:	21 e0       	ldi	r18, 0x01	; 1

	return xReturn;
}
    147c:	82 2f       	mov	r24, r18
    147e:	08 95       	ret

00001480 <vQueueDelete>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    1480:	0f 93       	push	r16
    1482:	1f 93       	push	r17
    1484:	8c 01       	movw	r16, r24
	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    1486:	fc 01       	movw	r30, r24
    1488:	80 81       	ld	r24, Z
    148a:	91 81       	ldd	r25, Z+1	; 0x01
    148c:	0e 94 99 14 	call	0x2932	; 0x2932 <vPortFree>
	vPortFree( pxQueue );
    1490:	c8 01       	movw	r24, r16
    1492:	0e 94 99 14 	call	0x2932	; 0x2932 <vPortFree>
}
    1496:	1f 91       	pop	r17
    1498:	0f 91       	pop	r16
    149a:	08 95       	ret

0000149c <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    149c:	0f 93       	push	r16
    149e:	1f 93       	push	r17
    14a0:	cf 93       	push	r28
    14a2:	df 93       	push	r29
    14a4:	ec 01       	movw	r28, r24
    14a6:	fb 01       	movw	r30, r22
    14a8:	8a 01       	movw	r16, r20
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    14aa:	8a 8d       	ldd	r24, Y+26	; 0x1a
    14ac:	88 23       	and	r24, r24
    14ae:	81 f1       	breq	.+96     	; 0x1510 <xQueueReceiveFromISR+0x74>
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    14b0:	48 81       	ld	r20, Y
    14b2:	59 81       	ldd	r21, Y+1	; 0x01
    14b4:	41 15       	cp	r20, r1
    14b6:	51 05       	cpc	r21, r1
    14b8:	a9 f0       	breq	.+42     	; 0x14e4 <xQueueReceiveFromISR+0x48>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    14ba:	8c 8d       	ldd	r24, Y+28	; 0x1c
    14bc:	2e 81       	ldd	r18, Y+6	; 0x06
    14be:	3f 81       	ldd	r19, Y+7	; 0x07
    14c0:	28 0f       	add	r18, r24
    14c2:	31 1d       	adc	r19, r1
    14c4:	3f 83       	std	Y+7, r19	; 0x07
    14c6:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    14c8:	8a 81       	ldd	r24, Y+2	; 0x02
    14ca:	9b 81       	ldd	r25, Y+3	; 0x03
    14cc:	28 17       	cp	r18, r24
    14ce:	39 07       	cpc	r19, r25
    14d0:	10 f0       	brcs	.+4      	; 0x14d6 <xQueueReceiveFromISR+0x3a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    14d2:	5f 83       	std	Y+7, r21	; 0x07
    14d4:	4e 83       	std	Y+6, r20	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    14d6:	4c 8d       	ldd	r20, Y+28	; 0x1c
    14d8:	6e 81       	ldd	r22, Y+6	; 0x06
    14da:	7f 81       	ldd	r23, Y+7	; 0x07
    14dc:	cf 01       	movw	r24, r30
    14de:	50 e0       	ldi	r21, 0x00	; 0
    14e0:	0e 94 80 26 	call	0x4d00	; 0x4d00 <memcpy>
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
			--( pxQueue->uxMessagesWaiting );
    14e4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    14e6:	81 50       	subi	r24, 0x01	; 1
    14e8:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    14ea:	8d 8d       	ldd	r24, Y+29	; 0x1d
    14ec:	8f 3f       	cpi	r24, 0xFF	; 255
    14ee:	69 f4       	brne	.+26     	; 0x150a <xQueueReceiveFromISR+0x6e>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
    14f0:	88 85       	ldd	r24, Y+8	; 0x08
    14f2:	88 23       	and	r24, r24
    14f4:	61 f0       	breq	.+24     	; 0x150e <xQueueReceiveFromISR+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    14f6:	ce 01       	movw	r24, r28
    14f8:	08 96       	adiw	r24, 0x08	; 8
    14fa:	0e 94 ae 0d 	call	0x1b5c	; 0x1b5c <xTaskRemoveFromEventList>
    14fe:	88 23       	and	r24, r24
    1500:	31 f0       	breq	.+12     	; 0x150e <xQueueReceiveFromISR+0x72>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    1502:	81 e0       	ldi	r24, 0x01	; 1
    1504:	f8 01       	movw	r30, r16
    1506:	80 83       	st	Z, r24
    1508:	03 c0       	rjmp	.+6      	; 0x1510 <xQueueReceiveFromISR+0x74>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    150a:	8f 5f       	subi	r24, 0xFF	; 255
    150c:	8d 8f       	std	Y+29, r24	; 0x1d
    150e:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1510:	df 91       	pop	r29
    1512:	cf 91       	pop	r28
    1514:	1f 91       	pop	r17
    1516:	0f 91       	pop	r16
    1518:	08 95       	ret

0000151a <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    151a:	cf 93       	push	r28
    151c:	df 93       	push	r29
    151e:	ec 01       	movw	r28, r24
    1520:	84 2f       	mov	r24, r20
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    1522:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1524:	44 23       	and	r20, r20
    1526:	a1 f1       	breq	.+104    	; 0x1590 <prvCopyDataToQueue+0x76>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    1528:	88 23       	and	r24, r24
    152a:	b1 f4       	brne	.+44     	; 0x1558 <prvCopyDataToQueue+0x3e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    152c:	8c 81       	ldd	r24, Y+4	; 0x04
    152e:	9d 81       	ldd	r25, Y+5	; 0x05
    1530:	50 e0       	ldi	r21, 0x00	; 0
    1532:	0e 94 80 26 	call	0x4d00	; 0x4d00 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    1536:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1538:	2c 81       	ldd	r18, Y+4	; 0x04
    153a:	3d 81       	ldd	r19, Y+5	; 0x05
    153c:	28 0f       	add	r18, r24
    153e:	31 1d       	adc	r19, r1
    1540:	3d 83       	std	Y+5, r19	; 0x05
    1542:	2c 83       	std	Y+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    1544:	8a 81       	ldd	r24, Y+2	; 0x02
    1546:	9b 81       	ldd	r25, Y+3	; 0x03
    1548:	28 17       	cp	r18, r24
    154a:	39 07       	cpc	r19, r25
    154c:	08 f1       	brcs	.+66     	; 0x1590 <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    154e:	88 81       	ld	r24, Y
    1550:	99 81       	ldd	r25, Y+1	; 0x01
    1552:	9d 83       	std	Y+5, r25	; 0x05
    1554:	8c 83       	std	Y+4, r24	; 0x04
    1556:	1c c0       	rjmp	.+56     	; 0x1590 <prvCopyDataToQueue+0x76>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1558:	8e 81       	ldd	r24, Y+6	; 0x06
    155a:	9f 81       	ldd	r25, Y+7	; 0x07
    155c:	50 e0       	ldi	r21, 0x00	; 0
    155e:	0e 94 80 26 	call	0x4d00	; 0x4d00 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    1562:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1564:	90 e0       	ldi	r25, 0x00	; 0
    1566:	44 27       	eor	r20, r20
    1568:	55 27       	eor	r21, r21
    156a:	48 1b       	sub	r20, r24
    156c:	59 0b       	sbc	r21, r25
    156e:	8e 81       	ldd	r24, Y+6	; 0x06
    1570:	9f 81       	ldd	r25, Y+7	; 0x07
    1572:	84 0f       	add	r24, r20
    1574:	95 1f       	adc	r25, r21
    1576:	9f 83       	std	Y+7, r25	; 0x07
    1578:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    157a:	28 81       	ld	r18, Y
    157c:	39 81       	ldd	r19, Y+1	; 0x01
    157e:	82 17       	cp	r24, r18
    1580:	93 07       	cpc	r25, r19
    1582:	30 f4       	brcc	.+12     	; 0x1590 <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    1584:	8a 81       	ldd	r24, Y+2	; 0x02
    1586:	9b 81       	ldd	r25, Y+3	; 0x03
    1588:	84 0f       	add	r24, r20
    158a:	95 1f       	adc	r25, r21
    158c:	9f 83       	std	Y+7, r25	; 0x07
    158e:	8e 83       	std	Y+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    1590:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1592:	8f 5f       	subi	r24, 0xFF	; 255
    1594:	8a 8f       	std	Y+26, r24	; 0x1a
}
    1596:	df 91       	pop	r29
    1598:	cf 91       	pop	r28
    159a:	08 95       	ret

0000159c <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    159c:	0f 93       	push	r16
    159e:	1f 93       	push	r17
    15a0:	cf 93       	push	r28
    15a2:	df 93       	push	r29
    15a4:	ec 01       	movw	r28, r24
    15a6:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    15a8:	9a 8d       	ldd	r25, Y+26	; 0x1a
    15aa:	8b 8d       	ldd	r24, Y+27	; 0x1b
    15ac:	98 17       	cp	r25, r24
    15ae:	10 f0       	brcs	.+4      	; 0x15b4 <xQueueGenericSendFromISR+0x18>
    15b0:	80 e0       	ldi	r24, 0x00	; 0
    15b2:	17 c0       	rjmp	.+46     	; 0x15e2 <xQueueGenericSendFromISR+0x46>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    15b4:	ce 01       	movw	r24, r28
    15b6:	42 2f       	mov	r20, r18
    15b8:	0e 94 8d 0a 	call	0x151a	; 0x151a <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    15bc:	8e 8d       	ldd	r24, Y+30	; 0x1e
    15be:	8f 3f       	cpi	r24, 0xFF	; 255
    15c0:	69 f4       	brne	.+26     	; 0x15dc <xQueueGenericSendFromISR+0x40>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    15c2:	89 89       	ldd	r24, Y+17	; 0x11
    15c4:	88 23       	and	r24, r24
    15c6:	61 f0       	breq	.+24     	; 0x15e0 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    15c8:	ce 01       	movw	r24, r28
    15ca:	41 96       	adiw	r24, 0x11	; 17
    15cc:	0e 94 ae 0d 	call	0x1b5c	; 0x1b5c <xTaskRemoveFromEventList>
    15d0:	88 23       	and	r24, r24
    15d2:	31 f0       	breq	.+12     	; 0x15e0 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    15d4:	81 e0       	ldi	r24, 0x01	; 1
    15d6:	f8 01       	movw	r30, r16
    15d8:	80 83       	st	Z, r24
    15da:	03 c0       	rjmp	.+6      	; 0x15e2 <xQueueGenericSendFromISR+0x46>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    15dc:	8f 5f       	subi	r24, 0xFF	; 255
    15de:	8e 8f       	std	Y+30, r24	; 0x1e
    15e0:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    15e2:	df 91       	pop	r29
    15e4:	cf 91       	pop	r28
    15e6:	1f 91       	pop	r17
    15e8:	0f 91       	pop	r16
    15ea:	08 95       	ret

000015ec <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    15ec:	0f 93       	push	r16
    15ee:	1f 93       	push	r17
    15f0:	cf 93       	push	r28
    15f2:	df 93       	push	r29
    15f4:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    15f6:	0f b6       	in	r0, 0x3f	; 63
    15f8:	f8 94       	cli
    15fa:	0f 92       	push	r0
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    15fc:	8c 01       	movw	r16, r24
    15fe:	0f 5e       	subi	r16, 0xEF	; 239
    1600:	1f 4f       	sbci	r17, 0xFF	; 255
    1602:	0d c0       	rjmp	.+26     	; 0x161e <prvUnlockQueue+0x32>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    1604:	89 89       	ldd	r24, Y+17	; 0x11
    1606:	88 23       	and	r24, r24
    1608:	69 f0       	breq	.+26     	; 0x1624 <prvUnlockQueue+0x38>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    160a:	c8 01       	movw	r24, r16
    160c:	0e 94 ae 0d 	call	0x1b5c	; 0x1b5c <xTaskRemoveFromEventList>
    1610:	88 23       	and	r24, r24
    1612:	11 f0       	breq	.+4      	; 0x1618 <prvUnlockQueue+0x2c>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    1614:	0e 94 aa 0d 	call	0x1b54	; 0x1b54 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    1618:	8e 8d       	ldd	r24, Y+30	; 0x1e
    161a:	81 50       	subi	r24, 0x01	; 1
    161c:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    161e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1620:	18 16       	cp	r1, r24
    1622:	84 f3       	brlt	.-32     	; 0x1604 <prvUnlockQueue+0x18>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    1624:	8f ef       	ldi	r24, 0xFF	; 255
    1626:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1628:	0f 90       	pop	r0
    162a:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    162c:	0f b6       	in	r0, 0x3f	; 63
    162e:	f8 94       	cli
    1630:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1632:	8e 01       	movw	r16, r28
    1634:	08 5f       	subi	r16, 0xF8	; 248
    1636:	1f 4f       	sbci	r17, 0xFF	; 255
    1638:	0d c0       	rjmp	.+26     	; 0x1654 <prvUnlockQueue+0x68>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
    163a:	88 85       	ldd	r24, Y+8	; 0x08
    163c:	88 23       	and	r24, r24
    163e:	69 f0       	breq	.+26     	; 0x165a <prvUnlockQueue+0x6e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1640:	c8 01       	movw	r24, r16
    1642:	0e 94 ae 0d 	call	0x1b5c	; 0x1b5c <xTaskRemoveFromEventList>
    1646:	88 23       	and	r24, r24
    1648:	11 f0       	breq	.+4      	; 0x164e <prvUnlockQueue+0x62>
				{
					vTaskMissedYield();
    164a:	0e 94 aa 0d 	call	0x1b54	; 0x1b54 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    164e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1650:	81 50       	subi	r24, 0x01	; 1
    1652:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1654:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1656:	18 16       	cp	r1, r24
    1658:	84 f3       	brlt	.-32     	; 0x163a <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    165a:	8f ef       	ldi	r24, 0xFF	; 255
    165c:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    165e:	0f 90       	pop	r0
    1660:	0f be       	out	0x3f, r0	; 63
}
    1662:	df 91       	pop	r29
    1664:	cf 91       	pop	r28
    1666:	1f 91       	pop	r17
    1668:	0f 91       	pop	r16
    166a:	08 95       	ret

0000166c <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    166c:	7f 92       	push	r7
    166e:	8f 92       	push	r8
    1670:	9f 92       	push	r9
    1672:	af 92       	push	r10
    1674:	bf 92       	push	r11
    1676:	cf 92       	push	r12
    1678:	df 92       	push	r13
    167a:	ef 92       	push	r14
    167c:	ff 92       	push	r15
    167e:	0f 93       	push	r16
    1680:	1f 93       	push	r17
    1682:	df 93       	push	r29
    1684:	cf 93       	push	r28
    1686:	00 d0       	rcall	.+0      	; 0x1688 <xQueueGenericReceive+0x1c>
    1688:	00 d0       	rcall	.+0      	; 0x168a <xQueueGenericReceive+0x1e>
    168a:	0f 92       	push	r0
    168c:	cd b7       	in	r28, 0x3d	; 61
    168e:	de b7       	in	r29, 0x3e	; 62
    1690:	8c 01       	movw	r16, r24
    1692:	96 2e       	mov	r9, r22
    1694:	87 2e       	mov	r8, r23
    1696:	5d 83       	std	Y+5, r21	; 0x05
    1698:	4c 83       	std	Y+4, r20	; 0x04
    169a:	72 2e       	mov	r7, r18
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    169c:	91 e1       	ldi	r25, 0x11	; 17
    169e:	c9 2e       	mov	r12, r25
    16a0:	d1 2c       	mov	r13, r1
    16a2:	c0 0e       	add	r12, r16
    16a4:	d1 1e       	adc	r13, r17
    16a6:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    16a8:	7e 01       	movw	r14, r28
    16aa:	08 94       	sec
    16ac:	e1 1c       	adc	r14, r1
    16ae:	f1 1c       	adc	r15, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    16b0:	84 e0       	ldi	r24, 0x04	; 4
    16b2:	a8 2e       	mov	r10, r24
    16b4:	b1 2c       	mov	r11, r1
    16b6:	ac 0e       	add	r10, r28
    16b8:	bd 1e       	adc	r11, r29
    16ba:	01 c0       	rjmp	.+2      	; 0x16be <xQueueGenericReceive+0x52>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    16bc:	21 e0       	ldi	r18, 0x01	; 1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    16be:	0f b6       	in	r0, 0x3f	; 63
    16c0:	f8 94       	cli
    16c2:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    16c4:	f8 01       	movw	r30, r16
    16c6:	82 8d       	ldd	r24, Z+26	; 0x1a
    16c8:	88 23       	and	r24, r24
    16ca:	09 f4       	brne	.+2      	; 0x16ce <xQueueGenericReceive+0x62>
    16cc:	3e c0       	rjmp	.+124    	; 0x174a <xQueueGenericReceive+0xde>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    16ce:	e6 80       	ldd	r14, Z+6	; 0x06
    16d0:	f7 80       	ldd	r15, Z+7	; 0x07
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    16d2:	40 81       	ld	r20, Z
    16d4:	51 81       	ldd	r21, Z+1	; 0x01
    16d6:	41 15       	cp	r20, r1
    16d8:	51 05       	cpc	r21, r1
    16da:	b1 f0       	breq	.+44     	; 0x1708 <xQueueGenericReceive+0x9c>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    16dc:	84 8d       	ldd	r24, Z+28	; 0x1c
    16de:	97 01       	movw	r18, r14
    16e0:	28 0f       	add	r18, r24
    16e2:	31 1d       	adc	r19, r1
    16e4:	37 83       	std	Z+7, r19	; 0x07
    16e6:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    16e8:	82 81       	ldd	r24, Z+2	; 0x02
    16ea:	93 81       	ldd	r25, Z+3	; 0x03
    16ec:	28 17       	cp	r18, r24
    16ee:	39 07       	cpc	r19, r25
    16f0:	10 f0       	brcs	.+4      	; 0x16f6 <xQueueGenericReceive+0x8a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    16f2:	57 83       	std	Z+7, r21	; 0x07
    16f4:	46 83       	std	Z+6, r20	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    16f6:	f8 01       	movw	r30, r16
    16f8:	44 8d       	ldd	r20, Z+28	; 0x1c
    16fa:	66 81       	ldd	r22, Z+6	; 0x06
    16fc:	77 81       	ldd	r23, Z+7	; 0x07
    16fe:	89 2d       	mov	r24, r9
    1700:	98 2d       	mov	r25, r8
    1702:	50 e0       	ldi	r21, 0x00	; 0
    1704:	0e 94 80 26 	call	0x4d00	; 0x4d00 <memcpy>
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
    1708:	77 20       	and	r7, r7
    170a:	71 f4       	brne	.+28     	; 0x1728 <xQueueGenericReceive+0xbc>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    170c:	f8 01       	movw	r30, r16
    170e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1710:	81 50       	subi	r24, 0x01	; 1
    1712:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1714:	80 85       	ldd	r24, Z+8	; 0x08
    1716:	88 23       	and	r24, r24
    1718:	a1 f0       	breq	.+40     	; 0x1742 <xQueueGenericReceive+0xd6>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    171a:	c8 01       	movw	r24, r16
    171c:	08 96       	adiw	r24, 0x08	; 8
    171e:	0e 94 ae 0d 	call	0x1b5c	; 0x1b5c <xTaskRemoveFromEventList>
    1722:	81 30       	cpi	r24, 0x01	; 1
    1724:	71 f4       	brne	.+28     	; 0x1742 <xQueueGenericReceive+0xd6>
    1726:	0b c0       	rjmp	.+22     	; 0x173e <xQueueGenericReceive+0xd2>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    1728:	f8 01       	movw	r30, r16
    172a:	f7 82       	std	Z+7, r15	; 0x07
    172c:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    172e:	81 89       	ldd	r24, Z+17	; 0x11
    1730:	88 23       	and	r24, r24
    1732:	39 f0       	breq	.+14     	; 0x1742 <xQueueGenericReceive+0xd6>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1734:	c6 01       	movw	r24, r12
    1736:	0e 94 ae 0d 	call	0x1b5c	; 0x1b5c <xTaskRemoveFromEventList>
    173a:	88 23       	and	r24, r24
    173c:	11 f0       	breq	.+4      	; 0x1742 <xQueueGenericReceive+0xd6>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    173e:	0e 94 76 12 	call	0x24ec	; 0x24ec <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    1742:	0f 90       	pop	r0
    1744:	0f be       	out	0x3f, r0	; 63
    1746:	81 e0       	ldi	r24, 0x01	; 1
    1748:	4a c0       	rjmp	.+148    	; 0x17de <xQueueGenericReceive+0x172>
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    174a:	8c 81       	ldd	r24, Y+4	; 0x04
    174c:	9d 81       	ldd	r25, Y+5	; 0x05
    174e:	89 2b       	or	r24, r25
    1750:	19 f4       	brne	.+6      	; 0x1758 <xQueueGenericReceive+0xec>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1752:	0f 90       	pop	r0
    1754:	0f be       	out	0x3f, r0	; 63
    1756:	42 c0       	rjmp	.+132    	; 0x17dc <xQueueGenericReceive+0x170>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1758:	22 23       	and	r18, r18
    175a:	19 f4       	brne	.+6      	; 0x1762 <xQueueGenericReceive+0xf6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    175c:	c7 01       	movw	r24, r14
    175e:	0e 94 65 0d 	call	0x1aca	; 0x1aca <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    1762:	0f 90       	pop	r0
    1764:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1766:	0e 94 09 0d 	call	0x1a12	; 0x1a12 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    176a:	0f b6       	in	r0, 0x3f	; 63
    176c:	f8 94       	cli
    176e:	0f 92       	push	r0
    1770:	f8 01       	movw	r30, r16
    1772:	85 8d       	ldd	r24, Z+29	; 0x1d
    1774:	8f 3f       	cpi	r24, 0xFF	; 255
    1776:	09 f4       	brne	.+2      	; 0x177a <xQueueGenericReceive+0x10e>
    1778:	15 8e       	std	Z+29, r1	; 0x1d
    177a:	f8 01       	movw	r30, r16
    177c:	86 8d       	ldd	r24, Z+30	; 0x1e
    177e:	8f 3f       	cpi	r24, 0xFF	; 255
    1780:	09 f4       	brne	.+2      	; 0x1784 <xQueueGenericReceive+0x118>
    1782:	16 8e       	std	Z+30, r1	; 0x1e
    1784:	0f 90       	pop	r0
    1786:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1788:	c7 01       	movw	r24, r14
    178a:	b5 01       	movw	r22, r10
    178c:	0e 94 70 0d 	call	0x1ae0	; 0x1ae0 <xTaskCheckForTimeOut>
    1790:	88 23       	and	r24, r24
    1792:	f9 f4       	brne	.+62     	; 0x17d2 <xQueueGenericReceive+0x166>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1794:	0f b6       	in	r0, 0x3f	; 63
    1796:	f8 94       	cli
    1798:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    179a:	f8 01       	movw	r30, r16
    179c:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    179e:	0f 90       	pop	r0
    17a0:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
    17a2:	88 23       	and	r24, r24
    17a4:	81 f4       	brne	.+32     	; 0x17c6 <xQueueGenericReceive+0x15a>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    17a6:	6c 81       	ldd	r22, Y+4	; 0x04
    17a8:	7d 81       	ldd	r23, Y+5	; 0x05
    17aa:	c6 01       	movw	r24, r12
    17ac:	0e 94 67 0e 	call	0x1cce	; 0x1cce <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    17b0:	c8 01       	movw	r24, r16
    17b2:	0e 94 f6 0a 	call	0x15ec	; 0x15ec <prvUnlockQueue>
				if( !xTaskResumeAll() )
    17b6:	0e 94 a0 0e 	call	0x1d40	; 0x1d40 <xTaskResumeAll>
    17ba:	88 23       	and	r24, r24
    17bc:	09 f0       	breq	.+2      	; 0x17c0 <xQueueGenericReceive+0x154>
    17be:	7e cf       	rjmp	.-260    	; 0x16bc <xQueueGenericReceive+0x50>
				{
					portYIELD_WITHIN_API();
    17c0:	0e 94 76 12 	call	0x24ec	; 0x24ec <vPortYield>
    17c4:	7b cf       	rjmp	.-266    	; 0x16bc <xQueueGenericReceive+0x50>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    17c6:	c8 01       	movw	r24, r16
    17c8:	0e 94 f6 0a 	call	0x15ec	; 0x15ec <prvUnlockQueue>
				( void ) xTaskResumeAll();
    17cc:	0e 94 a0 0e 	call	0x1d40	; 0x1d40 <xTaskResumeAll>
    17d0:	75 cf       	rjmp	.-278    	; 0x16bc <xQueueGenericReceive+0x50>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    17d2:	c8 01       	movw	r24, r16
    17d4:	0e 94 f6 0a 	call	0x15ec	; 0x15ec <prvUnlockQueue>
			( void ) xTaskResumeAll();
    17d8:	0e 94 a0 0e 	call	0x1d40	; 0x1d40 <xTaskResumeAll>
    17dc:	80 e0       	ldi	r24, 0x00	; 0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
    17de:	0f 90       	pop	r0
    17e0:	0f 90       	pop	r0
    17e2:	0f 90       	pop	r0
    17e4:	0f 90       	pop	r0
    17e6:	0f 90       	pop	r0
    17e8:	cf 91       	pop	r28
    17ea:	df 91       	pop	r29
    17ec:	1f 91       	pop	r17
    17ee:	0f 91       	pop	r16
    17f0:	ff 90       	pop	r15
    17f2:	ef 90       	pop	r14
    17f4:	df 90       	pop	r13
    17f6:	cf 90       	pop	r12
    17f8:	bf 90       	pop	r11
    17fa:	af 90       	pop	r10
    17fc:	9f 90       	pop	r9
    17fe:	8f 90       	pop	r8
    1800:	7f 90       	pop	r7
    1802:	08 95       	ret

00001804 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    1804:	7f 92       	push	r7
    1806:	8f 92       	push	r8
    1808:	9f 92       	push	r9
    180a:	af 92       	push	r10
    180c:	bf 92       	push	r11
    180e:	cf 92       	push	r12
    1810:	df 92       	push	r13
    1812:	ef 92       	push	r14
    1814:	ff 92       	push	r15
    1816:	0f 93       	push	r16
    1818:	1f 93       	push	r17
    181a:	df 93       	push	r29
    181c:	cf 93       	push	r28
    181e:	00 d0       	rcall	.+0      	; 0x1820 <xQueueGenericSend+0x1c>
    1820:	00 d0       	rcall	.+0      	; 0x1822 <xQueueGenericSend+0x1e>
    1822:	0f 92       	push	r0
    1824:	cd b7       	in	r28, 0x3d	; 61
    1826:	de b7       	in	r29, 0x3e	; 62
    1828:	8c 01       	movw	r16, r24
    182a:	6b 01       	movw	r12, r22
    182c:	5d 83       	std	Y+5, r21	; 0x05
    182e:	4c 83       	std	Y+4, r20	; 0x04
    1830:	72 2e       	mov	r7, r18
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1832:	48 e0       	ldi	r20, 0x08	; 8
    1834:	e4 2e       	mov	r14, r20
    1836:	f1 2c       	mov	r15, r1
    1838:	e8 0e       	add	r14, r24
    183a:	f9 1e       	adc	r15, r25
    183c:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    183e:	5e 01       	movw	r10, r28
    1840:	08 94       	sec
    1842:	a1 1c       	adc	r10, r1
    1844:	b1 1c       	adc	r11, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1846:	34 e0       	ldi	r19, 0x04	; 4
    1848:	83 2e       	mov	r8, r19
    184a:	91 2c       	mov	r9, r1
    184c:	8c 0e       	add	r8, r28
    184e:	9d 1e       	adc	r9, r29
    1850:	01 c0       	rjmp	.+2      	; 0x1854 <xQueueGenericSend+0x50>
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1852:	21 e0       	ldi	r18, 0x01	; 1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1854:	0f b6       	in	r0, 0x3f	; 63
    1856:	f8 94       	cli
    1858:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    185a:	f8 01       	movw	r30, r16
    185c:	92 8d       	ldd	r25, Z+26	; 0x1a
    185e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1860:	98 17       	cp	r25, r24
    1862:	a8 f4       	brcc	.+42     	; 0x188e <xQueueGenericSend+0x8a>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1864:	c8 01       	movw	r24, r16
    1866:	b6 01       	movw	r22, r12
    1868:	47 2d       	mov	r20, r7
    186a:	0e 94 8d 0a 	call	0x151a	; 0x151a <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    186e:	f8 01       	movw	r30, r16
    1870:	81 89       	ldd	r24, Z+17	; 0x11
    1872:	88 23       	and	r24, r24
    1874:	41 f0       	breq	.+16     	; 0x1886 <xQueueGenericSend+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1876:	c8 01       	movw	r24, r16
    1878:	41 96       	adiw	r24, 0x11	; 17
    187a:	0e 94 ae 0d 	call	0x1b5c	; 0x1b5c <xTaskRemoveFromEventList>
    187e:	81 30       	cpi	r24, 0x01	; 1
    1880:	11 f4       	brne	.+4      	; 0x1886 <xQueueGenericSend+0x82>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    1882:	0e 94 76 12 	call	0x24ec	; 0x24ec <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    1886:	0f 90       	pop	r0
    1888:	0f be       	out	0x3f, r0	; 63
    188a:	81 e0       	ldi	r24, 0x01	; 1
    188c:	4c c0       	rjmp	.+152    	; 0x1926 <xQueueGenericSend+0x122>
				function. */
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    188e:	8c 81       	ldd	r24, Y+4	; 0x04
    1890:	9d 81       	ldd	r25, Y+5	; 0x05
    1892:	89 2b       	or	r24, r25
    1894:	19 f4       	brne	.+6      	; 0x189c <xQueueGenericSend+0x98>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1896:	0f 90       	pop	r0
    1898:	0f be       	out	0x3f, r0	; 63
    189a:	44 c0       	rjmp	.+136    	; 0x1924 <xQueueGenericSend+0x120>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    189c:	22 23       	and	r18, r18
    189e:	19 f4       	brne	.+6      	; 0x18a6 <xQueueGenericSend+0xa2>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    18a0:	c5 01       	movw	r24, r10
    18a2:	0e 94 65 0d 	call	0x1aca	; 0x1aca <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    18a6:	0f 90       	pop	r0
    18a8:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    18aa:	0e 94 09 0d 	call	0x1a12	; 0x1a12 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    18ae:	0f b6       	in	r0, 0x3f	; 63
    18b0:	f8 94       	cli
    18b2:	0f 92       	push	r0
    18b4:	f8 01       	movw	r30, r16
    18b6:	85 8d       	ldd	r24, Z+29	; 0x1d
    18b8:	8f 3f       	cpi	r24, 0xFF	; 255
    18ba:	09 f4       	brne	.+2      	; 0x18be <xQueueGenericSend+0xba>
    18bc:	15 8e       	std	Z+29, r1	; 0x1d
    18be:	f8 01       	movw	r30, r16
    18c0:	86 8d       	ldd	r24, Z+30	; 0x1e
    18c2:	8f 3f       	cpi	r24, 0xFF	; 255
    18c4:	09 f4       	brne	.+2      	; 0x18c8 <xQueueGenericSend+0xc4>
    18c6:	16 8e       	std	Z+30, r1	; 0x1e
    18c8:	0f 90       	pop	r0
    18ca:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    18cc:	c5 01       	movw	r24, r10
    18ce:	b4 01       	movw	r22, r8
    18d0:	0e 94 70 0d 	call	0x1ae0	; 0x1ae0 <xTaskCheckForTimeOut>
    18d4:	88 23       	and	r24, r24
    18d6:	09 f5       	brne	.+66     	; 0x191a <xQueueGenericSend+0x116>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    18d8:	0f b6       	in	r0, 0x3f	; 63
    18da:	f8 94       	cli
    18dc:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    18de:	f8 01       	movw	r30, r16
    18e0:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    18e2:	0f 90       	pop	r0
    18e4:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
    18e6:	f8 01       	movw	r30, r16
    18e8:	83 8d       	ldd	r24, Z+27	; 0x1b
    18ea:	98 17       	cp	r25, r24
    18ec:	81 f4       	brne	.+32     	; 0x190e <xQueueGenericSend+0x10a>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    18ee:	6c 81       	ldd	r22, Y+4	; 0x04
    18f0:	7d 81       	ldd	r23, Y+5	; 0x05
    18f2:	c7 01       	movw	r24, r14
    18f4:	0e 94 67 0e 	call	0x1cce	; 0x1cce <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    18f8:	c8 01       	movw	r24, r16
    18fa:	0e 94 f6 0a 	call	0x15ec	; 0x15ec <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
    18fe:	0e 94 a0 0e 	call	0x1d40	; 0x1d40 <xTaskResumeAll>
    1902:	88 23       	and	r24, r24
    1904:	09 f0       	breq	.+2      	; 0x1908 <xQueueGenericSend+0x104>
    1906:	a5 cf       	rjmp	.-182    	; 0x1852 <xQueueGenericSend+0x4e>
				{
					portYIELD_WITHIN_API();
    1908:	0e 94 76 12 	call	0x24ec	; 0x24ec <vPortYield>
    190c:	a2 cf       	rjmp	.-188    	; 0x1852 <xQueueGenericSend+0x4e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    190e:	c8 01       	movw	r24, r16
    1910:	0e 94 f6 0a 	call	0x15ec	; 0x15ec <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1914:	0e 94 a0 0e 	call	0x1d40	; 0x1d40 <xTaskResumeAll>
    1918:	9c cf       	rjmp	.-200    	; 0x1852 <xQueueGenericSend+0x4e>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    191a:	c8 01       	movw	r24, r16
    191c:	0e 94 f6 0a 	call	0x15ec	; 0x15ec <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1920:	0e 94 a0 0e 	call	0x1d40	; 0x1d40 <xTaskResumeAll>
    1924:	80 e0       	ldi	r24, 0x00	; 0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
    1926:	0f 90       	pop	r0
    1928:	0f 90       	pop	r0
    192a:	0f 90       	pop	r0
    192c:	0f 90       	pop	r0
    192e:	0f 90       	pop	r0
    1930:	cf 91       	pop	r28
    1932:	df 91       	pop	r29
    1934:	1f 91       	pop	r17
    1936:	0f 91       	pop	r16
    1938:	ff 90       	pop	r15
    193a:	ef 90       	pop	r14
    193c:	df 90       	pop	r13
    193e:	cf 90       	pop	r12
    1940:	bf 90       	pop	r11
    1942:	af 90       	pop	r10
    1944:	9f 90       	pop	r9
    1946:	8f 90       	pop	r8
    1948:	7f 90       	pop	r7
    194a:	08 95       	ret

0000194c <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    194c:	8f 92       	push	r8
    194e:	9f 92       	push	r9
    1950:	af 92       	push	r10
    1952:	bf 92       	push	r11
    1954:	cf 92       	push	r12
    1956:	df 92       	push	r13
    1958:	ef 92       	push	r14
    195a:	ff 92       	push	r15
    195c:	0f 93       	push	r16
    195e:	1f 93       	push	r17
    1960:	cf 93       	push	r28
    1962:	df 93       	push	r29
    1964:	98 2e       	mov	r9, r24
    1966:	86 2e       	mov	r8, r22
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    1968:	88 23       	and	r24, r24
    196a:	09 f4       	brne	.+2      	; 0x196e <xQueueCreate+0x22>
    196c:	42 c0       	rjmp	.+132    	; 0x19f2 <xQueueCreate+0xa6>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    196e:	8f e1       	ldi	r24, 0x1F	; 31
    1970:	90 e0       	ldi	r25, 0x00	; 0
    1972:	0e 94 a9 14 	call	0x2952	; 0x2952 <pvPortMalloc>
    1976:	8c 01       	movw	r16, r24
    1978:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    197a:	00 97       	sbiw	r24, 0x00	; 0
    197c:	e1 f1       	breq	.+120    	; 0x19f6 <xQueueCreate+0xaa>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    197e:	c9 2c       	mov	r12, r9
    1980:	dd 24       	eor	r13, r13
    1982:	a8 2c       	mov	r10, r8
    1984:	bb 24       	eor	r11, r11
    1986:	ac 9c       	mul	r10, r12
    1988:	70 01       	movw	r14, r0
    198a:	ad 9c       	mul	r10, r13
    198c:	f0 0c       	add	r15, r0
    198e:	bc 9c       	mul	r11, r12
    1990:	f0 0c       	add	r15, r0
    1992:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    1994:	c7 01       	movw	r24, r14
    1996:	01 96       	adiw	r24, 0x01	; 1
    1998:	0e 94 a9 14 	call	0x2952	; 0x2952 <pvPortMalloc>
    199c:	9c 01       	movw	r18, r24
    199e:	99 83       	std	Y+1, r25	; 0x01
    19a0:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    19a2:	00 97       	sbiw	r24, 0x00	; 0
    19a4:	19 f1       	breq	.+70     	; 0x19ec <xQueueCreate+0xa0>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    19a6:	e8 0e       	add	r14, r24
    19a8:	f9 1e       	adc	r15, r25
    19aa:	fb 82       	std	Y+3, r15	; 0x03
    19ac:	ea 82       	std	Y+2, r14	; 0x02
				pxNewQueue->uxMessagesWaiting = 0;
    19ae:	1a 8e       	std	Y+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    19b0:	9d 83       	std	Y+5, r25	; 0x05
    19b2:	8c 83       	std	Y+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
    19b4:	08 94       	sec
    19b6:	c1 08       	sbc	r12, r1
    19b8:	d1 08       	sbc	r13, r1
    19ba:	ca 9c       	mul	r12, r10
    19bc:	c0 01       	movw	r24, r0
    19be:	cb 9c       	mul	r12, r11
    19c0:	90 0d       	add	r25, r0
    19c2:	da 9c       	mul	r13, r10
    19c4:	90 0d       	add	r25, r0
    19c6:	11 24       	eor	r1, r1
    19c8:	28 0f       	add	r18, r24
    19ca:	39 1f       	adc	r19, r25
    19cc:	3f 83       	std	Y+7, r19	; 0x07
    19ce:	2e 83       	std	Y+6, r18	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    19d0:	9b 8e       	std	Y+27, r9	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    19d2:	8c 8e       	std	Y+28, r8	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    19d4:	8f ef       	ldi	r24, 0xFF	; 255
    19d6:	8d 8f       	std	Y+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    19d8:	8e 8f       	std	Y+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    19da:	c8 01       	movw	r24, r16
    19dc:	08 96       	adiw	r24, 0x08	; 8
    19de:	0e 94 8a 09 	call	0x1314	; 0x1314 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    19e2:	c8 01       	movw	r24, r16
    19e4:	41 96       	adiw	r24, 0x11	; 17
    19e6:	0e 94 8a 09 	call	0x1314	; 0x1314 <vListInitialise>
    19ea:	05 c0       	rjmp	.+10     	; 0x19f6 <xQueueCreate+0xaa>
				return  pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    19ec:	c8 01       	movw	r24, r16
    19ee:	0e 94 99 14 	call	0x2932	; 0x2932 <vPortFree>
    19f2:	c0 e0       	ldi	r28, 0x00	; 0
    19f4:	d0 e0       	ldi	r29, 0x00	; 0
	}

	/* Will only reach here if we could not allocate enough memory or no memory
	was required. */
	return NULL;
}
    19f6:	ce 01       	movw	r24, r28
    19f8:	df 91       	pop	r29
    19fa:	cf 91       	pop	r28
    19fc:	1f 91       	pop	r17
    19fe:	0f 91       	pop	r16
    1a00:	ff 90       	pop	r15
    1a02:	ef 90       	pop	r14
    1a04:	df 90       	pop	r13
    1a06:	cf 90       	pop	r12
    1a08:	bf 90       	pop	r11
    1a0a:	af 90       	pop	r10
    1a0c:	9f 90       	pop	r9
    1a0e:	8f 90       	pop	r8
    1a10:	08 95       	ret

00001a12 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    1a12:	80 91 a2 02 	lds	r24, 0x02A2
    1a16:	8f 5f       	subi	r24, 0xFF	; 255
    1a18:	80 93 a2 02 	sts	0x02A2, r24
}
    1a1c:	08 95       	ret

00001a1e <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portENTER_CRITICAL();
    1a1e:	0f b6       	in	r0, 0x3f	; 63
    1a20:	f8 94       	cli
    1a22:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    1a24:	20 91 a0 02 	lds	r18, 0x02A0
    1a28:	30 91 a1 02 	lds	r19, 0x02A1
	}
	portEXIT_CRITICAL();
    1a2c:	0f 90       	pop	r0
    1a2e:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    1a30:	c9 01       	movw	r24, r18
    1a32:	08 95       	ret

00001a34 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
	return xTickCount;
    1a34:	20 91 a0 02 	lds	r18, 0x02A0
    1a38:	30 91 a1 02 	lds	r19, 0x02A1
}
    1a3c:	c9 01       	movw	r24, r18
    1a3e:	08 95       	ret

00001a40 <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    1a40:	80 91 a5 02 	lds	r24, 0x02A5
}
    1a44:	08 95       	ret

00001a46 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    1a46:	80 91 a2 02 	lds	r24, 0x02A2
    1a4a:	88 23       	and	r24, r24
    1a4c:	51 f0       	breq	.+20     	; 0x1a62 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    1a4e:	81 e0       	ldi	r24, 0x01	; 1
    1a50:	80 93 9e 02 	sts	0x029E, r24
    1a54:	08 95       	ret
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
	{
		--uxTopReadyPriority;
    1a56:	80 91 a3 02 	lds	r24, 0x02A3
    1a5a:	81 50       	subi	r24, 0x01	; 1
    1a5c:	80 93 a3 02 	sts	0x02A3, r24
    1a60:	01 c0       	rjmp	.+2      	; 0x1a64 <vTaskSwitchContext+0x1e>

	taskFIRST_CHECK_FOR_STACK_OVERFLOW();
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1a62:	99 e0       	ldi	r25, 0x09	; 9
    1a64:	e0 91 a3 02 	lds	r30, 0x02A3
    1a68:	e9 9f       	mul	r30, r25
    1a6a:	f0 01       	movw	r30, r0
    1a6c:	11 24       	eor	r1, r1
    1a6e:	e6 55       	subi	r30, 0x56	; 86
    1a70:	fd 4f       	sbci	r31, 0xFD	; 253
    1a72:	80 81       	ld	r24, Z
    1a74:	88 23       	and	r24, r24
    1a76:	79 f3       	breq	.-34     	; 0x1a56 <vTaskSwitchContext+0x10>
		--uxTopReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    1a78:	90 91 a3 02 	lds	r25, 0x02A3
    1a7c:	89 e0       	ldi	r24, 0x09	; 9
    1a7e:	98 9f       	mul	r25, r24
    1a80:	d0 01       	movw	r26, r0
    1a82:	11 24       	eor	r1, r1
    1a84:	a6 55       	subi	r26, 0x56	; 86
    1a86:	bd 4f       	sbci	r27, 0xFD	; 253
    1a88:	11 96       	adiw	r26, 0x01	; 1
    1a8a:	ed 91       	ld	r30, X+
    1a8c:	fc 91       	ld	r31, X
    1a8e:	12 97       	sbiw	r26, 0x02	; 2
    1a90:	02 80       	ldd	r0, Z+2	; 0x02
    1a92:	f3 81       	ldd	r31, Z+3	; 0x03
    1a94:	e0 2d       	mov	r30, r0
    1a96:	12 96       	adiw	r26, 0x02	; 2
    1a98:	fc 93       	st	X, r31
    1a9a:	ee 93       	st	-X, r30
    1a9c:	11 97       	sbiw	r26, 0x01	; 1
    1a9e:	cd 01       	movw	r24, r26
    1aa0:	03 96       	adiw	r24, 0x03	; 3
    1aa2:	e8 17       	cp	r30, r24
    1aa4:	f9 07       	cpc	r31, r25
    1aa6:	31 f4       	brne	.+12     	; 0x1ab4 <vTaskSwitchContext+0x6e>
    1aa8:	82 81       	ldd	r24, Z+2	; 0x02
    1aaa:	93 81       	ldd	r25, Z+3	; 0x03
    1aac:	12 96       	adiw	r26, 0x02	; 2
    1aae:	9c 93       	st	X, r25
    1ab0:	8e 93       	st	-X, r24
    1ab2:	11 97       	sbiw	r26, 0x01	; 1
    1ab4:	11 96       	adiw	r26, 0x01	; 1
    1ab6:	ed 91       	ld	r30, X+
    1ab8:	fc 91       	ld	r31, X
    1aba:	12 97       	sbiw	r26, 0x02	; 2
    1abc:	86 81       	ldd	r24, Z+6	; 0x06
    1abe:	97 81       	ldd	r25, Z+7	; 0x07
    1ac0:	90 93 9d 02 	sts	0x029D, r25
    1ac4:	80 93 9c 02 	sts	0x029C, r24
    1ac8:	08 95       	ret

00001aca <vTaskSetTimeOutState>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    1aca:	fc 01       	movw	r30, r24
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1acc:	80 91 9f 02 	lds	r24, 0x029F
    1ad0:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    1ad2:	80 91 a0 02 	lds	r24, 0x02A0
    1ad6:	90 91 a1 02 	lds	r25, 0x02A1
    1ada:	92 83       	std	Z+2, r25	; 0x02
    1adc:	81 83       	std	Z+1, r24	; 0x01
}
    1ade:	08 95       	ret

00001ae0 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    1ae0:	fc 01       	movw	r30, r24
    1ae2:	db 01       	movw	r26, r22
portBASE_TYPE xReturn;

	portENTER_CRITICAL();
    1ae4:	0f b6       	in	r0, 0x3f	; 63
    1ae6:	f8 94       	cli
    1ae8:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    1aea:	90 91 9f 02 	lds	r25, 0x029F
    1aee:	80 81       	ld	r24, Z
    1af0:	98 17       	cp	r25, r24
    1af2:	49 f0       	breq	.+18     	; 0x1b06 <xTaskCheckForTimeOut+0x26>
    1af4:	20 91 a0 02 	lds	r18, 0x02A0
    1af8:	30 91 a1 02 	lds	r19, 0x02A1
    1afc:	81 81       	ldd	r24, Z+1	; 0x01
    1afe:	92 81       	ldd	r25, Z+2	; 0x02
    1b00:	28 17       	cp	r18, r24
    1b02:	39 07       	cpc	r19, r25
    1b04:	18 f5       	brcc	.+70     	; 0x1b4c <xTaskCheckForTimeOut+0x6c>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    1b06:	80 91 a0 02 	lds	r24, 0x02A0
    1b0a:	90 91 a1 02 	lds	r25, 0x02A1
    1b0e:	21 81       	ldd	r18, Z+1	; 0x01
    1b10:	32 81       	ldd	r19, Z+2	; 0x02
    1b12:	4d 91       	ld	r20, X+
    1b14:	5c 91       	ld	r21, X
    1b16:	11 97       	sbiw	r26, 0x01	; 1
    1b18:	82 1b       	sub	r24, r18
    1b1a:	93 0b       	sbc	r25, r19
    1b1c:	84 17       	cp	r24, r20
    1b1e:	95 07       	cpc	r25, r21
    1b20:	a8 f4       	brcc	.+42     	; 0x1b4c <xTaskCheckForTimeOut+0x6c>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    1b22:	80 91 a0 02 	lds	r24, 0x02A0
    1b26:	90 91 a1 02 	lds	r25, 0x02A1
    1b2a:	28 1b       	sub	r18, r24
    1b2c:	39 0b       	sbc	r19, r25
    1b2e:	24 0f       	add	r18, r20
    1b30:	35 1f       	adc	r19, r21
    1b32:	2d 93       	st	X+, r18
    1b34:	3c 93       	st	X, r19
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1b36:	80 91 9f 02 	lds	r24, 0x029F
    1b3a:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    1b3c:	80 91 a0 02 	lds	r24, 0x02A0
    1b40:	90 91 a1 02 	lds	r25, 0x02A1
    1b44:	92 83       	std	Z+2, r25	; 0x02
    1b46:	81 83       	std	Z+1, r24	; 0x01
    1b48:	80 e0       	ldi	r24, 0x00	; 0
    1b4a:	01 c0       	rjmp	.+2      	; 0x1b4e <xTaskCheckForTimeOut+0x6e>
    1b4c:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			xReturn = pdTRUE;
		}
	}
	portEXIT_CRITICAL();
    1b4e:	0f 90       	pop	r0
    1b50:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1b52:	08 95       	ret

00001b54 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    1b54:	81 e0       	ldi	r24, 0x01	; 1
    1b56:	80 93 9e 02 	sts	0x029E, r24
}
    1b5a:	08 95       	ret

00001b5c <xTaskRemoveFromEventList>:
	#endif
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    1b5c:	0f 93       	push	r16
    1b5e:	1f 93       	push	r17
    1b60:	cf 93       	push	r28
    1b62:	df 93       	push	r29
    1b64:	fc 01       	movw	r30, r24
	it to the ready list.

	If an event is for a queue that is locked then this function will never
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1b66:	80 81       	ld	r24, Z
    1b68:	88 23       	and	r24, r24
    1b6a:	19 f4       	brne	.+6      	; 0x1b72 <xTaskRemoveFromEventList+0x16>
    1b6c:	c0 e0       	ldi	r28, 0x00	; 0
    1b6e:	d0 e0       	ldi	r29, 0x00	; 0
    1b70:	05 c0       	rjmp	.+10     	; 0x1b7c <xTaskRemoveFromEventList+0x20>
    1b72:	05 80       	ldd	r0, Z+5	; 0x05
    1b74:	f6 81       	ldd	r31, Z+6	; 0x06
    1b76:	e0 2d       	mov	r30, r0
    1b78:	c6 81       	ldd	r28, Z+6	; 0x06
    1b7a:	d7 81       	ldd	r29, Z+7	; 0x07
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    1b7c:	8e 01       	movw	r16, r28
    1b7e:	04 5f       	subi	r16, 0xF4	; 244
    1b80:	1f 4f       	sbci	r17, 0xFF	; 255
    1b82:	c8 01       	movw	r24, r16
    1b84:	0e 94 fc 09 	call	0x13f8	; 0x13f8 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1b88:	80 91 a2 02 	lds	r24, 0x02A2
    1b8c:	88 23       	and	r24, r24
    1b8e:	a1 f4       	brne	.+40     	; 0x1bb8 <xTaskRemoveFromEventList+0x5c>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    1b90:	8e 01       	movw	r16, r28
    1b92:	0e 5f       	subi	r16, 0xFE	; 254
    1b94:	1f 4f       	sbci	r17, 0xFF	; 255
    1b96:	c8 01       	movw	r24, r16
    1b98:	0e 94 fc 09 	call	0x13f8	; 0x13f8 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    1b9c:	9e 89       	ldd	r25, Y+22	; 0x16
    1b9e:	80 91 a3 02 	lds	r24, 0x02A3
    1ba2:	89 17       	cp	r24, r25
    1ba4:	10 f4       	brcc	.+4      	; 0x1baa <xTaskRemoveFromEventList+0x4e>
    1ba6:	90 93 a3 02 	sts	0x02A3, r25
    1baa:	89 e0       	ldi	r24, 0x09	; 9
    1bac:	98 9f       	mul	r25, r24
    1bae:	c0 01       	movw	r24, r0
    1bb0:	11 24       	eor	r1, r1
    1bb2:	86 55       	subi	r24, 0x56	; 86
    1bb4:	9d 4f       	sbci	r25, 0xFD	; 253
    1bb6:	02 c0       	rjmp	.+4      	; 0x1bbc <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    1bb8:	84 ee       	ldi	r24, 0xE4	; 228
    1bba:	92 e0       	ldi	r25, 0x02	; 2
    1bbc:	b8 01       	movw	r22, r16
    1bbe:	0e 94 9e 09 	call	0x133c	; 0x133c <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1bc2:	e0 91 9c 02 	lds	r30, 0x029C
    1bc6:	f0 91 9d 02 	lds	r31, 0x029D
    1bca:	20 e0       	ldi	r18, 0x00	; 0
    1bcc:	9e 89       	ldd	r25, Y+22	; 0x16
    1bce:	86 89       	ldd	r24, Z+22	; 0x16
    1bd0:	98 17       	cp	r25, r24
    1bd2:	08 f0       	brcs	.+2      	; 0x1bd6 <xTaskRemoveFromEventList+0x7a>
    1bd4:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    1bd6:	82 2f       	mov	r24, r18
    1bd8:	df 91       	pop	r29
    1bda:	cf 91       	pop	r28
    1bdc:	1f 91       	pop	r17
    1bde:	0f 91       	pop	r16
    1be0:	08 95       	ret

00001be2 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
    1be2:	ff 92       	push	r15
    1be4:	0f 93       	push	r16
    1be6:	1f 93       	push	r17
    1be8:	cf 93       	push	r28
    1bea:	df 93       	push	r29
	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1bec:	80 91 a2 02 	lds	r24, 0x02A2
    1bf0:	88 23       	and	r24, r24
    1bf2:	09 f0       	breq	.+2      	; 0x1bf6 <vTaskIncrementTick+0x14>
    1bf4:	61 c0       	rjmp	.+194    	; 0x1cb8 <vTaskIncrementTick+0xd6>
	{
		++xTickCount;
    1bf6:	80 91 a0 02 	lds	r24, 0x02A0
    1bfa:	90 91 a1 02 	lds	r25, 0x02A1
    1bfe:	01 96       	adiw	r24, 0x01	; 1
    1c00:	90 93 a1 02 	sts	0x02A1, r25
    1c04:	80 93 a0 02 	sts	0x02A0, r24
		if( xTickCount == ( portTickType ) 0 )
    1c08:	80 91 a0 02 	lds	r24, 0x02A0
    1c0c:	90 91 a1 02 	lds	r25, 0x02A1
    1c10:	89 2b       	or	r24, r25
    1c12:	e9 f5       	brne	.+122    	; 0x1c8e <vTaskIncrementTick+0xac>
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			pxTemp = pxDelayedTaskList;
    1c14:	80 91 e0 02 	lds	r24, 0x02E0
    1c18:	90 91 e1 02 	lds	r25, 0x02E1
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    1c1c:	20 91 e2 02 	lds	r18, 0x02E2
    1c20:	30 91 e3 02 	lds	r19, 0x02E3
    1c24:	30 93 e1 02 	sts	0x02E1, r19
    1c28:	20 93 e0 02 	sts	0x02E0, r18
			pxOverflowDelayedTaskList = pxTemp;
    1c2c:	90 93 e3 02 	sts	0x02E3, r25
    1c30:	80 93 e2 02 	sts	0x02E2, r24
			xNumOfOverflows++;
    1c34:	80 91 9f 02 	lds	r24, 0x029F
    1c38:	8f 5f       	subi	r24, 0xFF	; 255
    1c3a:	80 93 9f 02 	sts	0x029F, r24
    1c3e:	27 c0       	rjmp	.+78     	; 0x1c8e <vTaskIncrementTick+0xac>
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    1c40:	20 91 a0 02 	lds	r18, 0x02A0
    1c44:	30 91 a1 02 	lds	r19, 0x02A1
    1c48:	8a 81       	ldd	r24, Y+2	; 0x02
    1c4a:	9b 81       	ldd	r25, Y+3	; 0x03
    1c4c:	28 17       	cp	r18, r24
    1c4e:	39 07       	cpc	r19, r25
    1c50:	c0 f1       	brcs	.+112    	; 0x1cc2 <vTaskIncrementTick+0xe0>
    1c52:	8e 01       	movw	r16, r28
    1c54:	0e 5f       	subi	r16, 0xFE	; 254
    1c56:	1f 4f       	sbci	r17, 0xFF	; 255
    1c58:	c8 01       	movw	r24, r16
    1c5a:	0e 94 fc 09 	call	0x13f8	; 0x13f8 <vListRemove>
    1c5e:	8c 89       	ldd	r24, Y+20	; 0x14
    1c60:	9d 89       	ldd	r25, Y+21	; 0x15
    1c62:	89 2b       	or	r24, r25
    1c64:	21 f0       	breq	.+8      	; 0x1c6e <vTaskIncrementTick+0x8c>
    1c66:	ce 01       	movw	r24, r28
    1c68:	0c 96       	adiw	r24, 0x0c	; 12
    1c6a:	0e 94 fc 09 	call	0x13f8	; 0x13f8 <vListRemove>
    1c6e:	9e 89       	ldd	r25, Y+22	; 0x16
    1c70:	80 91 a3 02 	lds	r24, 0x02A3
    1c74:	89 17       	cp	r24, r25
    1c76:	10 f4       	brcc	.+4      	; 0x1c7c <vTaskIncrementTick+0x9a>
    1c78:	90 93 a3 02 	sts	0x02A3, r25
    1c7c:	9f 9d       	mul	r25, r15
    1c7e:	c0 01       	movw	r24, r0
    1c80:	11 24       	eor	r1, r1
    1c82:	86 55       	subi	r24, 0x56	; 86
    1c84:	9d 4f       	sbci	r25, 0xFD	; 253
    1c86:	b8 01       	movw	r22, r16
    1c88:	0e 94 9e 09 	call	0x133c	; 0x133c <vListInsertEnd>
    1c8c:	02 c0       	rjmp	.+4      	; 0x1c92 <vTaskIncrementTick+0xb0>
    1c8e:	89 e0       	ldi	r24, 0x09	; 9
    1c90:	f8 2e       	mov	r15, r24
    1c92:	e0 91 e0 02 	lds	r30, 0x02E0
    1c96:	f0 91 e1 02 	lds	r31, 0x02E1
    1c9a:	80 81       	ld	r24, Z
    1c9c:	88 23       	and	r24, r24
    1c9e:	89 f0       	breq	.+34     	; 0x1cc2 <vTaskIncrementTick+0xe0>
    1ca0:	e0 91 e0 02 	lds	r30, 0x02E0
    1ca4:	f0 91 e1 02 	lds	r31, 0x02E1
    1ca8:	05 80       	ldd	r0, Z+5	; 0x05
    1caa:	f6 81       	ldd	r31, Z+6	; 0x06
    1cac:	e0 2d       	mov	r30, r0
    1cae:	c6 81       	ldd	r28, Z+6	; 0x06
    1cb0:	d7 81       	ldd	r29, Z+7	; 0x07
    1cb2:	20 97       	sbiw	r28, 0x00	; 0
    1cb4:	29 f6       	brne	.-118    	; 0x1c40 <vTaskIncrementTick+0x5e>
    1cb6:	05 c0       	rjmp	.+10     	; 0x1cc2 <vTaskIncrementTick+0xe0>
	}
	else
	{
		++uxMissedTicks;
    1cb8:	80 91 a4 02 	lds	r24, 0x02A4
    1cbc:	8f 5f       	subi	r24, 0xFF	; 255
    1cbe:	80 93 a4 02 	sts	0x02A4, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    1cc2:	df 91       	pop	r29
    1cc4:	cf 91       	pop	r28
    1cc6:	1f 91       	pop	r17
    1cc8:	0f 91       	pop	r16
    1cca:	ff 90       	pop	r15
    1ccc:	08 95       	ret

00001cce <vTaskPlaceOnEventList>:
	vWriteTraceToBuffer();
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    1cce:	0f 93       	push	r16
    1cd0:	1f 93       	push	r17
    1cd2:	8b 01       	movw	r16, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    1cd4:	60 91 9c 02 	lds	r22, 0x029C
    1cd8:	70 91 9d 02 	lds	r23, 0x029D
    1cdc:	64 5f       	subi	r22, 0xF4	; 244
    1cde:	7f 4f       	sbci	r23, 0xFF	; 255
    1ce0:	0e 94 c7 09 	call	0x138e	; 0x138e <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1ce4:	80 91 9c 02 	lds	r24, 0x029C
    1ce8:	90 91 9d 02 	lds	r25, 0x029D
    1cec:	02 96       	adiw	r24, 0x02	; 2
    1cee:	0e 94 fc 09 	call	0x13f8	; 0x13f8 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    1cf2:	80 91 a0 02 	lds	r24, 0x02A0
    1cf6:	90 91 a1 02 	lds	r25, 0x02A1
    1cfa:	80 0f       	add	r24, r16
    1cfc:	91 1f       	adc	r25, r17

			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    1cfe:	e0 91 9c 02 	lds	r30, 0x029C
    1d02:	f0 91 9d 02 	lds	r31, 0x029D
    1d06:	93 83       	std	Z+3, r25	; 0x03
    1d08:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xTickCount )
    1d0a:	20 91 a0 02 	lds	r18, 0x02A0
    1d0e:	30 91 a1 02 	lds	r19, 0x02A1
    1d12:	82 17       	cp	r24, r18
    1d14:	93 07       	cpc	r25, r19
    1d16:	28 f4       	brcc	.+10     	; 0x1d22 <vTaskPlaceOnEventList+0x54>
			{
				/* Wake time has overflowed.  Place this item in the overflow list. */
				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1d18:	80 91 e2 02 	lds	r24, 0x02E2
    1d1c:	90 91 e3 02 	lds	r25, 0x02E3
    1d20:	04 c0       	rjmp	.+8      	; 0x1d2a <vTaskPlaceOnEventList+0x5c>
			}
			else
			{
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1d22:	80 91 e0 02 	lds	r24, 0x02E0
    1d26:	90 91 e1 02 	lds	r25, 0x02E1
    1d2a:	60 91 9c 02 	lds	r22, 0x029C
    1d2e:	70 91 9d 02 	lds	r23, 0x029D
    1d32:	6e 5f       	subi	r22, 0xFE	; 254
    1d34:	7f 4f       	sbci	r23, 0xFF	; 255
    1d36:	0e 94 c7 09 	call	0x138e	; 0x138e <vListInsert>
			}
	}
	#endif
}
    1d3a:	1f 91       	pop	r17
    1d3c:	0f 91       	pop	r16
    1d3e:	08 95       	ret

00001d40 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    1d40:	cf 92       	push	r12
    1d42:	df 92       	push	r13
    1d44:	ff 92       	push	r15
    1d46:	0f 93       	push	r16
    1d48:	1f 93       	push	r17
    1d4a:	df 93       	push	r29
    1d4c:	cf 93       	push	r28
    1d4e:	0f 92       	push	r0
    1d50:	cd b7       	in	r28, 0x3d	; 61
    1d52:	de b7       	in	r29, 0x3e	; 62
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	portENTER_CRITICAL();
    1d54:	0f b6       	in	r0, 0x3f	; 63
    1d56:	f8 94       	cli
    1d58:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    1d5a:	80 91 a2 02 	lds	r24, 0x02A2
    1d5e:	81 50       	subi	r24, 0x01	; 1
    1d60:	80 93 a2 02 	sts	0x02A2, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1d64:	80 91 a2 02 	lds	r24, 0x02A2
    1d68:	88 23       	and	r24, r24
    1d6a:	09 f0       	breq	.+2      	; 0x1d6e <xTaskResumeAll+0x2e>
    1d6c:	5b c0       	rjmp	.+182    	; 0x1e24 <xTaskResumeAll+0xe4>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
    1d6e:	80 91 a5 02 	lds	r24, 0x02A5
    1d72:	88 23       	and	r24, r24
    1d74:	09 f4       	brne	.+2      	; 0x1d78 <xTaskResumeAll+0x38>
    1d76:	56 c0       	rjmp	.+172    	; 0x1e24 <xTaskResumeAll+0xe4>
    1d78:	19 82       	std	Y+1, r1	; 0x01
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    1d7a:	99 e0       	ldi	r25, 0x09	; 9
    1d7c:	f9 2e       	mov	r15, r25
    1d7e:	27 c0       	rjmp	.+78     	; 0x1dce <xTaskResumeAll+0x8e>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
    1d80:	c6 01       	movw	r24, r12
    1d82:	0c 96       	adiw	r24, 0x0c	; 12
    1d84:	0e 94 fc 09 	call	0x13f8	; 0x13f8 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    1d88:	86 01       	movw	r16, r12
    1d8a:	0e 5f       	subi	r16, 0xFE	; 254
    1d8c:	1f 4f       	sbci	r17, 0xFF	; 255
    1d8e:	c8 01       	movw	r24, r16
    1d90:	0e 94 fc 09 	call	0x13f8	; 0x13f8 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1d94:	d6 01       	movw	r26, r12
    1d96:	56 96       	adiw	r26, 0x16	; 22
    1d98:	9c 91       	ld	r25, X
    1d9a:	80 91 a3 02 	lds	r24, 0x02A3
    1d9e:	89 17       	cp	r24, r25
    1da0:	10 f4       	brcc	.+4      	; 0x1da6 <xTaskResumeAll+0x66>
    1da2:	90 93 a3 02 	sts	0x02A3, r25
    1da6:	9f 9d       	mul	r25, r15
    1da8:	c0 01       	movw	r24, r0
    1daa:	11 24       	eor	r1, r1
    1dac:	86 55       	subi	r24, 0x56	; 86
    1dae:	9d 4f       	sbci	r25, 0xFD	; 253
    1db0:	b8 01       	movw	r22, r16
    1db2:	0e 94 9e 09 	call	0x133c	; 0x133c <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1db6:	e0 91 9c 02 	lds	r30, 0x029C
    1dba:	f0 91 9d 02 	lds	r31, 0x029D
    1dbe:	d6 01       	movw	r26, r12
    1dc0:	56 96       	adiw	r26, 0x16	; 22
    1dc2:	9c 91       	ld	r25, X
    1dc4:	86 89       	ldd	r24, Z+22	; 0x16
    1dc6:	98 17       	cp	r25, r24
    1dc8:	10 f0       	brcs	.+4      	; 0x1dce <xTaskResumeAll+0x8e>
    1dca:	b1 e0       	ldi	r27, 0x01	; 1
    1dcc:	b9 83       	std	Y+1, r27	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
    1dce:	80 91 e4 02 	lds	r24, 0x02E4
    1dd2:	88 23       	and	r24, r24
    1dd4:	49 f0       	breq	.+18     	; 0x1de8 <xTaskResumeAll+0xa8>
    1dd6:	e0 91 e9 02 	lds	r30, 0x02E9
    1dda:	f0 91 ea 02 	lds	r31, 0x02EA
    1dde:	c6 80       	ldd	r12, Z+6	; 0x06
    1de0:	d7 80       	ldd	r13, Z+7	; 0x07
    1de2:	c1 14       	cp	r12, r1
    1de4:	d1 04       	cpc	r13, r1
    1de6:	61 f6       	brne	.-104    	; 0x1d80 <xTaskResumeAll+0x40>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    1de8:	80 91 a4 02 	lds	r24, 0x02A4
    1dec:	88 23       	and	r24, r24
    1dee:	41 f4       	brne	.+16     	; 0x1e00 <xTaskResumeAll+0xc0>
    1df0:	0c c0       	rjmp	.+24     	; 0x1e0a <xTaskResumeAll+0xca>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
    1df2:	0e 94 f1 0d 	call	0x1be2	; 0x1be2 <vTaskIncrementTick>
						--uxMissedTicks;
    1df6:	80 91 a4 02 	lds	r24, 0x02A4
    1dfa:	81 50       	subi	r24, 0x01	; 1
    1dfc:	80 93 a4 02 	sts	0x02A4, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    1e00:	80 91 a4 02 	lds	r24, 0x02A4
    1e04:	88 23       	and	r24, r24
    1e06:	a9 f7       	brne	.-22     	; 0x1df2 <xTaskResumeAll+0xb2>
    1e08:	07 c0       	rjmp	.+14     	; 0x1e18 <xTaskResumeAll+0xd8>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    1e0a:	e9 81       	ldd	r30, Y+1	; 0x01
    1e0c:	e1 30       	cpi	r30, 0x01	; 1
    1e0e:	21 f0       	breq	.+8      	; 0x1e18 <xTaskResumeAll+0xd8>
    1e10:	80 91 9e 02 	lds	r24, 0x029E
    1e14:	81 30       	cpi	r24, 0x01	; 1
    1e16:	31 f4       	brne	.+12     	; 0x1e24 <xTaskResumeAll+0xe4>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    1e18:	10 92 9e 02 	sts	0x029E, r1
					portYIELD_WITHIN_API();
    1e1c:	0e 94 76 12 	call	0x24ec	; 0x24ec <vPortYield>
    1e20:	81 e0       	ldi	r24, 0x01	; 1
    1e22:	01 c0       	rjmp	.+2      	; 0x1e26 <xTaskResumeAll+0xe6>
    1e24:	80 e0       	ldi	r24, 0x00	; 0
				}
			}
		}
	}
	portEXIT_CRITICAL();
    1e26:	0f 90       	pop	r0
    1e28:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    1e2a:	0f 90       	pop	r0
    1e2c:	cf 91       	pop	r28
    1e2e:	df 91       	pop	r29
    1e30:	1f 91       	pop	r17
    1e32:	0f 91       	pop	r16
    1e34:	ff 90       	pop	r15
    1e36:	df 90       	pop	r13
    1e38:	cf 90       	pop	r12
    1e3a:	08 95       	ret

00001e3c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1e3c:	0f 93       	push	r16
    1e3e:	1f 93       	push	r17
    1e40:	9c 01       	movw	r18, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
    1e42:	00 97       	sbiw	r24, 0x00	; 0
    1e44:	a1 f1       	breq	.+104    	; 0x1eae <vTaskDelay+0x72>

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    1e46:	80 91 a2 02 	lds	r24, 0x02A2
    1e4a:	8f 5f       	subi	r24, 0xFF	; 255
    1e4c:	80 93 a2 02 	sts	0x02A2, r24
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1e50:	00 91 a0 02 	lds	r16, 0x02A0
    1e54:	10 91 a1 02 	lds	r17, 0x02A1
    1e58:	02 0f       	add	r16, r18
    1e5a:	13 1f       	adc	r17, r19

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1e5c:	80 91 9c 02 	lds	r24, 0x029C
    1e60:	90 91 9d 02 	lds	r25, 0x029D
    1e64:	02 96       	adiw	r24, 0x02	; 2
    1e66:	0e 94 fc 09 	call	0x13f8	; 0x13f8 <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    1e6a:	e0 91 9c 02 	lds	r30, 0x029C
    1e6e:	f0 91 9d 02 	lds	r31, 0x029D
    1e72:	13 83       	std	Z+3, r17	; 0x03
    1e74:	02 83       	std	Z+2, r16	; 0x02

				if( xTimeToWake < xTickCount )
    1e76:	80 91 a0 02 	lds	r24, 0x02A0
    1e7a:	90 91 a1 02 	lds	r25, 0x02A1
    1e7e:	08 17       	cp	r16, r24
    1e80:	19 07       	cpc	r17, r25
    1e82:	28 f4       	brcc	.+10     	; 0x1e8e <vTaskDelay+0x52>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1e84:	80 91 e2 02 	lds	r24, 0x02E2
    1e88:	90 91 e3 02 	lds	r25, 0x02E3
    1e8c:	04 c0       	rjmp	.+8      	; 0x1e96 <vTaskDelay+0x5a>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1e8e:	80 91 e0 02 	lds	r24, 0x02E0
    1e92:	90 91 e1 02 	lds	r25, 0x02E1
    1e96:	60 91 9c 02 	lds	r22, 0x029C
    1e9a:	70 91 9d 02 	lds	r23, 0x029D
    1e9e:	6e 5f       	subi	r22, 0xFE	; 254
    1ea0:	7f 4f       	sbci	r23, 0xFF	; 255
    1ea2:	0e 94 c7 09 	call	0x138e	; 0x138e <vListInsert>
				}
			}
			xAlreadyYielded = xTaskResumeAll();
    1ea6:	0e 94 a0 0e 	call	0x1d40	; 0x1d40 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
    1eaa:	88 23       	and	r24, r24
    1eac:	11 f4       	brne	.+4      	; 0x1eb2 <vTaskDelay+0x76>
		{
			portYIELD_WITHIN_API();
    1eae:	0e 94 76 12 	call	0x24ec	; 0x24ec <vPortYield>
		}
	}
    1eb2:	1f 91       	pop	r17
    1eb4:	0f 91       	pop	r16
    1eb6:	08 95       	ret

00001eb8 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    1eb8:	cf 93       	push	r28
    1eba:	df 93       	push	r29
    1ebc:	fc 01       	movw	r30, r24
    1ebe:	eb 01       	movw	r28, r22

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    1ec0:	80 91 a2 02 	lds	r24, 0x02A2
    1ec4:	8f 5f       	subi	r24, 0xFF	; 255
    1ec6:	80 93 a2 02 	sts	0x02A2, r24
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		vTaskSuspendAll();
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1eca:	20 81       	ld	r18, Z
    1ecc:	31 81       	ldd	r19, Z+1	; 0x01
    1ece:	c2 0f       	add	r28, r18
    1ed0:	d3 1f       	adc	r29, r19

			if( xTickCount < *pxPreviousWakeTime )
    1ed2:	80 91 a0 02 	lds	r24, 0x02A0
    1ed6:	90 91 a1 02 	lds	r25, 0x02A1
    1eda:	82 17       	cp	r24, r18
    1edc:	93 07       	cpc	r25, r19
    1ede:	28 f4       	brcc	.+10     	; 0x1eea <vTaskDelayUntil+0x32>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    1ee0:	c2 17       	cp	r28, r18
    1ee2:	d3 07       	cpc	r29, r19
    1ee4:	28 f0       	brcs	.+10     	; 0x1ef0 <vTaskDelayUntil+0x38>
    1ee6:	20 e0       	ldi	r18, 0x00	; 0
    1ee8:	0c c0       	rjmp	.+24     	; 0x1f02 <vTaskDelayUntil+0x4a>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    1eea:	c2 17       	cp	r28, r18
    1eec:	d3 07       	cpc	r29, r19
    1eee:	40 f0       	brcs	.+16     	; 0x1f00 <vTaskDelayUntil+0x48>
    1ef0:	80 91 a0 02 	lds	r24, 0x02A0
    1ef4:	90 91 a1 02 	lds	r25, 0x02A1
    1ef8:	20 e0       	ldi	r18, 0x00	; 0
    1efa:	8c 17       	cp	r24, r28
    1efc:	9d 07       	cpc	r25, r29
    1efe:	08 f4       	brcc	.+2      	; 0x1f02 <vTaskDelayUntil+0x4a>
    1f00:	21 e0       	ldi	r18, 0x01	; 1
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1f02:	d1 83       	std	Z+1, r29	; 0x01
    1f04:	c0 83       	st	Z, r28

			if( xShouldDelay )
    1f06:	22 23       	and	r18, r18
    1f08:	29 f1       	breq	.+74     	; 0x1f54 <vTaskDelayUntil+0x9c>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1f0a:	80 91 9c 02 	lds	r24, 0x029C
    1f0e:	90 91 9d 02 	lds	r25, 0x029D
    1f12:	02 96       	adiw	r24, 0x02	; 2
    1f14:	0e 94 fc 09 	call	0x13f8	; 0x13f8 <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    1f18:	e0 91 9c 02 	lds	r30, 0x029C
    1f1c:	f0 91 9d 02 	lds	r31, 0x029D
    1f20:	d3 83       	std	Z+3, r29	; 0x03
    1f22:	c2 83       	std	Z+2, r28	; 0x02

				if( xTimeToWake < xTickCount )
    1f24:	80 91 a0 02 	lds	r24, 0x02A0
    1f28:	90 91 a1 02 	lds	r25, 0x02A1
    1f2c:	c8 17       	cp	r28, r24
    1f2e:	d9 07       	cpc	r29, r25
    1f30:	28 f4       	brcc	.+10     	; 0x1f3c <vTaskDelayUntil+0x84>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1f32:	80 91 e2 02 	lds	r24, 0x02E2
    1f36:	90 91 e3 02 	lds	r25, 0x02E3
    1f3a:	04 c0       	rjmp	.+8      	; 0x1f44 <vTaskDelayUntil+0x8c>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1f3c:	80 91 e0 02 	lds	r24, 0x02E0
    1f40:	90 91 e1 02 	lds	r25, 0x02E1
    1f44:	60 91 9c 02 	lds	r22, 0x029C
    1f48:	70 91 9d 02 	lds	r23, 0x029D
    1f4c:	6e 5f       	subi	r22, 0xFE	; 254
    1f4e:	7f 4f       	sbci	r23, 0xFF	; 255
    1f50:	0e 94 c7 09 	call	0x138e	; 0x138e <vListInsert>
				}
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1f54:	0e 94 a0 0e 	call	0x1d40	; 0x1d40 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
    1f58:	88 23       	and	r24, r24
    1f5a:	11 f4       	brne	.+4      	; 0x1f60 <vTaskDelayUntil+0xa8>
		{
			portYIELD_WITHIN_API();
    1f5c:	0e 94 76 12 	call	0x24ec	; 0x24ec <vPortYield>
		}
	}
    1f60:	df 91       	pop	r29
    1f62:	cf 91       	pop	r28
    1f64:	08 95       	ret

00001f66 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    1f66:	ef 92       	push	r14
    1f68:	ff 92       	push	r15
    1f6a:	0f 93       	push	r16
    1f6c:	1f 93       	push	r17
    1f6e:	cf 93       	push	r28
    1f70:	df 93       	push	r29
    1f72:	8c 01       	movw	r16, r24
	tskTCB *pxTCB;

		portENTER_CRITICAL();
    1f74:	0f b6       	in	r0, 0x3f	; 63
    1f76:	f8 94       	cli
    1f78:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    1f7a:	80 91 9c 02 	lds	r24, 0x029C
    1f7e:	90 91 9d 02 	lds	r25, 0x029D
    1f82:	08 17       	cp	r16, r24
    1f84:	19 07       	cpc	r17, r25
    1f86:	19 f4       	brne	.+6      	; 0x1f8e <vTaskDelete+0x28>
    1f88:	00 e0       	ldi	r16, 0x00	; 0
    1f8a:	10 e0       	ldi	r17, 0x00	; 0
    1f8c:	03 c0       	rjmp	.+6      	; 0x1f94 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    1f8e:	01 15       	cp	r16, r1
    1f90:	11 05       	cpc	r17, r1
    1f92:	29 f4       	brne	.+10     	; 0x1f9e <vTaskDelete+0x38>
    1f94:	c0 91 9c 02 	lds	r28, 0x029C
    1f98:	d0 91 9d 02 	lds	r29, 0x029D
    1f9c:	01 c0       	rjmp	.+2      	; 0x1fa0 <vTaskDelete+0x3a>
    1f9e:	e8 01       	movw	r28, r16

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    1fa0:	22 e0       	ldi	r18, 0x02	; 2
    1fa2:	e2 2e       	mov	r14, r18
    1fa4:	f1 2c       	mov	r15, r1
    1fa6:	ec 0e       	add	r14, r28
    1fa8:	fd 1e       	adc	r15, r29
    1faa:	c7 01       	movw	r24, r14
    1fac:	0e 94 fc 09 	call	0x13f8	; 0x13f8 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer )
    1fb0:	8c 89       	ldd	r24, Y+20	; 0x14
    1fb2:	9d 89       	ldd	r25, Y+21	; 0x15
    1fb4:	89 2b       	or	r24, r25
    1fb6:	21 f0       	breq	.+8      	; 0x1fc0 <vTaskDelete+0x5a>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    1fb8:	ce 01       	movw	r24, r28
    1fba:	0c 96       	adiw	r24, 0x0c	; 12
    1fbc:	0e 94 fc 09 	call	0x13f8	; 0x13f8 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    1fc0:	8d ee       	ldi	r24, 0xED	; 237
    1fc2:	92 e0       	ldi	r25, 0x02	; 2
    1fc4:	b7 01       	movw	r22, r14
    1fc6:	0e 94 9e 09 	call	0x133c	; 0x133c <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    1fca:	80 91 a7 02 	lds	r24, 0x02A7
    1fce:	8f 5f       	subi	r24, 0xFF	; 255
    1fd0:	80 93 a7 02 	sts	0x02A7, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    1fd4:	80 91 a8 02 	lds	r24, 0x02A8
    1fd8:	8f 5f       	subi	r24, 0xFF	; 255
    1fda:	80 93 a8 02 	sts	0x02A8, r24

			traceTASK_DELETE( pxTCB );
		}
		portEXIT_CRITICAL();
    1fde:	0f 90       	pop	r0
    1fe0:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    1fe2:	80 91 a6 02 	lds	r24, 0x02A6
    1fe6:	88 23       	and	r24, r24
    1fe8:	21 f0       	breq	.+8      	; 0x1ff2 <vTaskDelete+0x8c>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    1fea:	01 2b       	or	r16, r17
    1fec:	11 f4       	brne	.+4      	; 0x1ff2 <vTaskDelete+0x8c>
			{
				portYIELD_WITHIN_API();
    1fee:	0e 94 76 12 	call	0x24ec	; 0x24ec <vPortYield>
			}
		}
	}
    1ff2:	df 91       	pop	r29
    1ff4:	cf 91       	pop	r28
    1ff6:	1f 91       	pop	r17
    1ff8:	0f 91       	pop	r16
    1ffa:	ff 90       	pop	r15
    1ffc:	ef 90       	pop	r14
    1ffe:	08 95       	ret

00002000 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    2000:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    2002:	10 92 a6 02 	sts	0x02A6, r1
	vPortEndScheduler();
    2006:	0e 94 17 12 	call	0x242e	; 0x242e <vPortEndScheduler>
}
    200a:	08 95       	ret

0000200c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    200c:	1f 93       	push	r17
    200e:	cf 93       	push	r28
    2010:	df 93       	push	r29
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
    2012:	80 91 a7 02 	lds	r24, 0x02A7
    2016:	88 23       	and	r24, r24
    2018:	91 f1       	breq	.+100    	; 0x207e <prvIdleTask+0x72>

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    201a:	80 91 a2 02 	lds	r24, 0x02A2
    201e:	8f 5f       	subi	r24, 0xFF	; 255
    2020:	80 93 a2 02 	sts	0x02A2, r24
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    2024:	10 91 ed 02 	lds	r17, 0x02ED
			xTaskResumeAll();
    2028:	0e 94 a0 0e 	call	0x1d40	; 0x1d40 <xTaskResumeAll>

			if( !xListIsEmpty )
    202c:	11 23       	and	r17, r17
    202e:	39 f1       	breq	.+78     	; 0x207e <prvIdleTask+0x72>
			{
				tskTCB *pxTCB;

				portENTER_CRITICAL();
    2030:	0f b6       	in	r0, 0x3f	; 63
    2032:	f8 94       	cli
    2034:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    2036:	80 91 ed 02 	lds	r24, 0x02ED
    203a:	88 23       	and	r24, r24
    203c:	19 f4       	brne	.+6      	; 0x2044 <prvIdleTask+0x38>
    203e:	c0 e0       	ldi	r28, 0x00	; 0
    2040:	d0 e0       	ldi	r29, 0x00	; 0
    2042:	06 c0       	rjmp	.+12     	; 0x2050 <prvIdleTask+0x44>
    2044:	e0 91 f2 02 	lds	r30, 0x02F2
    2048:	f0 91 f3 02 	lds	r31, 0x02F3
    204c:	c6 81       	ldd	r28, Z+6	; 0x06
    204e:	d7 81       	ldd	r29, Z+7	; 0x07
					vListRemove( &( pxTCB->xGenericListItem ) );
    2050:	ce 01       	movw	r24, r28
    2052:	02 96       	adiw	r24, 0x02	; 2
    2054:	0e 94 fc 09 	call	0x13f8	; 0x13f8 <vListRemove>
					--uxCurrentNumberOfTasks;
    2058:	80 91 a5 02 	lds	r24, 0x02A5
    205c:	81 50       	subi	r24, 0x01	; 1
    205e:	80 93 a5 02 	sts	0x02A5, r24
					--uxTasksDeleted;
    2062:	80 91 a7 02 	lds	r24, 0x02A7
    2066:	81 50       	subi	r24, 0x01	; 1
    2068:	80 93 a7 02 	sts	0x02A7, r24
				}
				portEXIT_CRITICAL();
    206c:	0f 90       	pop	r0
    206e:	0f be       	out	0x3f, r0	; 63

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    2070:	8f 89       	ldd	r24, Y+23	; 0x17
    2072:	98 8d       	ldd	r25, Y+24	; 0x18
    2074:	0e 94 99 14 	call	0x2932	; 0x2932 <vPortFree>
		vPortFree( pxTCB );
    2078:	ce 01       	movw	r24, r28
    207a:	0e 94 99 14 	call	0x2932	; 0x2932 <vPortFree>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    207e:	80 91 aa 02 	lds	r24, 0x02AA
    2082:	82 30       	cpi	r24, 0x02	; 2
    2084:	30 f2       	brcs	.-116    	; 0x2012 <prvIdleTask+0x6>
			{
				taskYIELD();
    2086:	0e 94 76 12 	call	0x24ec	; 0x24ec <vPortYield>
    208a:	c3 cf       	rjmp	.-122    	; 0x2012 <prvIdleTask+0x6>

0000208c <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    208c:	2f 92       	push	r2
    208e:	3f 92       	push	r3
    2090:	5f 92       	push	r5
    2092:	6f 92       	push	r6
    2094:	7f 92       	push	r7
    2096:	8f 92       	push	r8
    2098:	9f 92       	push	r9
    209a:	af 92       	push	r10
    209c:	bf 92       	push	r11
    209e:	cf 92       	push	r12
    20a0:	df 92       	push	r13
    20a2:	ef 92       	push	r14
    20a4:	ff 92       	push	r15
    20a6:	0f 93       	push	r16
    20a8:	1f 93       	push	r17
    20aa:	df 93       	push	r29
    20ac:	cf 93       	push	r28
    20ae:	00 d0       	rcall	.+0      	; 0x20b0 <xTaskGenericCreate+0x24>
    20b0:	00 d0       	rcall	.+0      	; 0x20b2 <xTaskGenericCreate+0x26>
    20b2:	cd b7       	in	r28, 0x3d	; 61
    20b4:	de b7       	in	r29, 0x3e	; 62
    20b6:	9a 83       	std	Y+2, r25	; 0x02
    20b8:	89 83       	std	Y+1, r24	; 0x01
    20ba:	4b 01       	movw	r8, r22
    20bc:	5a 01       	movw	r10, r20
    20be:	19 01       	movw	r2, r18
    20c0:	50 2e       	mov	r5, r16
    20c2:	37 01       	movw	r6, r14
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    20c4:	81 e2       	ldi	r24, 0x21	; 33
    20c6:	90 e0       	ldi	r25, 0x00	; 0
    20c8:	0e 94 a9 14 	call	0x2952	; 0x2952 <pvPortMalloc>
    20cc:	8b 83       	std	Y+3, r24	; 0x03
    20ce:	9c 83       	std	Y+4, r25	; 0x04

	if( pxNewTCB != NULL )
    20d0:	8b 81       	ldd	r24, Y+3	; 0x03
    20d2:	9c 81       	ldd	r25, Y+4	; 0x04
    20d4:	89 2b       	or	r24, r25
    20d6:	89 f0       	breq	.+34     	; 0x20fa <xTaskGenericCreate+0x6e>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    20d8:	c1 14       	cp	r12, r1
    20da:	d1 04       	cpc	r13, r1
    20dc:	21 f4       	brne	.+8      	; 0x20e6 <xTaskGenericCreate+0x5a>
    20de:	c5 01       	movw	r24, r10
    20e0:	0e 94 a9 14 	call	0x2952	; 0x2952 <pvPortMalloc>
    20e4:	6c 01       	movw	r12, r24
    20e6:	eb 81       	ldd	r30, Y+3	; 0x03
    20e8:	fc 81       	ldd	r31, Y+4	; 0x04
    20ea:	d0 8e       	std	Z+24, r13	; 0x18
    20ec:	c7 8a       	std	Z+23, r12	; 0x17

		if( pxNewTCB->pxStack == NULL )
    20ee:	c1 14       	cp	r12, r1
    20f0:	d1 04       	cpc	r13, r1
    20f2:	29 f4       	brne	.+10     	; 0x20fe <xTaskGenericCreate+0x72>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    20f4:	cf 01       	movw	r24, r30
    20f6:	0e 94 99 14 	call	0x2932	; 0x2932 <vPortFree>
    20fa:	8f ef       	ldi	r24, 0xFF	; 255
    20fc:	d5 c0       	rjmp	.+426    	; 0x22a8 <__stack+0xa9>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
    20fe:	c6 01       	movw	r24, r12
    2100:	65 ea       	ldi	r22, 0xA5	; 165
    2102:	70 e0       	ldi	r23, 0x00	; 0
    2104:	a5 01       	movw	r20, r10
    2106:	0e 94 89 26 	call	0x4d12	; 0x4d12 <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
    210a:	08 94       	sec
    210c:	a1 08       	sbc	r10, r1
    210e:	b1 08       	sbc	r11, r1
    2110:	eb 81       	ldd	r30, Y+3	; 0x03
    2112:	fc 81       	ldd	r31, Y+4	; 0x04
    2114:	e7 88       	ldd	r14, Z+23	; 0x17
    2116:	f0 8c       	ldd	r15, Z+24	; 0x18
    2118:	ea 0c       	add	r14, r10
    211a:	fb 1c       	adc	r15, r11
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    211c:	cf 01       	movw	r24, r30
    211e:	49 96       	adiw	r24, 0x19	; 25
    2120:	b4 01       	movw	r22, r8
    2122:	48 e0       	ldi	r20, 0x08	; 8
    2124:	50 e0       	ldi	r21, 0x00	; 0
    2126:	0e 94 90 26 	call	0x4d20	; 0x4d20 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
    212a:	eb 81       	ldd	r30, Y+3	; 0x03
    212c:	fc 81       	ldd	r31, Y+4	; 0x04
    212e:	10 a2       	std	Z+32, r1	; 0x20
    2130:	05 2d       	mov	r16, r5
    2132:	f3 e0       	ldi	r31, 0x03	; 3
    2134:	f5 15       	cp	r31, r5
    2136:	08 f4       	brcc	.+2      	; 0x213a <xTaskGenericCreate+0xae>
    2138:	03 e0       	ldi	r16, 0x03	; 3
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - 1;
	}

	pxTCB->uxPriority = uxPriority;
    213a:	eb 81       	ldd	r30, Y+3	; 0x03
    213c:	fc 81       	ldd	r31, Y+4	; 0x04
    213e:	06 8b       	std	Z+22, r16	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    2140:	42 e0       	ldi	r20, 0x02	; 2
    2142:	c4 2e       	mov	r12, r20
    2144:	d1 2c       	mov	r13, r1
    2146:	ce 0e       	add	r12, r30
    2148:	df 1e       	adc	r13, r31
    214a:	c6 01       	movw	r24, r12
    214c:	0e 94 9a 09 	call	0x1334	; 0x1334 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    2150:	8b 81       	ldd	r24, Y+3	; 0x03
    2152:	9c 81       	ldd	r25, Y+4	; 0x04
    2154:	0c 96       	adiw	r24, 0x0c	; 12
    2156:	0e 94 9a 09 	call	0x1334	; 0x1334 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    215a:	8b 81       	ldd	r24, Y+3	; 0x03
    215c:	9c 81       	ldd	r25, Y+4	; 0x04
    215e:	fc 01       	movw	r30, r24
    2160:	91 87       	std	Z+9, r25	; 0x09
    2162:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    2164:	84 e0       	ldi	r24, 0x04	; 4
    2166:	90 e0       	ldi	r25, 0x00	; 0
    2168:	80 1b       	sub	r24, r16
    216a:	91 09       	sbc	r25, r1
    216c:	95 87       	std	Z+13, r25	; 0x0d
    216e:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    2170:	f3 8b       	std	Z+19, r31	; 0x13
    2172:	e2 8b       	std	Z+18, r30	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    2174:	c7 01       	movw	r24, r14
    2176:	69 81       	ldd	r22, Y+1	; 0x01
    2178:	7a 81       	ldd	r23, Y+2	; 0x02
    217a:	a1 01       	movw	r20, r2
    217c:	0e 94 95 11 	call	0x232a	; 0x232a <pxPortInitialiseStack>
    2180:	eb 81       	ldd	r30, Y+3	; 0x03
    2182:	fc 81       	ldd	r31, Y+4	; 0x04
    2184:	91 83       	std	Z+1, r25	; 0x01
    2186:	80 83       	st	Z, r24
		}
		#endif

		if( ( void * ) pxCreatedTask != NULL )
    2188:	61 14       	cp	r6, r1
    218a:	71 04       	cpc	r7, r1
    218c:	21 f0       	breq	.+8      	; 0x2196 <xTaskGenericCreate+0x10a>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    218e:	cf 01       	movw	r24, r30
    2190:	f3 01       	movw	r30, r6
    2192:	91 83       	std	Z+1, r25	; 0x01
    2194:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		portENTER_CRITICAL();
    2196:	0f b6       	in	r0, 0x3f	; 63
    2198:	f8 94       	cli
    219a:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    219c:	80 91 a5 02 	lds	r24, 0x02A5
    21a0:	8f 5f       	subi	r24, 0xFF	; 255
    21a2:	80 93 a5 02 	sts	0x02A5, r24
			if( pxCurrentTCB == NULL )
    21a6:	80 91 9c 02 	lds	r24, 0x029C
    21aa:	90 91 9d 02 	lds	r25, 0x029D
    21ae:	89 2b       	or	r24, r25
    21b0:	b9 f5       	brne	.+110    	; 0x2220 <__stack+0x21>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    21b2:	eb 81       	ldd	r30, Y+3	; 0x03
    21b4:	fc 81       	ldd	r31, Y+4	; 0x04
    21b6:	f0 93 9d 02 	sts	0x029D, r31
    21ba:	e0 93 9c 02 	sts	0x029C, r30

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    21be:	80 91 a5 02 	lds	r24, 0x02A5
    21c2:	81 30       	cpi	r24, 0x01	; 1
    21c4:	f1 f5       	brne	.+124    	; 0x2242 <__stack+0x43>
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    21c6:	8a ea       	ldi	r24, 0xAA	; 170
    21c8:	92 e0       	ldi	r25, 0x02	; 2
    21ca:	0e 94 8a 09 	call	0x1314	; 0x1314 <vListInitialise>
    21ce:	83 eb       	ldi	r24, 0xB3	; 179
    21d0:	92 e0       	ldi	r25, 0x02	; 2
    21d2:	0e 94 8a 09 	call	0x1314	; 0x1314 <vListInitialise>
    21d6:	8c eb       	ldi	r24, 0xBC	; 188
    21d8:	92 e0       	ldi	r25, 0x02	; 2
    21da:	0e 94 8a 09 	call	0x1314	; 0x1314 <vListInitialise>
    21de:	85 ec       	ldi	r24, 0xC5	; 197
    21e0:	92 e0       	ldi	r25, 0x02	; 2
    21e2:	0e 94 8a 09 	call	0x1314	; 0x1314 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    21e6:	3e ec       	ldi	r19, 0xCE	; 206
    21e8:	e3 2e       	mov	r14, r19
    21ea:	32 e0       	ldi	r19, 0x02	; 2
    21ec:	f3 2e       	mov	r15, r19
    21ee:	c7 01       	movw	r24, r14
    21f0:	0e 94 8a 09 	call	0x1314	; 0x1314 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    21f4:	07 ed       	ldi	r16, 0xD7	; 215
    21f6:	12 e0       	ldi	r17, 0x02	; 2
    21f8:	c8 01       	movw	r24, r16
    21fa:	0e 94 8a 09 	call	0x1314	; 0x1314 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    21fe:	84 ee       	ldi	r24, 0xE4	; 228
    2200:	92 e0       	ldi	r25, 0x02	; 2
    2202:	0e 94 8a 09 	call	0x1314	; 0x1314 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    2206:	8d ee       	ldi	r24, 0xED	; 237
    2208:	92 e0       	ldi	r25, 0x02	; 2
    220a:	0e 94 8a 09 	call	0x1314	; 0x1314 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    220e:	f0 92 e1 02 	sts	0x02E1, r15
    2212:	e0 92 e0 02 	sts	0x02E0, r14
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    2216:	10 93 e3 02 	sts	0x02E3, r17
    221a:	00 93 e2 02 	sts	0x02E2, r16
    221e:	11 c0       	rjmp	.+34     	; 0x2242 <__stack+0x43>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    2220:	80 91 a6 02 	lds	r24, 0x02A6
    2224:	88 23       	and	r24, r24
    2226:	69 f4       	brne	.+26     	; 0x2242 <__stack+0x43>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    2228:	e0 91 9c 02 	lds	r30, 0x029C
    222c:	f0 91 9d 02 	lds	r31, 0x029D
    2230:	86 89       	ldd	r24, Z+22	; 0x16
    2232:	58 16       	cp	r5, r24
    2234:	30 f0       	brcs	.+12     	; 0x2242 <__stack+0x43>
					{
						pxCurrentTCB = pxNewTCB;
    2236:	8b 81       	ldd	r24, Y+3	; 0x03
    2238:	9c 81       	ldd	r25, Y+4	; 0x04
    223a:	90 93 9d 02 	sts	0x029D, r25
    223e:	80 93 9c 02 	sts	0x029C, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    2242:	eb 81       	ldd	r30, Y+3	; 0x03
    2244:	fc 81       	ldd	r31, Y+4	; 0x04
    2246:	96 89       	ldd	r25, Z+22	; 0x16
    2248:	80 91 a9 02 	lds	r24, 0x02A9
    224c:	89 17       	cp	r24, r25
    224e:	10 f4       	brcc	.+4      	; 0x2254 <__stack+0x55>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    2250:	90 93 a9 02 	sts	0x02A9, r25
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    2254:	80 91 a8 02 	lds	r24, 0x02A8
    2258:	8f 5f       	subi	r24, 0xFF	; 255
    225a:	80 93 a8 02 	sts	0x02A8, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    225e:	eb 81       	ldd	r30, Y+3	; 0x03
    2260:	fc 81       	ldd	r31, Y+4	; 0x04
    2262:	96 89       	ldd	r25, Z+22	; 0x16
    2264:	80 91 a3 02 	lds	r24, 0x02A3
    2268:	89 17       	cp	r24, r25
    226a:	10 f4       	brcc	.+4      	; 0x2270 <__stack+0x71>
    226c:	90 93 a3 02 	sts	0x02A3, r25
    2270:	eb 81       	ldd	r30, Y+3	; 0x03
    2272:	fc 81       	ldd	r31, Y+4	; 0x04
    2274:	86 89       	ldd	r24, Z+22	; 0x16
    2276:	29 e0       	ldi	r18, 0x09	; 9
    2278:	82 9f       	mul	r24, r18
    227a:	c0 01       	movw	r24, r0
    227c:	11 24       	eor	r1, r1
    227e:	86 55       	subi	r24, 0x56	; 86
    2280:	9d 4f       	sbci	r25, 0xFD	; 253
    2282:	b6 01       	movw	r22, r12
    2284:	0e 94 9e 09 	call	0x133c	; 0x133c <vListInsertEnd>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		portEXIT_CRITICAL();
    2288:	0f 90       	pop	r0
    228a:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED( pxNewTCB );
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    228c:	80 91 a6 02 	lds	r24, 0x02A6
    2290:	88 23       	and	r24, r24
    2292:	49 f0       	breq	.+18     	; 0x22a6 <__stack+0xa7>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    2294:	e0 91 9c 02 	lds	r30, 0x029C
    2298:	f0 91 9d 02 	lds	r31, 0x029D
    229c:	86 89       	ldd	r24, Z+22	; 0x16
    229e:	85 15       	cp	r24, r5
    22a0:	10 f4       	brcc	.+4      	; 0x22a6 <__stack+0xa7>
			{
				portYIELD_WITHIN_API();
    22a2:	0e 94 76 12 	call	0x24ec	; 0x24ec <vPortYield>
    22a6:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    22a8:	0f 90       	pop	r0
    22aa:	0f 90       	pop	r0
    22ac:	0f 90       	pop	r0
    22ae:	0f 90       	pop	r0
    22b0:	cf 91       	pop	r28
    22b2:	df 91       	pop	r29
    22b4:	1f 91       	pop	r17
    22b6:	0f 91       	pop	r16
    22b8:	ff 90       	pop	r15
    22ba:	ef 90       	pop	r14
    22bc:	df 90       	pop	r13
    22be:	cf 90       	pop	r12
    22c0:	bf 90       	pop	r11
    22c2:	af 90       	pop	r10
    22c4:	9f 90       	pop	r9
    22c6:	8f 90       	pop	r8
    22c8:	7f 90       	pop	r7
    22ca:	6f 90       	pop	r6
    22cc:	5f 90       	pop	r5
    22ce:	3f 90       	pop	r3
    22d0:	2f 90       	pop	r2
    22d2:	08 95       	ret

000022d4 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    22d4:	af 92       	push	r10
    22d6:	bf 92       	push	r11
    22d8:	cf 92       	push	r12
    22da:	df 92       	push	r13
    22dc:	ef 92       	push	r14
    22de:	ff 92       	push	r15
    22e0:	0f 93       	push	r16
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
    22e2:	86 e0       	ldi	r24, 0x06	; 6
    22e4:	90 e1       	ldi	r25, 0x10	; 16
    22e6:	62 e9       	ldi	r22, 0x92	; 146
    22e8:	72 e0       	ldi	r23, 0x02	; 2
    22ea:	45 e5       	ldi	r20, 0x55	; 85
    22ec:	50 e0       	ldi	r21, 0x00	; 0
    22ee:	20 e0       	ldi	r18, 0x00	; 0
    22f0:	30 e0       	ldi	r19, 0x00	; 0
    22f2:	00 e0       	ldi	r16, 0x00	; 0
    22f4:	ee 24       	eor	r14, r14
    22f6:	ff 24       	eor	r15, r15
    22f8:	cc 24       	eor	r12, r12
    22fa:	dd 24       	eor	r13, r13
    22fc:	aa 24       	eor	r10, r10
    22fe:	bb 24       	eor	r11, r11
    2300:	0e 94 46 10 	call	0x208c	; 0x208c <xTaskGenericCreate>

	if( xReturn == pdPASS )
    2304:	81 30       	cpi	r24, 0x01	; 1
    2306:	49 f4       	brne	.+18     	; 0x231a <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    2308:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    230a:	80 93 a6 02 	sts	0x02A6, r24
		xTickCount = ( portTickType ) 0;
    230e:	10 92 a1 02 	sts	0x02A1, r1
    2312:	10 92 a0 02 	sts	0x02A0, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
    2316:	0e 94 dd 11 	call	0x23ba	; 0x23ba <xPortStartScheduler>
		else
		{
			/* Should only reach here if a task calls xTaskEndScheduler(). */
		}
	}
}
    231a:	0f 91       	pop	r16
    231c:	ff 90       	pop	r15
    231e:	ef 90       	pop	r14
    2320:	df 90       	pop	r13
    2322:	cf 90       	pop	r12
    2324:	bf 90       	pop	r11
    2326:	af 90       	pop	r10
    2328:	08 95       	ret

0000232a <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    232a:	fc 01       	movw	r30, r24
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    232c:	91 e1       	ldi	r25, 0x11	; 17
    232e:	90 83       	st	Z, r25
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    2330:	22 e2       	ldi	r18, 0x22	; 34
    2332:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    2334:	83 e3       	ldi	r24, 0x33	; 51
    2336:	82 93       	st	-Z, r24
	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	

	usAddress = ( unsigned short ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2338:	62 93       	st	-Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    233a:	72 93       	st	-Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    233c:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    233e:	80 e8       	ldi	r24, 0x80	; 128
    2340:	82 93       	st	-Z, r24
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    2342:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    2344:	82 e0       	ldi	r24, 0x02	; 2
    2346:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    2348:	83 e0       	ldi	r24, 0x03	; 3
    234a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    234c:	84 e0       	ldi	r24, 0x04	; 4
    234e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    2350:	85 e0       	ldi	r24, 0x05	; 5
    2352:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    2354:	86 e0       	ldi	r24, 0x06	; 6
    2356:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    2358:	87 e0       	ldi	r24, 0x07	; 7
    235a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    235c:	88 e0       	ldi	r24, 0x08	; 8
    235e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    2360:	89 e0       	ldi	r24, 0x09	; 9
    2362:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    2364:	80 e1       	ldi	r24, 0x10	; 16
    2366:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    2368:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    236a:	82 e1       	ldi	r24, 0x12	; 18
    236c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    236e:	83 e1       	ldi	r24, 0x13	; 19
    2370:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    2372:	84 e1       	ldi	r24, 0x14	; 20
    2374:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    2376:	85 e1       	ldi	r24, 0x15	; 21
    2378:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    237a:	86 e1       	ldi	r24, 0x16	; 22
    237c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    237e:	87 e1       	ldi	r24, 0x17	; 23
    2380:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    2382:	88 e1       	ldi	r24, 0x18	; 24
    2384:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    2386:	89 e1       	ldi	r24, 0x19	; 25
    2388:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    238a:	80 e2       	ldi	r24, 0x20	; 32
    238c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    238e:	81 e2       	ldi	r24, 0x21	; 33
    2390:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    2392:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    2394:	83 e2       	ldi	r24, 0x23	; 35
    2396:	82 93       	st	-Z, r24
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */

	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2398:	42 93       	st	-Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    239a:	52 93       	st	-Z, r21
	pxTopOfStack--;


	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    239c:	86 e2       	ldi	r24, 0x26	; 38
    239e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    23a0:	87 e2       	ldi	r24, 0x27	; 39
    23a2:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    23a4:	88 e2       	ldi	r24, 0x28	; 40
    23a6:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    23a8:	89 e2       	ldi	r24, 0x29	; 41
    23aa:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    23ac:	80 e3       	ldi	r24, 0x30	; 48
    23ae:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    23b0:	81 e3       	ldi	r24, 0x31	; 49
    23b2:	82 93       	st	-Z, r24
    23b4:	31 97       	sbiw	r30, 0x01	; 1
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    23b6:	cf 01       	movw	r24, r30
    23b8:	08 95       	ret

000023ba <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	OCR1AH = ucHighByte;
    23ba:	10 92 89 00 	sts	0x0089, r1
	OCR1AL = ucLowByte;
    23be:	89 ef       	ldi	r24, 0xF9	; 249
    23c0:	80 93 88 00 	sts	0x0088, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    23c4:	8b e0       	ldi	r24, 0x0B	; 11
    23c6:	80 93 81 00 	sts	0x0081, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
    23ca:	ef e6       	ldi	r30, 0x6F	; 111
    23cc:	f0 e0       	ldi	r31, 0x00	; 0
    23ce:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    23d0:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
    23d2:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    23d4:	a0 91 9c 02 	lds	r26, 0x029C
    23d8:	b0 91 9d 02 	lds	r27, 0x029D
    23dc:	cd 91       	ld	r28, X+
    23de:	cd bf       	out	0x3d, r28	; 61
    23e0:	dd 91       	ld	r29, X+
    23e2:	de bf       	out	0x3e, r29	; 62
    23e4:	ff 91       	pop	r31
    23e6:	ef 91       	pop	r30
    23e8:	df 91       	pop	r29
    23ea:	cf 91       	pop	r28
    23ec:	bf 91       	pop	r27
    23ee:	af 91       	pop	r26
    23f0:	9f 91       	pop	r25
    23f2:	8f 91       	pop	r24
    23f4:	7f 91       	pop	r23
    23f6:	6f 91       	pop	r22
    23f8:	5f 91       	pop	r21
    23fa:	4f 91       	pop	r20
    23fc:	3f 91       	pop	r19
    23fe:	2f 91       	pop	r18
    2400:	1f 91       	pop	r17
    2402:	0f 91       	pop	r16
    2404:	ff 90       	pop	r15
    2406:	ef 90       	pop	r14
    2408:	df 90       	pop	r13
    240a:	cf 90       	pop	r12
    240c:	bf 90       	pop	r11
    240e:	af 90       	pop	r10
    2410:	9f 90       	pop	r9
    2412:	8f 90       	pop	r8
    2414:	7f 90       	pop	r7
    2416:	6f 90       	pop	r6
    2418:	5f 90       	pop	r5
    241a:	4f 90       	pop	r4
    241c:	3f 90       	pop	r3
    241e:	2f 90       	pop	r2
    2420:	1f 90       	pop	r1
    2422:	0f 90       	pop	r0
    2424:	0f be       	out	0x3f, r0	; 63
    2426:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    2428:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    242a:	81 e0       	ldi	r24, 0x01	; 1
    242c:	08 95       	ret

0000242e <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    242e:	08 95       	ret

00002430 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2430:	0f 92       	push	r0
    2432:	0f b6       	in	r0, 0x3f	; 63
    2434:	f8 94       	cli
    2436:	0f 92       	push	r0
    2438:	1f 92       	push	r1
    243a:	11 24       	eor	r1, r1
    243c:	2f 92       	push	r2
    243e:	3f 92       	push	r3
    2440:	4f 92       	push	r4
    2442:	5f 92       	push	r5
    2444:	6f 92       	push	r6
    2446:	7f 92       	push	r7
    2448:	8f 92       	push	r8
    244a:	9f 92       	push	r9
    244c:	af 92       	push	r10
    244e:	bf 92       	push	r11
    2450:	cf 92       	push	r12
    2452:	df 92       	push	r13
    2454:	ef 92       	push	r14
    2456:	ff 92       	push	r15
    2458:	0f 93       	push	r16
    245a:	1f 93       	push	r17
    245c:	2f 93       	push	r18
    245e:	3f 93       	push	r19
    2460:	4f 93       	push	r20
    2462:	5f 93       	push	r21
    2464:	6f 93       	push	r22
    2466:	7f 93       	push	r23
    2468:	8f 93       	push	r24
    246a:	9f 93       	push	r25
    246c:	af 93       	push	r26
    246e:	bf 93       	push	r27
    2470:	cf 93       	push	r28
    2472:	df 93       	push	r29
    2474:	ef 93       	push	r30
    2476:	ff 93       	push	r31
    2478:	a0 91 9c 02 	lds	r26, 0x029C
    247c:	b0 91 9d 02 	lds	r27, 0x029D
    2480:	0d b6       	in	r0, 0x3d	; 61
    2482:	0d 92       	st	X+, r0
    2484:	0e b6       	in	r0, 0x3e	; 62
    2486:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    2488:	0e 94 f1 0d 	call	0x1be2	; 0x1be2 <vTaskIncrementTick>
	vTaskSwitchContext();
    248c:	0e 94 23 0d 	call	0x1a46	; 0x1a46 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2490:	a0 91 9c 02 	lds	r26, 0x029C
    2494:	b0 91 9d 02 	lds	r27, 0x029D
    2498:	cd 91       	ld	r28, X+
    249a:	cd bf       	out	0x3d, r28	; 61
    249c:	dd 91       	ld	r29, X+
    249e:	de bf       	out	0x3e, r29	; 62
    24a0:	ff 91       	pop	r31
    24a2:	ef 91       	pop	r30
    24a4:	df 91       	pop	r29
    24a6:	cf 91       	pop	r28
    24a8:	bf 91       	pop	r27
    24aa:	af 91       	pop	r26
    24ac:	9f 91       	pop	r25
    24ae:	8f 91       	pop	r24
    24b0:	7f 91       	pop	r23
    24b2:	6f 91       	pop	r22
    24b4:	5f 91       	pop	r21
    24b6:	4f 91       	pop	r20
    24b8:	3f 91       	pop	r19
    24ba:	2f 91       	pop	r18
    24bc:	1f 91       	pop	r17
    24be:	0f 91       	pop	r16
    24c0:	ff 90       	pop	r15
    24c2:	ef 90       	pop	r14
    24c4:	df 90       	pop	r13
    24c6:	cf 90       	pop	r12
    24c8:	bf 90       	pop	r11
    24ca:	af 90       	pop	r10
    24cc:	9f 90       	pop	r9
    24ce:	8f 90       	pop	r8
    24d0:	7f 90       	pop	r7
    24d2:	6f 90       	pop	r6
    24d4:	5f 90       	pop	r5
    24d6:	4f 90       	pop	r4
    24d8:	3f 90       	pop	r3
    24da:	2f 90       	pop	r2
    24dc:	1f 90       	pop	r1
    24de:	0f 90       	pop	r0
    24e0:	0f be       	out	0x3f, r0	; 63
    24e2:	0f 90       	pop	r0

	asm volatile ( "ret" );
    24e4:	08 95       	ret

000024e6 <__vector_17>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    24e6:	0e 94 18 12 	call	0x2430	; 0x2430 <vPortYieldFromTick>
		asm volatile ( "reti" );
    24ea:	18 95       	reti

000024ec <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    24ec:	0f 92       	push	r0
    24ee:	0f b6       	in	r0, 0x3f	; 63
    24f0:	f8 94       	cli
    24f2:	0f 92       	push	r0
    24f4:	1f 92       	push	r1
    24f6:	11 24       	eor	r1, r1
    24f8:	2f 92       	push	r2
    24fa:	3f 92       	push	r3
    24fc:	4f 92       	push	r4
    24fe:	5f 92       	push	r5
    2500:	6f 92       	push	r6
    2502:	7f 92       	push	r7
    2504:	8f 92       	push	r8
    2506:	9f 92       	push	r9
    2508:	af 92       	push	r10
    250a:	bf 92       	push	r11
    250c:	cf 92       	push	r12
    250e:	df 92       	push	r13
    2510:	ef 92       	push	r14
    2512:	ff 92       	push	r15
    2514:	0f 93       	push	r16
    2516:	1f 93       	push	r17
    2518:	2f 93       	push	r18
    251a:	3f 93       	push	r19
    251c:	4f 93       	push	r20
    251e:	5f 93       	push	r21
    2520:	6f 93       	push	r22
    2522:	7f 93       	push	r23
    2524:	8f 93       	push	r24
    2526:	9f 93       	push	r25
    2528:	af 93       	push	r26
    252a:	bf 93       	push	r27
    252c:	cf 93       	push	r28
    252e:	df 93       	push	r29
    2530:	ef 93       	push	r30
    2532:	ff 93       	push	r31
    2534:	a0 91 9c 02 	lds	r26, 0x029C
    2538:	b0 91 9d 02 	lds	r27, 0x029D
    253c:	0d b6       	in	r0, 0x3d	; 61
    253e:	0d 92       	st	X+, r0
    2540:	0e b6       	in	r0, 0x3e	; 62
    2542:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2544:	0e 94 23 0d 	call	0x1a46	; 0x1a46 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2548:	a0 91 9c 02 	lds	r26, 0x029C
    254c:	b0 91 9d 02 	lds	r27, 0x029D
    2550:	cd 91       	ld	r28, X+
    2552:	cd bf       	out	0x3d, r28	; 61
    2554:	dd 91       	ld	r29, X+
    2556:	de bf       	out	0x3e, r29	; 62
    2558:	ff 91       	pop	r31
    255a:	ef 91       	pop	r30
    255c:	df 91       	pop	r29
    255e:	cf 91       	pop	r28
    2560:	bf 91       	pop	r27
    2562:	af 91       	pop	r26
    2564:	9f 91       	pop	r25
    2566:	8f 91       	pop	r24
    2568:	7f 91       	pop	r23
    256a:	6f 91       	pop	r22
    256c:	5f 91       	pop	r21
    256e:	4f 91       	pop	r20
    2570:	3f 91       	pop	r19
    2572:	2f 91       	pop	r18
    2574:	1f 91       	pop	r17
    2576:	0f 91       	pop	r16
    2578:	ff 90       	pop	r15
    257a:	ef 90       	pop	r14
    257c:	df 90       	pop	r13
    257e:	cf 90       	pop	r12
    2580:	bf 90       	pop	r11
    2582:	af 90       	pop	r10
    2584:	9f 90       	pop	r9
    2586:	8f 90       	pop	r8
    2588:	7f 90       	pop	r7
    258a:	6f 90       	pop	r6
    258c:	5f 90       	pop	r5
    258e:	4f 90       	pop	r4
    2590:	3f 90       	pop	r3
    2592:	2f 90       	pop	r2
    2594:	1f 90       	pop	r1
    2596:	0f 90       	pop	r0
    2598:	0f be       	out	0x3f, r0	; 63
    259a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    259c:	08 95       	ret

0000259e <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    259e:	0f 93       	push	r16
    25a0:	1f 93       	push	r17
    25a2:	cf 93       	push	r28
    25a4:	df 93       	push	r29
    25a6:	fc 01       	movw	r30, r24
corCRCB *pxUnblockedCRCB;
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    25a8:	80 81       	ld	r24, Z
    25aa:	88 23       	and	r24, r24
    25ac:	19 f4       	brne	.+6      	; 0x25b4 <xCoRoutineRemoveFromEventList+0x16>
    25ae:	c0 e0       	ldi	r28, 0x00	; 0
    25b0:	d0 e0       	ldi	r29, 0x00	; 0
    25b2:	05 c0       	rjmp	.+10     	; 0x25be <xCoRoutineRemoveFromEventList+0x20>
    25b4:	05 80       	ldd	r0, Z+5	; 0x05
    25b6:	f6 81       	ldd	r31, Z+6	; 0x06
    25b8:	e0 2d       	mov	r30, r0
    25ba:	c6 81       	ldd	r28, Z+6	; 0x06
    25bc:	d7 81       	ldd	r29, Z+7	; 0x07
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    25be:	8e 01       	movw	r16, r28
    25c0:	04 5f       	subi	r16, 0xF4	; 244
    25c2:	1f 4f       	sbci	r17, 0xFF	; 255
    25c4:	c8 01       	movw	r24, r16
    25c6:	0e 94 fc 09 	call	0x13f8	; 0x13f8 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    25ca:	87 e2       	ldi	r24, 0x27	; 39
    25cc:	93 e0       	ldi	r25, 0x03	; 3
    25ce:	b8 01       	movw	r22, r16
    25d0:	0e 94 9e 09 	call	0x133c	; 0x133c <vListInsertEnd>
    25d4:	20 e0       	ldi	r18, 0x00	; 0
    25d6:	e0 91 f6 02 	lds	r30, 0x02F6
    25da:	f0 91 f7 02 	lds	r31, 0x02F7
    25de:	9e 89       	ldd	r25, Y+22	; 0x16
    25e0:	86 89       	ldd	r24, Z+22	; 0x16
    25e2:	98 17       	cp	r25, r24
    25e4:	08 f0       	brcs	.+2      	; 0x25e8 <xCoRoutineRemoveFromEventList+0x4a>
    25e6:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    25e8:	82 2f       	mov	r24, r18
    25ea:	df 91       	pop	r29
    25ec:	cf 91       	pop	r28
    25ee:	1f 91       	pop	r17
    25f0:	0f 91       	pop	r16
    25f2:	08 95       	ret

000025f4 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    25f4:	ff 92       	push	r15
    25f6:	0f 93       	push	r16
    25f8:	1f 93       	push	r17
    25fa:	cf 93       	push	r28
    25fc:	df 93       	push	r29
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    25fe:	99 e0       	ldi	r25, 0x09	; 9
    2600:	f9 2e       	mov	r15, r25
    2602:	28 c0       	rjmp	.+80     	; 0x2654 <vCoRoutineSchedule+0x60>
	while( !listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    2604:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    2606:	80 91 27 03 	lds	r24, 0x0327
    260a:	88 23       	and	r24, r24
    260c:	19 f4       	brne	.+6      	; 0x2614 <vCoRoutineSchedule+0x20>
    260e:	c0 e0       	ldi	r28, 0x00	; 0
    2610:	d0 e0       	ldi	r29, 0x00	; 0
    2612:	06 c0       	rjmp	.+12     	; 0x2620 <vCoRoutineSchedule+0x2c>
    2614:	e0 91 2c 03 	lds	r30, 0x032C
    2618:	f0 91 2d 03 	lds	r31, 0x032D
    261c:	c6 81       	ldd	r28, Z+6	; 0x06
    261e:	d7 81       	ldd	r29, Z+7	; 0x07
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2620:	ce 01       	movw	r24, r28
    2622:	0c 96       	adiw	r24, 0x0c	; 12
    2624:	0e 94 fc 09 	call	0x13f8	; 0x13f8 <vListRemove>
		}
		portENABLE_INTERRUPTS();
    2628:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    262a:	8e 01       	movw	r16, r28
    262c:	0e 5f       	subi	r16, 0xFE	; 254
    262e:	1f 4f       	sbci	r17, 0xFF	; 255
    2630:	c8 01       	movw	r24, r16
    2632:	0e 94 fc 09 	call	0x13f8	; 0x13f8 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    2636:	9e 89       	ldd	r25, Y+22	; 0x16
    2638:	80 91 f8 02 	lds	r24, 0x02F8
    263c:	89 17       	cp	r24, r25
    263e:	10 f4       	brcc	.+4      	; 0x2644 <vCoRoutineSchedule+0x50>
    2640:	90 93 f8 02 	sts	0x02F8, r25
    2644:	9f 9d       	mul	r25, r15
    2646:	c0 01       	movw	r24, r0
    2648:	11 24       	eor	r1, r1
    264a:	81 50       	subi	r24, 0x01	; 1
    264c:	9d 4f       	sbci	r25, 0xFD	; 253
    264e:	b8 01       	movw	r22, r16
    2650:	0e 94 9e 09 	call	0x133c	; 0x133c <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( !listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) )
    2654:	80 91 27 03 	lds	r24, 0x0327
    2658:	88 23       	and	r24, r24
    265a:	a1 f6       	brne	.-88     	; 0x2604 <vCoRoutineSchedule+0x10>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    265c:	0e 94 0f 0d 	call	0x1a1e	; 0x1a1e <xTaskGetTickCount>
    2660:	20 91 f9 02 	lds	r18, 0x02F9
    2664:	30 91 fa 02 	lds	r19, 0x02FA
    2668:	82 1b       	sub	r24, r18
    266a:	93 0b       	sbc	r25, r19
    266c:	90 93 fc 02 	sts	0x02FC, r25
    2670:	80 93 fb 02 	sts	0x02FB, r24
					vListRemove( &( pxCRCB->xEventListItem ) );											
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    2674:	89 e0       	ldi	r24, 0x09	; 9
    2676:	f8 2e       	mov	r15, r24
    2678:	54 c0       	rjmp	.+168    	; 0x2722 <vCoRoutineSchedule+0x12e>
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    267a:	01 96       	adiw	r24, 0x01	; 1
    267c:	90 93 fe 02 	sts	0x02FE, r25
    2680:	80 93 fd 02 	sts	0x02FD, r24
		xPassedTicks--;
    2684:	21 50       	subi	r18, 0x01	; 1
    2686:	30 40       	sbci	r19, 0x00	; 0
    2688:	30 93 fc 02 	sts	0x02FC, r19
    268c:	20 93 fb 02 	sts	0x02FB, r18

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    2690:	89 2b       	or	r24, r25
    2692:	c9 f5       	brne	.+114    	; 0x2706 <vCoRoutineSchedule+0x112>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    2694:	20 91 23 03 	lds	r18, 0x0323
    2698:	30 91 24 03 	lds	r19, 0x0324
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    269c:	80 91 25 03 	lds	r24, 0x0325
    26a0:	90 91 26 03 	lds	r25, 0x0326
    26a4:	90 93 24 03 	sts	0x0324, r25
    26a8:	80 93 23 03 	sts	0x0323, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    26ac:	30 93 26 03 	sts	0x0326, r19
    26b0:	20 93 25 03 	sts	0x0325, r18
    26b4:	28 c0       	rjmp	.+80     	; 0x2706 <vCoRoutineSchedule+0x112>
		}

		/* See if this tick has made a timeout expire. */
		while( ( pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList ) ) != NULL )
		{	
			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    26b6:	20 91 fd 02 	lds	r18, 0x02FD
    26ba:	30 91 fe 02 	lds	r19, 0x02FE
    26be:	8a 81       	ldd	r24, Y+2	; 0x02
    26c0:	9b 81       	ldd	r25, Y+3	; 0x03
    26c2:	28 17       	cp	r18, r24
    26c4:	39 07       	cpc	r19, r25
    26c6:	68 f1       	brcs	.+90     	; 0x2722 <vCoRoutineSchedule+0x12e>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    26c8:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    26ca:	8e 01       	movw	r16, r28
    26cc:	0e 5f       	subi	r16, 0xFE	; 254
    26ce:	1f 4f       	sbci	r17, 0xFF	; 255
    26d0:	c8 01       	movw	r24, r16
    26d2:	0e 94 fc 09 	call	0x13f8	; 0x13f8 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    26d6:	8c 89       	ldd	r24, Y+20	; 0x14
    26d8:	9d 89       	ldd	r25, Y+21	; 0x15
    26da:	89 2b       	or	r24, r25
    26dc:	21 f0       	breq	.+8      	; 0x26e6 <vCoRoutineSchedule+0xf2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    26de:	ce 01       	movw	r24, r28
    26e0:	0c 96       	adiw	r24, 0x0c	; 12
    26e2:	0e 94 fc 09 	call	0x13f8	; 0x13f8 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    26e6:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    26e8:	9e 89       	ldd	r25, Y+22	; 0x16
    26ea:	80 91 f8 02 	lds	r24, 0x02F8
    26ee:	89 17       	cp	r24, r25
    26f0:	10 f4       	brcc	.+4      	; 0x26f6 <vCoRoutineSchedule+0x102>
    26f2:	90 93 f8 02 	sts	0x02F8, r25
    26f6:	9f 9d       	mul	r25, r15
    26f8:	c0 01       	movw	r24, r0
    26fa:	11 24       	eor	r1, r1
    26fc:	81 50       	subi	r24, 0x01	; 1
    26fe:	9d 4f       	sbci	r25, 0xFD	; 253
    2700:	b8 01       	movw	r22, r16
    2702:	0e 94 9e 09 	call	0x133c	; 0x133c <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( ( pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList ) ) != NULL )
    2706:	e0 91 23 03 	lds	r30, 0x0323
    270a:	f0 91 24 03 	lds	r31, 0x0324
    270e:	80 81       	ld	r24, Z
    2710:	88 23       	and	r24, r24
    2712:	39 f0       	breq	.+14     	; 0x2722 <vCoRoutineSchedule+0x12e>
    2714:	05 80       	ldd	r0, Z+5	; 0x05
    2716:	f6 81       	ldd	r31, Z+6	; 0x06
    2718:	e0 2d       	mov	r30, r0
    271a:	c6 81       	ldd	r28, Z+6	; 0x06
    271c:	d7 81       	ldd	r29, Z+7	; 0x07
    271e:	20 97       	sbiw	r28, 0x00	; 0
    2720:	51 f6       	brne	.-108    	; 0x26b6 <vCoRoutineSchedule+0xc2>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    2722:	20 91 fb 02 	lds	r18, 0x02FB
    2726:	30 91 fc 02 	lds	r19, 0x02FC
    272a:	80 91 fd 02 	lds	r24, 0x02FD
    272e:	90 91 fe 02 	lds	r25, 0x02FE
    2732:	21 15       	cp	r18, r1
    2734:	31 05       	cpc	r19, r1
    2736:	09 f0       	breq	.+2      	; 0x273a <vCoRoutineSchedule+0x146>
    2738:	a0 cf       	rjmp	.-192    	; 0x267a <vCoRoutineSchedule+0x86>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    273a:	90 93 fa 02 	sts	0x02FA, r25
    273e:	80 93 f9 02 	sts	0x02F9, r24
    2742:	90 91 f8 02 	lds	r25, 0x02F8

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    2746:	29 e0       	ldi	r18, 0x09	; 9
    2748:	06 c0       	rjmp	.+12     	; 0x2756 <vCoRoutineSchedule+0x162>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    274a:	99 23       	and	r25, r25
    274c:	19 f4       	brne	.+6      	; 0x2754 <vCoRoutineSchedule+0x160>
    274e:	10 92 f8 02 	sts	0x02F8, r1
    2752:	32 c0       	rjmp	.+100    	; 0x27b8 <vCoRoutineSchedule+0x1c4>
    2754:	91 50       	subi	r25, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    2756:	92 9f       	mul	r25, r18
    2758:	d0 01       	movw	r26, r0
    275a:	11 24       	eor	r1, r1
    275c:	a1 50       	subi	r26, 0x01	; 1
    275e:	bd 4f       	sbci	r27, 0xFD	; 253
    2760:	8c 91       	ld	r24, X
    2762:	88 23       	and	r24, r24
    2764:	91 f3       	breq	.-28     	; 0x274a <vCoRoutineSchedule+0x156>
    2766:	90 93 f8 02 	sts	0x02F8, r25
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    276a:	11 96       	adiw	r26, 0x01	; 1
    276c:	ed 91       	ld	r30, X+
    276e:	fc 91       	ld	r31, X
    2770:	12 97       	sbiw	r26, 0x02	; 2
    2772:	02 80       	ldd	r0, Z+2	; 0x02
    2774:	f3 81       	ldd	r31, Z+3	; 0x03
    2776:	e0 2d       	mov	r30, r0
    2778:	12 96       	adiw	r26, 0x02	; 2
    277a:	fc 93       	st	X, r31
    277c:	ee 93       	st	-X, r30
    277e:	11 97       	sbiw	r26, 0x01	; 1
    2780:	cd 01       	movw	r24, r26
    2782:	03 96       	adiw	r24, 0x03	; 3
    2784:	e8 17       	cp	r30, r24
    2786:	f9 07       	cpc	r31, r25
    2788:	31 f4       	brne	.+12     	; 0x2796 <vCoRoutineSchedule+0x1a2>
    278a:	82 81       	ldd	r24, Z+2	; 0x02
    278c:	93 81       	ldd	r25, Z+3	; 0x03
    278e:	12 96       	adiw	r26, 0x02	; 2
    2790:	9c 93       	st	X, r25
    2792:	8e 93       	st	-X, r24
    2794:	11 97       	sbiw	r26, 0x01	; 1
    2796:	11 96       	adiw	r26, 0x01	; 1
    2798:	ed 91       	ld	r30, X+
    279a:	fc 91       	ld	r31, X
    279c:	12 97       	sbiw	r26, 0x02	; 2
    279e:	06 80       	ldd	r0, Z+6	; 0x06
    27a0:	f7 81       	ldd	r31, Z+7	; 0x07
    27a2:	e0 2d       	mov	r30, r0
    27a4:	f0 93 f7 02 	sts	0x02F7, r31
    27a8:	e0 93 f6 02 	sts	0x02F6, r30

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    27ac:	20 81       	ld	r18, Z
    27ae:	31 81       	ldd	r19, Z+1	; 0x01
    27b0:	cf 01       	movw	r24, r30
    27b2:	67 89       	ldd	r22, Z+23	; 0x17
    27b4:	f9 01       	movw	r30, r18
    27b6:	09 95       	icall

	return;
}
    27b8:	df 91       	pop	r29
    27ba:	cf 91       	pop	r28
    27bc:	1f 91       	pop	r17
    27be:	0f 91       	pop	r16
    27c0:	ff 90       	pop	r15
    27c2:	08 95       	ret

000027c4 <vCoRoutineAddToDelayedList>:
	return xReturn;	
}
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    27c4:	0f 93       	push	r16
    27c6:	1f 93       	push	r17
    27c8:	cf 93       	push	r28
    27ca:	df 93       	push	r29
    27cc:	eb 01       	movw	r28, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    27ce:	00 91 fd 02 	lds	r16, 0x02FD
    27d2:	10 91 fe 02 	lds	r17, 0x02FE
    27d6:	08 0f       	add	r16, r24
    27d8:	19 1f       	adc	r17, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    27da:	80 91 f6 02 	lds	r24, 0x02F6
    27de:	90 91 f7 02 	lds	r25, 0x02F7
    27e2:	02 96       	adiw	r24, 0x02	; 2
    27e4:	0e 94 fc 09 	call	0x13f8	; 0x13f8 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    27e8:	e0 91 f6 02 	lds	r30, 0x02F6
    27ec:	f0 91 f7 02 	lds	r31, 0x02F7
    27f0:	13 83       	std	Z+3, r17	; 0x03
    27f2:	02 83       	std	Z+2, r16	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    27f4:	80 91 fd 02 	lds	r24, 0x02FD
    27f8:	90 91 fe 02 	lds	r25, 0x02FE
    27fc:	bf 01       	movw	r22, r30
    27fe:	6e 5f       	subi	r22, 0xFE	; 254
    2800:	7f 4f       	sbci	r23, 0xFF	; 255
    2802:	08 17       	cp	r16, r24
    2804:	19 07       	cpc	r17, r25
    2806:	28 f4       	brcc	.+10     	; 0x2812 <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2808:	80 91 25 03 	lds	r24, 0x0325
    280c:	90 91 26 03 	lds	r25, 0x0326
    2810:	04 c0       	rjmp	.+8      	; 0x281a <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2812:	80 91 23 03 	lds	r24, 0x0323
    2816:	90 91 24 03 	lds	r25, 0x0324
    281a:	0e 94 c7 09 	call	0x138e	; 0x138e <vListInsert>
	}

	if( pxEventList )
    281e:	20 97       	sbiw	r28, 0x00	; 0
    2820:	49 f0       	breq	.+18     	; 0x2834 <vCoRoutineAddToDelayedList+0x70>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    2822:	60 91 f6 02 	lds	r22, 0x02F6
    2826:	70 91 f7 02 	lds	r23, 0x02F7
    282a:	64 5f       	subi	r22, 0xF4	; 244
    282c:	7f 4f       	sbci	r23, 0xFF	; 255
    282e:	ce 01       	movw	r24, r28
    2830:	0e 94 c7 09 	call	0x138e	; 0x138e <vListInsert>
	}
}
    2834:	df 91       	pop	r29
    2836:	cf 91       	pop	r28
    2838:	1f 91       	pop	r17
    283a:	0f 91       	pop	r16
    283c:	08 95       	ret

0000283e <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    283e:	af 92       	push	r10
    2840:	bf 92       	push	r11
    2842:	cf 92       	push	r12
    2844:	df 92       	push	r13
    2846:	ef 92       	push	r14
    2848:	ff 92       	push	r15
    284a:	0f 93       	push	r16
    284c:	1f 93       	push	r17
    284e:	cf 93       	push	r28
    2850:	df 93       	push	r29
    2852:	6c 01       	movw	r12, r24
    2854:	b6 2e       	mov	r11, r22
    2856:	a4 2e       	mov	r10, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    2858:	8a e1       	ldi	r24, 0x1A	; 26
    285a:	90 e0       	ldi	r25, 0x00	; 0
    285c:	0e 94 a9 14 	call	0x2952	; 0x2952 <pvPortMalloc>
    2860:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
    2862:	00 97       	sbiw	r24, 0x00	; 0
    2864:	11 f4       	brne	.+4      	; 0x286a <xCoRoutineCreate+0x2c>
    2866:	8f ef       	ldi	r24, 0xFF	; 255
    2868:	59 c0       	rjmp	.+178    	; 0x291c <xCoRoutineCreate+0xde>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    286a:	80 91 f6 02 	lds	r24, 0x02F6
    286e:	90 91 f7 02 	lds	r25, 0x02F7
    2872:	89 2b       	or	r24, r25
    2874:	21 f5       	brne	.+72     	; 0x28be <xCoRoutineCreate+0x80>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    2876:	d0 93 f7 02 	sts	0x02F7, r29
    287a:	c0 93 f6 02 	sts	0x02F6, r28
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    287e:	8f ef       	ldi	r24, 0xFF	; 255
    2880:	92 e0       	ldi	r25, 0x02	; 2
    2882:	0e 94 8a 09 	call	0x1314	; 0x1314 <vListInitialise>
    2886:	88 e0       	ldi	r24, 0x08	; 8
    2888:	93 e0       	ldi	r25, 0x03	; 3
    288a:	0e 94 8a 09 	call	0x1314	; 0x1314 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    288e:	21 e1       	ldi	r18, 0x11	; 17
    2890:	e2 2e       	mov	r14, r18
    2892:	23 e0       	ldi	r18, 0x03	; 3
    2894:	f2 2e       	mov	r15, r18
    2896:	c7 01       	movw	r24, r14
    2898:	0e 94 8a 09 	call	0x1314	; 0x1314 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    289c:	0a e1       	ldi	r16, 0x1A	; 26
    289e:	13 e0       	ldi	r17, 0x03	; 3
    28a0:	c8 01       	movw	r24, r16
    28a2:	0e 94 8a 09 	call	0x1314	; 0x1314 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    28a6:	87 e2       	ldi	r24, 0x27	; 39
    28a8:	93 e0       	ldi	r25, 0x03	; 3
    28aa:	0e 94 8a 09 	call	0x1314	; 0x1314 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    28ae:	f0 92 24 03 	sts	0x0324, r15
    28b2:	e0 92 23 03 	sts	0x0323, r14
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    28b6:	10 93 26 03 	sts	0x0326, r17
    28ba:	00 93 25 03 	sts	0x0325, r16
    28be:	eb 2c       	mov	r14, r11
    28c0:	bb 20       	and	r11, r11
    28c2:	11 f0       	breq	.+4      	; 0x28c8 <xCoRoutineCreate+0x8a>
    28c4:	ee 24       	eor	r14, r14
    28c6:	e3 94       	inc	r14
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    28c8:	19 8e       	std	Y+25, r1	; 0x19
    28ca:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    28cc:	ee 8a       	std	Y+22, r14	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    28ce:	af 8a       	std	Y+23, r10	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    28d0:	fe 01       	movw	r30, r28
    28d2:	c1 92       	st	Z+, r12
    28d4:	d1 92       	st	Z+, r13
    28d6:	8f 01       	movw	r16, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    28d8:	cf 01       	movw	r24, r30
    28da:	0e 94 9a 09 	call	0x1334	; 0x1334 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    28de:	ce 01       	movw	r24, r28
    28e0:	0c 96       	adiw	r24, 0x0c	; 12
    28e2:	0e 94 9a 09 	call	0x1334	; 0x1334 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    28e6:	d9 87       	std	Y+9, r29	; 0x09
    28e8:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    28ea:	db 8b       	std	Y+19, r29	; 0x13
    28ec:	ca 8b       	std	Y+18, r28	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    28ee:	84 e0       	ldi	r24, 0x04	; 4
    28f0:	90 e0       	ldi	r25, 0x00	; 0
    28f2:	8e 19       	sub	r24, r14
    28f4:	91 09       	sbc	r25, r1
    28f6:	9d 87       	std	Y+13, r25	; 0x0d
    28f8:	8c 87       	std	Y+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    28fa:	9e 89       	ldd	r25, Y+22	; 0x16
    28fc:	80 91 f8 02 	lds	r24, 0x02F8
    2900:	89 17       	cp	r24, r25
    2902:	10 f4       	brcc	.+4      	; 0x2908 <xCoRoutineCreate+0xca>
    2904:	90 93 f8 02 	sts	0x02F8, r25
    2908:	89 e0       	ldi	r24, 0x09	; 9
    290a:	98 9f       	mul	r25, r24
    290c:	c0 01       	movw	r24, r0
    290e:	11 24       	eor	r1, r1
    2910:	81 50       	subi	r24, 0x01	; 1
    2912:	9d 4f       	sbci	r25, 0xFD	; 253
    2914:	b8 01       	movw	r22, r16
    2916:	0e 94 9e 09 	call	0x133c	; 0x133c <vListInsertEnd>
    291a:	81 e0       	ldi	r24, 0x01	; 1
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
	}
	
	return xReturn;	
}
    291c:	df 91       	pop	r29
    291e:	cf 91       	pop	r28
    2920:	1f 91       	pop	r17
    2922:	0f 91       	pop	r16
    2924:	ff 90       	pop	r15
    2926:	ef 90       	pop	r14
    2928:	df 90       	pop	r13
    292a:	cf 90       	pop	r12
    292c:	bf 90       	pop	r11
    292e:	af 90       	pop	r10
    2930:	08 95       	ret

00002932 <vPortFree>:
{
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    2932:	08 95       	ret

00002934 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    2934:	10 92 31 03 	sts	0x0331, r1
    2938:	10 92 30 03 	sts	0x0330, r1
}
    293c:	08 95       	ret

0000293e <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    293e:	28 eb       	ldi	r18, 0xB8	; 184
    2940:	3b e0       	ldi	r19, 0x0B	; 11
    2942:	80 91 30 03 	lds	r24, 0x0330
    2946:	90 91 31 03 	lds	r25, 0x0331
    294a:	28 1b       	sub	r18, r24
    294c:	39 0b       	sbc	r19, r25
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
}
    294e:	c9 01       	movw	r24, r18
    2950:	08 95       	ret

00002952 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2952:	0f 93       	push	r16
    2954:	1f 93       	push	r17
    2956:	cf 93       	push	r28
    2958:	df 93       	push	r29
    295a:	8c 01       	movw	r16, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    295c:	0e 94 09 0d 	call	0x1a12	; 0x1a12 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    2960:	80 91 30 03 	lds	r24, 0x0330
    2964:	90 91 31 03 	lds	r25, 0x0331
    2968:	98 01       	movw	r18, r16
    296a:	28 0f       	add	r18, r24
    296c:	39 1f       	adc	r19, r25
    296e:	4b e0       	ldi	r20, 0x0B	; 11
    2970:	28 3b       	cpi	r18, 0xB8	; 184
    2972:	34 07       	cpc	r19, r20
    2974:	58 f4       	brcc	.+22     	; 0x298c <pvPortMalloc+0x3a>
    2976:	82 17       	cp	r24, r18
    2978:	93 07       	cpc	r25, r19
    297a:	40 f4       	brcc	.+16     	; 0x298c <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    297c:	ec 01       	movw	r28, r24
    297e:	ce 5c       	subi	r28, 0xCE	; 206
    2980:	dc 4f       	sbci	r29, 0xFC	; 252
			xNextFreeByte += xWantedSize;			
    2982:	30 93 31 03 	sts	0x0331, r19
    2986:	20 93 30 03 	sts	0x0330, r18
    298a:	02 c0       	rjmp	.+4      	; 0x2990 <pvPortMalloc+0x3e>
    298c:	c0 e0       	ldi	r28, 0x00	; 0
    298e:	d0 e0       	ldi	r29, 0x00	; 0
		}	
	}
	xTaskResumeAll();
    2990:	0e 94 a0 0e 	call	0x1d40	; 0x1d40 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
    2994:	ce 01       	movw	r24, r28
    2996:	df 91       	pop	r29
    2998:	cf 91       	pop	r28
    299a:	1f 91       	pop	r17
    299c:	0f 91       	pop	r16
    299e:	08 95       	ret

000029a0 <prescaler_hex_to_value>:
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    29a0:	e8 2f       	mov	r30, r24
    29a2:	f0 e0       	ldi	r31, 0x00	; 0
    29a4:	e7 70       	andi	r30, 0x07	; 7
    29a6:	f0 70       	andi	r31, 0x00	; 0
    29a8:	ee 0f       	add	r30, r30
    29aa:	ff 1f       	adc	r31, r31
    29ac:	e2 57       	subi	r30, 0x72	; 114
    29ae:	fe 4f       	sbci	r31, 0xFE	; 254
    29b0:	25 91       	lpm	r18, Z+
    29b2:	34 91       	lpm	r19, Z+
}
    29b4:	c9 01       	movw	r24, r18
    29b6:	08 95       	ret

000029b8 <prescaler_hex_to_value_for_timer2>:
uint16_t prescaler_hex_to_value_for_timer2(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to Timer2PrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(Timer2PrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    29b8:	e8 2f       	mov	r30, r24
    29ba:	f0 e0       	ldi	r31, 0x00	; 0
    29bc:	e7 70       	andi	r30, 0x07	; 7
    29be:	f0 70       	andi	r31, 0x00	; 0
    29c0:	ee 0f       	add	r30, r30
    29c2:	ff 1f       	adc	r31, r31
    29c4:	e6 56       	subi	r30, 0x66	; 102
    29c6:	fe 4f       	sbci	r31, 0xFE	; 254
    29c8:	25 91       	lpm	r18, Z+
    29ca:	34 91       	lpm	r19, Z+
}
    29cc:	c9 01       	movw	r24, r18
    29ce:	08 95       	ret

000029d0 <get_timer0_prescaler>:

uint16_t get_timer0_prescaler(void)
{
  return prescaler_hex_to_value(TCCR0B);
    29d0:	85 b5       	in	r24, 0x25	; 37
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    29d2:	e8 2f       	mov	r30, r24
    29d4:	f0 e0       	ldi	r31, 0x00	; 0
    29d6:	e7 70       	andi	r30, 0x07	; 7
    29d8:	f0 70       	andi	r31, 0x00	; 0
    29da:	ee 0f       	add	r30, r30
    29dc:	ff 1f       	adc	r31, r31
    29de:	e2 57       	subi	r30, 0x72	; 114
    29e0:	fe 4f       	sbci	r31, 0xFE	; 254
    29e2:	25 91       	lpm	r18, Z+
    29e4:	34 91       	lpm	r19, Z+
}

uint16_t get_timer0_prescaler(void)
{
  return prescaler_hex_to_value(TCCR0B);
}
    29e6:	c9 01       	movw	r24, r18
    29e8:	08 95       	ret

000029ea <get_timer1_prescaler>:
uint16_t get_timer1_prescaler(void)
{
  return prescaler_hex_to_value(TCCR1B);
    29ea:	80 91 81 00 	lds	r24, 0x0081
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    29ee:	e8 2f       	mov	r30, r24
    29f0:	f0 e0       	ldi	r31, 0x00	; 0
    29f2:	e7 70       	andi	r30, 0x07	; 7
    29f4:	f0 70       	andi	r31, 0x00	; 0
    29f6:	ee 0f       	add	r30, r30
    29f8:	ff 1f       	adc	r31, r31
    29fa:	e2 57       	subi	r30, 0x72	; 114
    29fc:	fe 4f       	sbci	r31, 0xFE	; 254
    29fe:	25 91       	lpm	r18, Z+
    2a00:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR0B);
}
uint16_t get_timer1_prescaler(void)
{
  return prescaler_hex_to_value(TCCR1B);
}
    2a02:	c9 01       	movw	r24, r18
    2a04:	08 95       	ret

00002a06 <get_timer2_prescaler>:
uint16_t get_timer2_prescaler(void)
{
  return prescaler_hex_to_value_for_timer2(TCCR2B);
    2a06:	80 91 b1 00 	lds	r24, 0x00B1
uint16_t prescaler_hex_to_value_for_timer2(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to Timer2PrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(Timer2PrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    2a0a:	e8 2f       	mov	r30, r24
    2a0c:	f0 e0       	ldi	r31, 0x00	; 0
    2a0e:	e7 70       	andi	r30, 0x07	; 7
    2a10:	f0 70       	andi	r31, 0x00	; 0
    2a12:	ee 0f       	add	r30, r30
    2a14:	ff 1f       	adc	r31, r31
    2a16:	e6 56       	subi	r30, 0x66	; 102
    2a18:	fe 4f       	sbci	r31, 0xFE	; 254
    2a1a:	25 91       	lpm	r18, Z+
    2a1c:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR1B);
}
uint16_t get_timer2_prescaler(void)
{
  return prescaler_hex_to_value_for_timer2(TCCR2B);
}
    2a1e:	c9 01       	movw	r24, r18
    2a20:	08 95       	ret

00002a22 <get_timer3_prescaler>:
uint16_t get_timer3_prescaler(void)
{
  return prescaler_hex_to_value(TCCR3B);
    2a22:	80 91 91 00 	lds	r24, 0x0091
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    2a26:	e8 2f       	mov	r30, r24
    2a28:	f0 e0       	ldi	r31, 0x00	; 0
    2a2a:	e7 70       	andi	r30, 0x07	; 7
    2a2c:	f0 70       	andi	r31, 0x00	; 0
    2a2e:	ee 0f       	add	r30, r30
    2a30:	ff 1f       	adc	r31, r31
    2a32:	e2 57       	subi	r30, 0x72	; 114
    2a34:	fe 4f       	sbci	r31, 0xFE	; 254
    2a36:	25 91       	lpm	r18, Z+
    2a38:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value_for_timer2(TCCR2B);
}
uint16_t get_timer3_prescaler(void)
{
  return prescaler_hex_to_value(TCCR3B);
}
    2a3a:	c9 01       	movw	r24, r18
    2a3c:	08 95       	ret

00002a3e <get_timer4_prescaler>:
uint16_t get_timer4_prescaler(void)
{
  return prescaler_hex_to_value(TCCR4B);
    2a3e:	80 91 a1 00 	lds	r24, 0x00A1
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    2a42:	e8 2f       	mov	r30, r24
    2a44:	f0 e0       	ldi	r31, 0x00	; 0
    2a46:	e7 70       	andi	r30, 0x07	; 7
    2a48:	f0 70       	andi	r31, 0x00	; 0
    2a4a:	ee 0f       	add	r30, r30
    2a4c:	ff 1f       	adc	r31, r31
    2a4e:	e2 57       	subi	r30, 0x72	; 114
    2a50:	fe 4f       	sbci	r31, 0xFE	; 254
    2a52:	25 91       	lpm	r18, Z+
    2a54:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR3B);
}
uint16_t get_timer4_prescaler(void)
{
  return prescaler_hex_to_value(TCCR4B);
}
    2a56:	c9 01       	movw	r24, r18
    2a58:	08 95       	ret

00002a5a <get_timer5_prescaler>:
uint16_t get_timer5_prescaler(void)
{
  return prescaler_hex_to_value(TCCR5B);
    2a5a:	80 91 21 01 	lds	r24, 0x0121
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    2a5e:	e8 2f       	mov	r30, r24
    2a60:	f0 e0       	ldi	r31, 0x00	; 0
    2a62:	e7 70       	andi	r30, 0x07	; 7
    2a64:	f0 70       	andi	r31, 0x00	; 0
    2a66:	ee 0f       	add	r30, r30
    2a68:	ff 1f       	adc	r31, r31
    2a6a:	e2 57       	subi	r30, 0x72	; 114
    2a6c:	fe 4f       	sbci	r31, 0xFE	; 254
    2a6e:	25 91       	lpm	r18, Z+
    2a70:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR4B);
}
uint16_t get_timer5_prescaler(void)
{
  return prescaler_hex_to_value(TCCR5B);
}
    2a72:	c9 01       	movw	r24, r18
    2a74:	08 95       	ret

00002a76 <get_timer0_overflow>:

const uint32_t get_timer0_overflow(void)
{
    return timer0_ovrflow_cnt;
    2a76:	20 91 c6 12 	lds	r18, 0x12C6
    2a7a:	30 91 c7 12 	lds	r19, 0x12C7
    2a7e:	40 91 c8 12 	lds	r20, 0x12C8
    2a82:	50 91 c9 12 	lds	r21, 0x12C9
}
    2a86:	b9 01       	movw	r22, r18
    2a88:	ca 01       	movw	r24, r20
    2a8a:	08 95       	ret

00002a8c <get_timer1_overflow>:
const uint32_t get_timer1_overflow(void)
{
    return timer1_ovrflow_cnt;
    2a8c:	20 91 c2 12 	lds	r18, 0x12C2
    2a90:	30 91 c3 12 	lds	r19, 0x12C3
    2a94:	40 91 c4 12 	lds	r20, 0x12C4
    2a98:	50 91 c5 12 	lds	r21, 0x12C5
}
    2a9c:	b9 01       	movw	r22, r18
    2a9e:	ca 01       	movw	r24, r20
    2aa0:	08 95       	ret

00002aa2 <get_timer2_overflow>:
const uint32_t get_timer2_overflow(void)
{
    return timer2_ovrflow_cnt;
    2aa2:	20 91 ca 12 	lds	r18, 0x12CA
    2aa6:	30 91 cb 12 	lds	r19, 0x12CB
    2aaa:	40 91 cc 12 	lds	r20, 0x12CC
    2aae:	50 91 cd 12 	lds	r21, 0x12CD
}
    2ab2:	b9 01       	movw	r22, r18
    2ab4:	ca 01       	movw	r24, r20
    2ab6:	08 95       	ret

00002ab8 <get_timer3_overflow>:
const uint32_t get_timer3_overflow(void)
{
    return timer3_ovrflow_cnt;
    2ab8:	20 91 d2 12 	lds	r18, 0x12D2
    2abc:	30 91 d3 12 	lds	r19, 0x12D3
    2ac0:	40 91 d4 12 	lds	r20, 0x12D4
    2ac4:	50 91 d5 12 	lds	r21, 0x12D5
}
    2ac8:	b9 01       	movw	r22, r18
    2aca:	ca 01       	movw	r24, r20
    2acc:	08 95       	ret

00002ace <get_timer4_overflow>:
const uint32_t get_timer4_overflow(void)
{
    return timer4_ovrflow_cnt;
    2ace:	20 91 be 12 	lds	r18, 0x12BE
    2ad2:	30 91 bf 12 	lds	r19, 0x12BF
    2ad6:	40 91 c0 12 	lds	r20, 0x12C0
    2ada:	50 91 c1 12 	lds	r21, 0x12C1
}
    2ade:	b9 01       	movw	r22, r18
    2ae0:	ca 01       	movw	r24, r20
    2ae2:	08 95       	ret

00002ae4 <get_timer5_overflow>:
const uint32_t get_timer5_overflow(void)
{
    return timer5_ovrflow_cnt;
    2ae4:	20 91 d6 12 	lds	r18, 0x12D6
    2ae8:	30 91 d7 12 	lds	r19, 0x12D7
    2aec:	40 91 d8 12 	lds	r20, 0x12D8
    2af0:	50 91 d9 12 	lds	r21, 0x12D9
}
    2af4:	b9 01       	movw	r22, r18
    2af6:	ca 01       	movw	r24, r20
    2af8:	08 95       	ret

00002afa <get_timer0_counter>:

const uint8_t get_timer0_counter(void)
{
    return TCNT0;
    2afa:	86 b5       	in	r24, 0x26	; 38
}
    2afc:	08 95       	ret

00002afe <get_timer1_counter>:
const uint16_t get_timer1_counter(void)
{
    return TCNT1;
    2afe:	20 91 84 00 	lds	r18, 0x0084
    2b02:	30 91 85 00 	lds	r19, 0x0085
}
    2b06:	c9 01       	movw	r24, r18
    2b08:	08 95       	ret

00002b0a <get_timer2_counter>:
const uint8_t get_timer2_counter(void)
{
    return TCNT2;
    2b0a:	80 91 b2 00 	lds	r24, 0x00B2
}
    2b0e:	08 95       	ret

00002b10 <get_timer3_counter>:
const uint16_t get_timer3_counter(void)
{
    return TCNT3;
    2b10:	20 91 94 00 	lds	r18, 0x0094
    2b14:	30 91 95 00 	lds	r19, 0x0095
}
    2b18:	c9 01       	movw	r24, r18
    2b1a:	08 95       	ret

00002b1c <get_timer4_counter>:
const uint16_t get_timer4_counter(void)
{
    return TCNT4;
    2b1c:	20 91 a4 00 	lds	r18, 0x00A4
    2b20:	30 91 a5 00 	lds	r19, 0x00A5
}
    2b24:	c9 01       	movw	r24, r18
    2b26:	08 95       	ret

00002b28 <get_timer5_counter>:
const uint16_t get_timer5_counter(void)
{
    return TCNT5;
    2b28:	20 91 24 01 	lds	r18, 0x0124
    2b2c:	30 91 25 01 	lds	r19, 0x0125
}
    2b30:	c9 01       	movw	r24, r18
    2b32:	08 95       	ret

00002b34 <reset_timer0>:

void reset_timer0(void)
{
    TCNT0 = timer0_ovrflow_cnt = 0;
    2b34:	10 92 c6 12 	sts	0x12C6, r1
    2b38:	10 92 c7 12 	sts	0x12C7, r1
    2b3c:	10 92 c8 12 	sts	0x12C8, r1
    2b40:	10 92 c9 12 	sts	0x12C9, r1
    2b44:	16 bc       	out	0x26, r1	; 38
}
    2b46:	08 95       	ret

00002b48 <reset_timer1>:
void reset_timer1(void)
{
    TCNT1 = timer1_ovrflow_cnt = 0;
    2b48:	10 92 c2 12 	sts	0x12C2, r1
    2b4c:	10 92 c3 12 	sts	0x12C3, r1
    2b50:	10 92 c4 12 	sts	0x12C4, r1
    2b54:	10 92 c5 12 	sts	0x12C5, r1
    2b58:	10 92 85 00 	sts	0x0085, r1
    2b5c:	10 92 84 00 	sts	0x0084, r1
}
    2b60:	08 95       	ret

00002b62 <reset_timer2>:
void reset_timer2(void)
{
    TCNT2 = timer2_ovrflow_cnt = 0;
    2b62:	10 92 ca 12 	sts	0x12CA, r1
    2b66:	10 92 cb 12 	sts	0x12CB, r1
    2b6a:	10 92 cc 12 	sts	0x12CC, r1
    2b6e:	10 92 cd 12 	sts	0x12CD, r1
    2b72:	10 92 b2 00 	sts	0x00B2, r1
}
    2b76:	08 95       	ret

00002b78 <reset_timer3>:
void reset_timer3(void)
{
    TCNT3 = timer3_ovrflow_cnt = 0;
    2b78:	10 92 d2 12 	sts	0x12D2, r1
    2b7c:	10 92 d3 12 	sts	0x12D3, r1
    2b80:	10 92 d4 12 	sts	0x12D4, r1
    2b84:	10 92 d5 12 	sts	0x12D5, r1
    2b88:	10 92 95 00 	sts	0x0095, r1
    2b8c:	10 92 94 00 	sts	0x0094, r1
}
    2b90:	08 95       	ret

00002b92 <reset_timer4>:
void reset_timer4(void)
{
    TCNT4 = timer4_ovrflow_cnt = 0;
    2b92:	10 92 be 12 	sts	0x12BE, r1
    2b96:	10 92 bf 12 	sts	0x12BF, r1
    2b9a:	10 92 c0 12 	sts	0x12C0, r1
    2b9e:	10 92 c1 12 	sts	0x12C1, r1
    2ba2:	10 92 a5 00 	sts	0x00A5, r1
    2ba6:	10 92 a4 00 	sts	0x00A4, r1
}
    2baa:	08 95       	ret

00002bac <reset_timer5>:
void reset_timer5(void)
{
    TCNT5 = timer5_ovrflow_cnt = 0;
    2bac:	10 92 d6 12 	sts	0x12D6, r1
    2bb0:	10 92 d7 12 	sts	0x12D7, r1
    2bb4:	10 92 d8 12 	sts	0x12D8, r1
    2bb8:	10 92 d9 12 	sts	0x12D9, r1
    2bbc:	10 92 25 01 	sts	0x0125, r1
    2bc0:	10 92 24 01 	sts	0x0124, r1
}
    2bc4:	08 95       	ret

00002bc6 <delay_us>:

	delay_loops = ((time_us * CYCLES_PER_US)+3) / 5; // +3 for rounding up (dirty) 

	// one loop takes 5 cpu cycles 
	for (i=0; i < delay_loops; i++) {};
}
    2bc6:	08 95       	ret

00002bc8 <init_timer0>:

void init_timer0(const uint8_t prescaler)
{
  TCCR0B = prescaler;
    2bc8:	85 bd       	out	0x25, r24	; 37
  TIMSK0 = _BV(TOIE0); // enable interrupts
    2bca:	81 e0       	ldi	r24, 0x01	; 1
    2bcc:	80 93 6e 00 	sts	0x006E, r24
    return TCNT5;
}

void reset_timer0(void)
{
    TCNT0 = timer0_ovrflow_cnt = 0;
    2bd0:	10 92 c6 12 	sts	0x12C6, r1
    2bd4:	10 92 c7 12 	sts	0x12C7, r1
    2bd8:	10 92 c8 12 	sts	0x12C8, r1
    2bdc:	10 92 c9 12 	sts	0x12C9, r1
    2be0:	16 bc       	out	0x26, r1	; 38
void init_timer0(const uint8_t prescaler)
{
  TCCR0B = prescaler;
  TIMSK0 = _BV(TOIE0); // enable interrupts
  reset_timer0(); // reset counter
}
    2be2:	08 95       	ret

00002be4 <init_timer1>:
void init_timer1(const uint8_t prescaler)
{
  TCCR1B = prescaler;
    2be4:	80 93 81 00 	sts	0x0081, r24
  TIMSK1 = _BV(TOIE1); // enable interrupts
    2be8:	81 e0       	ldi	r24, 0x01	; 1
    2bea:	80 93 6f 00 	sts	0x006F, r24
{
    TCNT0 = timer0_ovrflow_cnt = 0;
}
void reset_timer1(void)
{
    TCNT1 = timer1_ovrflow_cnt = 0;
    2bee:	10 92 c2 12 	sts	0x12C2, r1
    2bf2:	10 92 c3 12 	sts	0x12C3, r1
    2bf6:	10 92 c4 12 	sts	0x12C4, r1
    2bfa:	10 92 c5 12 	sts	0x12C5, r1
    2bfe:	10 92 85 00 	sts	0x0085, r1
    2c02:	10 92 84 00 	sts	0x0084, r1
void init_timer1(const uint8_t prescaler)
{
  TCCR1B = prescaler;
  TIMSK1 = _BV(TOIE1); // enable interrupts
  reset_timer1(); // reset counter
}
    2c06:	08 95       	ret

00002c08 <init_timer2>:
void init_timer2(const uint8_t prescaler)
{
  TCCR2B = prescaler;
    2c08:	80 93 b1 00 	sts	0x00B1, r24
  TIMSK2 = _BV(TOIE2); // enable interrupts
    2c0c:	81 e0       	ldi	r24, 0x01	; 1
    2c0e:	80 93 70 00 	sts	0x0070, r24
{
    TCNT1 = timer1_ovrflow_cnt = 0;
}
void reset_timer2(void)
{
    TCNT2 = timer2_ovrflow_cnt = 0;
    2c12:	10 92 ca 12 	sts	0x12CA, r1
    2c16:	10 92 cb 12 	sts	0x12CB, r1
    2c1a:	10 92 cc 12 	sts	0x12CC, r1
    2c1e:	10 92 cd 12 	sts	0x12CD, r1
    2c22:	10 92 b2 00 	sts	0x00B2, r1
void init_timer2(const uint8_t prescaler)
{
  TCCR2B = prescaler;
  TIMSK2 = _BV(TOIE2); // enable interrupts
  reset_timer2(); // reset counter
}
    2c26:	08 95       	ret

00002c28 <init_timer3>:
void init_timer3(const uint8_t prescaler)
{
  TCCR3B = prescaler;
    2c28:	80 93 91 00 	sts	0x0091, r24
  TIMSK3 = _BV(TOIE3); // enable interrupts
    2c2c:	81 e0       	ldi	r24, 0x01	; 1
    2c2e:	80 93 71 00 	sts	0x0071, r24
{
    TCNT2 = timer2_ovrflow_cnt = 0;
}
void reset_timer3(void)
{
    TCNT3 = timer3_ovrflow_cnt = 0;
    2c32:	10 92 d2 12 	sts	0x12D2, r1
    2c36:	10 92 d3 12 	sts	0x12D3, r1
    2c3a:	10 92 d4 12 	sts	0x12D4, r1
    2c3e:	10 92 d5 12 	sts	0x12D5, r1
    2c42:	10 92 95 00 	sts	0x0095, r1
    2c46:	10 92 94 00 	sts	0x0094, r1
void init_timer3(const uint8_t prescaler)
{
  TCCR3B = prescaler;
  TIMSK3 = _BV(TOIE3); // enable interrupts
  reset_timer3(); // reset counter
}
    2c4a:	08 95       	ret

00002c4c <init_timer4>:
void init_timer4(const uint8_t prescaler)
{
  TCCR4B = prescaler;
    2c4c:	80 93 a1 00 	sts	0x00A1, r24
  TIMSK4 = _BV(TOIE4); // enable interrupts
    2c50:	81 e0       	ldi	r24, 0x01	; 1
    2c52:	80 93 72 00 	sts	0x0072, r24
{
    TCNT3 = timer3_ovrflow_cnt = 0;
}
void reset_timer4(void)
{
    TCNT4 = timer4_ovrflow_cnt = 0;
    2c56:	10 92 be 12 	sts	0x12BE, r1
    2c5a:	10 92 bf 12 	sts	0x12BF, r1
    2c5e:	10 92 c0 12 	sts	0x12C0, r1
    2c62:	10 92 c1 12 	sts	0x12C1, r1
    2c66:	10 92 a5 00 	sts	0x00A5, r1
    2c6a:	10 92 a4 00 	sts	0x00A4, r1
void init_timer4(const uint8_t prescaler)
{
  TCCR4B = prescaler;
  TIMSK4 = _BV(TOIE4); // enable interrupts
  reset_timer4(); // reset counter
}
    2c6e:	08 95       	ret

00002c70 <init_timer5>:
void init_timer5(const uint8_t prescaler)
{
  TCCR5B = prescaler;
    2c70:	80 93 21 01 	sts	0x0121, r24
  TIMSK5 = _BV(TOIE5); // enable interrupts
    2c74:	81 e0       	ldi	r24, 0x01	; 1
    2c76:	80 93 73 00 	sts	0x0073, r24
{
    TCNT4 = timer4_ovrflow_cnt = 0;
}
void reset_timer5(void)
{
    TCNT5 = timer5_ovrflow_cnt = 0;
    2c7a:	10 92 d6 12 	sts	0x12D6, r1
    2c7e:	10 92 d7 12 	sts	0x12D7, r1
    2c82:	10 92 d8 12 	sts	0x12D8, r1
    2c86:	10 92 d9 12 	sts	0x12D9, r1
    2c8a:	10 92 25 01 	sts	0x0125, r1
    2c8e:	10 92 24 01 	sts	0x0124, r1
void init_timer5(const uint8_t prescaler)
{
  TCCR5B = prescaler;
  TIMSK5 = _BV(TOIE5); // enable interrupts
  reset_timer5(); // reset counter
}
    2c92:	08 95       	ret

00002c94 <timer_attach>:

void timer_attach(TimerInterrupt_t interrupt, void (*user_func)(void) )
{
  // set the interrupt function to run
  // the supplied user's function
  TimerIntFunc[interrupt] = user_func;
    2c94:	e8 2f       	mov	r30, r24
    2c96:	f0 e0       	ldi	r31, 0x00	; 0
    2c98:	ee 0f       	add	r30, r30
    2c9a:	ff 1f       	adc	r31, r31
    2c9c:	e6 51       	subi	r30, 0x16	; 22
    2c9e:	f1 4f       	sbci	r31, 0xF1	; 241
    2ca0:	71 83       	std	Z+1, r23	; 0x01
    2ca2:	60 83       	st	Z, r22
}
    2ca4:	08 95       	ret

00002ca6 <timer_detach>:

void timer_detach(TimerInterrupt_t interrupt)
{
  // clear the user defined interrupt function
  TimerIntFunc[interrupt] = NULL;
    2ca6:	e8 2f       	mov	r30, r24
    2ca8:	f0 e0       	ldi	r31, 0x00	; 0
    2caa:	ee 0f       	add	r30, r30
    2cac:	ff 1f       	adc	r31, r31
    2cae:	e6 51       	subi	r30, 0x16	; 22
    2cb0:	f1 4f       	sbci	r31, 0xF1	; 241
    2cb2:	11 82       	std	Z+1, r1	; 0x01
    2cb4:	10 82       	st	Z, r1
}
    2cb6:	08 95       	ret

00002cb8 <_delay_loop_2>:

void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    2cb8:	01 97       	sbiw	r24, 0x01	; 1
    2cba:	f1 f7       	brne	.-4      	; 0x2cb8 <_delay_loop_2>
		"1: sbiw %0,1" "\n\t"
		"brne 1b"
		: "=w" (__count)
		: "0" (__count)
	);
}
    2cbc:	08 95       	ret

00002cbe <sleep>:

void sleep(uint16_t time_ms)
{
    2cbe:	af 92       	push	r10
    2cc0:	bf 92       	push	r11
    2cc2:	cf 92       	push	r12
    2cc4:	df 92       	push	r13
    2cc6:	ef 92       	push	r14
    2cc8:	ff 92       	push	r15
    2cca:	0f 93       	push	r16
    2ccc:	1f 93       	push	r17
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * time_ms;
    2cce:	a0 e0       	ldi	r26, 0x00	; 0
    2cd0:	b0 e0       	ldi	r27, 0x00	; 0
    2cd2:	bc 01       	movw	r22, r24
    2cd4:	cd 01       	movw	r24, r26
    2cd6:	0e 94 9c 27 	call	0x4f38	; 0x4f38 <__floatunsisf>
    2cda:	5b 01       	movw	r10, r22
    2cdc:	6c 01       	movw	r12, r24
    2cde:	20 e0       	ldi	r18, 0x00	; 0
    2ce0:	30 e0       	ldi	r19, 0x00	; 0
    2ce2:	4a e7       	ldi	r20, 0x7A	; 122
    2ce4:	55 e4       	ldi	r21, 0x45	; 69
    2ce6:	0e 94 52 28 	call	0x50a4	; 0x50a4 <__mulsf3>
    2cea:	7b 01       	movw	r14, r22
    2cec:	8c 01       	movw	r16, r24
	if (__tmp < 1.0)
    2cee:	20 e0       	ldi	r18, 0x00	; 0
    2cf0:	30 e0       	ldi	r19, 0x00	; 0
    2cf2:	40 e8       	ldi	r20, 0x80	; 128
    2cf4:	5f e3       	ldi	r21, 0x3F	; 63
    2cf6:	0e 94 04 27 	call	0x4e08	; 0x4e08 <__cmpsf2>
    2cfa:	88 23       	and	r24, r24
    2cfc:	1c f4       	brge	.+6      	; 0x2d04 <sleep+0x46>
    2cfe:	61 e0       	ldi	r22, 0x01	; 1
    2d00:	70 e0       	ldi	r23, 0x00	; 0
    2d02:	24 c0       	rjmp	.+72     	; 0x2d4c <sleep+0x8e>
		__ticks = 1;
	else if (__tmp > 65535)
    2d04:	c8 01       	movw	r24, r16
    2d06:	b7 01       	movw	r22, r14
    2d08:	20 e0       	ldi	r18, 0x00	; 0
    2d0a:	3f ef       	ldi	r19, 0xFF	; 255
    2d0c:	4f e7       	ldi	r20, 0x7F	; 127
    2d0e:	57 e4       	ldi	r21, 0x47	; 71
    2d10:	0e 94 4e 28 	call	0x509c	; 0x509c <__gesf2>
    2d14:	18 16       	cp	r1, r24
    2d16:	b4 f4       	brge	.+44     	; 0x2d44 <sleep+0x86>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (time_ms * 10.0);
    2d18:	c6 01       	movw	r24, r12
    2d1a:	b5 01       	movw	r22, r10
    2d1c:	20 e0       	ldi	r18, 0x00	; 0
    2d1e:	30 e0       	ldi	r19, 0x00	; 0
    2d20:	40 e2       	ldi	r20, 0x20	; 32
    2d22:	51 e4       	ldi	r21, 0x41	; 65
    2d24:	0e 94 52 28 	call	0x50a4	; 0x50a4 <__mulsf3>
    2d28:	0e 94 70 27 	call	0x4ee0	; 0x4ee0 <__fixunssfsi>
}

void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    2d2c:	80 e9       	ldi	r24, 0x90	; 144
    2d2e:	91 e0       	ldi	r25, 0x01	; 1
    2d30:	05 c0       	rjmp	.+10     	; 0x2d3c <sleep+0x7e>
    2d32:	fc 01       	movw	r30, r24
    2d34:	31 97       	sbiw	r30, 0x01	; 1
    2d36:	f1 f7       	brne	.-4      	; 0x2d34 <sleep+0x76>
		__ticks = (uint16_t) (time_ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2d38:	61 50       	subi	r22, 0x01	; 1
    2d3a:	70 40       	sbci	r23, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (time_ms * 10.0);
		while(__ticks)
    2d3c:	61 15       	cp	r22, r1
    2d3e:	71 05       	cpc	r23, r1
    2d40:	c1 f7       	brne	.-16     	; 0x2d32 <sleep+0x74>
    2d42:	07 c0       	rjmp	.+14     	; 0x2d52 <sleep+0x94>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2d44:	c8 01       	movw	r24, r16
    2d46:	b7 01       	movw	r22, r14
    2d48:	0e 94 70 27 	call	0x4ee0	; 0x4ee0 <__fixunssfsi>
}

void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    2d4c:	cb 01       	movw	r24, r22
    2d4e:	01 97       	sbiw	r24, 0x01	; 1
    2d50:	f1 f7       	brne	.-4      	; 0x2d4e <sleep+0x90>
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
	_delay_loop_2(__ticks);
}
    2d52:	1f 91       	pop	r17
    2d54:	0f 91       	pop	r16
    2d56:	ff 90       	pop	r15
    2d58:	ef 90       	pop	r14
    2d5a:	df 90       	pop	r13
    2d5c:	cf 90       	pop	r12
    2d5e:	bf 90       	pop	r11
    2d60:	af 90       	pop	r10
    2d62:	08 95       	ret

00002d64 <__vector_23>:
    }
  }
}*/

ISR(TIMER0_OVF_vect) 
{
    2d64:	1f 92       	push	r1
    2d66:	0f 92       	push	r0
    2d68:	0f b6       	in	r0, 0x3f	; 63
    2d6a:	0f 92       	push	r0
    2d6c:	11 24       	eor	r1, r1
    2d6e:	2f 93       	push	r18
    2d70:	3f 93       	push	r19
    2d72:	4f 93       	push	r20
    2d74:	5f 93       	push	r21
    2d76:	6f 93       	push	r22
    2d78:	7f 93       	push	r23
    2d7a:	8f 93       	push	r24
    2d7c:	9f 93       	push	r25
    2d7e:	af 93       	push	r26
    2d80:	bf 93       	push	r27
    2d82:	ef 93       	push	r30
    2d84:	ff 93       	push	r31
  timer0_ovrflow_cnt++;
    2d86:	80 91 c6 12 	lds	r24, 0x12C6
    2d8a:	90 91 c7 12 	lds	r25, 0x12C7
    2d8e:	a0 91 c8 12 	lds	r26, 0x12C8
    2d92:	b0 91 c9 12 	lds	r27, 0x12C9
    2d96:	01 96       	adiw	r24, 0x01	; 1
    2d98:	a1 1d       	adc	r26, r1
    2d9a:	b1 1d       	adc	r27, r1
    2d9c:	80 93 c6 12 	sts	0x12C6, r24
    2da0:	90 93 c7 12 	sts	0x12C7, r25
    2da4:	a0 93 c8 12 	sts	0x12C8, r26
    2da8:	b0 93 c9 12 	sts	0x12C9, r27
  timer_sleep_cnt++;
    2dac:	80 91 ce 12 	lds	r24, 0x12CE
    2db0:	90 91 cf 12 	lds	r25, 0x12CF
    2db4:	a0 91 d0 12 	lds	r26, 0x12D0
    2db8:	b0 91 d1 12 	lds	r27, 0x12D1
    2dbc:	01 96       	adiw	r24, 0x01	; 1
    2dbe:	a1 1d       	adc	r26, r1
    2dc0:	b1 1d       	adc	r27, r1
    2dc2:	80 93 ce 12 	sts	0x12CE, r24
    2dc6:	90 93 cf 12 	sts	0x12CF, r25
    2dca:	a0 93 d0 12 	sts	0x12D0, r26
    2dce:	b0 93 d1 12 	sts	0x12D1, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER0_OVF_interrupt);
    2dd2:	80 91 ee 0e 	lds	r24, 0x0EEE
    2dd6:	90 91 ef 0e 	lds	r25, 0x0EEF
    2dda:	89 2b       	or	r24, r25
    2ddc:	29 f0       	breq	.+10     	; 0x2de8 <__vector_23+0x84>
    2dde:	e0 91 ee 0e 	lds	r30, 0x0EEE
    2de2:	f0 91 ef 0e 	lds	r31, 0x0EEF
    2de6:	09 95       	icall
}
    2de8:	ff 91       	pop	r31
    2dea:	ef 91       	pop	r30
    2dec:	bf 91       	pop	r27
    2dee:	af 91       	pop	r26
    2df0:	9f 91       	pop	r25
    2df2:	8f 91       	pop	r24
    2df4:	7f 91       	pop	r23
    2df6:	6f 91       	pop	r22
    2df8:	5f 91       	pop	r21
    2dfa:	4f 91       	pop	r20
    2dfc:	3f 91       	pop	r19
    2dfe:	2f 91       	pop	r18
    2e00:	0f 90       	pop	r0
    2e02:	0f be       	out	0x3f, r0	; 63
    2e04:	0f 90       	pop	r0
    2e06:	1f 90       	pop	r1
    2e08:	18 95       	reti

00002e0a <__vector_20>:
ISR(TIMER1_OVF_vect) 
{
    2e0a:	1f 92       	push	r1
    2e0c:	0f 92       	push	r0
    2e0e:	0f b6       	in	r0, 0x3f	; 63
    2e10:	0f 92       	push	r0
    2e12:	11 24       	eor	r1, r1
    2e14:	2f 93       	push	r18
    2e16:	3f 93       	push	r19
    2e18:	4f 93       	push	r20
    2e1a:	5f 93       	push	r21
    2e1c:	6f 93       	push	r22
    2e1e:	7f 93       	push	r23
    2e20:	8f 93       	push	r24
    2e22:	9f 93       	push	r25
    2e24:	af 93       	push	r26
    2e26:	bf 93       	push	r27
    2e28:	ef 93       	push	r30
    2e2a:	ff 93       	push	r31
  timer1_ovrflow_cnt++;
    2e2c:	80 91 c2 12 	lds	r24, 0x12C2
    2e30:	90 91 c3 12 	lds	r25, 0x12C3
    2e34:	a0 91 c4 12 	lds	r26, 0x12C4
    2e38:	b0 91 c5 12 	lds	r27, 0x12C5
    2e3c:	01 96       	adiw	r24, 0x01	; 1
    2e3e:	a1 1d       	adc	r26, r1
    2e40:	b1 1d       	adc	r27, r1
    2e42:	80 93 c2 12 	sts	0x12C2, r24
    2e46:	90 93 c3 12 	sts	0x12C3, r25
    2e4a:	a0 93 c4 12 	sts	0x12C4, r26
    2e4e:	b0 93 c5 12 	sts	0x12C5, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER1_OVF_interrupt);
    2e52:	80 91 f8 0e 	lds	r24, 0x0EF8
    2e56:	90 91 f9 0e 	lds	r25, 0x0EF9
    2e5a:	89 2b       	or	r24, r25
    2e5c:	29 f0       	breq	.+10     	; 0x2e68 <__vector_20+0x5e>
    2e5e:	e0 91 f8 0e 	lds	r30, 0x0EF8
    2e62:	f0 91 f9 0e 	lds	r31, 0x0EF9
    2e66:	09 95       	icall
}
    2e68:	ff 91       	pop	r31
    2e6a:	ef 91       	pop	r30
    2e6c:	bf 91       	pop	r27
    2e6e:	af 91       	pop	r26
    2e70:	9f 91       	pop	r25
    2e72:	8f 91       	pop	r24
    2e74:	7f 91       	pop	r23
    2e76:	6f 91       	pop	r22
    2e78:	5f 91       	pop	r21
    2e7a:	4f 91       	pop	r20
    2e7c:	3f 91       	pop	r19
    2e7e:	2f 91       	pop	r18
    2e80:	0f 90       	pop	r0
    2e82:	0f be       	out	0x3f, r0	; 63
    2e84:	0f 90       	pop	r0
    2e86:	1f 90       	pop	r1
    2e88:	18 95       	reti

00002e8a <__vector_15>:
ISR(TIMER2_OVF_vect) 
{
    2e8a:	1f 92       	push	r1
    2e8c:	0f 92       	push	r0
    2e8e:	0f b6       	in	r0, 0x3f	; 63
    2e90:	0f 92       	push	r0
    2e92:	11 24       	eor	r1, r1
    2e94:	2f 93       	push	r18
    2e96:	3f 93       	push	r19
    2e98:	4f 93       	push	r20
    2e9a:	5f 93       	push	r21
    2e9c:	6f 93       	push	r22
    2e9e:	7f 93       	push	r23
    2ea0:	8f 93       	push	r24
    2ea2:	9f 93       	push	r25
    2ea4:	af 93       	push	r26
    2ea6:	bf 93       	push	r27
    2ea8:	ef 93       	push	r30
    2eaa:	ff 93       	push	r31
  timer2_ovrflow_cnt++;
    2eac:	80 91 ca 12 	lds	r24, 0x12CA
    2eb0:	90 91 cb 12 	lds	r25, 0x12CB
    2eb4:	a0 91 cc 12 	lds	r26, 0x12CC
    2eb8:	b0 91 cd 12 	lds	r27, 0x12CD
    2ebc:	01 96       	adiw	r24, 0x01	; 1
    2ebe:	a1 1d       	adc	r26, r1
    2ec0:	b1 1d       	adc	r27, r1
    2ec2:	80 93 ca 12 	sts	0x12CA, r24
    2ec6:	90 93 cb 12 	sts	0x12CB, r25
    2eca:	a0 93 cc 12 	sts	0x12CC, r26
    2ece:	b0 93 cd 12 	sts	0x12CD, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER2_OVF_interrupt);
    2ed2:	80 91 fe 0e 	lds	r24, 0x0EFE
    2ed6:	90 91 ff 0e 	lds	r25, 0x0EFF
    2eda:	89 2b       	or	r24, r25
    2edc:	29 f0       	breq	.+10     	; 0x2ee8 <__vector_15+0x5e>
    2ede:	e0 91 fe 0e 	lds	r30, 0x0EFE
    2ee2:	f0 91 ff 0e 	lds	r31, 0x0EFF
    2ee6:	09 95       	icall
}
    2ee8:	ff 91       	pop	r31
    2eea:	ef 91       	pop	r30
    2eec:	bf 91       	pop	r27
    2eee:	af 91       	pop	r26
    2ef0:	9f 91       	pop	r25
    2ef2:	8f 91       	pop	r24
    2ef4:	7f 91       	pop	r23
    2ef6:	6f 91       	pop	r22
    2ef8:	5f 91       	pop	r21
    2efa:	4f 91       	pop	r20
    2efc:	3f 91       	pop	r19
    2efe:	2f 91       	pop	r18
    2f00:	0f 90       	pop	r0
    2f02:	0f be       	out	0x3f, r0	; 63
    2f04:	0f 90       	pop	r0
    2f06:	1f 90       	pop	r1
    2f08:	18 95       	reti

00002f0a <__vector_35>:
ISR(TIMER3_OVF_vect) 
{
    2f0a:	1f 92       	push	r1
    2f0c:	0f 92       	push	r0
    2f0e:	0f b6       	in	r0, 0x3f	; 63
    2f10:	0f 92       	push	r0
    2f12:	11 24       	eor	r1, r1
    2f14:	2f 93       	push	r18
    2f16:	3f 93       	push	r19
    2f18:	4f 93       	push	r20
    2f1a:	5f 93       	push	r21
    2f1c:	6f 93       	push	r22
    2f1e:	7f 93       	push	r23
    2f20:	8f 93       	push	r24
    2f22:	9f 93       	push	r25
    2f24:	af 93       	push	r26
    2f26:	bf 93       	push	r27
    2f28:	ef 93       	push	r30
    2f2a:	ff 93       	push	r31
  timer3_ovrflow_cnt++;
    2f2c:	80 91 d2 12 	lds	r24, 0x12D2
    2f30:	90 91 d3 12 	lds	r25, 0x12D3
    2f34:	a0 91 d4 12 	lds	r26, 0x12D4
    2f38:	b0 91 d5 12 	lds	r27, 0x12D5
    2f3c:	01 96       	adiw	r24, 0x01	; 1
    2f3e:	a1 1d       	adc	r26, r1
    2f40:	b1 1d       	adc	r27, r1
    2f42:	80 93 d2 12 	sts	0x12D2, r24
    2f46:	90 93 d3 12 	sts	0x12D3, r25
    2f4a:	a0 93 d4 12 	sts	0x12D4, r26
    2f4e:	b0 93 d5 12 	sts	0x12D5, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER3_OVF_interrupt);
    2f52:	80 91 08 0f 	lds	r24, 0x0F08
    2f56:	90 91 09 0f 	lds	r25, 0x0F09
    2f5a:	89 2b       	or	r24, r25
    2f5c:	29 f0       	breq	.+10     	; 0x2f68 <__vector_35+0x5e>
    2f5e:	e0 91 08 0f 	lds	r30, 0x0F08
    2f62:	f0 91 09 0f 	lds	r31, 0x0F09
    2f66:	09 95       	icall
}
    2f68:	ff 91       	pop	r31
    2f6a:	ef 91       	pop	r30
    2f6c:	bf 91       	pop	r27
    2f6e:	af 91       	pop	r26
    2f70:	9f 91       	pop	r25
    2f72:	8f 91       	pop	r24
    2f74:	7f 91       	pop	r23
    2f76:	6f 91       	pop	r22
    2f78:	5f 91       	pop	r21
    2f7a:	4f 91       	pop	r20
    2f7c:	3f 91       	pop	r19
    2f7e:	2f 91       	pop	r18
    2f80:	0f 90       	pop	r0
    2f82:	0f be       	out	0x3f, r0	; 63
    2f84:	0f 90       	pop	r0
    2f86:	1f 90       	pop	r1
    2f88:	18 95       	reti

00002f8a <__vector_45>:
ISR(TIMER4_OVF_vect) 
{
    2f8a:	1f 92       	push	r1
    2f8c:	0f 92       	push	r0
    2f8e:	0f b6       	in	r0, 0x3f	; 63
    2f90:	0f 92       	push	r0
    2f92:	11 24       	eor	r1, r1
    2f94:	2f 93       	push	r18
    2f96:	3f 93       	push	r19
    2f98:	4f 93       	push	r20
    2f9a:	5f 93       	push	r21
    2f9c:	6f 93       	push	r22
    2f9e:	7f 93       	push	r23
    2fa0:	8f 93       	push	r24
    2fa2:	9f 93       	push	r25
    2fa4:	af 93       	push	r26
    2fa6:	bf 93       	push	r27
    2fa8:	ef 93       	push	r30
    2faa:	ff 93       	push	r31
  timer4_ovrflow_cnt++;
    2fac:	80 91 be 12 	lds	r24, 0x12BE
    2fb0:	90 91 bf 12 	lds	r25, 0x12BF
    2fb4:	a0 91 c0 12 	lds	r26, 0x12C0
    2fb8:	b0 91 c1 12 	lds	r27, 0x12C1
    2fbc:	01 96       	adiw	r24, 0x01	; 1
    2fbe:	a1 1d       	adc	r26, r1
    2fc0:	b1 1d       	adc	r27, r1
    2fc2:	80 93 be 12 	sts	0x12BE, r24
    2fc6:	90 93 bf 12 	sts	0x12BF, r25
    2fca:	a0 93 c0 12 	sts	0x12C0, r26
    2fce:	b0 93 c1 12 	sts	0x12C1, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER4_OVF_interrupt);
    2fd2:	80 91 12 0f 	lds	r24, 0x0F12
    2fd6:	90 91 13 0f 	lds	r25, 0x0F13
    2fda:	89 2b       	or	r24, r25
    2fdc:	29 f0       	breq	.+10     	; 0x2fe8 <__vector_45+0x5e>
    2fde:	e0 91 12 0f 	lds	r30, 0x0F12
    2fe2:	f0 91 13 0f 	lds	r31, 0x0F13
    2fe6:	09 95       	icall
}
    2fe8:	ff 91       	pop	r31
    2fea:	ef 91       	pop	r30
    2fec:	bf 91       	pop	r27
    2fee:	af 91       	pop	r26
    2ff0:	9f 91       	pop	r25
    2ff2:	8f 91       	pop	r24
    2ff4:	7f 91       	pop	r23
    2ff6:	6f 91       	pop	r22
    2ff8:	5f 91       	pop	r21
    2ffa:	4f 91       	pop	r20
    2ffc:	3f 91       	pop	r19
    2ffe:	2f 91       	pop	r18
    3000:	0f 90       	pop	r0
    3002:	0f be       	out	0x3f, r0	; 63
    3004:	0f 90       	pop	r0
    3006:	1f 90       	pop	r1
    3008:	18 95       	reti

0000300a <__vector_50>:
ISR(TIMER5_OVF_vect) 
{
    300a:	1f 92       	push	r1
    300c:	0f 92       	push	r0
    300e:	0f b6       	in	r0, 0x3f	; 63
    3010:	0f 92       	push	r0
    3012:	11 24       	eor	r1, r1
    3014:	2f 93       	push	r18
    3016:	3f 93       	push	r19
    3018:	4f 93       	push	r20
    301a:	5f 93       	push	r21
    301c:	6f 93       	push	r22
    301e:	7f 93       	push	r23
    3020:	8f 93       	push	r24
    3022:	9f 93       	push	r25
    3024:	af 93       	push	r26
    3026:	bf 93       	push	r27
    3028:	ef 93       	push	r30
    302a:	ff 93       	push	r31
  timer5_ovrflow_cnt++;
    302c:	80 91 d6 12 	lds	r24, 0x12D6
    3030:	90 91 d7 12 	lds	r25, 0x12D7
    3034:	a0 91 d8 12 	lds	r26, 0x12D8
    3038:	b0 91 d9 12 	lds	r27, 0x12D9
    303c:	01 96       	adiw	r24, 0x01	; 1
    303e:	a1 1d       	adc	r26, r1
    3040:	b1 1d       	adc	r27, r1
    3042:	80 93 d6 12 	sts	0x12D6, r24
    3046:	90 93 d7 12 	sts	0x12D7, r25
    304a:	a0 93 d8 12 	sts	0x12D8, r26
    304e:	b0 93 d9 12 	sts	0x12D9, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER5_OVF_interrupt);
    3052:	80 91 1c 0f 	lds	r24, 0x0F1C
    3056:	90 91 1d 0f 	lds	r25, 0x0F1D
    305a:	89 2b       	or	r24, r25
    305c:	29 f0       	breq	.+10     	; 0x3068 <__vector_50+0x5e>
    305e:	e0 91 1c 0f 	lds	r30, 0x0F1C
    3062:	f0 91 1d 0f 	lds	r31, 0x0F1D
    3066:	09 95       	icall
}
    3068:	ff 91       	pop	r31
    306a:	ef 91       	pop	r30
    306c:	bf 91       	pop	r27
    306e:	af 91       	pop	r26
    3070:	9f 91       	pop	r25
    3072:	8f 91       	pop	r24
    3074:	7f 91       	pop	r23
    3076:	6f 91       	pop	r22
    3078:	5f 91       	pop	r21
    307a:	4f 91       	pop	r20
    307c:	3f 91       	pop	r19
    307e:	2f 91       	pop	r18
    3080:	0f 90       	pop	r0
    3082:	0f be       	out	0x3f, r0	; 63
    3084:	0f 90       	pop	r0
    3086:	1f 90       	pop	r1
    3088:	18 95       	reti

0000308a <__vector_21>:
ISR(TIMER0_COMPA_vect)
{
    308a:	1f 92       	push	r1
    308c:	0f 92       	push	r0
    308e:	0f b6       	in	r0, 0x3f	; 63
    3090:	0f 92       	push	r0
    3092:	11 24       	eor	r1, r1
    3094:	2f 93       	push	r18
    3096:	3f 93       	push	r19
    3098:	4f 93       	push	r20
    309a:	5f 93       	push	r21
    309c:	6f 93       	push	r22
    309e:	7f 93       	push	r23
    30a0:	8f 93       	push	r24
    30a2:	9f 93       	push	r25
    30a4:	af 93       	push	r26
    30a6:	bf 93       	push	r27
    30a8:	ef 93       	push	r30
    30aa:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER0_COMPA_interrupt);
    30ac:	80 91 ea 0e 	lds	r24, 0x0EEA
    30b0:	90 91 eb 0e 	lds	r25, 0x0EEB
    30b4:	89 2b       	or	r24, r25
    30b6:	29 f0       	breq	.+10     	; 0x30c2 <__vector_21+0x38>
    30b8:	e0 91 ea 0e 	lds	r30, 0x0EEA
    30bc:	f0 91 eb 0e 	lds	r31, 0x0EEB
    30c0:	09 95       	icall
}
    30c2:	ff 91       	pop	r31
    30c4:	ef 91       	pop	r30
    30c6:	bf 91       	pop	r27
    30c8:	af 91       	pop	r26
    30ca:	9f 91       	pop	r25
    30cc:	8f 91       	pop	r24
    30ce:	7f 91       	pop	r23
    30d0:	6f 91       	pop	r22
    30d2:	5f 91       	pop	r21
    30d4:	4f 91       	pop	r20
    30d6:	3f 91       	pop	r19
    30d8:	2f 91       	pop	r18
    30da:	0f 90       	pop	r0
    30dc:	0f be       	out	0x3f, r0	; 63
    30de:	0f 90       	pop	r0
    30e0:	1f 90       	pop	r1
    30e2:	18 95       	reti

000030e4 <__vector_22>:
ISR(TIMER0_COMPB_vect)
{
    30e4:	1f 92       	push	r1
    30e6:	0f 92       	push	r0
    30e8:	0f b6       	in	r0, 0x3f	; 63
    30ea:	0f 92       	push	r0
    30ec:	11 24       	eor	r1, r1
    30ee:	2f 93       	push	r18
    30f0:	3f 93       	push	r19
    30f2:	4f 93       	push	r20
    30f4:	5f 93       	push	r21
    30f6:	6f 93       	push	r22
    30f8:	7f 93       	push	r23
    30fa:	8f 93       	push	r24
    30fc:	9f 93       	push	r25
    30fe:	af 93       	push	r26
    3100:	bf 93       	push	r27
    3102:	ef 93       	push	r30
    3104:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER0_COMPB_interrupt);
    3106:	80 91 ec 0e 	lds	r24, 0x0EEC
    310a:	90 91 ed 0e 	lds	r25, 0x0EED
    310e:	89 2b       	or	r24, r25
    3110:	29 f0       	breq	.+10     	; 0x311c <__vector_22+0x38>
    3112:	e0 91 ec 0e 	lds	r30, 0x0EEC
    3116:	f0 91 ed 0e 	lds	r31, 0x0EED
    311a:	09 95       	icall
}
    311c:	ff 91       	pop	r31
    311e:	ef 91       	pop	r30
    3120:	bf 91       	pop	r27
    3122:	af 91       	pop	r26
    3124:	9f 91       	pop	r25
    3126:	8f 91       	pop	r24
    3128:	7f 91       	pop	r23
    312a:	6f 91       	pop	r22
    312c:	5f 91       	pop	r21
    312e:	4f 91       	pop	r20
    3130:	3f 91       	pop	r19
    3132:	2f 91       	pop	r18
    3134:	0f 90       	pop	r0
    3136:	0f be       	out	0x3f, r0	; 63
    3138:	0f 90       	pop	r0
    313a:	1f 90       	pop	r1
    313c:	18 95       	reti

0000313e <__vector_16>:
ISR(TIMER1_CAPT_vect)
{
    313e:	1f 92       	push	r1
    3140:	0f 92       	push	r0
    3142:	0f b6       	in	r0, 0x3f	; 63
    3144:	0f 92       	push	r0
    3146:	11 24       	eor	r1, r1
    3148:	2f 93       	push	r18
    314a:	3f 93       	push	r19
    314c:	4f 93       	push	r20
    314e:	5f 93       	push	r21
    3150:	6f 93       	push	r22
    3152:	7f 93       	push	r23
    3154:	8f 93       	push	r24
    3156:	9f 93       	push	r25
    3158:	af 93       	push	r26
    315a:	bf 93       	push	r27
    315c:	ef 93       	push	r30
    315e:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER1_CAPT_interrupt);
    3160:	80 91 f0 0e 	lds	r24, 0x0EF0
    3164:	90 91 f1 0e 	lds	r25, 0x0EF1
    3168:	89 2b       	or	r24, r25
    316a:	29 f0       	breq	.+10     	; 0x3176 <__vector_16+0x38>
    316c:	e0 91 f0 0e 	lds	r30, 0x0EF0
    3170:	f0 91 f1 0e 	lds	r31, 0x0EF1
    3174:	09 95       	icall
}
    3176:	ff 91       	pop	r31
    3178:	ef 91       	pop	r30
    317a:	bf 91       	pop	r27
    317c:	af 91       	pop	r26
    317e:	9f 91       	pop	r25
    3180:	8f 91       	pop	r24
    3182:	7f 91       	pop	r23
    3184:	6f 91       	pop	r22
    3186:	5f 91       	pop	r21
    3188:	4f 91       	pop	r20
    318a:	3f 91       	pop	r19
    318c:	2f 91       	pop	r18
    318e:	0f 90       	pop	r0
    3190:	0f be       	out	0x3f, r0	; 63
    3192:	0f 90       	pop	r0
    3194:	1f 90       	pop	r1
    3196:	18 95       	reti

00003198 <__vector_18>:
{
  RUN_USER_DEFINE_INTERRUPT(TIMER1_COMPA_interrupt);
}
*/
ISR(TIMER1_COMPB_vect)
{
    3198:	1f 92       	push	r1
    319a:	0f 92       	push	r0
    319c:	0f b6       	in	r0, 0x3f	; 63
    319e:	0f 92       	push	r0
    31a0:	11 24       	eor	r1, r1
    31a2:	2f 93       	push	r18
    31a4:	3f 93       	push	r19
    31a6:	4f 93       	push	r20
    31a8:	5f 93       	push	r21
    31aa:	6f 93       	push	r22
    31ac:	7f 93       	push	r23
    31ae:	8f 93       	push	r24
    31b0:	9f 93       	push	r25
    31b2:	af 93       	push	r26
    31b4:	bf 93       	push	r27
    31b6:	ef 93       	push	r30
    31b8:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER1_COMPB_interrupt);
    31ba:	80 91 f4 0e 	lds	r24, 0x0EF4
    31be:	90 91 f5 0e 	lds	r25, 0x0EF5
    31c2:	89 2b       	or	r24, r25
    31c4:	29 f0       	breq	.+10     	; 0x31d0 <__vector_18+0x38>
    31c6:	e0 91 f4 0e 	lds	r30, 0x0EF4
    31ca:	f0 91 f5 0e 	lds	r31, 0x0EF5
    31ce:	09 95       	icall
}
    31d0:	ff 91       	pop	r31
    31d2:	ef 91       	pop	r30
    31d4:	bf 91       	pop	r27
    31d6:	af 91       	pop	r26
    31d8:	9f 91       	pop	r25
    31da:	8f 91       	pop	r24
    31dc:	7f 91       	pop	r23
    31de:	6f 91       	pop	r22
    31e0:	5f 91       	pop	r21
    31e2:	4f 91       	pop	r20
    31e4:	3f 91       	pop	r19
    31e6:	2f 91       	pop	r18
    31e8:	0f 90       	pop	r0
    31ea:	0f be       	out	0x3f, r0	; 63
    31ec:	0f 90       	pop	r0
    31ee:	1f 90       	pop	r1
    31f0:	18 95       	reti

000031f2 <__vector_19>:
ISR(TIMER1_COMPC_vect)
{
    31f2:	1f 92       	push	r1
    31f4:	0f 92       	push	r0
    31f6:	0f b6       	in	r0, 0x3f	; 63
    31f8:	0f 92       	push	r0
    31fa:	11 24       	eor	r1, r1
    31fc:	2f 93       	push	r18
    31fe:	3f 93       	push	r19
    3200:	4f 93       	push	r20
    3202:	5f 93       	push	r21
    3204:	6f 93       	push	r22
    3206:	7f 93       	push	r23
    3208:	8f 93       	push	r24
    320a:	9f 93       	push	r25
    320c:	af 93       	push	r26
    320e:	bf 93       	push	r27
    3210:	ef 93       	push	r30
    3212:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER1_COMPC_interrupt);
    3214:	80 91 f6 0e 	lds	r24, 0x0EF6
    3218:	90 91 f7 0e 	lds	r25, 0x0EF7
    321c:	89 2b       	or	r24, r25
    321e:	29 f0       	breq	.+10     	; 0x322a <__vector_19+0x38>
    3220:	e0 91 f6 0e 	lds	r30, 0x0EF6
    3224:	f0 91 f7 0e 	lds	r31, 0x0EF7
    3228:	09 95       	icall
}
    322a:	ff 91       	pop	r31
    322c:	ef 91       	pop	r30
    322e:	bf 91       	pop	r27
    3230:	af 91       	pop	r26
    3232:	9f 91       	pop	r25
    3234:	8f 91       	pop	r24
    3236:	7f 91       	pop	r23
    3238:	6f 91       	pop	r22
    323a:	5f 91       	pop	r21
    323c:	4f 91       	pop	r20
    323e:	3f 91       	pop	r19
    3240:	2f 91       	pop	r18
    3242:	0f 90       	pop	r0
    3244:	0f be       	out	0x3f, r0	; 63
    3246:	0f 90       	pop	r0
    3248:	1f 90       	pop	r1
    324a:	18 95       	reti

0000324c <__vector_13>:
ISR(TIMER2_COMPA_vect)
{
    324c:	1f 92       	push	r1
    324e:	0f 92       	push	r0
    3250:	0f b6       	in	r0, 0x3f	; 63
    3252:	0f 92       	push	r0
    3254:	11 24       	eor	r1, r1
    3256:	2f 93       	push	r18
    3258:	3f 93       	push	r19
    325a:	4f 93       	push	r20
    325c:	5f 93       	push	r21
    325e:	6f 93       	push	r22
    3260:	7f 93       	push	r23
    3262:	8f 93       	push	r24
    3264:	9f 93       	push	r25
    3266:	af 93       	push	r26
    3268:	bf 93       	push	r27
    326a:	ef 93       	push	r30
    326c:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER2_COMPA_interrupt);
    326e:	80 91 fa 0e 	lds	r24, 0x0EFA
    3272:	90 91 fb 0e 	lds	r25, 0x0EFB
    3276:	89 2b       	or	r24, r25
    3278:	29 f0       	breq	.+10     	; 0x3284 <__vector_13+0x38>
    327a:	e0 91 fa 0e 	lds	r30, 0x0EFA
    327e:	f0 91 fb 0e 	lds	r31, 0x0EFB
    3282:	09 95       	icall
}
    3284:	ff 91       	pop	r31
    3286:	ef 91       	pop	r30
    3288:	bf 91       	pop	r27
    328a:	af 91       	pop	r26
    328c:	9f 91       	pop	r25
    328e:	8f 91       	pop	r24
    3290:	7f 91       	pop	r23
    3292:	6f 91       	pop	r22
    3294:	5f 91       	pop	r21
    3296:	4f 91       	pop	r20
    3298:	3f 91       	pop	r19
    329a:	2f 91       	pop	r18
    329c:	0f 90       	pop	r0
    329e:	0f be       	out	0x3f, r0	; 63
    32a0:	0f 90       	pop	r0
    32a2:	1f 90       	pop	r1
    32a4:	18 95       	reti

000032a6 <__vector_14>:
ISR(TIMER2_COMPB_vect)
{
    32a6:	1f 92       	push	r1
    32a8:	0f 92       	push	r0
    32aa:	0f b6       	in	r0, 0x3f	; 63
    32ac:	0f 92       	push	r0
    32ae:	11 24       	eor	r1, r1
    32b0:	2f 93       	push	r18
    32b2:	3f 93       	push	r19
    32b4:	4f 93       	push	r20
    32b6:	5f 93       	push	r21
    32b8:	6f 93       	push	r22
    32ba:	7f 93       	push	r23
    32bc:	8f 93       	push	r24
    32be:	9f 93       	push	r25
    32c0:	af 93       	push	r26
    32c2:	bf 93       	push	r27
    32c4:	ef 93       	push	r30
    32c6:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER2_COMPB_interrupt);
    32c8:	80 91 fc 0e 	lds	r24, 0x0EFC
    32cc:	90 91 fd 0e 	lds	r25, 0x0EFD
    32d0:	89 2b       	or	r24, r25
    32d2:	29 f0       	breq	.+10     	; 0x32de <__vector_14+0x38>
    32d4:	e0 91 fc 0e 	lds	r30, 0x0EFC
    32d8:	f0 91 fd 0e 	lds	r31, 0x0EFD
    32dc:	09 95       	icall
}
    32de:	ff 91       	pop	r31
    32e0:	ef 91       	pop	r30
    32e2:	bf 91       	pop	r27
    32e4:	af 91       	pop	r26
    32e6:	9f 91       	pop	r25
    32e8:	8f 91       	pop	r24
    32ea:	7f 91       	pop	r23
    32ec:	6f 91       	pop	r22
    32ee:	5f 91       	pop	r21
    32f0:	4f 91       	pop	r20
    32f2:	3f 91       	pop	r19
    32f4:	2f 91       	pop	r18
    32f6:	0f 90       	pop	r0
    32f8:	0f be       	out	0x3f, r0	; 63
    32fa:	0f 90       	pop	r0
    32fc:	1f 90       	pop	r1
    32fe:	18 95       	reti

00003300 <__vector_31>:
ISR(TIMER3_CAPT_vect)
{
    3300:	1f 92       	push	r1
    3302:	0f 92       	push	r0
    3304:	0f b6       	in	r0, 0x3f	; 63
    3306:	0f 92       	push	r0
    3308:	11 24       	eor	r1, r1
    330a:	2f 93       	push	r18
    330c:	3f 93       	push	r19
    330e:	4f 93       	push	r20
    3310:	5f 93       	push	r21
    3312:	6f 93       	push	r22
    3314:	7f 93       	push	r23
    3316:	8f 93       	push	r24
    3318:	9f 93       	push	r25
    331a:	af 93       	push	r26
    331c:	bf 93       	push	r27
    331e:	ef 93       	push	r30
    3320:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_CAPT_interrupt);
    3322:	80 91 00 0f 	lds	r24, 0x0F00
    3326:	90 91 01 0f 	lds	r25, 0x0F01
    332a:	89 2b       	or	r24, r25
    332c:	29 f0       	breq	.+10     	; 0x3338 <__vector_31+0x38>
    332e:	e0 91 00 0f 	lds	r30, 0x0F00
    3332:	f0 91 01 0f 	lds	r31, 0x0F01
    3336:	09 95       	icall
}
    3338:	ff 91       	pop	r31
    333a:	ef 91       	pop	r30
    333c:	bf 91       	pop	r27
    333e:	af 91       	pop	r26
    3340:	9f 91       	pop	r25
    3342:	8f 91       	pop	r24
    3344:	7f 91       	pop	r23
    3346:	6f 91       	pop	r22
    3348:	5f 91       	pop	r21
    334a:	4f 91       	pop	r20
    334c:	3f 91       	pop	r19
    334e:	2f 91       	pop	r18
    3350:	0f 90       	pop	r0
    3352:	0f be       	out	0x3f, r0	; 63
    3354:	0f 90       	pop	r0
    3356:	1f 90       	pop	r1
    3358:	18 95       	reti

0000335a <__vector_32>:
ISR(TIMER3_COMPA_vect)
{
    335a:	1f 92       	push	r1
    335c:	0f 92       	push	r0
    335e:	0f b6       	in	r0, 0x3f	; 63
    3360:	0f 92       	push	r0
    3362:	11 24       	eor	r1, r1
    3364:	2f 93       	push	r18
    3366:	3f 93       	push	r19
    3368:	4f 93       	push	r20
    336a:	5f 93       	push	r21
    336c:	6f 93       	push	r22
    336e:	7f 93       	push	r23
    3370:	8f 93       	push	r24
    3372:	9f 93       	push	r25
    3374:	af 93       	push	r26
    3376:	bf 93       	push	r27
    3378:	ef 93       	push	r30
    337a:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_COMPA_interrupt);
    337c:	80 91 02 0f 	lds	r24, 0x0F02
    3380:	90 91 03 0f 	lds	r25, 0x0F03
    3384:	89 2b       	or	r24, r25
    3386:	29 f0       	breq	.+10     	; 0x3392 <__vector_32+0x38>
    3388:	e0 91 02 0f 	lds	r30, 0x0F02
    338c:	f0 91 03 0f 	lds	r31, 0x0F03
    3390:	09 95       	icall
}
    3392:	ff 91       	pop	r31
    3394:	ef 91       	pop	r30
    3396:	bf 91       	pop	r27
    3398:	af 91       	pop	r26
    339a:	9f 91       	pop	r25
    339c:	8f 91       	pop	r24
    339e:	7f 91       	pop	r23
    33a0:	6f 91       	pop	r22
    33a2:	5f 91       	pop	r21
    33a4:	4f 91       	pop	r20
    33a6:	3f 91       	pop	r19
    33a8:	2f 91       	pop	r18
    33aa:	0f 90       	pop	r0
    33ac:	0f be       	out	0x3f, r0	; 63
    33ae:	0f 90       	pop	r0
    33b0:	1f 90       	pop	r1
    33b2:	18 95       	reti

000033b4 <__vector_33>:
ISR(TIMER3_COMPB_vect)
{
    33b4:	1f 92       	push	r1
    33b6:	0f 92       	push	r0
    33b8:	0f b6       	in	r0, 0x3f	; 63
    33ba:	0f 92       	push	r0
    33bc:	11 24       	eor	r1, r1
    33be:	2f 93       	push	r18
    33c0:	3f 93       	push	r19
    33c2:	4f 93       	push	r20
    33c4:	5f 93       	push	r21
    33c6:	6f 93       	push	r22
    33c8:	7f 93       	push	r23
    33ca:	8f 93       	push	r24
    33cc:	9f 93       	push	r25
    33ce:	af 93       	push	r26
    33d0:	bf 93       	push	r27
    33d2:	ef 93       	push	r30
    33d4:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_COMPB_interrupt);
    33d6:	80 91 04 0f 	lds	r24, 0x0F04
    33da:	90 91 05 0f 	lds	r25, 0x0F05
    33de:	89 2b       	or	r24, r25
    33e0:	29 f0       	breq	.+10     	; 0x33ec <__vector_33+0x38>
    33e2:	e0 91 04 0f 	lds	r30, 0x0F04
    33e6:	f0 91 05 0f 	lds	r31, 0x0F05
    33ea:	09 95       	icall
}
    33ec:	ff 91       	pop	r31
    33ee:	ef 91       	pop	r30
    33f0:	bf 91       	pop	r27
    33f2:	af 91       	pop	r26
    33f4:	9f 91       	pop	r25
    33f6:	8f 91       	pop	r24
    33f8:	7f 91       	pop	r23
    33fa:	6f 91       	pop	r22
    33fc:	5f 91       	pop	r21
    33fe:	4f 91       	pop	r20
    3400:	3f 91       	pop	r19
    3402:	2f 91       	pop	r18
    3404:	0f 90       	pop	r0
    3406:	0f be       	out	0x3f, r0	; 63
    3408:	0f 90       	pop	r0
    340a:	1f 90       	pop	r1
    340c:	18 95       	reti

0000340e <__vector_34>:
ISR(TIMER3_COMPC_vect)
{
    340e:	1f 92       	push	r1
    3410:	0f 92       	push	r0
    3412:	0f b6       	in	r0, 0x3f	; 63
    3414:	0f 92       	push	r0
    3416:	11 24       	eor	r1, r1
    3418:	2f 93       	push	r18
    341a:	3f 93       	push	r19
    341c:	4f 93       	push	r20
    341e:	5f 93       	push	r21
    3420:	6f 93       	push	r22
    3422:	7f 93       	push	r23
    3424:	8f 93       	push	r24
    3426:	9f 93       	push	r25
    3428:	af 93       	push	r26
    342a:	bf 93       	push	r27
    342c:	ef 93       	push	r30
    342e:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_COMPC_interrupt);
    3430:	80 91 06 0f 	lds	r24, 0x0F06
    3434:	90 91 07 0f 	lds	r25, 0x0F07
    3438:	89 2b       	or	r24, r25
    343a:	29 f0       	breq	.+10     	; 0x3446 <__vector_34+0x38>
    343c:	e0 91 06 0f 	lds	r30, 0x0F06
    3440:	f0 91 07 0f 	lds	r31, 0x0F07
    3444:	09 95       	icall
}
    3446:	ff 91       	pop	r31
    3448:	ef 91       	pop	r30
    344a:	bf 91       	pop	r27
    344c:	af 91       	pop	r26
    344e:	9f 91       	pop	r25
    3450:	8f 91       	pop	r24
    3452:	7f 91       	pop	r23
    3454:	6f 91       	pop	r22
    3456:	5f 91       	pop	r21
    3458:	4f 91       	pop	r20
    345a:	3f 91       	pop	r19
    345c:	2f 91       	pop	r18
    345e:	0f 90       	pop	r0
    3460:	0f be       	out	0x3f, r0	; 63
    3462:	0f 90       	pop	r0
    3464:	1f 90       	pop	r1
    3466:	18 95       	reti

00003468 <__vector_41>:
ISR(TIMER4_CAPT_vect)
{
    3468:	1f 92       	push	r1
    346a:	0f 92       	push	r0
    346c:	0f b6       	in	r0, 0x3f	; 63
    346e:	0f 92       	push	r0
    3470:	11 24       	eor	r1, r1
    3472:	2f 93       	push	r18
    3474:	3f 93       	push	r19
    3476:	4f 93       	push	r20
    3478:	5f 93       	push	r21
    347a:	6f 93       	push	r22
    347c:	7f 93       	push	r23
    347e:	8f 93       	push	r24
    3480:	9f 93       	push	r25
    3482:	af 93       	push	r26
    3484:	bf 93       	push	r27
    3486:	ef 93       	push	r30
    3488:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_CAPT_interrupt);
    348a:	80 91 0a 0f 	lds	r24, 0x0F0A
    348e:	90 91 0b 0f 	lds	r25, 0x0F0B
    3492:	89 2b       	or	r24, r25
    3494:	29 f0       	breq	.+10     	; 0x34a0 <__vector_41+0x38>
    3496:	e0 91 0a 0f 	lds	r30, 0x0F0A
    349a:	f0 91 0b 0f 	lds	r31, 0x0F0B
    349e:	09 95       	icall
}
    34a0:	ff 91       	pop	r31
    34a2:	ef 91       	pop	r30
    34a4:	bf 91       	pop	r27
    34a6:	af 91       	pop	r26
    34a8:	9f 91       	pop	r25
    34aa:	8f 91       	pop	r24
    34ac:	7f 91       	pop	r23
    34ae:	6f 91       	pop	r22
    34b0:	5f 91       	pop	r21
    34b2:	4f 91       	pop	r20
    34b4:	3f 91       	pop	r19
    34b6:	2f 91       	pop	r18
    34b8:	0f 90       	pop	r0
    34ba:	0f be       	out	0x3f, r0	; 63
    34bc:	0f 90       	pop	r0
    34be:	1f 90       	pop	r1
    34c0:	18 95       	reti

000034c2 <__vector_42>:
ISR(TIMER4_COMPA_vect)
{
    34c2:	1f 92       	push	r1
    34c4:	0f 92       	push	r0
    34c6:	0f b6       	in	r0, 0x3f	; 63
    34c8:	0f 92       	push	r0
    34ca:	11 24       	eor	r1, r1
    34cc:	2f 93       	push	r18
    34ce:	3f 93       	push	r19
    34d0:	4f 93       	push	r20
    34d2:	5f 93       	push	r21
    34d4:	6f 93       	push	r22
    34d6:	7f 93       	push	r23
    34d8:	8f 93       	push	r24
    34da:	9f 93       	push	r25
    34dc:	af 93       	push	r26
    34de:	bf 93       	push	r27
    34e0:	ef 93       	push	r30
    34e2:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_COMPA_interrupt);
    34e4:	80 91 0c 0f 	lds	r24, 0x0F0C
    34e8:	90 91 0d 0f 	lds	r25, 0x0F0D
    34ec:	89 2b       	or	r24, r25
    34ee:	29 f0       	breq	.+10     	; 0x34fa <__vector_42+0x38>
    34f0:	e0 91 0c 0f 	lds	r30, 0x0F0C
    34f4:	f0 91 0d 0f 	lds	r31, 0x0F0D
    34f8:	09 95       	icall
}
    34fa:	ff 91       	pop	r31
    34fc:	ef 91       	pop	r30
    34fe:	bf 91       	pop	r27
    3500:	af 91       	pop	r26
    3502:	9f 91       	pop	r25
    3504:	8f 91       	pop	r24
    3506:	7f 91       	pop	r23
    3508:	6f 91       	pop	r22
    350a:	5f 91       	pop	r21
    350c:	4f 91       	pop	r20
    350e:	3f 91       	pop	r19
    3510:	2f 91       	pop	r18
    3512:	0f 90       	pop	r0
    3514:	0f be       	out	0x3f, r0	; 63
    3516:	0f 90       	pop	r0
    3518:	1f 90       	pop	r1
    351a:	18 95       	reti

0000351c <__vector_43>:
ISR(TIMER4_COMPB_vect)
{
    351c:	1f 92       	push	r1
    351e:	0f 92       	push	r0
    3520:	0f b6       	in	r0, 0x3f	; 63
    3522:	0f 92       	push	r0
    3524:	11 24       	eor	r1, r1
    3526:	2f 93       	push	r18
    3528:	3f 93       	push	r19
    352a:	4f 93       	push	r20
    352c:	5f 93       	push	r21
    352e:	6f 93       	push	r22
    3530:	7f 93       	push	r23
    3532:	8f 93       	push	r24
    3534:	9f 93       	push	r25
    3536:	af 93       	push	r26
    3538:	bf 93       	push	r27
    353a:	ef 93       	push	r30
    353c:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_COMPB_interrupt);
    353e:	80 91 0e 0f 	lds	r24, 0x0F0E
    3542:	90 91 0f 0f 	lds	r25, 0x0F0F
    3546:	89 2b       	or	r24, r25
    3548:	29 f0       	breq	.+10     	; 0x3554 <__vector_43+0x38>
    354a:	e0 91 0e 0f 	lds	r30, 0x0F0E
    354e:	f0 91 0f 0f 	lds	r31, 0x0F0F
    3552:	09 95       	icall
}
    3554:	ff 91       	pop	r31
    3556:	ef 91       	pop	r30
    3558:	bf 91       	pop	r27
    355a:	af 91       	pop	r26
    355c:	9f 91       	pop	r25
    355e:	8f 91       	pop	r24
    3560:	7f 91       	pop	r23
    3562:	6f 91       	pop	r22
    3564:	5f 91       	pop	r21
    3566:	4f 91       	pop	r20
    3568:	3f 91       	pop	r19
    356a:	2f 91       	pop	r18
    356c:	0f 90       	pop	r0
    356e:	0f be       	out	0x3f, r0	; 63
    3570:	0f 90       	pop	r0
    3572:	1f 90       	pop	r1
    3574:	18 95       	reti

00003576 <__vector_44>:
ISR(TIMER4_COMPC_vect)
{
    3576:	1f 92       	push	r1
    3578:	0f 92       	push	r0
    357a:	0f b6       	in	r0, 0x3f	; 63
    357c:	0f 92       	push	r0
    357e:	11 24       	eor	r1, r1
    3580:	2f 93       	push	r18
    3582:	3f 93       	push	r19
    3584:	4f 93       	push	r20
    3586:	5f 93       	push	r21
    3588:	6f 93       	push	r22
    358a:	7f 93       	push	r23
    358c:	8f 93       	push	r24
    358e:	9f 93       	push	r25
    3590:	af 93       	push	r26
    3592:	bf 93       	push	r27
    3594:	ef 93       	push	r30
    3596:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_COMPC_interrupt);
    3598:	80 91 10 0f 	lds	r24, 0x0F10
    359c:	90 91 11 0f 	lds	r25, 0x0F11
    35a0:	89 2b       	or	r24, r25
    35a2:	29 f0       	breq	.+10     	; 0x35ae <__vector_44+0x38>
    35a4:	e0 91 10 0f 	lds	r30, 0x0F10
    35a8:	f0 91 11 0f 	lds	r31, 0x0F11
    35ac:	09 95       	icall
}
    35ae:	ff 91       	pop	r31
    35b0:	ef 91       	pop	r30
    35b2:	bf 91       	pop	r27
    35b4:	af 91       	pop	r26
    35b6:	9f 91       	pop	r25
    35b8:	8f 91       	pop	r24
    35ba:	7f 91       	pop	r23
    35bc:	6f 91       	pop	r22
    35be:	5f 91       	pop	r21
    35c0:	4f 91       	pop	r20
    35c2:	3f 91       	pop	r19
    35c4:	2f 91       	pop	r18
    35c6:	0f 90       	pop	r0
    35c8:	0f be       	out	0x3f, r0	; 63
    35ca:	0f 90       	pop	r0
    35cc:	1f 90       	pop	r1
    35ce:	18 95       	reti

000035d0 <__vector_46>:
ISR(TIMER5_CAPT_vect)
{
    35d0:	1f 92       	push	r1
    35d2:	0f 92       	push	r0
    35d4:	0f b6       	in	r0, 0x3f	; 63
    35d6:	0f 92       	push	r0
    35d8:	11 24       	eor	r1, r1
    35da:	2f 93       	push	r18
    35dc:	3f 93       	push	r19
    35de:	4f 93       	push	r20
    35e0:	5f 93       	push	r21
    35e2:	6f 93       	push	r22
    35e4:	7f 93       	push	r23
    35e6:	8f 93       	push	r24
    35e8:	9f 93       	push	r25
    35ea:	af 93       	push	r26
    35ec:	bf 93       	push	r27
    35ee:	ef 93       	push	r30
    35f0:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_CAPT_interrupt);
    35f2:	80 91 14 0f 	lds	r24, 0x0F14
    35f6:	90 91 15 0f 	lds	r25, 0x0F15
    35fa:	89 2b       	or	r24, r25
    35fc:	29 f0       	breq	.+10     	; 0x3608 <__vector_46+0x38>
    35fe:	e0 91 14 0f 	lds	r30, 0x0F14
    3602:	f0 91 15 0f 	lds	r31, 0x0F15
    3606:	09 95       	icall
}
    3608:	ff 91       	pop	r31
    360a:	ef 91       	pop	r30
    360c:	bf 91       	pop	r27
    360e:	af 91       	pop	r26
    3610:	9f 91       	pop	r25
    3612:	8f 91       	pop	r24
    3614:	7f 91       	pop	r23
    3616:	6f 91       	pop	r22
    3618:	5f 91       	pop	r21
    361a:	4f 91       	pop	r20
    361c:	3f 91       	pop	r19
    361e:	2f 91       	pop	r18
    3620:	0f 90       	pop	r0
    3622:	0f be       	out	0x3f, r0	; 63
    3624:	0f 90       	pop	r0
    3626:	1f 90       	pop	r1
    3628:	18 95       	reti

0000362a <__vector_47>:
ISR(TIMER5_COMPA_vect)
{
    362a:	1f 92       	push	r1
    362c:	0f 92       	push	r0
    362e:	0f b6       	in	r0, 0x3f	; 63
    3630:	0f 92       	push	r0
    3632:	11 24       	eor	r1, r1
    3634:	2f 93       	push	r18
    3636:	3f 93       	push	r19
    3638:	4f 93       	push	r20
    363a:	5f 93       	push	r21
    363c:	6f 93       	push	r22
    363e:	7f 93       	push	r23
    3640:	8f 93       	push	r24
    3642:	9f 93       	push	r25
    3644:	af 93       	push	r26
    3646:	bf 93       	push	r27
    3648:	ef 93       	push	r30
    364a:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_COMPA_interrupt);
    364c:	80 91 16 0f 	lds	r24, 0x0F16
    3650:	90 91 17 0f 	lds	r25, 0x0F17
    3654:	89 2b       	or	r24, r25
    3656:	29 f0       	breq	.+10     	; 0x3662 <__vector_47+0x38>
    3658:	e0 91 16 0f 	lds	r30, 0x0F16
    365c:	f0 91 17 0f 	lds	r31, 0x0F17
    3660:	09 95       	icall
}
    3662:	ff 91       	pop	r31
    3664:	ef 91       	pop	r30
    3666:	bf 91       	pop	r27
    3668:	af 91       	pop	r26
    366a:	9f 91       	pop	r25
    366c:	8f 91       	pop	r24
    366e:	7f 91       	pop	r23
    3670:	6f 91       	pop	r22
    3672:	5f 91       	pop	r21
    3674:	4f 91       	pop	r20
    3676:	3f 91       	pop	r19
    3678:	2f 91       	pop	r18
    367a:	0f 90       	pop	r0
    367c:	0f be       	out	0x3f, r0	; 63
    367e:	0f 90       	pop	r0
    3680:	1f 90       	pop	r1
    3682:	18 95       	reti

00003684 <__vector_48>:
ISR(TIMER5_COMPB_vect)
{
    3684:	1f 92       	push	r1
    3686:	0f 92       	push	r0
    3688:	0f b6       	in	r0, 0x3f	; 63
    368a:	0f 92       	push	r0
    368c:	11 24       	eor	r1, r1
    368e:	2f 93       	push	r18
    3690:	3f 93       	push	r19
    3692:	4f 93       	push	r20
    3694:	5f 93       	push	r21
    3696:	6f 93       	push	r22
    3698:	7f 93       	push	r23
    369a:	8f 93       	push	r24
    369c:	9f 93       	push	r25
    369e:	af 93       	push	r26
    36a0:	bf 93       	push	r27
    36a2:	ef 93       	push	r30
    36a4:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_COMPB_interrupt);
    36a6:	80 91 18 0f 	lds	r24, 0x0F18
    36aa:	90 91 19 0f 	lds	r25, 0x0F19
    36ae:	89 2b       	or	r24, r25
    36b0:	29 f0       	breq	.+10     	; 0x36bc <__vector_48+0x38>
    36b2:	e0 91 18 0f 	lds	r30, 0x0F18
    36b6:	f0 91 19 0f 	lds	r31, 0x0F19
    36ba:	09 95       	icall
}
    36bc:	ff 91       	pop	r31
    36be:	ef 91       	pop	r30
    36c0:	bf 91       	pop	r27
    36c2:	af 91       	pop	r26
    36c4:	9f 91       	pop	r25
    36c6:	8f 91       	pop	r24
    36c8:	7f 91       	pop	r23
    36ca:	6f 91       	pop	r22
    36cc:	5f 91       	pop	r21
    36ce:	4f 91       	pop	r20
    36d0:	3f 91       	pop	r19
    36d2:	2f 91       	pop	r18
    36d4:	0f 90       	pop	r0
    36d6:	0f be       	out	0x3f, r0	; 63
    36d8:	0f 90       	pop	r0
    36da:	1f 90       	pop	r1
    36dc:	18 95       	reti

000036de <__vector_49>:
ISR(TIMER5_COMPC_vect)
{
    36de:	1f 92       	push	r1
    36e0:	0f 92       	push	r0
    36e2:	0f b6       	in	r0, 0x3f	; 63
    36e4:	0f 92       	push	r0
    36e6:	11 24       	eor	r1, r1
    36e8:	2f 93       	push	r18
    36ea:	3f 93       	push	r19
    36ec:	4f 93       	push	r20
    36ee:	5f 93       	push	r21
    36f0:	6f 93       	push	r22
    36f2:	7f 93       	push	r23
    36f4:	8f 93       	push	r24
    36f6:	9f 93       	push	r25
    36f8:	af 93       	push	r26
    36fa:	bf 93       	push	r27
    36fc:	ef 93       	push	r30
    36fe:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_COMPC_interrupt);
    3700:	80 91 1a 0f 	lds	r24, 0x0F1A
    3704:	90 91 1b 0f 	lds	r25, 0x0F1B
    3708:	89 2b       	or	r24, r25
    370a:	29 f0       	breq	.+10     	; 0x3716 <__vector_49+0x38>
    370c:	e0 91 1a 0f 	lds	r30, 0x0F1A
    3710:	f0 91 1b 0f 	lds	r31, 0x0F1B
    3714:	09 95       	icall
}
    3716:	ff 91       	pop	r31
    3718:	ef 91       	pop	r30
    371a:	bf 91       	pop	r27
    371c:	af 91       	pop	r26
    371e:	9f 91       	pop	r25
    3720:	8f 91       	pop	r24
    3722:	7f 91       	pop	r23
    3724:	6f 91       	pop	r22
    3726:	5f 91       	pop	r21
    3728:	4f 91       	pop	r20
    372a:	3f 91       	pop	r19
    372c:	2f 91       	pop	r18
    372e:	0f 90       	pop	r0
    3730:	0f be       	out	0x3f, r0	; 63
    3732:	0f 90       	pop	r0
    3734:	1f 90       	pop	r1
    3736:	18 95       	reti

00003738 <__vector_default>:

ISR(BADISR_vect)
{
    3738:	1f 92       	push	r1
    373a:	0f 92       	push	r0
    373c:	0f b6       	in	r0, 0x3f	; 63
    373e:	0f 92       	push	r0
    3740:	11 24       	eor	r1, r1
    3742:	2f 93       	push	r18
    3744:	3f 93       	push	r19
    3746:	4f 93       	push	r20
    3748:	5f 93       	push	r21
    374a:	6f 93       	push	r22
    374c:	7f 93       	push	r23
    374e:	8f 93       	push	r24
    3750:	9f 93       	push	r25
    3752:	af 93       	push	r26
    3754:	bf 93       	push	r27
    3756:	ef 93       	push	r30
    3758:	ff 93       	push	r31
  rprintf("BAD_vect called!");
    375a:	00 d0       	rcall	.+0      	; 0x375c <__vector_default+0x24>
    375c:	0f 92       	push	r0
    375e:	81 e0       	ldi	r24, 0x01	; 1
    3760:	ed b7       	in	r30, 0x3d	; 61
    3762:	fe b7       	in	r31, 0x3e	; 62
    3764:	81 83       	std	Z+1, r24	; 0x01
    3766:	8a ea       	ldi	r24, 0xAA	; 170
    3768:	91 e0       	ldi	r25, 0x01	; 1
    376a:	93 83       	std	Z+3, r25	; 0x03
    376c:	82 83       	std	Z+2, r24	; 0x02
    376e:	0e 94 66 23 	call	0x46cc	; 0x46cc <rprintf1RamRom>
    3772:	0f 90       	pop	r0
    3774:	0f 90       	pop	r0
    3776:	0f 90       	pop	r0
}
    3778:	ff 91       	pop	r31
    377a:	ef 91       	pop	r30
    377c:	bf 91       	pop	r27
    377e:	af 91       	pop	r26
    3780:	9f 91       	pop	r25
    3782:	8f 91       	pop	r24
    3784:	7f 91       	pop	r23
    3786:	6f 91       	pop	r22
    3788:	5f 91       	pop	r21
    378a:	4f 91       	pop	r20
    378c:	3f 91       	pop	r19
    378e:	2f 91       	pop	r18
    3790:	0f 90       	pop	r0
    3792:	0f be       	out	0x3f, r0	; 63
    3794:	0f 90       	pop	r0
    3796:	1f 90       	pop	r1
    3798:	18 95       	reti

0000379a <uartSetRxHandler>:
}

void uartSetRxHandler(u08 nUart, void (*rx_func)(unsigned char c))
{
	// make sure the uart number is within bounds
	if(nUart < 4)
    379a:	84 30       	cpi	r24, 0x04	; 4
    379c:	40 f4       	brcc	.+16     	; 0x37ae <uartSetRxHandler+0x14>
	{
		// set the receive interrupt to run the supplied user function
		UartRxFunc[nUart] = rx_func;
    379e:	e8 2f       	mov	r30, r24
    37a0:	f0 e0       	ldi	r31, 0x00	; 0
    37a2:	ee 0f       	add	r30, r30
    37a4:	ff 1f       	adc	r31, r31
    37a6:	e2 5a       	subi	r30, 0xA2	; 162
    37a8:	fe 4e       	sbci	r31, 0xEE	; 238
    37aa:	71 83       	std	Z+1, r23	; 0x01
    37ac:	60 83       	st	Z, r22
    37ae:	08 95       	ret

000037b0 <uartSetBaudRate>:
	}
}

void uartSetBaudRate(u08 nUart, u32 baudrate)
{
    37b0:	1f 93       	push	r17
    37b2:	18 2f       	mov	r17, r24
    37b4:	9a 01       	movw	r18, r20
    37b6:	ab 01       	movw	r20, r22
	// calculate division factor for requested baud rate, and set it
	u16 bauddiv = ((F_CPU+(baudrate*8L))/(baudrate*16L)-1);
    37b8:	ca 01       	movw	r24, r20
    37ba:	b9 01       	movw	r22, r18
    37bc:	60 58       	subi	r22, 0x80	; 128
    37be:	7b 47       	sbci	r23, 0x7B	; 123
    37c0:	81 4e       	sbci	r24, 0xE1	; 225
    37c2:	9f 4f       	sbci	r25, 0xFF	; 255
    37c4:	f3 e0       	ldi	r31, 0x03	; 3
    37c6:	66 0f       	add	r22, r22
    37c8:	77 1f       	adc	r23, r23
    37ca:	88 1f       	adc	r24, r24
    37cc:	99 1f       	adc	r25, r25
    37ce:	fa 95       	dec	r31
    37d0:	d1 f7       	brne	.-12     	; 0x37c6 <uartSetBaudRate+0x16>
    37d2:	e4 e0       	ldi	r30, 0x04	; 4
    37d4:	22 0f       	add	r18, r18
    37d6:	33 1f       	adc	r19, r19
    37d8:	44 1f       	adc	r20, r20
    37da:	55 1f       	adc	r21, r21
    37dc:	ea 95       	dec	r30
    37de:	d1 f7       	brne	.-12     	; 0x37d4 <uartSetBaudRate+0x24>
    37e0:	0e 94 dc 28 	call	0x51b8	; 0x51b8 <__udivmodsi4>
    37e4:	21 50       	subi	r18, 0x01	; 1
    37e6:	30 40       	sbci	r19, 0x00	; 0
	if(nUart==3)
    37e8:	13 30       	cpi	r17, 0x03	; 3
    37ea:	29 f4       	brne	.+10     	; 0x37f6 <uartSetBaudRate+0x46>
	{
		outb(UBRR3L, bauddiv);
    37ec:	20 93 34 01 	sts	0x0134, r18
		#ifdef UBRR3H
		outb(UBRR3H, bauddiv>>8);
    37f0:	30 93 35 01 	sts	0x0135, r19
    37f4:	12 c0       	rjmp	.+36     	; 0x381a <uartSetBaudRate+0x6a>
		#endif
	}
	else if(nUart==2)
    37f6:	12 30       	cpi	r17, 0x02	; 2
    37f8:	29 f4       	brne	.+10     	; 0x3804 <uartSetBaudRate+0x54>
	{
		outb(UBRR2L, bauddiv);
    37fa:	20 93 d4 00 	sts	0x00D4, r18
		#ifdef UBRR2H
		outb(UBRR2H, bauddiv>>8);
    37fe:	30 93 d5 00 	sts	0x00D5, r19
    3802:	0b c0       	rjmp	.+22     	; 0x381a <uartSetBaudRate+0x6a>
		#endif
	}
	else if(nUart==1)
    3804:	11 30       	cpi	r17, 0x01	; 1
    3806:	29 f4       	brne	.+10     	; 0x3812 <uartSetBaudRate+0x62>
	{
		outb(UBRR1L, bauddiv);
    3808:	20 93 cc 00 	sts	0x00CC, r18
		#ifdef UBRR1H
		outb(UBRR1H, bauddiv>>8);
    380c:	30 93 cd 00 	sts	0x00CD, r19
    3810:	04 c0       	rjmp	.+8      	; 0x381a <uartSetBaudRate+0x6a>
		#endif
	}
	else
	{
		outb(UBRR0L, bauddiv);
    3812:	20 93 c4 00 	sts	0x00C4, r18
		#ifdef UBRR0H
		outb(UBRR0H, bauddiv>>8);
    3816:	30 93 c5 00 	sts	0x00C5, r19
		#endif
	}
}
    381a:	1f 91       	pop	r17
    381c:	08 95       	ret

0000381e <uartGetRxBuffer>:

cBuffer* uartGetRxBuffer(u08 nUart)
{
    381e:	28 2f       	mov	r18, r24
    3820:	30 e0       	ldi	r19, 0x00	; 0
    3822:	a3 e0       	ldi	r26, 0x03	; 3
    3824:	22 0f       	add	r18, r18
    3826:	33 1f       	adc	r19, r19
    3828:	aa 95       	dec	r26
    382a:	e1 f7       	brne	.-8      	; 0x3824 <uartGetRxBuffer+0x6>
    382c:	22 52       	subi	r18, 0x22	; 34
    382e:	3d 4e       	sbci	r19, 0xED	; 237
	// return rx buffer pointer
	return &uartRxBuffer[nUart];
}
    3830:	c9 01       	movw	r24, r18
    3832:	08 95       	ret

00003834 <uartGetTxBuffer>:

cBuffer* uartGetTxBuffer(u08 nUart)
{
    3834:	28 2f       	mov	r18, r24
    3836:	30 e0       	ldi	r19, 0x00	; 0
    3838:	b3 e0       	ldi	r27, 0x03	; 3
    383a:	22 0f       	add	r18, r18
    383c:	33 1f       	adc	r19, r19
    383e:	ba 95       	dec	r27
    3840:	e1 f7       	brne	.-8      	; 0x383a <uartGetTxBuffer+0x6>
    3842:	2e 5f       	subi	r18, 0xFE	; 254
    3844:	3c 4e       	sbci	r19, 0xEC	; 236
	// return tx buffer pointer
	return &uartTxBuffer[nUart];
}
    3846:	c9 01       	movw	r24, r18
    3848:	08 95       	ret

0000384a <uartSendByte>:

void uartSendByte(u08 nUart, u08 txData)
{
    384a:	e8 2f       	mov	r30, r24
	// wait for the transmitter to be ready
//	while(!uartReadyTx[nUart]);
	// send byte
	if(nUart==3)
    384c:	83 30       	cpi	r24, 0x03	; 3
    384e:	39 f4       	brne	.+14     	; 0x385e <uartSendByte+0x14>
	{
		while(!(UCSR3A & (1<<UDRE3)));
    3850:	80 91 30 01 	lds	r24, 0x0130
    3854:	85 ff       	sbrs	r24, 5
    3856:	fc cf       	rjmp	.-8      	; 0x3850 <uartSendByte+0x6>
		outb(UDR3, txData);
    3858:	60 93 36 01 	sts	0x0136, r22
    385c:	18 c0       	rjmp	.+48     	; 0x388e <uartSendByte+0x44>
	}
	else if(nUart==2)
    385e:	82 30       	cpi	r24, 0x02	; 2
    3860:	39 f4       	brne	.+14     	; 0x3870 <uartSendByte+0x26>
	{
		while(!(UCSR2A & (1<<UDRE2)));
    3862:	80 91 d0 00 	lds	r24, 0x00D0
    3866:	85 ff       	sbrs	r24, 5
    3868:	fc cf       	rjmp	.-8      	; 0x3862 <uartSendByte+0x18>
		outb(UDR2, txData);
    386a:	60 93 d6 00 	sts	0x00D6, r22
    386e:	0f c0       	rjmp	.+30     	; 0x388e <uartSendByte+0x44>
	}
	else if(nUart==1)
    3870:	81 30       	cpi	r24, 0x01	; 1
    3872:	39 f4       	brne	.+14     	; 0x3882 <uartSendByte+0x38>
	{
		while(!(UCSR1A & (1<<UDRE1)));
    3874:	80 91 c8 00 	lds	r24, 0x00C8
    3878:	85 ff       	sbrs	r24, 5
    387a:	fc cf       	rjmp	.-8      	; 0x3874 <uartSendByte+0x2a>
		outb(UDR1, txData);
    387c:	60 93 ce 00 	sts	0x00CE, r22
    3880:	06 c0       	rjmp	.+12     	; 0x388e <uartSendByte+0x44>
	}
	else
	{
		while(!(UCSR0A & (1<<UDRE0)));
    3882:	80 91 c0 00 	lds	r24, 0x00C0
    3886:	85 ff       	sbrs	r24, 5
    3888:	fc cf       	rjmp	.-8      	; 0x3882 <uartSendByte+0x38>
		outb(UDR0, txData);
    388a:	60 93 c6 00 	sts	0x00C6, r22
	}
	// set ready state to FALSE
	uartReadyTx[nUart] = FALSE;
    388e:	f0 e0       	ldi	r31, 0x00	; 0
    3890:	e6 52       	subi	r30, 0x26	; 38
    3892:	fd 4e       	sbci	r31, 0xED	; 237
    3894:	10 82       	st	Z, r1
}
    3896:	08 95       	ret

00003898 <uart0SendByte>:

void uart0SendByte(u08 data)
{
    3898:	68 2f       	mov	r22, r24
	// send byte on UART0
	uartSendByte(0, data);
    389a:	80 e0       	ldi	r24, 0x00	; 0
    389c:	0e 94 25 1c 	call	0x384a	; 0x384a <uartSendByte>
}
    38a0:	08 95       	ret

000038a2 <uart1SendByte>:

void uart1SendByte(u08 data)
{
    38a2:	68 2f       	mov	r22, r24
	// send byte on UART1
	uartSendByte(1, data);
    38a4:	81 e0       	ldi	r24, 0x01	; 1
    38a6:	0e 94 25 1c 	call	0x384a	; 0x384a <uartSendByte>
}
    38aa:	08 95       	ret

000038ac <uart2SendByte>:

void uart2SendByte(u08 data)
{
    38ac:	68 2f       	mov	r22, r24
	// send byte on UART2
	uartSendByte(2, data);
    38ae:	82 e0       	ldi	r24, 0x02	; 2
    38b0:	0e 94 25 1c 	call	0x384a	; 0x384a <uartSendByte>
}
    38b4:	08 95       	ret

000038b6 <uart3SendByte>:

void uart3SendByte(u08 data)
{
    38b6:	68 2f       	mov	r22, r24
	// send byte on UART3
	uartSendByte(3, data);
    38b8:	83 e0       	ldi	r24, 0x03	; 3
    38ba:	0e 94 25 1c 	call	0x384a	; 0x384a <uartSendByte>
}
    38be:	08 95       	ret

000038c0 <uartReceiveBufferIsEmpty>:
	// flush all data from receive buffer
	bufferFlush(&uartRxBuffer[nUart]);
}

u08 uartReceiveBufferIsEmpty(u08 nUart)
{
    38c0:	20 e0       	ldi	r18, 0x00	; 0
    38c2:	e8 2f       	mov	r30, r24
    38c4:	f0 e0       	ldi	r31, 0x00	; 0
    38c6:	83 e0       	ldi	r24, 0x03	; 3
    38c8:	ee 0f       	add	r30, r30
    38ca:	ff 1f       	adc	r31, r31
    38cc:	8a 95       	dec	r24
    38ce:	e1 f7       	brne	.-8      	; 0x38c8 <uartReceiveBufferIsEmpty+0x8>
    38d0:	ee 51       	subi	r30, 0x1E	; 30
    38d2:	fd 4e       	sbci	r31, 0xED	; 237
    38d4:	80 81       	ld	r24, Z
    38d6:	91 81       	ldd	r25, Z+1	; 0x01
    38d8:	89 2b       	or	r24, r25
    38da:	09 f4       	brne	.+2      	; 0x38de <uartReceiveBufferIsEmpty+0x1e>
    38dc:	21 e0       	ldi	r18, 0x01	; 1
	return (uartRxBuffer[nUart].datalength == 0);
}
    38de:	82 2f       	mov	r24, r18
    38e0:	08 95       	ret

000038e2 <uartReceiveService>:
	}
}

// UART Receive Complete Interrupt Function
void uartReceiveService(u08 nUart)
{
    38e2:	cf 93       	push	r28
    38e4:	df 93       	push	r29
	u08 c;
	// get received char
	if(nUart==3)
    38e6:	83 30       	cpi	r24, 0x03	; 3
    38e8:	19 f4       	brne	.+6      	; 0x38f0 <uartReceiveService+0xe>
		c = inb(UDR3);
    38ea:	60 91 36 01 	lds	r22, 0x0136
    38ee:	0c c0       	rjmp	.+24     	; 0x3908 <uartReceiveService+0x26>
	else if(nUart==2)
    38f0:	82 30       	cpi	r24, 0x02	; 2
    38f2:	19 f4       	brne	.+6      	; 0x38fa <uartReceiveService+0x18>
		c = inb(UDR2);
    38f4:	60 91 d6 00 	lds	r22, 0x00D6
    38f8:	07 c0       	rjmp	.+14     	; 0x3908 <uartReceiveService+0x26>
	else if(nUart==1)
    38fa:	81 30       	cpi	r24, 0x01	; 1
    38fc:	19 f4       	brne	.+6      	; 0x3904 <uartReceiveService+0x22>
		c = inb(UDR1);
    38fe:	60 91 ce 00 	lds	r22, 0x00CE
    3902:	02 c0       	rjmp	.+4      	; 0x3908 <uartReceiveService+0x26>
	else
		c = inb(UDR0);
    3904:	60 91 c6 00 	lds	r22, 0x00C6

	// if there's a user function to handle this receive event
	if(UartRxFunc[nUart])
    3908:	28 2f       	mov	r18, r24
    390a:	30 e0       	ldi	r19, 0x00	; 0
    390c:	e9 01       	movw	r28, r18
    390e:	cc 0f       	add	r28, r28
    3910:	dd 1f       	adc	r29, r29
    3912:	fe 01       	movw	r30, r28
    3914:	e2 5a       	subi	r30, 0xA2	; 162
    3916:	fe 4e       	sbci	r31, 0xEE	; 238
    3918:	80 81       	ld	r24, Z
    391a:	91 81       	ldd	r25, Z+1	; 0x01
    391c:	89 2b       	or	r24, r25
    391e:	31 f0       	breq	.+12     	; 0x392c <uartReceiveService+0x4a>
	{
		// call it and pass the received data
		UartRxFunc[nUart](c);
    3920:	01 90       	ld	r0, Z+
    3922:	f0 81       	ld	r31, Z
    3924:	e0 2d       	mov	r30, r0
    3926:	86 2f       	mov	r24, r22
    3928:	09 95       	icall
    392a:	14 c0       	rjmp	.+40     	; 0x3954 <uartReceiveService+0x72>
	else
	{
		// otherwise do default processing
		// put received char in buffer
		// check if there's space
		if( !bufferAddToEnd(&uartRxBuffer[nUart], c) )
    392c:	93 e0       	ldi	r25, 0x03	; 3
    392e:	22 0f       	add	r18, r18
    3930:	33 1f       	adc	r19, r19
    3932:	9a 95       	dec	r25
    3934:	e1 f7       	brne	.-8      	; 0x392e <uartReceiveService+0x4c>
    3936:	c9 01       	movw	r24, r18
    3938:	82 52       	subi	r24, 0x22	; 34
    393a:	9d 4e       	sbci	r25, 0xED	; 237
    393c:	0e 94 7d 20 	call	0x40fa	; 0x40fa <bufferAddToEnd>
    3940:	88 23       	and	r24, r24
    3942:	41 f4       	brne	.+16     	; 0x3954 <uartReceiveService+0x72>
		{
			// no space in buffer
			// count overflow
			uartRxOverflow[nUart]++;
    3944:	fe 01       	movw	r30, r28
    3946:	ee 5d       	subi	r30, 0xDE	; 222
    3948:	fc 4e       	sbci	r31, 0xEC	; 236
    394a:	80 81       	ld	r24, Z
    394c:	91 81       	ldd	r25, Z+1	; 0x01
    394e:	01 96       	adiw	r24, 0x01	; 1
    3950:	91 83       	std	Z+1, r25	; 0x01
    3952:	80 83       	st	Z, r24
		}
	}
}
    3954:	df 91       	pop	r29
    3956:	cf 91       	pop	r28
    3958:	08 95       	ret

0000395a <__vector_54>:
{
	uartReceiveService(2);
}

UART_INTERRUPT_HANDLER(SIG_USART3_RECV)      
{
    395a:	1f 92       	push	r1
    395c:	0f 92       	push	r0
    395e:	0f b6       	in	r0, 0x3f	; 63
    3960:	0f 92       	push	r0
    3962:	11 24       	eor	r1, r1
    3964:	2f 93       	push	r18
    3966:	3f 93       	push	r19
    3968:	4f 93       	push	r20
    396a:	5f 93       	push	r21
    396c:	6f 93       	push	r22
    396e:	7f 93       	push	r23
    3970:	8f 93       	push	r24
    3972:	9f 93       	push	r25
    3974:	af 93       	push	r26
    3976:	bf 93       	push	r27
    3978:	ef 93       	push	r30
    397a:	ff 93       	push	r31
	uartReceiveService(3);
    397c:	83 e0       	ldi	r24, 0x03	; 3
    397e:	0e 94 71 1c 	call	0x38e2	; 0x38e2 <uartReceiveService>
}
    3982:	ff 91       	pop	r31
    3984:	ef 91       	pop	r30
    3986:	bf 91       	pop	r27
    3988:	af 91       	pop	r26
    398a:	9f 91       	pop	r25
    398c:	8f 91       	pop	r24
    398e:	7f 91       	pop	r23
    3990:	6f 91       	pop	r22
    3992:	5f 91       	pop	r21
    3994:	4f 91       	pop	r20
    3996:	3f 91       	pop	r19
    3998:	2f 91       	pop	r18
    399a:	0f 90       	pop	r0
    399c:	0f be       	out	0x3f, r0	; 63
    399e:	0f 90       	pop	r0
    39a0:	1f 90       	pop	r1
    39a2:	18 95       	reti

000039a4 <__vector_51>:
{
	uartReceiveService(1);
}

UART_INTERRUPT_HANDLER(SIG_USART2_RECV)      
{
    39a4:	1f 92       	push	r1
    39a6:	0f 92       	push	r0
    39a8:	0f b6       	in	r0, 0x3f	; 63
    39aa:	0f 92       	push	r0
    39ac:	11 24       	eor	r1, r1
    39ae:	2f 93       	push	r18
    39b0:	3f 93       	push	r19
    39b2:	4f 93       	push	r20
    39b4:	5f 93       	push	r21
    39b6:	6f 93       	push	r22
    39b8:	7f 93       	push	r23
    39ba:	8f 93       	push	r24
    39bc:	9f 93       	push	r25
    39be:	af 93       	push	r26
    39c0:	bf 93       	push	r27
    39c2:	ef 93       	push	r30
    39c4:	ff 93       	push	r31
	uartReceiveService(2);
    39c6:	82 e0       	ldi	r24, 0x02	; 2
    39c8:	0e 94 71 1c 	call	0x38e2	; 0x38e2 <uartReceiveService>
}
    39cc:	ff 91       	pop	r31
    39ce:	ef 91       	pop	r30
    39d0:	bf 91       	pop	r27
    39d2:	af 91       	pop	r26
    39d4:	9f 91       	pop	r25
    39d6:	8f 91       	pop	r24
    39d8:	7f 91       	pop	r23
    39da:	6f 91       	pop	r22
    39dc:	5f 91       	pop	r21
    39de:	4f 91       	pop	r20
    39e0:	3f 91       	pop	r19
    39e2:	2f 91       	pop	r18
    39e4:	0f 90       	pop	r0
    39e6:	0f be       	out	0x3f, r0	; 63
    39e8:	0f 90       	pop	r0
    39ea:	1f 90       	pop	r1
    39ec:	18 95       	reti

000039ee <__vector_36>:
{
	uartReceiveService(0);
}

UART_INTERRUPT_HANDLER(SIG_USART1_RECV)      
{
    39ee:	1f 92       	push	r1
    39f0:	0f 92       	push	r0
    39f2:	0f b6       	in	r0, 0x3f	; 63
    39f4:	0f 92       	push	r0
    39f6:	11 24       	eor	r1, r1
    39f8:	2f 93       	push	r18
    39fa:	3f 93       	push	r19
    39fc:	4f 93       	push	r20
    39fe:	5f 93       	push	r21
    3a00:	6f 93       	push	r22
    3a02:	7f 93       	push	r23
    3a04:	8f 93       	push	r24
    3a06:	9f 93       	push	r25
    3a08:	af 93       	push	r26
    3a0a:	bf 93       	push	r27
    3a0c:	ef 93       	push	r30
    3a0e:	ff 93       	push	r31
	uartReceiveService(1);
    3a10:	81 e0       	ldi	r24, 0x01	; 1
    3a12:	0e 94 71 1c 	call	0x38e2	; 0x38e2 <uartReceiveService>
}
    3a16:	ff 91       	pop	r31
    3a18:	ef 91       	pop	r30
    3a1a:	bf 91       	pop	r27
    3a1c:	af 91       	pop	r26
    3a1e:	9f 91       	pop	r25
    3a20:	8f 91       	pop	r24
    3a22:	7f 91       	pop	r23
    3a24:	6f 91       	pop	r22
    3a26:	5f 91       	pop	r21
    3a28:	4f 91       	pop	r20
    3a2a:	3f 91       	pop	r19
    3a2c:	2f 91       	pop	r18
    3a2e:	0f 90       	pop	r0
    3a30:	0f be       	out	0x3f, r0	; 63
    3a32:	0f 90       	pop	r0
    3a34:	1f 90       	pop	r1
    3a36:	18 95       	reti

00003a38 <__vector_25>:
	uartTransmitService(3);
}

	// service UART receive interrupt
UART_INTERRUPT_HANDLER(SIG_USART0_RECV)      
{
    3a38:	1f 92       	push	r1
    3a3a:	0f 92       	push	r0
    3a3c:	0f b6       	in	r0, 0x3f	; 63
    3a3e:	0f 92       	push	r0
    3a40:	11 24       	eor	r1, r1
    3a42:	2f 93       	push	r18
    3a44:	3f 93       	push	r19
    3a46:	4f 93       	push	r20
    3a48:	5f 93       	push	r21
    3a4a:	6f 93       	push	r22
    3a4c:	7f 93       	push	r23
    3a4e:	8f 93       	push	r24
    3a50:	9f 93       	push	r25
    3a52:	af 93       	push	r26
    3a54:	bf 93       	push	r27
    3a56:	ef 93       	push	r30
    3a58:	ff 93       	push	r31
	uartReceiveService(0);
    3a5a:	80 e0       	ldi	r24, 0x00	; 0
    3a5c:	0e 94 71 1c 	call	0x38e2	; 0x38e2 <uartReceiveService>
}
    3a60:	ff 91       	pop	r31
    3a62:	ef 91       	pop	r30
    3a64:	bf 91       	pop	r27
    3a66:	af 91       	pop	r26
    3a68:	9f 91       	pop	r25
    3a6a:	8f 91       	pop	r24
    3a6c:	7f 91       	pop	r23
    3a6e:	6f 91       	pop	r22
    3a70:	5f 91       	pop	r21
    3a72:	4f 91       	pop	r20
    3a74:	3f 91       	pop	r19
    3a76:	2f 91       	pop	r18
    3a78:	0f 90       	pop	r0
    3a7a:	0f be       	out	0x3f, r0	; 63
    3a7c:	0f 90       	pop	r0
    3a7e:	1f 90       	pop	r1
    3a80:	18 95       	reti

00003a82 <uartSendBuffer>:
	// send the first byte to get things going by interrupts
	uartSendByte(nUart, bufferGetFromFront(&uartTxBuffer[nUart]));
}

u08 uartSendBuffer(u08 nUart, char *buffer, u16 nBytes)
{
    3a82:	8f 92       	push	r8
    3a84:	9f 92       	push	r9
    3a86:	af 92       	push	r10
    3a88:	bf 92       	push	r11
    3a8a:	cf 92       	push	r12
    3a8c:	df 92       	push	r13
    3a8e:	ef 92       	push	r14
    3a90:	ff 92       	push	r15
    3a92:	0f 93       	push	r16
    3a94:	1f 93       	push	r17
    3a96:	cf 93       	push	r28
    3a98:	df 93       	push	r29
    3a9a:	88 2e       	mov	r8, r24
    3a9c:	db 01       	movw	r26, r22
	register u08 first;
	register u16 i;

	// check if there's space (and that we have any bytes to send at all)
	if((uartTxBuffer[nUart].datalength + nBytes < uartTxBuffer[nUart].size) && nBytes)
    3a9e:	c8 2e       	mov	r12, r24
    3aa0:	dd 24       	eor	r13, r13
    3aa2:	f6 01       	movw	r30, r12
    3aa4:	13 e0       	ldi	r17, 0x03	; 3
    3aa6:	ee 0f       	add	r30, r30
    3aa8:	ff 1f       	adc	r31, r31
    3aaa:	1a 95       	dec	r17
    3aac:	e1 f7       	brne	.-8      	; 0x3aa6 <uartSendBuffer+0x24>
    3aae:	ea 5f       	subi	r30, 0xFA	; 250
    3ab0:	fc 4e       	sbci	r31, 0xEC	; 236
    3ab2:	20 81       	ld	r18, Z
    3ab4:	31 81       	ldd	r19, Z+1	; 0x01
    3ab6:	24 0f       	add	r18, r20
    3ab8:	35 1f       	adc	r19, r21
    3aba:	f6 01       	movw	r30, r12
    3abc:	73 e0       	ldi	r23, 0x03	; 3
    3abe:	ee 0f       	add	r30, r30
    3ac0:	ff 1f       	adc	r31, r31
    3ac2:	7a 95       	dec	r23
    3ac4:	e1 f7       	brne	.-8      	; 0x3abe <uartSendBuffer+0x3c>
    3ac6:	ec 5f       	subi	r30, 0xFC	; 252
    3ac8:	fc 4e       	sbci	r31, 0xEC	; 236
    3aca:	80 81       	ld	r24, Z
    3acc:	91 81       	ldd	r25, Z+1	; 0x01
    3ace:	28 17       	cp	r18, r24
    3ad0:	39 07       	cpc	r19, r25
    3ad2:	70 f5       	brcc	.+92     	; 0x3b30 <uartSendBuffer+0xae>
    3ad4:	41 15       	cp	r20, r1
    3ad6:	51 05       	cpc	r21, r1
    3ad8:	59 f1       	breq	.+86     	; 0x3b30 <uartSendBuffer+0xae>
	{
		// grab first character
		first = *buffer++;
    3ada:	9c 90       	ld	r9, X
		// copy user buffer to uart transmit buffer
		for(i = 0; i < nBytes-1; i++)
		{
			// put data bytes at end of buffer
			bufferAddToEnd(&uartTxBuffer[nUart], *buffer++);
    3adc:	76 01       	movw	r14, r12
    3ade:	63 e0       	ldi	r22, 0x03	; 3
    3ae0:	ee 0c       	add	r14, r14
    3ae2:	ff 1c       	adc	r15, r15
    3ae4:	6a 95       	dec	r22
    3ae6:	e1 f7       	brne	.-8      	; 0x3ae0 <uartSendBuffer+0x5e>
    3ae8:	82 e0       	ldi	r24, 0x02	; 2
    3aea:	93 e1       	ldi	r25, 0x13	; 19
    3aec:	e8 0e       	add	r14, r24
    3aee:	f9 1e       	adc	r15, r25
    3af0:	8d 01       	movw	r16, r26
    3af2:	c0 e0       	ldi	r28, 0x00	; 0
    3af4:	d0 e0       	ldi	r29, 0x00	; 0
	if((uartTxBuffer[nUart].datalength + nBytes < uartTxBuffer[nUart].size) && nBytes)
	{
		// grab first character
		first = *buffer++;
		// copy user buffer to uart transmit buffer
		for(i = 0; i < nBytes-1; i++)
    3af6:	5a 01       	movw	r10, r20
    3af8:	08 94       	sec
    3afa:	a1 08       	sbc	r10, r1
    3afc:	b1 08       	sbc	r11, r1
    3afe:	06 c0       	rjmp	.+12     	; 0x3b0c <uartSendBuffer+0x8a>
    3b00:	c7 01       	movw	r24, r14
    3b02:	f8 01       	movw	r30, r16
    3b04:	60 81       	ld	r22, Z
    3b06:	0e 94 7d 20 	call	0x40fa	; 0x40fa <bufferAddToEnd>
    3b0a:	21 96       	adiw	r28, 0x01	; 1
    3b0c:	0f 5f       	subi	r16, 0xFF	; 255
    3b0e:	1f 4f       	sbci	r17, 0xFF	; 255
    3b10:	ca 15       	cp	r28, r10
    3b12:	db 05       	cpc	r29, r11
    3b14:	a8 f3       	brcs	.-22     	; 0x3b00 <uartSendBuffer+0x7e>
			// put data bytes at end of buffer
			bufferAddToEnd(&uartTxBuffer[nUart], *buffer++);
		}

		// send the first byte to get things going by interrupts
		uartBufferedTx[nUart] = TRUE;
    3b16:	8e ef       	ldi	r24, 0xFE	; 254
    3b18:	92 e1       	ldi	r25, 0x12	; 18
    3b1a:	c8 0e       	add	r12, r24
    3b1c:	d9 1e       	adc	r13, r25
    3b1e:	8f ef       	ldi	r24, 0xFF	; 255
    3b20:	f6 01       	movw	r30, r12
    3b22:	80 83       	st	Z, r24
		uartSendByte(nUart, first);
    3b24:	88 2d       	mov	r24, r8
    3b26:	69 2d       	mov	r22, r9
    3b28:	0e 94 25 1c 	call	0x384a	; 0x384a <uartSendByte>
    3b2c:	8f ef       	ldi	r24, 0xFF	; 255
    3b2e:	01 c0       	rjmp	.+2      	; 0x3b32 <uartSendBuffer+0xb0>
		// return success
		return TRUE;
    3b30:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		// return failure
		return FALSE;
	}
}
    3b32:	df 91       	pop	r29
    3b34:	cf 91       	pop	r28
    3b36:	1f 91       	pop	r17
    3b38:	0f 91       	pop	r16
    3b3a:	ff 90       	pop	r15
    3b3c:	ef 90       	pop	r14
    3b3e:	df 90       	pop	r13
    3b40:	cf 90       	pop	r12
    3b42:	bf 90       	pop	r11
    3b44:	af 90       	pop	r10
    3b46:	9f 90       	pop	r9
    3b48:	8f 90       	pop	r8
    3b4a:	08 95       	ret

00003b4c <uartAddToTxBuffer>:
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    3b4c:	90 e0       	ldi	r25, 0x00	; 0
    3b4e:	23 e0       	ldi	r18, 0x03	; 3
    3b50:	88 0f       	add	r24, r24
    3b52:	99 1f       	adc	r25, r25
    3b54:	2a 95       	dec	r18
    3b56:	e1 f7       	brne	.-8      	; 0x3b50 <uartAddToTxBuffer+0x4>
    3b58:	8e 5f       	subi	r24, 0xFE	; 254
    3b5a:	9c 4e       	sbci	r25, 0xEC	; 236
    3b5c:	0e 94 7d 20 	call	0x40fa	; 0x40fa <bufferAddToEnd>
}
    3b60:	08 95       	ret

00003b62 <uart3AddToTxBuffer>:
{
	uartAddToTxBuffer(2,data);
}

void uart3AddToTxBuffer(u08 data)
{
    3b62:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    3b64:	8a e1       	ldi	r24, 0x1A	; 26
    3b66:	93 e1       	ldi	r25, 0x13	; 19
    3b68:	0e 94 7d 20 	call	0x40fa	; 0x40fa <bufferAddToEnd>
}

void uart3AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(3,data);
}
    3b6c:	08 95       	ret

00003b6e <uart2AddToTxBuffer>:
{
	uartAddToTxBuffer(1,data);
}

void uart2AddToTxBuffer(u08 data)
{
    3b6e:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    3b70:	82 e1       	ldi	r24, 0x12	; 18
    3b72:	93 e1       	ldi	r25, 0x13	; 19
    3b74:	0e 94 7d 20 	call	0x40fa	; 0x40fa <bufferAddToEnd>
}

void uart2AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(2,data);
}
    3b78:	08 95       	ret

00003b7a <uart1AddToTxBuffer>:
{
	uartAddToTxBuffer(0,data);
}

void uart1AddToTxBuffer(u08 data)
{
    3b7a:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    3b7c:	8a e0       	ldi	r24, 0x0A	; 10
    3b7e:	93 e1       	ldi	r25, 0x13	; 19
    3b80:	0e 94 7d 20 	call	0x40fa	; 0x40fa <bufferAddToEnd>
}

void uart1AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(1,data);
}
    3b84:	08 95       	ret

00003b86 <uart0AddToTxBuffer>:
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
}

void uart0AddToTxBuffer(u08 data)
{
    3b86:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    3b88:	82 e0       	ldi	r24, 0x02	; 2
    3b8a:	93 e1       	ldi	r25, 0x13	; 19
    3b8c:	0e 94 7d 20 	call	0x40fa	; 0x40fa <bufferAddToEnd>
}

void uart0AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(0,data);
}
    3b90:	08 95       	ret

00003b92 <uartTransmitService>:
	}
}

// UART Transmit Complete Interrupt Function
void uartTransmitService(u08 nUart)
{
    3b92:	cf 93       	push	r28
    3b94:	df 93       	push	r29
    3b96:	28 2f       	mov	r18, r24
	// check if buffered tx is enabled
	if(uartBufferedTx[nUart])
    3b98:	a8 2f       	mov	r26, r24
    3b9a:	b0 e0       	ldi	r27, 0x00	; 0
    3b9c:	ed 01       	movw	r28, r26
    3b9e:	c2 50       	subi	r28, 0x02	; 2
    3ba0:	dd 4e       	sbci	r29, 0xED	; 237
    3ba2:	88 81       	ld	r24, Y
    3ba4:	88 23       	and	r24, r24
    3ba6:	79 f1       	breq	.+94     	; 0x3c06 <uartTransmitService+0x74>
	{
		// check if there's data left in the buffer
		if(uartTxBuffer[nUart].datalength)
    3ba8:	fd 01       	movw	r30, r26
    3baa:	33 e0       	ldi	r19, 0x03	; 3
    3bac:	ee 0f       	add	r30, r30
    3bae:	ff 1f       	adc	r31, r31
    3bb0:	3a 95       	dec	r19
    3bb2:	e1 f7       	brne	.-8      	; 0x3bac <uartTransmitService+0x1a>
    3bb4:	ea 5f       	subi	r30, 0xFA	; 250
    3bb6:	fc 4e       	sbci	r31, 0xEC	; 236
    3bb8:	80 81       	ld	r24, Z
    3bba:	91 81       	ldd	r25, Z+1	; 0x01
    3bbc:	89 2b       	or	r24, r25
    3bbe:	11 f1       	breq	.+68     	; 0x3c04 <uartTransmitService+0x72>
		{
			// send byte from top of buffer
			if(nUart==3)
    3bc0:	23 30       	cpi	r18, 0x03	; 3
    3bc2:	39 f4       	brne	.+14     	; 0x3bd2 <uartTransmitService+0x40>
				outb(UDR3,  bufferGetFromFront(&uartTxBuffer[3]) );
    3bc4:	8a e1       	ldi	r24, 0x1A	; 26
    3bc6:	93 e1       	ldi	r25, 0x13	; 19
    3bc8:	0e 94 14 20 	call	0x4028	; 0x4028 <bufferGetFromFront>
    3bcc:	80 93 36 01 	sts	0x0136, r24
    3bd0:	1e c0       	rjmp	.+60     	; 0x3c0e <uartTransmitService+0x7c>
			else if(nUart==2)
    3bd2:	22 30       	cpi	r18, 0x02	; 2
    3bd4:	39 f4       	brne	.+14     	; 0x3be4 <uartTransmitService+0x52>
				outb(UDR2,  bufferGetFromFront(&uartTxBuffer[2]) );
    3bd6:	82 e1       	ldi	r24, 0x12	; 18
    3bd8:	93 e1       	ldi	r25, 0x13	; 19
    3bda:	0e 94 14 20 	call	0x4028	; 0x4028 <bufferGetFromFront>
    3bde:	80 93 d6 00 	sts	0x00D6, r24
    3be2:	15 c0       	rjmp	.+42     	; 0x3c0e <uartTransmitService+0x7c>
			else if(nUart==1)
    3be4:	21 30       	cpi	r18, 0x01	; 1
    3be6:	39 f4       	brne	.+14     	; 0x3bf6 <uartTransmitService+0x64>
				outb(UDR1,  bufferGetFromFront(&uartTxBuffer[1]) );
    3be8:	8a e0       	ldi	r24, 0x0A	; 10
    3bea:	93 e1       	ldi	r25, 0x13	; 19
    3bec:	0e 94 14 20 	call	0x4028	; 0x4028 <bufferGetFromFront>
    3bf0:	80 93 ce 00 	sts	0x00CE, r24
    3bf4:	0c c0       	rjmp	.+24     	; 0x3c0e <uartTransmitService+0x7c>
			else
				outb(UDR0,  bufferGetFromFront(&uartTxBuffer[0]) );
    3bf6:	82 e0       	ldi	r24, 0x02	; 2
    3bf8:	93 e1       	ldi	r25, 0x13	; 19
    3bfa:	0e 94 14 20 	call	0x4028	; 0x4028 <bufferGetFromFront>
    3bfe:	80 93 c6 00 	sts	0x00C6, r24
    3c02:	05 c0       	rjmp	.+10     	; 0x3c0e <uartTransmitService+0x7c>
		}
		else
		{
			// no data left
			uartBufferedTx[nUart] = FALSE;
    3c04:	18 82       	st	Y, r1
	}
	else
	{
		// we're using single-byte tx mode
		// indicate transmit complete, back to ready
		uartReadyTx[nUart] = TRUE;
    3c06:	a6 52       	subi	r26, 0x26	; 38
    3c08:	bd 4e       	sbci	r27, 0xED	; 237
    3c0a:	8f ef       	ldi	r24, 0xFF	; 255
    3c0c:	8c 93       	st	X, r24
	}
}
    3c0e:	df 91       	pop	r29
    3c10:	cf 91       	pop	r28
    3c12:	08 95       	ret

00003c14 <__vector_56>:
{
	uartTransmitService(2);
}

UART_INTERRUPT_HANDLER(SIG_USART3_TRANS)      
{
    3c14:	1f 92       	push	r1
    3c16:	0f 92       	push	r0
    3c18:	0f b6       	in	r0, 0x3f	; 63
    3c1a:	0f 92       	push	r0
    3c1c:	11 24       	eor	r1, r1
    3c1e:	2f 93       	push	r18
    3c20:	3f 93       	push	r19
    3c22:	4f 93       	push	r20
    3c24:	5f 93       	push	r21
    3c26:	6f 93       	push	r22
    3c28:	7f 93       	push	r23
    3c2a:	8f 93       	push	r24
    3c2c:	9f 93       	push	r25
    3c2e:	af 93       	push	r26
    3c30:	bf 93       	push	r27
    3c32:	ef 93       	push	r30
    3c34:	ff 93       	push	r31
	uartTransmitService(3);
    3c36:	83 e0       	ldi	r24, 0x03	; 3
    3c38:	0e 94 c9 1d 	call	0x3b92	; 0x3b92 <uartTransmitService>
}
    3c3c:	ff 91       	pop	r31
    3c3e:	ef 91       	pop	r30
    3c40:	bf 91       	pop	r27
    3c42:	af 91       	pop	r26
    3c44:	9f 91       	pop	r25
    3c46:	8f 91       	pop	r24
    3c48:	7f 91       	pop	r23
    3c4a:	6f 91       	pop	r22
    3c4c:	5f 91       	pop	r21
    3c4e:	4f 91       	pop	r20
    3c50:	3f 91       	pop	r19
    3c52:	2f 91       	pop	r18
    3c54:	0f 90       	pop	r0
    3c56:	0f be       	out	0x3f, r0	; 63
    3c58:	0f 90       	pop	r0
    3c5a:	1f 90       	pop	r1
    3c5c:	18 95       	reti

00003c5e <__vector_53>:
{
	uartTransmitService(1);
}

UART_INTERRUPT_HANDLER(SIG_USART2_TRANS)      
{
    3c5e:	1f 92       	push	r1
    3c60:	0f 92       	push	r0
    3c62:	0f b6       	in	r0, 0x3f	; 63
    3c64:	0f 92       	push	r0
    3c66:	11 24       	eor	r1, r1
    3c68:	2f 93       	push	r18
    3c6a:	3f 93       	push	r19
    3c6c:	4f 93       	push	r20
    3c6e:	5f 93       	push	r21
    3c70:	6f 93       	push	r22
    3c72:	7f 93       	push	r23
    3c74:	8f 93       	push	r24
    3c76:	9f 93       	push	r25
    3c78:	af 93       	push	r26
    3c7a:	bf 93       	push	r27
    3c7c:	ef 93       	push	r30
    3c7e:	ff 93       	push	r31
	uartTransmitService(2);
    3c80:	82 e0       	ldi	r24, 0x02	; 2
    3c82:	0e 94 c9 1d 	call	0x3b92	; 0x3b92 <uartTransmitService>
}
    3c86:	ff 91       	pop	r31
    3c88:	ef 91       	pop	r30
    3c8a:	bf 91       	pop	r27
    3c8c:	af 91       	pop	r26
    3c8e:	9f 91       	pop	r25
    3c90:	8f 91       	pop	r24
    3c92:	7f 91       	pop	r23
    3c94:	6f 91       	pop	r22
    3c96:	5f 91       	pop	r21
    3c98:	4f 91       	pop	r20
    3c9a:	3f 91       	pop	r19
    3c9c:	2f 91       	pop	r18
    3c9e:	0f 90       	pop	r0
    3ca0:	0f be       	out	0x3f, r0	; 63
    3ca2:	0f 90       	pop	r0
    3ca4:	1f 90       	pop	r1
    3ca6:	18 95       	reti

00003ca8 <__vector_38>:
{
	uartTransmitService(0);
}

UART_INTERRUPT_HANDLER(SIG_USART1_TRANS)      
{
    3ca8:	1f 92       	push	r1
    3caa:	0f 92       	push	r0
    3cac:	0f b6       	in	r0, 0x3f	; 63
    3cae:	0f 92       	push	r0
    3cb0:	11 24       	eor	r1, r1
    3cb2:	2f 93       	push	r18
    3cb4:	3f 93       	push	r19
    3cb6:	4f 93       	push	r20
    3cb8:	5f 93       	push	r21
    3cba:	6f 93       	push	r22
    3cbc:	7f 93       	push	r23
    3cbe:	8f 93       	push	r24
    3cc0:	9f 93       	push	r25
    3cc2:	af 93       	push	r26
    3cc4:	bf 93       	push	r27
    3cc6:	ef 93       	push	r30
    3cc8:	ff 93       	push	r31
	uartTransmitService(1);
    3cca:	81 e0       	ldi	r24, 0x01	; 1
    3ccc:	0e 94 c9 1d 	call	0x3b92	; 0x3b92 <uartTransmitService>
}
    3cd0:	ff 91       	pop	r31
    3cd2:	ef 91       	pop	r30
    3cd4:	bf 91       	pop	r27
    3cd6:	af 91       	pop	r26
    3cd8:	9f 91       	pop	r25
    3cda:	8f 91       	pop	r24
    3cdc:	7f 91       	pop	r23
    3cde:	6f 91       	pop	r22
    3ce0:	5f 91       	pop	r21
    3ce2:	4f 91       	pop	r20
    3ce4:	3f 91       	pop	r19
    3ce6:	2f 91       	pop	r18
    3ce8:	0f 90       	pop	r0
    3cea:	0f be       	out	0x3f, r0	; 63
    3cec:	0f 90       	pop	r0
    3cee:	1f 90       	pop	r1
    3cf0:	18 95       	reti

00003cf2 <__vector_27>:
	}
}

	// service UART transmit interrupt
UART_INTERRUPT_HANDLER(SIG_USART0_TRANS)      
{
    3cf2:	1f 92       	push	r1
    3cf4:	0f 92       	push	r0
    3cf6:	0f b6       	in	r0, 0x3f	; 63
    3cf8:	0f 92       	push	r0
    3cfa:	11 24       	eor	r1, r1
    3cfc:	2f 93       	push	r18
    3cfe:	3f 93       	push	r19
    3d00:	4f 93       	push	r20
    3d02:	5f 93       	push	r21
    3d04:	6f 93       	push	r22
    3d06:	7f 93       	push	r23
    3d08:	8f 93       	push	r24
    3d0a:	9f 93       	push	r25
    3d0c:	af 93       	push	r26
    3d0e:	bf 93       	push	r27
    3d10:	ef 93       	push	r30
    3d12:	ff 93       	push	r31
	uartTransmitService(0);
    3d14:	80 e0       	ldi	r24, 0x00	; 0
    3d16:	0e 94 c9 1d 	call	0x3b92	; 0x3b92 <uartTransmitService>
}
    3d1a:	ff 91       	pop	r31
    3d1c:	ef 91       	pop	r30
    3d1e:	bf 91       	pop	r27
    3d20:	af 91       	pop	r26
    3d22:	9f 91       	pop	r25
    3d24:	8f 91       	pop	r24
    3d26:	7f 91       	pop	r23
    3d28:	6f 91       	pop	r22
    3d2a:	5f 91       	pop	r21
    3d2c:	4f 91       	pop	r20
    3d2e:	3f 91       	pop	r19
    3d30:	2f 91       	pop	r18
    3d32:	0f 90       	pop	r0
    3d34:	0f be       	out	0x3f, r0	; 63
    3d36:	0f 90       	pop	r0
    3d38:	1f 90       	pop	r1
    3d3a:	18 95       	reti

00003d3c <uartSendTxBuffer>:
{
	uartAddToTxBuffer(3,data);
}

void uartSendTxBuffer(u08 nUart)
{
    3d3c:	1f 93       	push	r17
    3d3e:	18 2f       	mov	r17, r24
	// turn on buffered transmit
	uartBufferedTx[nUart] = TRUE;
    3d40:	90 e0       	ldi	r25, 0x00	; 0
    3d42:	fc 01       	movw	r30, r24
    3d44:	e2 50       	subi	r30, 0x02	; 2
    3d46:	fd 4e       	sbci	r31, 0xED	; 237
    3d48:	2f ef       	ldi	r18, 0xFF	; 255
    3d4a:	20 83       	st	Z, r18
	// send the first byte to get things going by interrupts
	uartSendByte(nUart, bufferGetFromFront(&uartTxBuffer[nUart]));
    3d4c:	43 e0       	ldi	r20, 0x03	; 3
    3d4e:	88 0f       	add	r24, r24
    3d50:	99 1f       	adc	r25, r25
    3d52:	4a 95       	dec	r20
    3d54:	e1 f7       	brne	.-8      	; 0x3d4e <uartSendTxBuffer+0x12>
    3d56:	8e 5f       	subi	r24, 0xFE	; 254
    3d58:	9c 4e       	sbci	r25, 0xEC	; 236
    3d5a:	0e 94 14 20 	call	0x4028	; 0x4028 <bufferGetFromFront>
    3d5e:	68 2f       	mov	r22, r24
    3d60:	81 2f       	mov	r24, r17
    3d62:	0e 94 25 1c 	call	0x384a	; 0x384a <uartSendByte>
}
    3d66:	1f 91       	pop	r17
    3d68:	08 95       	ret

00003d6a <uartReceiveByte>:
		return -1;
}


u08 uartReceiveByte(u08 nUart, u08* rxData)
{
    3d6a:	cf 93       	push	r28
    3d6c:	df 93       	push	r29
    3d6e:	eb 01       	movw	r28, r22
	// make sure we have a receive buffer
	if(uartRxBuffer[nUart].size)
    3d70:	28 2f       	mov	r18, r24
    3d72:	30 e0       	ldi	r19, 0x00	; 0
    3d74:	f9 01       	movw	r30, r18
    3d76:	73 e0       	ldi	r23, 0x03	; 3
    3d78:	ee 0f       	add	r30, r30
    3d7a:	ff 1f       	adc	r31, r31
    3d7c:	7a 95       	dec	r23
    3d7e:	e1 f7       	brne	.-8      	; 0x3d78 <uartReceiveByte+0xe>
    3d80:	e0 52       	subi	r30, 0x20	; 32
    3d82:	fd 4e       	sbci	r31, 0xED	; 237
    3d84:	80 81       	ld	r24, Z
    3d86:	91 81       	ldd	r25, Z+1	; 0x01
    3d88:	89 2b       	or	r24, r25
    3d8a:	c9 f0       	breq	.+50     	; 0x3dbe <uartReceiveByte+0x54>
	{
		// make sure we have data
		if(uartRxBuffer[nUart].datalength)
    3d8c:	f9 01       	movw	r30, r18
    3d8e:	63 e0       	ldi	r22, 0x03	; 3
    3d90:	ee 0f       	add	r30, r30
    3d92:	ff 1f       	adc	r31, r31
    3d94:	6a 95       	dec	r22
    3d96:	e1 f7       	brne	.-8      	; 0x3d90 <uartReceiveByte+0x26>
    3d98:	ee 51       	subi	r30, 0x1E	; 30
    3d9a:	fd 4e       	sbci	r31, 0xED	; 237
    3d9c:	80 81       	ld	r24, Z
    3d9e:	91 81       	ldd	r25, Z+1	; 0x01
    3da0:	89 2b       	or	r24, r25
    3da2:	69 f0       	breq	.+26     	; 0x3dbe <uartReceiveByte+0x54>
		{
			// get byte from beginning of buffer
			*rxData = bufferGetFromFront(&uartRxBuffer[nUart]);
    3da4:	53 e0       	ldi	r21, 0x03	; 3
    3da6:	22 0f       	add	r18, r18
    3da8:	33 1f       	adc	r19, r19
    3daa:	5a 95       	dec	r21
    3dac:	e1 f7       	brne	.-8      	; 0x3da6 <uartReceiveByte+0x3c>
    3dae:	c9 01       	movw	r24, r18
    3db0:	82 52       	subi	r24, 0x22	; 34
    3db2:	9d 4e       	sbci	r25, 0xED	; 237
    3db4:	0e 94 14 20 	call	0x4028	; 0x4028 <bufferGetFromFront>
    3db8:	88 83       	st	Y, r24
    3dba:	8f ef       	ldi	r24, 0xFF	; 255
    3dbc:	01 c0       	rjmp	.+2      	; 0x3dc0 <uartReceiveByte+0x56>
			return TRUE;
    3dbe:	80 e0       	ldi	r24, 0x00	; 0
		else
			return FALSE;			// no data
	}
	else
		return FALSE;				// no buffer
}
    3dc0:	df 91       	pop	r29
    3dc2:	cf 91       	pop	r28
    3dc4:	08 95       	ret

00003dc6 <uart3GetByte>:
	else
		return -1;
}

int uart3GetByte(void)
{
    3dc6:	df 93       	push	r29
    3dc8:	cf 93       	push	r28
    3dca:	0f 92       	push	r0
    3dcc:	cd b7       	in	r28, 0x3d	; 61
    3dce:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(3,&c))
    3dd0:	83 e0       	ldi	r24, 0x03	; 3
    3dd2:	be 01       	movw	r22, r28
    3dd4:	6f 5f       	subi	r22, 0xFF	; 255
    3dd6:	7f 4f       	sbci	r23, 0xFF	; 255
    3dd8:	0e 94 b5 1e 	call	0x3d6a	; 0x3d6a <uartReceiveByte>
    3ddc:	88 23       	and	r24, r24
    3dde:	19 f4       	brne	.+6      	; 0x3de6 <uart3GetByte+0x20>
    3de0:	2f ef       	ldi	r18, 0xFF	; 255
    3de2:	3f ef       	ldi	r19, 0xFF	; 255
    3de4:	03 c0       	rjmp	.+6      	; 0x3dec <uart3GetByte+0x26>
		return c;
    3de6:	89 81       	ldd	r24, Y+1	; 0x01
    3de8:	28 2f       	mov	r18, r24
    3dea:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    3dec:	c9 01       	movw	r24, r18
    3dee:	0f 90       	pop	r0
    3df0:	cf 91       	pop	r28
    3df2:	df 91       	pop	r29
    3df4:	08 95       	ret

00003df6 <uart2GetByte>:
	else
		return -1;
}

int uart2GetByte(void)
{
    3df6:	df 93       	push	r29
    3df8:	cf 93       	push	r28
    3dfa:	0f 92       	push	r0
    3dfc:	cd b7       	in	r28, 0x3d	; 61
    3dfe:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(2,&c))
    3e00:	82 e0       	ldi	r24, 0x02	; 2
    3e02:	be 01       	movw	r22, r28
    3e04:	6f 5f       	subi	r22, 0xFF	; 255
    3e06:	7f 4f       	sbci	r23, 0xFF	; 255
    3e08:	0e 94 b5 1e 	call	0x3d6a	; 0x3d6a <uartReceiveByte>
    3e0c:	88 23       	and	r24, r24
    3e0e:	19 f4       	brne	.+6      	; 0x3e16 <uart2GetByte+0x20>
    3e10:	2f ef       	ldi	r18, 0xFF	; 255
    3e12:	3f ef       	ldi	r19, 0xFF	; 255
    3e14:	03 c0       	rjmp	.+6      	; 0x3e1c <uart2GetByte+0x26>
		return c;
    3e16:	89 81       	ldd	r24, Y+1	; 0x01
    3e18:	28 2f       	mov	r18, r24
    3e1a:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    3e1c:	c9 01       	movw	r24, r18
    3e1e:	0f 90       	pop	r0
    3e20:	cf 91       	pop	r28
    3e22:	df 91       	pop	r29
    3e24:	08 95       	ret

00003e26 <uart1GetByte>:
	else
		return -1;
}

int uart1GetByte(void)
{
    3e26:	df 93       	push	r29
    3e28:	cf 93       	push	r28
    3e2a:	0f 92       	push	r0
    3e2c:	cd b7       	in	r28, 0x3d	; 61
    3e2e:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(1,&c))
    3e30:	81 e0       	ldi	r24, 0x01	; 1
    3e32:	be 01       	movw	r22, r28
    3e34:	6f 5f       	subi	r22, 0xFF	; 255
    3e36:	7f 4f       	sbci	r23, 0xFF	; 255
    3e38:	0e 94 b5 1e 	call	0x3d6a	; 0x3d6a <uartReceiveByte>
    3e3c:	88 23       	and	r24, r24
    3e3e:	19 f4       	brne	.+6      	; 0x3e46 <uart1GetByte+0x20>
    3e40:	2f ef       	ldi	r18, 0xFF	; 255
    3e42:	3f ef       	ldi	r19, 0xFF	; 255
    3e44:	03 c0       	rjmp	.+6      	; 0x3e4c <uart1GetByte+0x26>
		return c;
    3e46:	89 81       	ldd	r24, Y+1	; 0x01
    3e48:	28 2f       	mov	r18, r24
    3e4a:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    3e4c:	c9 01       	movw	r24, r18
    3e4e:	0f 90       	pop	r0
    3e50:	cf 91       	pop	r28
    3e52:	df 91       	pop	r29
    3e54:	08 95       	ret

00003e56 <uart0GetByte>:
	// send byte on UART3
	uartSendByte(3, data);
}

int uart0GetByte(void)
{
    3e56:	df 93       	push	r29
    3e58:	cf 93       	push	r28
    3e5a:	0f 92       	push	r0
    3e5c:	cd b7       	in	r28, 0x3d	; 61
    3e5e:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(0,&c))
    3e60:	80 e0       	ldi	r24, 0x00	; 0
    3e62:	be 01       	movw	r22, r28
    3e64:	6f 5f       	subi	r22, 0xFF	; 255
    3e66:	7f 4f       	sbci	r23, 0xFF	; 255
    3e68:	0e 94 b5 1e 	call	0x3d6a	; 0x3d6a <uartReceiveByte>
    3e6c:	88 23       	and	r24, r24
    3e6e:	19 f4       	brne	.+6      	; 0x3e76 <uart0GetByte+0x20>
    3e70:	2f ef       	ldi	r18, 0xFF	; 255
    3e72:	3f ef       	ldi	r19, 0xFF	; 255
    3e74:	03 c0       	rjmp	.+6      	; 0x3e7c <uart0GetByte+0x26>
		return c;
    3e76:	89 81       	ldd	r24, Y+1	; 0x01
    3e78:	28 2f       	mov	r18, r24
    3e7a:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    3e7c:	c9 01       	movw	r24, r18
    3e7e:	0f 90       	pop	r0
    3e80:	cf 91       	pop	r28
    3e82:	df 91       	pop	r29
    3e84:	08 95       	ret

00003e86 <uartFlushReceiveBuffer>:
}

void uartFlushReceiveBuffer(u08 nUart)
{
	// flush all data from receive buffer
	bufferFlush(&uartRxBuffer[nUart]);
    3e86:	90 e0       	ldi	r25, 0x00	; 0
    3e88:	e3 e0       	ldi	r30, 0x03	; 3
    3e8a:	88 0f       	add	r24, r24
    3e8c:	99 1f       	adc	r25, r25
    3e8e:	ea 95       	dec	r30
    3e90:	e1 f7       	brne	.-8      	; 0x3e8a <uartFlushReceiveBuffer+0x4>
    3e92:	82 52       	subi	r24, 0x22	; 34
    3e94:	9d 4e       	sbci	r25, 0xED	; 237
    3e96:	0e 94 b0 20 	call	0x4160	; 0x4160 <bufferFlush>
}
    3e9a:	08 95       	ret

00003e9c <uart3InitBuffers>:

void uart3InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART3 buffers
		bufferInit(&uartRxBuffer[3], (u08*) uart3RxData, UART3_RX_BUFFER_SIZE);
    3e9c:	86 ef       	ldi	r24, 0xF6	; 246
    3e9e:	92 e1       	ldi	r25, 0x12	; 18
    3ea0:	6e ec       	ldi	r22, 0xCE	; 206
    3ea2:	70 e1       	ldi	r23, 0x10	; 16
    3ea4:	40 e8       	ldi	r20, 0x80	; 128
    3ea6:	50 e0       	ldi	r21, 0x00	; 0
    3ea8:	0e 94 07 20 	call	0x400e	; 0x400e <bufferInit>
		bufferInit(&uartTxBuffer[3], (u08*) uart3TxData, UART3_TX_BUFFER_SIZE);
    3eac:	8a e1       	ldi	r24, 0x1A	; 26
    3eae:	93 e1       	ldi	r25, 0x13	; 19
    3eb0:	6e e4       	ldi	r22, 0x4E	; 78
    3eb2:	71 e1       	ldi	r23, 0x11	; 17
    3eb4:	40 e1       	ldi	r20, 0x10	; 16
    3eb6:	50 e0       	ldi	r21, 0x00	; 0
    3eb8:	0e 94 07 20 	call	0x400e	; 0x400e <bufferInit>
	#else
		// initialize the UART3 buffers
		bufferInit(&uartRxBuffer[3], (u08*) UART3_RX_BUFFER_ADDR, UART3_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[3], (u08*) UART3_TX_BUFFER_ADDR, UART3_TX_BUFFER_SIZE);
	#endif
}
    3ebc:	08 95       	ret

00003ebe <uart3Init>:
}

void uart3Init(void)
{
	// initialize the buffers
	uart3InitBuffers();
    3ebe:	0e 94 4e 1f 	call	0x3e9c	; 0x3e9c <uart3InitBuffers>
	// initialize user receive handlers
	UartRxFunc[3] = 0;
    3ec2:	10 92 65 11 	sts	0x1165, r1
    3ec6:	10 92 64 11 	sts	0x1164, r1
	// enable RxD/TxD and interrupts
	outb(UCSR3B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    3eca:	88 ed       	ldi	r24, 0xD8	; 216
    3ecc:	80 93 31 01 	sts	0x0131, r24
	// set default baud rate
	uartSetBaudRate(3, UART3_DEFAULT_BAUD_RATE);
    3ed0:	83 e0       	ldi	r24, 0x03	; 3
    3ed2:	40 e8       	ldi	r20, 0x80	; 128
    3ed4:	55 e2       	ldi	r21, 0x25	; 37
    3ed6:	60 e0       	ldi	r22, 0x00	; 0
    3ed8:	70 e0       	ldi	r23, 0x00	; 0
    3eda:	0e 94 d8 1b 	call	0x37b0	; 0x37b0 <uartSetBaudRate>
	// initialize states
	uartReadyTx[3] = TRUE;
    3ede:	8f ef       	ldi	r24, 0xFF	; 255
    3ee0:	80 93 dd 12 	sts	0x12DD, r24
	uartBufferedTx[3] = FALSE;
    3ee4:	10 92 01 13 	sts	0x1301, r1
	// clear overflow count
	uartRxOverflow[3] = 0;
    3ee8:	10 92 29 13 	sts	0x1329, r1
    3eec:	10 92 28 13 	sts	0x1328, r1
	// enable interrupts
	sei();
    3ef0:	78 94       	sei
}
    3ef2:	08 95       	ret

00003ef4 <uart2InitBuffers>:

void uart2InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART2 buffers
		bufferInit(&uartRxBuffer[2], (u08*) uart2RxData, UART2_RX_BUFFER_SIZE);
    3ef4:	8e ee       	ldi	r24, 0xEE	; 238
    3ef6:	92 e1       	ldi	r25, 0x12	; 18
    3ef8:	6e e3       	ldi	r22, 0x3E	; 62
    3efa:	70 e1       	ldi	r23, 0x10	; 16
    3efc:	40 e8       	ldi	r20, 0x80	; 128
    3efe:	50 e0       	ldi	r21, 0x00	; 0
    3f00:	0e 94 07 20 	call	0x400e	; 0x400e <bufferInit>
		bufferInit(&uartTxBuffer[2], (u08*) uart2TxData, UART2_TX_BUFFER_SIZE);
    3f04:	82 e1       	ldi	r24, 0x12	; 18
    3f06:	93 e1       	ldi	r25, 0x13	; 19
    3f08:	6e eb       	ldi	r22, 0xBE	; 190
    3f0a:	70 e1       	ldi	r23, 0x10	; 16
    3f0c:	40 e1       	ldi	r20, 0x10	; 16
    3f0e:	50 e0       	ldi	r21, 0x00	; 0
    3f10:	0e 94 07 20 	call	0x400e	; 0x400e <bufferInit>
	#else
		// initialize the UART2 buffers
		bufferInit(&uartRxBuffer[2], (u08*) UART2_RX_BUFFER_ADDR, UART2_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[2], (u08*) UART2_TX_BUFFER_ADDR, UART2_TX_BUFFER_SIZE);
	#endif
}
    3f14:	08 95       	ret

00003f16 <uart2Init>:
}

void uart2Init(void)
{
	// initialize the buffers
	uart2InitBuffers();
    3f16:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <uart2InitBuffers>
	// initialize user receive handlers
	UartRxFunc[2] = 0;
    3f1a:	10 92 63 11 	sts	0x1163, r1
    3f1e:	10 92 62 11 	sts	0x1162, r1
	// enable RxD/TxD and interrupts
	outb(UCSR2B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    3f22:	88 ed       	ldi	r24, 0xD8	; 216
    3f24:	80 93 d1 00 	sts	0x00D1, r24
	// set default baud rate
	uartSetBaudRate(2, UART2_DEFAULT_BAUD_RATE);
    3f28:	82 e0       	ldi	r24, 0x02	; 2
    3f2a:	40 e8       	ldi	r20, 0x80	; 128
    3f2c:	55 e2       	ldi	r21, 0x25	; 37
    3f2e:	60 e0       	ldi	r22, 0x00	; 0
    3f30:	70 e0       	ldi	r23, 0x00	; 0
    3f32:	0e 94 d8 1b 	call	0x37b0	; 0x37b0 <uartSetBaudRate>
	// initialize states
	uartReadyTx[2] = TRUE;
    3f36:	8f ef       	ldi	r24, 0xFF	; 255
    3f38:	80 93 dc 12 	sts	0x12DC, r24
	uartBufferedTx[2] = FALSE;
    3f3c:	10 92 00 13 	sts	0x1300, r1
	// clear overflow count
	uartRxOverflow[2] = 0;
    3f40:	10 92 27 13 	sts	0x1327, r1
    3f44:	10 92 26 13 	sts	0x1326, r1
	// enable interrupts
	sei();
    3f48:	78 94       	sei
}
    3f4a:	08 95       	ret

00003f4c <uart1InitBuffers>:

void uart1InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART1 buffers
		bufferInit(&uartRxBuffer[1], (u08*) uart1RxData, UART1_RX_BUFFER_SIZE);
    3f4c:	86 ee       	ldi	r24, 0xE6	; 230
    3f4e:	92 e1       	ldi	r25, 0x12	; 18
    3f50:	6e ea       	ldi	r22, 0xAE	; 174
    3f52:	7f e0       	ldi	r23, 0x0F	; 15
    3f54:	40 e8       	ldi	r20, 0x80	; 128
    3f56:	50 e0       	ldi	r21, 0x00	; 0
    3f58:	0e 94 07 20 	call	0x400e	; 0x400e <bufferInit>
		bufferInit(&uartTxBuffer[1], (u08*) uart1TxData, UART1_TX_BUFFER_SIZE);
    3f5c:	8a e0       	ldi	r24, 0x0A	; 10
    3f5e:	93 e1       	ldi	r25, 0x13	; 19
    3f60:	6e e2       	ldi	r22, 0x2E	; 46
    3f62:	70 e1       	ldi	r23, 0x10	; 16
    3f64:	40 e1       	ldi	r20, 0x10	; 16
    3f66:	50 e0       	ldi	r21, 0x00	; 0
    3f68:	0e 94 07 20 	call	0x400e	; 0x400e <bufferInit>
	#else
		// initialize the UART1 buffers
		bufferInit(&uartRxBuffer[1], (u08*) UART1_RX_BUFFER_ADDR, UART1_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[1], (u08*) UART1_TX_BUFFER_ADDR, UART1_TX_BUFFER_SIZE);
	#endif
}
    3f6c:	08 95       	ret

00003f6e <uart1Init>:
}

void uart1Init(void)
{
	// initialize the buffers
	uart1InitBuffers();
    3f6e:	0e 94 a6 1f 	call	0x3f4c	; 0x3f4c <uart1InitBuffers>
	// initialize user receive handlers
	UartRxFunc[1] = 0;
    3f72:	10 92 61 11 	sts	0x1161, r1
    3f76:	10 92 60 11 	sts	0x1160, r1
	// enable RxD/TxD and interrupts
	outb(UCSR1B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    3f7a:	88 ed       	ldi	r24, 0xD8	; 216
    3f7c:	80 93 c9 00 	sts	0x00C9, r24
	// set default baud rate
	uartSetBaudRate(1, UART1_DEFAULT_BAUD_RATE);
    3f80:	81 e0       	ldi	r24, 0x01	; 1
    3f82:	40 e8       	ldi	r20, 0x80	; 128
    3f84:	55 e2       	ldi	r21, 0x25	; 37
    3f86:	60 e0       	ldi	r22, 0x00	; 0
    3f88:	70 e0       	ldi	r23, 0x00	; 0
    3f8a:	0e 94 d8 1b 	call	0x37b0	; 0x37b0 <uartSetBaudRate>
	// initialize states
	uartReadyTx[1] = TRUE;
    3f8e:	8f ef       	ldi	r24, 0xFF	; 255
    3f90:	80 93 db 12 	sts	0x12DB, r24
	uartBufferedTx[1] = FALSE;
    3f94:	10 92 ff 12 	sts	0x12FF, r1
	// clear overflow count
	uartRxOverflow[1] = 0;
    3f98:	10 92 25 13 	sts	0x1325, r1
    3f9c:	10 92 24 13 	sts	0x1324, r1
	// enable interrupts
	sei();
    3fa0:	78 94       	sei
}
    3fa2:	08 95       	ret

00003fa4 <uart0InitBuffers>:

void uart0InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART0 buffers
		bufferInit(&uartRxBuffer[0], (u08*) uart0RxData, UART0_RX_BUFFER_SIZE);
    3fa4:	8e ed       	ldi	r24, 0xDE	; 222
    3fa6:	92 e1       	ldi	r25, 0x12	; 18
    3fa8:	6e e1       	ldi	r22, 0x1E	; 30
    3faa:	7f e0       	ldi	r23, 0x0F	; 15
    3fac:	40 e8       	ldi	r20, 0x80	; 128
    3fae:	50 e0       	ldi	r21, 0x00	; 0
    3fb0:	0e 94 07 20 	call	0x400e	; 0x400e <bufferInit>
		bufferInit(&uartTxBuffer[0], (u08*) uart0TxData, UART0_TX_BUFFER_SIZE);
    3fb4:	82 e0       	ldi	r24, 0x02	; 2
    3fb6:	93 e1       	ldi	r25, 0x13	; 19
    3fb8:	6e e9       	ldi	r22, 0x9E	; 158
    3fba:	7f e0       	ldi	r23, 0x0F	; 15
    3fbc:	40 e1       	ldi	r20, 0x10	; 16
    3fbe:	50 e0       	ldi	r21, 0x00	; 0
    3fc0:	0e 94 07 20 	call	0x400e	; 0x400e <bufferInit>
	#else
		// initialize the UART0 buffers
		bufferInit(&uartRxBuffer[0], (u08*) UART0_RX_BUFFER_ADDR, UART0_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[0], (u08*) UART0_TX_BUFFER_ADDR, UART0_TX_BUFFER_SIZE);
	#endif
}
    3fc4:	08 95       	ret

00003fc6 <uart0Init>:
}

void uart0Init(void)
{
	// initialize the buffers
	uart0InitBuffers();
    3fc6:	0e 94 d2 1f 	call	0x3fa4	; 0x3fa4 <uart0InitBuffers>
	// initialize user receive handlers
	UartRxFunc[0] = 0;
    3fca:	10 92 5f 11 	sts	0x115F, r1
    3fce:	10 92 5e 11 	sts	0x115E, r1
	// enable RxD/TxD and interrupts
	outb(UCSR0B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    3fd2:	88 ed       	ldi	r24, 0xD8	; 216
    3fd4:	80 93 c1 00 	sts	0x00C1, r24
	// set default baud rate
	uartSetBaudRate(0, UART0_DEFAULT_BAUD_RATE); 
    3fd8:	80 e0       	ldi	r24, 0x00	; 0
    3fda:	40 e8       	ldi	r20, 0x80	; 128
    3fdc:	55 e2       	ldi	r21, 0x25	; 37
    3fde:	60 e0       	ldi	r22, 0x00	; 0
    3fe0:	70 e0       	ldi	r23, 0x00	; 0
    3fe2:	0e 94 d8 1b 	call	0x37b0	; 0x37b0 <uartSetBaudRate>
	// initialize states
	uartReadyTx[0] = TRUE;
    3fe6:	8f ef       	ldi	r24, 0xFF	; 255
    3fe8:	80 93 da 12 	sts	0x12DA, r24
	uartBufferedTx[0] = FALSE;
    3fec:	10 92 fe 12 	sts	0x12FE, r1
	// clear overflow count
	uartRxOverflow[0] = 0;
    3ff0:	10 92 23 13 	sts	0x1323, r1
    3ff4:	10 92 22 13 	sts	0x1322, r1
	// enable interrupts
	sei();
    3ff8:	78 94       	sei
}
    3ffa:	08 95       	ret

00003ffc <uartInit>:
volatile static voidFuncPtru08 UartRxFunc[4];

void uartInit(void)
{
	// initialize all uarts
	uart0Init();
    3ffc:	0e 94 e3 1f 	call	0x3fc6	; 0x3fc6 <uart0Init>
	uart1Init();
    4000:	0e 94 b7 1f 	call	0x3f6e	; 0x3f6e <uart1Init>
	uart2Init();
    4004:	0e 94 8b 1f 	call	0x3f16	; 0x3f16 <uart2Init>
	uart3Init();
    4008:	0e 94 5f 1f 	call	0x3ebe	; 0x3ebe <uart3Init>
}
    400c:	08 95       	ret

0000400e <bufferInit>:
// global variables

// initialization

void bufferInit(cBuffer* buffer, unsigned char *start, unsigned short size)
{
    400e:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    4010:	8f b7       	in	r24, 0x3f	; 63
    4012:	f8 94       	cli
	// set start pointer of the buffer
	buffer->dataptr = start;
    4014:	71 83       	std	Z+1, r23	; 0x01
    4016:	60 83       	st	Z, r22
	buffer->size = size;
    4018:	53 83       	std	Z+3, r21	; 0x03
    401a:	42 83       	std	Z+2, r20	; 0x02
	// initialize index and length
	buffer->dataindex = 0;
    401c:	17 82       	std	Z+7, r1	; 0x07
    401e:	16 82       	std	Z+6, r1	; 0x06
	buffer->datalength = 0;
    4020:	15 82       	std	Z+5, r1	; 0x05
    4022:	14 82       	std	Z+4, r1	; 0x04
	// end critical section
	CRITICAL_SECTION_END;
    4024:	8f bf       	out	0x3f, r24	; 63
}
    4026:	08 95       	ret

00004028 <bufferGetFromFront>:

// access routines
unsigned char  bufferGetFromFront(cBuffer* buffer)
{
    4028:	dc 01       	movw	r26, r24
	unsigned char data = 0;
	// begin critical section
	CRITICAL_SECTION_START;
    402a:	4f b7       	in	r20, 0x3f	; 63
    402c:	f8 94       	cli
	// check to see if there's data in the buffer
	if(buffer->datalength)
    402e:	14 96       	adiw	r26, 0x04	; 4
    4030:	8d 91       	ld	r24, X+
    4032:	9c 91       	ld	r25, X
    4034:	15 97       	sbiw	r26, 0x05	; 5
    4036:	89 2b       	or	r24, r25
    4038:	11 f4       	brne	.+4      	; 0x403e <bufferGetFromFront+0x16>
    403a:	e0 e0       	ldi	r30, 0x00	; 0
    403c:	25 c0       	rjmp	.+74     	; 0x4088 <bufferGetFromFront+0x60>
	{
		// get the first character from buffer
		data = buffer->dataptr[buffer->dataindex];
    403e:	16 96       	adiw	r26, 0x06	; 6
    4040:	8d 91       	ld	r24, X+
    4042:	9c 91       	ld	r25, X
    4044:	17 97       	sbiw	r26, 0x07	; 7
    4046:	ed 91       	ld	r30, X+
    4048:	fc 91       	ld	r31, X
    404a:	11 97       	sbiw	r26, 0x01	; 1
    404c:	e8 0f       	add	r30, r24
    404e:	f9 1f       	adc	r31, r25
    4050:	e0 81       	ld	r30, Z
		// move index down and decrement length
		buffer->dataindex++;
    4052:	01 96       	adiw	r24, 0x01	; 1
    4054:	17 96       	adiw	r26, 0x07	; 7
    4056:	9c 93       	st	X, r25
    4058:	8e 93       	st	-X, r24
    405a:	16 97       	sbiw	r26, 0x06	; 6
		if(buffer->dataindex >= buffer->size)
    405c:	12 96       	adiw	r26, 0x02	; 2
    405e:	2d 91       	ld	r18, X+
    4060:	3c 91       	ld	r19, X
    4062:	13 97       	sbiw	r26, 0x03	; 3
    4064:	82 17       	cp	r24, r18
    4066:	93 07       	cpc	r25, r19
    4068:	30 f0       	brcs	.+12     	; 0x4076 <bufferGetFromFront+0x4e>
		{
			buffer->dataindex -= buffer->size;
    406a:	82 1b       	sub	r24, r18
    406c:	93 0b       	sbc	r25, r19
    406e:	17 96       	adiw	r26, 0x07	; 7
    4070:	9c 93       	st	X, r25
    4072:	8e 93       	st	-X, r24
    4074:	16 97       	sbiw	r26, 0x06	; 6
		}
		buffer->datalength--;
    4076:	14 96       	adiw	r26, 0x04	; 4
    4078:	8d 91       	ld	r24, X+
    407a:	9c 91       	ld	r25, X
    407c:	15 97       	sbiw	r26, 0x05	; 5
    407e:	01 97       	sbiw	r24, 0x01	; 1
    4080:	15 96       	adiw	r26, 0x05	; 5
    4082:	9c 93       	st	X, r25
    4084:	8e 93       	st	-X, r24
    4086:	14 97       	sbiw	r26, 0x04	; 4
	}
	// end critical section
	CRITICAL_SECTION_END;
    4088:	4f bf       	out	0x3f, r20	; 63
	// return
	return data;
}
    408a:	8e 2f       	mov	r24, r30
    408c:	08 95       	ret

0000408e <bufferDumpFromFront>:

void bufferDumpFromFront(cBuffer* buffer, unsigned short numbytes)
{
    408e:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    4090:	4f b7       	in	r20, 0x3f	; 63
    4092:	f8 94       	cli
	// dump numbytes from the front of the buffer
	// are we dumping less than the entire buffer?
	if(numbytes < buffer->datalength)
    4094:	84 81       	ldd	r24, Z+4	; 0x04
    4096:	95 81       	ldd	r25, Z+5	; 0x05
    4098:	68 17       	cp	r22, r24
    409a:	79 07       	cpc	r23, r25
    409c:	b0 f4       	brcc	.+44     	; 0x40ca <bufferDumpFromFront+0x3c>
	{
		// move index down by numbytes and decrement length by numbytes
		buffer->dataindex += numbytes;
    409e:	86 81       	ldd	r24, Z+6	; 0x06
    40a0:	97 81       	ldd	r25, Z+7	; 0x07
    40a2:	86 0f       	add	r24, r22
    40a4:	97 1f       	adc	r25, r23
    40a6:	97 83       	std	Z+7, r25	; 0x07
    40a8:	86 83       	std	Z+6, r24	; 0x06
		if(buffer->dataindex >= buffer->size)
    40aa:	22 81       	ldd	r18, Z+2	; 0x02
    40ac:	33 81       	ldd	r19, Z+3	; 0x03
    40ae:	82 17       	cp	r24, r18
    40b0:	93 07       	cpc	r25, r19
    40b2:	20 f0       	brcs	.+8      	; 0x40bc <bufferDumpFromFront+0x2e>
		{
			buffer->dataindex -= buffer->size;
    40b4:	82 1b       	sub	r24, r18
    40b6:	93 0b       	sbc	r25, r19
    40b8:	97 83       	std	Z+7, r25	; 0x07
    40ba:	86 83       	std	Z+6, r24	; 0x06
		}
		buffer->datalength -= numbytes;
    40bc:	84 81       	ldd	r24, Z+4	; 0x04
    40be:	95 81       	ldd	r25, Z+5	; 0x05
    40c0:	86 1b       	sub	r24, r22
    40c2:	97 0b       	sbc	r25, r23
    40c4:	95 83       	std	Z+5, r25	; 0x05
    40c6:	84 83       	std	Z+4, r24	; 0x04
    40c8:	02 c0       	rjmp	.+4      	; 0x40ce <bufferDumpFromFront+0x40>
	}
	else
	{
		// flush the whole buffer
		buffer->datalength = 0;
    40ca:	15 82       	std	Z+5, r1	; 0x05
    40cc:	14 82       	std	Z+4, r1	; 0x04
	}
	// end critical section
	CRITICAL_SECTION_END;
    40ce:	4f bf       	out	0x3f, r20	; 63
}
    40d0:	08 95       	ret

000040d2 <bufferGetAtIndex>:

unsigned char bufferGetAtIndex(cBuffer* buffer, unsigned short index)
{
    40d2:	fc 01       	movw	r30, r24
    40d4:	cb 01       	movw	r24, r22
	// begin critical section
	CRITICAL_SECTION_START;
    40d6:	2f b7       	in	r18, 0x3f	; 63
    40d8:	f8 94       	cli
	// return character at index in buffer
	unsigned char data = buffer->dataptr[(buffer->dataindex+index)%(buffer->size)];
	// end critical section
	CRITICAL_SECTION_END;
    40da:	2f bf       	out	0x3f, r18	; 63
    40dc:	26 81       	ldd	r18, Z+6	; 0x06
    40de:	37 81       	ldd	r19, Z+7	; 0x07
    40e0:	62 81       	ldd	r22, Z+2	; 0x02
    40e2:	73 81       	ldd	r23, Z+3	; 0x03
    40e4:	82 0f       	add	r24, r18
    40e6:	93 1f       	adc	r25, r19
    40e8:	0e 94 b5 28 	call	0x516a	; 0x516a <__udivmodhi4>
    40ec:	01 90       	ld	r0, Z+
    40ee:	f0 81       	ld	r31, Z
    40f0:	e0 2d       	mov	r30, r0
    40f2:	e8 0f       	add	r30, r24
    40f4:	f9 1f       	adc	r31, r25
	return data;
}
    40f6:	80 81       	ld	r24, Z
    40f8:	08 95       	ret

000040fa <bufferAddToEnd>:

unsigned char bufferAddToEnd(cBuffer* buffer, unsigned char data)
{
    40fa:	1f 93       	push	r17
    40fc:	cf 93       	push	r28
    40fe:	df 93       	push	r29
    4100:	ec 01       	movw	r28, r24
    4102:	16 2f       	mov	r17, r22
	// begin critical section
	CRITICAL_SECTION_START;
    4104:	4f b7       	in	r20, 0x3f	; 63
    4106:	f8 94       	cli
	// make sure the buffer has room
	if(buffer->datalength < buffer->size)
    4108:	2c 81       	ldd	r18, Y+4	; 0x04
    410a:	3d 81       	ldd	r19, Y+5	; 0x05
    410c:	6a 81       	ldd	r22, Y+2	; 0x02
    410e:	7b 81       	ldd	r23, Y+3	; 0x03
    4110:	26 17       	cp	r18, r22
    4112:	37 07       	cpc	r19, r23
    4114:	98 f4       	brcc	.+38     	; 0x413c <bufferAddToEnd+0x42>
	{
		// save data byte at end of buffer
		buffer->dataptr[(buffer->dataindex + buffer->datalength) % buffer->size] = data;
    4116:	8e 81       	ldd	r24, Y+6	; 0x06
    4118:	9f 81       	ldd	r25, Y+7	; 0x07
    411a:	82 0f       	add	r24, r18
    411c:	93 1f       	adc	r25, r19
    411e:	0e 94 b5 28 	call	0x516a	; 0x516a <__udivmodhi4>
    4122:	e8 81       	ld	r30, Y
    4124:	f9 81       	ldd	r31, Y+1	; 0x01
    4126:	e8 0f       	add	r30, r24
    4128:	f9 1f       	adc	r31, r25
    412a:	10 83       	st	Z, r17
		// increment the length
		buffer->datalength++;
    412c:	8c 81       	ldd	r24, Y+4	; 0x04
    412e:	9d 81       	ldd	r25, Y+5	; 0x05
    4130:	01 96       	adiw	r24, 0x01	; 1
    4132:	9d 83       	std	Y+5, r25	; 0x05
    4134:	8c 83       	std	Y+4, r24	; 0x04
		// end critical section
		CRITICAL_SECTION_END;
    4136:	4f bf       	out	0x3f, r20	; 63
    4138:	8f ef       	ldi	r24, 0xFF	; 255
    413a:	02 c0       	rjmp	.+4      	; 0x4140 <bufferAddToEnd+0x46>
		// return success
		return -1;
	}
	// end critical section
	CRITICAL_SECTION_END;
    413c:	4f bf       	out	0x3f, r20	; 63
    413e:	80 e0       	ldi	r24, 0x00	; 0
	// return failure
	return 0;
}
    4140:	df 91       	pop	r29
    4142:	cf 91       	pop	r28
    4144:	1f 91       	pop	r17
    4146:	08 95       	ret

00004148 <bufferIsNotFull>:

unsigned short bufferIsNotFull(cBuffer* buffer)
{
    4148:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    414a:	8f b7       	in	r24, 0x3f	; 63
    414c:	f8 94       	cli
	// check to see if the buffer has room
	// return true if there is room
	unsigned short bytesleft = (buffer->size - buffer->datalength);
	// end critical section
	CRITICAL_SECTION_END;
    414e:	8f bf       	out	0x3f, r24	; 63
    4150:	22 81       	ldd	r18, Z+2	; 0x02
    4152:	33 81       	ldd	r19, Z+3	; 0x03
    4154:	84 81       	ldd	r24, Z+4	; 0x04
    4156:	95 81       	ldd	r25, Z+5	; 0x05
    4158:	28 1b       	sub	r18, r24
    415a:	39 0b       	sbc	r19, r25
	return bytesleft;
}
    415c:	c9 01       	movw	r24, r18
    415e:	08 95       	ret

00004160 <bufferFlush>:

void bufferFlush(cBuffer* buffer)
{
    4160:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    4162:	8f b7       	in	r24, 0x3f	; 63
    4164:	f8 94       	cli
	// flush contents of the buffer
	buffer->datalength = 0;
    4166:	15 82       	std	Z+5, r1	; 0x05
    4168:	14 82       	std	Z+4, r1	; 0x04
	// end critical section
	CRITICAL_SECTION_END;
    416a:	8f bf       	out	0x3f, r24	; 63
}
    416c:	08 95       	ret

0000416e <a2dInit>:
// functions

// initialize a2d converter
void a2dInit(void)
{
	sbi(ADCSR, ADEN);				// enable ADC (turn on ADC power)
    416e:	aa e7       	ldi	r26, 0x7A	; 122
    4170:	b0 e0       	ldi	r27, 0x00	; 0
    4172:	8c 91       	ld	r24, X
    4174:	80 68       	ori	r24, 0x80	; 128
    4176:	8c 93       	st	X, r24
	cbi(ADCSR, ADFR);				// default to single sample convert mode
    4178:	8c 91       	ld	r24, X
    417a:	8f 7d       	andi	r24, 0xDF	; 223
    417c:	8c 93       	st	X, r24
}

// configure A2D converter clock division (prescaling)
void a2dSetPrescaler(unsigned char prescale)
{
	outb(ADCSR, ((inb(ADCSR) & ~ADC_PRESCALE_MASK) | prescale));
    417e:	8c 91       	ld	r24, X
    4180:	88 7f       	andi	r24, 0xF8	; 248
    4182:	86 60       	ori	r24, 0x06	; 6
    4184:	8c 93       	st	X, r24
}

// configure A2D converter voltage reference
void a2dSetReference(unsigned char ref)
{
	outb(ADMUX, ((inb(ADMUX) & ~ADC_REFERENCE_MASK) | (ref<<6)));
    4186:	ec e7       	ldi	r30, 0x7C	; 124
    4188:	f0 e0       	ldi	r31, 0x00	; 0
    418a:	80 81       	ld	r24, Z
    418c:	8f 73       	andi	r24, 0x3F	; 63
    418e:	80 64       	ori	r24, 0x40	; 64
    4190:	80 83       	st	Z, r24
{
	sbi(ADCSR, ADEN);				// enable ADC (turn on ADC power)
	cbi(ADCSR, ADFR);				// default to single sample convert mode
	a2dSetPrescaler(ADC_PRESCALE);	// set default prescaler
	a2dSetReference(ADC_REFERENCE);	// set default reference
	cbi(ADMUX, ADLAR);				// set to right-adjusted result
    4192:	80 81       	ld	r24, Z
    4194:	8f 7d       	andi	r24, 0xDF	; 223
    4196:	80 83       	st	Z, r24

	sbi(ADCSR, ADIE);				// enable ADC interrupts
    4198:	8c 91       	ld	r24, X
    419a:	88 60       	ori	r24, 0x08	; 8
    419c:	8c 93       	st	X, r24

	a2dCompleteFlag = FALSE;		// clear conversion complete flag
    419e:	10 92 2a 13 	sts	0x132A, r1
	sei();							// turn on interrupts (if not already on)
    41a2:	78 94       	sei
}
    41a4:	08 95       	ret

000041a6 <a2dOff>:

// turn off a2d converter
void a2dOff(void)
{
	cbi(ADCSR, ADIE);				// disable ADC interrupts
    41a6:	ea e7       	ldi	r30, 0x7A	; 122
    41a8:	f0 e0       	ldi	r31, 0x00	; 0
    41aa:	80 81       	ld	r24, Z
    41ac:	87 7f       	andi	r24, 0xF7	; 247
    41ae:	80 83       	st	Z, r24
	cbi(ADCSR, ADEN);				// disable ADC (turn off ADC power)
    41b0:	80 81       	ld	r24, Z
    41b2:	8f 77       	andi	r24, 0x7F	; 127
    41b4:	80 83       	st	Z, r24
}
    41b6:	08 95       	ret

000041b8 <a2dSetPrescaler>:

// configure A2D converter clock division (prescaling)
void a2dSetPrescaler(unsigned char prescale)
{
	outb(ADCSR, ((inb(ADCSR) & ~ADC_PRESCALE_MASK) | prescale));
    41b8:	ea e7       	ldi	r30, 0x7A	; 122
    41ba:	f0 e0       	ldi	r31, 0x00	; 0
    41bc:	90 81       	ld	r25, Z
    41be:	98 7f       	andi	r25, 0xF8	; 248
    41c0:	98 2b       	or	r25, r24
    41c2:	90 83       	st	Z, r25
}
    41c4:	08 95       	ret

000041c6 <a2dSetReference>:

// configure A2D converter voltage reference
void a2dSetReference(unsigned char ref)
{
	outb(ADMUX, ((inb(ADMUX) & ~ADC_REFERENCE_MASK) | (ref<<6)));
    41c6:	ec e7       	ldi	r30, 0x7C	; 124
    41c8:	f0 e0       	ldi	r31, 0x00	; 0
    41ca:	90 81       	ld	r25, Z
    41cc:	82 95       	swap	r24
    41ce:	88 0f       	add	r24, r24
    41d0:	88 0f       	add	r24, r24
    41d2:	80 7c       	andi	r24, 0xC0	; 192
    41d4:	9f 73       	andi	r25, 0x3F	; 63
    41d6:	98 2b       	or	r25, r24
    41d8:	90 83       	st	Z, r25
}
    41da:	08 95       	ret

000041dc <a2dSetChannel>:

// sets the a2d input channel
void a2dSetChannel(unsigned char ch)
{
	outb(ADMUX, (inb(ADMUX) & ~ADC_MUX_MASK) | (ch & ADC_MUX_MASK));	// set channel
    41dc:	ec e7       	ldi	r30, 0x7C	; 124
    41de:	f0 e0       	ldi	r31, 0x00	; 0
    41e0:	90 81       	ld	r25, Z
    41e2:	8f 71       	andi	r24, 0x1F	; 31
    41e4:	90 7e       	andi	r25, 0xE0	; 224
    41e6:	89 2b       	or	r24, r25
    41e8:	80 83       	st	Z, r24
}
    41ea:	08 95       	ret

000041ec <a2dStartConvert>:

// start a conversion on the current a2d input channel
void a2dStartConvert(void)
{
	sbi(ADCSR, ADIF);	// clear hardware "conversion complete" flag 
    41ec:	ea e7       	ldi	r30, 0x7A	; 122
    41ee:	f0 e0       	ldi	r31, 0x00	; 0
    41f0:	80 81       	ld	r24, Z
    41f2:	80 61       	ori	r24, 0x10	; 16
    41f4:	80 83       	st	Z, r24
	sbi(ADCSR, ADSC);	// start conversion
    41f6:	80 81       	ld	r24, Z
    41f8:	80 64       	ori	r24, 0x40	; 64
    41fa:	80 83       	st	Z, r24
}
    41fc:	08 95       	ret

000041fe <a2dIsComplete>:

// return TRUE if conversion is complete
u08 a2dIsComplete(void)
{
	return bit_is_set(ADCSR, ADSC);
    41fe:	80 91 7a 00 	lds	r24, 0x007A
}
    4202:	80 74       	andi	r24, 0x40	; 64
    4204:	08 95       	ret

00004206 <a2dConvert10bit>:

// Perform a 10-bit conversion
// starts conversion, waits until conversion is done, and returns result
unsigned short a2dConvert10bit(unsigned char ch)
{
    4206:	98 2f       	mov	r25, r24
	a2dCompleteFlag = FALSE;				// clear conversion complete flag
    4208:	10 92 2a 13 	sts	0x132A, r1

if (ch >= 8)
    420c:	88 30       	cpi	r24, 0x08	; 8
    420e:	20 f0       	brcs	.+8      	; 0x4218 <a2dConvert10bit+0x12>
    ADCSRB |= _BV(MUX5);
    4210:	80 91 7b 00 	lds	r24, 0x007B
    4214:	88 60       	ori	r24, 0x08	; 8
    4216:	03 c0       	rjmp	.+6      	; 0x421e <a2dConvert10bit+0x18>
else
    ADCSRB &= ~_BV(MUX5);
    4218:	80 91 7b 00 	lds	r24, 0x007B
    421c:	87 7f       	andi	r24, 0xF7	; 247
    421e:	80 93 7b 00 	sts	0x007B, r24

   outb(ADMUX, (inb(ADMUX) & ~7) | (ch & 7));   // set channel
    4222:	80 91 7c 00 	lds	r24, 0x007C
    4226:	97 70       	andi	r25, 0x07	; 7
    4228:	88 7f       	andi	r24, 0xF8	; 248
    422a:	89 2b       	or	r24, r25
    422c:	80 93 7c 00 	sts	0x007C, r24

	//outb(ADMUX, (inb(ADMUX) & ~ADC_MUX_MASK) | (ch & ADC_MUX_MASK));	// set channel
	sbi(ADCSR, ADIF);						// clear hardware "conversion complete" flag 
    4230:	80 91 7a 00 	lds	r24, 0x007A
    4234:	80 61       	ori	r24, 0x10	; 16
    4236:	80 93 7a 00 	sts	0x007A, r24
	sbi(ADCSR, ADSC);						// start conversion
    423a:	80 91 7a 00 	lds	r24, 0x007A
    423e:	80 64       	ori	r24, 0x40	; 64
    4240:	80 93 7a 00 	sts	0x007A, r24
	//while(!a2dCompleteFlag);				// wait until conversion complete
	//while( bit_is_clear(ADCSR, ADIF) );		// wait until conversion complete
	while( bit_is_set(ADCSR, ADSC) );		// wait until conversion complete
    4244:	80 91 7a 00 	lds	r24, 0x007A
    4248:	86 fd       	sbrc	r24, 6
    424a:	fc cf       	rjmp	.-8      	; 0x4244 <a2dConvert10bit+0x3e>

	// CAUTION: MUST READ ADCL BEFORE ADCH!!!
	//return (inb(ADCL) | (inb(ADCH)<<8));	// read ADC (full 10 bits) //old version
	return ADC;//new version code
    424c:	20 91 78 00 	lds	r18, 0x0078
    4250:	30 91 79 00 	lds	r19, 0x0079
}
    4254:	c9 01       	movw	r24, r18
    4256:	08 95       	ret

00004258 <a2dConvert8bit>:
// Perform a 8-bit conversion.
// starts conversion, waits until conversion is done, and returns result
unsigned char a2dConvert8bit(unsigned char ch)
{
	// do 10-bit conversion and return highest 8 bits
	return a2dConvert10bit(ch)>>2;			// return ADC MSB byte
    4258:	0e 94 03 21 	call	0x4206	; 0x4206 <a2dConvert10bit>
    425c:	96 95       	lsr	r25
    425e:	87 95       	ror	r24
    4260:	96 95       	lsr	r25
    4262:	87 95       	ror	r24
}
    4264:	08 95       	ret

00004266 <__vector_29>:

//! Interrupt handler for ADC complete interrupt.
SIGNAL(SIG_ADC)
{
    4266:	1f 92       	push	r1
    4268:	0f 92       	push	r0
    426a:	0f b6       	in	r0, 0x3f	; 63
    426c:	0f 92       	push	r0
    426e:	11 24       	eor	r1, r1
    4270:	8f 93       	push	r24
	// set the a2d conversion flag to indicate "complete"
	a2dCompleteFlag = TRUE;
    4272:	8f ef       	ldi	r24, 0xFF	; 255
    4274:	80 93 2a 13 	sts	0x132A, r24
}
    4278:	8f 91       	pop	r24
    427a:	0f 90       	pop	r0
    427c:	0f be       	out	0x3f, r0	; 63
    427e:	0f 90       	pop	r0
    4280:	1f 90       	pop	r1
    4282:	18 95       	reti

00004284 <rprintfInit>:
// *** rprintf initialization ***
// you must call this function once and supply the character output
// routine before using other functions in this library
void rprintfInit(void (*putchar_func)(unsigned char c))
{
	rputchar = putchar_func;
    4284:	90 93 67 11 	sts	0x1167, r25
    4288:	80 93 66 11 	sts	0x1166, r24
}
    428c:	08 95       	ret

0000428e <rprintfChar>:

// *** rprintfChar ***
// send a character/byte to the current output device
void rprintfChar(unsigned char c)
{
    428e:	1f 93       	push	r17
    4290:	18 2f       	mov	r17, r24
	// do LF -> CR/LF translation
	if(c == '\n')
    4292:	8a 30       	cpi	r24, 0x0A	; 10
    4294:	31 f4       	brne	.+12     	; 0x42a2 <rprintfChar+0x14>
		rputchar('\r');
    4296:	e0 91 66 11 	lds	r30, 0x1166
    429a:	f0 91 67 11 	lds	r31, 0x1167
    429e:	8d e0       	ldi	r24, 0x0D	; 13
    42a0:	09 95       	icall
	// send character
	rputchar(c);
    42a2:	e0 91 66 11 	lds	r30, 0x1166
    42a6:	f0 91 67 11 	lds	r31, 0x1167
    42aa:	81 2f       	mov	r24, r17
    42ac:	09 95       	icall
}
    42ae:	1f 91       	pop	r17
    42b0:	08 95       	ret

000042b2 <rprintfStr>:

// *** rprintfStr ***
// prints a null-terminated string stored in RAM
void rprintfStr(char str[])
{
    42b2:	cf 93       	push	r28
    42b4:	df 93       	push	r29
    42b6:	ec 01       	movw	r28, r24
	// send a string stored in RAM
	// check to make sure we have a good pointer
	if (!str) return;
    42b8:	00 97       	sbiw	r24, 0x00	; 0
    42ba:	21 f4       	brne	.+8      	; 0x42c4 <rprintfStr+0x12>
    42bc:	06 c0       	rjmp	.+12     	; 0x42ca <rprintfStr+0x18>

	// print the string until a null-terminator
	while (*str)
		rprintfChar(*str++);
    42be:	21 96       	adiw	r28, 0x01	; 1
    42c0:	0e 94 47 21 	call	0x428e	; 0x428e <rprintfChar>
	// send a string stored in RAM
	// check to make sure we have a good pointer
	if (!str) return;

	// print the string until a null-terminator
	while (*str)
    42c4:	88 81       	ld	r24, Y
    42c6:	88 23       	and	r24, r24
    42c8:	d1 f7       	brne	.-12     	; 0x42be <rprintfStr+0xc>
		rprintfChar(*str++);
}
    42ca:	df 91       	pop	r29
    42cc:	cf 91       	pop	r28
    42ce:	08 95       	ret

000042d0 <rprintfStrLen>:
// *** rprintfStrLen ***
// prints a section of a string stored in RAM
// begins printing at position indicated by <start>
// prints number of characters indicated by <len>
void rprintfStrLen(char str[], unsigned int start, unsigned int len)
{
    42d0:	ef 92       	push	r14
    42d2:	ff 92       	push	r15
    42d4:	0f 93       	push	r16
    42d6:	1f 93       	push	r17
    42d8:	cf 93       	push	r28
    42da:	df 93       	push	r29
    42dc:	8c 01       	movw	r16, r24
    42de:	7a 01       	movw	r14, r20
	register int i=0;

	// check to make sure we have a good pointer
	if (!str) return;
    42e0:	00 97       	sbiw	r24, 0x00	; 0
    42e2:	e9 f0       	breq	.+58     	; 0x431e <rprintfStrLen+0x4e>
    42e4:	20 e0       	ldi	r18, 0x00	; 0
    42e6:	30 e0       	ldi	r19, 0x00	; 0
	// spin through characters up to requested start
	// keep going as long as there's no null
	while((i++<start) && (*str++));
    42e8:	26 17       	cp	r18, r22
    42ea:	37 07       	cpc	r19, r23
    42ec:	38 f4       	brcc	.+14     	; 0x42fc <rprintfStrLen+0x2c>
    42ee:	f8 01       	movw	r30, r16
    42f0:	81 91       	ld	r24, Z+
    42f2:	8f 01       	movw	r16, r30
    42f4:	2f 5f       	subi	r18, 0xFF	; 255
    42f6:	3f 4f       	sbci	r19, 0xFF	; 255
    42f8:	88 23       	and	r24, r24
    42fa:	b1 f7       	brne	.-20     	; 0x42e8 <rprintfStrLen+0x18>
    42fc:	c0 e0       	ldi	r28, 0x00	; 0
    42fe:	d0 e0       	ldi	r29, 0x00	; 0
    4300:	0b c0       	rjmp	.+22     	; 0x4318 <rprintfStrLen+0x48>
	// then print exactly len characters
	for(i=0; i<len; i++)
	{
		// print data out of the string as long as we haven't reached a null yet
		// at the null, start printing spaces
		if(*str)
    4302:	f8 01       	movw	r30, r16
    4304:	80 81       	ld	r24, Z
    4306:	88 23       	and	r24, r24
    4308:	19 f0       	breq	.+6      	; 0x4310 <rprintfStrLen+0x40>
			rprintfChar(*str++);
    430a:	0f 5f       	subi	r16, 0xFF	; 255
    430c:	1f 4f       	sbci	r17, 0xFF	; 255
    430e:	01 c0       	rjmp	.+2      	; 0x4312 <rprintfStrLen+0x42>
		else
			rprintfChar(' ');
    4310:	80 e2       	ldi	r24, 0x20	; 32
    4312:	0e 94 47 21 	call	0x428e	; 0x428e <rprintfChar>
//		// keep steping through string as long as there's no null
//		if(*str) str++;
//	}

	// then print exactly len characters
	for(i=0; i<len; i++)
    4316:	21 96       	adiw	r28, 0x01	; 1
    4318:	ce 15       	cp	r28, r14
    431a:	df 05       	cpc	r29, r15
    431c:	90 f3       	brcs	.-28     	; 0x4302 <rprintfStrLen+0x32>
			rprintfChar(*str++);
		else
			rprintfChar(' ');
	}

}
    431e:	df 91       	pop	r29
    4320:	cf 91       	pop	r28
    4322:	1f 91       	pop	r17
    4324:	0f 91       	pop	r16
    4326:	ff 90       	pop	r15
    4328:	ef 90       	pop	r14
    432a:	08 95       	ret

0000432c <rprintfProgStr>:

// *** rprintfProgStr ***
// prints a null-terminated string stored in program ROM
void rprintfProgStr(const prog_char str[])
{
    432c:	cf 93       	push	r28
    432e:	df 93       	push	r29
    4330:	ec 01       	movw	r28, r24
	// print a string stored in program memory
	register char c;

	// check to make sure we have a good pointer
	if (!str) return;
    4332:	00 97       	sbiw	r24, 0x00	; 0
    4334:	19 f4       	brne	.+6      	; 0x433c <rprintfProgStr+0x10>
    4336:	07 c0       	rjmp	.+14     	; 0x4346 <rprintfProgStr+0x1a>
	
	// print the string until the null-terminator
	while((c = pgm_read_byte(str++)))
		rprintfChar(c);
    4338:	0e 94 47 21 	call	0x428e	; 0x428e <rprintfChar>
    433c:	fe 01       	movw	r30, r28

	// check to make sure we have a good pointer
	if (!str) return;
	
	// print the string until the null-terminator
	while((c = pgm_read_byte(str++)))
    433e:	21 96       	adiw	r28, 0x01	; 1
    4340:	84 91       	lpm	r24, Z+
    4342:	88 23       	and	r24, r24
    4344:	c9 f7       	brne	.-14     	; 0x4338 <rprintfProgStr+0xc>
		rprintfChar(c);
}
    4346:	df 91       	pop	r29
    4348:	cf 91       	pop	r28
    434a:	08 95       	ret

0000434c <rprintfCRLF>:
void rprintfCRLF(void)
{
	// print CR/LF
	//rprintfChar('\r');
	// LF -> CR/LF translation built-in to rprintfChar()
	rprintfChar('\n');
    434c:	8a e0       	ldi	r24, 0x0A	; 10
    434e:	0e 94 47 21 	call	0x428e	; 0x428e <rprintfChar>
}
    4352:	08 95       	ret

00004354 <rprintfu04>:
//	char Character = data&0x0f;
//	if (Character>9)
//		Character+='A'-10;
//	else
//		Character+='0';
	rprintfChar(hexchar(data));
    4354:	e8 2f       	mov	r30, r24
    4356:	f0 e0       	ldi	r31, 0x00	; 0
    4358:	ef 70       	andi	r30, 0x0F	; 15
    435a:	f0 70       	andi	r31, 0x00	; 0
    435c:	e5 54       	subi	r30, 0x45	; 69
    435e:	fe 4f       	sbci	r31, 0xFE	; 254
    4360:	e4 91       	lpm	r30, Z+
    4362:	8e 2f       	mov	r24, r30
    4364:	0e 94 47 21 	call	0x428e	; 0x428e <rprintfChar>
}
    4368:	08 95       	ret

0000436a <rprintfu08>:

// *** rprintfu08 ***
// prints an unsigned 8-bit number in hex (2 digits)
void rprintfu08(unsigned char data)
{
    436a:	1f 93       	push	r17
    436c:	18 2f       	mov	r17, r24
	// print 8-bit hex value
	rprintfu04(data>>4);
    436e:	82 95       	swap	r24
    4370:	8f 70       	andi	r24, 0x0F	; 15
    4372:	0e 94 aa 21 	call	0x4354	; 0x4354 <rprintfu04>
	rprintfu04(data);
    4376:	81 2f       	mov	r24, r17
    4378:	0e 94 aa 21 	call	0x4354	; 0x4354 <rprintfu04>
}
    437c:	1f 91       	pop	r17
    437e:	08 95       	ret

00004380 <rprintfu16>:

// *** rprintfu16 ***
// prints an unsigned 16-bit number in hex (4 digits)
void rprintfu16(unsigned short data)
{
    4380:	1f 93       	push	r17
    4382:	18 2f       	mov	r17, r24
	// print 16-bit hex value
	rprintfu08(data>>8);
    4384:	89 2f       	mov	r24, r25
    4386:	0e 94 b5 21 	call	0x436a	; 0x436a <rprintfu08>
	rprintfu08(data);
    438a:	81 2f       	mov	r24, r17
    438c:	0e 94 b5 21 	call	0x436a	; 0x436a <rprintfu08>
}
    4390:	1f 91       	pop	r17
    4392:	08 95       	ret

00004394 <rprintfu32>:

// *** rprintfu32 ***
// prints an unsigned 32-bit number in hex (8 digits)
void rprintfu32(unsigned long data)
{
    4394:	ef 92       	push	r14
    4396:	ff 92       	push	r15
    4398:	0f 93       	push	r16
    439a:	1f 93       	push	r17
    439c:	7b 01       	movw	r14, r22
    439e:	8c 01       	movw	r16, r24
	// print 32-bit hex value
	rprintfu16(data>>16);
    43a0:	c8 01       	movw	r24, r16
    43a2:	aa 27       	eor	r26, r26
    43a4:	bb 27       	eor	r27, r27
    43a6:	0e 94 c0 21 	call	0x4380	; 0x4380 <rprintfu16>
	rprintfu16(data);
    43aa:	c7 01       	movw	r24, r14
    43ac:	0e 94 c0 21 	call	0x4380	; 0x4380 <rprintfu16>
}
    43b0:	1f 91       	pop	r17
    43b2:	0f 91       	pop	r16
    43b4:	ff 90       	pop	r15
    43b6:	ef 90       	pop	r14
    43b8:	08 95       	ret

000043ba <rprintfNum>:
//	Examples:
//	uartPrintfNum(10, 6,  TRUE, ' ',   1234);  -->  " +1234"
//	uartPrintfNum(10, 6, FALSE, '0',   1234);  -->  "001234"
//	uartPrintfNum(16, 6, FALSE, '.', 0x5AA5);  -->  "..5AA5"
void rprintfNum(char base, char numDigits, char isSigned, char padchar, long n)
{
    43ba:	2f 92       	push	r2
    43bc:	3f 92       	push	r3
    43be:	4f 92       	push	r4
    43c0:	5f 92       	push	r5
    43c2:	6f 92       	push	r6
    43c4:	7f 92       	push	r7
    43c6:	8f 92       	push	r8
    43c8:	9f 92       	push	r9
    43ca:	af 92       	push	r10
    43cc:	bf 92       	push	r11
    43ce:	cf 92       	push	r12
    43d0:	df 92       	push	r13
    43d2:	ef 92       	push	r14
    43d4:	ff 92       	push	r15
    43d6:	0f 93       	push	r16
    43d8:	1f 93       	push	r17
    43da:	df 93       	push	r29
    43dc:	cf 93       	push	r28
    43de:	cd b7       	in	r28, 0x3d	; 61
    43e0:	de b7       	in	r29, 0x3e	; 62
    43e2:	a3 97       	sbiw	r28, 0x23	; 35
    43e4:	0f b6       	in	r0, 0x3f	; 63
    43e6:	f8 94       	cli
    43e8:	de bf       	out	0x3e, r29	; 62
    43ea:	0f be       	out	0x3f, r0	; 63
    43ec:	cd bf       	out	0x3d, r28	; 61
    43ee:	6a a3       	std	Y+34, r22	; 0x22
    43f0:	24 2e       	mov	r2, r20
    43f2:	2b a3       	std	Y+35, r18	; 0x23
    43f4:	37 01       	movw	r6, r14
    43f6:	48 01       	movw	r8, r16
	char *p, buf[32];
	unsigned long x;
	unsigned char count;

	// prepare negative number
	if( isSigned && (n < 0) )
    43f8:	44 23       	and	r20, r20
    43fa:	51 f0       	breq	.+20     	; 0x4410 <rprintfNum+0x56>
    43fc:	17 ff       	sbrs	r17, 7
    43fe:	08 c0       	rjmp	.+16     	; 0x4410 <rprintfNum+0x56>
	{
		x = -n;
    4400:	ee 24       	eor	r14, r14
    4402:	ff 24       	eor	r15, r15
    4404:	87 01       	movw	r16, r14
    4406:	e6 18       	sub	r14, r6
    4408:	f7 08       	sbc	r15, r7
    440a:	08 09       	sbc	r16, r8
    440c:	19 09       	sbc	r17, r9
    440e:	02 c0       	rjmp	.+4      	; 0x4414 <rprintfNum+0x5a>
	}
	else
	{
	 	x = n;
    4410:	84 01       	movw	r16, r8
    4412:	73 01       	movw	r14, r6
	}

	// setup little string buffer
	count = (numDigits-1)-(isSigned?1:0);
    4414:	2a a1       	ldd	r18, Y+34	; 0x22
    4416:	21 50       	subi	r18, 0x01	; 1
    4418:	90 e0       	ldi	r25, 0x00	; 0
    441a:	21 10       	cpse	r2, r1
    441c:	91 e0       	ldi	r25, 0x01	; 1
    441e:	29 1b       	sub	r18, r25
    4420:	29 a3       	std	Y+33, r18	; 0x21
  	p = buf + sizeof (buf);
  	*--p = '\0';
    4422:	18 a2       	std	Y+32, r1	; 0x20
	
	// force calculation of first digit
	// (to prevent zero from not printing at all!!!)
	*--p = hexchar(x%base); x /= base;
    4424:	a8 2e       	mov	r10, r24
    4426:	bb 24       	eor	r11, r11
    4428:	cc 24       	eor	r12, r12
    442a:	dd 24       	eor	r13, r13
    442c:	c8 01       	movw	r24, r16
    442e:	b7 01       	movw	r22, r14
    4430:	a6 01       	movw	r20, r12
    4432:	95 01       	movw	r18, r10
    4434:	0e 94 dc 28 	call	0x51b8	; 0x51b8 <__udivmodsi4>
    4438:	fb 01       	movw	r30, r22
    443a:	ef 70       	andi	r30, 0x0F	; 15
    443c:	f0 70       	andi	r31, 0x00	; 0
    443e:	e5 54       	subi	r30, 0x45	; 69
    4440:	fe 4f       	sbci	r31, 0xFE	; 254
    4442:	64 91       	lpm	r22, Z+
    4444:	6f 8f       	std	Y+31, r22	; 0x1f
    4446:	c8 01       	movw	r24, r16
    4448:	b7 01       	movw	r22, r14
    444a:	a6 01       	movw	r20, r12
    444c:	95 01       	movw	r18, r10
    444e:	0e 94 dc 28 	call	0x51b8	; 0x51b8 <__udivmodsi4>
    4452:	c9 01       	movw	r24, r18
    4454:	da 01       	movw	r26, r20
    4456:	7c 01       	movw	r14, r24
    4458:	8d 01       	movw	r16, r26
    445a:	9e e1       	ldi	r25, 0x1E	; 30
    445c:	49 2e       	mov	r4, r25
    445e:	51 2c       	mov	r5, r1
    4460:	4c 0e       	add	r4, r28
    4462:	5d 1e       	adc	r5, r29
    4464:	39 a0       	ldd	r3, Y+33	; 0x21
    4466:	25 c0       	rjmp	.+74     	; 0x44b2 <rprintfNum+0xf8>
	// calculate remaining digits
	while(count--)
	{
		if(x != 0)
    4468:	e1 14       	cp	r14, r1
    446a:	f1 04       	cpc	r15, r1
    446c:	01 05       	cpc	r16, r1
    446e:	11 05       	cpc	r17, r1
    4470:	c9 f0       	breq	.+50     	; 0x44a4 <rprintfNum+0xea>
		{
			// calculate next digit
			*--p = hexchar(x%base); x /= base;
    4472:	c8 01       	movw	r24, r16
    4474:	b7 01       	movw	r22, r14
    4476:	a6 01       	movw	r20, r12
    4478:	95 01       	movw	r18, r10
    447a:	0e 94 dc 28 	call	0x51b8	; 0x51b8 <__udivmodsi4>
    447e:	fb 01       	movw	r30, r22
    4480:	ef 70       	andi	r30, 0x0F	; 15
    4482:	f0 70       	andi	r31, 0x00	; 0
    4484:	e5 54       	subi	r30, 0x45	; 69
    4486:	fe 4f       	sbci	r31, 0xFE	; 254
    4488:	64 91       	lpm	r22, Z+
    448a:	f2 01       	movw	r30, r4
    448c:	60 83       	st	Z, r22
    448e:	c8 01       	movw	r24, r16
    4490:	b7 01       	movw	r22, r14
    4492:	a6 01       	movw	r20, r12
    4494:	95 01       	movw	r18, r10
    4496:	0e 94 dc 28 	call	0x51b8	; 0x51b8 <__udivmodsi4>
    449a:	c9 01       	movw	r24, r18
    449c:	da 01       	movw	r26, r20
    449e:	7c 01       	movw	r14, r24
    44a0:	8d 01       	movw	r16, r26
    44a2:	03 c0       	rjmp	.+6      	; 0x44aa <rprintfNum+0xf0>
		}
		else
		{
			// no more digits left, pad out to desired length
			*--p = padchar;
    44a4:	2b a1       	ldd	r18, Y+35	; 0x23
    44a6:	f2 01       	movw	r30, r4
    44a8:	20 83       	st	Z, r18
    44aa:	3a 94       	dec	r3
    44ac:	08 94       	sec
    44ae:	41 08       	sbc	r4, r1
    44b0:	51 08       	sbc	r5, r1
	
	// force calculation of first digit
	// (to prevent zero from not printing at all!!!)
	*--p = hexchar(x%base); x /= base;
	// calculate remaining digits
	while(count--)
    44b2:	33 20       	and	r3, r3
    44b4:	c9 f6       	brne	.-78     	; 0x4468 <rprintfNum+0xae>
    44b6:	ce 01       	movw	r24, r28
    44b8:	4f 96       	adiw	r24, 0x1f	; 31
    44ba:	8c 01       	movw	r16, r24
    44bc:	e9 a1       	ldd	r30, Y+33	; 0x21
    44be:	0e 1b       	sub	r16, r30
    44c0:	11 09       	sbc	r17, r1
			*--p = padchar;
		}
	}

	// apply signed notation if requested
	if( isSigned )
    44c2:	22 20       	and	r2, r2
    44c4:	f1 f0       	breq	.+60     	; 0x4502 <rprintfNum+0x148>
	{
		if(n < 0)
    44c6:	97 fe       	sbrs	r9, 7
    44c8:	05 c0       	rjmp	.+10     	; 0x44d4 <rprintfNum+0x11a>
		{
   			*--p = '-';
    44ca:	8d e2       	ldi	r24, 0x2D	; 45
    44cc:	f8 01       	movw	r30, r16
    44ce:	82 93       	st	-Z, r24
    44d0:	8f 01       	movw	r16, r30
    44d2:	17 c0       	rjmp	.+46     	; 0x4502 <rprintfNum+0x148>
    44d4:	c8 01       	movw	r24, r16
    44d6:	01 97       	sbiw	r24, 0x01	; 1
		}
		else if(n > 0)
    44d8:	61 14       	cp	r6, r1
    44da:	71 04       	cpc	r7, r1
    44dc:	81 04       	cpc	r8, r1
    44de:	91 04       	cpc	r9, r1
    44e0:	19 f0       	breq	.+6      	; 0x44e8 <rprintfNum+0x12e>
		{
	   		*--p = '+';
    44e2:	8c 01       	movw	r16, r24
    44e4:	8b e2       	ldi	r24, 0x2B	; 43
    44e6:	02 c0       	rjmp	.+4      	; 0x44ec <rprintfNum+0x132>
		}
		else
		{
	   		*--p = ' ';
    44e8:	8c 01       	movw	r16, r24
    44ea:	80 e2       	ldi	r24, 0x20	; 32
    44ec:	f8 01       	movw	r30, r16
    44ee:	80 83       	st	Z, r24
    44f0:	08 c0       	rjmp	.+16     	; 0x4502 <rprintfNum+0x148>

	// print the string right-justified
	count = numDigits;
	while(count--)
	{
		rprintfChar(*p++);
    44f2:	f8 01       	movw	r30, r16
    44f4:	81 91       	ld	r24, Z+
    44f6:	8f 01       	movw	r16, r30
    44f8:	0e 94 47 21 	call	0x428e	; 0x428e <rprintfChar>
    44fc:	fa a1       	ldd	r31, Y+34	; 0x22
    44fe:	f1 50       	subi	r31, 0x01	; 1
    4500:	fa a3       	std	Y+34, r31	; 0x22
		}
	}

	// print the string right-justified
	count = numDigits;
	while(count--)
    4502:	2a a1       	ldd	r18, Y+34	; 0x22
    4504:	22 23       	and	r18, r18
    4506:	a9 f7       	brne	.-22     	; 0x44f2 <rprintfNum+0x138>
	{
		rprintfChar(*p++);
	}
}
    4508:	a3 96       	adiw	r28, 0x23	; 35
    450a:	0f b6       	in	r0, 0x3f	; 63
    450c:	f8 94       	cli
    450e:	de bf       	out	0x3e, r29	; 62
    4510:	0f be       	out	0x3f, r0	; 63
    4512:	cd bf       	out	0x3d, r28	; 61
    4514:	cf 91       	pop	r28
    4516:	df 91       	pop	r29
    4518:	1f 91       	pop	r17
    451a:	0f 91       	pop	r16
    451c:	ff 90       	pop	r15
    451e:	ef 90       	pop	r14
    4520:	df 90       	pop	r13
    4522:	cf 90       	pop	r12
    4524:	bf 90       	pop	r11
    4526:	af 90       	pop	r10
    4528:	9f 90       	pop	r9
    452a:	8f 90       	pop	r8
    452c:	7f 90       	pop	r7
    452e:	6f 90       	pop	r6
    4530:	5f 90       	pop	r5
    4532:	4f 90       	pop	r4
    4534:	3f 90       	pop	r3
    4536:	2f 90       	pop	r2
    4538:	08 95       	ret

0000453a <rprintfFloat>:

#ifdef RPRINTF_FLOAT
// *** rprintfFloat ***
// floating-point print
void rprintfFloat(char numDigits, double x)
{
    453a:	4f 92       	push	r4
    453c:	5f 92       	push	r5
    453e:	6f 92       	push	r6
    4540:	7f 92       	push	r7
    4542:	8f 92       	push	r8
    4544:	9f 92       	push	r9
    4546:	af 92       	push	r10
    4548:	bf 92       	push	r11
    454a:	cf 92       	push	r12
    454c:	df 92       	push	r13
    454e:	ef 92       	push	r14
    4550:	ff 92       	push	r15
    4552:	0f 93       	push	r16
    4554:	1f 93       	push	r17
    4556:	cf 93       	push	r28
    4558:	df 93       	push	r29
    455a:	48 2e       	mov	r4, r24
    455c:	5a 01       	movw	r10, r20
    455e:	6b 01       	movw	r12, r22
	double place = 1.0;
	
	// save sign
	negative = (x<0);
	// convert to absolute value
	x = (x>0)?(x):(-x);
    4560:	cb 01       	movw	r24, r22
    4562:	ba 01       	movw	r22, r20
    4564:	20 e0       	ldi	r18, 0x00	; 0
    4566:	30 e0       	ldi	r19, 0x00	; 0
    4568:	40 e0       	ldi	r20, 0x00	; 0
    456a:	50 e0       	ldi	r21, 0x00	; 0
    456c:	0e 94 4e 28 	call	0x509c	; 0x509c <__gesf2>
    4570:	18 16       	cp	r1, r24
    4572:	1c f4       	brge	.+6      	; 0x457a <rprintfFloat+0x40>
    4574:	35 01       	movw	r6, r10
    4576:	46 01       	movw	r8, r12
    4578:	06 c0       	rjmp	.+12     	; 0x4586 <rprintfFloat+0x4c>
    457a:	35 01       	movw	r6, r10
    457c:	46 01       	movw	r8, r12
    457e:	97 fa       	bst	r9, 7
    4580:	90 94       	com	r9
    4582:	97 f8       	bld	r9, 7
    4584:	90 94       	com	r9
    4586:	0f 2e       	mov	r0, r31
    4588:	f0 e0       	ldi	r31, 0x00	; 0
    458a:	ef 2e       	mov	r14, r31
    458c:	f0 e0       	ldi	r31, 0x00	; 0
    458e:	ff 2e       	mov	r15, r31
    4590:	f0 e8       	ldi	r31, 0x80	; 128
    4592:	0f 2f       	mov	r16, r31
    4594:	ff e3       	ldi	r31, 0x3F	; 63
    4596:	1f 2f       	mov	r17, r31
    4598:	f0 2d       	mov	r31, r0
    459a:	55 24       	eor	r5, r5
	
	// find starting digit place
	for(i=0; i<15; i++)
	{
		if((x/place) < 10.0)
    459c:	c4 01       	movw	r24, r8
    459e:	b3 01       	movw	r22, r6
    45a0:	a8 01       	movw	r20, r16
    45a2:	97 01       	movw	r18, r14
    45a4:	0e 94 08 27 	call	0x4e10	; 0x4e10 <__divsf3>
    45a8:	20 e0       	ldi	r18, 0x00	; 0
    45aa:	30 e0       	ldi	r19, 0x00	; 0
    45ac:	40 e2       	ldi	r20, 0x20	; 32
    45ae:	51 e4       	ldi	r21, 0x41	; 65
    45b0:	0e 94 04 27 	call	0x4e08	; 0x4e08 <__cmpsf2>
    45b4:	87 fd       	sbrc	r24, 7
    45b6:	0e c0       	rjmp	.+28     	; 0x45d4 <rprintfFloat+0x9a>
			break;
		else
			place *= 10.0;
    45b8:	c8 01       	movw	r24, r16
    45ba:	b7 01       	movw	r22, r14
    45bc:	20 e0       	ldi	r18, 0x00	; 0
    45be:	30 e0       	ldi	r19, 0x00	; 0
    45c0:	40 e2       	ldi	r20, 0x20	; 32
    45c2:	51 e4       	ldi	r21, 0x41	; 65
    45c4:	0e 94 52 28 	call	0x50a4	; 0x50a4 <__mulsf3>
    45c8:	7b 01       	movw	r14, r22
    45ca:	8c 01       	movw	r16, r24
	negative = (x<0);
	// convert to absolute value
	x = (x>0)?(x):(-x);
	
	// find starting digit place
	for(i=0; i<15; i++)
    45cc:	53 94       	inc	r5
    45ce:	8f e0       	ldi	r24, 0x0F	; 15
    45d0:	58 16       	cp	r5, r24
    45d2:	21 f7       	brne	.-56     	; 0x459c <rprintfFloat+0x62>
			break;
		else
			place *= 10.0;
	}
	// print polarity character
	if(negative)
    45d4:	c6 01       	movw	r24, r12
    45d6:	b5 01       	movw	r22, r10
    45d8:	20 e0       	ldi	r18, 0x00	; 0
    45da:	30 e0       	ldi	r19, 0x00	; 0
    45dc:	40 e0       	ldi	r20, 0x00	; 0
    45de:	50 e0       	ldi	r21, 0x00	; 0
    45e0:	0e 94 04 27 	call	0x4e08	; 0x4e08 <__cmpsf2>
    45e4:	88 23       	and	r24, r24
    45e6:	14 f4       	brge	.+4      	; 0x45ec <rprintfFloat+0xb2>
		rprintfChar('-');
    45e8:	8d e2       	ldi	r24, 0x2D	; 45
    45ea:	01 c0       	rjmp	.+2      	; 0x45ee <rprintfFloat+0xb4>
	else
		rprintfChar('+');
    45ec:	8b e2       	ldi	r24, 0x2B	; 43
    45ee:	0e 94 47 21 	call	0x428e	; 0x428e <rprintfChar>
    45f2:	dd 24       	eor	r13, r13
    45f4:	aa 24       	eor	r10, r10
    45f6:	56 c0       	rjmp	.+172    	; 0x46a4 <rprintfFloat+0x16a>

	// print digits
	for(i=0; i<numDigits; i++)
	{
		digit = (x/place);
    45f8:	c4 01       	movw	r24, r8
    45fa:	b3 01       	movw	r22, r6
    45fc:	a8 01       	movw	r20, r16
    45fe:	97 01       	movw	r18, r14
    4600:	0e 94 08 27 	call	0x4e10	; 0x4e10 <__divsf3>
    4604:	0e 94 70 27 	call	0x4ee0	; 0x4ee0 <__fixunssfsi>
    4608:	b6 2e       	mov	r11, r22

		if(digit | firstplace | (place == 1.0))
    460a:	d6 2a       	or	r13, r22
    460c:	cd 2d       	mov	r28, r13
    460e:	d0 e0       	ldi	r29, 0x00	; 0
    4610:	cc 24       	eor	r12, r12
    4612:	dd 24       	eor	r13, r13
    4614:	c8 01       	movw	r24, r16
    4616:	b7 01       	movw	r22, r14
    4618:	20 e0       	ldi	r18, 0x00	; 0
    461a:	30 e0       	ldi	r19, 0x00	; 0
    461c:	40 e8       	ldi	r20, 0x80	; 128
    461e:	5f e3       	ldi	r21, 0x3F	; 63
    4620:	0e 94 04 27 	call	0x4e08	; 0x4e08 <__cmpsf2>
    4624:	88 23       	and	r24, r24
    4626:	19 f4       	brne	.+6      	; 0x462e <rprintfFloat+0xf4>
    4628:	21 e0       	ldi	r18, 0x01	; 1
    462a:	c2 2e       	mov	r12, r18
    462c:	d1 2c       	mov	r13, r1
    462e:	cc 29       	or	r28, r12
    4630:	dd 29       	or	r29, r13
    4632:	cd 2b       	or	r28, r29
    4634:	39 f0       	breq	.+14     	; 0x4644 <rprintfFloat+0x10a>
		{
			firstplace = TRUE;
			rprintfChar(digit+0x30);
    4636:	8b 2d       	mov	r24, r11
    4638:	80 5d       	subi	r24, 0xD0	; 208
    463a:	0e 94 47 21 	call	0x428e	; 0x428e <rprintfChar>
    463e:	dd 24       	eor	r13, r13
    4640:	da 94       	dec	r13
    4642:	04 c0       	rjmp	.+8      	; 0x464c <rprintfFloat+0x112>
		}
		else
			rprintfChar(' ');
    4644:	80 e2       	ldi	r24, 0x20	; 32
    4646:	0e 94 47 21 	call	0x428e	; 0x428e <rprintfChar>
    464a:	dd 24       	eor	r13, r13
		
		if(place == 1.0)
    464c:	c8 01       	movw	r24, r16
    464e:	b7 01       	movw	r22, r14
    4650:	20 e0       	ldi	r18, 0x00	; 0
    4652:	30 e0       	ldi	r19, 0x00	; 0
    4654:	40 e8       	ldi	r20, 0x80	; 128
    4656:	5f e3       	ldi	r21, 0x3F	; 63
    4658:	0e 94 04 27 	call	0x4e08	; 0x4e08 <__cmpsf2>
    465c:	88 23       	and	r24, r24
    465e:	19 f4       	brne	.+6      	; 0x4666 <rprintfFloat+0x12c>
		{
			rprintfChar('.');
    4660:	8e e2       	ldi	r24, 0x2E	; 46
    4662:	0e 94 47 21 	call	0x428e	; 0x428e <rprintfChar>
		}
		
		x -= (digit*place);
    4666:	6b 2d       	mov	r22, r11
    4668:	70 e0       	ldi	r23, 0x00	; 0
    466a:	88 27       	eor	r24, r24
    466c:	77 fd       	sbrc	r23, 7
    466e:	80 95       	com	r24
    4670:	98 2f       	mov	r25, r24
    4672:	0e 94 9e 27 	call	0x4f3c	; 0x4f3c <__floatsisf>
    4676:	a8 01       	movw	r20, r16
    4678:	97 01       	movw	r18, r14
    467a:	0e 94 52 28 	call	0x50a4	; 0x50a4 <__mulsf3>
    467e:	9b 01       	movw	r18, r22
    4680:	ac 01       	movw	r20, r24
    4682:	c4 01       	movw	r24, r8
    4684:	b3 01       	movw	r22, r6
    4686:	0e 94 9f 26 	call	0x4d3e	; 0x4d3e <__subsf3>
    468a:	3b 01       	movw	r6, r22
    468c:	4c 01       	movw	r8, r24
		place /= 10.0;
    468e:	c8 01       	movw	r24, r16
    4690:	b7 01       	movw	r22, r14
    4692:	20 e0       	ldi	r18, 0x00	; 0
    4694:	30 e0       	ldi	r19, 0x00	; 0
    4696:	40 e2       	ldi	r20, 0x20	; 32
    4698:	51 e4       	ldi	r21, 0x41	; 65
    469a:	0e 94 08 27 	call	0x4e10	; 0x4e10 <__divsf3>
    469e:	7b 01       	movw	r14, r22
    46a0:	8c 01       	movw	r16, r24
		rprintfChar('-');
	else
		rprintfChar('+');

	// print digits
	for(i=0; i<numDigits; i++)
    46a2:	a3 94       	inc	r10
    46a4:	a4 14       	cp	r10, r4
    46a6:	08 f4       	brcc	.+2      	; 0x46aa <rprintfFloat+0x170>
    46a8:	a7 cf       	rjmp	.-178    	; 0x45f8 <rprintfFloat+0xbe>
		}
		
		x -= (digit*place);
		place /= 10.0;
	}
}
    46aa:	df 91       	pop	r29
    46ac:	cf 91       	pop	r28
    46ae:	1f 91       	pop	r17
    46b0:	0f 91       	pop	r16
    46b2:	ff 90       	pop	r15
    46b4:	ef 90       	pop	r14
    46b6:	df 90       	pop	r13
    46b8:	cf 90       	pop	r12
    46ba:	bf 90       	pop	r11
    46bc:	af 90       	pop	r10
    46be:	9f 90       	pop	r9
    46c0:	8f 90       	pop	r8
    46c2:	7f 90       	pop	r7
    46c4:	6f 90       	pop	r6
    46c6:	5f 90       	pop	r5
    46c8:	4f 90       	pop	r4
    46ca:	08 95       	ret

000046cc <rprintf1RamRom>:
// Supports:
// %d - decimal
// %x - hex
// %c - character
int rprintf1RamRom(unsigned char stringInRom, const char *format, ...)
{
    46cc:	7f 92       	push	r7
    46ce:	8f 92       	push	r8
    46d0:	9f 92       	push	r9
    46d2:	af 92       	push	r10
    46d4:	bf 92       	push	r11
    46d6:	cf 92       	push	r12
    46d8:	df 92       	push	r13
    46da:	ef 92       	push	r14
    46dc:	ff 92       	push	r15
    46de:	0f 93       	push	r16
    46e0:	1f 93       	push	r17
    46e2:	df 93       	push	r29
    46e4:	cf 93       	push	r28
    46e6:	cd b7       	in	r28, 0x3d	; 61
    46e8:	de b7       	in	r29, 0x3e	; 62
    46ea:	78 88       	ldd	r7, Y+16	; 0x10
    46ec:	c9 88       	ldd	r12, Y+17	; 0x11
    46ee:	da 88       	ldd	r13, Y+18	; 0x12
    46f0:	63 e1       	ldi	r22, 0x13	; 19
    46f2:	e6 2e       	mov	r14, r22
    46f4:	f1 2c       	mov	r15, r1
    46f6:	ec 0e       	add	r14, r28
    46f8:	fd 1e       	adc	r15, r29
    46fa:	14 c0       	rjmp	.+40     	; 0x4724 <rprintf1RamRom+0x58>
	va_start(ap, format);
	for (;;)
	{
		while ((format_flag = READMEMBYTE(stringInRom,format++) ) != '%')
		{	// Until '%' or '\0'
			if (!format_flag)
    46fc:	88 23       	and	r24, r24
    46fe:	81 f4       	brne	.+32     	; 0x4720 <rprintf1RamRom+0x54>
				div_val /= base;
			} while (div_val);
		}
	}
	va_end(ap);
}
    4700:	80 e0       	ldi	r24, 0x00	; 0
    4702:	90 e0       	ldi	r25, 0x00	; 0
    4704:	cf 91       	pop	r28
    4706:	df 91       	pop	r29
    4708:	1f 91       	pop	r17
    470a:	0f 91       	pop	r16
    470c:	ff 90       	pop	r15
    470e:	ef 90       	pop	r14
    4710:	df 90       	pop	r13
    4712:	cf 90       	pop	r12
    4714:	bf 90       	pop	r11
    4716:	af 90       	pop	r10
    4718:	9f 90       	pop	r9
    471a:	8f 90       	pop	r8
    471c:	7f 90       	pop	r7
    471e:	08 95       	ret
			if (!format_flag)
			{
				va_end(ap);
				return(0);
			}
			rprintfChar(format_flag);
    4720:	0e 94 47 21 	call	0x428e	; 0x428e <rprintfChar>
    4724:	96 01       	movw	r18, r12
    4726:	2f 5f       	subi	r18, 0xFF	; 255
    4728:	3f 4f       	sbci	r19, 0xFF	; 255
	va_list ap;

	va_start(ap, format);
	for (;;)
	{
		while ((format_flag = READMEMBYTE(stringInRom,format++) ) != '%')
    472a:	77 20       	and	r7, r7
    472c:	21 f0       	breq	.+8      	; 0x4736 <rprintf1RamRom+0x6a>
    472e:	f6 01       	movw	r30, r12
    4730:	69 01       	movw	r12, r18
    4732:	84 91       	lpm	r24, Z+
    4734:	03 c0       	rjmp	.+6      	; 0x473c <rprintf1RamRom+0x70>
    4736:	f6 01       	movw	r30, r12
    4738:	80 81       	ld	r24, Z
    473a:	69 01       	movw	r12, r18
    473c:	85 32       	cpi	r24, 0x25	; 37
    473e:	f1 f6       	brne	.-68     	; 0x46fc <rprintf1RamRom+0x30>
    4740:	2f 5f       	subi	r18, 0xFF	; 255
    4742:	3f 4f       	sbci	r19, 0xFF	; 255
				return(0);
			}
			rprintfChar(format_flag);
		}

		switch (format_flag = READMEMBYTE(stringInRom,format++) )
    4744:	77 20       	and	r7, r7
    4746:	21 f0       	breq	.+8      	; 0x4750 <rprintf1RamRom+0x84>
    4748:	f6 01       	movw	r30, r12
    474a:	69 01       	movw	r12, r18
    474c:	84 91       	lpm	r24, Z+
    474e:	03 c0       	rjmp	.+6      	; 0x4756 <rprintf1RamRom+0x8a>
    4750:	f6 01       	movw	r30, r12
    4752:	80 81       	ld	r24, Z
    4754:	69 01       	movw	r12, r18
    4756:	84 36       	cpi	r24, 0x64	; 100
    4758:	29 f0       	breq	.+10     	; 0x4764 <rprintf1RamRom+0x98>
    475a:	88 37       	cpi	r24, 0x78	; 120
    475c:	81 f0       	breq	.+32     	; 0x477e <rprintf1RamRom+0xb2>
    475e:	83 36       	cpi	r24, 0x63	; 99
    4760:	f9 f6       	brne	.-66     	; 0x4720 <rprintf1RamRom+0x54>
    4762:	06 c0       	rjmp	.+12     	; 0x4770 <rprintf1RamRom+0xa4>
    4764:	00 e1       	ldi	r16, 0x10	; 16
    4766:	17 e2       	ldi	r17, 0x27	; 39
    4768:	5a e0       	ldi	r21, 0x0A	; 10
    476a:	a5 2e       	mov	r10, r21
    476c:	b1 2c       	mov	r11, r1
    476e:	0c c0       	rjmp	.+24     	; 0x4788 <rprintf1RamRom+0xbc>
		{
			case 'c': format_flag = va_arg(ap,int);
    4770:	f7 01       	movw	r30, r14
    4772:	80 81       	ld	r24, Z
    4774:	22 e0       	ldi	r18, 0x02	; 2
    4776:	30 e0       	ldi	r19, 0x00	; 0
    4778:	e2 0e       	add	r14, r18
    477a:	f3 1e       	adc	r15, r19
    477c:	d1 cf       	rjmp	.-94     	; 0x4720 <rprintf1RamRom+0x54>
			default:  rprintfChar(format_flag); continue;
    477e:	00 e0       	ldi	r16, 0x00	; 0
    4780:	10 e1       	ldi	r17, 0x10	; 16
    4782:	40 e1       	ldi	r20, 0x10	; 16
    4784:	a4 2e       	mov	r10, r20
    4786:	b1 2c       	mov	r11, r1
			case 'd': base = 10; div_val = 10000; goto CONVERSION_LOOP;
//			case 'x': base = 16; div_val = 0x10;
			case 'x': base = 16; div_val = 0x1000;

			CONVERSION_LOOP:
			u_val = va_arg(ap,int);
    4788:	32 e0       	ldi	r19, 0x02	; 2
    478a:	83 2e       	mov	r8, r19
    478c:	91 2c       	mov	r9, r1
    478e:	8e 0c       	add	r8, r14
    4790:	9f 1c       	adc	r9, r15
    4792:	f7 01       	movw	r30, r14
    4794:	e0 80       	ld	r14, Z
    4796:	f1 80       	ldd	r15, Z+1	; 0x01
			if (format_flag == 'd')
    4798:	84 36       	cpi	r24, 0x64	; 100
    479a:	b1 f4       	brne	.+44     	; 0x47c8 <rprintf1RamRom+0xfc>
			{
				if (((int)u_val) < 0)
    479c:	f7 fe       	sbrs	r15, 7
    479e:	11 c0       	rjmp	.+34     	; 0x47c2 <rprintf1RamRom+0xf6>
				{
					u_val = - u_val;
    47a0:	f0 94       	com	r15
    47a2:	e1 94       	neg	r14
    47a4:	f1 08       	sbc	r15, r1
    47a6:	f3 94       	inc	r15
					rprintfChar('-');
    47a8:	8d e2       	ldi	r24, 0x2D	; 45
    47aa:	0e 94 47 21 	call	0x428e	; 0x428e <rprintfChar>
    47ae:	09 c0       	rjmp	.+18     	; 0x47c2 <rprintf1RamRom+0xf6>
				}
				while (div_val > 1 && div_val > u_val) div_val /= 10;
    47b0:	c8 01       	movw	r24, r16
    47b2:	6a e0       	ldi	r22, 0x0A	; 10
    47b4:	70 e0       	ldi	r23, 0x00	; 0
    47b6:	0e 94 b5 28 	call	0x516a	; 0x516a <__udivmodhi4>
    47ba:	8b 01       	movw	r16, r22
    47bc:	62 30       	cpi	r22, 0x02	; 2
    47be:	71 05       	cpc	r23, r1
    47c0:	18 f0       	brcs	.+6      	; 0x47c8 <rprintf1RamRom+0xfc>
    47c2:	e0 16       	cp	r14, r16
    47c4:	f1 06       	cpc	r15, r17
    47c6:	a0 f3       	brcs	.-24     	; 0x47b0 <rprintf1RamRom+0xe4>
			}
			do
			{
				//rprintfChar(pgm_read_byte(HexChars+(u_val/div_val)));
				rprintfu04(u_val/div_val);
    47c8:	c7 01       	movw	r24, r14
    47ca:	b8 01       	movw	r22, r16
    47cc:	0e 94 b5 28 	call	0x516a	; 0x516a <__udivmodhi4>
    47d0:	86 2f       	mov	r24, r22
    47d2:	0e 94 aa 21 	call	0x4354	; 0x4354 <rprintfu04>
				u_val %= div_val;
    47d6:	c7 01       	movw	r24, r14
    47d8:	b8 01       	movw	r22, r16
    47da:	0e 94 b5 28 	call	0x516a	; 0x516a <__udivmodhi4>
    47de:	7c 01       	movw	r14, r24
				div_val /= base;
    47e0:	c8 01       	movw	r24, r16
    47e2:	b5 01       	movw	r22, r10
    47e4:	0e 94 b5 28 	call	0x516a	; 0x516a <__udivmodhi4>
    47e8:	8b 01       	movw	r16, r22
			} while (div_val);
    47ea:	61 15       	cp	r22, r1
    47ec:	71 05       	cpc	r23, r1
    47ee:	61 f7       	brne	.-40     	; 0x47c8 <rprintf1RamRom+0xfc>
    47f0:	74 01       	movw	r14, r8
    47f2:	98 cf       	rjmp	.-208    	; 0x4724 <rprintf1RamRom+0x58>

000047f4 <i2cSetBitrate>:
	// SCL freq = F_CPU/(16+2*TWBR))
	#ifdef TWPS0
		// for processors with additional bitrate division (mega128)
		// SCL freq = F_CPU/(16+2*TWBR*4^TWPS)
		// set TWPS to zero
		cbi(TWSR, TWPS0);
    47f4:	20 91 b9 00 	lds	r18, 0x00B9
    47f8:	2e 7f       	andi	r18, 0xFE	; 254
    47fa:	20 93 b9 00 	sts	0x00B9, r18
		cbi(TWSR, TWPS1);
    47fe:	20 91 b9 00 	lds	r18, 0x00B9
    4802:	2d 7f       	andi	r18, 0xFD	; 253
    4804:	20 93 b9 00 	sts	0x00B9, r18
	#endif
	// calculate bitrate division	
	bitrate_div = ((F_CPU/1000l)/bitrateKHz);
    4808:	9c 01       	movw	r18, r24
    480a:	40 e0       	ldi	r20, 0x00	; 0
    480c:	50 e0       	ldi	r21, 0x00	; 0
    480e:	60 e8       	ldi	r22, 0x80	; 128
    4810:	7e e3       	ldi	r23, 0x3E	; 62
    4812:	80 e0       	ldi	r24, 0x00	; 0
    4814:	90 e0       	ldi	r25, 0x00	; 0
    4816:	0e 94 fe 28 	call	0x51fc	; 0x51fc <__divmodsi4>
	if(bitrate_div >= 16)
    481a:	20 31       	cpi	r18, 0x10	; 16
    481c:	30 f0       	brcs	.+12     	; 0x482a <i2cSetBitrate+0x36>
		bitrate_div = (bitrate_div-16)/2;
    481e:	82 2f       	mov	r24, r18
    4820:	90 e0       	ldi	r25, 0x00	; 0
    4822:	40 97       	sbiw	r24, 0x10	; 16
    4824:	95 95       	asr	r25
    4826:	87 95       	ror	r24
    4828:	28 2f       	mov	r18, r24
	outb(TWBR, bitrate_div);
    482a:	20 93 b8 00 	sts	0x00B8, r18
}
    482e:	08 95       	ret

00004830 <i2cInit>:

// functions
void i2cInit(void)
{
	// set pull-up resistors on I2C bus pins
	sbi(PORTD, 0);	// i2c SCL on 640
    4830:	58 9a       	sbi	0x0b, 0	; 11
	sbi(PORTD, 1);	// i2c SDA on 640
    4832:	59 9a       	sbi	0x0b, 1	; 11

	// clear SlaveReceive and SlaveTransmit handler to null
	i2cSlaveReceive = 0;
    4834:	10 92 af 11 	sts	0x11AF, r1
    4838:	10 92 ae 11 	sts	0x11AE, r1
	i2cSlaveTransmit = 0;
    483c:	10 92 b1 11 	sts	0x11B1, r1
    4840:	10 92 b0 11 	sts	0x11B0, r1
	// set i2c bit rate to 100KHz
	i2cSetBitrate(100);
    4844:	84 e6       	ldi	r24, 0x64	; 100
    4846:	90 e0       	ldi	r25, 0x00	; 0
    4848:	0e 94 fa 23 	call	0x47f4	; 0x47f4 <i2cSetBitrate>
	// enable TWI (two-wire interface)
	sbi(TWCR, TWEN);
    484c:	ec eb       	ldi	r30, 0xBC	; 188
    484e:	f0 e0       	ldi	r31, 0x00	; 0
    4850:	80 81       	ld	r24, Z
    4852:	84 60       	ori	r24, 0x04	; 4
    4854:	80 83       	st	Z, r24
	// set state
	I2cState = I2C_IDLE;
    4856:	10 92 68 11 	sts	0x1168, r1
	// enable TWI interrupt and slave address ACK
	sbi(TWCR, TWIE);
    485a:	80 81       	ld	r24, Z
    485c:	81 60       	ori	r24, 0x01	; 1
    485e:	80 83       	st	Z, r24
	sbi(TWCR, TWEA);
    4860:	80 81       	ld	r24, Z
    4862:	80 64       	ori	r24, 0x40	; 64
    4864:	80 83       	st	Z, r24
	//outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
	// enable interrupts
	sei();
    4866:	78 94       	sei
}
    4868:	08 95       	ret

0000486a <i2cSetLocalDeviceAddr>:
}

void i2cSetLocalDeviceAddr(u08 deviceAddr, u08 genCallEn)
{
	// set local device address (used in slave mode only)
	outb(TWAR, ((deviceAddr&0xFE) | (genCallEn?1:0)) );
    486a:	90 e0       	ldi	r25, 0x00	; 0
    486c:	61 11       	cpse	r22, r1
    486e:	91 e0       	ldi	r25, 0x01	; 1
    4870:	8e 7f       	andi	r24, 0xFE	; 254
    4872:	98 2b       	or	r25, r24
    4874:	90 93 ba 00 	sts	0x00BA, r25
}
    4878:	08 95       	ret

0000487a <i2cSetSlaveReceiveHandler>:

void i2cSetSlaveReceiveHandler(void (*i2cSlaveRx_func)(u08 receiveDataLength, u08* recieveData))
{
	i2cSlaveReceive = i2cSlaveRx_func;
    487a:	90 93 af 11 	sts	0x11AF, r25
    487e:	80 93 ae 11 	sts	0x11AE, r24
}
    4882:	08 95       	ret

00004884 <i2cSetSlaveTransmitHandler>:

void i2cSetSlaveTransmitHandler(u08 (*i2cSlaveTx_func)(u08 transmitDataLengthMax, u08* transmitData))
{
	i2cSlaveTransmit = i2cSlaveTx_func;
    4884:	90 93 b1 11 	sts	0x11B1, r25
    4888:	80 93 b0 11 	sts	0x11B0, r24
}
    488c:	08 95       	ret

0000488e <i2cSendStart>:

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    488e:	ec eb       	ldi	r30, 0xBC	; 188
    4890:	f0 e0       	ldi	r31, 0x00	; 0
    4892:	80 81       	ld	r24, Z
    4894:	8f 70       	andi	r24, 0x0F	; 15
    4896:	80 6a       	ori	r24, 0xA0	; 160
    4898:	80 83       	st	Z, r24
}
    489a:	08 95       	ret

0000489c <i2cSendStop>:

inline void i2cSendStop(void)
{
	// transmit stop condition
	// leave with TWEA on for slave receiving
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA)|BV(TWSTO));
    489c:	ec eb       	ldi	r30, 0xBC	; 188
    489e:	f0 e0       	ldi	r31, 0x00	; 0
    48a0:	80 81       	ld	r24, Z
    48a2:	8f 70       	andi	r24, 0x0F	; 15
    48a4:	80 6d       	ori	r24, 0xD0	; 208
    48a6:	80 83       	st	Z, r24
}
    48a8:	08 95       	ret

000048aa <i2cWaitForComplete>:

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    48aa:	80 91 bc 00 	lds	r24, 0x00BC
    48ae:	87 ff       	sbrs	r24, 7
    48b0:	fc cf       	rjmp	.-8      	; 0x48aa <i2cWaitForComplete>
}
    48b2:	08 95       	ret

000048b4 <i2cSendByte>:

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    48b4:	80 93 bb 00 	sts	0x00BB, r24
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    48b8:	ec eb       	ldi	r30, 0xBC	; 188
    48ba:	f0 e0       	ldi	r31, 0x00	; 0
    48bc:	80 81       	ld	r24, Z
    48be:	8f 70       	andi	r24, 0x0F	; 15
    48c0:	80 68       	ori	r24, 0x80	; 128
    48c2:	80 83       	st	Z, r24
}
    48c4:	08 95       	ret

000048c6 <i2cReceiveByte>:

inline void i2cReceiveByte(u08 ackFlag)
{
	// begin receive over i2c
	if( ackFlag )
    48c6:	88 23       	and	r24, r24
    48c8:	29 f0       	breq	.+10     	; 0x48d4 <i2cReceiveByte+0xe>
	{
		// ackFlag = TRUE: ACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    48ca:	80 91 bc 00 	lds	r24, 0x00BC
    48ce:	8f 70       	andi	r24, 0x0F	; 15
    48d0:	80 6c       	ori	r24, 0xC0	; 192
    48d2:	04 c0       	rjmp	.+8      	; 0x48dc <i2cReceiveByte+0x16>
	}
	else
	{
		// ackFlag = FALSE: NACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    48d4:	80 91 bc 00 	lds	r24, 0x00BC
    48d8:	8f 70       	andi	r24, 0x0F	; 15
    48da:	80 68       	ori	r24, 0x80	; 128
    48dc:	80 93 bc 00 	sts	0x00BC, r24
    48e0:	08 95       	ret

000048e2 <i2cGetReceivedByte>:
}

inline u08 i2cGetReceivedByte(void)
{
	// retieve received data byte from i2c TWDR
	return( inb(TWDR) );
    48e2:	80 91 bb 00 	lds	r24, 0x00BB
}
    48e6:	08 95       	ret

000048e8 <i2cGetStatus>:

inline u08 i2cGetStatus(void)
{
	// retieve current i2c status from i2c TWSR
	return( inb(TWSR) );
    48e8:	80 91 b9 00 	lds	r24, 0x00B9
}
    48ec:	08 95       	ret

000048ee <i2cMasterSend>:

void i2cMasterSend(u08 deviceAddr, u08 length, u08* data)
{
    48ee:	98 2f       	mov	r25, r24
	u08 i;
	// wait for interface to be ready
	while(I2cState);
    48f0:	80 91 68 11 	lds	r24, 0x1168
    48f4:	88 23       	and	r24, r24
    48f6:	e1 f7       	brne	.-8      	; 0x48f0 <i2cMasterSend+0x2>
	// set state
	I2cState = I2C_MASTER_TX;
    48f8:	82 e0       	ldi	r24, 0x02	; 2
    48fa:	80 93 68 11 	sts	0x1168, r24
	// save data
	I2cDeviceAddrRW = (deviceAddr & 0xFE);	// RW cleared: write operation
    48fe:	9e 7f       	andi	r25, 0xFE	; 254
    4900:	90 93 69 11 	sts	0x1169, r25
    4904:	aa e6       	ldi	r26, 0x6A	; 106
    4906:	b1 e1       	ldi	r27, 0x11	; 17
    4908:	fa 01       	movw	r30, r20
    490a:	02 c0       	rjmp	.+4      	; 0x4910 <i2cMasterSend+0x22>
	for(i=0; i<length; i++)
		I2cSendData[i] = *data++;
    490c:	81 91       	ld	r24, Z+
    490e:	8d 93       	st	X+, r24
	while(I2cState);
	// set state
	I2cState = I2C_MASTER_TX;
	// save data
	I2cDeviceAddrRW = (deviceAddr & 0xFE);	// RW cleared: write operation
	for(i=0; i<length; i++)
    4910:	8e 2f       	mov	r24, r30
    4912:	84 1b       	sub	r24, r20
    4914:	86 17       	cp	r24, r22
    4916:	d0 f3       	brcs	.-12     	; 0x490c <i2cMasterSend+0x1e>
		I2cSendData[i] = *data++;
	I2cSendDataIndex = 0;
    4918:	10 92 8a 11 	sts	0x118A, r1
	I2cSendDataLength = length;
    491c:	60 93 8b 11 	sts	0x118B, r22
}

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    4920:	80 91 bc 00 	lds	r24, 0x00BC
    4924:	8f 70       	andi	r24, 0x0F	; 15
    4926:	80 6a       	ori	r24, 0xA0	; 160
    4928:	80 93 bc 00 	sts	0x00BC, r24
		I2cSendData[i] = *data++;
	I2cSendDataIndex = 0;
	I2cSendDataLength = length;
	// send start condition
	i2cSendStart();
}
    492c:	08 95       	ret

0000492e <i2cMasterReceive>:

void i2cMasterReceive(u08 deviceAddr, u08 length, u08* data)
{
    492e:	98 2f       	mov	r25, r24
	u08 i;
	// wait for interface to be ready
	while(I2cState);
    4930:	80 91 68 11 	lds	r24, 0x1168
    4934:	88 23       	and	r24, r24
    4936:	e1 f7       	brne	.-8      	; 0x4930 <i2cMasterReceive+0x2>
	// set state
	I2cState = I2C_MASTER_RX;
    4938:	83 e0       	ldi	r24, 0x03	; 3
    493a:	80 93 68 11 	sts	0x1168, r24
	// save data
	I2cDeviceAddrRW = (deviceAddr|0x01);	// RW set: read operation
    493e:	91 60       	ori	r25, 0x01	; 1
    4940:	90 93 69 11 	sts	0x1169, r25
	I2cReceiveDataIndex = 0;
    4944:	10 92 ac 11 	sts	0x11AC, r1
	I2cReceiveDataLength = length;
    4948:	60 93 ad 11 	sts	0x11AD, r22
}

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    494c:	80 91 bc 00 	lds	r24, 0x00BC
    4950:	8f 70       	andi	r24, 0x0F	; 15
    4952:	80 6a       	ori	r24, 0xA0	; 160
    4954:	80 93 bc 00 	sts	0x00BC, r24
	I2cReceiveDataIndex = 0;
	I2cReceiveDataLength = length;
	// send start condition
	i2cSendStart();
	// wait for data
	while(I2cState);
    4958:	80 91 68 11 	lds	r24, 0x1168
    495c:	88 23       	and	r24, r24
    495e:	e1 f7       	brne	.-8      	; 0x4958 <i2cMasterReceive+0x2a>
    4960:	ac e8       	ldi	r26, 0x8C	; 140
    4962:	b1 e1       	ldi	r27, 0x11	; 17
    4964:	fa 01       	movw	r30, r20
    4966:	02 c0       	rjmp	.+4      	; 0x496c <i2cMasterReceive+0x3e>
	// return data
	for(i=0; i<length; i++)
		*data++ = I2cReceiveData[i];
    4968:	8d 91       	ld	r24, X+
    496a:	81 93       	st	Z+, r24
	// send start condition
	i2cSendStart();
	// wait for data
	while(I2cState);
	// return data
	for(i=0; i<length; i++)
    496c:	8e 2f       	mov	r24, r30
    496e:	84 1b       	sub	r24, r20
    4970:	86 17       	cp	r24, r22
    4972:	d0 f3       	brcs	.-12     	; 0x4968 <i2cMasterReceive+0x3a>
		*data++ = I2cReceiveData[i];
}
    4974:	08 95       	ret

00004976 <i2cMasterSendNI>:

u08 i2cMasterSendNI(u08 deviceAddr, u08 length, u08* data)
{
    4976:	98 2f       	mov	r25, r24
    4978:	fa 01       	movw	r30, r20
	u08 retval = I2C_OK;

	// disable TWI interrupt
	cbi(TWCR, TWIE);
    497a:	80 91 bc 00 	lds	r24, 0x00BC
    497e:	8e 7f       	andi	r24, 0xFE	; 254
    4980:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    4984:	80 91 bc 00 	lds	r24, 0x00BC
    4988:	8f 70       	andi	r24, 0x0F	; 15
    498a:	80 6a       	ori	r24, 0xA0	; 160
    498c:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    4990:	80 91 bc 00 	lds	r24, 0x00BC
    4994:	87 ff       	sbrs	r24, 7
    4996:	fc cf       	rjmp	.-8      	; 0x4990 <i2cMasterSendNI+0x1a>
	// send start condition
	i2cSendStart();
	i2cWaitForComplete();

	// send device address with write
	i2cSendByte( deviceAddr & 0xFE );
    4998:	9e 7f       	andi	r25, 0xFE	; 254
}

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    499a:	90 93 bb 00 	sts	0x00BB, r25
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    499e:	80 91 bc 00 	lds	r24, 0x00BC
    49a2:	8f 70       	andi	r24, 0x0F	; 15
    49a4:	80 68       	ori	r24, 0x80	; 128
    49a6:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    49aa:	80 91 bc 00 	lds	r24, 0x00BC
    49ae:	87 ff       	sbrs	r24, 7
    49b0:	fc cf       	rjmp	.-8      	; 0x49aa <i2cMasterSendNI+0x34>
	// send device address with write
	i2cSendByte( deviceAddr & 0xFE );
	i2cWaitForComplete();

	// check if device is present and live
	if( inb(TWSR) == TW_MT_SLA_ACK)
    49b2:	80 91 b9 00 	lds	r24, 0x00B9
    49b6:	88 31       	cpi	r24, 0x18	; 24
    49b8:	89 f0       	breq	.+34     	; 0x49dc <i2cMasterSendNI+0x66>
    49ba:	91 e0       	ldi	r25, 0x01	; 1
    49bc:	12 c0       	rjmp	.+36     	; 0x49e2 <i2cMasterSendNI+0x6c>
	{
		// send data
		while(length)
		{
			i2cSendByte( *data++ );
    49be:	80 81       	ld	r24, Z
}

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    49c0:	80 93 bb 00 	sts	0x00BB, r24
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    49c4:	80 91 bc 00 	lds	r24, 0x00BC
    49c8:	8f 70       	andi	r24, 0x0F	; 15
    49ca:	80 68       	ori	r24, 0x80	; 128
    49cc:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    49d0:	80 91 bc 00 	lds	r24, 0x00BC
    49d4:	87 ff       	sbrs	r24, 7
    49d6:	fc cf       	rjmp	.-8      	; 0x49d0 <i2cMasterSendNI+0x5a>
	if( inb(TWSR) == TW_MT_SLA_ACK)
	{
		// send data
		while(length)
		{
			i2cSendByte( *data++ );
    49d8:	31 96       	adiw	r30, 0x01	; 1
			i2cWaitForComplete();
			length--;
    49da:	61 50       	subi	r22, 0x01	; 1

	// check if device is present and live
	if( inb(TWSR) == TW_MT_SLA_ACK)
	{
		// send data
		while(length)
    49dc:	66 23       	and	r22, r22
    49de:	79 f7       	brne	.-34     	; 0x49be <i2cMasterSendNI+0x48>
    49e0:	90 e0       	ldi	r25, 0x00	; 0

inline void i2cSendStop(void)
{
	// transmit stop condition
	// leave with TWEA on for slave receiving
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA)|BV(TWSTO));
    49e2:	80 91 bc 00 	lds	r24, 0x00BC
    49e6:	8f 70       	andi	r24, 0x0F	; 15
    49e8:	80 6d       	ori	r24, 0xD0	; 208
    49ea:	80 93 bc 00 	sts	0x00BC, r24
	}

	// transmit stop condition
	// leave with TWEA on for slave receiving
	i2cSendStop();
	while( !(inb(TWCR) & BV(TWSTO)) );
    49ee:	80 91 bc 00 	lds	r24, 0x00BC
    49f2:	84 ff       	sbrs	r24, 4
    49f4:	fc cf       	rjmp	.-8      	; 0x49ee <i2cMasterSendNI+0x78>

	// enable TWI interrupt
	sbi(TWCR, TWIE);
    49f6:	80 91 bc 00 	lds	r24, 0x00BC
    49fa:	81 60       	ori	r24, 0x01	; 1
    49fc:	80 93 bc 00 	sts	0x00BC, r24

	return retval;
}
    4a00:	89 2f       	mov	r24, r25
    4a02:	08 95       	ret

00004a04 <i2cMasterReceiveNI>:

u08 i2cMasterReceiveNI(u08 deviceAddr, u08 length, u08 *data)
{
    4a04:	98 2f       	mov	r25, r24
    4a06:	fa 01       	movw	r30, r20
	u08 retval = I2C_OK;

	// disable TWI interrupt
	cbi(TWCR, TWIE);
    4a08:	80 91 bc 00 	lds	r24, 0x00BC
    4a0c:	8e 7f       	andi	r24, 0xFE	; 254
    4a0e:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    4a12:	80 91 bc 00 	lds	r24, 0x00BC
    4a16:	8f 70       	andi	r24, 0x0F	; 15
    4a18:	80 6a       	ori	r24, 0xA0	; 160
    4a1a:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    4a1e:	80 91 bc 00 	lds	r24, 0x00BC
    4a22:	87 ff       	sbrs	r24, 7
    4a24:	fc cf       	rjmp	.-8      	; 0x4a1e <i2cMasterReceiveNI+0x1a>
	// send start condition
	i2cSendStart();
	i2cWaitForComplete();

	// send device address with read
	i2cSendByte( deviceAddr | 0x01 );
    4a26:	91 60       	ori	r25, 0x01	; 1
}

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    4a28:	90 93 bb 00 	sts	0x00BB, r25
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    4a2c:	80 91 bc 00 	lds	r24, 0x00BC
    4a30:	8f 70       	andi	r24, 0x0F	; 15
    4a32:	80 68       	ori	r24, 0x80	; 128
    4a34:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    4a38:	80 91 bc 00 	lds	r24, 0x00BC
    4a3c:	87 ff       	sbrs	r24, 7
    4a3e:	fc cf       	rjmp	.-8      	; 0x4a38 <i2cMasterReceiveNI+0x34>
	// send device address with read
	i2cSendByte( deviceAddr | 0x01 );
	i2cWaitForComplete();

	// check if device is present and live
	if( inb(TWSR) == TW_MR_SLA_ACK)
    4a40:	80 91 b9 00 	lds	r24, 0x00B9
    4a44:	80 34       	cpi	r24, 0x40	; 64
    4a46:	81 f0       	breq	.+32     	; 0x4a68 <i2cMasterReceiveNI+0x64>
    4a48:	91 e0       	ldi	r25, 0x01	; 1
    4a4a:	1e c0       	rjmp	.+60     	; 0x4a88 <i2cMasterReceiveNI+0x84>
{
	// begin receive over i2c
	if( ackFlag )
	{
		// ackFlag = TRUE: ACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    4a4c:	80 91 bc 00 	lds	r24, 0x00BC
    4a50:	8f 70       	andi	r24, 0x0F	; 15
    4a52:	80 6c       	ori	r24, 0xC0	; 192
    4a54:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    4a58:	80 91 bc 00 	lds	r24, 0x00BC
    4a5c:	87 ff       	sbrs	r24, 7
    4a5e:	fc cf       	rjmp	.-8      	; 0x4a58 <i2cMasterReceiveNI+0x54>
}

inline u08 i2cGetReceivedByte(void)
{
	// retieve received data byte from i2c TWDR
	return( inb(TWDR) );
    4a60:	80 91 bb 00 	lds	r24, 0x00BB
		// accept receive data and ack it
		while(length > 1)
		{
			i2cReceiveByte(TRUE);
			i2cWaitForComplete();
			*data++ = i2cGetReceivedByte();
    4a64:	81 93       	st	Z+, r24
			// decrement length
			length--;
    4a66:	61 50       	subi	r22, 0x01	; 1

	// check if device is present and live
	if( inb(TWSR) == TW_MR_SLA_ACK)
	{
		// accept receive data and ack it
		while(length > 1)
    4a68:	62 30       	cpi	r22, 0x02	; 2
    4a6a:	80 f7       	brcc	.-32     	; 0x4a4c <i2cMasterReceiveNI+0x48>
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
	}
	else
	{
		// ackFlag = FALSE: NACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    4a6c:	80 91 bc 00 	lds	r24, 0x00BC
    4a70:	8f 70       	andi	r24, 0x0F	; 15
    4a72:	80 68       	ori	r24, 0x80	; 128
    4a74:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    4a78:	80 91 bc 00 	lds	r24, 0x00BC
    4a7c:	87 ff       	sbrs	r24, 7
    4a7e:	fc cf       	rjmp	.-8      	; 0x4a78 <i2cMasterReceiveNI+0x74>
}

inline u08 i2cGetReceivedByte(void)
{
	// retieve received data byte from i2c TWDR
	return( inb(TWDR) );
    4a80:	80 91 bb 00 	lds	r24, 0x00BB
		}

		// accept receive data and nack it (last-byte signal)
		i2cReceiveByte(FALSE);
		i2cWaitForComplete();
		*data++ = i2cGetReceivedByte();
    4a84:	80 83       	st	Z, r24
    4a86:	90 e0       	ldi	r25, 0x00	; 0

inline void i2cSendStop(void)
{
	// transmit stop condition
	// leave with TWEA on for slave receiving
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA)|BV(TWSTO));
    4a88:	80 91 bc 00 	lds	r24, 0x00BC
    4a8c:	8f 70       	andi	r24, 0x0F	; 15
    4a8e:	80 6d       	ori	r24, 0xD0	; 208
    4a90:	80 93 bc 00 	sts	0x00BC, r24
	// transmit stop condition
	// leave with TWEA on for slave receiving
	i2cSendStop();

	// enable TWI interrupt
	sbi(TWCR, TWIE);
    4a94:	80 91 bc 00 	lds	r24, 0x00BC
    4a98:	81 60       	ori	r24, 0x01	; 1
    4a9a:	80 93 bc 00 	sts	0x00BC, r24

	return retval;
}
    4a9e:	89 2f       	mov	r24, r25
    4aa0:	08 95       	ret

00004aa2 <__vector_39>:
}
*/

//! I2C (TWI) interrupt service routine
SIGNAL(SIG_2WIRE_SERIAL)
{
    4aa2:	1f 92       	push	r1
    4aa4:	0f 92       	push	r0
    4aa6:	0f b6       	in	r0, 0x3f	; 63
    4aa8:	0f 92       	push	r0
    4aaa:	11 24       	eor	r1, r1
    4aac:	2f 93       	push	r18
    4aae:	3f 93       	push	r19
    4ab0:	4f 93       	push	r20
    4ab2:	5f 93       	push	r21
    4ab4:	6f 93       	push	r22
    4ab6:	7f 93       	push	r23
    4ab8:	8f 93       	push	r24
    4aba:	9f 93       	push	r25
    4abc:	af 93       	push	r26
    4abe:	bf 93       	push	r27
    4ac0:	ef 93       	push	r30
    4ac2:	ff 93       	push	r31
	// read status bits
	u08 status = inb(TWSR) & TWSR_STATUS_MASK;
    4ac4:	80 91 b9 00 	lds	r24, 0x00B9

	switch(status)
    4ac8:	88 7f       	andi	r24, 0xF8	; 248
    4aca:	80 36       	cpi	r24, 0x60	; 96
    4acc:	09 f4       	brne	.+2      	; 0x4ad0 <__vector_39+0x2e>
    4ace:	a0 c0       	rjmp	.+320    	; 0x4c10 <__vector_39+0x16e>
    4ad0:	81 36       	cpi	r24, 0x61	; 97
    4ad2:	70 f5       	brcc	.+92     	; 0x4b30 <__vector_39+0x8e>
    4ad4:	88 32       	cpi	r24, 0x28	; 40
    4ad6:	09 f4       	brne	.+2      	; 0x4ada <__vector_39+0x38>
    4ad8:	5f c0       	rjmp	.+190    	; 0x4b98 <__vector_39+0xf6>
    4ada:	89 32       	cpi	r24, 0x29	; 41
    4adc:	98 f4       	brcc	.+38     	; 0x4b04 <__vector_39+0x62>
    4ade:	80 31       	cpi	r24, 0x10	; 16
    4ae0:	09 f4       	brne	.+2      	; 0x4ae4 <__vector_39+0x42>
    4ae2:	57 c0       	rjmp	.+174    	; 0x4b92 <__vector_39+0xf0>
    4ae4:	81 31       	cpi	r24, 0x11	; 17
    4ae6:	38 f4       	brcc	.+14     	; 0x4af6 <__vector_39+0x54>
    4ae8:	88 23       	and	r24, r24
    4aea:	09 f4       	brne	.+2      	; 0x4aee <__vector_39+0x4c>
    4aec:	ea c0       	rjmp	.+468    	; 0x4cc2 <__vector_39+0x220>
    4aee:	88 30       	cpi	r24, 0x08	; 8
    4af0:	09 f0       	breq	.+2      	; 0x4af4 <__vector_39+0x52>
    4af2:	ef c0       	rjmp	.+478    	; 0x4cd2 <__vector_39+0x230>
    4af4:	4e c0       	rjmp	.+156    	; 0x4b92 <__vector_39+0xf0>
    4af6:	88 31       	cpi	r24, 0x18	; 24
    4af8:	09 f4       	brne	.+2      	; 0x4afc <__vector_39+0x5a>
    4afa:	4e c0       	rjmp	.+156    	; 0x4b98 <__vector_39+0xf6>
    4afc:	80 32       	cpi	r24, 0x20	; 32
    4afe:	09 f0       	breq	.+2      	; 0x4b02 <__vector_39+0x60>
    4b00:	e8 c0       	rjmp	.+464    	; 0x4cd2 <__vector_39+0x230>
    4b02:	df c0       	rjmp	.+446    	; 0x4cc2 <__vector_39+0x220>
    4b04:	80 34       	cpi	r24, 0x40	; 64
    4b06:	09 f4       	brne	.+2      	; 0x4b0a <__vector_39+0x68>
    4b08:	77 c0       	rjmp	.+238    	; 0x4bf8 <__vector_39+0x156>
    4b0a:	81 34       	cpi	r24, 0x41	; 65
    4b0c:	38 f4       	brcc	.+14     	; 0x4b1c <__vector_39+0x7a>
    4b0e:	80 33       	cpi	r24, 0x30	; 48
    4b10:	09 f4       	brne	.+2      	; 0x4b14 <__vector_39+0x72>
    4b12:	d7 c0       	rjmp	.+430    	; 0x4cc2 <__vector_39+0x220>
    4b14:	88 33       	cpi	r24, 0x38	; 56
    4b16:	09 f0       	breq	.+2      	; 0x4b1a <__vector_39+0x78>
    4b18:	dc c0       	rjmp	.+440    	; 0x4cd2 <__vector_39+0x230>
    4b1a:	5d c0       	rjmp	.+186    	; 0x4bd6 <__vector_39+0x134>
    4b1c:	80 35       	cpi	r24, 0x50	; 80
    4b1e:	09 f4       	brne	.+2      	; 0x4b22 <__vector_39+0x80>
    4b20:	5f c0       	rjmp	.+190    	; 0x4be0 <__vector_39+0x13e>
    4b22:	88 35       	cpi	r24, 0x58	; 88
    4b24:	09 f4       	brne	.+2      	; 0x4b28 <__vector_39+0x86>
    4b26:	4a c0       	rjmp	.+148    	; 0x4bbc <__vector_39+0x11a>
    4b28:	88 34       	cpi	r24, 0x48	; 72
    4b2a:	09 f0       	breq	.+2      	; 0x4b2e <__vector_39+0x8c>
    4b2c:	d2 c0       	rjmp	.+420    	; 0x4cd2 <__vector_39+0x230>
    4b2e:	c9 c0       	rjmp	.+402    	; 0x4cc2 <__vector_39+0x220>
    4b30:	88 39       	cpi	r24, 0x98	; 152
    4b32:	09 f4       	brne	.+2      	; 0x4b36 <__vector_39+0x94>
    4b34:	ba c0       	rjmp	.+372    	; 0x4caa <__vector_39+0x208>
    4b36:	89 39       	cpi	r24, 0x99	; 153
    4b38:	b0 f4       	brcc	.+44     	; 0x4b66 <__vector_39+0xc4>
    4b3a:	88 37       	cpi	r24, 0x78	; 120
    4b3c:	09 f4       	brne	.+2      	; 0x4b40 <__vector_39+0x9e>
    4b3e:	68 c0       	rjmp	.+208    	; 0x4c10 <__vector_39+0x16e>
    4b40:	89 37       	cpi	r24, 0x79	; 121
    4b42:	38 f4       	brcc	.+14     	; 0x4b52 <__vector_39+0xb0>
    4b44:	88 36       	cpi	r24, 0x68	; 104
    4b46:	09 f4       	brne	.+2      	; 0x4b4a <__vector_39+0xa8>
    4b48:	63 c0       	rjmp	.+198    	; 0x4c10 <__vector_39+0x16e>
    4b4a:	80 37       	cpi	r24, 0x70	; 112
    4b4c:	09 f0       	breq	.+2      	; 0x4b50 <__vector_39+0xae>
    4b4e:	c1 c0       	rjmp	.+386    	; 0x4cd2 <__vector_39+0x230>
    4b50:	5f c0       	rjmp	.+190    	; 0x4c10 <__vector_39+0x16e>
    4b52:	88 38       	cpi	r24, 0x88	; 136
    4b54:	09 f4       	brne	.+2      	; 0x4b58 <__vector_39+0xb6>
    4b56:	a9 c0       	rjmp	.+338    	; 0x4caa <__vector_39+0x208>
    4b58:	80 39       	cpi	r24, 0x90	; 144
    4b5a:	09 f4       	brne	.+2      	; 0x4b5e <__vector_39+0xbc>
    4b5c:	5f c0       	rjmp	.+190    	; 0x4c1c <__vector_39+0x17a>
    4b5e:	80 38       	cpi	r24, 0x80	; 128
    4b60:	09 f0       	breq	.+2      	; 0x4b64 <__vector_39+0xc2>
    4b62:	b7 c0       	rjmp	.+366    	; 0x4cd2 <__vector_39+0x230>
    4b64:	5b c0       	rjmp	.+182    	; 0x4c1c <__vector_39+0x17a>
    4b66:	80 3b       	cpi	r24, 0xB0	; 176
    4b68:	09 f4       	brne	.+2      	; 0x4b6c <__vector_39+0xca>
    4b6a:	79 c0       	rjmp	.+242    	; 0x4c5e <__vector_39+0x1bc>
    4b6c:	81 3b       	cpi	r24, 0xB1	; 177
    4b6e:	38 f4       	brcc	.+14     	; 0x4b7e <__vector_39+0xdc>
    4b70:	80 3a       	cpi	r24, 0xA0	; 160
    4b72:	09 f4       	brne	.+2      	; 0x4b76 <__vector_39+0xd4>
    4b74:	62 c0       	rjmp	.+196    	; 0x4c3a <__vector_39+0x198>
    4b76:	88 3a       	cpi	r24, 0xA8	; 168
    4b78:	09 f0       	breq	.+2      	; 0x4b7c <__vector_39+0xda>
    4b7a:	ab c0       	rjmp	.+342    	; 0x4cd2 <__vector_39+0x230>
    4b7c:	70 c0       	rjmp	.+224    	; 0x4c5e <__vector_39+0x1bc>
    4b7e:	80 3c       	cpi	r24, 0xC0	; 192
    4b80:	09 f4       	brne	.+2      	; 0x4b84 <__vector_39+0xe2>
    4b82:	9a c0       	rjmp	.+308    	; 0x4cb8 <__vector_39+0x216>
    4b84:	88 3c       	cpi	r24, 0xC8	; 200
    4b86:	09 f4       	brne	.+2      	; 0x4b8a <__vector_39+0xe8>
    4b88:	97 c0       	rjmp	.+302    	; 0x4cb8 <__vector_39+0x216>
    4b8a:	88 3b       	cpi	r24, 0xB8	; 184
    4b8c:	09 f0       	breq	.+2      	; 0x4b90 <__vector_39+0xee>
    4b8e:	a1 c0       	rjmp	.+322    	; 0x4cd2 <__vector_39+0x230>
    4b90:	77 c0       	rjmp	.+238    	; 0x4c80 <__vector_39+0x1de>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: M->START\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// send device address
		i2cSendByte(I2cDeviceAddrRW);
    4b92:	80 91 69 11 	lds	r24, 0x1169
    4b96:	0f c0       	rjmp	.+30     	; 0x4bb6 <__vector_39+0x114>
		#ifdef I2C_DEBUG
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MT->SLA_ACK or DATA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		if(I2cSendDataIndex < I2cSendDataLength)
    4b98:	90 91 8a 11 	lds	r25, 0x118A
    4b9c:	80 91 8b 11 	lds	r24, 0x118B
    4ba0:	98 17       	cp	r25, r24
    4ba2:	08 f0       	brcs	.+2      	; 0x4ba6 <__vector_39+0x104>
    4ba4:	8e c0       	rjmp	.+284    	; 0x4cc2 <__vector_39+0x220>
		{
			// send data
			i2cSendByte( I2cSendData[I2cSendDataIndex++] );
    4ba6:	e9 2f       	mov	r30, r25
    4ba8:	f0 e0       	ldi	r31, 0x00	; 0
    4baa:	e6 59       	subi	r30, 0x96	; 150
    4bac:	fe 4e       	sbci	r31, 0xEE	; 238
    4bae:	80 81       	ld	r24, Z
    4bb0:	9f 5f       	subi	r25, 0xFF	; 255
    4bb2:	90 93 8a 11 	sts	0x118A, r25
}

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    4bb6:	80 93 bb 00 	sts	0x00BB, r24
    4bba:	77 c0       	rjmp	.+238    	; 0x4caa <__vector_39+0x208>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MR->DATA_NACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// store final received data byte
		I2cReceiveData[I2cReceiveDataIndex++] = inb(TWDR);
    4bbc:	80 91 ac 11 	lds	r24, 0x11AC
    4bc0:	90 91 bb 00 	lds	r25, 0x00BB
    4bc4:	e8 2f       	mov	r30, r24
    4bc6:	f0 e0       	ldi	r31, 0x00	; 0
    4bc8:	e4 57       	subi	r30, 0x74	; 116
    4bca:	fe 4e       	sbci	r31, 0xEE	; 238
    4bcc:	90 83       	st	Z, r25
    4bce:	8f 5f       	subi	r24, 0xFF	; 255
    4bd0:	80 93 ac 11 	sts	0x11AC, r24
    4bd4:	76 c0       	rjmp	.+236    	; 0x4cc2 <__vector_39+0x220>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MT->ARB_LOST\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// release bus
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    4bd6:	80 91 bc 00 	lds	r24, 0x00BC
    4bda:	8f 70       	andi	r24, 0x0F	; 15
    4bdc:	80 68       	ori	r24, 0x80	; 128
    4bde:	75 c0       	rjmp	.+234    	; 0x4cca <__vector_39+0x228>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MR->DATA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// store received data byte
		I2cReceiveData[I2cReceiveDataIndex++] = inb(TWDR);
    4be0:	80 91 ac 11 	lds	r24, 0x11AC
    4be4:	90 91 bb 00 	lds	r25, 0x00BB
    4be8:	e8 2f       	mov	r30, r24
    4bea:	f0 e0       	ldi	r31, 0x00	; 0
    4bec:	e4 57       	subi	r30, 0x74	; 116
    4bee:	fe 4e       	sbci	r31, 0xEE	; 238
    4bf0:	90 83       	st	Z, r25
    4bf2:	8f 5f       	subi	r24, 0xFF	; 255
    4bf4:	80 93 ac 11 	sts	0x11AC, r24
		#ifdef I2C_DEBUG
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MR->SLA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		if(I2cReceiveDataIndex < (I2cReceiveDataLength-1))
    4bf8:	20 91 ac 11 	lds	r18, 0x11AC
    4bfc:	30 e0       	ldi	r19, 0x00	; 0
    4bfe:	80 91 ad 11 	lds	r24, 0x11AD
    4c02:	90 e0       	ldi	r25, 0x00	; 0
    4c04:	01 97       	sbiw	r24, 0x01	; 1
    4c06:	28 17       	cp	r18, r24
    4c08:	39 07       	cpc	r19, r25
    4c0a:	0c f0       	brlt	.+2      	; 0x4c0e <__vector_39+0x16c>
    4c0c:	4e c0       	rjmp	.+156    	; 0x4caa <__vector_39+0x208>
    4c0e:	48 c0       	rjmp	.+144    	; 0x4ca0 <__vector_39+0x1fe>
		rprintf("I2C: SR->SLA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// we are being addressed as slave for writing (data will be received from master)
		// set state
		I2cState = I2C_SLAVE_RX;
    4c10:	85 e0       	ldi	r24, 0x05	; 5
    4c12:	80 93 68 11 	sts	0x1168, r24
		// prepare buffer
		I2cReceiveDataIndex = 0;
    4c16:	10 92 ac 11 	sts	0x11AC, r1
    4c1a:	42 c0       	rjmp	.+132    	; 0x4ca0 <__vector_39+0x1fe>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: SR->DATA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// get previously received data byte
		I2cReceiveData[I2cReceiveDataIndex++] = inb(TWDR);
    4c1c:	80 91 ac 11 	lds	r24, 0x11AC
    4c20:	90 91 bb 00 	lds	r25, 0x00BB
    4c24:	e8 2f       	mov	r30, r24
    4c26:	f0 e0       	ldi	r31, 0x00	; 0
    4c28:	e4 57       	subi	r30, 0x74	; 116
    4c2a:	fe 4e       	sbci	r31, 0xEE	; 238
    4c2c:	90 83       	st	Z, r25
    4c2e:	8f 5f       	subi	r24, 0xFF	; 255
    4c30:	80 93 ac 11 	sts	0x11AC, r24
		// check receive buffer status
		if(I2cReceiveDataIndex < I2C_RECEIVE_DATA_BUFFER_SIZE)
    4c34:	80 32       	cpi	r24, 0x20	; 32
    4c36:	c8 f5       	brcc	.+114    	; 0x4caa <__vector_39+0x208>
    4c38:	33 c0       	rjmp	.+102    	; 0x4ca0 <__vector_39+0x1fe>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: SR->SR_STOP\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// switch to SR mode with SLA ACK
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    4c3a:	80 91 bc 00 	lds	r24, 0x00BC
    4c3e:	8f 70       	andi	r24, 0x0F	; 15
    4c40:	80 6c       	ori	r24, 0xC0	; 192
    4c42:	80 93 bc 00 	sts	0x00BC, r24
		// i2c receive is complete, call i2cSlaveReceive
		if(i2cSlaveReceive) i2cSlaveReceive(I2cReceiveDataIndex, I2cReceiveData);
    4c46:	e0 91 ae 11 	lds	r30, 0x11AE
    4c4a:	f0 91 af 11 	lds	r31, 0x11AF
    4c4e:	30 97       	sbiw	r30, 0x00	; 0
    4c50:	f1 f1       	breq	.+124    	; 0x4cce <__vector_39+0x22c>
    4c52:	80 91 ac 11 	lds	r24, 0x11AC
    4c56:	6c e8       	ldi	r22, 0x8C	; 140
    4c58:	71 e1       	ldi	r23, 0x11	; 17
    4c5a:	09 95       	icall
    4c5c:	38 c0       	rjmp	.+112    	; 0x4cce <__vector_39+0x22c>
		rprintf("I2C: ST->SLA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// we are being addressed as slave for reading (data must be transmitted back to master)
		// set state
		I2cState = I2C_SLAVE_TX;
    4c5e:	84 e0       	ldi	r24, 0x04	; 4
    4c60:	80 93 68 11 	sts	0x1168, r24
		// request data from application
		if(i2cSlaveTransmit) I2cSendDataLength = i2cSlaveTransmit(I2C_SEND_DATA_BUFFER_SIZE, I2cSendData);
    4c64:	e0 91 b0 11 	lds	r30, 0x11B0
    4c68:	f0 91 b1 11 	lds	r31, 0x11B1
    4c6c:	30 97       	sbiw	r30, 0x00	; 0
    4c6e:	31 f0       	breq	.+12     	; 0x4c7c <__vector_39+0x1da>
    4c70:	80 e2       	ldi	r24, 0x20	; 32
    4c72:	6a e6       	ldi	r22, 0x6A	; 106
    4c74:	71 e1       	ldi	r23, 0x11	; 17
    4c76:	09 95       	icall
    4c78:	80 93 8b 11 	sts	0x118B, r24
		// reset data index
		I2cSendDataIndex = 0;
    4c7c:	10 92 8a 11 	sts	0x118A, r1
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: ST->DATA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// transmit data byte
		outb(TWDR, I2cSendData[I2cSendDataIndex++]);
    4c80:	90 91 8a 11 	lds	r25, 0x118A
    4c84:	e9 2f       	mov	r30, r25
    4c86:	f0 e0       	ldi	r31, 0x00	; 0
    4c88:	e6 59       	subi	r30, 0x96	; 150
    4c8a:	fe 4e       	sbci	r31, 0xEE	; 238
    4c8c:	80 81       	ld	r24, Z
    4c8e:	80 93 bb 00 	sts	0x00BB, r24
    4c92:	9f 5f       	subi	r25, 0xFF	; 255
    4c94:	90 93 8a 11 	sts	0x118A, r25
		if(I2cSendDataIndex < I2cSendDataLength)
    4c98:	80 91 8b 11 	lds	r24, 0x118B
    4c9c:	98 17       	cp	r25, r24
    4c9e:	28 f4       	brcc	.+10     	; 0x4caa <__vector_39+0x208>
			// expect ACK to data byte
			outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    4ca0:	80 91 bc 00 	lds	r24, 0x00BC
    4ca4:	8f 70       	andi	r24, 0x0F	; 15
    4ca6:	80 6c       	ori	r24, 0xC0	; 192
    4ca8:	04 c0       	rjmp	.+8      	; 0x4cb2 <__vector_39+0x210>
		else
			// expect NACK to data byte
			outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    4caa:	80 91 bc 00 	lds	r24, 0x00BC
    4cae:	8f 70       	andi	r24, 0x0F	; 15
    4cb0:	80 68       	ori	r24, 0x80	; 128
    4cb2:	80 93 bc 00 	sts	0x00BC, r24
    4cb6:	0d c0       	rjmp	.+26     	; 0x4cd2 <__vector_39+0x230>
		rprintf("I2C: ST->DATA_NACK or LAST_DATA\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// all done
		// switch to open slave
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    4cb8:	80 91 bc 00 	lds	r24, 0x00BC
    4cbc:	8f 70       	andi	r24, 0x0F	; 15
    4cbe:	80 6c       	ori	r24, 0xC0	; 192
    4cc0:	04 c0       	rjmp	.+8      	; 0x4cca <__vector_39+0x228>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: BUS_ERROR\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// reset internal hardware and release bus
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTO)|BV(TWEA));
    4cc2:	80 91 bc 00 	lds	r24, 0x00BC
    4cc6:	8f 70       	andi	r24, 0x0F	; 15
    4cc8:	80 6d       	ori	r24, 0xD0	; 208
    4cca:	80 93 bc 00 	sts	0x00BC, r24
		// set state
		I2cState = I2C_IDLE;
    4cce:	10 92 68 11 	sts	0x1168, r1
		break;
	}
}
    4cd2:	ff 91       	pop	r31
    4cd4:	ef 91       	pop	r30
    4cd6:	bf 91       	pop	r27
    4cd8:	af 91       	pop	r26
    4cda:	9f 91       	pop	r25
    4cdc:	8f 91       	pop	r24
    4cde:	7f 91       	pop	r23
    4ce0:	6f 91       	pop	r22
    4ce2:	5f 91       	pop	r21
    4ce4:	4f 91       	pop	r20
    4ce6:	3f 91       	pop	r19
    4ce8:	2f 91       	pop	r18
    4cea:	0f 90       	pop	r0
    4cec:	0f be       	out	0x3f, r0	; 63
    4cee:	0f 90       	pop	r0
    4cf0:	1f 90       	pop	r1
    4cf2:	18 95       	reti

00004cf4 <i2cGetState>:

eI2cStateType i2cGetState(void)
{
	return I2cState;
    4cf4:	80 91 68 11 	lds	r24, 0x1168
}
    4cf8:	08 95       	ret

00004cfa <exit>:
    4cfa:	f8 94       	cli
    4cfc:	0c 94 19 29 	jmp	0x5232	; 0x5232 <_exit>

00004d00 <memcpy>:
    4d00:	fb 01       	movw	r30, r22
    4d02:	dc 01       	movw	r26, r24
    4d04:	02 c0       	rjmp	.+4      	; 0x4d0a <memcpy+0xa>
    4d06:	01 90       	ld	r0, Z+
    4d08:	0d 92       	st	X+, r0
    4d0a:	41 50       	subi	r20, 0x01	; 1
    4d0c:	50 40       	sbci	r21, 0x00	; 0
    4d0e:	d8 f7       	brcc	.-10     	; 0x4d06 <memcpy+0x6>
    4d10:	08 95       	ret

00004d12 <memset>:
    4d12:	dc 01       	movw	r26, r24
    4d14:	01 c0       	rjmp	.+2      	; 0x4d18 <memset+0x6>
    4d16:	6d 93       	st	X+, r22
    4d18:	41 50       	subi	r20, 0x01	; 1
    4d1a:	50 40       	sbci	r21, 0x00	; 0
    4d1c:	e0 f7       	brcc	.-8      	; 0x4d16 <memset+0x4>
    4d1e:	08 95       	ret

00004d20 <strncpy>:
    4d20:	fb 01       	movw	r30, r22
    4d22:	dc 01       	movw	r26, r24
    4d24:	41 50       	subi	r20, 0x01	; 1
    4d26:	50 40       	sbci	r21, 0x00	; 0
    4d28:	48 f0       	brcs	.+18     	; 0x4d3c <strncpy+0x1c>
    4d2a:	01 90       	ld	r0, Z+
    4d2c:	0d 92       	st	X+, r0
    4d2e:	00 20       	and	r0, r0
    4d30:	c9 f7       	brne	.-14     	; 0x4d24 <strncpy+0x4>
    4d32:	01 c0       	rjmp	.+2      	; 0x4d36 <strncpy+0x16>
    4d34:	1d 92       	st	X+, r1
    4d36:	41 50       	subi	r20, 0x01	; 1
    4d38:	50 40       	sbci	r21, 0x00	; 0
    4d3a:	e0 f7       	brcc	.-8      	; 0x4d34 <strncpy+0x14>
    4d3c:	08 95       	ret

00004d3e <__subsf3>:
    4d3e:	50 58       	subi	r21, 0x80	; 128

00004d40 <__addsf3>:
    4d40:	bb 27       	eor	r27, r27
    4d42:	aa 27       	eor	r26, r26
    4d44:	0e d0       	rcall	.+28     	; 0x4d62 <__addsf3x>
    4d46:	70 c1       	rjmp	.+736    	; 0x5028 <__fp_round>
    4d48:	61 d1       	rcall	.+706    	; 0x500c <__fp_pscA>
    4d4a:	30 f0       	brcs	.+12     	; 0x4d58 <__addsf3+0x18>
    4d4c:	66 d1       	rcall	.+716    	; 0x501a <__fp_pscB>
    4d4e:	20 f0       	brcs	.+8      	; 0x4d58 <__addsf3+0x18>
    4d50:	31 f4       	brne	.+12     	; 0x4d5e <__addsf3+0x1e>
    4d52:	9f 3f       	cpi	r25, 0xFF	; 255
    4d54:	11 f4       	brne	.+4      	; 0x4d5a <__addsf3+0x1a>
    4d56:	1e f4       	brtc	.+6      	; 0x4d5e <__addsf3+0x1e>
    4d58:	56 c1       	rjmp	.+684    	; 0x5006 <__fp_nan>
    4d5a:	0e f4       	brtc	.+2      	; 0x4d5e <__addsf3+0x1e>
    4d5c:	e0 95       	com	r30
    4d5e:	e7 fb       	bst	r30, 7
    4d60:	4c c1       	rjmp	.+664    	; 0x4ffa <__fp_inf>

00004d62 <__addsf3x>:
    4d62:	e9 2f       	mov	r30, r25
    4d64:	72 d1       	rcall	.+740    	; 0x504a <__fp_split3>
    4d66:	80 f3       	brcs	.-32     	; 0x4d48 <__addsf3+0x8>
    4d68:	ba 17       	cp	r27, r26
    4d6a:	62 07       	cpc	r22, r18
    4d6c:	73 07       	cpc	r23, r19
    4d6e:	84 07       	cpc	r24, r20
    4d70:	95 07       	cpc	r25, r21
    4d72:	18 f0       	brcs	.+6      	; 0x4d7a <__addsf3x+0x18>
    4d74:	71 f4       	brne	.+28     	; 0x4d92 <__addsf3x+0x30>
    4d76:	9e f5       	brtc	.+102    	; 0x4dde <__addsf3x+0x7c>
    4d78:	8a c1       	rjmp	.+788    	; 0x508e <__fp_zero>
    4d7a:	0e f4       	brtc	.+2      	; 0x4d7e <__addsf3x+0x1c>
    4d7c:	e0 95       	com	r30
    4d7e:	0b 2e       	mov	r0, r27
    4d80:	ba 2f       	mov	r27, r26
    4d82:	a0 2d       	mov	r26, r0
    4d84:	0b 01       	movw	r0, r22
    4d86:	b9 01       	movw	r22, r18
    4d88:	90 01       	movw	r18, r0
    4d8a:	0c 01       	movw	r0, r24
    4d8c:	ca 01       	movw	r24, r20
    4d8e:	a0 01       	movw	r20, r0
    4d90:	11 24       	eor	r1, r1
    4d92:	ff 27       	eor	r31, r31
    4d94:	59 1b       	sub	r21, r25
    4d96:	99 f0       	breq	.+38     	; 0x4dbe <__addsf3x+0x5c>
    4d98:	59 3f       	cpi	r21, 0xF9	; 249
    4d9a:	50 f4       	brcc	.+20     	; 0x4db0 <__addsf3x+0x4e>
    4d9c:	50 3e       	cpi	r21, 0xE0	; 224
    4d9e:	68 f1       	brcs	.+90     	; 0x4dfa <__addsf3x+0x98>
    4da0:	1a 16       	cp	r1, r26
    4da2:	f0 40       	sbci	r31, 0x00	; 0
    4da4:	a2 2f       	mov	r26, r18
    4da6:	23 2f       	mov	r18, r19
    4da8:	34 2f       	mov	r19, r20
    4daa:	44 27       	eor	r20, r20
    4dac:	58 5f       	subi	r21, 0xF8	; 248
    4dae:	f3 cf       	rjmp	.-26     	; 0x4d96 <__addsf3x+0x34>
    4db0:	46 95       	lsr	r20
    4db2:	37 95       	ror	r19
    4db4:	27 95       	ror	r18
    4db6:	a7 95       	ror	r26
    4db8:	f0 40       	sbci	r31, 0x00	; 0
    4dba:	53 95       	inc	r21
    4dbc:	c9 f7       	brne	.-14     	; 0x4db0 <__addsf3x+0x4e>
    4dbe:	7e f4       	brtc	.+30     	; 0x4dde <__addsf3x+0x7c>
    4dc0:	1f 16       	cp	r1, r31
    4dc2:	ba 0b       	sbc	r27, r26
    4dc4:	62 0b       	sbc	r22, r18
    4dc6:	73 0b       	sbc	r23, r19
    4dc8:	84 0b       	sbc	r24, r20
    4dca:	ba f0       	brmi	.+46     	; 0x4dfa <__addsf3x+0x98>
    4dcc:	91 50       	subi	r25, 0x01	; 1
    4dce:	a1 f0       	breq	.+40     	; 0x4df8 <__addsf3x+0x96>
    4dd0:	ff 0f       	add	r31, r31
    4dd2:	bb 1f       	adc	r27, r27
    4dd4:	66 1f       	adc	r22, r22
    4dd6:	77 1f       	adc	r23, r23
    4dd8:	88 1f       	adc	r24, r24
    4dda:	c2 f7       	brpl	.-16     	; 0x4dcc <__addsf3x+0x6a>
    4ddc:	0e c0       	rjmp	.+28     	; 0x4dfa <__addsf3x+0x98>
    4dde:	ba 0f       	add	r27, r26
    4de0:	62 1f       	adc	r22, r18
    4de2:	73 1f       	adc	r23, r19
    4de4:	84 1f       	adc	r24, r20
    4de6:	48 f4       	brcc	.+18     	; 0x4dfa <__addsf3x+0x98>
    4de8:	87 95       	ror	r24
    4dea:	77 95       	ror	r23
    4dec:	67 95       	ror	r22
    4dee:	b7 95       	ror	r27
    4df0:	f7 95       	ror	r31
    4df2:	9e 3f       	cpi	r25, 0xFE	; 254
    4df4:	08 f0       	brcs	.+2      	; 0x4df8 <__addsf3x+0x96>
    4df6:	b3 cf       	rjmp	.-154    	; 0x4d5e <__addsf3+0x1e>
    4df8:	93 95       	inc	r25
    4dfa:	88 0f       	add	r24, r24
    4dfc:	08 f0       	brcs	.+2      	; 0x4e00 <__addsf3x+0x9e>
    4dfe:	99 27       	eor	r25, r25
    4e00:	ee 0f       	add	r30, r30
    4e02:	97 95       	ror	r25
    4e04:	87 95       	ror	r24
    4e06:	08 95       	ret

00004e08 <__cmpsf2>:
    4e08:	d4 d0       	rcall	.+424    	; 0x4fb2 <__fp_cmp>
    4e0a:	08 f4       	brcc	.+2      	; 0x4e0e <__cmpsf2+0x6>
    4e0c:	81 e0       	ldi	r24, 0x01	; 1
    4e0e:	08 95       	ret

00004e10 <__divsf3>:
    4e10:	0c d0       	rcall	.+24     	; 0x4e2a <__divsf3x>
    4e12:	0a c1       	rjmp	.+532    	; 0x5028 <__fp_round>
    4e14:	02 d1       	rcall	.+516    	; 0x501a <__fp_pscB>
    4e16:	40 f0       	brcs	.+16     	; 0x4e28 <__divsf3+0x18>
    4e18:	f9 d0       	rcall	.+498    	; 0x500c <__fp_pscA>
    4e1a:	30 f0       	brcs	.+12     	; 0x4e28 <__divsf3+0x18>
    4e1c:	21 f4       	brne	.+8      	; 0x4e26 <__divsf3+0x16>
    4e1e:	5f 3f       	cpi	r21, 0xFF	; 255
    4e20:	19 f0       	breq	.+6      	; 0x4e28 <__divsf3+0x18>
    4e22:	eb c0       	rjmp	.+470    	; 0x4ffa <__fp_inf>
    4e24:	51 11       	cpse	r21, r1
    4e26:	34 c1       	rjmp	.+616    	; 0x5090 <__fp_szero>
    4e28:	ee c0       	rjmp	.+476    	; 0x5006 <__fp_nan>

00004e2a <__divsf3x>:
    4e2a:	0f d1       	rcall	.+542    	; 0x504a <__fp_split3>
    4e2c:	98 f3       	brcs	.-26     	; 0x4e14 <__divsf3+0x4>

00004e2e <__divsf3_pse>:
    4e2e:	99 23       	and	r25, r25
    4e30:	c9 f3       	breq	.-14     	; 0x4e24 <__divsf3+0x14>
    4e32:	55 23       	and	r21, r21
    4e34:	b1 f3       	breq	.-20     	; 0x4e22 <__divsf3+0x12>
    4e36:	95 1b       	sub	r25, r21
    4e38:	55 0b       	sbc	r21, r21
    4e3a:	bb 27       	eor	r27, r27
    4e3c:	aa 27       	eor	r26, r26
    4e3e:	62 17       	cp	r22, r18
    4e40:	73 07       	cpc	r23, r19
    4e42:	84 07       	cpc	r24, r20
    4e44:	38 f0       	brcs	.+14     	; 0x4e54 <__divsf3_pse+0x26>
    4e46:	9f 5f       	subi	r25, 0xFF	; 255
    4e48:	5f 4f       	sbci	r21, 0xFF	; 255
    4e4a:	22 0f       	add	r18, r18
    4e4c:	33 1f       	adc	r19, r19
    4e4e:	44 1f       	adc	r20, r20
    4e50:	aa 1f       	adc	r26, r26
    4e52:	a9 f3       	breq	.-22     	; 0x4e3e <__divsf3_pse+0x10>
    4e54:	33 d0       	rcall	.+102    	; 0x4ebc <__divsf3_pse+0x8e>
    4e56:	0e 2e       	mov	r0, r30
    4e58:	3a f0       	brmi	.+14     	; 0x4e68 <__divsf3_pse+0x3a>
    4e5a:	e0 e8       	ldi	r30, 0x80	; 128
    4e5c:	30 d0       	rcall	.+96     	; 0x4ebe <__divsf3_pse+0x90>
    4e5e:	91 50       	subi	r25, 0x01	; 1
    4e60:	50 40       	sbci	r21, 0x00	; 0
    4e62:	e6 95       	lsr	r30
    4e64:	00 1c       	adc	r0, r0
    4e66:	ca f7       	brpl	.-14     	; 0x4e5a <__divsf3_pse+0x2c>
    4e68:	29 d0       	rcall	.+82     	; 0x4ebc <__divsf3_pse+0x8e>
    4e6a:	fe 2f       	mov	r31, r30
    4e6c:	27 d0       	rcall	.+78     	; 0x4ebc <__divsf3_pse+0x8e>
    4e6e:	66 0f       	add	r22, r22
    4e70:	77 1f       	adc	r23, r23
    4e72:	88 1f       	adc	r24, r24
    4e74:	bb 1f       	adc	r27, r27
    4e76:	26 17       	cp	r18, r22
    4e78:	37 07       	cpc	r19, r23
    4e7a:	48 07       	cpc	r20, r24
    4e7c:	ab 07       	cpc	r26, r27
    4e7e:	b0 e8       	ldi	r27, 0x80	; 128
    4e80:	09 f0       	breq	.+2      	; 0x4e84 <__divsf3_pse+0x56>
    4e82:	bb 0b       	sbc	r27, r27
    4e84:	80 2d       	mov	r24, r0
    4e86:	bf 01       	movw	r22, r30
    4e88:	ff 27       	eor	r31, r31
    4e8a:	93 58       	subi	r25, 0x83	; 131
    4e8c:	5f 4f       	sbci	r21, 0xFF	; 255
    4e8e:	2a f0       	brmi	.+10     	; 0x4e9a <__divsf3_pse+0x6c>
    4e90:	9e 3f       	cpi	r25, 0xFE	; 254
    4e92:	51 05       	cpc	r21, r1
    4e94:	68 f0       	brcs	.+26     	; 0x4eb0 <__divsf3_pse+0x82>
    4e96:	b1 c0       	rjmp	.+354    	; 0x4ffa <__fp_inf>
    4e98:	fb c0       	rjmp	.+502    	; 0x5090 <__fp_szero>
    4e9a:	5f 3f       	cpi	r21, 0xFF	; 255
    4e9c:	ec f3       	brlt	.-6      	; 0x4e98 <__divsf3_pse+0x6a>
    4e9e:	98 3e       	cpi	r25, 0xE8	; 232
    4ea0:	dc f3       	brlt	.-10     	; 0x4e98 <__divsf3_pse+0x6a>
    4ea2:	86 95       	lsr	r24
    4ea4:	77 95       	ror	r23
    4ea6:	67 95       	ror	r22
    4ea8:	b7 95       	ror	r27
    4eaa:	f7 95       	ror	r31
    4eac:	9f 5f       	subi	r25, 0xFF	; 255
    4eae:	c9 f7       	brne	.-14     	; 0x4ea2 <__divsf3_pse+0x74>
    4eb0:	88 0f       	add	r24, r24
    4eb2:	91 1d       	adc	r25, r1
    4eb4:	96 95       	lsr	r25
    4eb6:	87 95       	ror	r24
    4eb8:	97 f9       	bld	r25, 7
    4eba:	08 95       	ret
    4ebc:	e1 e0       	ldi	r30, 0x01	; 1
    4ebe:	66 0f       	add	r22, r22
    4ec0:	77 1f       	adc	r23, r23
    4ec2:	88 1f       	adc	r24, r24
    4ec4:	bb 1f       	adc	r27, r27
    4ec6:	62 17       	cp	r22, r18
    4ec8:	73 07       	cpc	r23, r19
    4eca:	84 07       	cpc	r24, r20
    4ecc:	ba 07       	cpc	r27, r26
    4ece:	20 f0       	brcs	.+8      	; 0x4ed8 <__divsf3_pse+0xaa>
    4ed0:	62 1b       	sub	r22, r18
    4ed2:	73 0b       	sbc	r23, r19
    4ed4:	84 0b       	sbc	r24, r20
    4ed6:	ba 0b       	sbc	r27, r26
    4ed8:	ee 1f       	adc	r30, r30
    4eda:	88 f7       	brcc	.-30     	; 0x4ebe <__divsf3_pse+0x90>
    4edc:	e0 95       	com	r30
    4ede:	08 95       	ret

00004ee0 <__fixunssfsi>:
    4ee0:	bc d0       	rcall	.+376    	; 0x505a <__fp_splitA>
    4ee2:	88 f0       	brcs	.+34     	; 0x4f06 <__fixunssfsi+0x26>
    4ee4:	9f 57       	subi	r25, 0x7F	; 127
    4ee6:	90 f0       	brcs	.+36     	; 0x4f0c <__fixunssfsi+0x2c>
    4ee8:	b9 2f       	mov	r27, r25
    4eea:	99 27       	eor	r25, r25
    4eec:	b7 51       	subi	r27, 0x17	; 23
    4eee:	a0 f0       	brcs	.+40     	; 0x4f18 <__fixunssfsi+0x38>
    4ef0:	d1 f0       	breq	.+52     	; 0x4f26 <__fixunssfsi+0x46>
    4ef2:	66 0f       	add	r22, r22
    4ef4:	77 1f       	adc	r23, r23
    4ef6:	88 1f       	adc	r24, r24
    4ef8:	99 1f       	adc	r25, r25
    4efa:	1a f0       	brmi	.+6      	; 0x4f02 <__fixunssfsi+0x22>
    4efc:	ba 95       	dec	r27
    4efe:	c9 f7       	brne	.-14     	; 0x4ef2 <__fixunssfsi+0x12>
    4f00:	12 c0       	rjmp	.+36     	; 0x4f26 <__fixunssfsi+0x46>
    4f02:	b1 30       	cpi	r27, 0x01	; 1
    4f04:	81 f0       	breq	.+32     	; 0x4f26 <__fixunssfsi+0x46>
    4f06:	c3 d0       	rcall	.+390    	; 0x508e <__fp_zero>
    4f08:	b1 e0       	ldi	r27, 0x01	; 1
    4f0a:	08 95       	ret
    4f0c:	c0 c0       	rjmp	.+384    	; 0x508e <__fp_zero>
    4f0e:	67 2f       	mov	r22, r23
    4f10:	78 2f       	mov	r23, r24
    4f12:	88 27       	eor	r24, r24
    4f14:	b8 5f       	subi	r27, 0xF8	; 248
    4f16:	39 f0       	breq	.+14     	; 0x4f26 <__fixunssfsi+0x46>
    4f18:	b9 3f       	cpi	r27, 0xF9	; 249
    4f1a:	cc f3       	brlt	.-14     	; 0x4f0e <__fixunssfsi+0x2e>
    4f1c:	86 95       	lsr	r24
    4f1e:	77 95       	ror	r23
    4f20:	67 95       	ror	r22
    4f22:	b3 95       	inc	r27
    4f24:	d9 f7       	brne	.-10     	; 0x4f1c <__fixunssfsi+0x3c>
    4f26:	3e f4       	brtc	.+14     	; 0x4f36 <__fixunssfsi+0x56>
    4f28:	90 95       	com	r25
    4f2a:	80 95       	com	r24
    4f2c:	70 95       	com	r23
    4f2e:	61 95       	neg	r22
    4f30:	7f 4f       	sbci	r23, 0xFF	; 255
    4f32:	8f 4f       	sbci	r24, 0xFF	; 255
    4f34:	9f 4f       	sbci	r25, 0xFF	; 255
    4f36:	08 95       	ret

00004f38 <__floatunsisf>:
    4f38:	e8 94       	clt
    4f3a:	09 c0       	rjmp	.+18     	; 0x4f4e <__floatsisf+0x12>

00004f3c <__floatsisf>:
    4f3c:	97 fb       	bst	r25, 7
    4f3e:	3e f4       	brtc	.+14     	; 0x4f4e <__floatsisf+0x12>
    4f40:	90 95       	com	r25
    4f42:	80 95       	com	r24
    4f44:	70 95       	com	r23
    4f46:	61 95       	neg	r22
    4f48:	7f 4f       	sbci	r23, 0xFF	; 255
    4f4a:	8f 4f       	sbci	r24, 0xFF	; 255
    4f4c:	9f 4f       	sbci	r25, 0xFF	; 255
    4f4e:	99 23       	and	r25, r25
    4f50:	a9 f0       	breq	.+42     	; 0x4f7c <__floatsisf+0x40>
    4f52:	f9 2f       	mov	r31, r25
    4f54:	96 e9       	ldi	r25, 0x96	; 150
    4f56:	bb 27       	eor	r27, r27
    4f58:	93 95       	inc	r25
    4f5a:	f6 95       	lsr	r31
    4f5c:	87 95       	ror	r24
    4f5e:	77 95       	ror	r23
    4f60:	67 95       	ror	r22
    4f62:	b7 95       	ror	r27
    4f64:	f1 11       	cpse	r31, r1
    4f66:	f8 cf       	rjmp	.-16     	; 0x4f58 <__floatsisf+0x1c>
    4f68:	fa f4       	brpl	.+62     	; 0x4fa8 <__floatsisf+0x6c>
    4f6a:	bb 0f       	add	r27, r27
    4f6c:	11 f4       	brne	.+4      	; 0x4f72 <__floatsisf+0x36>
    4f6e:	60 ff       	sbrs	r22, 0
    4f70:	1b c0       	rjmp	.+54     	; 0x4fa8 <__floatsisf+0x6c>
    4f72:	6f 5f       	subi	r22, 0xFF	; 255
    4f74:	7f 4f       	sbci	r23, 0xFF	; 255
    4f76:	8f 4f       	sbci	r24, 0xFF	; 255
    4f78:	9f 4f       	sbci	r25, 0xFF	; 255
    4f7a:	16 c0       	rjmp	.+44     	; 0x4fa8 <__floatsisf+0x6c>
    4f7c:	88 23       	and	r24, r24
    4f7e:	11 f0       	breq	.+4      	; 0x4f84 <__floatsisf+0x48>
    4f80:	96 e9       	ldi	r25, 0x96	; 150
    4f82:	11 c0       	rjmp	.+34     	; 0x4fa6 <__floatsisf+0x6a>
    4f84:	77 23       	and	r23, r23
    4f86:	21 f0       	breq	.+8      	; 0x4f90 <__floatsisf+0x54>
    4f88:	9e e8       	ldi	r25, 0x8E	; 142
    4f8a:	87 2f       	mov	r24, r23
    4f8c:	76 2f       	mov	r23, r22
    4f8e:	05 c0       	rjmp	.+10     	; 0x4f9a <__floatsisf+0x5e>
    4f90:	66 23       	and	r22, r22
    4f92:	71 f0       	breq	.+28     	; 0x4fb0 <__floatsisf+0x74>
    4f94:	96 e8       	ldi	r25, 0x86	; 134
    4f96:	86 2f       	mov	r24, r22
    4f98:	70 e0       	ldi	r23, 0x00	; 0
    4f9a:	60 e0       	ldi	r22, 0x00	; 0
    4f9c:	2a f0       	brmi	.+10     	; 0x4fa8 <__floatsisf+0x6c>
    4f9e:	9a 95       	dec	r25
    4fa0:	66 0f       	add	r22, r22
    4fa2:	77 1f       	adc	r23, r23
    4fa4:	88 1f       	adc	r24, r24
    4fa6:	da f7       	brpl	.-10     	; 0x4f9e <__floatsisf+0x62>
    4fa8:	88 0f       	add	r24, r24
    4faa:	96 95       	lsr	r25
    4fac:	87 95       	ror	r24
    4fae:	97 f9       	bld	r25, 7
    4fb0:	08 95       	ret

00004fb2 <__fp_cmp>:
    4fb2:	99 0f       	add	r25, r25
    4fb4:	00 08       	sbc	r0, r0
    4fb6:	55 0f       	add	r21, r21
    4fb8:	aa 0b       	sbc	r26, r26
    4fba:	e0 e8       	ldi	r30, 0x80	; 128
    4fbc:	fe ef       	ldi	r31, 0xFE	; 254
    4fbe:	16 16       	cp	r1, r22
    4fc0:	17 06       	cpc	r1, r23
    4fc2:	e8 07       	cpc	r30, r24
    4fc4:	f9 07       	cpc	r31, r25
    4fc6:	c0 f0       	brcs	.+48     	; 0x4ff8 <__fp_cmp+0x46>
    4fc8:	12 16       	cp	r1, r18
    4fca:	13 06       	cpc	r1, r19
    4fcc:	e4 07       	cpc	r30, r20
    4fce:	f5 07       	cpc	r31, r21
    4fd0:	98 f0       	brcs	.+38     	; 0x4ff8 <__fp_cmp+0x46>
    4fd2:	62 1b       	sub	r22, r18
    4fd4:	73 0b       	sbc	r23, r19
    4fd6:	84 0b       	sbc	r24, r20
    4fd8:	95 0b       	sbc	r25, r21
    4fda:	39 f4       	brne	.+14     	; 0x4fea <__fp_cmp+0x38>
    4fdc:	0a 26       	eor	r0, r26
    4fde:	61 f0       	breq	.+24     	; 0x4ff8 <__fp_cmp+0x46>
    4fe0:	23 2b       	or	r18, r19
    4fe2:	24 2b       	or	r18, r20
    4fe4:	25 2b       	or	r18, r21
    4fe6:	21 f4       	brne	.+8      	; 0x4ff0 <__fp_cmp+0x3e>
    4fe8:	08 95       	ret
    4fea:	0a 26       	eor	r0, r26
    4fec:	09 f4       	brne	.+2      	; 0x4ff0 <__fp_cmp+0x3e>
    4fee:	a1 40       	sbci	r26, 0x01	; 1
    4ff0:	a6 95       	lsr	r26
    4ff2:	8f ef       	ldi	r24, 0xFF	; 255
    4ff4:	81 1d       	adc	r24, r1
    4ff6:	81 1d       	adc	r24, r1
    4ff8:	08 95       	ret

00004ffa <__fp_inf>:
    4ffa:	97 f9       	bld	r25, 7
    4ffc:	9f 67       	ori	r25, 0x7F	; 127
    4ffe:	80 e8       	ldi	r24, 0x80	; 128
    5000:	70 e0       	ldi	r23, 0x00	; 0
    5002:	60 e0       	ldi	r22, 0x00	; 0
    5004:	08 95       	ret

00005006 <__fp_nan>:
    5006:	9f ef       	ldi	r25, 0xFF	; 255
    5008:	80 ec       	ldi	r24, 0xC0	; 192
    500a:	08 95       	ret

0000500c <__fp_pscA>:
    500c:	00 24       	eor	r0, r0
    500e:	0a 94       	dec	r0
    5010:	16 16       	cp	r1, r22
    5012:	17 06       	cpc	r1, r23
    5014:	18 06       	cpc	r1, r24
    5016:	09 06       	cpc	r0, r25
    5018:	08 95       	ret

0000501a <__fp_pscB>:
    501a:	00 24       	eor	r0, r0
    501c:	0a 94       	dec	r0
    501e:	12 16       	cp	r1, r18
    5020:	13 06       	cpc	r1, r19
    5022:	14 06       	cpc	r1, r20
    5024:	05 06       	cpc	r0, r21
    5026:	08 95       	ret

00005028 <__fp_round>:
    5028:	09 2e       	mov	r0, r25
    502a:	03 94       	inc	r0
    502c:	00 0c       	add	r0, r0
    502e:	11 f4       	brne	.+4      	; 0x5034 <__fp_round+0xc>
    5030:	88 23       	and	r24, r24
    5032:	52 f0       	brmi	.+20     	; 0x5048 <__fp_round+0x20>
    5034:	bb 0f       	add	r27, r27
    5036:	40 f4       	brcc	.+16     	; 0x5048 <__fp_round+0x20>
    5038:	bf 2b       	or	r27, r31
    503a:	11 f4       	brne	.+4      	; 0x5040 <__fp_round+0x18>
    503c:	60 ff       	sbrs	r22, 0
    503e:	04 c0       	rjmp	.+8      	; 0x5048 <__fp_round+0x20>
    5040:	6f 5f       	subi	r22, 0xFF	; 255
    5042:	7f 4f       	sbci	r23, 0xFF	; 255
    5044:	8f 4f       	sbci	r24, 0xFF	; 255
    5046:	9f 4f       	sbci	r25, 0xFF	; 255
    5048:	08 95       	ret

0000504a <__fp_split3>:
    504a:	57 fd       	sbrc	r21, 7
    504c:	90 58       	subi	r25, 0x80	; 128
    504e:	44 0f       	add	r20, r20
    5050:	55 1f       	adc	r21, r21
    5052:	59 f0       	breq	.+22     	; 0x506a <__fp_splitA+0x10>
    5054:	5f 3f       	cpi	r21, 0xFF	; 255
    5056:	71 f0       	breq	.+28     	; 0x5074 <__fp_splitA+0x1a>
    5058:	47 95       	ror	r20

0000505a <__fp_splitA>:
    505a:	88 0f       	add	r24, r24
    505c:	97 fb       	bst	r25, 7
    505e:	99 1f       	adc	r25, r25
    5060:	61 f0       	breq	.+24     	; 0x507a <__fp_splitA+0x20>
    5062:	9f 3f       	cpi	r25, 0xFF	; 255
    5064:	79 f0       	breq	.+30     	; 0x5084 <__fp_splitA+0x2a>
    5066:	87 95       	ror	r24
    5068:	08 95       	ret
    506a:	12 16       	cp	r1, r18
    506c:	13 06       	cpc	r1, r19
    506e:	14 06       	cpc	r1, r20
    5070:	55 1f       	adc	r21, r21
    5072:	f2 cf       	rjmp	.-28     	; 0x5058 <__fp_split3+0xe>
    5074:	46 95       	lsr	r20
    5076:	f1 df       	rcall	.-30     	; 0x505a <__fp_splitA>
    5078:	08 c0       	rjmp	.+16     	; 0x508a <__fp_splitA+0x30>
    507a:	16 16       	cp	r1, r22
    507c:	17 06       	cpc	r1, r23
    507e:	18 06       	cpc	r1, r24
    5080:	99 1f       	adc	r25, r25
    5082:	f1 cf       	rjmp	.-30     	; 0x5066 <__fp_splitA+0xc>
    5084:	86 95       	lsr	r24
    5086:	71 05       	cpc	r23, r1
    5088:	61 05       	cpc	r22, r1
    508a:	08 94       	sec
    508c:	08 95       	ret

0000508e <__fp_zero>:
    508e:	e8 94       	clt

00005090 <__fp_szero>:
    5090:	bb 27       	eor	r27, r27
    5092:	66 27       	eor	r22, r22
    5094:	77 27       	eor	r23, r23
    5096:	cb 01       	movw	r24, r22
    5098:	97 f9       	bld	r25, 7
    509a:	08 95       	ret

0000509c <__gesf2>:
    509c:	8a df       	rcall	.-236    	; 0x4fb2 <__fp_cmp>
    509e:	08 f4       	brcc	.+2      	; 0x50a2 <__gesf2+0x6>
    50a0:	8f ef       	ldi	r24, 0xFF	; 255
    50a2:	08 95       	ret

000050a4 <__mulsf3>:
    50a4:	0b d0       	rcall	.+22     	; 0x50bc <__mulsf3x>
    50a6:	c0 cf       	rjmp	.-128    	; 0x5028 <__fp_round>
    50a8:	b1 df       	rcall	.-158    	; 0x500c <__fp_pscA>
    50aa:	28 f0       	brcs	.+10     	; 0x50b6 <__mulsf3+0x12>
    50ac:	b6 df       	rcall	.-148    	; 0x501a <__fp_pscB>
    50ae:	18 f0       	brcs	.+6      	; 0x50b6 <__mulsf3+0x12>
    50b0:	95 23       	and	r25, r21
    50b2:	09 f0       	breq	.+2      	; 0x50b6 <__mulsf3+0x12>
    50b4:	a2 cf       	rjmp	.-188    	; 0x4ffa <__fp_inf>
    50b6:	a7 cf       	rjmp	.-178    	; 0x5006 <__fp_nan>
    50b8:	11 24       	eor	r1, r1
    50ba:	ea cf       	rjmp	.-44     	; 0x5090 <__fp_szero>

000050bc <__mulsf3x>:
    50bc:	c6 df       	rcall	.-116    	; 0x504a <__fp_split3>
    50be:	a0 f3       	brcs	.-24     	; 0x50a8 <__mulsf3+0x4>

000050c0 <__mulsf3_pse>:
    50c0:	95 9f       	mul	r25, r21
    50c2:	d1 f3       	breq	.-12     	; 0x50b8 <__mulsf3+0x14>
    50c4:	95 0f       	add	r25, r21
    50c6:	50 e0       	ldi	r21, 0x00	; 0
    50c8:	55 1f       	adc	r21, r21
    50ca:	62 9f       	mul	r22, r18
    50cc:	f0 01       	movw	r30, r0
    50ce:	72 9f       	mul	r23, r18
    50d0:	bb 27       	eor	r27, r27
    50d2:	f0 0d       	add	r31, r0
    50d4:	b1 1d       	adc	r27, r1
    50d6:	63 9f       	mul	r22, r19
    50d8:	aa 27       	eor	r26, r26
    50da:	f0 0d       	add	r31, r0
    50dc:	b1 1d       	adc	r27, r1
    50de:	aa 1f       	adc	r26, r26
    50e0:	64 9f       	mul	r22, r20
    50e2:	66 27       	eor	r22, r22
    50e4:	b0 0d       	add	r27, r0
    50e6:	a1 1d       	adc	r26, r1
    50e8:	66 1f       	adc	r22, r22
    50ea:	82 9f       	mul	r24, r18
    50ec:	22 27       	eor	r18, r18
    50ee:	b0 0d       	add	r27, r0
    50f0:	a1 1d       	adc	r26, r1
    50f2:	62 1f       	adc	r22, r18
    50f4:	73 9f       	mul	r23, r19
    50f6:	b0 0d       	add	r27, r0
    50f8:	a1 1d       	adc	r26, r1
    50fa:	62 1f       	adc	r22, r18
    50fc:	83 9f       	mul	r24, r19
    50fe:	a0 0d       	add	r26, r0
    5100:	61 1d       	adc	r22, r1
    5102:	22 1f       	adc	r18, r18
    5104:	74 9f       	mul	r23, r20
    5106:	33 27       	eor	r19, r19
    5108:	a0 0d       	add	r26, r0
    510a:	61 1d       	adc	r22, r1
    510c:	23 1f       	adc	r18, r19
    510e:	84 9f       	mul	r24, r20
    5110:	60 0d       	add	r22, r0
    5112:	21 1d       	adc	r18, r1
    5114:	82 2f       	mov	r24, r18
    5116:	76 2f       	mov	r23, r22
    5118:	6a 2f       	mov	r22, r26
    511a:	11 24       	eor	r1, r1
    511c:	9f 57       	subi	r25, 0x7F	; 127
    511e:	50 40       	sbci	r21, 0x00	; 0
    5120:	8a f0       	brmi	.+34     	; 0x5144 <__mulsf3_pse+0x84>
    5122:	e1 f0       	breq	.+56     	; 0x515c <__mulsf3_pse+0x9c>
    5124:	88 23       	and	r24, r24
    5126:	4a f0       	brmi	.+18     	; 0x513a <__mulsf3_pse+0x7a>
    5128:	ee 0f       	add	r30, r30
    512a:	ff 1f       	adc	r31, r31
    512c:	bb 1f       	adc	r27, r27
    512e:	66 1f       	adc	r22, r22
    5130:	77 1f       	adc	r23, r23
    5132:	88 1f       	adc	r24, r24
    5134:	91 50       	subi	r25, 0x01	; 1
    5136:	50 40       	sbci	r21, 0x00	; 0
    5138:	a9 f7       	brne	.-22     	; 0x5124 <__mulsf3_pse+0x64>
    513a:	9e 3f       	cpi	r25, 0xFE	; 254
    513c:	51 05       	cpc	r21, r1
    513e:	70 f0       	brcs	.+28     	; 0x515c <__mulsf3_pse+0x9c>
    5140:	5c cf       	rjmp	.-328    	; 0x4ffa <__fp_inf>
    5142:	a6 cf       	rjmp	.-180    	; 0x5090 <__fp_szero>
    5144:	5f 3f       	cpi	r21, 0xFF	; 255
    5146:	ec f3       	brlt	.-6      	; 0x5142 <__mulsf3_pse+0x82>
    5148:	98 3e       	cpi	r25, 0xE8	; 232
    514a:	dc f3       	brlt	.-10     	; 0x5142 <__mulsf3_pse+0x82>
    514c:	86 95       	lsr	r24
    514e:	77 95       	ror	r23
    5150:	67 95       	ror	r22
    5152:	b7 95       	ror	r27
    5154:	f7 95       	ror	r31
    5156:	e7 95       	ror	r30
    5158:	9f 5f       	subi	r25, 0xFF	; 255
    515a:	c1 f7       	brne	.-16     	; 0x514c <__mulsf3_pse+0x8c>
    515c:	fe 2b       	or	r31, r30
    515e:	88 0f       	add	r24, r24
    5160:	91 1d       	adc	r25, r1
    5162:	96 95       	lsr	r25
    5164:	87 95       	ror	r24
    5166:	97 f9       	bld	r25, 7
    5168:	08 95       	ret

0000516a <__udivmodhi4>:
    516a:	aa 1b       	sub	r26, r26
    516c:	bb 1b       	sub	r27, r27
    516e:	51 e1       	ldi	r21, 0x11	; 17
    5170:	07 c0       	rjmp	.+14     	; 0x5180 <__udivmodhi4_ep>

00005172 <__udivmodhi4_loop>:
    5172:	aa 1f       	adc	r26, r26
    5174:	bb 1f       	adc	r27, r27
    5176:	a6 17       	cp	r26, r22
    5178:	b7 07       	cpc	r27, r23
    517a:	10 f0       	brcs	.+4      	; 0x5180 <__udivmodhi4_ep>
    517c:	a6 1b       	sub	r26, r22
    517e:	b7 0b       	sbc	r27, r23

00005180 <__udivmodhi4_ep>:
    5180:	88 1f       	adc	r24, r24
    5182:	99 1f       	adc	r25, r25
    5184:	5a 95       	dec	r21
    5186:	a9 f7       	brne	.-22     	; 0x5172 <__udivmodhi4_loop>
    5188:	80 95       	com	r24
    518a:	90 95       	com	r25
    518c:	bc 01       	movw	r22, r24
    518e:	cd 01       	movw	r24, r26
    5190:	08 95       	ret

00005192 <__divmodhi4>:
    5192:	97 fb       	bst	r25, 7
    5194:	09 2e       	mov	r0, r25
    5196:	07 26       	eor	r0, r23
    5198:	0a d0       	rcall	.+20     	; 0x51ae <__divmodhi4_neg1>
    519a:	77 fd       	sbrc	r23, 7
    519c:	04 d0       	rcall	.+8      	; 0x51a6 <__divmodhi4_neg2>
    519e:	e5 df       	rcall	.-54     	; 0x516a <__udivmodhi4>
    51a0:	06 d0       	rcall	.+12     	; 0x51ae <__divmodhi4_neg1>
    51a2:	00 20       	and	r0, r0
    51a4:	1a f4       	brpl	.+6      	; 0x51ac <__divmodhi4_exit>

000051a6 <__divmodhi4_neg2>:
    51a6:	70 95       	com	r23
    51a8:	61 95       	neg	r22
    51aa:	7f 4f       	sbci	r23, 0xFF	; 255

000051ac <__divmodhi4_exit>:
    51ac:	08 95       	ret

000051ae <__divmodhi4_neg1>:
    51ae:	f6 f7       	brtc	.-4      	; 0x51ac <__divmodhi4_exit>
    51b0:	90 95       	com	r25
    51b2:	81 95       	neg	r24
    51b4:	9f 4f       	sbci	r25, 0xFF	; 255
    51b6:	08 95       	ret

000051b8 <__udivmodsi4>:
    51b8:	a1 e2       	ldi	r26, 0x21	; 33
    51ba:	1a 2e       	mov	r1, r26
    51bc:	aa 1b       	sub	r26, r26
    51be:	bb 1b       	sub	r27, r27
    51c0:	fd 01       	movw	r30, r26
    51c2:	0d c0       	rjmp	.+26     	; 0x51de <__udivmodsi4_ep>

000051c4 <__udivmodsi4_loop>:
    51c4:	aa 1f       	adc	r26, r26
    51c6:	bb 1f       	adc	r27, r27
    51c8:	ee 1f       	adc	r30, r30
    51ca:	ff 1f       	adc	r31, r31
    51cc:	a2 17       	cp	r26, r18
    51ce:	b3 07       	cpc	r27, r19
    51d0:	e4 07       	cpc	r30, r20
    51d2:	f5 07       	cpc	r31, r21
    51d4:	20 f0       	brcs	.+8      	; 0x51de <__udivmodsi4_ep>
    51d6:	a2 1b       	sub	r26, r18
    51d8:	b3 0b       	sbc	r27, r19
    51da:	e4 0b       	sbc	r30, r20
    51dc:	f5 0b       	sbc	r31, r21

000051de <__udivmodsi4_ep>:
    51de:	66 1f       	adc	r22, r22
    51e0:	77 1f       	adc	r23, r23
    51e2:	88 1f       	adc	r24, r24
    51e4:	99 1f       	adc	r25, r25
    51e6:	1a 94       	dec	r1
    51e8:	69 f7       	brne	.-38     	; 0x51c4 <__udivmodsi4_loop>
    51ea:	60 95       	com	r22
    51ec:	70 95       	com	r23
    51ee:	80 95       	com	r24
    51f0:	90 95       	com	r25
    51f2:	9b 01       	movw	r18, r22
    51f4:	ac 01       	movw	r20, r24
    51f6:	bd 01       	movw	r22, r26
    51f8:	cf 01       	movw	r24, r30
    51fa:	08 95       	ret

000051fc <__divmodsi4>:
    51fc:	97 fb       	bst	r25, 7
    51fe:	09 2e       	mov	r0, r25
    5200:	05 26       	eor	r0, r21
    5202:	0e d0       	rcall	.+28     	; 0x5220 <__divmodsi4_neg1>
    5204:	57 fd       	sbrc	r21, 7
    5206:	04 d0       	rcall	.+8      	; 0x5210 <__divmodsi4_neg2>
    5208:	d7 df       	rcall	.-82     	; 0x51b8 <__udivmodsi4>
    520a:	0a d0       	rcall	.+20     	; 0x5220 <__divmodsi4_neg1>
    520c:	00 1c       	adc	r0, r0
    520e:	38 f4       	brcc	.+14     	; 0x521e <__divmodsi4_exit>

00005210 <__divmodsi4_neg2>:
    5210:	50 95       	com	r21
    5212:	40 95       	com	r20
    5214:	30 95       	com	r19
    5216:	21 95       	neg	r18
    5218:	3f 4f       	sbci	r19, 0xFF	; 255
    521a:	4f 4f       	sbci	r20, 0xFF	; 255
    521c:	5f 4f       	sbci	r21, 0xFF	; 255

0000521e <__divmodsi4_exit>:
    521e:	08 95       	ret

00005220 <__divmodsi4_neg1>:
    5220:	f6 f7       	brtc	.-4      	; 0x521e <__divmodsi4_exit>
    5222:	90 95       	com	r25
    5224:	80 95       	com	r24
    5226:	70 95       	com	r23
    5228:	61 95       	neg	r22
    522a:	7f 4f       	sbci	r23, 0xFF	; 255
    522c:	8f 4f       	sbci	r24, 0xFF	; 255
    522e:	9f 4f       	sbci	r25, 0xFF	; 255
    5230:	08 95       	ret

00005232 <_exit>:
    5232:	f8 94       	cli

00005234 <__stop_program>:
    5234:	ff cf       	rjmp	.-2      	; 0x5234 <__stop_program>
